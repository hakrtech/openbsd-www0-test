<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
 <head>
  <meta http-equiv="Content-Type"
        content="text/html; charset=iso-2022-jp">
  <meta name="resource-type"
        content="document">
  <meta name="description"
        CONTENT="How to make an OpenBSD port">
  <meta name="keywords"
        content="openbsd,ports">
  <meta name="distribution"
        content="global">
  <meta name="copyright"
        content="This document copyright 1997-2002 by OpenBSD.">
  <title>OpenBSD の ports のビルド</title>
  <link rev="made" HREF="mailto:www@openbsd.org">
 </head>
 <body text="#000000" bgcolor="#FFFFFF" link="#23238E">
<a href="index.html"><img alt="[OpenBSD]" height="30" width="141" src="../images/smalltitle.gif" border="0"></a>

  <h2><font color="#e00000">OpenBSD の ports のビルド</font></h2>

   あなたはお好みのソフトウェアパッケージをあなたの OpenBSD マシン上で
   コンパイルしたので、その努力の結果を標準の ports として共有したく
   なりました。さて、それにはどうすれば良いのでしょう ?
  <p>
   そのとき、あなたがすべき最も重要なことは<strong>会話すること</strong>です。まず、
   <a href="mailto:ports@openbsd.org">ports@openbsd.org</a> で、人々に同じ ports について
   作業している人がいないかどうか聞いてみましょう。そして、あなたが見つけた問題点を含め、
   <em>元のソフトウェアの著作者にそのことを伝えましょう。</em> もし、ライセンス情報が
   正しくないように見えたなら、彼にそのことを伝えましょう。また、もし、ports のビルドの
   際にループを飛び越えなければならなかったなら、彼にどうすれば修正可能かを伝えましょう。
   さらに、もし、彼らが Linux 上でのみ開発していて、残りの Unix の世界を無視しているように
   見えたなら、彼らの見方を変えるように努力してみましょう。
  <p>
   <strong>会話することで</strong>、成功する ports と、皆からゆっくりと
   避けられていく ports との違いが出てくるのです。
  <p>
   まず、このページの移植のための情報に目を通してください。そして、
   参照ドキュメント、特に OpenBSD への移植に関する
   <a href="checklist.html">チェックリスト</a>もチェックしてください。
  <p>
   テストして、またテストして、そして最終テストをもう一度行ってください !
  <p>
   ports を投稿します。ports のディレクトリの gzip 圧縮をかけた tar ボールを
   作成します。そして、それを公開されている FTP または HTTP サーバに置いて、
   それを <a href="mailto:ports@openbsd.org">ports@openbsd.org</a> 宛に送るか、
   あるいは ports を MIME エンコードして上記のアドレスに送るかしてください。
   これらの方法から、あなたにとって最も都合のよい方を選んでください。

<h3><font color="#0000e0">移植ドキュメントの目次</font></h3>
<ul>
<li><a href="#Avail">利用可能な移植ドキュメント</a></li>
<li><a href="#Policy">OpenBSD の移植ポリシー</a></li>
<li><a href="#Security">セキュリティ上の推奨</a></li>
<li><a href="#Generic">一般的な移植のヒント</a></li>
<li><a href="#Other">その他の役に立つヒント</a></li>
</ul>

  <h3><font color="#0000e0"><a name="Avail">利用可能な移植ドキュメント</a></font></h3>
  <ul>
   <li>OpenBSD への移植に関する<a href="checklist.html">チェックリスト</a>。
   <li>マニュアルページ、
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5">bsd.port.mk(5)</a>。
       これは、それぞれの ports 用の makefile の最後に含まれている、ports
       のインフラストラクチャーとなる makefile についてのドキュメントです。
       このファイル自身の先頭に少しコメントがあるだけですが、
       ほとんどの役に立つ情報が
       ドキュメント化されています。
   <li>他の BSD の ports システムとの、いくつかの差異について。これはほとんど、
   <a href="../porting/ja/diffs.html">インフラストラクチャーの差異</a>のサマリです。
   <li><a href="../porting/ja/libraries.html">OpenBSD の ports による
   共有ライブラリの使用について</a>。このルールは、特に
   pkg_update が動く場合など、共有ライブラリを使う場合に、
   <strong>非常に重要</strong>なものです。
   <li><a href="audio-port.html">オーディオアプリケーションの OpenBSD への移植</a>。
   <li><a href="http://www.netbsd.org/Documentation/software/packages.html">
       NetBSD パッケージシステム</a>のドキュメンテーション。
       このドキュメントは、FreeBSD の ports システムの NetBSD 版についての
       ドキュメントで、実に役に立つものです。
   <li><a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/index.html">FreeBSD
       への移植者向けハンドブック</a>。
       これは FreeBSD への移植のバイブルです。
   <li>OpenBSD ports メーリングリスト
       <a href="mailto:ports@openbsd.org">ports@OpenBSD.ORG</a>。
  </ul>
  <h3><font color="#0000e0"><a name="Policy">OpenBSD の移植ポリシー</a></font></h3>
  <ul>
   <li>OpenBSD では <code>/usr/local/etc/rc.d</code> を使用<strong>しません</strong>。
       <code>/usr/local</code> は、しばしば NFS を利用していくつかの
         マシン間で共有されていることがあります。このため、そのマシン専用の
         設定ファイルは <code>/usr/local</code> の下に置くことができず、
         <code>/etc</code> がマシンごとの設定ファイルの集中的な置場となっています。
         さらには、OpenBSD のポリシーでは、<code>/etc</code> の下のファイルは
         決して自動更新されません。起動時に、ある特有の設定を要する ports は、
         暗黙のうちにファイルをインストールする代わりに、管理者に対して
         何をすべきかをアドバイスするようにすべきなのです。
   <li>OpenBSD は man ページを圧縮<strong>しません</strong>。
   <li>OpenBSD は <code>-lcrypt</code> を必要と<strong>しません</strong>。<br>
       DES による暗号化は標準的な <code>libc</code> の一部分となっています。
   <li>OpenBSD では、ports によって生成されるユーザおよびグループの名前空間を分けています。
       詳細は、<code>/usr/ports/infrastructure/db/user.list</code> を参照してください。
   <li>OpenBSD は、セキュリティに強く立脚しています。このページの
       <a href="#Security">セキュリティの章</a>を読んで理解しておいてください。
   <li>Makefile 中に <code>&#36;OpenBSD&#36;</code> CVS タグを入れるのを
       忘れないようにしてください。また、他のシステムの ports を持ってくる場合には、
       同様に Makefile 中のそのシステムのタグの除去も忘れないようにしてください。
       あるいは、FreeBSD <code>&#36;Id&#36;</code> タグを
       <code>&#36;FreeBSD&#36;</code> タグで置き換えるのでも構いません。
   <li>目標は、OpenBSD をサポートするすべての移植済アプリケーションを得ることです。
       この目標を達成するためには、アプリケーションのメンテナに OpenBSD 用のパッチを
       フィードバックする<strong>必要があります。</strong>
  </ul>
  <h3><font color="#0000e0"><a name="Security">セキュリティ上の推奨</a></font></h3>
  現在、心配すべきセキュリティ上の問題が多数あります。あなたがしようとしていること
       について、確実ではないことがあるのでしたら、
       <a href="mailto:ports@openbsd.org">ports</a> メイリングリストに
       ヘルプを求めてください。

  <ul>
   <li>ports を用意する場合に、アルファやベータバージョンのコードを使用<em>しない</em>で
       ください。最新の通常バージョンかパッチバージョンを使用するようにしてください。

   <li>サーバとしてインストールされるいかなるソフトウェアに対しても、
       バッファオーバーフロー、特に <code>strcat/strcpy/strcmp/sprintf</code>
       の安全ではない使用法についての検査を行うべきです。また、一般的に、
       <code>sprintf</code> は <code>snprintf</code> に置き換えるべきです。

   <li>本当のセキュリティの代わりのファイル名を決して使用してはいけません。正当に
       制御できない数多くの競合状態が発生します。たとえば、あなたのマシン上のユーザの
       権限を既に手に入れた攻撃者は、<code>/tmp</code> の下のファイルを、
       <code>/etc/master.passwd</code> のような、より重要なファイルへの
       シンボリックリンクに置き換えてしまうかも知れません。

   <li>たとえば、<code>fopen</code> および <code>freopen</code> のどちらも、書き込み時に
       <strong>新しいファイルを作成するか既存のファイルをオープンします</strong>。
       攻撃者は、<code>/etc/master.passwd</code> へのシンボリックリンクを
       <code>/tmp/addrpool_dump</code> として作成するかも知れません。これを簡単に
       オープンしてしまうと、パスワードファイルが破壊されることになってしまいます。
       ですので、その前に正しく <code>unlink</code> しておきます。これは、機会を
       小さくしておくことなのです。あるいは、その代わりに、<code>O_CREAT|O_EXCL</code>
       を指定した <code>open</code> や <code>fdopen</code> を使用してください。

   <li>もうひとつの非常に共通的な問題として、<code>mktemp</code> 関数があります。
       これの使用に関しての BSD のリンカの警告に注意してください。
       <strong>これは修正されなければならないものなのです</strong>。
       これは単純に、<code>s/mktemp/mkstemp/g</code> すれば良いものではありません。<br>
       より詳しい指示については、OpenBSD -current の man ページの
       <code>mktemp(3)</code> を参照してください。
       <code>mkstemp</code> を使用する正しいコードは、<code>ed</code> または
       <code>mail</code> へのソースを含みます。
       <code>mktemp</code> を正しく使用する数少ないコードの実例は、
       <code>rsync</code> の ports に見ることができます。

   <li>読めばわかると思いますが、あなたがそうすべきということを意味しません。この本質的に
       良く知られた穴が <code>startx</code> 問題でした。どのようなスクリプトでも setuid
       プログラムとして startx 経由で起動できてしまったのです。ファイルが正しいシェル
       スクリプトではないなら、問題のファイルの最初の行で、その後のいかなるパーミッション
       チェックも行われずに、シンタクスエラーメッセージが出ているかも知れません。
       しばしば root ユーザのエントリから始まるシャドウパスワードファイルの最初の行を
       掴むのは実に簡単なのです。いきなりファイルをオープンするのではなく、それをオープン
       可能かどうか (あるいは攻撃者が、/dev/rst0 で遊んでテープを巻き戻そうとしているのか
       どうか) を調べるため、オープンしたディスクリプタに対して <code>fstat</code> を
       実行して、それから正しい uid/gid/grouplist を使用してオープンしましょう。

   <li>特権を落とす前の setuid プログラムからは、いかなるシェルも
       フォークしてはいけません。これには、<code>popen</code> や
       <code>system</code> も含まれます。代わりに、<code>fork</code>、
       <code>pipe</code> や <code>execve</code> を使用するようにしましょう。

   <li>競合状態を避けるため、他のプログラムにはファイル名の代わりにオープンした
       ディスクリプタをわたすようにしましょう。プログラムがファイルディスクリプタを
       受け取ることができない場合でも、<code>/dev/fd/0</code> なら使用できるはずです。

   <li>ファイルディスクリプタに割り付けられた権限にアクセスします。ファイルをオープン
       するのに setuid の権限が必要なら、ファイルをオープンした後に特権を落とします。
       それでも、オープン済のディスクリプタに対してはアクセス可能ですので、心配には
       およびません。しかし、これは両刃の剣であり、特権を落とした後でも、これらの
       ディスクリプタに注意を払っておく必要があるのです。

   <li>できる限り、root の setuid は避けてください。基本的に root は何でもできますが、
       おそらく、1024 未満の番号のソケットポートを生成する場合を除けば、root 権限が
       必要となることは非常に稀なことなのです。そのようなことは、<code>inetd</code>
       の制御の下に置いておくのがおそらくより良い方法であり、これは単に
       <code>inetd.conf</code> に関連するエントリを追加するだけです。
       そのためには、デーモンを書くための適正な術を知っておく必要があります。
       もし、そのようにするための方法を御存知ないのであれば、setuid プログラムを
       書くのはあなたの仕事ではないと言えるかも知れません。

   <li>setuid の代わりに setgid を使用してください。setgid プログラムが必要とする特定の
       ファイルを除けば、ほとんどのファイルはグループ書き込み可能にはなっていません。
       ですので、setgid プログラムのセキュリティの問題は、あまりシステムの脅威には
       ならないはずです。ただし、グループの権限でも、最悪の場合には、侵入者はゲームの
       スコアテーブルをハックしたり、まぁその程度のことができる場合があります。
       そのような変更の実例としては、ports の <code>xkobo</code> を参照してください。

   <li>グループ書き込み可能なファイルを使用してはいけません。しかし、それらが
       監査されている限り、setgid プログラムが重要な潜在的セキュリティホールだとは
       認められていません。ですので、スタッフは、重要な情報だとは認められない情報を
       改変することもできるのです。

   <li>環境変数を信用してはいけません !  これは <code>PATH</code> のような単純なものでも
       関係のあることで (決して精査されてない名前で <code>system</code> を使用しては
       いけませんし、<code>execvp</code> の使用は避けましょう)、locale、timezone、
       termcap などのような微妙なものについても同様です。
       あなたがどれほど細心の注意を払ったとしても、プログラムを直接呼び出したりするのは
       不可避なことではありません。<strong>決して</strong>、特権を持つプログラム上で
       <code>system</code> を呼び出してはいけません。コマンドラインを作成し、制御可能な
       環境変数を用意した上で、直接 <code>execve</code> を呼び出します。
       <code>perlsec</code> の man ページは、このような問題に対する良い手引書です。

   <li>setuid されたシェルスクリプトは決して使用してはいけません。このようなものは本質的
       に安全ではありません。それらは正当な環境変数を保証するための C コードでラップして
       使用しましょう。これに対して、OpenBSD には安全な Perl スクリプトがあります。

   <li>ダイナミックローダにも注意が必要です。setuid プログラムを実行しているなら、
       ldconfig がスキャンした信用できるライブラリのみを使用するものでしょう。
       しかし、setgid は十分ではありません。

   <li>ダイナミックライブラリはトリッキーです。C++ のコードにも同様の問題があります。
       基本的に、メインプログラムがその setuid ステータスをチェックできるようになる前に、
       ライブラリは環境変数に基づいてある種の動きをするかも知れません。
       OpenBSD の <code>issetugid</code> は、ライブラリを書く側の観点から、この問題を
       解決してくれます。この問題を完全に理解できるまでは、ports のライブラリを
       試そうとしない方が良いでしょう。
  </ul>
  <h3><font color="#0000e0"><a name="Generic">一般的な移植のヒント</a></font></h3>
  <ul>
   <li>できれば、<code>__OpenBSD__</code> は慎重に使用されるべきです。
       次のような構文、
       <pre>
            #if defined(__NetBSD__) || defined(__FreeBSD__)
       </pre>
       は、しばしば適切ではありません。ですので、何も考えずに <code>__OpenBSD__</code>
       を追加してはいけません。その代わりに、それが何をしようとしているのか、実際に何が
       必要なのかの理解に努めてください。マニュアルページは、特殊な機能がいつ BSD に組み
       込まれたかなどの記述や歴史的なコメントを含んでいたりして、あるときにはそれが
       便利だったりします。知られているリリース番号ではなく、<code>BSD</code> の数値を
       調べることもしばしば正しいことでしょう。より詳しい情報は、
       <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/Packages.txt">NetBSD パッケージガイド</a>
       を参照してください。
   <li><code>BSD</code> を定義するのは良い考えではありません。<code>sys/param.h</code>
       をインクルードしてみてください。そこには <code>BSD</code> が定義されているだけ
       ではなく、適正な値も与えられています。正しいコードの一部を以下に示します。
       <pre>
           #if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
           #include &lt;sys/param.h&gt;
           #endif
       </pre>
   <li>特定の OS のためではなく、機能のためにテストしてください。長時間実行することで、
       BSD 4.3 以降や SystemV R4 で実行するより、非常に良い状態で <code>tcgetattr</code>
       が実行できるかどうかテストすることができます。この種のテストは、単に問題を複雑化
       することがあります。これをうまく行うためには、たとえば、ひとつの特定のシステムの
       ためのテストを行うため、多数の <code>HAVE_TCGETATTR</code> の定義を行い、そして
       次のシステムのテストに進みます。
       この技法は特定の OS から機能テストを分離することができるものです。
       そして容易に別の移植者が <code>-DHAVE_XXX</code> の全セットを Makefile 中に
       加えることもできるようになります。また、ある人は、configure スクリプトに
       その機能をチェックし、そして自動的にその機能を追加するためのスクリプトを
       を追加したり書き起こしたりすることもできるのです。別の例として nethack 3.2.2 の
       ソースをチェックしてみてください。システムのタイプに基づいて、ロードするものを
       仮定するようになっています。そして、このような仮定のほとんどは既に使用されない
       ものであり、もはや実態を反映していませんが、これは、伝統的な BSD 関数が
       今や互換ライブラリを通してサポートされるだけと言えるくらい、 POSIX 関数は
       昔の BSD と SystemV との違い以上に、より役に立つものだからなのです。

   <li>他のインクルードファイルをインクルードするインクルードファイルをインクルードする...
       というのは避けてください。まず、これは非効率的ですし、やがてこのプロジェクトは、
       何もかもインクルードするファイルをインクルードするようになってしまうでしょう。また、
       解決が困難な問題を起こしたり、ある場所で特定のファイルをインクルード<em>しない</em>
       ようにするのが困難になってしまったりします。

   <li>マクロを使用した奇抜なトリックは避けてください。ヘッダファイルで定義されたマクロを
       未定義にするのは良い考えではありません。また、コンパイルモードはグローバルである
       べきなので、インクルードファイルからのいくつかの特定の挙動を以ってマクロを定義する
       ことも良い考えではないのです。もし、POSIX の挙動にしたい場合には、そのように宣言し、
       そのようにしたいと思った時にではなく、
       <code>#define POSIX_C_SOURCE</code> をプロジェクト全体を通して定義してください。

   <li>システム関数のプロトタイプ宣言は絶体に書かないでください。OpenBSD を含む、現代的な
       すべてのシステムでは、このようなプロトタイプ宣言を標準的な場所に持っているからです。
       これらはたとえば、<code>unistd.h</code>、<code>fcntl.h</code> や
       <code>termios.h</code> を含む場所のことです。
       man ページには、このようなプロトタイプ宣言がどこにあるのか繰り返し書かれています。
       また、これとは別に、正しいファイルを得るための <code>HAVE_XXX</code> マクロが大量に
       必要になるかも知れません。インクルードファイルは、すべての種類の厄介なことを防止する
       仕組みを持っていますので、同じファイルを二度インクルードしても心配はありません。<br>
       ある種の壊れたシステム用に、プロトタイプ宣言を書かなければならないかも知れませんが、それを
       他のシステムすべてに見せないでください。手作りのプロトタイプ宣言は (<code>size_t</code> の
       代わりの <code>unsigned long</code> のように)、あなたのシステム上では等価な型を使用している
       かも知れませんが、他のシステムには移植できないかも知れませんし、いくつかの <code>const</code>
       のステータスが間違っているかも知れなど、いずれ破綻することになるでしょう。
       また、OpenBSD に附属する gcc のような、ある種のコンパイラも同様で、正しいヘッダ
       ファイルが使用されていれば、<code>strlen</code> のような、いくつかの非常に頻繁に
       使用される関数で、より良い性能を発揮したりします。

   <li>標準システム関数の名前を他のどのようなものにも使用してはいけません。
       独自の関数が必要なら、独自の名前を使用して、それを各所で呼び出すように
       しましょう。そうしておけば、デフォルトのシステム関数に戻したくなった場合には、
       独自関数のコードをコメントアウトした上で、その独自の名前をシステム関数に
       #define で定義し直すことが必要になるだけです。これを別の方法で行わないで
       ください。このコードの例は、以下のようなものになるでしょう。
<pre>
       /* prototype part */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf);
       #else
       /* include correct file */
       #include &lt;stdlib.h&gt;
       /* use system function */
       #define foo_gcvt  gcvt
       #endif

       /* definition part */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf)
          {
          /* proper definition */
          }

       /* typical use */
       s = foo_gcvt(n, 15, b);
       </pre>
  </ul>
  <h3><font color="#0000e0"><a name="Other">その他の役に立つヒント</a></font></h3>
  <ul>
   <li>最近のバージョンの <code>bsd.port.mk</code> をインストーラのパスに
       セットします。特に、<code>/usr/bin</code> と <code>/bin</code> は、
       <code>/usr/local/bin</code> や <code>/usr/X11R6/bin</code> よりも
       <em>先に</em>検索されるよう、パスはセットされています。
   <li><code>${NO_SHARED_LIBS}</code> が定義されている場合には、共有ライブラリを
       生成<em>しないで</em>ください (これは <code>bsd.port.mk</code> のインクルード後
       にのみ定義可能であることに注意してください)。GNU configure を持つポートの場合は、
       単に Makefile に
       <code>CONFIGURE_ARGS += ${CONFIGURE_SHARED}</code> という行を追加するだけです。
   <li>ユーザの人々が <code>bsd.port.mk</code> を含む、ports ツリー全体を
       更新しようと考えることになるので、<code>bsd.port.mk</code> の最近の
       バージョンに存在する機能に依存しても構いません。
       NEED_VERSION は現在は使用されなくなりました。
   <li>OpenBSD では、<code>curses.h/libcurses/libtermlib</code> は
       ``new curses'' ですので、以下のように変更してください。<br>
       <code>ncurses.h ==&gt; curses.h</code><br>
       <code>curses.h</code> をインクルードする前に、(通常は Makefile 中で)
       <code>_USE_OLD_CURSES_</code>
       を定義し、<code>-locurses</code> としてリンクを行うことによって、
       ``old (BSD) curses'' を利用することもできます。
   <li>OpenBSD では、ターミナルディシプリンは、古い目の BSD <code>sgtty</code> から、
       より新しい POSIX の <code>tcgetattr</code> ファミリにアップグレードされています。
       新しいコードでは、古いスタイルを回避してください。いくつかのコードでは、
       古い <code>sgtty</code> の同義語として <code>tcgetattr</code> を定義している
       かも知れませんが、これは OpenBSD では、せいぜい間に合わせの手段でしかありません。
       <code>xterm</code> のソースコードは、何をしてはいけないかということの、非常に良い
       例になります。システムの機能性を正しく取得することを考えてみましょう。
       たとえば、ターミナルの状態を記憶しておくための型が必要になるかも知れませんし
       (typedef で可能)、現在の状態を取得するための関数や、新しい状態を設定するための
       関数が必要になるかも知れません。
       この状態を設定するための関数は、ターミナルがシステムの状態に応じて
       変化しようとしますので、より難しいものです。また、接続していない
       ターミナルを扱わなくてはならない場合や、終了だけではなくバックグラウンドの
       シグナル (<code>SIGTSTP</code>) も扱わなくてはならないことがあるかも知れない
       ということも忘れないでください。
       あなたは常にターミナルを健全な状態にしておくべきです。sh のように、
       プログラムが終了しても決してターミナルを初期化しないような、
       古い目のシェルの下でもテストを行ってください。
   <li>OpenBSD に含まれている、より新しい termcap/terminfo および curses は、
       カラーターミナルを制御するための標準的なシーケンスを含んでいます。
       可能ならこれらを使用すべきであり、他のシステムでは標準の ANSI カラー
       シーケンスに戻してください。しかし、いくつかのターミナルの記述は、まだ
       更新されていませんので、これらのシーケンスを手動で指定する必要がある
       かも知れません。これは vim に実装されている方法でもあります。これは、
       厳密には必要なことではありません。特権を持つプログラムを除いて、一般的には
       <code>TERMCAP</code> 環境変数を通して termcap の定義をオーバーライドすることが
       可能であり、それによって正しい動きをさせることが可能になります。
   <li>シグナルのセマンティクスはトリッキーなところがあり、あるシステムから別のものになると
       変化してしまいます。特定のセマンティクスを確実なものにするためには、関連する man ページで
       参照される他のシステムコールとともに、<code>sigaction</code> を使用してください。
  </ul>
  <hr>
  <a href="index.html"><img height="24" width="24" src="../back.gif" border="0" alt="OpenBSD"></a> 
  <a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: porting.html,v 1.46 ]
<br>
$Translation: porting.html,v 1.6 2003/10/01 03:15:33 toshi Exp $
<br>
$OpenBSD: porting.html,v 1.6 2003/10/02 12:03:09 horacio Exp $
</small>
</body>
</html>
