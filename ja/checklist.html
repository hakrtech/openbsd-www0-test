<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
<meta name="resource-type" content="document">
<meta name="description" CONTENT="How to make/update an OpenBSD port.">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1998-2002 by OpenBSD.">

<title>OpenBSD Porting チェックリスト</title>
</head>
 
<body text=Black bgcolor=White link="#23238E">
<a href="index.html"><img alt="[OpenBSD]" height="30" width="141" src="../images/smalltitle.gif" border="0"></a>

<h2><font color="#e00000">OpenBSD Porting チェックリスト</font></h2>

このドキュメントには、ports を make したりアップグレードする方法が書かれています。
これを作業項目の覚え書きとして使うと便利です。しかし、完璧に正確というわけでもないし、
抜けがないとも限りません。質問や意見がありましたら <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>
へお願いします (訳注: おそらく、英語で書かないと読めないと思います)。

<hr>
<ol>

<li> 
もしメンテナ (訳注: maintainer = ports の管理者) になりたいと思ったら
<a href="mailto:ports@openbsd.org"> ports@openbsd.org</a> を講読しましょう。
<ul><li> 
あらゆる ports に関する議論がここで行われています。
<li>
このメーリングリストで多くのアナウンスがされるので、このメーリングリストを読むことは重要です。
<li>
また、このメーリングリストには ports に詳しい人々がたくさん参加しています。
その人たちはアドバイスをくれたり ports のテストをしてくれたりします。
</ul>

<br><li>
メンテナになるということは、単に ports を投稿するよりも<strong>多く</strong>のことを求められます。
担当する ports をいつも最新に保つことはもちろん、それらについての質問にも
答えるようにしなければなりません。

<br><br><li>
ports ツリーを CVS からチェックアウトします。
この方法の説明は
<a href="http://www.openbsd.org/anoncvs.html">
http://www.openbsd.org/anoncvs.html</a>にあります。

<br><br><li> 
あなたの ports の置く場所を(訳注: ports ツリー全体の中のどこかに) 決め、
そこに基本的な構造を作ります。
<code>/usr/ports/infrastructure/templates/Makefile.template</code>
にある Makefile のテンプレートを使用しましょう。NEED_VERSION は古いマクロですので、
新しい ports で使用すべきではありません。あなたが ports の開発者ならば、bsd.port.mk
も含めて自分の ports ツリーをアップデートしていなければなりません。
<ul><li>
<code>patches、pkg</code> ディレクトリを作りましょう。
<li>
空のファイル <code>pkg/DESCR、pkg/PLIST</code> を作りましょう。
</ul>

<br><li> 
Makefile の fetch 部を書き加えます。
<ul><li>
.tar.gz ではない場合には EXTRACT_SUFX に書きます。.tar.gz 以外の例としては
.tar.Z や .tgz などが挙げられます。
<li>
DISTNAME には、ファイル名から上に述べた拡張子を除いたものを書きます。
たとえばファイル名が foo-1.0.tar.gz であったならば DISTNAME は foo-1.0 にします。
<li>
MASTER_SITES には distfile (訳注: ソフトウェアの作者が配布しているファイルのこと。
上の例で言えば foo-1.0.tar.gz というファイルがそれに該当する) があるディレクトリの URL を書きます。
たとえば ftp://ftp.openbsd.org/pub/OpenBSD/distfiles/ というようにします。<strong>最後に / (スラッシュ記号)
を付けるのを忘れないようにしましょう。</strong> できるならば最低 3 つの異なるサイトを同じように書きましょう。
URL は書いた順番に試されますので、一番容易に行けるサイトを最初に書きましょう。
<li>
fetch プログラムは ${MASTER_SITES}${DISTNAME}${EXTRACT_SUFX} というファイルを取りに行こうとすることを
忘れないようにしてください。これらの 3 つのマクロがすべて使用されます。
DISTNAME にファイルを直接指定してはいけません。
<li>
これら 3 つの値が正しく設定できたかどうかは
<b>make fetch-all</b> とコマンドを叩いてチェックすることができます。
</ul>
<p>
もっと複雑な ports には、さらに他のオプションやツールを使うこともできます。
<ul><li>
PATCHFILES という変数を使用することもできます。これは ports に対する (OpenBSD 以外の)
ベンダのパッチのリストです。よくある使い方としては、セキュリティパッチや
安定化パッチなどのようなものがあります。
<li>
もしあなたの ports が GNU や SunSite、CPAN といった大きなミラーサイトから取得できるものである場合には、
/usr/ports/infrastructure/templates/network.conf.template
の中にサイトのリストがすでに用意されています。
MASTER_SITES を ${MASTER_SITE_GNU} や ${MASTER_SITE_SUNSITE} などに設定してください。
配布物のサブディレクトリの名前を追加する場合には、
${MASTER_SITE_FOO:=subdir/} という書式を使用すると簡単です。
<li>
通常、ports はソフトウェアのある特定のバージョンと対応しています。ソフトウェアを取ってきたときには、そのファイルのチェックサムが計算され、distinfo に書かれているチェックサムと比較されます。
よって、混乱を避けるために、DISTFILESとPATCHFILES にははっきりと分かるバージョン番号が含まれているべきです。
foo-latest.tar.gz というものがあって、これが foo-1.0.5.tar.gz にリンクされていたとしても、foo-latest.tar.gz を取得してはいけません。
もしどうしても必要ならば、元のプログラムの作者にそれらの区別をはっきりさせるようにお願いしましょう。
<li>
もし、ある ports が 5 個以上の DISTFILES や PATCHFILES を必要とするならば、
/usr/ports/distfiles を必要以上に散らかさないためにも DIST_SUBDIRを使ってください。
<li>
DIST_SUBDIR にはバージョン番号を含めてはいけません。ports が最新版に更新されても、いくつかの配布ファイルは変化がないかも知れません。しかし DIST_SUBDIR が変更されていると、すべてダウンロードしなおしてしまいます。
たとえすべての配布ファイルが変更になっていたとしても、同じ DIST_SUBDIR を使う方がユーザが port を追いかけるのに便利です。
<li>
すべての DISTFILES と PATCHFILES が同じ MASTER_SITES の組み合わせから取得可能である必要はありません。
MASTER_SITES0 から MASTER_SITES9 までの変数を使用してその他のサイトを定義することができます。
foo-1.0.5.tar.gz を MASTER_SITES5 から取得するためには、単に DISTFILES=foo-1.0.5.tar.gz:5 と書くだけです。
<li>
ある環境においてはいくつかのファイルを取得する必要がない ports もあるかもしれません。例えばいくつかのコンパイル時オプションがある ports で、ある特定の場合のみあるファイルが必要となることもあるでしょう。
また、あるアーキテクチャでのみ必要なファイルがある場合もあります。このような場合には SUPDISTFILES 変数を使用してこれらのファイルについての情報を書くことができます。
makesum や mirror-distfiles といった (訳注: make の) target は、
普通のユーザが必要としないこれら補足のファイルについても取得します。
</ul>

<br><li>
<b>make makesum</b> を実行して <i>distinfo</i> ファイルの中にチェックサムを作成します。
その後、チェックサムが正しいかどうか確かめるために、<b>make checksum</b> を実行しましょう。
<ul><li>
ごくまれにファイルのチェックサムが確実に確かめることができない場合があります。そのような場合には、ぜひ、信頼できるサイトを見付ける努力をすべきです。
ソフトウェアの作者やアーカイブサイトの管理者とこの段階で連絡を取るのは、大変に好ましいことです。最悪の場合には、IGNOREFILES 変数を使用して、
チェックサムの確認できないファイルを指定することができます。
<li>
通常、DISTFILES に書かれたファイルはすべて make extract 中に処理されます。
EXTRACT_ONLY を使用して一部のファイルの展開を制限することもできます (空にすることもできます) (訳注: EXTRACT_ONLY に指定されたものだけが展開されます。特に記述しなかった場合には DISTFILES に指定されたもの全てが展開されます)。
この変数のよくある使われ方としては、展開方法のカスタマイズが挙げられます。
たとえば、いくつかの DISTFILES がある特別な扱いを必要とするならば、それらを EXTRACT_ONLY から取り除き、post-extract ステージにおいて手で取り扱うことができます。
歴史的理由により、作業ディレクトリは make extract によってファイルの展開と共に初めて作成されます。従って、pre-extract や do-extract ターゲットを使用するのはとても特殊な場合に限られます
(そして、それはかなり怪しい動作をして、とてつもなく分かりにくくなるでしょう)。
<li>
歴史的理由により、特別な扱いを必要とするパッチは DISTFILES に書き EXTRACT_ONLY から取り除くのが推奨される方法です。
</ul>

<br><li>
<b>make extract</b> として ports を展開します。ソースの展開されるディレクトリ
に注意してください。通常、<i>w-${PKGNAME}${FLAVOR_EXT}/${DISTNAME}</i> と
なります。これが異なる場合には、Makefile の WRKDIST を変更する必要があります。

<br><br><li>
portをビルドするためにしなければいけないことと、そのとき必要となるかも知れない
特別な選択肢について注意しながら、インストールドキュメントを読みましょう。

<br><br><li>
このときが、どのような種類のライセンスの制限が当てはまるかを調べるのにちょうど良いタイミングです。
多くは自由に再配布可能ですが、一方では少なからずそうではないものが存在します。ports
を配布するためには、次の 4 つの項目について正確に答える必要があります。
これらは Makefile の中の PERMIT_* の値として設定します。
<ul><li>
PERMIT_PACKAGE_CDROMはパッケージをCDROMに収録しても良いことを示します。
<li>
PERMIT_PACKAGE_FTPはパッケージをFTPサイトに置いても良いことを示します。
<li>
PERMIT_DISTFILES_CDROMはdistfileをCDROMに収録しても良いことを示します。
<li>
PERMIT_DISTFILES_FTPはdistfileをFTPサイトに置いても良いことを示します。
</ul>
<p>
該当の項目が許可されている場合にはその値を Yes に設定し、そうでない場合にはその理由の文字列を設定します。
後ほど満さなければならない特別な条件がある場合には十分注意してください。たとえば、ある ports
はライセンスのコピーをインストールすることを求めています。このような場合には、
<code>/usr/local/share/DISTNAME/</code> にそのライセンスを置くことをお薦めします。

<br><br><li>
コンフィギュレーションオプションを Makefile に追加し、必要があれば、コンフィギュレーションスクリプトを作成します。
<ul><li>
<code>scripts/</code> という名前のディレクトリの中に `configure' という名前の ports
コンフィギュレーションスクリプトを置くこともできます。このスクリプトは、 CONFIGURE_STYLE
によって指定されたどのコンフィギュレーションが実行されるよりも前に実行されます。
<li>
GNU configure が使用されている場合には、./configure --help を実行することによって
指定できるオプションを見ることができます。
<li>
上書きしたいものはどれでも、Makefile の CONFIGURE_ARGS パラメータに --option
フラグを追加することによって変更することができます。
<li>
変数に追加する場合には CONFIGURE_ARGS+= を使いましょう。
CONFIGURE_ARGS= とすると上書きされてしまいます。
</ul>

<br><li>
<b>make build</b> として ports をビルドしてみましょう。
<ul><li>
エラーなく最後まで行けばラッキーです。
<li>
何らかのエラーで終了してしまった場合にはパッチを作る必要があります。
どんな変更が必要であるかを調べパッチを作ってください。
<li>
パッチは ${WRKDIST} からの相対パスになるように作らなければなりません。
<li> ports をリセットしてパッチのテストをする一番簡単な方法は
<b>make clean patch</b> とすることです。こうすると作業ディレクトリを消し、
展開しなおして ports にパッチを適用します。
</ul>

<br><li>
さあ、何回でも <b>make build</b> してからパッチを作り
(もしくは <b>make update-patches</b> を実行し)、
<b>make clean patch</b> することを繰り返しましょう。
<ul><li>
パッチは <i>patches/</i> ディレクトリに置きます。また、その名前は patch-* とし、
* の部分は何か意味のある名前にするべきです。パッチが適用されるファイルの名前を
FILENAME だったとすると、パッチの名前は patch-FILENAME とすることをお薦めします
(<tt>make update-patches</tt> は自動的にこのようにします)。
<li>
PATCHFILES に指定されたパッチを適用するのは make patch ステージの前半です。この部分の処理は
make distpatch として分離して実行することもできます。これは ports の開発者にとって便利な
make のターゲットです。PATCHFILES を設定していない場合には、このターゲットは無視されます。
<li>
ひとつのパッチのファイルは、ひとつのソースファイルにだけパッチを適用するようにしてください。
<li>
パッチを作るには、<b>make update-patches</b> を使用しましょう。
<li>
すべてのパッチは ${WRKDIST} からの相対パスで作られる必要があります。
<li>
パッチが CVS によって書換えられてしまうタグを含んで<strong>いない</strong>ことを確認してください。
もし含んでいる場合には、チェックインした後にパッチが当たらなくなってしまいます。これを避けるために
-kk を付けてチェックインすることもできます。
<li>
そのパッチの役割についての短い説明文と OpenBSDのCVS tag <code>&#36;OpenBSD&#36;</code>
をパッチファイルのパッチ自身の前に付けてください。
<li>
ソフトウェアの作者にもパッチを送るように<b>お願いします。</b>
</ul>

<br><li>
<code>SEPARATE_BUILD</code> を設定するように試してみてください。
<ul><li>
ports がソースツリーとは別の場所でオブジェクトファイルをビルドできるようになっているならば、
これはよりきれいな方法で (<code>CONFIGURE_STYLE=gnu</code> となっている多くのプログラムではできるはずです)
ports ツリーをいくつかのアーキテクチャ上でマウントしている人達にとってはとても助かります。
<li>
これをするためには、ほとんどの時間を <code>configure</code>
を繰り返し実行しなおすような作業をしなければいけないかも知れません。
</ul>

<br><li>
(もしあれば) 出力をよく読んで Makefile の中のオプションをいじりましょう。
コマンドを繰り返して実行するには、`<b>make clean configure</b>' とします。
<p>
注意: ホスト依存のファイル (訳注: = ホスト毎に異なる内容を設定するべきファイル)
は <i>/etc</i> か <i>/etc/&lt;name&gt;</i> に置かれるように確認してください。
しかし、もともと <i>/etc</i> に存在しているファイルを<strong>置き換えたり変更したりしてはいけません。</strong>
一番良い方法は、<i>/usr/local/share/&lt;name&gt;</i> にインストールして、
それから <i>/etc</i> または <i>/etc/&lt;name&gt;</i> にファイルが存在しないときに限ってそこにコピーすることです。
もしすでにファイルが存在していたならば、「これこれのファイルを
修正する必要があります」というメッセージを表示してください。
<i>/usr/local</i> の下のファイルはすべて PLIST に含まれているので、
この方法を使用すればそれらのファイルが確実にパッケージに含まれるようになります。
パッケージのインストールインストール終了後には、<code>pkg/MESSAGE</code> が存在していれば表示されます。

<p>
OpenBSDにおけるファイルの置き場所は以下の通りです。
<pre>
   ユーザ用実行ファイル:		/usr/local/bin
   システム管理者用実行ファイル:	/usr/local/sbin
   プログラム用実行ファイル:		/usr/local/libexec
   ライブラリ				/usr/local/lib
   アーキテクチャ依存データ		/usr/local/lib/&lt;name&gt;
   インストールされるincludeファイル:	/usr/local/include or
					/usr/local/include/&lt;name&gt;
   マシン毎のデータ:			/etc or /etc/&lt;name&gt;
   ローカルの状態ファイル:		/var/run
   ゲームの点数記録ファイル:		/var/games
   GNU info のファイル:			/usr/local/info
   マニュアル (man pages):		/usr/local/man/...
   アーキテクチャ非依存のread-onlyファイル:	/usr/local/share/&lt;name&gt;
   その他のドキュメント:		/usr/local/share/doc/&lt;name&gt;
</pre>

<li>
問題がなくなるまで何回でも make し直してください。ports が作成されるまでパッチを当て、
clean し、make します。警告 (warning) メッセージがひとつも出ないようにしましょう。
特にセキュリティ関連の警告は注意してください。

<br><br><li>
SEPARATE_BUILD の動作を調整します。
SEPARATE_BUILD を定義して ports がビルドされている場合にはこの調整が必要です。
理想としては、${WRKSRC} 内のファイルは、<b>make patch</b> 後は
一切変更されないようにするべきです。
${WRKSRC} 以下に対する書き込み権限を持たない状態にすると
これをチェックすることができます。
これができれば <code>SEPARATE_BUILD=concurrent</code> を
設定することができます。つまり、同じソースツリーを使用して
異なるアーキテクチャ上で同時にビルドを実行できるようになるのです。
そうでない場合には、<code>SEPARATE_BUILD=simple</code> と設定してください。
これは、まずいタイミングでソースファイルが生成し直されるかもしれないために
異なるアーキテクチャ上での同時ビルドは問題が発生する可能性があることを示します。

<br><br><li>
Makefile に <i>COMMENT</i> を加えてください。
COMMENT はその ports についての<strong>短い</strong> 1 行の説明文です
(最大 60 文字)。COMMENT 中にパッケージ名
 (やソフトウェアのバージョン番号)
を入れては<strong>いけません。</strong>
特に意味的に重要な場合を除いて大文字で始めては<strong>いけません。</strong>
最後にピリオドを書いても<strong>いけません。</strong>
<strong>`a' や `as' を使用したあいまいな意味の文を書いてはいけません。
そのような場合、文が完全に削除されてしまいます。</strong>

<br><br><li>
<i>pkg/DESCR</i> と <i>pkg/PLIST</i> とを編集してください。
<ul><li>
DESCR は ports の長い説明文です。
1 段落〜数段落でその ports にできることを簡潔に説明してください。
1 行 72 文字で改行するようにすることも注意してください。
DESCR をエディタで編集してから 'fmt -w 72' を通せばそのようになります。
<li>
PLIST はこの時点では空にしておいてください。
</ul>

<br><li>
<b>make install</b> としてアプリケーションをインストールしてください。
ダイナミックライブラリをインストールする場合には nm を使用して、そのシンボルテーブルをチェックしてください。
ダイナミックライブラリを strip してしまうソフトウェアがあるため、後に変な失敗が発生することがあります。
他方、実行バイナリは strip されているべきです。これは <code>file</code> コマンドを使用して調べることができます。
ports がバイナリを strip するコードをもともと含んでいる場合にはそれを使いましょう
(たとえば、'install-strip' ターゲットのようなものです)。
そうでない場合には、portのMakefileにそのルールを追加してください。

<br><br><li>
<strong>ports のセキュリティホールをもう一度チェックしてください。</strong>
特にネットワークに関係する setuid プログラムの場合は重要です。
これに関しては、<a href="porting.html#security">OpenBSD のセキュリティ勧告</a>
を参照してください。気になるものや修正点は <code>pkg/SECURITY</code> ファイルに記録しましょう。
このファイルには、監査によって発見され修正された潜在的な問題点を、
関連したパッチと共に並べておくようにします。そうすることによって、
すでに修正されている問題点を他の人が一目で見ることができます。
以下に例を示します。
<pre> 
      &#36;OpenBSD&#36;

      ${WRKDIR}/receiver.c
         call to mktemp (wrapper function do_mktemp) does seem to be correct.

      The server makes extensive use of strlcpy/strlcat/snprintf.
</pre>

<li>
pkg/PLIST を作りましょう。インストール終了後、PLIST ファイルを
<i>pkg</i> ディレクトリに作成してくれる開発者用コマンド <b>make plist</b> を
使用してください。
<p>
注意: ファイルはタイムスタンプの情報を元に検索されます。
<ul><li>
`tar' でインストールされたファイルはファイルのタイムスタンプが変更されず、
`find' によって出てこないため、PLIST 中に入りません。
<li>
.info ファイルが追加されても <code>info/dir</code> ファイルは更新されません。
また、<code>info/dir</code> は PLIST の一部ではないことにも注意してください。
<li>
(訳注: ハード)リンクやシンボリックリンクに対して特別な処理は
行いません。ざっとした tar の検査ではリンクやシンボリックリンクを
正しく扱っているように見えますので、パッケージリストの中で
特別な場合について取り扱う必要はなさそうに見えます。が、しかし…
</ul>
<p>
`PLIST' をよく見直してすべて正しい場所にインストールされているか
確認してください。インストールされなかったものは
port の Makefile の `post-install' ルールで追加することができます。

<p>
共有ライブラリをインストールする ports には、PFRAG.shared という別のファイルが必要です。
<ul><li>
PLIST にはアーキテクチャが共有ライブラリをサポートしているかどうかとは関係のないファイルについて記述します。
<li>
PFRAG.shared には共有ライブラリをサポートするアーキテクチャ上のみ
インストールされるファイルについて記述します。
<li>
PFRAG.noshared には共有ライブラリをサポートしないアーキテクチャ上のみ
インストールされるファイルについて記述します。
</ul>

<br><li>
完全に動作するようになるまでアンインストールと再インストールとを繰り返して行ってください。
<em>「完全に動作する」</em>とはすべてのものがそれぞれの適切な位置にインストールされ、
または、アンインストールされるようになることです。アンインストールするためには、`pkg_delete &lt;pkg_name&gt;'
とします。再インストールするためには、`sudo make reinstall' を実行します。
確実に「きれいに掃除する」ために PLIST ファイルに書き加えることのできるその他のコマンドについては
`pkg_create' の man page を見てください。アンインストールの後には、次のコマンド、
<pre>
$ find /usr/local -newer w-${PKGNAME}${FLAVOR_EXT}/fake-${MACHINE_ARCH}[-${FLAVOR}]/.install_started -print
</pre>
が標準のディレクトリ名だけを表示するようになっているべきです。

<br><br><li>
パッケージ化のテストをしましょう。
パッケージを作るには、ports を正しくインストールしてから
<code>make package</code> というコマンドを実行します。
パッケージをテストするためには、まず、
<code>pkg_delete</code> を実行してから <code>pkg_add</code> します。
<code>pkg_add</code> した結果とは、`make install' したときと厳密に一致しているべきです。

<br><br><li>
意見とテストを求める短い文章を書いて
<a href="mailto:ports@openbsd.org">ports@openbsd.org</a> にメールしてください。
ports をそのメールに添付して送ってください。
<p>
あなたのためにいろいろなプラットフォームで ports をテストしてくれる人を捕まえましょう。
<ul><li>
DEC Alpha は、静的ライブラリしか持っておらず、また、
<code>sizeof(int) != sizeof(long)</code> であるということからテストするには良いプラットフォームです。
<li>
Sun SPARC もまた良いプラットフォームです。なぜなら、
とても一般的なプラットフォームでありそのバイトオーダが i386 とは逆だからです。
もちろん、もし SPARC 上で開発したならば i386 上でもテストしたいと思うでしょう。
</ul>

<br><li>
得られたフィードバックはすべて検討しましょう。あなたのプラットフォーム上でもう一度テストし直してください。
直した新しい ports をもう一度テストしてフィードバックを返してくれる人を捕まえましょう。

<br><br><li>
最後に作った ports を "ports" ツリーに入れます。CVS に書き込む権限を持っていない場合には、
<a href="mailto:ports@openbsd.org">ports@openbsd.org</a>にいる
誰かに commit してくれるように頼んでください。

<br><br><li>
もしあなたが CVS にアクセスできる開発者であるならば、
ports をチェックインしてください。
新しい ports の場合、通常、大量のファイルを個別に add するのではなく
"import"を使います。import は 1.1.1.1 というような
"vendor branch" バージョンを使用しますが、心配はいりません :-)。
どれかのファイルを変更 (つまり編集して cvs commit) すればそれは1.2になり、そのファイルが使用されます。
<p>
簡単にいうと、import は、普通、ports を作ったときに使用されます。
その観点で言えば、cvs add と cvs rm はファイルを追加したり削除したりする
ファイルを変更していく編集 → commit の通常のサイクルで使用されます。
たとえば、以下のようにすると良いでしょう。
<pre>
$ cd kaffe1
$ make clean	# you really don't want to check in all of work!
$ cvs -d cvs.openbsd.org:/cvs import -m 'kaffe port' ports/lang/kaffe1 \
	<I>YourName</I> <I>YourName_YYYY-MMM-DD</I>
</pre>
<ul><li>
-d cvs.openbsd.org:/cvs は CVS がどこにあるのかの場所を示しています。
これは環境変数 CVSROOT を設定すれば省略できます。
<li>
-m 'kaffe port' はあなたのログインメッセージです。お好きな内容にしてください。
<li>
ports/lang/kaffe1 は CVS が存在している /cvs からの相対パスです。
<li>
<i>YourName</i> (あなたのログイン名になっているはずです) は「ベンダタグ」
('vendor tag') です。あなたが import したらあなたがそのベンダです。
<li>
<i>YourName_YYYY-MMM-DD</i> (例: ian_2000-Jan-01) は「ベンダリリースタグ」
('vendor release tag') です。これは何でも構いません。
</ul>
<br>
本当に過去にあった例として、メンテナのひとりが 1998 年 9 月 8 日に
Kaffe1 の port をチェックインしたときの出力を下に示します。
<pre>
$ cd kaffe1
$ make clean >/dev/null
$ cvs import -m 'kaffe1.0(==JDK1.1) port' ports/lang/kaffe1 ian ian_1998-Sep-08
ian@cvs.openbsd.org's password: (not shown, obviously)
I ports/lang/kaffe1/CVS
I ports/lang/kaffe1/files/CVS
I ports/lang/kaffe1/pkg/CVS
N ports/lang/kaffe1/Makefile
cvs server: Importing /cvs/ports/lang/kaffe1/files
N ports/lang/kaffe1/files/md5
cvs server: Importing /cvs/ports/lang/kaffe1/pkg
N ports/lang/kaffe1/pkg/COMMENT
N ports/lang/kaffe1/pkg/DESCR
N ports/lang/kaffe1/pkg/PLIST

No conflicts created by this import
$ 
</pre>

<li>
最後に、親ディレクトリの Makefile に新しい ports のためのエントリを
1 行加えましょう。たとえば ports が ports/lang/kaffe1s だとすると
それを ports/lang/Makefile に加えるのです。

<br><br><li>
ports を維持管理しましょう。時間が経つにつれて問題が起きたり、新しいバージョンのソフトウェアがリリースされたりします。
メンテナは自分の ports を最新に保つように努力するべきです。
つまり、テスト、テスト、テスト…の繰り返しなのです。

<br><br><li>
ports をアップデートするときには、その ports に依存する他の ports も取り扱わなければならないことを
忘れないでください !  あなたの ports に依存しているどのような ports も壊すべきではありません。
問題が起きた場合には、それらの ports のメンテナと相談してください。同様に、依存関係の更新にも注意を払ってください。
そして、メンテナがそれらの作業をしたことをチェックするようにしてください。
</ol>
 
OpenBSD の "ports" を作る仕掛けを支えてくれているみなさんに感謝します。
<hr>
<a href="porting.html"><img height=24 width=24 src=../back.gif
 border=0 alt=Porting></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: checklist.html,v 1.48 ]
<br>
$Translation: checklist.html,v 1.2 2003/05/04 17:33:03 jufi Exp $
<br>
$OpenBSD: checklist.html,v 1.2 2003/05/05 09:39:08 jufi Exp $
</small>
</body>
</html>
