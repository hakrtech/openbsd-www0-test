<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content=
"Differences with other BSD porting systems.">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 2000 by OpenBSD.">
<title>Différences avec les autres systèmes de ports BSD</title>
</head>
<body text="Black" bgcolor="White" link="#23238E">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]"> 

<h1>Informations sur le portage OpenBSD</h1>

<h2><font color="#e00000">Différences importantes avec les autres
    projets BSD</font></h2>

<p>
NetBSD emploie le terme <em>ports</em> dans les cas dépendants de
l'architecture. Leur structure de ports est plutôt appelée
<em>packages</em>.
</p>

<h3>Support additionnel</h3>
L'infrastructure de portage inclut plusieurs scripts qui facilite
la création de nouveaux ports :
<dl>
<dt>build/resolve-lib
    <dd>invoqué via <code>make lib-depends-check</code>, pour vérifier
    les dépendances de bibliothèques dynamiques.
<dt>build/update-patches
    <dd>invoqué via <code>make update-patches</code>, qui devrait
    <strong>toujours être utilisé pour régénérer les patches.</strong>
<dt>install/make-plist
    <dd>invoqué via <code>make update-plist</code>. Il s'inquiète de la
    plupart des points importants influant sur la création des listes de
    paquetage.
    Les listes de paquetage OpenBSD sont significativement différentes de
    celles des autres projets BSD, en partie car les outils de paquetage
    ont été complètement réécris.
</dl>

<h3>Problèmes d'infrastructure Génériques</h3>

<p>
Le make d'OpenBSD supporte <code>${VAR:U}</code> et
<code>${VAR:L}</code> pour transformer la valeur d'une variable dans une
casse majuscule ou minuscule. De la même manière, make tests devrait
être codé d'une manière insensible à la casse, par exemple,
</p>

<pre>
        .if ${NEED_XXX:L} == "yes"
        do stuff if yes
        .else
        do other stuff
        .endif
</pre>

<p>
En théorie, toutes les variables booléennes reconnues par
<code>bsd.port.mk</code> devraient toujours être définies, les codes
comme <code>defined(USE_FOO)</code> ne seraient ainsi pas nécessaires,
et <code>${USE_FOO:L} != "no"</code> devrait fonctionner.
</p>

<p>
Le principal fichier <code>bsd.port.mk</code> a été lourdement profilé
et corrigé. En particulier, il supporte des processus make parallèles.
La fonctionnalité <code>scripts/{pre,do,post}-*</code> a été perdue dans
le processus. Pour remplacer cette fonctionnalité, invoquez le script
manuellement, depuis le Makefile.
</p>

<h3>Utilisation correcte de make</h3>

<p>
Notez que, si vous invoquez make avec <code>make VAR=value</code>,
l'assignation <em>redéfinira</em> toute valeur VAR pouvant provenir du
Makefile. Ainsi, de nombreux patches ne sont pas nécessaires, il est
plus avantageux de fixer correctement MAKE_FLAGS, pour diminuer le
fardeau de la maintenance.
</p>

<h3>Récupération des sources</h3>

<p>
Il y a deux sortes d'archives sources : DISTFILES et PATCHFILES. OpenBSD
les traite d'une manière identique, et les recherche par défaut depuis
MASTER_SITES. Il n'y a <strong>ni</strong> PATCH_SITES ni PATCH_SITES_SUBDIR.
</p>

<p>
Si tous les fichiers récupérés ne viennent pas du même ensemble de
sites, OpenBSD autorise l'extension filename:0 à filename:9, auquel cas
MASTER_SITES0 à MASTER_SITES9 seront utilisés pour récupérer les
fichiers.
</p>

<p>
Certaines architectures pourraient avoir besoin d'archives de
distribution spécifiques. Par le passé, ceci a causé des problèmes quand
des archives de distribution sur les miroirs étaient concernées.
OpenBSD supporte un troisième ensemble de fichiers : SUPDISTFILES. Ceux-
ci seront seulement utilisés pour la création de sommes de contrôle et
de contenus liés aux miroirs. Notez que SUPDISTFILES pourrait
chevaucher les DISTFILES ou PATCHFILES. Par exemple,
</p>

<pre>
        DISTFILES=foo-1.0.tgz
        .if ${ARCH} == "i386"
        DISTFILES+=foo-i386.tgz
        .elif ${ARCHI} == "sparc"
        DISTFILES+=foo-sparc.tgz
        .endif
        SUPDISTFILES=foo-i386.tgz foo-sparc.tgz
</pre>

<h3>L'infrastructure <code>WRKDIR</code></h3>

<p>
Nous ne voulons pas des ports qui utilisent <code>NO_WRKDIR</code>. Tous
les ports OpenBSD doivent avoir un répertoire de travail. Les détails de
nommage de ces répertoires de travail ne devraient pas être le soucis du
porteur. Si vous avez besoin de trouver un tel nom, demandez au Makefile
: <code>cd that_ports_dir &amp;&amp; make show=WRKDIR</code>
devrait vous donner une idée du <code>WRKDIR</code> de ce port.
</p>

<p>
La raison principale derrière cette interdiction est que le
<code>bsd.port.mk</code> d'OpenBSD agit comme un vrai Makefile, avec des
dépendances. L'étape <code>fetch</code> dépend des archives de
distribution et des fichiers de patch, toutes les autres étapes
dépendent de vrais fichiers peuplant le répertoire de travail (cookies),
ne pouvant exister sans répertoire de travail.
</p>

Si l'extraction des DISTFILES est spécifique, fixez
</p>

<pre>
EXTRACT_ONLY=
</pre> 

<p>
et faites l'extraction dans <code>post-extract.</code>
</p>

<dl>
<dt>WRKDIR</dt>

<dd>Le répertoire de travail des ports, ou sont mis les cookies de celui-
    ci.</dd>

<dt>WRKDIST</dt>

<dd>Le sous-répertoire de WRKDIR où les ports sont actuellement
    décompressés. C'est aussi le répertoire de base pour les patchs. Les
    autres BSD ne font actuellement pas la distinction WRKDIST/WRKSRC et
    ont seulement WRKSRC.</dd>

<dt>WRKSRC</dt>

<dd>Répertoire sous-jacent de WRKDIST où les sources actuelles se
    trouvent.</dd>

<dt>WRKBUILD</dt>

<dd>Répertoire sous-jacent de WRKDIR où la configuration et la
    construction du port se réalisera. Les autres BSD ne font pas la
    distinction WRKBUILD/WRKSRC. Les programmes basés sur autoconf (la
    plus grande partie) peuvent habituellement fixer SEPARATE_BUILD pour
    permettre la construction du port dans un répertoire WRKBUILD
    distinct de WRKSRC.</dd>

<dt>WRKCONF</dt>

<dd>Sous-répertoire de WRKDIR d'où les scripts configure devraient être
    lancés. Il est par défaut WRKBUILD, qui est correct 99% du
    temps.</dd>

<dt>WRKINST</dt>

<dd>Répertoire où le port sera installé avant la mise en paquetage
    (consultez la section Simulation des ports ci-dessous).</dd>
</dl>

<p>
<em>Notez que NO_WRKSUBDIR a été retiré : l'équivalent peut être
accomplit en fixant à la place WRKDIST=$(WRKDIR). </em>
</p>

<h3>Simulation des ports</h3>

<h4>Introduction</h4>

<p>
Lorsque la construction du port est terminée, les autres BSD traitent
ensuite de l'installation du port, puis construisent un paquetage grâce au
port installé. OpenBSD utilise à la place la simulation d'installation.
</p>

<ul>
<li>Un port OpenBSD est configuré et construit normalement (par exemple,
    installé dans <code>PREFIX</code>, habituellement
    <code>/usr/local</code>).</li>

<li>Mais il est possible de l'installer partout, normalement dans
    WRKINST, qui est habituellement un répertoire sous-jacent de
    WRKDIR.</li>

<li>Ensuite l'installation fictive est mise en paquetage, en utilisant
    l'option -B de pkg_create.</li>

<li>Enfin, le paquetage résultant peut être installé, en utilisant
    pkg_add.</li>
</ul>

<h4>Avantages</h4>

<ul>
<li>Pour un constructeur de paquetage, ceci signifie que la plupart des
    ports n'ont pas à être installés, ce qui évite un grand nombre de
    compromis et d'effets généraux néfastes provoqués par des ports mal
    installés. Ceci permet aussi la construction de plusieurs paquetages
    conflictuels sur la même machine. Enfin, ceci permet de construire
    un nouvel ensemble de paquetages non testés sans éclabousser une
    installation correcte.</li>

<li>Pour un développeur de ports, ceci simplifie agréablement la
    recherche de problèmes dans les listes de paquetage, puisque le lieu
    de l'installation fictive est vide avant que le port soit installé.
    Ainsi, si un port installe trop de fichiers, il n'est désormais plus
    nécessaire de personnaliser l'installation du port : ce n'est pas
    suffisant pour enregistrer les fichiers supplémentaires dans la
    liste des paquetages.</li>

<li>Pour l'utilisateur final, ceci améliore la qualité des paquetages : à
    condition que le port final soit installé en utilisant pkg_add,
    l'utilisateur final <em>obtient exactement</em> le même logiciel que
    celui qui fut préparé sur la machine du porteur.</li>
</ul>

<h4>Comment le faire</h4>

<p>
Les cibles invoquées pour <code>make fake</code> sont les cibles
habituelles d'installation, excepté sur quelques points de différence :
</p>

<ul>
<li>FAKE_FLAGS est utilisé au lieu de MAKE_FLAGS. Par défaut, FAKE_FLAGS
    fixe DESTDIR=${WRKINST}.</li>

<li>FAKE_TARGET est utilisé au lieu de INSTALL_TARGET.</li>

<li>Les fragments {pre,do,post}-install sont invoqués avec TRUEPREFIX
    fixé à $(PREFIX), PREFIX fixé à $(WRKINST)$(PREFIX), et DESTDIR fixé
    à $(WRKINST).</li>
</ul>

<p>
Les ports utilisant imake devraient fonctionner ainsi, puisque les
fragments imake sont configurés pour utiliser DESTDIR. De même, les GNU
configure récents ne devraient pas nécessiter de changement.
</p>

<p>
Une autre bonne technique est une astuce d'attache tardive : configurez
les ports pour utiliser un préfixe $(DESTDIR)/usr/local, le Makefile
résultant aura ainsi
</p>

<pre>
prefix=$(DESTDIR)/usr/local
</pre>

<p>
fixé. Quand le port est construit, puisque DESTDIR n'est pas fixée,
/usr/local est utilisé, et l'installation fictive mettra tous les
fichiers dans WRKINST/usr/local (par exemple, pour les configure GNU,
utilisez <code>CONFIGURE_STYLE= gnu dest</code>).
</p>

<h4>Pièges</h4>

<ul>
<li>Certains ports sont contradictoires dans leur traitement de DESTDIR
    : la plupart des ports préfèrent que DESTDIR soit fixée, mais pas un
    ou deux contrevenants. Corrigez le problème.</li>

<li>Soyez attentifs à distinguer l'emplacement actuel où le port est
    installé, et l'emplacement enregistré dans les fichiers de
    configuration du paquetage. Ceci est très facile à outrepasser, mais
    facile à corriger en utilisant TRUEPREFIX.</li>

<li>Les liens symboliques absolus nécessitent toujours une
    personnalisation. Heureusement, <code>bsd.port.mk</code> notifiera les
    problèmes de ce genre.</li>

<li>Quelques ports ne veulent pas laisser $(DESTDIR) seule à l'étape de
    configuration. Un fragment post-configure qui peaufine tous les
    Makefiles pour ajouter DESTDIR est nécessaire.</li>

<li>Très rarement, un port résistera à tous les essais raisonnables pour
    faire un FAKE. Une approche par force brute devrait fonctionner :
    utilisez pre-fake pour lier ou copier tout ce que le port veut
    trouver dans WRKINST, et passez à l'installation dans le
    chroot.</li>
</ul>

<h3>Outils de Packaging</h3>

<p>
Les outils de paquetage connaissent quelques types de fichiers, et peuvent
faire un grand nombre de choses automatiquement : dans la plupart des
cas, les scripts de commande <code>@exec</code> ou <code>INSTALL</code>
ne sont pas nécessaires.<br>
<em>Notez que tous les scripts non nécessaires devraient être bannis,
car ils posent des problèmes de stabilité. Il est plus facile de
déboguer une infrastructure simple de paquetage que de modifier des
centaines de scripts afin de gérer de nouveaux problèmes.
</em><br>
Par exemple :
</p>

<ul>
<li><code>@exec ldconfig</code> n'est pas nécessaire, car les bibliothèques
    partagées annotées avec <code>@lib libfoo.so.1.0</code> et
    <code>ldconfig</code> ne sont lancées que quand cela est utile, et
    gèrent les chroot correctement.</li>
<li><code>@exec install-info</code> n'est pas nécessaire, car les
    fichiers de documentation sont annotés de <code>@info
    file.info</code>. Ceci prend également en compte les fichiers d'info
    multiples, et enlève le besoin de <code>makeinfo --no-split
    </code>.</li>
<li>les fonts sont intégrées automatiquement grâce à <code>@font</code>
    et <code>@fontdir</code>.</li>
<li>Les nouveaux utilisateurs et groupes sont gérés par
    <code>@newuser</code> et <code>@newgroup</code> plutôt que par les
    scripts d'installation. Ils sont créés assez tôt afin que
    l'extraction du paquetage puisse les utiliser.</li>
<li>Les fichiers de configuration sont gérés via <code>@sample</code>
    plutôt que par les scripts d'installation.</li>
</ul>

<p>
Référez-vous à
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_create&amp;sektion=1&amp;format=html">pkg_create(1)</a>
pour plus de détails. Dans la plupart des cas,
<code>make update-plist</code>
écrira une très bonne approximation de la packing-list complète, et
gèrera les améliorations d'une version à l'autre.
</p>

<h3>Saveurs</h3>

<p>
Les options ont été regroupées en saveurs, la construction des paquetages
peut ainsi être conforme. Un port avec des options devrait fixer FLAVORS
avec la liste des options qui ont un sens pour ce port (par exemple,
FLAVORS=foo bar zoinx), et utiliser ensuite FLAVOR pour tester quelles
options sont actuellement sélectionnées (par exemple, FLAVOR=zoinx foo).
<code>bsd.port.mk</code> fournit un support :
</p>

<ul>
<li>Le PKGNAME est personnalisé pour inclure des options séparées par
    des "-" (par exemple, package-foo-zoinx).</li>

<li>Le WRKDIR est personnalisé, des saveurs distinctes peuvent ainsi
    être construites sans collision.</li>

<li>Les constructions de la forme %%flavor%% déclencheront la saveur
    PFRAG. La construction %%SHARED%% déclenchera l'inclusion de
    PFRAG.shared.</li>

<li>bsd.port.subdir.mk comprend l'extension SUBDIR=directory,opt1,opt2
    pour spécifier la construction du port dans le répertoire avec
    FLAVOR=opt1 opt2.</li>
</ul>

<p>
Rechercher si une saveur donnée a été sélectionnée est aussi simple que
:
</p>

<pre>
.if ${FLAVOR:L:Mzoinx}
</pre>

Il y a une extension additionnelle, connue sous le nom de
MULTI_PACKAGES. De manière générale, MULTI_PACKAGES et FLAVORS sont des
mécanismes orthogonaux. Ensemble, ils essaient de rendre l'arbre des
ports OpenBSD plus petit que sur les autres BSD, en autorisant un seul
répertoire pour construire un grand nombre de paquets distincts.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5&amp;format=html">bsd.port.mk(5)</a>
possède une section complète consacrée à FLAVORS et MULTI_PACKAGES.

<hr>

<small>
<!--
Originally [OpenBSD: diffs.html,v 1.19 ]<br>
$Translation: diffs.html,v 1.13 2012/04/15 13:17:35 rustybsd Exp $<br>
-->
$OpenBSD: diffs.html,v 1.12 2012/04/16 00:11:30 ajacoutot Exp $
</small>

</body>
</html>
