<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="Content-Type"
	content="text/html; charset=iso-8859-1">
  <meta name="resource-type"
	content="document">
  <meta name="description"
	CONTENT="How to make an OpenBSD port; audio">
  <meta name="keywords"
	content="openbsd,ports,audio">
  <meta name="distribution"
	content="global">
  <meta name="copyright"
	content="This document copyright 1998-2002 by OpenBSD.">
  <title>Manuel du porteur : applications audio</title>
  <link rev="made" HREF="mailto:www@openbsd.org">
 </head>
 <body text="#000000" bgcolor="#FFFFFF" link="#23238E">
 <img height="30" width="141" src="../../images/smalltitle.gif" alt="[OpenBSD]">
 <h1>Manuel du porteur : applications audio</h1>

<p>
  Ce document ne traite actuellement que des sons echantillonés. Les
  contributions abordant les synthétiseurs et les tables de mixage sont
  les bienvenues.

</p>
<p>
	Les applications audio sont en général difficiles à porter, le
	son étant un domaine dans lequel les interfaces ne sont pas du
	tout standardisées, même si l'approche ne varie que très peu en
	fonction des systèmes d'exploitation.
</p>

  <h2><font color="#e00000">Utilisation de
	  <code>ossaudio</code></font></h2>

  L'émulation <code>ossaudio</code> est peut-être le moyen le plus
  simple, mais elle ne fonctionne pas toujours, et ce n'est pas
  forcément un bon choix.
  <ul>
	<li>Elle redéfinit <code>ioctl</code>. Si le code à porter
	n'utilise pas <code>ioctl</code> seulement pour l'audio, vous
	aurez à utiliser <code>#undef ioctl</code> ainsi que la forme
	dénudée <code>_ossioctl</code>.

	<li>Certaines fonctionnalités du son linux ne sont pas émulées.

	<li>Les applications avec un support du son linux correct non
	spécifique à Intel utilisent généralement ces
	fonctionnalités.

  </ul>

  <h2><font color="#e00000">Utilisation de code NetBSD ou
	  FreeBSD</font></h2> Depuis que nous partageons une partie de
	  l'interface audio avec NetBSD et FreeBSD, partir d'un port NetBSD
	  est chose raisonnable. Pensez que certains fichiers changent de
	  place, et que certaines entrées dans <code>sys/audioio.h</code>
	  sont obsolètes. De plus, de nombreux ports ne sont pas idéalement
	  programmés, et ne fonctionnent réellement que sur un seul type de
	  machine. Certains changements deviennent ainsi nécessaires. Lisez
	  la partie suivante.

  <h2><font color="#e00000">Ecriture de code OpenBSD</font></h2>

	  <h3><font color="#0000e0">libsndio</font></h3>
   <p>
	OpenBSD posséde sa propre couche matérielle audio qui est fournie
	par la librairie sndio, documenté dans 
	<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sio_open&sektion=3">sio_open(3)</a>.
	Avant que cela ne soit inclu dans cette page, vous pouvez trouver
	plus d'informations sur la programmation de cette API dans ce guide,
	<a href="http://caoua.org/alex/obsd/libsndio.html">conseils sur
	l'écriture et le portage d'application audio.</a>.
	sndio permet aux processus utilisateurs d'accéder au matériel
	<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audio&sektion=4">audio(4)</a>
	et au serveur audio
	<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&sektion=1">aucat(1)</a>
	de maniére uniforme.
	Il supporte le mode full-duplex, et quand il est utilisé avec le serveur 
	<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&sektion=1">aucat(1)</a>
	il supporte le re-échantillonnage et la conversion de format à la volée.
   </p>

	  <h3><font color="#0000e0">Dépendances Matérielles</font></h3>

   <p>
	<strong>VOUS NE DEVRIEZ PARTIR SUR AUCUN PRESUPPOSES CONCERNANT
	LE MATERIEL AUDIO UTILISE.
	</strong><br>
	Du code éronné se caractérise par une simple vérification du
	champ <code>a_info.play.precision</code>, comportant 8 ou 16
	bits, et par le fait qu'il suppose que les échantillons sont
	signés ou non-signés en fonction du comportement de
	soundblaster. Vous devriez vérifier explicitement l'échantillon
	et programmer en fonction. Un simple exemple : </p> <pre>
	AUDIO_INIT_INFO(&amp;a_info); a_info.play.encoding =
	AUDIO_ENCODING_SLINEAR; a_info.play.precision = 16;
	a_info.play.sample_rate = 22050; error = ioctl(audio,
	AUDIO_SETINFO, &amp;a_info); if (error) /* deal with it */ error
	= ioctl(audio, AUDIO_GETINFO, &amp;a_info);
	switch(a_info.play.encoding) { case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_BE: if (a_info.play.precision == 8)
	/* ... */ else /* ... */ break; case ...

	default:
	/* n'oubliez pas de prendre en compte ce que vous ignorez !!!
	 * Par exemple,
	 */
	fprintf(stderr, 
			"Unsupported audio format (%d), ask ports@ about that\n",
			a_info.play.encoding);

	}
	/* à présent, n'oubliez pas de vérifier la fréquence
	 * d'échantillonage que vous avez
	 */
	</pre>
  
  <p>
  Ceci concerne le plus petit fragment de code que vous pourriez traiter
  avec un grand nombre de problèmes.

	<h3><font color="#0000e0">Formats 16 bit et
		"endianness"</font></h3> Lors d'une utilisation classique,
		vous demandez simplement le type d'encodage (par exemple,
		<code>AUDIO_ENCODING_SLINEAR</code>), et vous réessayez un
		encodage avec "endianness" (par exemple,
		<code>AUDIO_ENCODING_SLINEAR_LE</code>). Considérant qu'une
		carte son ne doit pas forcément utiliser le même "endianness"
		que votre plate-forme, vous devriez vous préparer à
		rencontrer cela. Le moyen le plus simple est probablement de
		préparer un buff audio complet, et d'utiliser
		<code>swab(3)</code> si un changement d'endianness est
		nécessaire. Traiter des échantillons externes consiste en
		général à : <ol>
			<li>Analyser le format de l'échantillon,
			<li>Obtenir l'échantillon présent,
			<li>Permuter l'endianness si ce n'est pas le format natif,
			<li>Calculer ce que vous voulez en sortie dans un buffer,
			<li>Permuter l'endianness si votre carte son n'est pas
			dans le format natif,
			<li>Jouer le contenu du buffer.
	</ol>
	Evidemment, vous pourriez être capable de sauter les étapes 3 et
	5 si vous jouez un son s'averrant être dans le format natif de
	votre carte son.

	<h3><font color="#0000e0">Qualité audio</font></h3>
	<p>
	Le matériel pourrait avoir d'étranges limitations, comme être
	incapable de dépasser les 22050 Hz en stereo, mais plus que
	44100 en mono. C'est dans ce genre de cas que vous devriez
	donner à l'utilisateur la possibilité de changer ses
	préférences, et d'essayer d'avoir les meilleures performances
	possibles. Par exemple, il est stupide de limiter la fréquence à
	22050 Hz sous prétexte que vous produisez un son stereo. Et si
	l'utilisateur n'avait pas un système de son stereo connecté à la
	sortie de sa carte son ? </p>

	<p>
	Il est également grotesque de saisir de manière permanente les
	limitations des compatibles soundblaster dans votre programme.
	Vous devriez en être conscient, mais essayer d'obtenir un son au
	delà de la barrière des 22050&nbsp;Hz/stereo et vérifier les
	résultats.
	</p>

	<h4>Echantillonage de la fréquence</h4>
	Vous devriez vraiment vérifier la fréquence
	d'échantillonage que votre carte vous restitue. Un décalage de
	5% relève déjà du mi-ton, et certaines personnes ont une
	audition beaucoup plus précise que cela, alors que beaucoup
	d'entre nous ne remarquerons rien. Votre application devrait
	être en mesure de rééchantilloner à la volée, peut être
	naïvement, ou via de sournoises applications des formules de
	rééchantillonage de Shannon si vous le pouvez.

	<h4>Gamme dynamique</h4>
	<p>
	Les échantillons n'utilisent pas toujours la gamme complète de
	valeurs possibles. Premièrement, les échantillons enregistrés
	avec un faible gain ne sonneront que très faiblement sur la
	machine, forçant ainsi l'utilisateur à augmenter le volume.
	Deuxièmement, sur les machines avec un matériel audio mal isolé,
	le rendu des sons bas signifie que vous entendrez surtout les
	battements de coeur de votre machine, au lieu du son que vous
	attendiez. Enfin, la conversion idiote de 16 bits à 8 bits
	pourrait vous laisser avec seulement 4 bits audio utilisables,
	ce qui procurerait une qualité désastreuse. </p>
	<p>
	Si cela est possible, la meilleure solution est probablement de
	parcourir intégralement le flux que vous êtes en passe de jouer,
	et de l'arranger afin qu'il utilise la gamme dynamique complète.
	Si vous ne pouvez pas vous le permettre, mais que vous pouvez
	gérer ceci afin d'avoir un minimum de regard sur ce que vous
	êtes en passe de jouer, vous pouvez ajuster le réglage du volume
	à la volée, vous n'avez qu'a vous assurer que ce dernier reste a
	une fréquence bien inférieure à celle du son que vous voulez
	jouer, et que vous n'obtenez <em>aucun débordement</em> -- ces
	derniers sonneront toujours moins bien que les améliorations que
	vous essayez de faire.<br>
	La perception du volume étant logarithmique, l'utilisation de
	décalages logarithmiques est généralement suffisante. Si votre
	donnée est signée, vous devriez explicitement coder le décalage
	comme une division, l'opérateur C <code>&gt;&gt;</code> n'étant
	pas utilisable sur des données signées.
	</p>
	<p>
	Si tout le reste échoue, vous devriez au moins essayer de
	fournir à l'utilisateur une option de décalage du volume.
	</p>

	<h3><font color="#0000e0">Audio performance</font></h3>
	<p>
	Les applications dotées de fins basses n'ont habituellement pas
	à s'en soucier. Gardez en tête que certains d'entre nous
	utilisent OpenBSD en fin basse 68030 et que si une application
	sonore peut fonctionner sur cela, il faut que ce soit le cas.
	</p>

	<p>
	N'oubliez pas de faire des comparatifs. Les optimisations
	théoriques ne sont que ceci : théoriques. Des figures
	significatives devraient être collectées pour vérifier ce qui
	est une amélioration majeure et ce qui ne l'est pas.
	</p>

	<p>
	Pour les applications audio haute performance, comme
	mpegI-layer3, certains points doivent être pris en compte :
	</p>
	<ul>
		<li>L'interface audio vous procure la taille de bloc
		matériel naturelle. L'utilisation de plusieurs de ces
		dernières pour votre buffer de sortie est essentielle.
		Gardez en tête que <code>write</code>, en tant qu'appel
		système implique un coût élevé comparé aux traitements audio
		internes.

		<li>La bande passante est un facteur très important lorsque
		l'on traite en matière d'audio. Un moyen utile pour
		optimiser un lecteur audio est de le voir comme un
		décompresseur. Plus long vous pouvez gardez avec la donnée
		compressée, mieux c'est. De très courts sautsqui font de
		très petits traitements sont une mauvaise idée. Il est
		généralement mieux de combiner tous les traitements dans un
		seul saut.

		<li>Certains formats encourent plus de recouvrement que
		d'autres. La primitive <code>ioctl</code>
		<code>AUDIO_GETENC</code> devrait être utilisée pour
		reprendre tous les formats que l'interface audio procure.
		Rendez vous tout spécialement compte du drapeau
		<code>AUDIO_ENCODINGFLAG_EMULATED</code>. Si votre
		application est d'ores et déjà capable de restituer tous les
		types de formats étranges, et raisonnablement optimisée pour
		cela, essayez à tout prix d'utiliser un format natif. D'un
		autre côté, le code d'émulation présent dans le périphérique
		audio peut être considéré comme relativement optimal, et ne
		le remplacez pas par un code rapidement mis sur pied. </ul>

	<p>Un modèle que vous pourriez avoir à suivre afin d'obtenir des
	résultats optimisés est de commencer par compiler un petit
	programme de test qui s'assure du matériel audio disponible, et
	procède ensuite à la configuration de votre programme pour qu'il
	traite de façon optimale le matériel audio disponible. Vous
	pourriez raisonnablement inciter les personnes voulant de bonnes
	performances audio à recompiler votre port quand ils changent de
	matériel, en s'assurant des changements. </p>

	<h3><font color="#0000e0">Temps réel ou synchronisé</font></h3>
	<p>
	Considérant qu'OpenBSD n'est pas temps réel, vous pourriez
	quand même vouloir écrire des applications audio souvent
	temps réel, comme par exemple les jeux. Dans ce cas, vous aurez
	à diminuer la taille des blocs afin que les effets sonores ne
	soient pas désynchronisés avec le jeu en court. Le problème avec
	ceci est que l'interface pourrait être affamée, entrainnant des
	rendements horribles. </p>
	<p>
	Dans le cas ou vous voudriez simplement que audio et graphismes
	soient synchronisés, et que le comportement de votre programme est
	prévisible, atteindre la synchronisation est chose facile. Vous jouez
	juste vos échantillons audio, et demandez au périphérique audio ce que
	vous êtes actuellement en train de jouer, via
	<code>AUDIO_GETOOFFS</code>, avant d'utiliser cette information
	pour synchroniser à l'avance les graphismes. Si vous demandez
	ceci suffisament fréquemment (disons, tous les dizièmes de
	seconde), et aussi longtemps que vous avez des ressources pour
	utiliser votre application, vous pouvez obtenir une très bonne
	synchronisation par ce moyen. Vous pourriez avoir à peaufiner
	les figures avec un décalage constant, il peut en effet y avoir
	des retards entre les informations rapportées par l'audio, ce
	qui se joue actuellement, et le temps mis par XWindow pour
	afficher quelquechose.
	</p>
	<h2><font color="#e00000">Contribution retour au code</font></h2>
	<p>Dans le cas d'applications audio, travailler avec l'auteur du
	programme est très important. Si son code ne marche par exemple
	qu'avec les cartes soundblaster, il y a de fortes chances pour
	qu'il faille faire face à d'autres technologies très
	prochainement.
	</p>

	<p>
	<strong>Si vous ne lui envoyez pas vos commentaires de cette
	manière, votre code aura été inutile</strong>.</p>
	<p>
	Il se pourrait aussi qu'il ait déjà notifié les problèmes que
	vous rencontrez, et qu'il s'y attèle dans l'arbre de
	développement. Si les patches que vous écrivez représentent plus
	qu'une poignée de lignes, la coopération est certainement une
	très bonne idée.
	</p>

<hr>
<a href="../../fr/porting.html"><img height=24 width=24 src=../../back.gif
border=0 alt=Porting></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: audio-port.html,v 1.4 ]<br>
$Translation: audio-port.html,v 1.4 2011/06/17 20:28:54 benoit Exp $<br>
-->
$OpenBSD: audio-port.html,v 1.2 2011/06/18 13:40:12 ajacoutot Exp $
</small>
</body>
</html>
