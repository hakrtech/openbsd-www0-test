<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content=
"Differences with other BSD porting systems.">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 2000 by OpenBSD.">
<title>Unterschiede zu anderen BSD-Portierungssystemen</title>
</head>
<body text="Black" bgcolor="White" link="#23238E">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]">

<h1>OpenBSD-Portierungsinformationen</h1>

<h2><font color="#e00000">Wichtige Unterschiede zu anderen
BSD-Projekten</font></h2>

<p>
NetBSD benutzt den Ausdruck <em>Ports</em> für Architektur-abhängige
Dinge. Ihre Ports-Struktur heißt stattdessen <em>packages</em>.
</p>

<h3>Zusätzliche Unterstützung</h3>
Die ,porting'-Infrastruktur enthält verschiedene Skripte, die das
Erzeugen neuer Ports erleichtern:
<dl>
<dt>build/resolve-lib
    <dd>aufgerufen durch <code>make lib-depends-check</code>, um
    Abhängigkeiten von Shared Librarys zu überprüfen.
<dt>build/update-patches
    <dd>aufgerufen durch <code>make update-patches</code>, das immer
    benutzt <strong>werden sollte, um die Patches neu zu
    erzeugen.</strong>
<dt>install/make-plist
    <dd>aufgerufen durch <code>make update-plist</code>. Hier wird sich
    sich um die meisten kleinen Punkte gekümmert, mit denen man
    akkurate Packing-Listen erzeugt. OpenBSD-Packing-Listen
    unterscheiden sich deutlich von anderen BSDs, zum Teil auch, weil
    die Packagetools vollkommen neu geschrieben wurden.
</dl>


<h3>Infrastruktur</h3>

<p>
OpenBSDs make unterstützt <code>${VAR:U}</code> und
<code>${VAR:L}</code>, um den Wert einer Variablen in Groß- oder
Kleinschreibung zu ändern. Dementsprechend sollte ,make test'
auch unabhängig von Groß- und Kleinschreibung programmiert sein,
also z.&nbsp;B.:
</p>

<pre>
	.if ${NEED_XXX:L} == "yes"
	do stuff if yes
	.else
	do other stuff
	.endif
</pre>

<p>
In der Theorie sollten alle Boolean-Variablen, die von
<code>bsd.port.mk</code> erkannt werden, auch definiert sein,
sodass Code wie
<code>defined(USE_FOO)</code> nicht notwendig sein sollte.
<code>${USE_FOO:L} != "no"</code> müsste funktionieren.
</p>

<p>
Die Haupt-<code>bsd.port.mk</code>-Datei wurde deutlich verändert und
schlanker gemacht. Insbesondere ist sie jetzt bereit für
,parallel-make'.
Das <code>scripts/{pre,do,post}-*</code>-Feature ging während des
Prozesses verloren. Um das Skript wieder auferstehen zu lassen, rufe es
per Hand aus dem Makefile auf.
</p>

<h3>make sauber benutzen</h3>

<p>
Denk daran, wenn du make mit <code>make VAR=value</code> aufrufst, wird
die Zuweisung jeden Wert <em>überschreiben</em>, den VAR vom Makefile
erhalten kann. Also sind viele Makefile-Patches nicht mehr notwendig,
es ist viel besser, die MAKE_FLAGS korrekt zu setzen, um den
Wartungsaufwand zu verringern.
</p>

<h3>Quelltexte holen</h3>

<p>
Es gibt zwei Arten von Archiven: DISTFILES und PATCHFILES.
OpenBSD behandelt sie in gleicher Art und Weise, und holt standardmäßig
alles von den MASTER_SITES. Es gibt <strong>keine</strong>
PATCH_SITES oder PATCH_SITES_SUBDIR.
</p>

<p>
Wenn nicht alle zu holenden Dateien von der selben Site kommen, erlaubt
OpenBSD die erweiterten Dateinamen:0 bis Dateiname:9, in diesem Fall
wird es die Dateien von den MASTER_SITES0 bis MASTER_SITES9 holen.
</p>

<p>
Manche Architekturen benötigen möglicherweise spezielle distfiles. In
der Vergangenheit gab es Probleme damit, soweit das Spiegeln von
distfiles betroffen war. OpenBSD unterstützt eine dritte Art von
Dateien: SUPDISTFILES. Diese werden nur zum Erzeugen von Prüfsummen
und beim Spiegeln verwendet. Denk dran, dass SUPDISTFILES
möglicherweise mit DISTFILES oder PATCHFILES kollidieren.
Zum Beispiel:
</p>

<pre>
	DISTFILES=foo-1.0.tgz
	.if ${ARCH} == "i386"
	DISTFILES+=foo-i386.tgz
	.elif ${ARCHI} == "sparc"
	DISTFILES+=foo-sparc.tgz
	.endif
	SUPDISTFILES=foo-i386.tgz foo-sparc.tgz
</pre>

<h3>Die <code>WRKDIR</code>-Infrastruktur</h3>

<p>
Wir wollen nicht, dass Ports <code>NO_WRKDIR</code> benutzen. Alle
OpenBSD-Ports müssen ein ,work directory' haben. Die Details der
Namensgebung sollten keine Angelegenheit des Portierers sein. Wenn du
einen solchen Namen erfahren musst, frage einfach das Makefile:
<code>cd that_ports_dir
&amp;&amp; make show=WRKDIR</code> wird die Vorstellung des
Codes von seinem <code>WRKDIR</code> offenlegen.
</p>

<p>
Der Hauptgrund hinter dieser Annahme ist, dass OpenBSDs
<code>bsd.port.mk</code> wie ein echtes Makefile agiert, allerdings mit
ein paar Abhängigkeiten. Die <code>fetch</code>-Stufe hängt von den
distfiles und patchfiles ab, alle anderen Stufen sind von echten
Dateien im ,working directory' (Cookies) abhängig, sodass sie gar
nicht ohne einem 'working directory' existieren können.
</p>

Wenn die DISTFILES-Extrahierung speziell ist, setze
</p>

<pre>
EXTRACT_ONLY=
</pre>

<p>
und mache die Extrahierung in <code>post-extract.</code>
</p>

<dl>
<dt>WRKDIR</dt>

<dd>Das Port-,working directory', wo es seine eigenen Cookies
unterbringt.
</dd>

<dt>WRKDIST</dt>

<dd>Unterverzeichnis von WRKDIR, in dem der Port tatsächlich ausgepackt
wird. Das ist auch das Basisverzeichnis für Patches. Andere BSDs haben
zurzeit keine WRKDIST/WRKSRC-Aufteilung, sondern nur WRKSRC.</dd>

<dt>WRKSRC</dt>

<dd>Unterverzeichnis von WRKDIST, in dem der tatsächliche Source
liegt.</dd>

<dt>WRKBUILD</dt>

<dd>Unterverzeichnis von WRKDIR, wo das Konfigurieren und Erzeugen
(build) des Ports geschehen wird. Andere BSDs haben die
WRKBUILD/WRKSRC-Aufteilung nicht. Programme, die (größtenteils) auf
autoconf basieren, können für gewöhnlich SEPARATE_BUILD setzen, damit
der Port in einem anderen Verzeichnis (WRKBUILD) als WRKSRC erzeugt
wird.</dd>

<dt>WRKCONF</dt>

<dd>Unterverzeichnis von WRKDIR, in dem configure-Skripte ausgeführt
werden sollten. Standardmäßig WRKBUILD, was in 99% der Fälle auch
korrekt ist.</dd>

<dt>WRKINST</dt>

<dd>Verzeichnis, in das der Port installiert wird, bevor er gepackt
wird (packaged) (siehe auch ,Faking ports' weiter unten).</dd>
</dl>

<p>
<em>Denk dran, dass es NO_WRKSUBDIR nicht mehr gibt: seine
Funktionalität kann stattdessen mit dem Setzen von WRKDIST=$(WRKDIR)
erreicht werden.</em>
</p>

<h3>Faking ports</h3>

<h4>Einführung</h4>

<p>
Nachdem ein ,build' komplett ist, gehen andere BSDs dazu, über den Port
zu installieren und erzeugen dann ein Package vom installierten Port.
OpenBSD benutzt stattdessen ,faked installation'.
</p>

<ul>
<li>Ein OpenBSD-Port wird ganz normal konfiguriert und erzeugt
(z.&nbsp;B. um unter <code>PREFIX</code> installiert zu werden,
normalerweise <code>/usr/local</code>).</li>

<li>Aber es wird ihm gesagt, er solle sich woanders installieren,
namentlich unter WRKINST, was für gewöhnlich ein Unterverzeichnis von
WRKDIR ist.</li>

<li>Dann wird die angebliche Installation gepackt (packaged), indem die
-B-Option von pkg_create benutzt wird.</li>

<li>Schlussendlich wird das daraus resultierende Paket (package)
mittels pkg_add installiert.</li>
</ul>

<h4>Vorteile</h4>

<ul>
<li>Für einen ,package builder' bedeutet es, dass die meisten Ports
nicht wirklich installiert werden müssen, was eine Menge potenzieller
Kompromisse und allgemeiner Probleme vermeidet.
Es erlaubt auch das Erzeugen von mehreren Paketen, die einen Konflikt
erzeugen, d.h. zum Beispiel verschiedene Versionen derselben Software
auf einer Maschine. Schlussendlich erlaubt es das Erzeugen von neuen,
ungetesteten Paketen ohne eine funktionierende Installation zu
gefährden.
</li>

<li>Für einen ,port writer' vereinfacht es das Ziel, Probleme in den
,packing lists' zu finden, da die ,fake area of installation' leer ist,
bevor der Port installiert wird. Zudem ist es nicht mehr nötig, die
Portinstallation zu beeinflussen, wenn ein Port zu viele Dateien
installiert, es reicht, die unwesentlichen Dateien einfach nicht in der
,packing list' aufzuführen.</li>

<li>Für den Anwender verbessert es die Qualität der Packages: da der
letztliche Port mit pkg_add installiert wird, erhält der Anwender
<em>exakt</em> die gleiche Software, wie die, die auf der Maschine des
Portierers vorbereitet wurde.
</li>
</ul>

<h4>Wie man es macht</h4>

<p>
Die Ziele (targets), die <code>make fake</code> aufruft, sind die üblichen
Installationsziele, mit einigen Ausnahmen:
</p>

<ul>
<li>FAKE_FLAGS wird anstelle von MAKE_FLAGS benutzt. Standardmäßig setzt
FAKE_FLAGS auf DESTDIR=${WRKINST}.</li>

<li>FAKE_TARGET wird anstelle von INSTALL_TARGET benutzt.</li>

<li>Die {pre,do,post}-Installationsfragmente werden mittels Setzen von
TRUEPREFIX auf $(PREFIX), PREFIX auf $(WRKINST)$(PREFIX) und DESTDIR
auf $(WRKINST) in Gang gebracht.</li>
</ul>

<p>
Ports, die imake benutzen, sollten so wie sie sind funktionieren, da
die imake-Fragmente konfiguriert sind, um DESTDIR zu benutzen. Genauso
sollten Ports, die ein aktuelles GNU configure nutzen, keine Änderungen
benötigen.
</p>

<p>
Eine weitere gute Technik ist ein ,late binding'-Trick: konfiguriere die
Ports so, dass sie einen Präfix von $(DESTDIR)/usr/local benutzen, so
dass das resultierende Makefile den Präfix
</p>

<pre>
prefix=$(DESTDIR)/usr/local
</pre>
<p>
hat. Wenn der Port erzeugt wird und DESTDIR nichts enthält, wird
/usr/local benutzt, und die fake-Installation wird alles unter
WRKINST/usr/local installieren (also für GNU configure benutze
<code>CONFIGURE_STYLE= gnu dest</code>).
</p>

<h4>Fallen</h4>

<ul>
<li>Einige Ports sind inkonsistent in ihrer DESTDIR-Verarbeitung: die
meisten Teile des Ports sind zufrieden mit dem gesetzten DESTDIR, mit
Ausnahme von zwei oder drei Ausreißern. Patche das Problem weg.</li>

<li>Unterscheide immer die wirkliche Stelle, an die der Port
installiert wird und die, die in den Konfigurationsdateien des Packages
aufgeführt ist. Das kann man leicht übersehen, ist aber leicht durch
die Verwendung von TRUEPREFIX zu vermeiden.</li>

<li>Absolute Symlinks müssen immer angepasst werden. Glücklicherweise
wird <code>bsd.port.mk</code> hier alle Probleme bemerken.</li>

<li>Ein paar Ports wollen $(DESTDIR) nicht alleine dem
configure-Schritt überlassen. Ein post-configure-Fragment, das allen
Makefiles das DESTDIR hinzufügt, wird benötigt.</li>

<li>Sehr selten wird ein Port allen vernünftigen Versuchen widerstehen,
FAKE zu benutzen. Ein Versuch mit roher Gewalt sollte funktionieren:
benutze pre-fake, um alles, was der Port im WRKINST-Bereich benötigt, zu
linken oder zu kopieren, danach installiere unter chroot.</li>
</ul>

<h3>Packaging-Tools</h3>

<p>
Die Package-Tools kennen schon ein paar Dateitypen und können viele
Dinge automatisch durchführen: in den meisten Fällen werden
<code>@exec</code>-Kommandos oder <code>INSTALL</code>-Skripte nicht
gebraucht.<br>
<em>Beachte, dass alle unnötigen Skripte verbannt werden sollten, da
das zu ,scalability'-Problemen führen kann. Es ist sehr viel einfacher,
eine einzelne Package-Infrastruktur nach Fehlern zu überprüfen, als
hunderte von Skripten zu modifizieren, damit sie mit neuen Problemen
umgehen können.</em><br>
Zum Beispiel:
</p>

<ul>
<li><code>@exec ldconfig</code> wird nicht benötigt, da Shared
Librarys mit <code>@lib libfoo.so.1.0</code> kommentiert werden
und <code>ldconfig</code> nur ausgeführt wird, wenn es benötigt wird,
und dann auch chroot dankbar verarbeiten wird.</li>
<li><code>@exec install-info</code> wird nicht benötigt, da
Dokumentationsdateien mit <code>@info file.info</code> kommentiert
werden. Dies handhabt auch mehrere Info-Dateien und entfernt die
Notwendigkeit von <code>makeinfo --no-split</code>.</li>
<li>Schriftarten werden dank <code>@font</code> und
<code>@fontdir</code> automatisch eingebunden.</li>
<li>Neue User und Gruppen werden über <code>@newuser</code> und
<code>@newgroup</code> verarbeitet, statt über Installationsskripte.
Sie werden auch früh genug angelegt, sodass weitere
Package-Extrahierung sie nutzen kann.</li>
<li>Konfigurationsdateien werden über <code>@sample</code> statt über
Installationsskripte verarbeitet.</li>
</ul>

<p>
Greife für weitere Details auf
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_create&amp;sektion=1&amp;format=html">pkg_create(1)</a>
zurück. In den meisten Fällen wird <code>make update-plist</code> einen
sehr guten Angleich für eine komplette Packing-Liste erstellen und wird
des weiteren auch von Hand durchgenommene Verbesserungen von einer
Version zur nächsten übernehmen.
</p>

<h3>,flavors'</h3>

<p>
Optionen wurden zu ,flavors' zusammengefasst, sodass das Erzeugen von
Packages (package building) konsistent sein kann. Ein Port mit Optionen
sollte mit FLAVORS eine Liste von all den Optionen setzen, die Sinn für
diesen Port machen (also FLAVORS=foo bar zoinx); benutze ,FLAVOR' um zu
testen, welche Optionen tatsächlich gesetzt wurden
(also: FLAVOR=zoinx foo).
<code>bsd.port.mk</code> bietet einige Unterstützung:
</p>

<ul>
<li>Der PKGNAME wird angepasst, um mit Bindestrich getrennte Optionen zu
enthalten (z.&nbsp;B. package-foo-zoinx).</li>

<li>Das WRKDIR wird so angepasst, dass konkurrierende ,flavors' erzeugt
werden können, ohne zu kollidieren.</li>

<li>Konstrukte der Form %%flavor%% werden die Einbeziehung von
pfrag.Flavor auslösen.
Das %%SHARED%%-Konstrukt löst die Einbeziehung von PFRAG.shared aus.</li>

<li>bsd.port.subdir.mk versteht die Erweiterung von
SUBDIR=directory,opt1,opt2  um sagen zu wollen: ,Baue den Port in
directory mit FLAVOR=opt1 opt2.'</li>
</ul>

<p>
Zu überprüfen, ob ein gegebenes ,flavor' ausgewählt wurde, ist recht
leicht:
</p>

<pre>
.if ${FLAVOR:L:Mzoinx}
</pre>

Es gibt eine Extra-Erweiterung namens MULTI_PACKAGES.
Allgemein gesagt sind MULTI_PACKAGES und FLAVORS orthogonale
Mechanismen, also ergänzend.
Zusammen sorgen sie dafür, dass der OpenBSD-Ports-Tree
kleiner ist als der von anderen BSDs, da sie dafür sorgen,
dass ein einzelner Port viele verschiedene Packages erzeugen
kann.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5&amp;format=html">bsd.port.mk(5)</a>
enthält ein ganzes Kapitel über FLAVORS und MULTI_PACKAGES.

<hr>

<small>
<!--
Originally [OpenBSD: diffs.html,v 1.19 ]<br>
$Translation: diffs.html,v 1.25 2007/11/03 10:45:52 paldium Exp $<br>
-->
$OpenBSD: diffs.html,v 1.25 2007/11/17 12:49:53 tobias Exp $
</small>

</body>
</html>
