<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content=
"Shared libraries in the ports tree">
<meta name="keywords" content="openbsd,ports,library">
<meta name="distribution" content="global">
<meta name="copyright" content=
"This document copyright 2001 by OpenBSD.">
<title>Gestión de bibliotecas compartidas en el
árbol de portes</title>
</head>
<body text="Black" bgcolor="White" link="#23238E">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]"> 

<h1>Gestión de bibliotecas compartidas en el
árbol de portes</h1>

<h2>Qué son las reglas numéricas de las
bibliotecas compartidas</h2>
Las bibliotecas compartidas son algo complicadas por varias
razones.  Para su manejo es necesario entender antes el
esquema de nombres de las bibliotecas:
<code>libfoo.so.major.minor</code>.
<p>
Cuando se enlaza un programa, el enlazador <code>ld</code>
embebe esa información en el binario que se genera.
Esto se puede ver con <code>ldd</code>.
Más tarde, cuando se ejecuta este programa, el
enlazador dinámico <code>ld.so</code> utiliza esa
información para encontrar la biblioteca
dinámica pertinente:
<ul>
	<li>Requiere una biblioteca con la numeración
	superior exactamente igual.
	<li>Requiere una biblioteca con la numeración
	inferior igual o mayor.
</ul>
Esto quiere decir que <strong>todas</strong> las bibliotecas
con el mismo número superior y con un número
inferior igual o mayor al requerido, <strong>deben satisfacer
el API binario que el programa espera encontrar</strong>.  Si
no fuera así, entonces el porte sería
erróneo;  en concreto, el porte no funcionaría
cuando los usuarios intentaran actualizar sus sistemas.
<p>
Las reglas para las bibliotecas compartidas son bastante
simples.
<ul>
	<li>Si se añaden funciones a la bibliotecas, es
	necesario incrementar el número inferior de la
	biblioteca:  un programa que necesite esas funciones
	no tiene otro modo para requerirlas que no sea el de
	pedirlas de forma explícita para, por lo menos,
	esta versión.
	<li>Si el API actual cambia, o sea, si se altera la
	firma de cualquier función, o si las secuencias
	de llamada ya no son válidas, si un tipo cambia
	de forma incompatible, el número superior
	<strong>se debe incrementar</strong>.
	<li>Esto incluye la eliminación de funciones
	antiguas.  Cualquier eliminación de funciones
	debería ir acompañada por un incremento
	en el número superior.
</ul>
<p>
Algunas veces sucede que una biblioteca está escrita en
varios ficheros, y las funciones internas son visibles para
permitir la comunicación entre esos ficheros.
Esos nombre de funciones suelen empezar con un guión
bajo, y no son parte del API.
<p>
Nótese que el esquema de nombres de las bibliotecas es
ubicuo en las plataformas de OpenBSD, tanto si el formato es
ELF como a.out.

<h2>Cambios en los portes para obtener nombre correctos</h2>
Un buen número de portes necesitan cambios para poder
ser compilados con bibliotecas compartidas.  Recuerde que la
compilación de las bibliotecas compartidas se debe
hacer mediante
<code>gcc -shared -fpic|-fPIC -o libfoo.so.4.5 obj1 obj2</code>
<p>
Si intenta cambiar el nombre de la biblioteca más tarde
para ajustar el número de versión, no
funcionará:  las bibliotecas ELF usan magia adicional
para el nombre interno de la biblioteca, por lo que debe
enlazar desde la primera vez con la versión correcta.
<p>
Por otra parte, recuerde que puede anular y cambiar variables
de <em>Makefile</em> desde la línea de órdenes,
usando <code>MAKE_FLAGS</code> en el fichero
<em>Makefile</em> del porte.  Esto le será de gran
utilidad en algunos portes, como por ejemplo los basados en
<em>libtool</em>, ya que proveen de una de estas variables de
versión por cada biblioteca que crean.
<p>
El mejor modo de manejar los portes basados en <em>libtool</em>
es configurar la variable <code>USE_LIBTOOL=Yes</code>. 
Esto activa la versión de <em>libtool</em> presente en el árbol de 
portes, y se encarga automáticamente de la mayoría de los detalles: 
<ul>
	<li>libtool mira en <code>SHARED_LIBS</code> y reemplaza 
	automáticamente los números de versión.
	<li>libtool produce un registro de biblioteca compartida
	en el fichero <code>${WRKBUILD}/shared_libs.log</code>
	que puede ser incluido directamente en el Makefile del porte.
</ul>

<h2>Intente poner todas las bibliotecas visibles en
/usr/local/lib</h2>
Exigir que el usuario añada directorios a su camino a
ldconfig es, como regla general, una mala idea:  todas las
bibliotecas compartidas que se encuentran directamente
enlazadas a programas deberían aparecer en
<em>/usr/local/lib</em>.  Sin embargo, es posible usar un
enlace simbólico a una determinada biblioteca.  Es
necesario que se comprendan las reglas de búsqueda de
las bibliotecas:
<ul>
	<li>En el momento de la compilación,
	<code>ld</code> usa señalizadores <code>-L</code>
	para configurar rutas en las que busca 
	bibliotecas.  En cuanto encuentra una biblioteca que
	coincide con sus requisitos, para de buscar.
	<li>En el momento de la ejecución,
	<code>ld.so</code> usa la información guardada
	mediante <code>ldconfig</code> para encontrar la
	biblioteca requerida.
</ul>

Asumamos que tenemos dos portes que provean dos versiones
principales de una cierta biblioteca, pongamos como ejemplo
<code>qt.1.45</code> y <code>qt.2.31</code>.  Como los dos
portes no se pueden instalar de forma simultánea, para
asegurarnos de que un programa cualquiera enlace con qt.1, esa
biblioteca se proveerá como
<code>/usr/local/lib/qt/libqt.so.1.45</code>, y los programas
se enlazarán usando 
<code>ld -o program program.o -L/usr/local/lib/qt -lqt</code>.
De igual modo, un programa que enlace con qt.2 usará el
fichero <code>/usr/local/lib/qt2/libqt.so.2.31</code> con
<code>ld -o program program.o -L/usr/local/lib/qt2 -lqt</code>.
<p>
Para resolver esas bibliotecas en el momento de la
ejecución, se proveerá un enlace llamado
<code>/usr/local/lib/libqt.so.1.45</code> y otro llamado
<code>/usr/local/lib/libqt.so.2.31</code>.  Esto será
suficiente para satisfacer a <code>ld.so</code>.
<p>
Enlazar un programa usando qt1 con
<code>ld -o program program.o -L/usr/local/lib -lqt</code> es
un error.  Este código asume que <code>qt.2.31</code>
no ha sido instalado, lo que es una presunción
errónea.
<p>
Estos trucos sólo son necesarios en casos especiales en
los que se den bibliotecas para las que se necesite proveer de
un periodo de transición entre versiones.  Por lo
general, bastará con asegurarse de que la biblioteca
aparezca en <em>/usr/local/lib</em>.
<h2>Cómo escribir correctamente las dependencias de las
bibliotecas</h2>
El nuevo código de dependencia necesita dependencias de
bibliotecas completas.  Debe usarse 
<code>make lib-depends-check</code> o 
<code>make port-lib-depends-check</code> 
para verificar que un porte mencione
todas las bibliotecas que requiere.  
Simplemente debe escribirlas en LIB_DEPENDS/WANTLIB de esta forma:
<pre>
        LIB_DEPENDS += ::x11/gtk+
        WANTLIB += gtk.&gt;=1.2,gdk.&gt;=1.2
</pre>
<p>
Además, especificar las bibliotecas estáticas en
una línea de WANTLIB no es un error.  WANTLIB
es evaluado por completo en el momento de la
compilación de un paquete:  el paquete resultante
tendrá la información sobre dependencias de
bibliotecas embebido, en forma de líneas para
<code>ld.so</code>, que contienen el número
superior.inferior que fue usado para su compilación, y
nada para las bibliotecas compartidas.
<p>
También debe proveer de RUN_DEPENDS si un porte
requiere algo más que compilar enlazando a una
biblioteca.  Esto permitirá al porte compilar
correctamente en arquitecturas que no tengan soporte para
bibliotecas compartidas.
<p>
De hecho, proveer líneas LIB_DEPENDS incluso para 
bibliotecas estáticas es una buena idea:  esto simplificará
la acutalización del porte si una cierta dependencia
pasa de biblioteca estática a biblioteca compartida.
<p>
La líneas WANTLIB deben especificar las mismas
rutas que se utilizan para <code>ld</code>. Con el ejemplo 
anterior, un fragmento de dependencia típico de qt2 dice:
<code>WANTLIB += lib/qt2/qt.=2</code>.
Esto permite a la dependencia comprobar el
código para poder hacer lo correcto si se encuentra con
varias versiones de la misma biblioteca.
<h2>Cómo actualizar los portes correctamente</h2>
Cuando se actualice o añada un porte en el que haya por
medio bibliotecas compartidas, hay que tener en cuenta unos
cuantos detalles.
<ul>
	<li>Asegúrese de que los números
	mayor.menor de las bibliotecas compartidas sean
	los correctos.
	<li>Verifique todos los portes que dependan de su
	porte.  Verifique que compilen correctamente con sus
	cambio.  Notifique de la actualización a los
	mantenedores correspondientes, para que éstos
	puedan verificar que sus portes todavía
	funcionan bien.
	<li>Puede que tenga que ajustar las dependencias de 
	portes WANTLIB y LIB_DEPENDS.  Si
	introduce nuevas bibliotecas compartidas, preste
	atención a los BUILD_DEPENDS que tengan que ser
	convertidos en LIB_DEPENDS.
	<li>Siempre que introduzca un nuevo porte debe
	verificar que no esté creando una biblioteca
	que entre en conflicto con otra ya existente:  las
	bibliotecas de dos portes con el mismo número
	son mortales, debido a que sus esquemas de
	enumeración de versiones no pueden coincidir.
	Debe intentar resolver esta situación con el
	programa del autor (por ejemplo, una biblioteca que se
	llame libnet es un mal comienzo).
	<li>Para obtener información más amplia, 
	diríjase a <a href="../update.html">la guía de 
	actualización de portes</a>.
</ul>
  <hr>
  <a href="../index.html"><img height=24 width=24 src=../../back.gif border=0 alt=OpenBSD></a> 
  <a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br><small>
     <!--
     Originally [OpenBSD: libraries.html,v 1.7 ]<br>
     $Translation: libraries.html,v 1.4 2011/02/21 12:52:58 mvidal Exp $<br>
     -->
     $OpenBSD: libraries.html,v 1.4 2011/02/25 12:35:57 ajacoutot Exp $
   </small>
 </body>
</html>
