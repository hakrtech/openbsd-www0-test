<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content=
"Differences with other BSD porting systems.">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content=
"This document copyright 2000 by OpenBSD.">
<title>Diferencias con Otros Sistemas de Portes BSD</title>
</head>
<body text="black" bgcolor="white" link="#23238e">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]"> 

<h1>Informaci&oacute;n de los Portes de OpenBSD</h1>

<h2><font color="#e00000">Diferencias importantes con otros BSD</font></h2>

NetBSD usa el t&eacute;rmino <em>ports</em> (portes) para temas
dependientes de la arquitectura.
Su estructura de portes se llama <em>packages</em> (paquetes).

<h3>Temas gen&eacute;ricos de infraestructura</h3>

Puede comprobar si una versi&oacute;n espec&iacute;fica de
<code>bsd.port.mk</code> se encuentra disponible configurando
NEED_VERSION.

<br><br>

Ponga siempre la l&iacute;nea de NEED_VERSION justo debajo de
CATEGORIES para simplificar el procesamiento automatizado.

<br><br>

En OpenBSD 'make' tiene soporte para <code>${VAR:U}</code> y 
<code>${VAR:L}</code> para transformar el valor de una variable a
may&uacute;sculas o min&uacute;sculas.
De acuerdo con esto, las comprobaciones de 'make' se deber&iacute;an
codificar de forma independiente del caso, v.g.:

<ul>
<pre>
.if ${NEED_XXX:L} == &quot;yes&quot;
do stuff if yes
.else
do other stuff
.endif
</pre>
</ul>

<br><br>

Existe una tendencia a asegurarse de que todas las variables
reconocidas por <code>bsd.port.mk</code> se encuentren siempre
definidas, de modo que al final podamos quitarnos de encima
<code>defined(GNU_CONFIGURE)</code> y usar <code>${GNU_CONFIGURE:L} !=
&quot;no&quot;</code> en su lugar.

<br><br>

El fichero principal <code>bsd.port.mk</code> ha sido fuertemente
adaptado y se han arreglado problemas.
En particular, est&aacute; preparado para it paralelo a 'make'.
La funcionalidad <code>scripts/{pre,do,post}-*</code> se ha perdido en
el proceso.
Para reemplazar esta funcionalidad, invoque el gui&oacute;n
(&quot;script&quot;) manualmente desde el fichero Makefile.

<p>
<h3>Usar make correctamente</h3>

Note que, si invoca 'make' como <code>make VAR=value</code>, la
asignaci&oacute;n <em>anular&aacute;</em> cualquier valor que VAR
obtenga de Makefile.
Por ello, muchos parche para Makefile no son necesarios, es mucho mejor
configurar correctamente MAKE_FLAGS para disminuir la carga del
mantenimiento.

<p>
<h3>Obtener los fuentes</h3>

Existen dos tipos de archivos de fuentes: DISTFILES y PATCHFILES.
OpenBSD los procesa de un modo uniforme y, por definici&oacute;n, lo
saca todo de MASTER_SITES.
<strong>No</strong> hay PATCH_SITES ni PATCH_SITES_SUBDIR.

<br><br>

Si todos los parches que se bajaran no provinieran del mismo grupo de
sitios, OpenBSD permitir&iacute;a las extensiones filename:0 a
filename:9, en cuyo caso usar&iacute;a MASTER_SITES0 hasta
MASTER_SITES9 para bajar el fichero.

<br><br>

Es posible que algunas arquitecturas necesiten distfiles
espec&iacute;ficos.
En el pasado, esto ha causado problemas en donde ha sido preciso
replicar (&quot;mirror&quot;) distfiles.
OpenBSD dispone de soporte para un tercer grupo de ficheros:
SUPDISTFILES.
&Eacute;stos ser&aacute;n considerados s&oacute;lo para generar sumas
de comprobaci&oacute;n y r&eacute;plicas.
N&oacute;tese que es posible que SUPDISTFILES tenga una coincidencia
parcial con DISTFILES o PATCHFILES.
Por ejemplo:

<pre>
DISTFILES=foo-1.0.tgz
.if ${ARCH} == &quot;i386&quot;
DISTFILES+=foo-i386.tgz
.elif ${ARCHI} == &quot;sparc&quot;
DISTFILES+=foo-sparc.tgz
.endif
SUPDISTFILES=foo-i386.tgz foo-sparc.tgz
</pre>

<p>
<h3>La infraestructura de trabajo <code>workdir</code></h3>

No queremos portes que usen <code>NO_WRKDIR</code>.
Todos los portes de OpenBSD deben tener un directorio de trabajo.
Los detalles sobre el nombre de estos directorios de trabajo no tienen
porqu&eacute; ser la preocupaci&oacute;n de un &laquo;portador&raquo;.
Si necesita averiguar uno de estos nombres, mire en el fichero
Makefile: <code>cd ese_porte_dir &amp;&amp; make show
VARNAME=WRKDIR</code> le dar&aacute; una idea sobre el <code>WRKDIR</code>
(directorio de trabajo) de ese porte.

<br><br>

La principal raz&oacute;n detr&aacute;s de esa prohibici&oacute;n es
que en OpenBSD, <code>bsd.port.mk</code> act&uacute;a como un fichero
Makefile real, con dependencias.
El paso <code>fethc</code> depende de los distfiles y patchfiles, y el
resto de los pasos dependen de ficheros reales ubicados en el
directorio de trabajo (&quot;cookies&quot;), as&iacute; que no pueden
existir sin un directorio de trabajo.

<br><br>

Debido a un accidente hist&oacute;rico, el fragmento
<code>do-extract</code> crea el directorio de trabajo.
De acuerdo con esto, <code>pre-extract</code> y <code>do-extract</code>
<em>nunca</em> se deber&iacute;an anular.
Si la extracci&oacute;n de DISTFILES es especial, configure

<pre>
EXTRACT_ONLY=
</pre> 

y lleve a cabo la extracci&oacute;n en <code>post-extract</code>.

<dl>
<dt>WRKDIR</dt>

<dd><code>Directorio de trabajo del porte, en donde pone sus propios
&quot;cookies&quot;</code>.</dd>

<dt>WRKDIST</dt>

<dd><code>Subdirectorio de WRKDIR, en donde el porte se
desempaqueta.
Tambi&eacute;n es el directorio base para parches.
Otros BSD no tienen en la actualidad la distinci&oacute;n
WRKDIST/WRKSRC, y s&oacute;lo tienen WRKSRC</code>.</dd>

<dt>WRKSRC</dt>

<dd><code>Subdirectorio de WRKDIST, en donde est&aacute;n ubicados
los fuentes</code>.</dd>

<dt>WRKBUILD</dt>

<dd><code>Subdirectorio de WRKDIR, en donde tendr&aacute; lugar la
configuraci&oacute;n y compilaci&oacute;n del porte.
Otros BSD no tienen la distinci&oacute;n WRKBUILD/WRKSRC.
Los programas que se basen en autoconf (la mayor&iacute;a) pueden
generalmente configurar SEPARATE_BUILD para dejar que la
compilaci&oacute;n del porte sea en un WRKBUILD diferente a
WRKSRC</code>.</dd>

<dt>WRKINST</dt>

<dd><code>Directorio en donde se instalar&aacute; el porte antes de ser
empaquetado (ver &laquo;Falsificaci&oacute;n de portes&raquo;,
m&aacute;s abajo)</code>.</dd>
</dl>

<em>Nota: NO_WRKSUBDIR ha sido eliminado;  su funcionalidad se puede
obtener configurando WRKDIST=$(WRKDIR).</em>
</pre>

<h3><code>Falsificar portes</code></h3>

<h4><code>Introducci&oacute;n</code></h4>

<code>Despu&eacute;s de que una compilaci&oacute;n se ha completado,
otros BSD proceden con la instalaci&oacute;n del porte y a
continuaci&oacute;n compilan un paquete con el porte instalado.
<br>
En lugar de eso, OpenBSD usa una instalaci&oacute;n falsa.
Usando FAKE, el &aacute;rbol de portes no se convierte del todo, pero
se va aproximando.</code>

<ul>
<li>Un porte falso se configura y compila normalmente (v.g., para
    instalarse en <code>PREFIX</code>, que suele ser
    /usr/local</code>).</li>

<li>Pero se le indica que se instale en otra parte, en
    <code>WRKINST</code>, que suele ser un subdirectorio de
    <code>WRKDIR</code>.</li>

<li>Entonces se empaqueta la falsa instalaci&oacute;n, usando la
    opci&oacute;n -s de pkg_create.</li>

<li>Finalmente, el paquete resultante puede ser instalado usando
    pkg_add.</li>
</ul>

<h4>Ventajas</h4>

<ul>
<li>Para quien construye el paquete, esto significa que la
    mayor&iacute;a de portes no tienen que ser instalados, lo que elimina
    un gran n&uacute;mero de compromisos potenciales y desagrado general
    debido a portes mal instalados.
    Tambi&eacute;n permite construir varios paquetes con conflictos
    entre s&iacute; en la misma m&aacute;quina.
    Finalmente, permite construir un nuevo grupo de paquetes no
    probados sin tener que hacer una instalaci&oacute;n correcta.

<li>Para quien construye un porte, simplifica enormemente la labor de
    encontrar problemas en listas de paquetes, ya que el &aacute;rea
    falsa de instalaci&oacute;n se encuentra vac&iacute;a antes de que
    sea instalado el porte.
    Adem&aacute;s, si un porte instala demasiados ficheros, ya no es
    necesario retocar la instalaci&oacute;n del porte:  es suficiente
    con no grabar los ficheros extra&ntilde;os en la lista de
    empaquetado.</li>

<li>Para el usuario final, mejora la calidad de los paquetes;  ya que el
    porte final se instala usando pkg_add, el usuario final obtiene
    <em>exactamente</em> el mismo software que fue preparado en la
    m&aacute;quina del portador.</li>
</ul>

<h4>C&oacute;mo hacerlo</h4>

<p>
Para activar el marco de trabajo, s&oacute;lo necesita configurar
FAKE=Yes en el fichero Makefile del porte.

<br><br>

Los objetivos invocados para <code>make fake</code> son los objetivos
de instalaci&oacute;n usuales, excepto unas pocas diferencias:

<ul>
<li>Se usa FAKE_FLAGS en lugar de MAKE_FLAGS.
    Por definici&oacute;n, FAKE_FLAGS configura
    DESTDIR=${WRKINST}.</li>

<li>Se usa FAKE_TARGET en lugar de INSTALL_TARGET.</li>

<li>Los fragmentos {pre,per,post}-instalaci&oacute;n se invocan con
    TRUEPREFIX configurado a $(PREFIX), PREFIX configurado a
    $(WRKINST)$(PREFIX), y DESTDIR configurado a $(WRKINST).</li>
</ul>

Los portes que usen imake deber&iacute;an funcionar tal cual, ya que
los fragmentos imake est&aacute;n configurados para usar DESTDIR.
De forma parecida, los portes recientes de gnu-configure no
deber&iacute;an necesitar ning&uacute;n cambio.

<br><br>

Otra t&eacute;cnica &uacute;til es un truco de `ligado tard&iacute;o':
configure los portes para usar un prefijo $(DESTDIR)/usr/local, de modo
que el fichero Makefile resultante tenga

<pre>
prefix=$(DESTDIR)/usr/local
</pre>

configurado.
Cuando el porte se compile, y puesto que DESTDIR est&aacute;
configurado a nada, se usar&aacute; /usr/local y la falsa
instalaci&oacute;n pondr&aacute; todo en WRKINST/usr/local (v.g., para
gnu configure use
<code>CONFIGURE_ARGS=--prefix='$$(DESTDIR)$(PREFIX)'</code>).

<br><br>

<h4>Dificultades</h4>

<ul>
<li>Algunos portes son inconsistentes procesando sus DESTDIR: la
    mayor&iacute;a de portes van bien con DESTDIR activado, excepto uno
    &oacute; dos.
    Solucione el problema con parches.</li>

<li>Lleve cuidado al distinguir entre la ubicaci&oacute;n real en donde
    est&aacute; instalado el porte, y la ubicaci&oacute;n grabada en los
    ficheros de configuraci&oacute;n del paquete.
    Es muy f&aacute;cil saltarse esto, pero tambi&eacute;n es f&aacute;cil
    de solucionar usando TRUEPREFIX.</li>

<li>Siempre hay que retocar los enlaces simb&oacute;licos absolutos.
    Por suerte, <code>bsd.port.mk</code> se dar&aacute; cuenta de los
    problemas en ese &aacute;rea.</li>

<li>Unos pocos portes no quieren dejar $(DESTDIR) s&oacute;lo durante
    la configuraci&oacute;n.
    Se necesita un fragmento de postconfiguraci&oacute;n que retoque
    todos los ficheros Makefile para a&ntilde;adir DESTDIR.</li>

<li>Raras veces, un porte se resistir&aacute; a todos lo intentos
    razonables por usar FAKE.
    Una aproximaci&oacute;n de fuerza bruta deber&iacute;a funcionar:
    use pre-fake para enlazar o copiar todo lo que el porte quiera
    encontrar en el &aacute;rea WRKINST, y entonces lleve a cabo la
    instalaci&oacute;n bajo chroot.</li>
</ul>

<h3>&laquo;Sabores&raquo;</h3>

Las opciones se han racionalizado como &laquo;sabores&raquo;, para que
la construcci&oacute;n de paquetes pueda ser consistente.
Un porte con opciones debe configurar FLAVORS a la lista de todas las
opciones que tengan sentido para ese porte (v.g., FLAVORS=foo bar
zoinx), y entonces usar FLAVOR para verificar qu&eacute; opciones han
sido seleccionadas (v.g., FLAVOR=zoinx foo).<br>
<code>bsd.port.mk</code> provee algo de soporte:

<ul>
<li>PKGNAME se retoca para incluir opciones separadas por guiones
    (v.g., package-foo-zoinx).</li>

<li>WRKDIR se retoca para que se puedan compilar sabores distintos de
    forma concurrente sin que colisionen.</li>

<li>Si la lista de empaquetado se denomina PLIST.sed, las
    construcciones de la forma %%flavor%% diparar&aacute;n la
    inclusi&oacute;n de PFRAG.flavor.
    La construcci&oacute;n %%SHARED%% dispara la inclusi&oacute;n de
    PFRAG.shared.</li>

<li>bsd.port.subdir.mk entiende la extensi&oacute;n
SUBDIR=directory:opt1,opt2 para decir &laquo;compila el porte en
directorio con FLAVOR=opt1 opt2&raquo;.</li>
</ul>

Comprobar que un sabor dado ha sido seleccionado es tan simple como:

<pre>
.if ${FLAVOR:L}=&quot;zoinx foo&quot;
</pre>

<br>

Comprobar que un sabor contiene una opci&oacute;n dada no es mucho
m&aacute;s complicado:

<pre>
.if ${FLAVOR:L:Mzoinx}
</pre>

<br><hr><br>

<small>
Originally [OpenBSD: diffs.html,v 1.4 2000/04/14 02:29:41 wvdputte Exp ]<br>
$Translation: diffs.html,v 1.2 2000/04/21 00:54:42 horacio Exp $<br>
$OpenBSD: diffs.html,v 1.1 2000/04/26 17:06:26 wvdputte Exp $
</small>

</body>
</html>

