<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content=
"Differences with other BSD porting systems.">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 2000 by OpenBSD.">
<title>Diferencias con otros sistemas de portes BSD</title>
</head>
<body text="Black" bgcolor="White" link="#23238E">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]"> 

<h1>Información sobre los portes de OpenBSD</h1>

<h2><font color="#e00000">Diferencias importantes con otros proyectos
BSD</font></h2>

<p>
NetBSD usa el término <em>ports</em> ("portes") para
definir a las diferentes arquitecturas en las que funciona el sistema
operativo.  Su estructura de portes se llama
<em>packages</em> ("paquetes").
</p>

<h3>Soporte adicional</h3>
La infraestructura de portes incluye varios guiones (<i>scripts</i>) 
que facilitan la creación de nuevos portes:
<dl>
<dt>build/resolve-lib
    <dd>invocado vía <code>make lib-depends-check</code>, para verificar 
    dependencias de bibliotecas dinámicas (compartidas).
<dt>build/update-patches
    <dd>invocado vía <code>make update-patches</code>, que debe 
    <strong>usarse siempre para regenerar los parches.</strong>
<dt>install/make-plist
    <dd>invocado vía <code>make update-plist</code>. Se ocupa de
    las cuestiones más importantes que afectan a la creación de listas 
    de empaquetado. Las listas de empaquetado de OpenBSD son significativamente 
    diferentes de los de otras proyectos BSD, en parte debido a que las
    herramientas de empaquetado han sido completamente reescritas.
</dl>

<h3>Temas genéricos de infraestructura</h3>

<p>
En OpenBSD, 'make' tiene soporte para <code>${VAR:U}</code> y 
<code>${VAR:L}</code> para transformar el valor de una variable a
mayúsculas o minúsculas.
De acuerdo con esto, las comprobaciones de 'make' se deberían
codificar de forma independiente del caso, v.g.:
</p>

<pre>
	.if ${NEED_XXX:L} == &quot;yes&quot;
	do stuff if yes
	.else
	do other stuff
	.endif
</pre>
 
<p>
En teoría, todas las variables booleanas reconocidas por 
<code>bsd.port.mk</code> deben siempre definirse, 
de modo que al final código como
<code>defined(USE_FOO)</code> no deba ser necesario y  
<code>${USE_FOO:L} != "no"</code> debería funcionar.
</p>

<p>
El fichero principal <code>bsd.port.mk</code> ha sido fuertemente
adaptado y se han solucionado algunos problemas.
En particular, está preparado para ir paralelo a 'make'.
La funcionalidad <code>scripts/{pre,do,post}-*</code> se ha perdido en
el proceso.
Para reemplazar esta funcionalidad, invoque el guión
(&quot;<em>script</em>&quot;) a mano desde el fichero Makefile.
</p>

<p>
<h3>Usar make correctamente</h3>

<p>
Note que si invoca 'make' como <code>make VAR=value</code>, la
asignación <em>anulará</em> cualquier valor que VAR
obtenga de Makefile.
Por ello, muchos parches para Makefile no son necesarios, es mucho
mejor configurar correctamente MAKE_FLAGS para disminuir la carga del
mantenimiento.
</p>

<p>
<h3>Obtener el código fuente</h3>

<p>
Existen dos tipos de archivos de fuentes: DISTFILES y PATCHFILES.
OpenBSD los procesa de un modo uniforme y, de modo predeterminado, lo
saca todo de MASTER_SITES.
<strong>No</strong> hay PATCH_SITES ni PATCH_SITES_SUBDIR.
</p>

<p>
Si todos los parches que se bajaran no provinieran del mismo grupo de
sitios, OpenBSD permitiría las extensiones filename:0 a
filename:9, en cuyo caso usaría MASTER_SITES0 hasta
MASTER_SITES9 para bajar el fichero.
</p>

<p>
Es posible que algunas arquitecturas necesiten ficheros distfiles
específicos.  En el pasado, esto ha causado problemas en donde
ha sido preciso replicar (&quot;<em>mirror</em>&quot;) distfiles.
OpenBSD dispone de soporte para un tercer grupo de ficheros:
SUPDISTFILES.  éstos serán considerados sólo para
generar sumas de comprobación y réplicas.  Nótese
que es posible que SUPDISTFILES coincida en parte con DISTFILES o
PATCHFILES.  Por ejemplo:
</p>

<pre>
	DISTFILES=foo-1.0.tgz
	.if ${ARCH} == &quot;i386&quot;
	DISTFILES+=foo-i386.tgz
	.elif ${ARCHI} == &quot;sparc&quot;
	DISTFILES+=foo-sparc.tgz
	.endif
	SUPDISTFILES=foo-i386.tgz foo-sparc.tgz
</pre>

<p>
<h3>La infraestructura de trabajo <code>WRKDIR</code></h3>

<p>
No queremos portes que usen <code>NO_WRKDIR</code>.
Todos los portes de OpenBSD deben tener un directorio de trabajo.
Los detalles sobre el nombre de estos directorios de trabajo no tienen
porqué ser la preocupación de un &laquo;portador&raquo;.
Si necesita averiguar uno de estos nombres, mire en el fichero
Makefile: <code>cd that_ports_dir &amp;&amp; make show=WRKDIR</code> 
le dará una idea sobre el <code>WRKDIR</code>
(directorio de trabajo) de ese porte.
</p>

<p>
La principal razón detrás de esa prohibición es
que en OpenBSD, <code>bsd.port.mk</code> actúa como un fichero
Makefile real, con dependencias.
El paso <code>fethc</code> depende de los distfiles y patchfiles, y el
resto de los pasos dependen de ficheros reales ubicados en el
directorio de trabajo (&quot;cookies&quot;), así que no pueden
existir sin un directorio de trabajo.
</p>

Si la extracción de DISTFILES es específica, configure
</p>

<pre>
EXTRACT_ONLY=
</pre> 

<p>
y lleve a cabo la extracción en <code>post-extract</code>.
</p>

<dl>
<dt>WRKDIR</dt>

<dd>Directorio de trabajo del porte, en donde pone sus propias
<em>cookies</em>.</dd>

<dt>WRKDIST</dt>

<dd>Subdirectorio de WRKDIR, en donde el porte se desempaqueta.
También es el directorio base para parches.  Otros BSD no tienen
en la actualidad la distinción WRKDIST/WRKSRC, y sólo
tienen WRKSRC.</dd>

<dt>WRKSRC</dt>

<dd>Subdirectorio de WRKDIST, en donde están ubicados los
fuentes.</dd>

<dt>WRKBUILD</dt>

<dd>Subdirectorio de WRKDIR, en donde tendrá lugar la
configuración y compilación del porte.  Otros BSD no
tienen la distinción WRKBUILD/WRKSRC.  Los programas que se
basen en autoconf (la mayoría) pueden generalmente configurar
SEPARATE_BUILD para dejar que la compilación del porte sea en un
WRKBUILD diferente a WRKSRC.</dd>

<dt>WRKCONF</dt>

<dd>Subdirectorio de WRKDIR donde los scripts configure deben
ejecutarse. De forma predeterminada es WRKBUILD, lo que es correcto 
el 99% del tiempo.</dd>

<dt>WRKINST</dt>

<dd>Directorio en donde se instalará el porte antes de ser
empaquetado (ver &laquo;Simulación de portes&raquo;,
más abajo).</dd>
</dl>

<p>
<em>Nota: NO_WRKSUBDIR ha sido eliminado;  su funcionalidad se puede
obtener configurando WRKDIST=$(WRKDIR).</em>
</p>

<h3>Simulación de portes</h3>

<h4>Introducción</h4>

<p>
Después de que una compilación se ha completado, otros
BSD proceden con la instalación del porte y a
continuación compilan un paquete con el porte instalado.
En lugar de eso, OpenBSD usa una instalación simulada.  
</p>

<ul>
<li>Un porte OpenBSD se configura y compila normalmente (v.g., para
    instalarse en <code>PREFIX</code>, que suele ser
    /usr/local</code>).</li>

<li>Pero se le indica que se instale en otra parte, en
    <code>WRKINST</code>, que suele ser un subdirectorio de
    <code>WRKDIR</code>.</li>

<li>Entonces se empaqueta la instalación ficticia, usando la
    opción -B de pkg_create.</li>

<li>Finalmente, el paquete resultante puede ser instalado usando
    pkg_add.</li>
</ul>

<h4>Ventajas</h4>

<ul>
<li>Para quien construye el paquete, esto significa que la
    mayoría de portes no tienen que ser instalados, lo que
    elimina un gran número de compromisos potenciales y
    desagrado general debido a portes mal instalados.  También
    permite construir varios paquetes con conflictos entre sí en
    la misma máquina.  Finalmente, permite construir un nuevo
    grupo de paquetes no probados sin tener que hacer una
    instalación correcta.</li>

<li>Para quien construye un porte, simplifica enormemente la labor de
    encontrar problemas en listas de paquetes, ya que el área
    falsa de instalación se encuentra vacía antes de que
    sea instalado el porte.  Además, si un porte instala
    demasiados ficheros, ya no es necesario retocar la
    instalación del porte:  es suficiente con no grabar los
    ficheros extraños en la lista de empaquetado.</li>

<li>Para el usuario final, mejora la calidad de los paquetes;  ya que
    el porte final se instala usando pkg_add, el usuario final obtiene
    <em>exactamente</em> el mismo software que fue preparado en la
    máquina del portador.</li>
</ul>

<h4>Cómo hacerlo</h4>

<p>
Los objetivos invocados para <code>make fake</code> son los objetivos
de instalación usuales, con la excepción de unas pocas
diferencias:
</p>

<ul>
<li>Se usa FAKE_FLAGS en lugar de MAKE_FLAGS.
    Por definición, FAKE_FLAGS configura
    DESTDIR=${WRKINST}.</li>

<li>Se usa FAKE_TARGET en lugar de INSTALL_TARGET.</li>

<li>Los fragmentos {pre,per,post}-instalación se invocan con
    TRUEPREFIX configurado a $(PREFIX), PREFIX configurado a
    $(WRKINST)$(PREFIX), y DESTDIR configurado a $(WRKINST).</li>
</ul>

<p>
Los portes que usen imake deberían funcionar tal cual, ya que
los fragmentos imake están configurados para usar DESTDIR.
De forma parecida, los portes recientes que usen GNU configure no
deberían necesitar ningún cambio.
</p>

<p>
Otra técnica útil es un truco de `ligado tardío':
configure los portes para usar un prefijo $(DESTDIR)/usr/local, de modo
que el fichero Makefile resultante tenga
</p>

<pre>
prefix=$(DESTDIR)/usr/local
</pre>

<p>
configurado.
Cuando el porte se compile, y puesto que DESTDIR está
configurado a nada, se usará /usr/local y la falsa
instalación pondrá todo en WRKINST/usr/local (v.g., para
portes que usen GNU configure, utilice
<code>CONFIGURE_STYLE= gnu dest</code>).
</p>

<h4>Dificultades</h4>

<ul>
<li>Algunos portes son inconsistentes procesando sus DESTDIR: la
    mayoría de portes van bien con DESTDIR activado, excepto uno
    ó dos.
    Solucione el problema con parches.</li>

<li>Lleve cuidado al distinguir entre la ubicación real en donde
    está instalado el porte, y la ubicación grabada en los
    ficheros de configuración del paquete.
    Es muy fácil saltarse esto, pero también es fácil
    de solucionar usando TRUEPREFIX.</li>

<li>Siempre hay que retocar los enlaces simbólicos absolutos.
    Por suerte, <code>bsd.port.mk</code> se dará cuenta de los
    problemas en ese área.</li>

<li>Unos pocos portes no quieren dejar $(DESTDIR) sólo durante
    la configuración.
    Se necesita un fragmento de postconfiguración que retoque
    todos los ficheros Makefile para añadir DESTDIR.</li>

<li>En raras ocasiones, un porte se puede resistir a todos lo intentos
    razonables por usar FAKE.
    Una aproximación de fuerza bruta debería funcionar:
    use pre-fake para enlazar o copiar todo lo que el porte quiera
    encontrar en el área WRKINST, y entonces lleve a cabo la
    instalación bajo chroot.</li>
</ul>

<h3>Herramientas de empaquetado</h3>

<p>
Las herramientas de empaquetado conocen algunos tipos de fichero, 
y pueden hacer muchas cosas de forma automática: 
en la mayoría de los casos órdenes <code>@exec</code> o
scripts <code>INSTALL</code> son innecesarios. 
<br>
<em>Tenga en cuenta que todos los scripts que no sean necesarios deben 
ser excluidos, ya que tienen problemas de escalabilidad. Es mucho más 
fácil de depurar una infraestructura simple de empaquetado que 
modificar cientos de scripts que generen nuevos problemas.
</em><br>
Por ejemplo:
</p>

<ul>
<li><code>@exec ldconfig</code> no es necesario, pues las bibliotecas
compartidas están anotadas con <code>@lib libfoo.so.1.0</code> 
y <code>ldconfig</code> es ejecutado cuando es necesario, y maneja
chroot con elegancia.</li>
<li><code>@exec install-info</code> no es necesario, pues los ficheros de
documentación son anotados con <code>@info file.info</code>. Se ocupa  
igualmente de  multiples ficheros info, y elimina la necesidad de
<code>makeinfo --no-split</code>.</li>
<li>las fuentes se integran automáticamente gracias a <code>@font</code> 
y  <code>@fontdir</code>.</li>
<li>Los nuevos usuarios y grupos son manejados con <code>@newuser</code> y
<code>@newgroup</code> en lugar de scripts de instalación. También son
creados lo suficientemente pronto para que la extracción de paquete 
pueda usarse.</li>
<li>Los ficheros de configuración son manejados por medio de 
<code>@sample</code> en lugar de scripts de instalación.</li>
</ul>

<p>
Diríjase a 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_create&amp;sektion=1&amp;format=html">pkg_create(1)</a>
para obtener más detalles.  En la mayoría de casos,
<code>make update-plist</code> escribirá una muy buena aproximación de la 
lista de empaquetado completa, y se encargará de las mejoras de una versión 
a otra. 
</p>

<h3>Sabores</h3>

<p>
Las opciones se han racionalizado como &laquo;sabores&raquo;, para que
la construcción de paquetes pueda ser consistente.
Un porte con opciones debe configurar FLAVORS a la lista de todas las
opciones que tengan sentido para ese porte (v.g., FLAVORS=foo bar
zoinx), y entonces usar FLAVOR para verificar qué opciones han
sido seleccionadas (v.g., FLAVOR=zoinx foo).<br>
bsd.port.mk provee algo de soporte:
</p>

<ul>
<li>PKGNAME se retoca para incluir opciones separadas por guiones
    (v.g., package-foo-zoinx).</li>

<li>WRKDIR se retoca para que se puedan compilar sabores distintos de
    forma concurrente sin que colisionen.</li>

<li>Las construcciones de la forma %%flavor%% activarán la
    inclusión de PFRAG.flavor.  La construcción
    %%SHARED%% activa la inclusión de PFRAG.shared.</li>

<li>bsd.port.subdir.mk entiende la extensión
    SUBDIR=directory,opt1,opt2 para decir &laquo;compila el porte en
    directorio con FLAVOR=opt1 opt2&raquo;.</li>
</ul>

<p>
Comprobar que un sabor dado ha sido seleccionado es tan simple como:
</p>

<pre>
.if ${FLAVOR:L:Mzoinx}
</pre>

Existe una extensión adicional denominada MULTI_PACKAGES. 
En términos generales, MULTI_PACKAGES y FLAVORS son mecanismos ortogonales. 
En conjunto, tratan de hacer el árbol de portes de OpenBSD algo más pequeño 
que los otros BSD, al permitir un directorio único de portes para construir un 
gran número de paquetes distintos. <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5&amp;format=html">bsd.port.mk(5)</a> 
tiene una sección completa dedicada a FLAVORS y MULTI_PACKAGES.

<hr>

<small>
<!--
Originally [OpenBSD: diffs.html,v 1.19 ]<br>
$Translation: diffs.html,v 1.10 2011/02/21 12:52:58 mvidal Exp $<br>
-->
$OpenBSD: diffs.html,v 1.9 2011/02/25 12:35:57 ajacoutot Exp $
</small>

</body>
</html>
