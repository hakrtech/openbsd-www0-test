<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, ver www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-8859-1">
<meta name="resource-type" content="documento">
<meta name="description" content="Diferencia con los sistemas de portes de otros BSD">
<meta name="keywords" content="openbsd,portes">
<meta name="distribution" content="global">
<meta name="copyright" content= "Este documento es copyright 2000 de OpenBSD.">
<title>Diferencias con Otros Sistemas de Portes BSD</title>
</head>
<body text="black" bgcolor="white" link="#23238e">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]"> 

<h1>Informaci&oacute;n sobre los Portes de OpenBSD</h1>

<h2><font color="#e00000">Diferencias importantes con otros proyectos
BSD</font></h2>

<p>
NetBSD usa el t&eacute;rmino <em>&quot;ports&quot;</em> (portes) para
definir a las diferentes arquitecturas en las que funciona el sistema
operativo.  Su estructura de portes se llama
<em>&quot;packages&quot;</em> (paquetes).
</p>

<h3>Temas gen&eacute;ricos de infraestructura</h3>

<p>
Puede comprobar si una versi&oacute;n espec&iacute;fica de
<code>bsd.port.mk</code> se encuentra disponible configurando
NEED_VERSION.
</p>

<p>
Ponga siempre la l&iacute;nea de NEED_VERSION justo debajo de
CATEGORIES para simplificar el procesamiento automatizado.
</p>

<p>
En OpenBSD 'make' tiene soporte para <code>${VAR:U}</code> y 
<code>${VAR:L}</code> para transformar el valor de una variable a
may&uacute;sculas o min&uacute;sculas.
De acuerdo con esto, las comprobaciones de 'make' se deber&iacute;an
codificar de forma independiente del caso, v.g.:
</p>

<pre>
	.if ${NEED_XXX:L} == &quot;yes&quot;
	do stuff if yes
	.else
	do other stuff
	.endif
</pre>
 
<p>
Existe una tendencia a asegurarse de que todas las variables
reconocidas por <code>bsd.port.mk</code> se encuentren siempre
definidas, de modo que al final podamos quitarnos de encima
<code>defined(GNU_GMAKE)</code> y usar 
<code>${GNU_GMAKE:L} != &quot;no&quot;</code> en su lugar.
</p>

<p>
El fichero principal <code>bsd.port.mk</code> ha sido fuertemente
adaptado y se han arreglado problemas.
En particular, est&aacute; preparado para it paralelo a 'make'.
La funcionalidad <code>scripts/{pre,do,post}-*</code> se ha perdido en
el proceso.
Para reemplazar esta funcionalidad, invoque el gui&oacute;n
(&quot;script&quot;) manualmente desde el fichero Makefile.
</p>

<p>
<h3>Usar make correctamente</h3>

<p>
Note que, si invoca 'make' como <code>make VAR=value</code>, la
asignaci&oacute;n <em>anular&aacute;</em> cualquier valor que VAR
obtenga de Makefile.
Por ello, muchos parche para Makefile no son necesarios, es mucho mejor
configurar correctamente MAKE_FLAGS para disminuir la carga del
mantenimiento.
</p>

<p>
<h3>Obtener el c&oacute;digo fuente</h3>

<p>
Existen dos tipos de archivos de fuentes: DISTFILES y PATCHFILES.
OpenBSD los procesa de un modo uniforme y, por definici&oacute;n, lo
saca todo de MASTER_SITES.
<strong>No</strong> hay PATCH_SITES ni PATCH_SITES_SUBDIR.
</p>

<p>
Si todos los parches que se bajaran no provinieran del mismo grupo de
sitios, OpenBSD permitir&iacute;a las extensiones filename:0 a
filename:9, en cuyo caso usar&iacute;a MASTER_SITES0 hasta
MASTER_SITES9 para bajar el fichero.
</p>

<p>
Es posible que algunas arquitecturas necesiten distfiles
espec&iacute;ficos.  En el pasado, esto ha causado problemas en donde
ha sido preciso replicar (&quot;mirror&quot;) distfiles.  OpenBSD
dispone de soporte para un tercer grupo de ficheros: SUPDISTFILES.
&Eacute;stos ser&aacute;n considerados s&oacute;lo para generar sumas
de comprobaci&oacute;n y r&eacute;plicas.  N&oacute;tese que es posible
que SUPDISTFILES tenga una coincidencia parcial con DISTFILES o
PATCHFILES.  Por ejemplo:
</p>

<pre>
	DISTFILES=foo-1.0.tgz
	.if ${ARCH} == &quot;i386&quot;
	DISTFILES+=foo-i386.tgz
	.elif ${ARCHI} == &quot;sparc&quot;
	DISTFILES+=foo-sparc.tgz
	.endif
	SUPDISTFILES=foo-i386.tgz foo-sparc.tgz
</pre>

<p>
<h3>La infraestructura de trabajo <code>workdir</code></h3>

<p>
No queremos portes que usen <code>NO_WRKDIR</code>.
Todos los portes de OpenBSD deben tener un directorio de trabajo.
Los detalles sobre el nombre de estos directorios de trabajo no tienen
porqu&eacute; ser la preocupaci&oacute;n de un &laquo;portador&raquo;.
Si necesita averiguar uno de estos nombres, mire en el fichero
Makefile: <code>cd ese_porte_dir &amp;&amp; make show
VARNAME=WRKDIR</code> le dar&aacute; una idea sobre el <code>WRKDIR</code>
(directorio de trabajo) de ese porte.
</p>

<p>
La principal raz&oacute;n detr&aacute;s de esa prohibici&oacute;n es
que en OpenBSD, <code>bsd.port.mk</code> act&uacute;a como un fichero
Makefile real, con dependencias.
El paso <code>fethc</code> depende de los distfiles y patchfiles, y el
resto de los pasos dependen de ficheros reales ubicados en el
directorio de trabajo (&quot;cookies&quot;), as&iacute; que no pueden
existir sin un directorio de trabajo.
</p>

<p>
Debido a un accidente hist&oacute;rico, el fragmento
<code>do-extract</code> crea el directorio de trabajo.
De acuerdo con esto, <code>pre-extract</code> y <code>do-extract</code>
<em>nunca</em> se deber&iacute;an anular.
Si la extracci&oacute;n de DISTFILES es especial, configure
</p>

<pre>
EXTRACT_ONLY=
</pre> 

<p>
y lleve a cabo la extracci&oacute;n en <code>post-extract</code>.
</p>

<dl>
<dt>WRKDIR</dt>

<dd>Directorio de trabajo del porte, en donde pone sus propios
&quot;cookies&quot;.</dd>

<dt>WRKDIST</dt>

<dd>Subdirectorio de WRKDIR, en donde el porte se desempaqueta.
Tambi&eacute;n es el directorio base para parches.  Otros BSD no tienen
en la actualidad la distinci&oacute;n WRKDIST/WRKSRC, y s&oacute;lo
tienen WRKSRC.</dd>

<dt>WRKSRC</dt>

<dd>Subdirectorio de WRKDIST, en donde est&aacute;n ubicados los
fuentes.</dd>

<dt>WRKBUILD</dt>

<dd>Subdirectorio de WRKDIR, en donde tendr&aacute; lugar la
configuraci&oacute;n y compilaci&oacute;n del porte.  Otros BSD no
tienen la distinci&oacute;n WRKBUILD/WRKSRC.  Los programas que se
basen en autoconf (la mayor&iacute;a) pueden generalmente configurar
SEPARATE_BUILD para dejar que la compilaci&oacute;n del porte sea en un
WRKBUILD diferente a WRKSRC.</dd>

<dt>WRKINST</dt>

<dd>Directorio en donde se instalar&aacute; el porte antes de ser
empaquetado (ver &laquo;Falsificaci&oacute;n de portes&raquo;,
m&aacute;s abajo).</dd>
</dl>

<p>
<em>Nota: NO_WRKSUBDIR ha sido eliminado;  su funcionalidad se puede
obtener configurando WRKDIST=$(WRKDIR).</em>
</p>

<h3>Falsificar portes</h3>

<h4>Introducci&oacute;n</h4>

<p>
Despu&eacute;s de que una compilaci&oacute;n se ha completado, otros
BSD proceden con la instalaci&oacute;n del porte y a
continuaci&oacute;n compilan un paquete con el porte instalado.
<br>
En lugar de eso, OpenBSD usa una instalaci&oacute;n falsa.  Usando
FAKE, el &aacute;rbol de portes no se convierte del todo, pero se va
aproximando.
</p>

<ul>
<li>Un porte falso se configura y compila normalmente (v.g., para
    instalarse en <code>PREFIX</code>, que suele ser
    /usr/local</code>).</li>

<li>Pero se le indica que se instale en otra parte, en
    <code>WRKINST</code>, que suele ser un subdirectorio de
    <code>WRKDIR</code>.</li>

<li>Entonces se empaqueta la falsa instalaci&oacute;n, usando la
    opci&oacute;n -s de pkg_create.</li>

<li>Finalmente, el paquete resultante puede ser instalado usando
    pkg_add.</li>
</ul>

<h4>Ventajas</h4>

<ul>
<li>Para quien construye el paquete, esto significa que la
    mayor&iacute;a de portes no tienen que ser instalados, lo que
    elimina un gran n&uacute;mero de compromisos potenciales y
    desagrado general debido a portes mal instalados.  Tambi&eacute;n
    permite construir varios paquetes con conflictos entre s&iacute; en
    la misma m&aacute;quina.  Finalmente, permite construir un nuevo
    grupo de paquetes no probados sin tener que hacer una
    instalaci&oacute;n correcta.</li>

<li>Para quien construye un porte, simplifica enormemente la labor de
    encontrar problemas en listas de paquetes, ya que el &aacute;rea
    falsa de instalaci&oacute;n se encuentra vac&iacute;a antes de que
    sea instalado el porte.  Adem&aacute;s, si un porte instala
    demasiados ficheros, ya no es necesario retocar la
    instalaci&oacute;n del porte:  es suficiente con no grabar los
    ficheros extra&ntilde;os en la lista de empaquetado.</li>

<li>Para el usuario final, mejora la calidad de los paquetes;  ya que
    el porte final se instala usando pkg_add, el usuario final obtiene
    <em>exactamente</em> el mismo software que fue preparado en la
    m&aacute;quina del portador.</li>
</ul>

<h4>C&oacute;mo hacerlo</h4>

<p>
Los objetivos invocados para <code>make fake</code> son los objetivos
de instalaci&oacute;n usuales, excepto unas pocas diferencias:
</p>

<ul>
<li>Se usa FAKE_FLAGS en lugar de MAKE_FLAGS.
    Por definici&oacute;n, FAKE_FLAGS configura
    DESTDIR=${WRKINST}.</li>

<li>Se usa FAKE_TARGET en lugar de INSTALL_TARGET.</li>

<li>Los fragmentos {pre,per,post}-instalaci&oacute;n se invocan con
    TRUEPREFIX configurado a $(PREFIX), PREFIX configurado a
    $(WRKINST)$(PREFIX), y DESTDIR configurado a $(WRKINST).</li>
</ul>

<p>
Los portes que usen imake deber&iacute;an funcionar tal cual, ya que
los fragmentos imake est&aacute;n configurados para usar DESTDIR.
De forma parecida, los portes recientes que usen GNU configure no
deber&iacute;an necesitar ning&uacute;n cambio.
</p>

<p>
Otra t&eacute;cnica &uacute;til es un truco de `ligado tard&iacute;o':
configure los portes para usar un prefijo $(DESTDIR)/usr/local, de modo
que el fichero Makefile resultante tenga
</p>

<pre>
prefix=$(DESTDIR)/usr/local
</pre>

<p>
configurado.
Cuando el porte se compile, y puesto que DESTDIR est&aacute;
configurado a nada, se usar&aacute; /usr/local y la falsa
instalaci&oacute;n pondr&aacute; todo en WRKINST/usr/local (v.g., para
portes que usen GNU configure, utilice
<code>CONFIGURE_STYLE= gnu dest</code>).
</p>

<h4>Dificultades</h4>

<ul>
<li>Algunos portes son inconsistentes procesando sus DESTDIR: la
    mayor&iacute;a de portes van bien con DESTDIR activado, excepto uno
    &oacute; dos.
    Solucione el problema con parches.</li>

<li>Lleve cuidado al distinguir entre la ubicaci&oacute;n real en donde
    est&aacute; instalado el porte, y la ubicaci&oacute;n grabada en los
    ficheros de configuraci&oacute;n del paquete.
    Es muy f&aacute;cil saltarse esto, pero tambi&eacute;n es f&aacute;cil
    de solucionar usando TRUEPREFIX.</li>

<li>Siempre hay que retocar los enlaces simb&oacute;licos absolutos.
    Por suerte, <code>bsd.port.mk</code> se dar&aacute; cuenta de los
    problemas en ese &aacute;rea.</li>

<li>Unos pocos portes no quieren dejar $(DESTDIR) s&oacute;lo durante
    la configuraci&oacute;n.
    Se necesita un fragmento de postconfiguraci&oacute;n que retoque
    todos los ficheros Makefile para a&ntilde;adir DESTDIR.</li>

<li>Raras veces, un porte se resistir&aacute; a todos lo intentos
    razonables por usar FAKE.
    Una aproximaci&oacute;n de fuerza bruta deber&iacute;a funcionar:
    use pre-fake para enlazar o copiar todo lo que el porte quiera
    encontrar en el &aacute;rea WRKINST, y entonces lleve a cabo la
    instalaci&oacute;n bajo chroot.</li>
</ul>

<h3>&laquo;Sabores&raquo;</h3>

<p>
Las opciones se han racionalizado como &laquo;sabores&raquo;, para que
la construcci&oacute;n de paquetes pueda ser consistente.
Un porte con opciones debe configurar FLAVORS a la lista de todas las
opciones que tengan sentido para ese porte (v.g., FLAVORS=foo bar
zoinx), y entonces usar FLAVOR para verificar qu&eacute; opciones han
sido seleccionadas (v.g., FLAVOR=zoinx foo).<br>
bsd.port.mk provee algo de soporte:
</p>

<ul>
<li>PKGNAME se retoca para incluir opciones separadas por guiones
    (v.g., package-foo-zoinx).</li>

<li>WRKDIR se retoca para que se puedan compilar sabores distintos de
    forma concurrente sin que colisionen.</li>

<li>Las construcciones de la forma %%flavor%% activar&acute;n la
    inclusi&oacute;n de PFRAG.flavor.  La construcci&oacute;n
    %%SHARED%% activa la inclusi&oacute;n de PFRAG.shared.</li>

<li>bsd.port.subdir.mk entiende la extensi&oacute;n
    SUBDIR=directory,opt1,opt2 para decir &laquo;compila el porte en
    directorio con FLAVOR=opt1 opt2&raquo;.</li>
</ul>

<p>
Comprobar que un sabor dado ha sido seleccionado es tan simple como:
</p>

<pre>
.if ${FLAVOR:L}=&quot;zoinx foo&quot;
</pre>

<p>
Comprobar que un sabor contiene una opci&oacute;n dada no es mucho
m&aacute;s complicado:
</p>

<pre>
.if ${FLAVOR:L:Mzoinx}
</pre>

<hr>

<small>
Originally [OpenBSD: diffs.html,v 1.7 2001/03/28 14:57:16 espie Exp ]<br>
$Translation: diffs.html,v 1.5 2001/04/06 15:56:53 horacio Exp $<br>
$OpenBSD: diffs.html,v 1.4 2001/04/07 08:03:08 jufi Exp $
</small>

</body>
</html>
