<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-2022-jp">
<meta name="resource-type" content="document">
<meta name="description" content=
"Differences with other BSD porting systems.">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 2000 by OpenBSD.">
<title>Differences from other BSD port systems</title>
</head>
<body text="Black" bgcolor="White" link="#23238E">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]">

<h1>OpenBSD の port 作成のための情報</h1>

<h2><font color="#e00000">他の BSD プロジェクトとの
重要な差異</font></h2>

<p>
NetBSD では、<em>ports</em> という用語を、アーキテクチャ依存のものとして使用しています。
その代わりに、彼らの ports の枠組は <em>packages</em> と呼ばれています。
</p>

<h3>特別のサポート</h3>
ports のためのインフラストラクチャは、新しい ports を生成するための機能を持つ、
以下のようないくつかのスクリプトを含みます。
<dl>
<dt>build/resolve-lib
    <dd>共有ライブラリの依存性を検証するため、<code>make lib-depends-check</code>
    から呼び出されます。
<dt>build/update-patches
    <dd><strong>常にパッチを再生成させるため</strong>、<code>make update-patches</code>
    から呼び出されます。
<dt>install/make-plist
    <dd><code>make update-plist</code> から呼び出されます。これは、
    正確なパッキングリストを作成するのに最も良い点のほとんどの部分を管理しています。
    OpenBSD のパッキングリストは、他の BSD プロジェクトとは大きく異なりますが、その理由のひとつに
    パッケージツールが完全に書き直されたことがあります。
</dl>

<h3>一般的なインフラストラクチャの問題</h3>

<p>
OpenBSD の make は、変数の値を大文字や小文字に変換するために、
<code>${VAR:U}</code> および <code>${VAR:L}</code> をサポートします。
このため、make の条件テストは、たとえば以下の例のように、
大文字・小文字に依存しない形でコーディングすべきです。
</p>

<pre>
	.if ${NEED_XXX:L} == "yes"
	do stuff if yes
	.else
	do other stuff
	.endif
</pre>

<p>
理論的には、<code>bsd.port.mk</code> が認識するすべてのブール変数は、
常に定義されているべきなので、<code>defined(USE_FOO)</code>
のようなコードを必要とすべきではなく、<code>${USE_FOO:L} != "no"</code>
が動作しなければなりません。
</p>

<p>
主となる <code>bsd.port.mk</code> ファイルは、大変効率化され、
修正されました。特に、並列 make が可能になっています。
<code>scripts/{pre,do,post}-*</code> の機能は、このプロセスから
なくなりました。この機能を置き換えるため、Makefile から手動で
スクリプトを呼び出してください。
</p>

<h3>make の正しい使用法</h3>

<p>
もし、<code>make VAR=value</code> として make を実行する場合には、Makefile
から得られた VAR の値がどのようなものであっても、その値の割り当てに優先することに
注意してください。ですから、多くの場合、Makefile のパッチは不要ですので、
メンテナンスの負荷を軽減するためには、MAKE_FLAGS を正確に設定する方が
ずっと良いでしょう。
</p>

<h3>ソースの取得</h3>

<p>
ソースアーカイブには、DISTFILES と PATCHFILES の 2 種類があります。
OpenBSD ではそれらを同じ方法で処理し、デフォルトでは MASTER_SITES
からすべてのものを受け取ります。PATCH_SITES や PATCH_SITES_SUBDIR
は存在<strong>しない</strong>のです。
</p>

<p>
OpenBSD は filename:0 から filename:9 までの拡張を許していますので、
もし、同一のサイトから必要なすべてのファイルを取得できなかった場合には、
たとえば、ファイルを受け取るために MASTER_SITES0 から MASTER_SITES9
まで使用されることになります。
</p>

<p>
いくつかのアーキテクチャでは、特定の配布ファイルが必要になるかも知れません。以前は
これが原因で、配布ファイルのミラーリングが関係したトラブルになることがありました。
OpenBSD は、SUPDISTFILES で 3 つ目のファイルのセットをサポートしています。これらは、
チェックサムの生成やミラーリングの目的のためだけに用意されているものと考えられます。
SUPDISTFILES は、たとえば、以下の例のように DISTFILES や PATCHFILES と重複している
かも知れないということに注意してください。
</p>

<pre>
	DISTFILES=foo-1.0.tgz
	.if ${ARCH} == "i386"
	DISTFILES+=foo-i386.tgz
	.elif ${ARCHI} == "sparc"
	DISTFILES+=foo-sparc.tgz
	.endif
	SUPDISTFILES=foo-i386.tgz foo-sparc.tgz
</pre>

<h3><code>WRKDIR</code> インフラストラクチャ</h3>

<p>
私たちは <code>NO_WRKDIR</code> を使用するような ports は欲しくはありません。
すべての OpenBSD の ports は作業用ディレクトリが指定されていなければなりません。
これらの作業用ディレクトリの命名の詳細は、port 作成者に関係のないようにすべきです。
もし、これらの名前を見つけたい場合には、Makefile を参照してください。
<code>cd that_ports_dir &amp;&amp; make show VARNAME=WRKDIR</code> とすれば、
その ports の <code>WRKDIR</code> を見ることができるはずです。
</p>

<p>
作業用ディレクトリない ports を禁止する主な理由は、OpenBSD の <code>bsd.port.mk</code>
が、実際の Makefile のように振る舞い、依存性があるからです。
<code>fetch</code> のステージは、配布ファイルやパッチファイルに依存し、
これ以外のすべてのステージは、作業用ディレクトリ (やクッキー) に存在する
実際のファイルに依存しているので、これらのファイルは
作業用ディレクトリなしに存在することができないのです。
</p>

もし、DISTFILES の展開が特殊である場合には、
</p>

<pre>
EXTRACT_ONLY=
</pre>

<p>
を設定し、そして <code>post-extract</code> の展開を実行してください。
</p>

<dl>
<dt>WRKDIR</dt>

<dd>ports が自分自身のクッキーを置くための
作業用ディレクトリです。</dd>

<dt>WRKDIST</dt>

<dd>WRKDIR のサブディレクトリで、ここで ports が実際に展開されます。
ここはまた、パッチを適用するためのベースディレクトリでもあります。
他の BSD は、現状では WRKDIST/WRKSRC を区別せず、WRKSRC
を持つのみです。</dd>

<dt>WRKSRC</dt>

<dd>WRKDIST のサブディレクトリで、ここに実際のソースが
置かれます。</dd>

<dt>WRKBUILD</dt>

<dd>WRKDIR のサブディレクトリで、ここで ports のコンフィギュアとビルドが
行われます。他の BSD は、WRKBUILD/WRKSRC を区別していません。
autoconf に基づくプログラムは、WRKSRC と区別された WRKBUILD の中で
ports のビルドを行わせるようにするため、SEPARATE_BUILD を (ほぼ)
普通にセットすることができます。</dd>

<dt>WRKCONF</dt>

<dd>WRKDIR のサブディレクトリで、コンフィギュアスクリプトはここで実行されるべきです。
省略時は WRKBUILD が使用されますが、十中八九問題ありません。</dd>

<dt>WRKINST</dt>

<dd>packages を作成するために ports がインストールされるディレクトリです
(下記の ports の仮インストールを参照してください)。</dd>
</dl>

<p>
<em>NO_WRKSUBDIR は削除されたことに注意してください。WRKDIST=$(WRKDIR)
を設定することで、この機能を代替可能です。</em>
</p>

<h3>ports の仮インストール</h3>

<h4>はじめに</h4>

<p>
ビルドの完了後、他の BSD では ports のインストールが行われ、その後に
インストールされた ports から packages のビルドが行われます。OpenBSD
では、その代わりに仮のインストールが使用されます。
</p>

<ul>
<li>OpenBSD の port は普通にコンフィギュアが行われ、ビルドされます
(たとえば、通常は <code>/usr/local</code> である <code>PREFIX</code>
の下にインストールされるように...)。</li>

<li>しかし、実際には他の場所、通常は WRKDIR のサブディレクトリの WRKINST
と名付けられたところの下にインストールされるよう指示されます。</li>

<li>そして、本物ではないインストールされた物は、pkg_create の -B
オプションを使用して packages として作成されます。</li>

<li>最終的に、pkg_add を使用してインストール可能な packages
が得られます。</li>
</ul>

<h4>優位性</h4>

<ul>
<li>packages 作成者にとって、これはほとんどの ports は実際にはインストールされる
必要がないことを意味し、多数の潜在的な妥協や正常にインストールされなかった ports
による一般的な障害を回避することができます。それはまた、同じマシン上で、
いくつかの互いに対立するような packages を構築できるということも意味していますし、
そしてさらには、正常なインストールを行わなくても、テストが行われていない新しい
packages を構築できるということでもあるのです。</li>

<li>ports の作者にとっては、ports がインストールされるまでは、仮の
インストール場所は空の領域ですので、パックするリストの問題点を見つける作業が
非常に簡単になります。そしてまた、ports が非常に多数のファイルをインストール
する場合でも、特に ports のインストールに関する微調整を行う必要はありません。
なぜなら、パックするリストの中に無関係なファイルを書かないようにするだけで
十分だからです。</li>

<li>エンドユーザにとっては、これは packages の質を改善します。なぜなら、
最終的な ports は pkg_add を使用してインストールされ、エンドユーザは
port 作成者のマシン上に用意されたソフトウェアと<em>厳密に</em>同じものが
得られるからです。</li>
</ul>

<h4>その方法</h4>

<p>
以下のようなわずかな違いを除いて、<code>make fake</code> で呼び出される
ターゲットが、通常はインストールされるターゲットになります。
</p>

<ul>
<li>MAKE_FLAGS の代わりに FAKE_FLAGS が使用されます。デフォルトでは、
FAKE_FLAGS は DESTDIR=${WRKINST} をセットします。</li>

<li>INSTALL_TARGET の代わりに FAKE_TARGET が使用されます。</li>

<li>{pre,do,post}-install という要素が TRUEPREFIX を $(PREFIX) に、
PREFIX を $(WRKINST)$(PREFIX) に、そして DESTDIR を $(WRKINST) に
セットした上で呼び出されます。</li>
</ul>

<p>
imake の要素は DESTDIR を使用するように構成されるので、imake を使用する
ports も、そのとおりに動作すべきです。同様にして、最近の GNU configure
を使用する ports も無変更で動作すべきです。
</p>

<p>
もうひとつの良いテクニックは、「遅延構築」の裏技です。Makefile
が以下の行を含むようにするため、ports が $(DESTDIR)/usr/local
を使用するように構成します。
</p>

<pre>
prefix=$(DESTDIR)/usr/local
</pre>

<p>
ports がビルドされる際に、DESTDIR には何もセットされていないので、
/usr/local が使用されます。そして、仮インストールでは、すべてのものが
WRKINST/usr/local の下に置かれます (例: GNU configure では、
<code>CONFIGURE_STYLE= gnu dest</code> を使用します)。
</p>

<h4>落とし穴</h4>

<ul>
<li>いくつかの ports は、その DESTDIR の処理に一貫性がありません。
ひとつかふたつの違反を除けば、ほとんどの ports は DESTDIR の組み合わせに
問題を抱えてはいません。パッチを当てて問題を解決してください。</li>

<li>ports がインストールされる実際の場所と packages
の構成ファイルに記録されている場所との区別には、
十分に注意してください。これはいとも簡単に見過ごしてしまうことですが、
TRUEPREFIX を使用して修正するのも簡単なことなのです。</li>

<li>絶対的なシンボリックリンクは、必ず微調整を必要とします。幸運にも
<code>bsd.port.mk</code> は、この領域の問題に対して警告してくれます。</li>

<li>少数の ports は、configure の段階で $(DESTDIR)
をそのままにしておいてくれません。すべての Makefiles に対して DESTDIR
を追加してくれる post-configure の要素が必要になります。</li>

<li>めったにないことですが、ports の仮インストールを行おうとする正当な試みが
すべて失敗することがあります。ports が見つけようとするすべてのものを WRKINST
の領域にコピーするかリンクするという pre-fake を使用するという、強引なアプローチを
使用できる場合があります。その場合、chroot 環境下でインストールを実行してください。</li>
</ul>

<h3>パッケージ化ツール</h3>

<p>
パッケージ化ツールは非常に少数のファイルタイプをサポートし、かつ
自動で多くのことをします。ほとんどの場合 <code>@exec</code> コマンドまたは
<code>INSTALL</code> スクリプトは必要とされません。<br>
<em>注: 不必要なスクリプトは禁止すべきです。なぜなら拡張性に関する
問題を有するからです。単一のパッケージ環境をデバッグすることは、新たな問題を
処理するために数百のスクリプトを変更することに比べて遥かに簡単だからです。
</em><br>
例えば:
</p>

<ul>
<li><code>@exec ldconfig</code> は必要ありません。なぜなら共有ライブラリは
<code>@lib libfoo.so.1.0</code> のように指示され、<code>ldconfig</code> は
必要なとき実行されるからです。また chroot も正しく使用されます。</li>
<li><code>@exec install-info</code> は必要ありません。なぜなら info 文書ファイルは
<code>@info file.info</code> のように指示されるからです。これはまた
複数の info ファイルを処理し、<code>makeinfo --no-split</code> する必要性を
除去します。</li>
<li>フォントは <code>@font</code> と <code>@fontdir</code> によって自動的に
統合されます。</li>
<li>新規ユーザーおよびグループは、インストール用スクリプトの代わりに <code>@newuser</code> と 
<code>@newgroup</code> により作成されます。新規ユーザーやグループはまた、以降に続く
パッケージ抽出処理時に利用可能となるよう、充分早い段階に作成されます。</li>
<li>コンフィギュレーションファイルは、インストール用スクリプトの代わりに
<code>@sample</code> によって処理されます。
</ul>

<p>
より詳細な内容は、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_create&amp;sektion=1&amp;format=html">pkg_create(1)</a>
を参照してください。ほとんどの場合、
<code>make update-plist</code> とすることで、非常に的確な完全パッキングリストの概要が
得られます。またあるバージョンから次のバージョンへの、手作業のような微調整が
可能になります。
</p>

<h3>フレーバ</h3>

<p>
オプションはフレーバとして合理化されていますので、packages の構築に一貫性を
持たせることができます。オプションを持つ ports は、その ports が理解可能な
すべてのオプションのリストを、(たとえば、FLAVORS=foo bar zoinx のように)
FLAVORS に設定すべきです。そして、実際に選択されたオプションが何であるのかを
テストするには、(たとえば、FLAVOR=zoinx foo のように) FLAVOR を使用します。
<code>bsd.port.mk</code> は、以下のようなものをいくつかサポートしています。
</p>

<ul>
<li>PKGNAME は、(たとえば package-foo-zoinx のように) ハイフンで
分けられたオプションを含むよう調整されます。</li>

<li>WRKDIR は、衝突することなく同時に構築できるフレーバを区別するために
調整されます。</li>

<li>%%flavor%% という形態での構築は、PFRAG.flavor を含む
きっかけとなります。また、%%SHARED%% という構成は、PFRAG.shared
を含むきっかけとなります。</li>

<li>bsd.port.subdir.mk は、`FLAVOR=opt1 opt2 用のディレクトリで ports
をビルドする' ということを宣言するための SUBDIR=directory,opt1,opt2
という拡張を理解します。</li>
</ul>

<p>
与えられたフレーバが選択されたかどうかは、以下のように簡単にチェックすることができます。
</p>

<pre>
.if ${FLAVOR:L:Mzoinx}
</pre>

MULTI_PACKAGES として知られる特別の拡張があります。一般的に言えば、
MULTI_PACKAGES と FLAVORS とは直交するメカニズムです。これらは、
多数の別の packages を構築するために、単一の ports の
ひとつのディレクトリを許容するので、OpenBSD の ports ツリーが
他の BSD よりいくぶん小さくなるのに役立っています。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5&amp;format=html">bsd.port.mk(5)</a> は
FLAVORS および MULTI_PACKAGES 専用のすべてのセクションを持っています。

<hr>

<small>
<!--
Originally [OpenBSD: diffs.html,v 1.18 ]
$Translation: diffs.html,v 1.6 2006/01/01 11:48:35 kimitake Exp $
-->
$OpenBSD: diffs.html,v 1.7 2006/01/02 06:51:10 saad Exp $
</small>

</body>
</html>
