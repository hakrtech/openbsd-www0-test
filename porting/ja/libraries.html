<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-2022-jp">
<meta name="resource-type" content="document">
<meta name="description" content=
"Quick guide to writing ports">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content=
"This document copyright 2001 by OpenBSD.">
<title>Handling shared libraries in the OpenBSD ports tree</title>
</head>
<body text="Black" bgcolor="White" link="#23238E">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]"> 

<h1>ports ツリーでは、共有ライブラリをどのように扱うか</h1>

<h2>共有ライブラリの採番ルールを理解する</h2>
共有ライブラリには、さまざまな理由により、若干トリッキーなところがあります。
ですので、<code>libfoo.so.major.minor</code> のような、
ライブラリの名前付けの仕組みを覚える必要があります。
</p>
プログラムをリンクする場合、リンカ <code>ld</code> は生成されたバイナリに
情報を埋め込みます。この情報は、<code>ldd</code> で見ることができます。
その後、プログラムを実行する際に、ダイナミックリンカ <code>ld.so</code> は、
次のようにして正しいダイナミックライブラリを見つけるために、この情報を利用します。
<ul>
	<li>厳密に同じメジャー番号のライブラリが要求されます。
	<li>同じかそれ以上のマイナー番号のライブラリが要求されます。
</ul>
つまり、これは、メジャー番号が同じで、マイナー番号が同じかそれ以上の
<strong>すべての</strong>ライブラリは、<strong>プログラムが期待するバイナリ API
を満足しなければならない</strong>ことを意味します。そのようになっていない場合には、
その ports は壊れているということになります。具体的には、ユーザが自分のシステムを
更新しようとするのを不可能にしてしまうことになるでしょう。
</p>
共有ライブラリのルールは極めて単純なものです。
<ul>
	<li>ライブラリに関数を追加した場合には、ライブラリのマイナー番号を
増加させなければなりません。それは、この関数を必要とするプログラムが、少なくとも
このバージョンを明示的に問い合わせずに、この関数を要求する手段はないからです。
	<li>既存の API を変更した場合や、何かの関数のシグネチャが変わってしまった場合、
正当な呼び出し手順がもはや正当なものではなくなってしまった場合、あるいは
互換性のない型の変更が加えられた場合には、ライブラリのメジャー番号を
<strong>増加させなければなりません</strong>。
	<li>これは、古い関数を削除する場合にも当てはまります。
どのような関数の削除であっても、メジャー番号は増加することになります。
</ul>
</p>
ときどき、ライブラリがいくつかのファイルとして書かれていて、その内部関数が
これらのファイルの間で通信する必要があるために見えてしまうことがあります。
このような関数名は伝統的にアンダースコアから始まっていて、これらは正当な
API の一部ではありません。
</p>
このライブラリの命名ほ枠組は、それが ELF か a.out かに関係なく、OpenBSD
プラットフォームのいたるところに存在するものであるということに注意してください。

<h2>ports ビルド時に正しい名前を受け取るための微調整</h2>
ごく一部の ports は、どのようにしても、共有ライブラリを正しくビルドするための微調整を必要とします。
共有ライブラリのビルドは、次のように行うべきであるということを思い出してください。
<code>gcc -shared -fpic|-fPIC -o libfoo.so.4.5 obj1 obj2</code>
</p>
バージョン番号の調整後にライブラリ名を変更することはできません。なぜなら、
ELF ライブラリはライブラリの内部名を設定するのに、いくつかの特別なマジックを
使用しているからで、最初から正しいバージョンをリンクしておく必要があります。
</p>
この一方で、ports の Makefile 中の <code>MAKE_FLAGS</code> を使用して、Makefile
の変数をコマンドラインから優先指定することができるということを思い出してください。
これはたとえば、libtool ベースの ports にとっては、実に価値のあることであり、それが
生成するそれぞれのライブラリ用に、ひとつのこのようなバージョン変数が用意れています。

<h2>ユーザに見えるすべてのライブラリは /usr/local/lib に置くように</h2>
一般的に、ldconfig のパスにディレクトリを追加するようユーザに要求するのは、
非常に悪い方法です。なぜなら、プログラムに直接リンクされるすべての共有
ライブラリは /usr/local/lib に現れるべきであるからです。しかしながら、
これは実際のライブラリへのシンボリックリンクを使用して簡単に実現できます。
以下のようなライブラリ参照ルールを理解しておいてください。
<ul>
	<li>ビルド時には、<code>ld</code> はライブラリを探索するパスを設定するのに
<code>-L</code> フラグを使用します。そして、その要求にマッチするライブラリを
見つけた時点で直ちに探索を停止します。
	<li>実行時には、<code>ld.so</code> は要求されたライブラリを探すのに
<code>ldconfig</code> によってキャッシュされた情報を使用します。
</ul>

ここで、<code>qt.1.45</code> と <code>qt.2.31</code> という、メジャーバージョンの
異なるふたつのライブラリを提供するふたつの ports があると仮定します。
どちらの ports も同時にインストール可能でなければならないので、与えられたプログラムが
<code>/usr/local/lib/qt/libqt.so.1.45</code> として用意されたライブラリ qt.1 を確実に
リンクできるよう、<code>ld -o program program.o -L/usr/local/lib/qt -lqt</code>
を使用してプログラムはリンクされます。
同様に、qt.2 とリンクされるプログラムは、
<code>ld -o program program.o -L/usr/local/lib/qt2 -lqt</code> で
<code>/usr/local/lib/qt2/libqt.so.2.31</code> ファイルを使用します。
</p>
これらのライブラリを実行時に解決するため、
<code>/usr/local/lib/libqt.so.1.45</code> を呼ぶリンクと
<code>/usr/local/lib/libqt.so.2.31</code> を呼ぶリンクとが用意されます。
<code>ld.so</code> にはこれで十分です。
</p>
<code>ld -o program program.o -L/usr/local/lib -lqt</code> で
qt1 を使用するプログラムをリンクしようとするとエラーになります。
これは、このコードが <code>qt.2.31</code> がインストールされていない
ことを仮定しているためですが、もちろんこれは間違った仮定です。
</p>
このようなトリックは、非常に普及したライブラリにおけるメジャーバージョンの
移行期のような稀な場合にのみ必要となるものです。
一般的には、ライブラリが <code>/usr/local/lib</code>
に確実に現れるようにするので十分です。
<h2>ライブラリの依存性を正確に記述</h2>
新しい依存性のコードは完全なライブラリの依存性を必要とします。ports が意図する
すべてのライブラリの必要性を検査するために <code>make lib-depends-check</code>
を使用しなければなりません。ライブラリの仕様は、
<code>LIB_DEPENDS=gtk.1.2,gdk.1.2::x11/gtk+</code>
のようにカンマで区切ってください。
</p>
また、LIB_DEPENDS 行にスタティックライブラリを指定しても間違いではありません。
LIB_DEPENDS は、パッケージのビルド時に完全に評価されます。その結果として、
ビルド時に使用された実際の メジャー.マイナー 番号を保持する <code>ld.so</code>
用の行として組み込まれたライブラリの依存情報を持ちますが、
スタティックライブラリ用には何も持っていません。
</p>
そしてまた、ports が適切なライブラリ以上の何かを要求する場合、RUN_DEPENDS
を用意しなければなりません。これにより、共有ライブラリをサポートしていない
アーキテクチャ上で、ports を正しくビルドできるようになります。
</p>
事実、LIB_DEPENDS 行をスタティックライブラリ用に用意するのは良い考えでしょう。
なぜなら、依存性がスタティックライブラリからダイナミックライブラリに移ってしまった
ような場合でも、ports を簡単に更新できるからです。
</p>
LIB_DEPENDS 行には、<code>ld</code> が使用するのと
同一のパスを指定しなければなりません。たとえば、標準的な qt2 は
<code>LIB_DEPENDS+=lib/qt2/qt.2::x11/qt2</code> という一部分に
依存するので、ライブラリ依存の行は正しく解決されるでしょう。
これにより、同じライブラリの複数のバージョンに遭遇した場合でも、
依存性を検査するコードが正しく動作できるようになります。
<h2>ports を正しく更新</h2>
ですので、共有ライブラリを必要とする ports を更新または追加する場合でも、
正しく行わなければならない内容が少しあります。
<ul>
	<li>共有ライブラリの メジャー.マイナー 番号が正しいことを確認してください。
	<li>あなたの ports が依存するすべての ports を確認してください。そして、あなたの
変更に対し、それらが正しくビルドされているか確認してください。また、更新に関連するメンテナが、
自身の portsが今も正しく実行可能かどうか確認できるよう、彼らに報告してください。
	<li>依存する ports の LIB_DEPENDS を調整しなければならないかも知れません。
もし、新しい共有ライブラリを導入した場合には、LIB_DEPENDS に変える必要のある
BUILD_DEPENDS に注意してください。
	<li>新しい ports を導入する場合には、必ず、既存のライブラリと
干渉するようなライブラリを生成していないことを検査すべきです。ふたつの
ports の間でバージョン番号を採番する仕組が合致する機会を持たないので、
同じ名前のライブラリになるのは致命的なことです。あなたは、その状況を
そのソフトウェアの著者と解決すべきです (たとえば、libnet という名前の
ライブラリは間違いなく致命的な名前です)。
</ul>
  <hr>
  <a href="../../index.html"><img height=24 width=24 src=../../back.gif border=0 alt=OpenBSD></a> 
  <a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: libraries.html,v 1.4 ]
<br>
$Translation: libraries.html,v 1.2 2004/01/12 16:05:19 toshi Exp $
<br>
$OpenBSD: libraries.html,v 1.4 2004/05/09 09:58:24 saad Exp $
</small>
</body>
</html>
