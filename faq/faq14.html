<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Disk Setup</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq12.html">[To Section 12 - Platform-Specific Questions]</a>
</font>

<h1><font color="#e00000">14 - Disk Setup</font></h1><hr>

<h3>Table of Contents</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Using OpenBSD's disklabel(8)</a>
<li><a href="#fdisk"      >14.2 - Using OpenBSD's fdisk(8)</a>
<li><a href="#NewDisk"    >14.3 - Adding extra disks in OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - How to swap to a file</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - How does OpenBSD/i386 boot?</a>
<li><a href="#LargeDrive" >14.7 - What are the issues regarding large
    drives with OpenBSD?</a>
<li><a href="#InstBoot"   >14.8 - Installing Bootblocks - i386 specific</a>
<li><a href="#Backup"     >14.9 - Preparing for disaster: Backing up and
    Restoring from tape.</a>
<li><a href="#MountImage" >14.10 - Mounting disk images in OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - Help! I'm getting errors with IDE DMA!</a>
<li><a href="#RAID"       >14.13 - RAID options with OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Why does <tt>df(1)</tt> tell me I
    have over 100% of my disk +used?</a>
</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Using OpenBSD's disklabel(8)</h2>
<h3>Table of Contents</h3>

<ul>
<li><a href="#disklabel.1">What is disklabel(8)?</a>
<li><a href="#disklabel.2">disklabel(8) during the OpenBSD install</a>
<li><a href="#disklabel.3">Common disklabel(8) uses.</a>
</ul>

   
<a name="disklabel.1"></a>
<h3>What is disklabel(8)?</h3>
  
<p>
First be sure to read the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man page.

<p>
Disklabels are created to allow an efficient interface between your disk
and the disk drivers contained within the kernel. Labels hold certain
information about your disk, like your drive geometry and information
about your filesystems. This is then used by the bootstrap program to
load the drive and to know where filesystems are contained on the drive.
Labels are also used in conjunction with the filesystems to create a
more efficient environment. You can read more in-depth information about
disklabel by reading the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>
man page.

<p>
As an additional gain, using disklabel helps overcome architecture
limitations on disk partitioning. For example, on i386, you can only
have 4 primary partitions. (Partitions that other operating systems,  
such as Windows NT or DOS can see.) With 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
you use one of these 'primary' partitions to store *all* of your 
OpenBSD partitions (eg. 'swap', '/', '/usr' and '/var'). 
And you still have 3 more partitions available for other OSs!

<a name="disklabel.2"></a>
<h3>disklabel(8) during OpenBSD's install</h3>

<p>
One of the major parts of OpenBSD's install is your initial creation of
labels. This comes (for i386 users) directly after using
<a href="#fdisk">fdisk(1)</a>.
During the install you use disklabel to create your separate labels
which will contain your separate mountpoints. During the install, you
can set your mountpoints from within
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
but this isn't completely necessary considering you will be prompted
later to confirm you choices. But it does make your install go just a
little smoother.

<p>
Since this is during the install you won't have any existing labels, and
they will need to be created. The first label you will create is the
label 'a'. This label SHOULD be your where / will be mounted. You can
see recommended partitions that should be created and their sizes by
reading <a href="faq4.html#SpaceNeeded">FAQ 4, Space Needed</a>. For
servers it is recommended that you create at least these labels
separately. For desktop users creating one mountpoint at / will probably
suffice. When initially creating your root partition ( 'a' label ), keep
in mind that you will need SOME space left for your swap label. Now that
the basics have been explained, here is an example of using disklabel
during an install. In this first example it is assumed that OpenBSD will
be the only operating system on this computer, and that a full install
will be done.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
At this point we have created a 64M root partition mounted at /, and a
64Meg swap partition. Notice that the offset starts at sector 63. This
is what you want. When it comes to the size, disklabel will show your
size in sectors, however, you don't need to enter sizes in the same
format. Like the example above you can enter sizes in the manner of
<i>64 Megabytes = 64M</i> and <i>2 Gigabytes = 2G</i>. Disklabel will
then round to the nearest cylinder. In the example above you will also
notice that disklabel assumes that label 'b' will be a swap. This is a
correct assumption as the GENERIC kernel is set to look for swap on
label 'b', and you should just follow this guideline and use 'b' as your
swap area.

<p>
The next example will take you through the creation of two more labels.
This means that it's not a complete install, as the size of these won't
be enough to install OpenBSD to its fullest.  Showing the creation of
all the partitions would just be repetitive.

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
In the above example, there are two things you might notice. One being
that the offset is automatically figured out for you to be the next in
order. When doing an install of this sort, you won't need to mess with
changing the offsets at all. Another difference you might notice will be
that label 'c' has been skipped. This is done for a reason, which is
that label 'c' is a label that represents the whole disk.  For this
reason you shouldn't deal with label 'c' in any way.

<p>
Once all your labels have been created all that's left to do is write
the labels to disk, and move on in the installation process. To write
everything and quit disklabel (and continue with the install) do:


<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>

<a name="disklabel.3"></a>
<h3>Common uses for disklabel(8)</h3>

<p>
Once your system is installed, you shouldn't need to use disklabel too
often. But some times you will need to use disklabel when adding,
removing or restructuring your disks. One of the first things you will
need to do is view your current disklabel. To do this, simply type:

<pre>
# <b>disklabel wd0</b> &gt;----- Or whatever disk device you'd like to view

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
The above command simply allows you to view the existing disklabel,
ensuring that you don't mess anything up. ( Which we all need sometimes.
) But to be able to make changes you must use the -E option with
disklabel like so:

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
This will bring you to a prompt, the same as the one that you used
during the OpenBSD install. Probably the single most important command
at this prompt is '?'. This will give you a list of possible options
pertaining to disklabel. You can even view the entire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man page with the 'M' command. From this prompt, you will do all of your
adding, deleting and changing of partitions. For additional information
read the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man page.

<a name="fdisk"></a>
<h2>14.2 - Using fdisk(8)</h2>

First be sure to check the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
man page.

<p>
Fdisk is a program to help with the maintenance of your partitions. This
program is used at install time to set up your OpenBSD partition (this
partition can contain <u>several</u> labels, each with
filesystems/swap/etc.).  It can divide space on your drives and set one
active. This program will usually be used in Single User Mode ( boot -s
). Fdisk also sets the MBR on your various hard disks.

<p>
For installation purposes, most times you'll only need <b>ONE</b> OpenBSD
partition, and then using disklabel to put a swap and a filesystem on it.

<p>
To just view your partition table using fdisk, use:

<pre># <b>fdisk sd0</b><br>
</pre>

<p>
Which will give an output similar to this:

<pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD     
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
</pre>

<p>
In this example we are viewing the fdisk output of the first SCSI drive.
We can
see the OpenBSD partition (A6) and its size. The * tells us that the
OpenBSD partition is a bootable partition.

<p>
In the previous example we just viewed our information. What if we want
to edit our partition table? Well, to do so we must use the <b>-e</b>
flag.  This will bring up a command line prompt to interact with fdisk.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p> 
It is perfectly safe in fdisk to go in and explore, just make sure to
answer <b>N</b> to saving the changes and *DON'T* use the <b>write</b>
command.

<p>Here is an overview of the commands you can use when you choose the
<b>-e</b> flag.

<ul>
<li><b>help</b>  Display a list of commands that fdisk understands in
the interactive edit mode.
<li><b>reinit</b>  Initialize the currently selected, in-memory copy of
the boot block.
<li><b>disk</b>  Display the current drive geometry that fdisk has
probed. You are given a chance to edit it if you wish.
<li><b>setpid</b>  Change the partition identifier of the given
partition table entry. This command is particularly useful for
reassigning an existing partition to OpenBSD.
<li><b>edit</b>  Edit a given table entry in the memory copy of the
current boot block.  You may edit either in BIOS geometry mode, or in
sector offsets and sizes.
<li><b>flag</b>  Make the given partition table entry bootable. Only one
entry can be marked bootable. If you wish to boot from an extended
partition, you will need to mark the partition table entry for the
extended partition as bootable.
<li><b>update</b>  Update the machine code in the memory copy of the
currently selected boot block.
<li><b>select</b>  Select and load into memory the boot block pointed to
by the extended partition table entry in the current boot block.
<li><b>print</b>   Print the currently selected in-memory copy of the
boot block and its MBR table to the terminal.
<li><b>write</b>   Write the in-memory copy of the boot block
to disk. You will be asked to confirm this operation.
<li><b>exit</b>  Exit the current level of fdisk, either returning to
the previously selected in-memory copy of a boot block, or exiting the
program if there is none.
<li><b>quit</b>  Exit the current level of fdisk, either returning to
the previously selected in-memory copy of a boot block, or exiting the
program if there is none.  Unlike exit it does write the modified block
out.
<li><b>abort</b>   Quit program without saving current changes.
</ul>

<a name="NewDisk"></a>
<h2>14.3 - Adding extra disks in OpenBSD</h2>

<p>
Well once you get your disk installed <b>PROPERLY</b> you need to use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>i386 only</i>) and 
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
to set up your disk in OpenBSD.

<p>
For i386 folks, start with fdisk.  Other architectures can ignore this.
In the below example we're adding a third SCSI drive to the system. 
<pre>
# <b>fdisk -i sd2</b>
</pre>
This will initialize the disk's "real" partition table for exclusive use
by OpenBSD.
Next you need to create a disklabel for it.  This will seem confusing.
<pre>
# <b>disklabel -e sd2</b>

<i>(screen goes blank, your $EDITOR comes up)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

First, ignore the 'c' partition, it's always there and is for programs
like disklabel to function! 
Fstype for OpenBSD is 4.2BSD.
Total sectors is the total size of the disk.  Say
this is a 3 gigabyte disk.  Three gigabytes in disk manufacturer terms
is 3000 megabytes.  So divide 6185088/3000 (use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1))</a>.
You get 2061.  So, to make up partition sizes for a, d, e, f, g, ...
just multiply X*2061 to get X megabytes of space on that partition.
The offset for your first new partition should be the same as the
"sectors/track" reported earlier in disklabel's output.  For us it is
63.  The offset for each partition afterwards should be a combination of
the size of each partition and the offset of each partition (Except the
'c' partition, since it has no play into this equation.)

<p>
Or, if you just want one partition on the disk, say you will use the
whole thing for web storage or a home directory or something, just take
the total size of the disk and subtract the sectors per track from it.
6185088-63 = 6185025.  Your partition is

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>If all this seems needlessly complex, you can just use disklabel -E
to get the same partitioning mode that you got on your install disk!</b>
There, you can just use "96M" to specify "96 megabytes".  (Or, if you
have a disk big enough, 96G for 96 gigs!) Unfortunately, the -E mode
uses the BIOS disk geometry, not the real disk geometry, and often times
the two are not the same.  To get around this limitation, type 'g d' for
'geometry disk'.  (Other options are 'g b' for 'geometry bios' and 'g u'
for geometry user, or simply, what the label said before disklabel made
any changes.)

<p>
That was a lot.  But you are not finished.  Finally, you need to create
the filesystem on that disk using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
Or whatever your disk was named as per OpenBSD's disk numbering scheme.
(Look at the output from
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
to see what your disk was named by OpenBSD.)

<p>
Now figure out where you are going to mount this new partition you just created.
Say you want to put it on /u.  First, make the directory /u.  Then, mount it.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Finally, add it to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>.

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
What if you need to migrate an existing directory like /usr/local? You
should mount the new drive in /mnt and use <tt>cpio -pdum</tt> to copy /usr/local
to the /mnt directory.  Edit the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
file to show that the /usr/local partition is now /dev/sd2a (your
freshly formatted partition.) Example:

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Reboot into single user mode with <b>boot -s</b>, move the existing
/usr/local to /usr/local-backup (or delete it if you feel lucky) and
create an empty directory /usr/local. Then reboot the system, and voila,
the files are there!


<a name="SwapFile"></a>
<h2>14.4 - How to swap to a file</h2>

<p>
(Note: if you are looking to swap to a file because you are getting
&quot;virtual memory exhausted&quot; errors, you should try raising
the per-process limits first with 
csh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>,
or
sh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>.)

<p>
Swapping to a file doesn't require a custom built kernel, although that
can still be done, this faq will show you how to add swap space both
ways.

<h3>Swapping to a file. </h3>

<p>
Swapping to a file is easiest and quickest way to get extra swap space
setup.  The file must not reside on a filesystem which has SoftUpdates
enabled (they are disabled by default).  To start out, you can see how
much swap you currently have and how much you are using with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
utility. You can do this by using the command:

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
This shows the devices currently being used for swapping and their
current statistics. In the above example there is only one device named
&quot;swap_device&quot;. This is the predefined area on disk that is
used for swapping. (Shows up as partition b when viewing disklabels) As
you can also see in the above example, that device isn't getting much
use at the moment. But for the purposes of this document, we will act as
if an extra 32M is needed.

<p>
The first step to setting up a file as a swap device is to create the
file. It's best to do this with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
utility. Here is an example of creating the file <i>/var/swap</i> that
is 32M large.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Once this has been done, we can turn on swapping to that device. Use the
following command to turn on swapping to this device

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
Now we need to check to see if it has been correctly added to the list
of our swap devices.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Now that the file is setup and swapping is being done, you need to add a
line to your <i>/etc/fstab</i> file so that this file is configured on
the next boot time also. If this line is not added, your won't have this
swap device configured.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>Swapping via a vnode device</h3>

<p>
This is a more permanent solution to adding more swap space. To swap to
a file permanently, first make a kernel with vnd0c as swap. If you have
wd0a as root filesystem, wd0b is the previous swap, use this line in the
kernel configuration file (refer to compiling a new kernel if in doubt):

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
After this is done, the file which will be used for swapping needs to be
created. You should do this by using the same command as in the above
examples.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Now your file is in place, you need to add the file to you
<i>/etc/fstab</i>. Here is a sample line to boot with this device as
swap on boot.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
At this point your computer needs to be rebooted so that the kernel
changes can take place. Once this has been done it's time to configure
the device as swap. To do this you will use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
Now for the last step, turning on swapping to that device. We will do
this just like in the above examples, using swapctl(8). Then we will
check to see if it was correctly added to our list of swap devices.

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>


<p>
Soft Updates is based on an idea proposed by
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
and Yale Patt</a> and developed for FreeBSD by
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a>.
SoftUpdates imposes a partial ordering on the buffer cache
operations which permits the requirement for synchronous writing of
directory entries to be removed from the FFS code. Thus, a large
performance increase is seen in disk writing performance.

<p>
The potential of background fsck(8), using Soft Updates
is not yet realised in OpenBSD, so
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
is still required after an unclean shutdown.
This may be changed in future versions.

<p>
To use Soft Updates, your kernel must have

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
compiled in, this is already in place on GENERIC.

<p>
Enabling soft updates must be done with a mount-time option. When
mounting a partition with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a> 
utility, you can specify that you wish to have soft updates enabled on
that partition. Below is a sample
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
entry that has one partition <i>sd0a</i> that we wish to have mounted
with soft updates.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Note to sparc users: Do not enable soft updates on sun4 or sun4c
machines.  These architectures support only a very limited amount of
kernel memory and cannot use this feature.  However, sun4m machines are
fine.

<a name="Boot386"></a>
<h2>14.6 - How does OpenBSD/i386 boot?</h2>
The boot process for OpenBSD/i386 is not trivial, and understanding how
it works can be useful to troubleshoot a problem when things don't work.
There are four key pieces to the boot process:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> The Master Boot Record is the 
first physical sector (512 bytes) on the disk.
It contains the primary partition table and a small program to load
the Partition Boot Record (PBR).
Note that in some environments, the term "MBR" is used to refer to only
the code portion of this first block on the disk, rather than the whole
first block (including the partition table).
It is critical to understand the meaning of "initialize the MBR" -- in
the terminology of OpenBSD, it would involve rewriting the entire MBR
sector, not just the code, as it might on some systems.
You will rarely want to do this.
Instead, use fdisk(8)'s "-u" command line option
("<tt>fdisk -u wd0</tt>").

<p>
While OpenBSD includes an MBR, you are not obliged
to use it, as virtually any MBR can boot OpenBSD.  
The MBR is manipulated by the fdisk(8) program, which is used both to 
edit the partition table, and also to install the MBR code on the 
disk.

<p>
OpenBSD's MBR announces itself with the message:
<pre>
    Using drive 0, partition 3.
</pre>
showing the disk and partition it is about to load the PBR from.
In addition to the obvious, it also shows a trailing period ("."), which
indicates this machine is capable of using LBA translation to boot.
If the machine were incapable of using LBA translation, the above
period would have have been replaced with a semicolon (";"), indicating
CHS translation:
<pre>
    Using Drive 0, Partition 3;
</pre>
Note that the trailing period or semicolon can be used as an indicator
of the "new" OpenBSD MBR, introduced with OpenBSD 3.5.

<li><b><i>Partition Boot Record (PBR):</i></b>
The Partition Boot Record, also called the PBR or 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(after the name of the file that holds the code) is the first physical
sector of the OpenBSD partition of the disk.
The PBR is the "first-stage boot loader" for OpenBSD.
It is loaded by the MBR code,
and has the task of loading the OpenBSD second-stage boot loader,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
Like the MBR, the PBR is a very tiny section of code and data,
only 512 bytes, total.
That's not enough to have a fully filesystem-aware application, so
rather than having the PBR locate <tt>/boot</tt> on the disk, the 
BIOS-accessible location of <tt>/boot</tt> is physically coded into the
PBR at installation time.

<p>
The PBR is installed by
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>,
which is further described <a href="faq14.html#InstBoot">later in this
document</a>.
The PBR announces itself with the message:
<pre>
    Loading...
</pre>
printing a dot for every file system block it attempts to load.
Again, the PBR shows if it is using LBA or CHS to load, if it has 
to use CHS translation, it displays a message with a semicolon:
<pre>
    Loading;... 
</pre>
The older (pre v3.5) biosboot(8) showed the message "<tt>reading
boot...</tt>.


<li><b><i>Second Stage Boot Loader, <tt>/boot</tt>:</i></b> <tt>/boot</tt> is
loaded by the PBR, and has the task of accessing the OpenBSD file system
through the machine's BIOS, and locating and loading the actual kernel.  
boot(8) also passes various options and information to the kernel.
<p>
boot(8) is an interactive program.  After it loads, it attempts to locate 
and read <tt>/etc/boot.conf</tt>, if it exists (which it does not on a 
default install), and processes any commands in it.  Unless instructed
otherwise by <tt>/etc/boot.conf</tt>, it then gives the user a prompt:

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.06
     boot>
</pre>
It gives the user (by default) five seconds to start giving it other
tasks, but if none are given before the timeout, it starts its default
behavior: loading the kernel, <tt>bsd</tt>, from the root partition of
the first hard drive.
The second-stage boot loader probes (examines) your system hardware,
through the BIOS (as the OpenBSD kernel is not loaded).
Above, you can see a few things it looked for and found:
<ul>
<li><b>pc0</b> - the standard keyboard and video display of a i386
system.
<li><b>com0, com1</b> - Two serial ports
<li><b>apm</b> - Advanced Power Management BIOS functions
<li><b>636k 190M</b> - The amount of conventional (below 1M) and
extended (above 1M) memory it found
<li><b>fd0 hd0+</b> - The BIOS disk devices found, in this case, one floppy and one hard
disk.
</ul>

The '+' character after the "hd0" indicates that the BIOS has told
<tt>/boot</tt> that this disk can be accessed via LBA.
When doing a first-time install, you will sometimes see a '*' after a
hard disk -- this indicates a disk that does not seem to have a valid
OpenBSD disk label on it. 


<li><b><i>Kernel: <tt>/bsd</tt></i>:</b>  This is the goal of the boot process,
to have the OpenBSD kernel loaded into RAM and properly running.
Once the kernel has loaded, OpenBSD accesses the hardware directly,
no longer through the BIOS.

</ol>

So, the very start of the boot process could look like this:
<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.06
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i><- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.5 (GENERIC) #34: Mon Mar 29 12:24:55 MST 2004
   ...
</pre></blockquote>


<h3>What can go wrong</h3>
<ul>
<li><b>Bad/invalid/incompatible MBR:</b>
Usually, a used hard disk has some MBR code in place, but if the
disk is new or moved from a different platform, AND you don't answer "Yes"
to the "Use entire disk" question of the <a href="faq4.html#Disks">installation
process</a>, you may end up with a disk without a valid MBR, and thus,
will not be bootable, even though it has a valid partition table.

<p>
You may install the OpenBSD MBR on your hard disk using the fdisk
program.  Boot from your install media, choose "Shell" to get a command
prompt:

<pre>
    # <b>fdisk -u wd0</b>
</pre>

You may also install a specific MBR to disk using fdisk:
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre> 

which will install the file <tt>/usr/mdec/mbr</tt> as your system's
MBR.
This particular file on a standard OpenBSD install happens
to be the standard MBR that is also built into fdisk, but any other
MBR could be specified here.

<li><b>Invalid <tt>/boot</tt> location installed in PBR:</b>
When installboot(8) installs the partition boot record, it writes the
block number and offset of <tt>/boot</tt>'s inode into the PBR.
Therefore, deleting and replacing <tt>/boot</tt> without re-running
<a href="faq14.html#InstBoot">installboot(8)</a> will render
your system unbootable, as the PBR will load whatever happens to be 
pointed to by the inode specified in it, which will almost certainly no
longer be the desired second-stage boot loader!

Since <tt>/boot</tt> is being read using BIOS calls, old verions of 
the PBR were sensitive to BIOS disk translation.
If you altered the
drive's geometry (i.e., took it out of one computer that uses CHS
translation and moving it into one that uses LBA translation, or even
changed a translation option in your BIOS), it would have <i>appeared to the BIOS</i>
to be in a different location (a different numerical block must be accessed
to get the same data from the disk), so you would have had to run
installboot(8) before the system could be rebooted.
The new (as of OpenBSD 3.5 and later) PBR is much more tollerant to 
changes in translation.
</ul>

As the PBR is very small, its range of error messages is pretty limited,
and somewhat cryptic.  Most likely messages are:

<ul>
<li><b>ERR R</b> -- BIOS returned an error when trying to read a
block from the disk.
Usually means exactly what it says: your disk wasn't readable.
<li><b>ERR M</b> -- An invalid 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>
number was read in the second-stage bootloader's header.
This generally means whatever it was that was read in was NOT
<tt>/boot</tt>, usually meaning installboot(8) was run incorrectly
or the /boot file was altered.
</ul>
Other error messages are detailed in the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">biosboot(8)
manual page</a>


For more information on the i386 boot process, see
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
  Hale Landis' "How it Works" documents.
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - What are the issues regarding large drives with OpenBSD?</h2>

<p>
OpenBSD supports an individual file system of up to
2<sup>31</sup>-1, or 2,147,483,647 sectors, and as each
sector is 512 bytes, that's a tiny amount less than 1T.

<p>
Of course, the ability of file system and the abilities of particular
hardware are two different things.
A new 250G IDE hard disk will not work on an older (pre >137G
standards) interfaces, and some very old SCSI adapters have been seen to
have problems with more modern drives, and some older BIOSs will hang
when they encounter a modern sized hard disk.
You must respect the abilities of your hardware, of course.

<h3>Partition size and location limitations</h3>
Unfortunately, the full ability of the OS isn't available until AFTER
the OS has been loaded into memory.
The boot process has to utilize (and is thus limited
by) the system's boot ROM.
 
<p>
For this reason, the entire /bsd file (the kernel) must be located on
the disk within the boot ROM addressable area.
This means that on some older i386 systems, the root partition must be
completely within the first 504M, but newer computers may have limits of
2G, 8G, 32G, 128G or more.
It is worth noting that many relatively new computers which support 
larger than 128G drives actually have BIOS limitations of booting 
only from within the first 128G.
You can use these systems with large drives, but your root partition
must be within the first 128G.
 
<p>
Note that it is possible to install a 40G drive on an old 486 and load
OpenBSD on it as one huge partition, and think you have successfully
violated the above rule.  However, it might come back to haunt you in a
most unpleasant way:

<ul>
  <li>You install on the 40G / partition.  It works, because the base 
OS and all its files (including /bsd) are within the first 504M.
  <li>You use the system, and end up with more than 504M of files on it.
  <li>You upgrade, build your own kernel, whatever, and copy your 
    new /bsd over the old one. 
  <li>You reboot.
  <li>You get a message such as "ERR M" or other problems on boot.
</ul>
<p>
Why?  Because when you copied "over" the new /bsd file, it didn't 
overwrite the old one, it got relocated to a new location on the 
disk, probably outside the 504M range the BIOS supported.  The 
boot loader was unable to fetch the file /bsd, and the 
system hung.

<p>
To get OpenBSD to boot, the boot loaders (biosboot(8) and <tt>/boot</tt>
in the case of i386) and the kernel (<tt>/bsd</tt>) must be within the
boot ROM's supported range, and within their own abilities.
To play it safe, the rule is simple:

<p>
<b>the entire root partition must be within the computer's BIOS
(or boot ROM) addressable space.</b>

<p>
Some non-i386 users think they are immune to this, however most platforms
have some kind of boot ROM limitation on disk size.
Finding out for sure what the limit is, however, can be difficult.

<p>
This is another good reason to <a href="faq4.html#SpaceNeeded">partition 
your hard disk</a>, rather than using one large partition.

<h3>fsck(8) time and memory requirements</h3>
Another consideration with large file systems is the time and memory
required to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
the file system after a crash or power interruption.
One should not put a 120G file system on a system with 32M of RAM and
expect it to successfully fsck(1) after a crash.
A rough guideline is the system should have at least 1M of available
memory for every 1G of disk space to successfully fsck the disk.
The time required to fsck the drive may become a problem as the file
system size expands.


<a name="InstBoot"></a>
<h2>14.8 - Installing Bootblocks - i386 specific</h2>

<p>
Older versions of MS-DOS can only deal with disk geometries of 1024
cylinders or less.  Since virtually all modern disks have more than 1024
cylinders, most SCSI BIOS chips (which come on the SCSI controller card)
and IDE BIOS (which is part of the rest of the PC BIOS) have an option
(sometimes the default) to "translate" the real disk geometry into
something that fits within MS-DOS' ability.  However, not all BIOS chips
"translate" the geometry in the same way.  If you change your BIOS
(either with a new motherboard or a new SCSI controller), and the new
one uses a different "translated" geometry, you will be unable to load
the second-stage boot loader (and thus unable to load the kernel).
(This is because the first-stage boot loader contains a list of the
blocks that comprise /boot in terms of the original "translated"
geometry).  If you are using IDE disks, and you make changes to your
BIOS settings, you can (unknowingly) change its translation also (most
IDE BIOS offer 3 different translations). To fix your boot block so that
you can boot normally, just put a boot floppy in your drive (or use a
bootable CD-ROM) and at the boot prompt, type "b hd0a:/bsd" to force it
to boot from the first hard disk (and not the floppy).  Your machine
should come up normally.  You now need to update the first-stage boot
Loader to see the new geometry (and re-write the boot block
accordingly).  <br> Our example will assume your boot disk is sd0 (but
for IDE it would be wd0, etc..):

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
If a newer version of bootblocks are required, you will need to compile
these yourself. To do so simply:

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (or whatever device your hard disk is)
</pre>

<a name="Backup"></a>
<h2>14.9 - Preparing for disaster: Backing up and Restoring from tape</h2>

<h3>Introduction:</h3>

<p>
If you plan on running what might be called a production server, it is
advisable to have some form of backup in the event one of your fixed
disk drives fails.

<p>
This information will assist you in using the standard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
utilities provided with OpenBSD.
A more advanced backup utility called "Amanda" is also available through
<a href="faq8.html#Ports">ports</a> for backing up multiple servers to
one tape drive.
In most environments
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
is enough. However, if you have a need to backup multiple machines to
one tape, Amanda might be worth investigating in the future.

<p>
The device examples in this document are for a configuration that uses
both SCSI disks and tape. In a production environment, SCSI disks are
recommended over IDE due to the way in which they handle bad blocks.
That is not to say this information is useless if you are using an IDE
disk or other type of tape drive, your device names will simply differ
slightly. For example sd0a would be wd0a in an IDE based system.

<h3>Backing up to tape:</h3>

<p>
Backing up to tape requires knowledge of where your file systems are
mounted. You can determine how your filesystems are mounted using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
command at your shell prompt. You should get output similar to this:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
In this example, the root (/) filesystem resides physically on sd0a
which indicates SCSI fixed disk 0, partition a. The /usr filesystem
resides on sd0h, which indicates SCSI fixed disk 0, partition h.

<p>
Another example of a more advanced mount table might be:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
In this more advanced example, the root (/) filesystem resides
physically on sd0a. The /var filesystem resides on sd0d, the /home
filesystem on sd0e and finally /usr on sd0h.

<p>
To backup your machine you will need to feed dump the name of each fixed
disk partition. Here is an example of the commands needed to backup the
simpler mount table listed above:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
For the more advanced mount table example, you would use something
similar to:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
You can review the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
man page to learn exactly what each command line switch does. Here is a
brief description of the parameters used above:

<ul>
<li><b>0</b> - Perform a level 0 dump, get everything
<li><b>a</b> - Attempt to automatically determine tape media length
<li><b>u</b> - Update the file /etc/dumpdates to indicate when backup was last performed
<li><b>f</b> - Which tape device to use (/dev/nrst0 in this case)
</ul>

<p>
Finally which partition to backup (/dev/rsd0a, etc)

<p>
The
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
command is used at the end to rewind the drive. Review the mt man page
for more options (such as eject).

<p>
If you are unsure of your tape device name, use dmesg to locate it. An
example tape drive entry in dmesg might appear similar to:

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
You may have noticed that when backing up, the tape drive is accessed as
device name "<tt>nrst0</tt>" instead of the "<tt>st0</tt>" name that is seen in dmesg.
When you access <tt>st0</tt> as <tt>nrst0</tt> you are accessing the same physical tape
drive but telling the drive to not rewind at the end of the job and
access the device in raw mode. To back up multiple file systems to a
single tape, be sure you use the non-rewind device, if you use a rewind
device (<tt>rst0</tt>) to back up multiple file systems, you'll end up
overwriting the prior filesystem with the next one dump tries to write
to tape. You can find a more elaborate description of various tape drive
devices in the dump man page.

<p>
If you wanted to write a small script called "backup", it might look
something like this:

<pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre>

<p>
If scheduled nightly backups are desired,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
could be used to launch your backup script automatically.

<p>
It will also be helpful to document (on a scrap of paper) how large each
file system needs to be. You can use "<tt>df -h</tt>" to determine how much space
each partition is currently using. This will be handy when the drive
fails and you need to recreate your partition table on the new drive.

<p>
Restoring your data will also help reduce fragmentation. To ensure you
get all files, the best way of backing up is rebooting your system in
single user mode. File systems do not need to be mounted to be backed
up. Don't forget to mount root (/) r/w after rebooting in single user
mode or your dump will fail when trying to write out dumpdates. Enter
"<tt>bsd -s</tt> at the boot&gt; prompt for single user mode.

<h3>Viewing the contents of a dump tape:</h3>


<p>
After you've backed up your file systems for the first time, it would be
a good idea to briefly test your tape and be sure the data on it is as
you expect it should be.

<p>
You can use the following example to review a catalog of files on a dump
tape:

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
This will cause a list of files that exist on the 1st partition of the
dump tape to be listed. Following along from the above examples, 1 would
be your root (/) file system.

<p>
To see what resides on the 2nd tape partition and send the output to a
file, you would use a command similar to:

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
If you have a mount table like the simple one, 2 would be /usr, if yours
is a more advanced mount table 2 might be /var or another fs. The
sequence number matches the order in which the file systems are written
to tape.


<h3>Restoring from tape:</h3>

<p>
The example scenario listed below would be useful if your fixed drive
has failed completely. In the event you want to restore a single file
from tape, review the restore man page and pay attention to the
interactive mode instructions.

<p>
If you have prepared properly, replacing a disk and restoring your data
from tape can be a very quick process. The standard OpenBSD install/boot
floppy already contains the required restore utility as well as the
binaries required to partition and make your new drive bootable. In most
cases, this floppy and your most recent dump tape is all you'll need to
get back up and running.

<p>
After physically replacing the failed disk drive, the basic steps to
restore your data are as follows:

<ul>
<li>
<p>
Boot from the OpenBSD install/boot floppy. At the menu selection, choose
Shell. Write protect and insert your most recent back up tape into the
drive.
<br>
<li>
<p>
Using ther
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>r
command, create a primary OpenBSD partition on this newly installed
drive. Example:

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
See <a href="#fdisk">fdisk FAQ</a> for more info.

<li>
<p>
Using the disklabel command, recreate your OpenBSD partition table
inside that primary OpenBSD partition you just created with fdisk.
Example:

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(Don't forget swap, see <a href="#disklabel">disklabel FAQ</a> for more
info)

<li>
<p>
Use the newfs command to build a clean file system on each partition you
created in the above step. Example:

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
Mount your newly prepared root (/) file system on /mnt. Example:

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
Change into that mounted root file system and start the restore process.
Example:

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
You'll want this new disk to be bootable, use the following to write a
new MBR to your drive. Example:

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
<p>
In addition to writing a new MBR to the drive, you will need to install
boot blocks to boot from it. The following is a brief example:

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
Your new root file system on the fixed disk should be ready enough so
you can boot it and continue restoring the rest of your file systems.
Since your operating system is not complete yet, be sure you boot back
up with single user mode. At the shell prompt, issue the following
commands to unmount and halt the system:

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
Remove the install/boot floppy from the drive and reboot your system. At
the OpenBSD boot&gt; prompt, issue the following command:

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
The bsd -s will cause the kernel to be started in single user mode which
will only require a root (/) file system.

<li>
<p>
Assuming you performed the above steps correctly and nothing has gone
wrong you should end up at a prompt asking you for a shell path or press
return. Press return to use sh. Next, you'll want to remount root in r/w
mode as opposed to read only. Issue the following command:

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
Once you have remounted in r/w mode you can continue restoring your
other file systems. Example:

<pre>
(simple mount table)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(more advanced mount table)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
You could use "<b>restore rvsf</b>" instead of just rsf to view names of
objects as they are extracted from the dump set.

<li>
<p>
Finally after you finish restoring all your other file systems to disk,
reboot into multiuser mode. If everything went as planned your system
will be back to the state it was in as of your most recent back up tape
and ready to use again.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Mounting disk images in OpenBSD</h2>

<p>
To mount a disk image (ISO images, disk images created with dd, etc) in
OpenBSD you must configure a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>
device. For example, if you have an ISO image located at
<i>/tmp/ISO.image</i>, you would take the following steps to mount the
image.

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
Notice that, since this image is a CD image you must specify type of
<i>cd9660</i> when mounting it. This is true, no matter what type, e.g.
you must use type ffs when mounting disk images.

<p>
To unmount the image use the following commands.

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
For more information, refer to the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
man page.


<a name="pciideErr"></a>
<h2>14.11 - Help! I'm getting errors with IDE DMA!</h2>

<p>
DMA IDE transfers, supported by 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>
are unreliable with many combinations of hardware.  Until
recently, most "mainstream" operating systems that claimed to support
DMA transfers with IDE drives did not ship with that feature active by
default due to unreliable hardware.
Now many of these same machines are being used for OpenBSD.

<p>
OpenBSD is aggressive and attempts to use the highest DMA Mode it can
configure. This will cause corruption of data transfers in some
configurations because of buggy motherboard chipsets, buggy drives,
and/or noise on the cables. Luckily, Ultra-DMA modes protect data
transfers with a CRC to detect corruption. When the Ultra-DMA CRC fails,
OpenBSD will print an error message and try the operation again.

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
After failing a couple times, OpenBSD will downgrade to a slower
(hopefully more reliable) Ultra-DMA mode. If Ultra-DMA mode 0 is hit,
then the drive downgrades to PIO mode.

<p>
UDMA errors are often caused by low quality or damaged cables.
Cable problems should usually be the first suspect if you get many
DMA errors or unexpectedly low DMA performance.
It is also a bad idea to put the CD-ROM on the same channel with a hard
disk.

<p>
If replacing cables does not resolve the problem and OpenBSD does not
successfully downgrade, or the process causes your machine to lock hard,
or causes excessive messages on the console and in the logs, you may
wish to force the system to use a lower level of DMA or UDMA by default.
This can be done by using <a href="faq5.html#BootConfig">UKC</a> or
<a href="faq5.html#config">config(8)</a> to change the flags on the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>
device.


<a name="RAID"></a>
<h2>14.13 - RAID options for OpenBSD</h2>
RAID (Redundant Array of Inexpensive Disks) gives an opportunity to use
multiple drives to give better performance, capacity and/or redundancy
than one can get out of a single drive alone.  While a full discussion
of the benefits and risks of RAID are outside the scope of this article,
there are a couple points that are important to make here:

<ul>
<li>RAID has nothing to do with backup.
<li>By itself, RAID will not eliminate down-time.
</ul>

If this is new information to you, this is not a good starting point for
your exploration of RAID.

<h3>Software Options</h3>
OpenBSD includes RAIDframe, a software RAID solution.  Documentation for
it can be found in the following places:

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe Homepage</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">man
     page for raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">man
     page for raid(4)</a>
</ul>

<p>
The root partition can be directly
mirrored by OpenBSD using the "Autoconfiguration" option of RAIDframe.

<h3>Hardware Options</h3>
<p>
Many OpenBSD <a href="../plat.html">platforms</a> include support for
various hardware RAID products.  The options vary by platform, see the
appropriate hardware support page (listed
<a href="../plat.html">here</a>).

<p>
Another option available for many platforms is one of the many products
which make multiple drives act as a single IDE or SCSI drive, and are
then plugged into a standard IDE or SCSI adapter.  These devices can
work on virtually any hardware platform that supports either SCSI or
IDE.

<p>
Some manufacturers of these products:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Note: these are just products that OpenBSD users have reported using
-- this is not any kind of endorsement, nor is it an
exhaustive list.)


<h3>Non-Options</h3>
<p>
An often asked question on the <a href="../mail.html">mail lists</a> is
"Are the Promise or HighPoint IDE RAID controllers supported?".  The
answer is "No". These cards and chips are not true hardware RAID
controllers, but rather BIOS-assisted boot of a software RAID.  As
OpenBSD already supports software RAID in a hardware-independent way,
there isn't much desire among the OpenBSD developers to implement
special support for these cards.


<a name="NegSpace"></a>
<h2>14.14 - Why does <tt>df(1)</tt> tell me I have over 100% of my disk
used?</h2>
People are sometimes surprised to find they have <i>negative</i>
available disk space, or more than 100% of a partition in use, as shown
by
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>.

<p>
When a partition is created with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>,
some of the available space is held in reserve from normal users.
This provides a margin of error when you accidently fill the disk, and
helps keep disk fragmentation to a minimum.
Default for this is 5% of the disk capacity, so if the root user has
been carelessly filling the disk, you may see up to 105% of the
available capacity in use.

<p>
If the 5% value is not appropriate for you, you can change it with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>
command.


<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq12.html">[To Section 12 - Platform-Specific Questions]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq14.html,v 1.108 2004/08/15 16:58:23 nick Exp $</small>

</body>
</html>
