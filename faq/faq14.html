<html>
<head>
<title>14.0 - Disk setup</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2001 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<h2><font color=#e00000>14.0 - Disk setup</font><hr></h2>
</p>

<p>
<ul><h3>Table of Contents</h3>
<li><a href="#disklabel"  >14.1 - Using OpenBSD's disklabel</a></li>
<li><a href="#fdisk"      >14.2 - Using OpenBSD's fdisk</a></li>
<li><a href="#NewDisk"    >14.3 - Adding extra disks in OpenBSD</a></li>
<li><a href="#SwapFile"   >14.4 - How to swap to a file</a></li>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a></li>
<li><a href="#D0P3"       >14.6 - When I boot after installation of OpenBSD/i386, it stops at 
"Using Drive: 0 Partition 3".</a></li>
<li><a href="#LargeDrive" >14.7 - What are the issues regarding large drives with OpenBSD? -i386 specific</a></li>
<li><a href="#InstBoot"   >14.8 - Installing Bootblocks - i386 specific</a></li>
<li><a href="#Backup"     >14.9 - Preparing for disaster: Backing up and Restoring from tape.</a></li>
<li><a href="#MountImage" >14.10 - Mounting disk images in OpenBSD</a></li>
<li><a href="#pciideErr"  >14.11 - Help! I'm getting errors with PCIIDE!</a></li>
</ul>
</p> 
<hr>

<p>
<a name= "disklabel"></a>
<a name="14.1"></a>
<h2>Using OpenBSD's disklabel</h2>
</p>   
<p>
<h3>Table of Contents</h3>
<ul>
<li><a href="#disklabel.1">What is disklabel?</a>
<li><a href="#disklabel.2">disklabel during the OpenBSD install</a>
<li><a href="#disklabel.3">Common disklabel uses.</a>
</ul>
</p>
   
<p>
<a name="disklabel.1"></a>
<h3>What is disklabel?</h3>
  
<p>
First be sure to read the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page.
</p>

<p>
Disklabels are created to allow an efficient interface between your disk
and the disk drivers contained within the kernel. Labels hold certain 
information about your disk, like your drive geometry and information
about your filesystems. This is then used by the bootstrap program to load
the drive and to know where filesystems are contained on the drive. Labels are
also used in conjunction with the filesystems to create a more efficient
environment. You can read more in-depth information about disklabel by
reading the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=5&format=html">disklabel(5)</a>
man page.
</p> 

<p>
As an additional gain, using disklabel helps overcome architecture
limitations on disk partitioning. For example, on i386, you can only
have 4 primary partitions. (Partitions that other operating systems,  
such as Windows NT or DOS can see.) With <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8),</a>
you use one of these 'primary' partitions to store *all* of your 
OpenBSD partitions (eg. 'swap', '/', '/usr' and '/var'). 
And you still have 3 more partitions available for other OSs!
</p>

<a name="disklabel.2"></a>
<h3>disklabel during OpenBSD's install</h3>

<p>
One of the major parts of OpenBSD's install is your initial creation of
labels. This comes (for i386 users) directly after using <a href="#14.2">fdisk(1)</a>.
During the install you use disklabel to create your separate labels which
will contain your separate mountpoints. During the install, you can set
your mountpoints from within 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8),</a>
but this isn't completely necessary considering you will be prompted later 
to confirm you choices. But it does make your install go just a little smoother.
</p>

<p>
Since this is during the install you won't have any existing labels, and
they will need to be created. The first label you will create is the label
'a'. This label SHOULD be your where / will be mounted. You can see
recommended partitions that should be created and their sizes by
reading <a href="faq4.html#4.3">faq4.3</a>. For servers it is recommended
that you create at least these label's separately. For desktop users
creating one mountpoint at / will probably suffice. When initially
creating your root partition ( 'a' label ), keep in mind that you will 
need SOME space left for your swap label. Now that the basics have been
explained, here is an example of using disklabel during an install. In   
this first example it is assumed that OpenBSD will be the only operating
system on this computer, and that a full install will be done.
</p>

<ul><pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <strong>d a</strong>
&gt; <strong>a a</strong>
offset: [63] <strong>&lt;Enter&gt;</strong>
size: [16386237] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
&gt; <strong>a b</strong>
offset: [131103] <strong>&lt;Enter&gt;</strong>
size: [16255197] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [swap] <strong>&lt;Enter&gt;</strong>
</pre></ul>

<p>
At this point we have created a 64M root partition mounted at /, and a 64Meg swap partition. Notice that
the offset starts at sector 63. This is what you want. When it comes to the size, disklabel will show
your size in sectors, however, you don't need to enter sizes in the same format. Like the example above
you can enter sizes in the manner of <i>64 Megabytes = 64M</i> and <i>2 Gigabytes = 2G</i>. Disklabel
will then round to the nearest cylinder. In the example above you will also notice that disklabel
assumes that label 'b' will be a swap. This is a correct assumption as the GENERIC kernel is set to look
for swap on label 'b', and you should just follow this guideline and use 'b' as your swap area.
</p>

<p>
The next example will take you through the creation of two more labels. This means that it's not a
complete install, as the size of these won't be enough to install OpenBSD to its fullest. 
Showing the creation of all the partitions would just be repetitive.
</p>

<ul><pre>
&gt; <strong>a d</strong>
offset: [262143] <strong>&lt;Enter&gt;</strong>
size: [16124157] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/tmp</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
&gt; <strong>a e</strong>
offset: [393183] <strong>&lt;Enter&gt;</strong>
size: [15993117] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/var</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
</pre></ul>

<p>
In the above example, there are two things you might notice. One being that the offset is automatically
figured out for you to be the next in order. When doing an install of this sort, you won't need to mess
with changing the offsets at all. Another difference you might notice will be that label 'c' has been
skipped. This is done for a reason, which is that label 'c' is a label that represents the whole disk.
For this reason you shouldn't deal with label 'c' in any way.
</p>

<p>
Once all your labels have been created all that's left to do is write the labels to disk, and move on in
the installation process. To write everything and quit disklabel (and continue with the install) do:
</p>

<ul><pre>
&gt; <strong>w</strong>
&gt; <strong>q</strong>
</pre></ul>

<p>
<strong>*NOTE*</strong> - For users with large drives. If your bios isn't able to support a drive of that size
OpenBSD cannot support it either. Otherwise OpenBSD should be able to handle your drive just fine. If you are in a 
situation where your bios doesn't support your drive, you can try Maxtor EZ-Drive or other similar overlay product.
</p>


<a name="disklabel.3"></a>
<h3>Common uses for disklabel(8)</h3>

<p>
Once your system is installed, you shouldn't need to use disklabel too often. But some times you will
need to use disklabel when adding, removing or restructuring your disks. One of the first things
you will need to do is view your current disklabel. To do this, simply type:
</p>

<ul><pre>
# <strong>disklabel wd0</strong> &gt;----- Or whatever disk device you'd like to view

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre></ul>

<p>
The above command simply allows you to view the existing disklabel, and assuring that you dont mess
anything up. ( Which we all need sometimes. ) But to be able to make changes you must use the -E option
with disklabel like so:
</p>

<ul><pre>
# <strong>disklabel -E wd0</strong>
</pre></ul>

<p>
This will bring you to a prompt, the same as the one that you used during the OpenBSD install. Probably
the single most important command at this prompt is '?'. This will give you a list of possible options
pertaining to disklabel. You can even view the entire 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page with the 'M' command. From this prompt, you will do all of your adding, deleting and 
changing of partitions. For additional information read the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page.
</p>

<p>
<a name= "fdisk"></a>
<a name="14.2"></a>
<h2>14.2 - Using fdisk</h2>
</p>
<p>
First be sure to check the fdisk man page. 
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
</p>
<p>
Fdisk is a program to help with the maintenance of your partitions. This
program is used at install time to set up your OpenBSD partition (this
partition can contain <u>several</u> labels, each with filesystems/swap/etc.).
It can divide space on your drives and set one active. This program will
usually be used in Single User Mode ( boot -s ). Fdisk also sets the MBR on
your various hard disks.
</p>

<p>
For installation purposes, most times you'll only need <b>ONE</b> OpenBSD
partition, and then using disklabel to put a swap and a filesystem on it.
</p>

<p>
To just view your partition table using fdisk, use:<br>
<ul>
<pre># <strong>fdisk fd0</strong><br>
</pre>
</ul>

Which will give an output similar to this:
</p>

<ul>
<pre>
         Disk: fd0       geometry: 80/2/18 [2880 sectors]
         Offset: 0       Signatures: 0xAA55,0x0
                  Starting        Ending
          #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
----------------------------------------------------------------------
         *0: A6    0   0   1 -   79   1  18 [         0 -       2880] OpenBSD
          1: 00    0   0   0 -    0   0   0 [         0 -          0] unused
          2: A7    0   0   2 -   79   1  18 [         1 -       2879] NEXTSTEP
          3: 00    0   0   0 -    0   0   0 [         0 -          0] unused
</pre>
</ul>

<p>
In this example we are viewing the fdisk output of floppy drive. We can
see the OpenBSD partition (A6) and its size. The * tells us that the
OpenBSD partition is a bootable partition.
</p>

<p>
In the previous example we just viewed our information. What if we want to
edit our partition table? Well, to do so we must use the <b>-e</b> flag.
This will bring up a command line prompt to interact with fdisk.
</p>

<ul>
<PRE>
# <strong>fdisk -e wd0</strong>
Enter 'help' for information
fdisk: 1&gt; <strong>help</strong>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</PRE>
</ul>

<p> 
It is perfectly safe in fdisk to go in and explore, just make sure to answer <Strong>N</strong> to saving
the changes and *DON'T* use the <strong>write</strong> command.
</p>

<p>Here is an overview of the commands you can use when you choose the <b>-e</b> flag.<br>
<ul>
<li><strong>help</strong>    Display a list of commands that fdisk understands in the interactive edit mode.</li>
<li><strong>reinit</strong>  Initialize the currently selected, in-memory copy of the boot block.</li>
<li><strong>disk</strong>    Display the current drive geometry that fdisk has probed. You are given a chance to edit it if you wish.</li>
<li><strong>edit</strong>    Edit a given table entry in the memory copy of the current boot block.  You may edit either in BIOS geometry mode, or in sector offsets and sizes.</li>
<li><strong>flag</strong>    Make the given partition table entry bootable. Only one entry can be marked bootable. If you 
wish to boot from an extended partition, you will need to mark the partition table entry for the extended partition as bootable.</li>
<li><strong>update</strong>  Update the machine code in the memory copy of the currently selected boot block.</li>
<li><strong>select</strong>  Select and load into memory the boot block pointed to by the extended partition table entry in the current boot block.</li>
<li><strong>print</strong>   Print the currently selected in-memory copy of the boot block and its MBR table to the terminal.</li>
<li><strong>write</strong>   Write the in-memory copy of the boot block to disk. You will be asked to confirm this operation.</li>
<li><strong>exit</strong>    Exit the current level of fdisk, either returning to the previously selected in-memory copy of a boot block, or exiting the program if there is none.</li>
<li><strong>quit</strong>    Exit the current level of fdisk, either returning to the previously selected
in-memory copy of a boot block, or exiting the program if there is none.  Unlike exit it does write the modified block out.</li>
<li><strong>abort</strong>   Quit program without saving current changes.</li>
</ul>
</p>
<br>

<p>
<a name= "NewDisk"></a>
<a name="14.3"></a>
<h2>14.3 - Adding extra disks in OpenBSD</h2>
</p>

<p>
Well once you get your disk installed <strong>PROPERLY</strong> you need to use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
(<i>i386 only</i
>) and 
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&apropos=0&sektion=8&format=html">
disklabel(8)</a> to set
 up your
disk in OpenBSD.
<P>
For i386 folks, start with fdisk.  Other architectures can ignore this.
<ul><pre>
# <Strong>fdisk -i sd2</strong>
</pre></ul>
This will initialize the disk's "real" partition table for exclusive use
by OpenBSD.
Next you need to create a disklabel for it.  This will seem confusing.
<ul><pre>
# <strong>disklabel -e sd2</strong>

<i>(screen goes blank, your $EDITOR comes up)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></ul>
First, ignore the 'c' partition, it's always there and is for
programs like disklabel to function! 
For normal operations, fsize should always be 1024, bsize should always be 8192,
and cpg should always be 16.  Fstype is 4.2BSD.  Total sectors is
the total size of the disk.
Say this is a 3 gigabyte disk.  Three gigabytes in disk manufacturer
terms is 3000 megabytes.  So divide 6185088/3000 (use 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&sektion=1">bc(1))</a>.  You get 2061.
So, to make up partition sizes for a, d, e, f, g, ... just multiply X*2061
to get X megabytes of space on that partition.   The offset for your
first new partition should be the same as the "sectors/track" reported
earlier in disklabel's output.  For us it is 63.  The offset for each
partition afterwards should be a combination of the size of each partition
and the offset of each partition (Except the 'c' partition, since it has
no play into this equation.)
<P>
Or, if you just want one partition on the disk, say you will use the
whole thing for web storage or a home directory or something,
just take the total size of the disk and subtract the sectors per track from it.
6185088-63 = 6185025.  Your partition is
<UL><PRE>
    d:  6185025       63    4.2BSD     1024  8192    16 
</PRE></UL>
<P>
<b>If all this seems needlessly complex, you can just use disklabel -E to get
the same partitioning mode that you got on your install disk!</b>
There, you can just use "96M" to specify "96 megabytes".  (Or, if you have a disk
big enough, 96G for 96 gigs!) Unfortunately,
the -E mode uses the BIOS disk geometry, not the real disk geometry,
and often times the two are not the same.  To get around this limitation,
type 'g d' for 'geometry disk'.  (Other options are 'g b' for 'geometry bios'
and 'g u' for geometry user, or simply, what the label said before
disklabel made any changes.)
<P>
That was a lot.  But you are not finished.  
Finally, you need to create the filesystem on that disk using <a href=
"http://www.openbsd.org/cgi-bin/man.cgi?query=newfs
&apropos=0&sektion=8&format=html">newfs(8)</a>.
</p>

<p>
<ul><pre>
bsd# <strong>newfs wd1a </strong></pre></ul>
</p>

<p>
Or whatever your disk was named as per OpenBSD's disk numbering scheme.  (Look at the
output from <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&sektion=8">dmesg(8)</a> to see what your disk was named by OpenBSD.)
</p>

<p>
Now figure out where you are going to mount this new partition you just created.
Say you want to put it on /u.  First, make the directory /u.  Then, mount it.
</p>

<UL><PRE>
mount /dev/wd1a /u
</PRE></UL>

<P>
Finally, add it to <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&sektion=5">/etc/fstab(5)</a>
</p>
<UL><PRE>/dev/wd1a /u ffs rw 1 1</PRE></UL>

<p>
What if you need to migrate an existing directory like /usr/local? You should mount 
the new drive in /mnt and use cpio -pdum to copy /usr/local to the /mnt directory.
Edit the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&sektion=5">/etc/fstab(5)</a> file to show that the /usr/local partition is now /dev/wd1a
(your freshly formatted partition.) 
Example:
</p>

<ul>
<strong>/dev/wd1a /usr/local ffs rw 1 1</strong>
</ul>

<p>
Reboot into single user mode..<strong>boot -s</strong> Move the existing
/usr/local to /usr/local-backup (or delete it if you feel lucky) and create an
empty directory /usr/local. Then reboot the system, and viola, the files are there!
</p>

<br>

<p>
<a name= "SwapFile"></a>
<a name="14.4"></a>
<h2>14.4 - How to swap to a file</h2>
</p>

<p>
(Note: if you are looking to swap to a file because you are getting
&quot;virtual memory exhausted&quot; errors, you should try raising
the per-process limits first with 
csh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&sektion=1&format=html">unlimit(1)</a>,
or
sh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&sektion=1&format=html">ulimit(1)</a>.)
</p>

<p>
After the release of OpenBSD 2.5 came
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a>, 
which made dealing with swap devices much easier. If you are on an OpenBSD 2.5 system, exchange swapctl
with swapon, and use pstat -s to list swap devices. Swapping to a file doesn't require a 
custom built kernel, although that can still be done, this faq will show you how to add 
swap space both ways.
</p>

<h3>Swapping to a file. </h3>

<p>
Swapping to a file is easiest and quickest way to get extra swap area's setup. This is not for users who
are currently using Soft Updates. (Which isn't enabled by default).
To start out, you can see how much swap you currently have and how much you are using with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a>
utility. You can do this by using the command:
</p>

<ul><pre>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></ul>

<p>
This shows the devices currently being used for swapping and their current statistics. In the above
example there is only one device named &quot;swap_device&quot;. This is the predefined area on disk that
is used for swapping. (Shows up as partition b when viewing disklabels) As you can also see in the above
example, that device isn't getting much use at the moment. But for the purposes of this document, we
will act as if an extra 32M is needed. 
</p>
<p>
The first step to setting up a file as a swap device is to create the file. It's best to do this with
the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&sektion=1&format=html">dd(1)</a>
utility. Here is an example of creating the file <i>/var/swap</i> that is 32M large.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></ul>

<p>
Once this has been done, we can turn on swapping to that device. Use the following command to turn on
swapping to this device
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo chmod 600 /var/swap</strong>
ericj@oshibana&gt; <strong>sudo swapctl -a /var/swap</strong>
</pre></ul>

<p>
Now we need to check to see if it has been correctly added to the list of our swap devices.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></ul>

<p>
Now that the file is setup and swapping is being done, you need to add a line to your <i>/etc/fstab</i>
file so that this file is configured on the next boot time also. If this line is not added, your won't
have this swap device configured.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>cat /etc/fstab</strong>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></ul>

<h3>Swapping via a vnode device</h3>

<p>
This is a more permanent solution to adding more swap space. To swap to a file permanently, first make a
kernel with vnd0c as swap. If you have wd0a as root filesystem, wd0b is the previous swap, use this line
in the kernel configuration file (refer to compiling a new kernel if in doubt): 
</p>

<ul><pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre></ul>

<p>
After this is done, the file which will be used for swapping needs to be created. You should do this by
using the same command as in the above examples.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></ul>

<p>
Now your file is in place, you need to add the file to you <i>/etc/fstab</i>. Here is a sample line to
boot with this device as swap on boot.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>cat /etc/fstab</strong>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre></ul>

<p>
At this point your computer needs to be rebooted so that the kernel changes can take place. Once this
has been done it's time to configure the device as swap. To do this you will use <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8&format=html">vnconfig(8)</a>.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo vnconfig -c -v vnd0 /var/swap</strong>
vnd0: 33554432 bytes on /var/swap
</pre></ul>

<p>
Now for the last step, turning on swapping to that device. We will do this just like in the above
examples, using swapctl(8). Then we will check to see if it was correctly added to our list of swap
devices.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo swapctl -a /dev/vnd0c</strong>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></ul>



<p>
<a name= "SoftUpdates"></a>
<a name="14.5"></a>
<h2>14.5 - Soft Updates</h2>
</p>

<p>
Over the last few years Kirk McKusick has been working on something called
"Soft Updates". This is based on an idea proposed by Greg Ganger and Yale
Patt that imposing a partial ordering on the buffer cache operations would
permit the requirement for synchronous writing of directory entries to be
removed from the FFS code. Thus, a large performance increase of disk
writing performance.<br>
As Soft Updates are still in development as a whole, an 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&sektion=8">fsck(8)</a> is still needed after 
the computer is abruptly turned off without a clean shutdown sequence, 
but this will be remedied in future versions.<p>
More internals and details about Soft Updates can be found in the papers of
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Ganger and Patt</a> 
and from <a href="http://www.mckusick.com/softdep/index.html">McKusick</a>. 
</p>

<p>
To enable Softupdates your kernel must have
</p>

<p>
<strong>option FFS_SOFTUPDATES</strong>
</p>
compiled in.

<p>
This option is included in GENERIC kernels starting with OpenBSD 2.9. However, you still must enable it on a per mount point basis.
</p>

<p>
Starting with 2.9, enabling soft updates must be done with a mount time option, instead of using <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&sektion=8">tunefs(8)</a>. Now, when mounting a partition with the  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&sektion=8">mount(8)</a> utility, you can specify that you wish to have soft updates enabled on that partition. Below is a sample <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&sektion=5">/etc/fstab(5)</a></i> entry that has one partition <i>sd0a</i> that we wish to have mounted with soft updates.
</p>

<ul><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></ul>

<p>
If you are using an OpenBSD release earlier than 2.9 you need to boot into single-user mode:
</p>

<ul>
<pre>
        boot> <strong>boot -s</strong>
        [snip]
        bsd# <strong>tunefs -s enable &lt;raw device&gt;</strong>
        bsd# <strong>reboot -n</strong>
</pre>
</ul>

<p>
Note to sparc users: Do not enable soft updates on sun4 or sun4c machines.  These architectures support only a very limited amount of kernel memory and cannot use this feature.  However, sun4m machines are fine.
</p>

<p>
<a name= "D0P3"></a>
<a name="14.6"></a>
<h2>14.6 -  When I boot after installation of OpenBSD/i386, it stops at "Using Drive: 0 Partition: 3" - i386 specific.</h2>
</p>
<p>
This isn't actually an error message by itself, it is the boot loader in 
the MBR telling you which drive and partition it is about to boot 
from.  The problem is, the boot process stopped here.
</p>
<p>
There are two common reasons why this may happen:  an incompatibility 
between the BIOS and the OpenBSD MBR, or a drive geometry problem.  An 
example of a drive geometry problem would be if you were to move a 
drive from one computer to another, update a BIOS or change a BIOS 
setting on a computer, though it is also reported that it can happen 
for unknown reasons during install. 
</p>
<p>
To fix the BIOS compatibility issue, you must replace the boot loader 
with one that is compatible with your system.  Fortunately, boot 
loaders are easy to come by.
</p>

<h3>Installing the BootEasy boot loader:</h3>
<p>
This requires booting your system.  As you can't boot off the hard
disk directly, we have to use a boot floppy or CD-ROM to start the boot
process.  When the system gets to the 'boot>' prompt, redirect it to
boot from the hard disk:
</p>
<UL><PRE>
reading boot.......
probing pc0 com0 com1 pci mem [639k 79m a20=on]
disk hd0 fd0
>> OpenBSD BOOT 1.28
boot> <b>boot hd0a:/bsd</b>
</pre></ul>
<p>
This command redirects the boot process to the file /bsd on the 'a'
partition of the first hard drive, allowing your system to boot. 
</p>
<p>
Once the system is booted, you need to install the BootEasy boot
loader.  The file itself can be found on both the CD-ROM and the FTP
sites, in the directory 3.0/tools/booteasy/Boot.bin, and can be
installed using the following 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> 
command:
</p>
<ul><pre>
# <b>fdisk -i -f /mnt/3.0/tools/booteasy/Boot.bin wd0</b>
</pre></ul>
<p>
This assumes you have a the 3.0 CD mounted on /mnt and that you
are using an IDE drive.  You may need to change this depending 
upon where Boot.bin is and what kind of hard disk you have (a SCSI 
drive would typically be 'sd0').  <b>Note: do NOT do this if your 
OpenBSD partition is not the entire
disk!</b> Initializing the MBR this way creates one OpenBSD
partition spanning the entire disk and deletes all other partitions,
which is rarely good.
</p>
<p>
BootEasy has another feature that might interest you even if you have
no problem with the default loader: It is capable of selecting a boot
partition at startup -- it will prompt you for which partition to boot
from, and will boot the active partition if no other choice is made. 
This might be very useful should you have multiple OS's on one disk. 
Installing BootEasy this way is done from MS-DOS with the BOOTINST.EXE 
program found in the BootEasy directory on the CD-ROM and FTP servers.
</p>
<h3>Installing the MS-DOS boot loader: </h3>
<p>
Boot from a Windows 9x or DOS v6 boot disk with FDISK.EXE on it.
Once the system is booted to an MS-DOS prompt, enter the following:
</p>
<UL><PRE>
A:\&gt<b>fdisk /mbr</b>
</pre></ul>
<p>
You should see a brief disk access, and then a command prompt should
return, with NO message of any kind.  "Bad command or file name" means
the disk you used did not have FDISK.EXE on it.  If you do this
properly, the "Using ..." message will be removed, as it replaces the
very code that produces that message.  If you had a BIOS compatibility
issue, it will now be gone, reboot, your OpenBSD install should come
right up.
</p>
<p>
It has been reported that this also works with FreeDOS.
</p>

<h3>The OS-BS Boot Loader:</h3>
<p>
Another boot loader, OS-BS, is included with the OpenBSD CD-ROMs and
available on the FTP sites in 2.9/tools/osbs135.exe. The OS-BS
web page is at 
<a href="http://www.prz.tu-berlin.de/~wolf/os-bs.html">
    http://www.prz.tu-berlin.de/~wolf/os-bs.html</a>
</p>
<h3>LILO:</h3>
<p>
The Linux LILO program can also be used.  For details, see
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/2.9/i386/INSTALL.linux">INSTALL.linux</a>
</p>

<p>
<h3>Avoiding the problem:</h3>
Relatively few machines have the BIOS compatibility problem, but if
you are setting up a machine which you know has this problem, it is
fairly easy to avoid it.  The only time the OpenBSD loader is
installed on your system during a normal install is when you say 'Y'
to the 'Use entire disk for OpenBSD' question.  If you answer 'N' 
and manually create the OpenBSD disk partition, it will not replace
the boot loader unless you use the 'reinit' or 'update' commands of
fdisk.  This, of course, assumes that your drive STARTED with some
kind of boot loader -- if it doesn't (new, blank drive, drive pulled
from another platform), you will have to install one before the system
will boot.
</p>

<h3>Fixing a drive geometry problem:</h3>
<p>
Ideally, you would want to avoid this problem by maintaining
the same drive geometry, not by fixing it, however sometimes you
can't avoid it.  An example would be moving a large drive from an old
computer which didn't support LBA geometry to a new machine which
insists upon using LBA.
</p>
<p>
Start your machine using a boot disk or CD-ROM, as indicated above. 
Log in as root, and execute the following commands:
</p>
<ul><pre>
# cp /usr/mdec/boot /boot
# /usr/mdec/installboot -v /boot /usr/mdec/biosboot wd0
</pre></ul>
<p>
Reboot, your system should come right up.
</p>
<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">installboot(8)</a>
installs and configures the the partition boot loader,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">biosboot(8)</a>,
 which loads 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">boot(8)</a>.  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">boot(8)</a> 
is the module which loads the kernel into RAM.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&apropos=0&sektion=8&manpath=OpenBSD+Current&arch=i386&format=html">biosboot(8)</a>
has a table within it that points to the physical location 
(according to the system's BIOS) of 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">boot(8)</a>.
If you do anything which changes the BIOS's perception of the location of 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">boot(8)</a>, 
you must re-run
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">installboot(8)</a>
as above to reinitialize the table pointing to 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">boot(8)</a>.
</p>
See <a href="#14.8">section 14.8</a> for more info.
<br>

<p>
<a name= "LargeDrive"></a>
<a name="14.7"></a>
<h2>14.7 - What are the issues regarding large drives with OpenBSD? - i386 specific</h2>
</p>
<p>

OpenBSD has support for file systems of sizes much larger than any
currently or soon to be available hard disks, however there are 
limitations on some interfaces which are smaller than the theoretical
maximum of OpenBSD. In
the case of IDE drives, the limit is 128GB, the limit of the currently 
popular ATA interface.  Note the next generation of ATA drives, 
those with capacities greater than 128G (1G=2^30 here, not 
1,000,000,000, so drive manufacturers will often call this 137G), 
will not be supported until new interface standard(s) are 
implemented in OpenBSD. 
(<a href="/donations.html">Donations</a> 
of 
<a href="/want.html">hardware</a> 
for development purposes welcome.)   
</p>
<p>
Unfortunately, the full ability of the 
OS isn't available until AFTER the OS has been loaded into memory, 
and the booting process introduces limits of its own.  The boot
process has to utilize (and is thus limited by) the system's BIOS.  
The OpenBSD boot loaders 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">biosboot(8)</a> 
and 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&sektion=8%2fi386&apropos=0&manpath=OpenBSD+Current&arch=i386">boot(8)</a>)
also have their own internal 
8G limitation, from an older BIOS limit.
</p> 
<p>
For this reason, the entire /bsd file (the kernel) must be located 
on the disk within the BIOS addressable area, or within the first 8G 
of the disk, whichever is smaller.  This means that on some older 
computers, the root partition must be completely within the first 
504M, but for most newer computers, the root partition may be 
anywhere within the first 8G.
</p>
<p>
Note that it is possible to install a 40G drive on an old 486 and 
load OpenBSD on it as one huge partition, and think you have 
successfully violated the above rule.  However, it might come 
back to haunt you in a most unpleasant way:
</p>
<ul>
  <li>You install on the 40G / partition.  It works, because the base 
OS and all its files (including /bsd) are within the first 504M.
  <li>You use the system, and end up with more than 504M of files on it.
  <li>You upgrade, build your own kernel, whatever, and copy your 
    new /bsd over the old one. 
  <li>You reboot.
  <li>You get a message such as "bad magic"
</ul>
<P>
Why?  Because when you copied "over" the new /bsd file, it didn't 
overwrite the old one, it got relocated to a new location on the 
disk, probably outside the 504M range the BIOS supported.  The 
BIOS-based boot loader was unable to fetch the file /bsd, and the 
system hung.
</p>
<p>
To get OpenBSD to boot, /bsd must be within the BIOS's
supported range. To play it safe, the rule is simple:
</p>
<p>
<b>The entire root partition must be within the computer's BIOS 
addressable space or within the first 8G, whichever is smaller.</b>
</p>
<p>
OpenBSD is capable of accessing entire IDE drives (up to 128G), not just the 
space recognized by the system BIOS, but root had best be 
within the BIOS's range.
</p>

<p>
<a name= "InstBoot"></a>
<a name="14.8"></a>
<h2>14.8 - Installing Bootblocks - i386 specific</h2>
</p>

<p>
Older versions of MS-DOS can only deal with disk geometries of 1024 cylinders
or less.  Since virtually all modern disks have more than 1024
cylinders, most SCSI BIOS chips (which come on the SCSI controller card)
and IDE BIOS (which is part of the rest of the PC BIOS)
have an option (sometimes the default) to "translate" the real disk
geometry into something that fits within MS-DOS' ability.
However, not all BIOS chips "translate" the geometry in
the same way.  If you change your BIOS (either with a new motherboard
or a new SCSI controller), and the new one uses a
different "translated" geometry, you will be unable to load the
second stage boot loader (and thus unable to load the kernel).
(This is because the first stage boot loader contains a list of the blocks
that comprise /boot in terms of the original "translated" geometry.)
If you are using IDE disks, and you make changes to your BIOS settings,
you can (unknowingly) change its translation also (most IDE BIOS offer 3 different
translations.) To fix your boot block so that you can boot normally,
just put a boot floppy in your hard drive, and at the boot prompt,
type "b hd0a:/bsd" to force it to boot from the first hard disk (and not the
floppy).  Your machine should come up normally.  You now need
to update the first stage boot loader to see the new geometry
(and re-write the boot block accordingly).
<br>
Our example will assume your boot disk is sd0 (but for IDE it would be wd0, etc..):
</p>
<ul>
<pre>
# <strong>cd /usr/mdec; ./installboot /boot biosboot sd0</strong>
</pre>
</ul>
<p>
If installboot complains that it is unable to read the BIOS geometry, at
the boot&gt; prompt you may issue the &quot;machine diskinfo&quot; (or
&quot;ma di&quot; for short) command to print the information you need.
Feed the &quot;heads&quot; and &quot;secs&quot; values to installboot's -h
and -s flags, respectively, so that the modified installboot command is
the following:
</p>
<ul><pre>
#<strong> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</strong>
</pre></ul>

<p>
If a newer version of bootblocks are required, you will need to compile these yourself. To do so simply:
</p>

<ul><pre>
# <strong>cd /sys/arch/i386/stand/</strong>
# <strong>make && make install </strong>
# <strong>cd /usr/mdec; cp ./boot /boot</strong>
# <strong>./installboot /boot biosboot sd0</strong> (or whatever device your hard disk is)
</pre></ul>

<p>
<a name= "Backup"></a>
<a name="14.9"></a>
<h2>14.9 - Preparing for disaster: Backing up and Restoring from tape</h2>
</p>

<h3>Introduction:</h3>

<p>
If you plan on running what might be called a production server, it is advisable to have some form of backup in the event one of your fixed disk drives fails.
</p>

<p>
This information will assist you in using the standard <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> utilities provided with OpenBSD. A more advanced backup utility called "Amanda" is also available for backing up multiple servers to one tape drive. In most environments <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> is enough. However, if you have a need to backup multiple machines to one tape, Amanda might be worth investigating in the future.
</p>

<p>
The device examples in this document are for a configuration that uses both SCSI disks and tape. In a production environment, SCSI disks are recommended over IDE due to the way in which they handle bad blocks. That is not to say this information is useless if you are using an IDE disk or other type of tape drive, your device names will simply differ slightly. For example sd0a would be wd0a in an IDE based system.
</p>

<h3>Backing up to tape:</h3>

<p>
Backing up to tape requires knowledge of where your file systems are mounted. You can determine how your filesystems are mounted using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&sektion=8">mount(8)</a> command at your shell prompt. You should get output similar to this:
</p>

<ul><pre>
shell# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></ul>

<p>
In this example, the root (/) filesystem resides physically on sd0a which indicates SCSI fixed disk 0, partition a. The /usr filesystem resides on sd0h, which indicates SCSI fixed disk 0, partition h.
</p>

<p>
Another example of a more advanced mount table might be:
</p>

<ul><pre>
shell# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></ul>

<p>
In this more advanced example, the root (/) filesystem resides physically on sd0a. The /var filesystem resides on sd0d, the /home filesystem on sd0e and finally /usr on sd0h.
</p>

<p>
To backup your machine you will need to feed dump the name of each fixed disk partition. Here is an example of the commands needed to backup the simpler mount table listed above:
</p>

<ul><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></ul>

<p>
For the more advanced mount table example, you would use something similar to:
</p>

<ul><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></ul>

<p>
You can review the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a> man page to learn exactly what each command line switch does. Here is a brief description of the parameters used above:
</p>

<ul>
<li><b>0</b> - Perform a level 0 dump, get everything
<li><b>a</b> - Attempt to automatically determine tape media length
<li><b>u</b> - Update the file /etc/dumpdates to indicate when backup was last performed
<li><b>f</b> - Which tape device to use (/dev/nrst0 in this case)
</ul>

<p>
Finally which partition to backup (/dev/rsd0a, etc)
</p>

<p>
The <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&sektion=1">mt(1)</a> command is used at the end to rewind the drive. Review the mt man page for more options (such as eject).
</p>

<p>
If you are unsure of your tape device name, use dmesg to locate it. An example tape drive entry in dmesg might appear similar to:
</p>

<ul><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></ul>

<p>
You may have noticed that when backing up, the tape drive is accessed as device name "nrst0" instead of the "st0" name that is seen in dmesg. When you access st0 as nrst0 you are accessing the same physical tape drive but telling the drive to not rewind at the end of the job and access the device in raw mode. To back up multiple file systems to a single tape, be sure you use the non-rewind device, if you use a rewind device (rst0) to back up multiple file systems, you'll end up overwriting the prior filesystem with the next one dump tries to write to tape. You can find a more elaborate description of various tape drive devices in the dump man page.
</p>

<p>
If you wanted to write a small script called "backup", it might look something like this:
</p>

<ul><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre></ul>

<p>
If scheduled nightly backups are desired, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&sektion=8&format=html">cron(8)</a> could be used to launch your backup script automatically.
</p>

<p>
It will also be helpful to document (on a scrap of paper) how large each file system needs to be. You can use df -h to determine how much space each partition is currently using. This will be handy when the drive fails and you need to recreate your partition table on the new drive.
</p>

<p>
Restoring your data will also help reduce fragmentation. To ensure you get all files, the best way of backing up is rebooting your system in single user mode. File systems do not need to be mounted to be backed up. Don't forget to mount root (/) r/w after rebooting in single user mode or your dump will fail when trying to write out dumpdates. Enter bsd -s at the boot> prompt for single user mode.
</p>

<h3>Viewing the contents of a dump tape:</h3>


<p>
After you've backed up your file systems for the first time, it would be a good idea to briefly test your tape and be sure the data on it is as you expect it should be.
</p>

<p>
You can use the following example to review a catalog of files on a dump tape:
</p>

<ul><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></ul>

<p>
This will cause a list of files that exist on the 1st partition of the dump tape to be listed. Following along from the above examples, 1 would be your root (/) file system.
</p>

<p>
To see what resides on the 2nd tape partition and send the output to a file, you would use a command similar to:
</p>

<ul><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></ul>

<p>
If you have a mount table like the simple one, 2 would be /usr, if yours is a more advanced mount table 2 might be /var or another fs. The sequence number matches the order in which the file systems are written to tape.
</p>


<h3>Restoring from tape:</h3>

<p>
The example scenario listed below would be useful if your fixed drive has failed completely. In the event you want to restore a single file from tape, review the restore man page and pay attention to the interactive mode instructions.
</p>

<p>
If you have prepared properly, replacing a disk and restoring your data from tape can be a very quick process. The standard OpenBSD install/boot floppy already contains the required restore utility as well as the binaries required to partition and make your new drive bootable. In most cases, this floppy and your most recent dump tape is all you'll need to get back up and running.
</p>

<p>
After physically replacing the failed disk drive, the basic steps to restore your data are as follows:
</p>

<ul>
<li>
<p>
Boot from the OpenBSD install/boot floppy. At the menu selection, choose Shell. Write protect and insert your most recent back up tape into the drive.
<br>
</p>

<li>
<p>
Using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> command, create a primary OpenBSD partition on this newly installed drive. Example:
</p>

<ul><pre>
shell# <b>fdisk -e sd0</b>
</pre></ul>

<p>
See <a href="#14.2">fdisk FAQ</a> for more info.
</p>

<li>
<p>
Using the disklabel command, recreate your OpenBSD partition table inside that primary OpenBSD partition you just created with fdisk. Example:
</p>

<ul><pre>
shell# <b>disklabel -E sd0</b>
</pre></ul>

<p>
(Don't forget swap, see <a href="#14.1">disklabel FAQ</a> for more info)
</p>

<li>
<p>
Use the newfs command to build a clean file system on each partition you created in the above step. Example:
</p>

<ul><pre>
shell# <b>newfs /dev/rsd0a</b>
shell# <b>newfs /dev/rsd0h</b>
</pre></ul>

<li>
<p>
Mount your newly prepared root (/) file system on /mnt. Example:
</p>

<ul><pre>
shell# <b>mount /dev/sd0a /mnt</b>
</pre></ul>

<li>
<p>
Change into that mounted root file system and start the restore process. Example:
</p>

<ul><pre>
shell# <b>cd /mnt</b>
shell# <b>restore -rs 1 -f /dev/rst0</b>
</pre></ul>

<li>
<p>
You'll want this new disk to be bootable, use the following to write a new MBR to your drive. Example:
</p>

<ul><pre>
shell# <b>fdisk -i sd0</b>
</pre></ul>

<li>
<p>
In addition to writing a new MBR to the drive, you will need to install boot blocks to boot from it. The following is a brief example:
</p>

<ul><pre>
shell# <b>cp /usr/mdec/boot /mnt/boot</b>
shell# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></ul>

<li>
<p>
Your new root file system on the fixed disk should be ready enough so you can boot it and continue restoring the rest of your file systems. Since your operating system is not complete yet, be sure you boot back up with single user mode. At the shell prompt, issue the following commands to unmount and halt the system:
</p>

<ul><pre>
shell# <b>umount /mnt</b>
shell# <b>halt</b>
</pre></ul>

<li>
<p>
Remove the install/boot floppy from the drive and reboot your system. At the OpenBSD boot&gt; prompt, issue the following command:
</p>

<ul><pre>
boot&gt; <b>bsd -s</b>
</pre></ul>

<p>
The bsd -s will cause the kernel to be started in single user mode which will only require a root (/) file system.
</p>

<li>
<p>
Assuming you performed the above steps correctly and nothing has gone wrong you should end up at a prompt asking you for a shell path or press return. Press return to use sh. Next, you'll want to remount root in r/w mode as opposed to read only. Issue the following command:
</p>

<ul><pre>
shell# <b>mount -u -w /</b>
</pre></ul>

<li>
<p>
Once you have remounted in r/w mode you can continue restoring your other file systems. Example:
</p>

<ul><pre>
(simple mount table)
shell# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(more advanced mount table)
shell#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></ul>

<p>
You could use "<b>restore rvsf</b>" instead of just rsf to view names of objects as they are extracted from the dump set.
</p>

<li>
<p>
Finally after you finish restoring all your other file systems to disk, reboot into multiuser mode. If everything went as planned your system will be back to the state it was in as of your most recent back up tape and ready to use again.
</p>
</ul>

<p>
<a name= "MountImage"></a>
<a name=14.10></a>
<h2>14.10 - Mounting disk images in OpenBSD</h2>
</p>

<p>
To mount a disk image (ISO images, Disk images created with dd, etc) in OpenBSD
you must configure a <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&sektion=4">vnd(4)</a> device. For example, If you have an ISO image located at <i>/tmp/ISO.image</i>, you would take the following steps to mount the image.
</p>

<ul>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <strong>vnconfig svnd0 /tmp/ISO.image</strong>
# <strong>mount -t cd9660 /dev/svnd0c /mnt</strong>
</pre>
                </td>
        </tr>
</table>
</ul>

<p>
Notice that, since this image is a CD image you must specify type of <i>cd9660</i> when mounting it. This is true, no matter what type, e.g. you must use type ffs when mounting disk images. 
</p>

<p>
To unmount the image use the following commands.
</p>

<ul>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <strong>umount /mnt</strong>
# <strong>vnconfig -u svnd0</strong>
</pre>
                </td>
        </tr>
</table>
</ul>

<p>
For more information, refer to the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8">vnconfig(8)</a> man page.
</p>


<p>
<a name= "pciideErr"></a>
<a name=14.11></a>
<h2>14.11 - Help! I'm getting errors with PCIIDE!</h2>
</p>

<p>
PCI IDE DMA is unreliable. This is why Microsoft disables it by
default on the operating systems it ships.
</p>

<p>
OpenBSD is aggressive and attempts to use the highest DMA Mode it can
configure. This will cause corruption of data transfers in some
configurations because of buggy motherboard chipsets, buggy drives,
and/or noise on the cables. Luckily, Ultra-DMA modes protect data
transfers with a CRC to detect corruption. When the Ultra-DMA CRC
fails, OpenBSD will print an error message and try the operation
again.
</p>

<ul><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79 (wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></ul>

<p>
After failing a couple times, OpenBSD will downgrade to a slower
(hopefully more reliable) Ultra-DMA mode. If Ultra-DMA mode 0 is hit,
then the drive downgrades to PIO mode.
</p>

<p>
If OpenBSD does not successfully downgrade, or the process causes
your machine to lock hard, please send in a <a href="../report.html">bug report</a>.
</p>

<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq13.html">[To Section 13.0 - IPsec]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq14.html,v 1.53 2002/01/12 01:39:29 ericj Exp $</small>
</p>
</body>
</html>
