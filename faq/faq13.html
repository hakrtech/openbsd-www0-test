<html>
<head>
<title>13.0 - Using IPSec</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright (C) 1999 OpenBSD">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">
<img alt="[OpenBSD]" height=30 width=141 src="/images/smalltitle.gif">
<p>

<p>
<font color= "#0000e0">
<a href="index.html">[Back to Main Index]</a>
<a href="faq12.html">[To Section 12.0 - For Advanced Users]</a>
<a href="faq14.html">[To Section 14.0 - Using disks in OpenBSD]</a>
</font>
</p>

<p>
<Font size="-1">
This document borrows large pieces from:
<UL>
<LI><A HREF="http://www.freebsd.org/~julian/IPSEC_4_Dummies.html">IPSec for Dummies</a> by Julian Elischer
<LI><A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&sektion=4&format=html">ipsec(4)</a> by Niels Provos, and several other people from the OpenBSD team
<LI><A HREF="http://www.secureops.com/resources/vpn/">Secureops VPN</a>
</UL>
Thanks, folks!
</font>
<p>
<h1>13.0 - Using IPSec (IP Security Protocol)</h1>
<UL>
<LI><A HREF="#13.1">13.1 - What is IPSec?</a>
<LI><A HREF="#13.2">13.2 - That's nice, but why do I want to use IPSec?</a>
<LI><A HREF="#13.3">13.3 - What are the protocols behind IPSec?</a>
<LI><A HREF="#13.4">13.4 - On the wire format</a>
<LI><A HREF="#13.5">13.5 - Configuring IPSec</a>
<LI><A HREF="#13.6">13.6 - How do I setup IPSec with manual keying?</a>
<LI><A HREF="#13.7">13.7 - How do I setup IPSec with photurisd?</a>
<LI><A HREF="#13.8">13.8 - How do I setup IPSec with isakmpd?</a>
<LI><A HREF="#13.9">13.9 - What IKE clients are compatible with isakmpd?</a>
<LI><A HREF="#13.10">13.10 - Troubleshooting IPSec/VPN</a>
<LI><A HREF="#13.11">13.11 - Related Documentation</a>
</UL>
<p>
<a name= "13.1">
<h1>13.1 - What is IPSec?</h1>
</a>
<P>
IPSec is a set of extensions to the IP protocol family.   It provides
cryptographic security services.  These services allow for authentication,
integrity, access control, and confidentiality.  IPSec provides
similar services as SSL, but at the network layer, in a way that is completely
transparent to your applications, and much more powerful.  We say this
because your applications do not have to have any knowledge of IPSec to be
able to use it.
You can use <A HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/protocols?rev=1.8">any IP protocol</a> over IPSec.  You can create encrypted tunnels (VPNs), or just do encryption between computers.
Since you have so many options, IPSec is rather complex (much more so then SSL!)
<P>
Before you start using IPSec, we strongly recommend that you check out
the "recommended reading" of <A HREF="faq6.html">part 6</a> of the FAQ.
In particular, if you don't already understand it, the <A HREF="http://www.3com.com/nsc/501302s.html">Understanding
IP Addressing</a> document is highly recommended.
<P>
In a logical sense, IPSec works in any of these three ways:
<UL>
<LI>Host-to-Host
<LI>Host-to-Network
<LI>Network-to-Network
</UL>
In every scenario that involves a network, we mean to imply
router.  As in, Host-to-Router (and this router controls and encrypts
traffic for a particular <i>Network</i>.)
<P>
As you can see, IPSec can be used to tunnel traffic for VPN connections.
However, its utility reaches beyond VPNs.  With a central Internet Key Exchange
registry, every machine on the internet could talk to another one
and employ powerful encryption and authentication!
<p>
<a name= "13.2">
<h1>13.2 - That's nice, but why do I want to use IPSec?</h1>
</a>
<P>
The internet protocol, IP, aka IPv4, does not inherently provide any protection
to your transferred data.  It does not even guarantee that the
sender is who he says he is.  IPSec tries to remedy this.  These services 
are considered distinct, but the IPSec supports them in a uniform manner. 
<P>
<h4>Confidentiality</h4> Make sure it is hard for anyone but the receiver
to understand what data has been communicated.  You do not want
anyone to see your passwords when logging into a remote machine
over the Internet.
<P>
<h4>Integrity</h4> Guarantee that the data does not get changed on the
way.  If you are on a line carrying invoicing data you probably
want to know that the amounts and account numbers are correct and
not altered while in-transit.
<P>
<h4>Authenticity</h4> Sign your data so that others can see that it is really
you that sent it.  It is clearly nice to know that documents
are not forged.
<P>
<h4>Replay protection</h4> We need ways to ensure a transaction can only
be carried out once unless we are authorized to repeat it.  I.e. it
should not be possible for someone to record a transaction, and
then replaying it verbatim, in order to get an effect of multiple
transactions being received by the peer.  Consider the attacker has
got to know what the traffic is all about by other means than
cracking the encryption, and that the traffic causes events
favourable for him, like depositing money into his account.  We
need to make sure he cannot just replay that traffic later.
<i>WARNING: as per the standards specification, replay protection is not
performed when using manual-keyed IPsec (e.g., when using <A
HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&apropos=0&sektion=8&format=html">ipsecadm(8)</a>)</i>.
<p>
<a name= "13.3">
<h1>13.3 - What are the protocols behind IPSec?</h1>
</a>
<P>
IPSec provides confidentiality, integrity, authenticity, and replay
protection through two new protocols.  These protocols are called AH,
Authentication header, and ESP, Encapsulated security payload.
<P>
AH provides authentication, integrity, and replay protection (but not
confidentiality). Its main difference with ESP is that AH also secures
parts of the IP header of the packet (like the source/destination
addresses).
<P>
ESP can provide authentication, integrity, replay protection, and
confidentiality of the data (it secures everything in the packet that follows
the  header). Replay protection requires authentication and integrity
(these two go always together). Confidentiality (encryption) can be used
with or without authentication/integrity. Similarly, one could use
authentication/integrity with or without confidentiality.
<P>
<a name= "13.4">
<h1>13.4 - On the wire format</h1>

<P>The <B>Authentication Header</B>
(AH) comes after the basic IP header and contains cryptographic
hashes of the data and identification information. The hashes can
also cover the invariant parts of the IP header itself. There are
several different RFCs giving a choice of actual algorithms to use in the
AH, however they all must follow the guidelines specified in <A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2402.html">RFC2402</A>.

<P>The <B>Encapsulating
Security Payload</B> (ESP) header, allows for rewriting of the payload
in encrypted form. The ESP header does not consider the fields of the IP
header before it and therefore makes no guarantees about anything except
the payload. The various types of ESP applicable must follow <A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2406.html">RFC2406</A>.
An ESP header can also provide authentication for the payload, (but not
the outer header).

<P>An orthogonal (mostly) division of IPSec functionality is applied depending
on whether the endpoint doing the IPSec encapsulation is the original source
of the data or a gateway:

<UL>
<LI><B>Transport</B> mode is used by a host that is generating the packets.
In transport mode, the security headers are added before the transport
layer (e.g . TCP, UDP) headers, before the IP header is prepended to the
packet. In other words an AH added to the packet will cover the hashing
of the TCP header and some fields of the end-to-end IP header, and an ESP
header will cover the encryption of the TCP header and the data, but
not the end-to-end IP header.</LI>

<LI><B>Tunnel</B> mode is used when the end-to-end IP header is already
attached to the packet, and one of the ends of the secure connection is
only a gateway. In this mode, the AH and ESP headers are used to cover
the entire packet including the end-to-end header, and a new IP header
is repended to the packet that covers just the hop to the other end of
the secure connection (though that may of course be several IP hops away).</LI>
</UL>

<P>IPSec secured links are defined in terms of <B>Security Associations
</B>(SAs). Each SA is defined for a single unidirectional flow of data,
and usually (ignoring multicast) from one single point to another, covering
traffic distinguishable by some <B>unique selector</B>. All traffic flowing
over a single SA is treated the same. Some traffic may be subject to several
SAs, each of which applies some transform. Groups of SAs are called an
SA <B>Bundle</B>. Incoming packets can be assigned to a particular SA by
the three defining fields, (<B>Destination IP address, Security Parameter
Index, security protocol</B>). SPI can be considered a cookie that is handed
out by the receiver of the SA when the parameters of the connection are
negotiated. The security protocol must be either AH or ESP. Since the IP
address of the receiver is part of the triple, this is a guaranteed unique
value. They can be found from the outer IP header and the first security
header (which contains the SPI and the security protocol).

<P>An example of a tunnel mode AH packet is:
<p>
<table border="1">
<tr>
<td><B>IPhdr</B></td>
<td><B>AH</B></td>
<td>IPhdr2</td>
<td>TCPhdr</td>
<td>data</td>
</tr>
</table>

<P>An example of a transport mode AH packet is:
<p>
<table border="1">
<tr>
<td><B>IPhdr</B></td>
<td><B>AH</B></td>
<td>TCPhdr</td>
<td>data</td>
</tr>
</table>

<P>Because an ESP header cannot authenticate the outer IP header,
it is useful to combine an AH and an ESP header to get the following:
<p>
<table border="1">
<tr>
<td><B>IPhdr</B></td>
<td><B>AH</B></td>
<td><B>ESP</B></td>
<td><I>TCPhdr</I></td>
<td><I>data</I></td>
</tr>
</table>

<P>This is called <B>Transport Adjacency</B>. The tunnelling version would
look like:
<p>
<table border="1">
<tr>
<td><B>IPhdr</B></td>
<td><B>AH</B></td>
<td><B>ESP</B></td>
<td><I>IPhdr2</I></td>
<td><I>TCPhdr</I></td>
<td><I>data</I></td>
</tr>
</table>

<P>However it is not specifically mentioned in the RFC. As with Transport
adjacency, this would authenticate the entire packet except a few headers
in the IP header and also encrypt the payload, (seen in italics). When
an AH and an ESP header are diectly applied together like this,
the order of the headers should be as shown. It is possible in tunnel mode,
to do arbitrary recursive encapsulation so that order is not specified.

<A name="13.5">
<h1>13.5 - Configuring IPSec</h1>
</a>

<P>How the IPSec systems and gateways are configured is to some extent
left to the designer, however the RFC has some strong recomendations as
to how this should be implemented, so as to minimize confusion.

<P>There are two administrative entities that control what happens to a
packet. One is the <B>Security Association Database</B> (SAD, referred
to as TDB or TDB table throughout OpenBSD's IPSec source code)
and the other is the <B>Security Policy Database</B> (SPD).

<P>They are similar in that given a number of selectors that describe some
traffic, they will deliver an entry that describes the processing needed.
However, the SPD is two steps removed from the actual processing: the
SPD is used for outgoing packets, to decide what SAD entries should
be used, and the SAD entries in turn describe the actual process and the
parameters for it. The SPD entries specify the existing SAD entries
to use (if it's a bundle there can be more than 1), but if there is not
already a suitable one, it is used to create new ones. The fields of the
SA being created can be taken either from the SPD entry or from the packet
that initiated the creation.

<P>Outgoing packets go from the SPD entry to the specific SA, to get encoding
parameters. Incoming packets get to the correct SA directly using the
SPI/DestIP/Proto triple, and from there get to the SPD entry.

<P>The SPD can also specify what traffic should bypass IPSec and what should
be dropped, so it must also be consulted for incoming non-IPSec traffic.
SPD entries must be explicitly ordered as several might match a particular
packet, and the processing must be reproducible.

<P>The SPD can be though of as similar to a packet filter where the actions
decided upon are the activation of SA processes. Selectors can include
src and dest address, port numbers if relevant, application and user IDs
if available (only on host based transport SAs), hostnames, security
sensitivity levels, protocols, etc.

<P>A SAD entry would include:

<UL>
<LI>Dest IP address
<LI>IPSec proto (SA or ESP)
<LI>SPI (cookie)
<LI>Sequence counter
<LI>Seq O/F flag
<LI>Anti-replay window info
<LI>AH type and info
<LI>ESP type and info
<LI>Lifetime info
<LI>Tunnel/transport mode flags
<LI>Path MTU info
</UL>

<P>A SPD entry would contain:

<UL>
<LI>Pointer to active SAs
<LI>Selector fields
</UL>

<P>Each SA can define one ESP header and one AH header.
An IPSec session must have one or the other or both, but cannot be defined
with neither - otherwise there would be no headers to specify the SPI
to look up the SA. The RFC doesn't say what would happen if the
AH and ESP headers disagree about the SPI value. One would presume
this would imply multiple SAs in a bundle.

<P>The SPD in OpenBSD is managed through the <tt>ipsecadm flow</tt> command.
(You would only make changes to it if you are using manual keying.)
SAD entries can be set manually with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&apropos=0&sektion=8&format=html">ipsecadm(8)</a>,
however the IETF has also defined automatic mechanisms
for initialization of sessions and such things as key exchange.
OpenBSD implements both Photuris (<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2522.html">RFC2522</a>, and
<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2523.html">RFC2523</a>)
and ISAKMP automatic key exchange
(<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC2407</a>,
<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC2408,</A> and
<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC2409</A>)
in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=photurisd&apropos=0&sektion=8&format=html">photurisd(8)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd&apropos=0&sektion=8&format=html">isakmpd(8)</a>
daemons.
<P>
<a name= "13.6">
<h1>13.6 - How do I setup IPSec with manual keying?</h1>
</a>
<P>
Manual keying is the easiest way to get started with IPSec.
You can setup encryption between networks, to create VPNs using this
method.  After you have read this section, you may want to
investigate using <A HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/rc.vpn?rev=1.3">/usr/share/ipsec/rc.vpn</a>
to set this up for you automatically.
<P>
First, you need to turn on IP AH and IP ESP options in the OpenBSD
kernel (if you are only using ESP, such as with the rc.vpn script, or
as with the example below, then <i>you do not need to enable AH</i>. In fact,
there may even be security concerns related to enabling AH if you are not
using it).<P>
There is a nice sysctl to enable these protocols.
<ul><tt>
# <b>sysctl -w net.inet.esp.enable=1</b><BR>
net.inet.esp.enable: 0 -> 1<br>
# <b>sysctl -w net.inet.ah.enable=1</b><br>
net.inet.ah.enable: 0 -> 1
</ul></tt>
You can edit <tt>/etc/sysctl.conf</tt> to turn these on at boot time.
You need to remove the # mark from in front of net.inet.esp.enable and/or
net.inet.ah.enable
(depending on which you plan to use) and make sure they are set to 1.
<P>
Now, you need to setup SAs, or Security Associations.
A Security Association is a combination of your IP addresses, an SPI, and
your security protocol (AH and/or ESP). The IP addresses are both your
own and that of your destination.  The SPI, or Security Parameter
Index, is a number that OpenBSD uses to classify different SAs.
<P>
<I>These examples only use ESP to encrypt your traffic.  ESP includes
authentication of the contained encrypted data, but does not authenticate
the surrounding IP header, as AH would.  This "limited authentication"
is nevertheless quite sufficient in most cases, especially for ESP in a
tunnel environment.</i>
<P>
<ul>
<tt>
# <b>ipsecadm new esp -spi SPI_OUT -src MY_EXTERNAL_IP -dst PEER_EXTERNAL_IP
-forcetunnel -enc blf -auth sha1 -key ENC_KEY -authkey AUTH_KEY</b>
</tt>
</ul>
<P>
Let's put this into practice with two routers, 192.168.5.1 and 192.168.25.9.
<P>
On Host 192.168.5.1:
<ul>
<tt>
# <b>ipsecadm new esp -spi 1000 -src 192.168.5.1 -dst 192.168.25.9 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b><BR>
# <b>ipsecadm new esp -spi 1001 -dst 192.168.5.1 -src 192.168.25.9 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b>
</tt>
</ul>
On Host 192.168.25.9:
<UL>
<tt>
# <b>ipsecadm new esp -spi 1001 -src 192.168.25.9 -dst 192.168.5.1 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b><BR>
# <b>ipsecadm new esp -spi 1000 -dst 192.168.25.9 -src 192.168.5.1 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b>
</TT>
</ul>
<P>
Notice that the SPIs are different.  See <A HREF="#13.4">On the wire format</a> for a complete description of what the SPI is and where it is used.
<P>
Now that you have your Security Associations in place,
set up your flows.
<P>
Note that, with the -local option, ipsecadm will actually create two flows,
one with the source address set to 0.0.0.0/32, which handles packets
originating from the gateway.
<P>
On 192.168.5.1:<P>
So, right here, <b>two</b> flows will be created, one with 0.0.0.0/32 as the
source address, which covers all packets originating from the local host
to the destination, as well as a flow from the destination back to the local
host.
<ul>
<tt>
# <b>ipsecadm flow -proto esp -dst 192.168.25.9 -spi 1000
-addr 192.168.5.1 255.255.255.255 192.168.25.9 255.255.255.255 -local</b>
</tt></ul>
On 192.168.25.9:
<ul>
<tt>
# <b>ipsecadm flow -proto esp -dst 192.168.5.1 -spi 1001
-addr 192.168.25.9 255.255.255.255 192.168.5.1 255.255.255.255 -local</b>
</tt></ul>
<P>
If you want less overhead on your Host-to-Host VPNs, creating the SPI
without <tt>-forcetunnel</tt> will let you use transport mode (whereas, <tt>-forcetunnel</tt>
makes sure all of the IP packet, including the IP header, are encapsulated
by SPI).  If either
the source or destination is a network, you will have to use tunnel
mode.  Creating an SA to and/or from a network will automatically ensure
tunnel mode SPIs are being created.
<p>
This is a simple way to start using IPSec.
<P>
You can use IPSec to tunnel private IP address spaces over the Internet.
Here is a good example... We want to tunnel 192.168.99.0/24, which is behind
208.1.1.1, to 208.1.2.0/24 and 208.1.5.0/24 which are behind 208.2.2.2.
These examples were generated using the <A HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/rc.vpn?rev=1.3">rc.vpn</a> script.
<P>
As you can see, when you are using manual keying with IPSec,
you have to specify <b>exactly</b> what you want done.
It won't guess for you.  Look at these examples...
<h2>On 208.1.1.1:</h2>
First, set up the security associations (SAs):<BR>
(This sets up the SPIs, encryption methods, and keys.) 
<UL><tt>
# <b>ipsecadm new esp -src 208.1.1.1 -dst 208.2.2.2 -forcetunnel -spi 1001 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -src 208.2.2.2 -dst 208.1.1.1 -forcetunnel -spi 1000 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
</ul></tt>
Next, setup a flow from 208.1.1.1 to 208.2.2.2
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.2.2.2 255.255.255.255 -local</b><br>
</ul></tt>
Next, setup a flow from 208.1.2.0/24, which is behind 208.2.2.2, to 192.168.99.0/24
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.1.2.0 255.255.255.0</b><BR>
</ul></tt>
Next, setup a flow from 208.1.5.0/24, which is behind 208.2.2.2, to 192.168.99.0/24
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.1.5.0 255.255.255.0</b><br>
</ul></tt>
Now, setup a flow from 208.1.2.0/24, which is behind 208.2.2.2 to the router 208.1.1.1.
<ul><tT>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.1.2.0 255.255.255.0 -local</b><br>
</ul></tt>
OK, setup a flow from 208.1.5.0/24, which is behind 208.2.2.2, to the router 208.1.1.1
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.1.5.0 255.255.255.0 -local</b><br>
</ul></tt>
Finally, setup a flow from the router 208.2.2.2 to 192.168.99.0/24
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.2.2.2 255.255.255.255</b><br>
</ul></tt>
<P>
<h2>On 208.2.2.2:</h2>
Same as before, we setup the SAs...
<UL><TT>
# <b>ipsecadm new esp -src 208.2.2.2 -dst 208.1.1.1 -forcetunnel -spi 1000 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -src 208.1.1.1 -dst 208.2.2.2 -forcetunnel -spi 1001 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
</ul></tt>
Now, this is the reverse side...
Setup a flow from the router 208.2.2.2 to 208.1.1.1
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.2.2.2 255.255.255.255 208.1.1.1 255.255.255.255 -local</b><br>
</ul></tt>
Setup a flow from the network 192.168.99.0/24, which is behind 208.1.1.1, to 208.1.2.0/24
<ul><tT>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.2.0 255.255.255.0 192.168.99.0 255.255.255.0</b><br>
</ul></tt>
Setup a flow from the network 192.168.99.0/24, which is behind 208.1.1.1, to 208.1.5.0/24
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.5.0 255.255.255.0 192.168.99.0 255.255.255.0</b><br>
</ul></tt>
Now, setup a flow from 192.169.99.0/24, which is behind 208.1.1.1, to the router 208.2.2.2
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.2.2.2 255.255.255.255 192.168.99.0 255.255.255.0 -local</b><br>
</ul></tt>
We're almost done...
Two flows left to get 208.1.2.0/24 and 208.1.5.0/24 from the router 208.2.2.2
to the router 208.1.1.1.
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.2.0 255.255.255.0 208.2.2.2 255.255.255.255</b><br>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.5.0 255.255.255.0 208.2.2.2 255.255.255.255</b><br>
</ul></tt>
<P>
If you have been using ipsecadm, and you want to get rid of any work
that you've done, and start from scratch, do
<ul><tt>
# <b>ipsecadm flush</b>
</ul></tt>
This will flush all IPSec info (SPIs, flows, routing entries) from your system.
<P>
<a name="13.7">
<h1>13.7 - How do I setup IPSec with photurisd?</h1>
</a>
<P>
Photuris is not widely used and is still considered experimental
as far as the RFC status is concerned.  However, many people have used it
with OpenBSD.
<P>
To setup your photurisd, first edit /etc/photuris/secrets.conf
on each host with photurisd.
<UL>
<PRE>
bsd# <b>cat /etc/photuris/secrets.conf</b>
# Accepted keywords are:
# identity local "id" "secret"
# identity pair local "receivedid" "myid" "secret"
# identity remote "id" "secret"
# identity lookup "tag" username
# Simple 
identity local "Default" "This should be changed."
identity remote "Default" "This should be changed."
</PRE></UL>
Change "This should be changed." to a key of your choice on the local config,
and another key of your choice on the remote config.  (Use the same config
on your remote box but swap "local" and "remote" so that it sees itself as the local key.)
Note that these keys will be replaced in a future version of photurisd 
that will carry out its initial key exchange with public keys.
<P>
Make sure <tt>net.inet.ah.enable</tt> is set to 1.
<UL><PRE>
bsd# <b>sysctl -w net.inet.ah.enable=1</b>
net.inet.ah.enable: 0 -> 1
</PRE></UL>
And run startkey.
<UL><PRE>
bsd# <b>startkey dst=remote.host</B>
</PRE></UL>
Now, run tcpdump to verify that your packets are being encrypted with AH.
(Run a ping in another window or session to generate traffic.)
<PRE><UL>
bsd# <b>tcpdump proto ah</b>
</PRE></UL>
You can also try using tcpdump by the host address if you aren't getting anything.
<PRE><UL>
bsd# <b>tcpdump host remote.host</b>
</PRE></UL>
You can make photurisd automatically set the source and destination
host or networks in /etc/photuris/photuris.startup

<P> <a name="13.8"> <h1>13.8 - How do I setup IPSec with isakmpd?</h1>
</a> <P>If you are thinking about VPNs or other traditional applications
of IPSec, you probably are going to use ISAKMP.  Some commercial
implementations of IPSec do not provide any manual keying ability, instead
they require you to use some form of ISAKMP.
<P>

<h3>13.8.1 - What is isakmpd?</h3> ISAKMP (sometimes referred to as IKE,
or Internet Key Exchange) is the key exchange mechanism for the VPN. It
meets security concerns using the methods mentioned in RFC 2407, RFC 2408
and RFC 2409. ISAKMP manages the exchange of cryptographic keys that you
would normally have to manage with <A
HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&apropos=0&sektion=8">ipsecadm(8)</a>.
It employs a two-phase process for establishing the IPSec parameters
between two IPSec nodes.

<P> <b>Phase 1</b> - The two ISAKMP peers establish a secure,
authenticated channel upon which to communicate between two daemons. This
establishes a Security Association (SA) between both hosts. <b>Main
Mode</b> and <b>Aggressive Mode</b> are the methods used to establish this
channel. Main Mode sends the various authentication information in a
certain sequence, providing identity protection. Aggressive Mode does not
provide identity protection because all of the authentication information
is sent at the same time. Aggressive mode should only be used in such
cases where network bandwidth is of concern.
<P>

<b>Phase 2</b> - Security Associations are negotiated on behalf of IPSec.
Phase 2 is establishes tunnels or endpoint SA's between IPSec hosts.
<b>Quick Mode</b> is used in Phase 2 because there is not need to repeat a
full authentication because Phase 1 has already established the SAs.

<P>

In brief, Phase 1 is used to get a secure channel in which to do the
(quicker) phase 2 setups, there can be several. Phase 2 is used to setup
the actual tunnels. In Phase 1, your IPSec nodes establish a connection
where they exchange authentication (Either a X509 certificate or a
pre-shared secret). This allows each end to make sure the other end is
authenticated.  Phase 2 is an exchange of keys to determine how the data
between the two will be encrypted.

<h3>13.8.2 - How do I get started with isakmpd?</h3>

<P>
By default, OpenBSD 2.6 comes with the proper binaries for ISAKMP and the
IPSec stack. Unfotunately, the same
cannot be said for the sample files. To retrieve them, you need to grab:
/usr/src/sbin/isakmpd/samples/VPN-east.conf and
/usr/src/sbin/isakmpd/samples/policy from the source tree.  You can
either use your CD (if you have one), <A
HREF="http://www.openbsd.org/cgi-bin/cvsweb/">cvsweb</a>, or
the <A HREF="http://www.usa.openbsd.org/anoncvs.html">command line CVS
client</a>. (Cvsweb has <A
HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/samples/VPN-east.conf">VPN-east.conf</a>
and <A
HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/samples/policy">policy</a>
readily available).  For the purposes of this example, copy <i>policy</i>
to /etc/isakmpd/policy.  Copy <i>VPN-east.conf</i> to /etc/isakmpd/conf.
Here we attempt to show you how to setup a VPN (tunnel).  If you want to
use isakmpd between single hosts, there are other configuration files in
the <i>samples</i> directory.

<P>
Your first step is to turn on esp.  The <A HREF="#13.6" TARGET="_blank">top
of section 13.6</a> tells you how to do this both for run-time and boot.
Next, you need to edit /etc/isakmpd/policy.  
This file tells ISAKMP who can access IPSec. In this scenario, the policy file states that anybody who sends data
using Encapsulate Security Payload(ESP), and has authenticated with the passphrase mekmitasdigoat (or whatever
passphrase you determine), is allowed to communicate with isakmpd.  You can modify this file to let ISAKMP know that we only
want to allow data signed with certain digital certificates or using a certain encryption transform. You could also
allow anybody to access IPSec.  This is only recommended for testing.
To do this, edit your policy file to contain only the following lines:
<BR>
<PRE>
KeyNote-Version: 2
Authoriser: "POLICY"
</PRE>
<P>
The same policy file contains two lines that start with the $ character.
You need to remove these lines before using it, they are only for cvs.  
<P>
A more useful policy file for this example looks like this:
<BR><PRE>
KeyNote-Version: 2
Comment: This policy accepts ESP SAs from a remote that uses the right password
Authoriser: "POLICY"
Licensees: "mekmitasdigoat"
Conditions: app_domain == "IPSec policy" &&
            esp_present == "yes" -> "true"; 
</pre>
This should be identical to the policy file included with OpenBSD 2.6.
<P>
Implementing this will give you a basic VPN (tunnel) using ESP only.
On host A, edit /etc/isakmpd/isakmpd.conf.  The 249.2.2.2 sample IP address
should be replaced with the external IP address of host A.

<PRE>
[General] 
Retransmits=		5
Exchange-max-time=	120
Listen-on=		249.2.2.2
</PRE>

Do similar for isakmpd.conf on host B.  249.3.3.3 represents the
external IP address for host B.

<PRE>
[General]
Retransmits=		5
Exchange-max-time=	120
Listen-on=		249.3.3.3
</PRE>

<p>This is where you can setup the variables that will affect the main behaviour of isakmpd. It is okay to 
use the defaults here.<br>
The <b>Listen-on</b>= value specifies the IP 
that isakmpd should listen on. Only the Internet IP of your gateway is necessary.
If you have multiple external interfaces on your gateway, 
you could list which interfaces you want to listening on by entering them using a comma separated list.
<P>
Next, on host A, edit isakmpd.conf again.

<PRE>
[Phase 1]
249.3.3.3=		HostB
</PRE>

On host B:

<PRE>
[Phase 1]
249.2.2.2=		HostA
</PRE>

<p>This section describes the IP addresses to accept in order to negotiate the phase 1 connection. 
Its value points to the section below (Remember that phase 1 simply 
authenticates the remote peer to make sure they are who they say they are). You can list multiple peers with additional lines in the format of
IP_Address=<i> &lt;PEER-NAME&gt;.</i><br>
<p>
Next, on host A:
<PRE>
[Phase 2]
Connections=		HostA-HostB
</PRE>

On host B:

<PRE>
[Phase 2]
Connections=		HostB-HostA
</PRE>

<p>This describes Phase 2 of the connection. This is the phase that determines what protocols the two 
peers will use to communicate.

<p>The <b>Connections</b>= tag refers to the section below. 
It initiates the requirements or the accepted methods to set up Phase 2. This also tells ISAKMPD which 
connections to initiate once started. Note that you can have multiple sections
as illustrated below 
if you are to connect with multiple peer hosts.

<p>If you do not have the IP address of the remote host, you can specify a Default= that points 
to a section describing a generic entry that will be referenced by any 
incoming IP that is not listed in the <b>Connections</b>= tag.
<P>
On host A:
<PRE>
[HostB]
Phase=			1
Transport=		udp
Local-address=		249.2.2.2
Address=		249.3.3.3
Configuration=		Default-main-mode
Authentication=		mekmitasdigoat
#Flags=
</PRE>

On host B:

<PRE>
[HostA]
Phase=			1
Transport=		udp
Local-address=		249.3.3.3
Address=		249.2.2.2
Configuration=		Default-main-mode
Authentication=		mekmitasdigoat
#Flags=
</PRE>

These represent the sections referred to by the Phase 1 section above. They each 
describe the requirements that the peer gateway must fulfil in order to proceed to Phase 2. There are 
many other options here but the ones mentioned above are the minimum requirements.<br>
<b>Phase=1 </b>is required because the ISAKMPD code uses the same procedures to process Phase 1 and 
Phase 2. It must be <b>1</b> or nothing will work.<br>
<b>Transport= </b>is gives you different possibilities for different peers. It's 
suggested that udp be used here so we'll leave it at that.<br>
Please note that some peers may be behind a firewall that doesn't let UDP traffic through.  Obviously, this needs to be determined before setup.
<b>Local-address </b>is the destination address that the incoming packets point to. In some cases, you 
can be listening on different Interfaces for Phase 1 connections.
In this example, there is only 1 interface listening, therefore this is the IP of the listening 
interface on this peer.<br>
<b>Address= </b>is the address that points to the source IP of the incoming packets. This usually points 
to the peer gateway. 
This needs further explanation, because the source IP address of the peer may be unknown!
<b>Configuration= </b>points to the section below. You can specify 
multiple sections like this. We use the default one 
specified by the sample file.<br>
<b>Authentication=</b> is the pre-shared secret to be used for this particular peer. It is more or less 
a passphrase that each peer uses. This passphrase gets passed to policy to verify whether this 
peer is allowed to use IPSEC with this host. If you change this phrase, you must also change it in the 
policy file because the sample file provides for this passphrase. If you decided to go with a 
minimum policy file then you can specify whatever you want here.<br>
<b>Flags=</b> is not currently being used. The RFCs leave room for extra options to be specified for 
phase 1.<br>
There are other tags here that will allow for other options to be set. Refer to 
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&apropos=0&sektion=5&format=html">isakmpd.conf(5)</a>
for descriptions.
<P>
On Host A:
<PRE>
[HostA-HostB]
Phase=			2
ISAKMP-peer=		HostB
Configuration=		Default-quick-mode
Local-ID=		Net-A
Remote-ID=		Net-B
</PRE>

On Host B:
<PRE>
[HostB-HostA]
Phase=			2
ISAKMP-peer=		HostA
Configuration=		Default-quick-mode
Local-ID=		Net-B
Remote-ID=		Net-A
</PRE>

<p>These represent the sections referred to by the Phase 2 section above. They are the 
individual settings that ISAKMPD must use to talk between the two gateways for the particular 
connection.
<b>Phase=2</b> is required because ISAKMPD code uses the same functions to authenticate Phase 1 and Phase 
2. This is required for the VPN to work.<br>
<b>ISAKMPD-Peer=</b> is the name of Host section above. This means that we are 
talking to that particular peer to establish a Phase 2 connection. This is provided because you can have 
multiple sections to describe isakmp peers and connections.
<b>Configuration=</b> refers to the section below that describes the 
standards by which this host and the particular peer for this connection must abide.<br>
<b>Local-ID=</b> refers to an IPSec-ID section below that describes our Private Network to 
the peer gateway. This is the portion that is passed so that the other gateway can set up the proper 
routing table that will transfer data over the VPN to our network.<br>
<b>Remote-ID=</b> refers to an IPSec-ID section below that describes what is supposed to be 
the remote Private Network to our host. This portion is interpreted to set up the proper routing tables 
that will transfer data from our Private Network over the VPN to the remote Private Network.<br>
There is another tag that is supported here called Flags=. If you require this tag, read 
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&apropos=0&sektion=5&format=html">isakmpd.conf(5)</a>.
<P>
This is the IPSec-ID section.  These entries need to exist
in the isakmpd.conf files for both Host A and Host B.  This example
will setup 192.168.1.0/255.255.255.0 for Host A (which was connected
to Net-A above) and 192.168.20.0/255.255.255.0 for Host B (Net-B above).
<PRE>
[Net-A]
ID-type=		IPV4_ADDR_SUBNET
Network=		192.168.1.0
Netmask=		255.255.255.0

[Net-B]
ID-type=		IPV4_ADDR_SUBNET
Network=		192.168.20.0
Netmask=		255.255.255.0
</PRE>

<p>These two sections are in the <b>conf</b> file of each host. They are the sections referenced by the 
<b>Local-ID</b> and <b>Remote-ID</b> identifiers. They describe the 
routes that should be set up to allow traffic from one private network to another.<br>
<b>ID-type</b>= can be <b>IPV4_ADDR_SUBNET</b> or <b>IPV4_ADDR</b> (RFC2708 mentions more possible values. Currently only IPv4 is supported in the OpenBSD 2.6 implementation.  IPv6 may be supported in OpenBSD-current. )
 
<P>
Now, on both hosts, the sample file should read:
<PRE>
[Default-main-mode]
DOI=			IPSEC
EXCHANGE_TYPE=		ID_PROT
Transforms=		3DES-SHA
</PRE>

This section describes the requirements for the encryption methods of Phase 1 connections. The name 
reflects the value of <i>Configuration=</i> variable.  As we can see here, we are stating our 
Domain of Interest which is IPSEC. The <b>EXCHANGE_TYPE</b> variable is set to <b>ID_PROT</b> for Phase 1, 
which identifies the protocols to be covered by this Authentication.<br>
<b>Transforms=</b> is the transform required (or assigned) for this exchange. In this case, this points to 
the section below in the configuration file that says we are receiving a packet 
encrypted with 3DES and a checksum verifiable with SHA. There are a bunch of different transforms defined 
inside the sample <b>VPN-east.conf</b>. These are provided because 3DES and SHA are not always supported 
across different platforms. For OpenBSD there should be no reason to change this for a basic setup. Feel 
free to create multiples of this section and change the transform. The only requirement is that you change  the Configuration= variable.

<PRE>
[Default-quick-mode]
DOI=			IPSEC
EXCHANGE_TYPE=		QUICK_MODE
Suites=			QM-ESP-3DES-SHA-PFS-SUITE,QM-ESP-DES-MD5-PFS-SUITE
</PRE>

<p>This section describes the requirements for the encryption of the data to be sent through the VPN and 
is referred to by <i>Configuration</i> above. Note the difference between this 
section and the Phase 1 equivalent just above is that the <b>EXCHANGE_TYPE</b> is <b>QUICK_MODE</b>. 
This is always the case for Phase 2.<br>
<b>Suites=</b> points to a IPSec Suite section describing the different encryption 
schemes available between the two hosts.<br>
There is much more to be said about ISAKMP and IPSec. By using the above basic descriptions you should 
be able to create a simple but solid VPN that cares and feeds itself.
This is the bare <i>minimum</i> 
<b>isakmpd.conf</b> for both hosts here.
 
<h3>13.8.3 - Starting isakmpd</h3>
You may wish to use
<b>$ isakmpd -d -DA=99</b><br>
the first time you decide to run this daemon. The daemon will not be running in daemon mode but as a 
regular process. It will log everything to your terminal.  To stop isakmpd
and flush the routes, you need to kill the isakmpd process on each node,
and run <b>ipsecadm flush</b>.

<P>
<a name= "13.9">
<h1>13.9 - What IKE clients are compatible with isakmpd?</h1>
</a>
<P>
<tt>isakmpd</tt> is the ISAKMP/Oakley key management daemon that comes with OpenBSD.
We suspect that it interoperates, at least partially, with most any ISAKMP
implementation, but the following have actually been tested.   Note that some
isakmp software out there is actually based on the OpenBSD isakmp daemon.
<P>
The following MS-Windows clients have been reported to be compatible:
<UL>
<LI><A HREF="http://www.timestep.com/">TimeStep</a> PERMIT/Client
<LI><A HREF="http://www.vpcom.com/">Ashley Laurent</a> VPCom VPN software
<LI><A HREF="http://www.nai.com/asp_set/products/tns/pgp_vpn.asp">PGP VPN</a> software
<LI><A HREF="http://www.radguard.com/">Radguard</a> cIPro client
<LI><A HREF="http://www.cisco.com/">Cisco</a> Win32 client (<i>unreleased?</i>)
</UL>
<P>
The following gateways/routers have been reported to be compatible:
<UL>
<LI><A HREF="http://www.cisco.com/">Cisco</a> IOS
<LI><A HREF="http://www.cisco.com/">Cisco</a> PIX
<LI><A HREF="http://www.intel.com/">Intel</a> LanRover
<LI><A HREF="http://www.timestep.com/">TimeStep</a> PERMIT/Gate
<LI><A HREF="http://www.cendio.com/">Cendio</a> Fuego
<LI><A HREF="http://www.kame.net/">KAME</a> for FreeBSD
<LI><A HREF="http://www.xs4all.nl/~freeswan/">FreeS/WAN</a> for Linux
<LI><A HREF="http://www.axent.com/">Axent</a> Raptor
<LI><A HREF="http://www.ericsson.com/">Ericsson</a> eBox
<LI><A HREF="http://www.radguard.com/">Radguard</a> cIPro-VPN
<LI><A HREF="http://www.f-secure.com/">F-Secure</a> VPN+
<LI><A HREF="http://www.teamware.com/">Teamware</a> TWISS
<LI><A HREF="http://www.3com.com/">3com</a> Pathbuilder
<LI><A HREF="http://www.nortelnetworks.com/">Nortel</a> Contivity
<LI><A HREF="http://www.checkpoint.com/">CheckPoint</a> FW-1
</UL>
<P>
<a name= "13.10">
<h1>13.10 - Troubleshooting IPSec/VPN</h1>
</a>
<P>
Your first tool for troubleshooting IPSec is <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&apropos=0&sektion=8&format=html">tcpdump(8)</a>.
Use <tt>tcpdump</tt> to look for several things.
<P>
First, if you are running
OpenBSD 2.6, you have an enhanced version of tcpdump which can show some
information about ESP and AH packets.  If you are using tcpdump from OpenBSD
2.5 or on another operating system, chances are you have an older
version that will simply show the protocol number for AH or ESP if it sees
either kind of packets on your network.  (ESP is IP protocol 50, AH is 51)
<UL>
<P>
<LI>
With tcpdump, look and see if traffic is using AH/ESP or cleartext.
If your traffic is in cleartext, then your flows are setup incorrectly
or your isakmp is not negotiating properly.  Use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&apropos=0&sektion=8&format=html">ping(8)</a>
to generate simple traffic.
<P>
<UL>
For instance, I have two hosts, 208.1.1.1 and 208.2.2.2.  
Logged in to 208.2.2.2, I am doing this:
<PRE>
vpn# <b>ping -c 3 208.1.1.1</b>
PING esp.mil (208.1.1.1): 56 data bytes
64 bytes from 208.1.1.1: icmp_seq=0 ttl=255 time=190.155 ms
64 bytes from 208.1.1.1: icmp_seq=1 ttl=255 time=201.040 ms
64 bytes from 208.1.1.1: icmp_seq=2 ttl=255 time=165.481 ms
--- esp.mil ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 165.481/185.558/201.040 ms
</PRE>
And in another session, I can see my encapsulated pings:
<PRE>
vpn# <b>tcpdump -ni fxp7 host 208.1.1.1</b>
tcpdump: listening on fxp7
14:12:19.630274 esp 208.2.2.2 > 208.1.1.1 spi 0x00001000 seq 4535 len 116
14:12:19.813519 esp 208.1.1.1 > 208.2.2.2 spi 0x00001001 seq 49313 len 116
14:12:20.630277 esp 208.2.2.2 > 208.1.1.1 spi 0x00001000 seq 4536 len 116
14:12:20.832458 esp 208.1.1.1 > 208.2.2.2 spi 0x00001001 seq 49314 len 116
14:12:21.630273 esp 208.2.2.2 > 208.1.1.1 spi 0x00001000 seq 4537 len 116
<b>^C</b>
1831 packets received by filter
0 packets dropped by kernel
</PRE>
</ul>
<P>
<LI>IKE runs on UDP port 500.  If this is locked out through a firewall
or packet filter, then you need to change it!
<P>
<LI>With tcpdump on OpenBSD, you can decode most cleartext parts of Internet
Key Exchange sessions.  If you are using tcpdump from a version of OpenBSD
that is <i>newer</i> then 2.6-RELEASE, tcpdump will also show AH payload
data.  If you are interested in a patch to do this for an older
version of tcpdump, contact <A HREF="mailto:ho@openbsd.org">ho@openbsd.org</a>.
<P>
<LI>Mount a /kern filesystem (if you don't use one by default already.)
<P>
<UL><TT>
# <b>mkdir /kern; mount -t kernfs /kern /kern</b>
</UL></TT>
<P>
In /kern, there is a table of current SA/SPIs, including which have flows
(outgoing SAs) or not (incoming SAs).
There are also traffic counters which you can use to see what traffic going
where.
<P>
<LI>Finally, you can use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">netstat(1)</a> to see your SAs.
<UL><PRE>
vpn% <b>netstat -rn -f encap</b>
Routing tables

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto) 
0.0.0.0/32         0     192.168.99/24      0     0     208.1.1.1/00001000/50
0.0.0.0/32         0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.1.2.0/24       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.1.2.0/24       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.1.5.0/24       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.1.5.0/24       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.2.2.2/32       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.2.2.2/32       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
</PRE></UL>
<P>
<LI>
If all else fails, recompile your kernel with <tt>option ENCDEBUG</tt>.
Then, set the sysctl <tt>net.inet.ip.encdebug</tt> to 1.  Look in your dmesg for
warnings or errors, and report them using <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sendbug&apropos=0&sektion=1&format=html">sendbug(1)</a>
to the OpenBSD developers.  Alternately, if you are not sure you have
actually run into a bug, you may want to send a message to one of the <A HREF="/mail.html">mailing lists</a>.
</UL>
<P>
<a name= "13.11">
<h1>13.11 - Related Documentation</h1>
</a>
<p>
IPSec is partially documented in the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vpn&apropos=0&sektion=0&format=html">vpn(8)</a>
man page.  There are various configuration templates in <A HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/">/usr/share/ipsec/</a>
directory which can also assist you.  The manual pages for
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&apropos=0&sektion=4&format=html">enc(4)</a>,
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&apropos=0&sektion=4&format=html">ipsec(4)</a>,
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&apropos=0&sektion=8&format=html">ipsecadm(8)</a>,
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=photurisd&apropos=0&sektion=8&format=html">photurisd(8)</a>,
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=startkey&apropos=0&sektion=1&format=html">startkey(1)</a>,
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd&apropos=0&sektion=8&format=html">isakmpd(8)</a> and
<a HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&apropos=0&sektion=5&format=html">isakmpd.conf(5)</a>
are detailed and can assist in setup and operation of IPSec.
<P>
Other links...
<UL>
<LI><A HREF="http://www.ietf.org/html.charters/ipsec-charter.html">IETF IPSec Working Group</a>
<LI><A HREF="http://isakmp-test.ssh.fi/">SSH IPSec interoperability Test Node</a>
<LI><A HREF="http://ipsec-wit.antd.nist.gov/">NIST IPSec Web Based Interoperability Tester</a>
<LI><A HREF="http://www.r4k.net/ipsec/">A port of OpenBSD's IPSec to FreeBSD</a>
<LI><A HREF="http://www.xs4all.nl/~freeswan/">FreeS/WAN - IPSec for Linux</a>
<LI><A HREF="http://www.cs.umass.edu/~lmccarth/ipsec.html">Lots of IPSec related links</A>
<LI><A HREF="http://www.codetalker.com/greenbox/docs/vpn-24-minifaq.html">OpenBSD 2.4 VPN Configuration Mini-FAQ</a>
</UL>
<p> 
And on to the RFCs...
<UL>
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2085.html">RFC 2085</a> - HMAC-MD5 IP Authentication with Replay Prevention
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2104.html">RFC 2104</a> - HMAC: Keyed-Hashing for Message Authentication
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2207.html">RFC 2207</a> - RSVP Extensions for IPSec Data Flows
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2401.html">RFC 2401</a> - Security Architecture for the Internet Protocol (<b>IPSec</b>)
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2402.html">RFC 2402</A> - IP Authentication Header (<b>AH</b>)
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2403.html">RFC 2403</A> - The Use of HMAC-MD5-96 within ESP and AH
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2404.html">RFC 2404</A> - The Use of HMAC-SHA-1-96 within ESP and AH
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2405.html">RFC 2405</A> - The ESP DES-CBC Cipher Algorithm With Explicit IV
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2406.html">RFC 2406</A> - IP Encapsulating Security Payload (<b>ESP</b>)
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC 2407</A> - The Internet IP Security Domain of Interpretation for ISAKMP
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC 2408</A> - Internet Security Association and Key Management Protocol (<b>ISAKMP</b>)
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC 2409</A> - The Internet Key Exchange (<b>IKE</b>)
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2410.html">RFC 2410</A> - The NULL Encryption Algorithm and Its Use With IPsec (ha ha...)
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2411.html">RFC 2411</A> - IP Security Document Roadmap
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2412.html">RFC 2412</A> - The OAKLEY Key Determination Protocol
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2451.html">RFC 2451</a> - The ESP CBC-Mode Cipher Algorithms
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2522.html">RFC 2522</a> - Photuris: Session-Key Management Protocol
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2523.html">RFC 2523</a> - Photuris: Extended Schemes and Attributes
<LI><A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2709.html">RFC 2709</a> - Security Model with Tunnel-mode IPsec for NAT Domains
</UL>

<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq12.html">[To Section 12.0 - For Advanced Users]</a>
<a href= "faq14.html">[To Section 14.0 - Using disks in OpenBSD]</a>
</font>
<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq13.html,v 1.24 2000/03/04 01:37:00 ericj Exp $</small>
</p>
</body>
</html>
