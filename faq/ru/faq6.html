<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Сеть</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 6 - Networking">
<meta name= "keywords"      content= "openbsd,faq6">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2012 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../ru/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ-Index]</a>
<a href="faq5.html">[Глава 5 - Сборка системы из исходников]</a>
<a href="faq7.html">[Глава 7 - Клавиатура и дисплей]</a>
</font>

<h1><font color="#e00000">6 - Сеть</font></h1>
<hr>

<p>
<h3>Содержание</h3>
<ul>
<li><a href="#Intro"    >6.1 - Перед тем, как начать</a>
<li><a href="#Setup"    >6.2 - Настройка сети</a>
<ul>
  <li><a href="#Setup.if"      >6.2.1 - Поиск и настройка сетевых интерфейсов</a>
  <li><a href="#Setup.gateway" >6.2.2 - Шлюз по умолчанию</a>
  <li><a href="#Setup.resolver">6.2.3 - Разрешение DNS</a>
  <li><a href="#Setup.myname"  >6.2.4 - Имя хоста</a>
  <li><a href="#Setup.activate">6.2.5 - Применение настроек</a>
  <li><a href="#Setup.chkroute">6.2.6 - Проверка маршрутизации</a>
  <li><a href="#Setup.forward" >6.2.7 - Настройка OpenBSD для работы в качестве шлюз</a>
  <li><a href="#Setup.aliases" >6.2.8 - Настройка алиасов для сетевых интерфейсов</a>
</ul>
<li><a href="#PF"       >6.3 - Как настроить фильтрацию и использовать OpenBSD в качестве фаервола?</a>
<li><a href="#DHCP"     >6.4 - Dynamic Host Configuration Protocol (DHCP)</a>
<ul>
  <li><a href="#DHCPclient">6.4.1 - DHCP клиент</a>
  <li><a href="#DHCPserver">6.4.2 - DHCP сервер</a>
</ul>
<li><a href="#PPP"      >6.5 - Point to Point Protocol (PPP)</a>
<li><a href="#Tuning"   >6.6 - Тюнинг параметров сети</a>
<li><a href="#NFS"      >6.7 - Использование NFS</a>
<li><a href="#Bridge"   >6.9 - Настройка сетевого моста в OpenBSD</a>
<li><a href="#PXE"      >6.10 - PXE загрузка (i386, amd64)</a>
<li><a href="#CARP"     >6.11 - Common Address Redundancy Protocol (CARP)</a>
<li><a href="#OpenNTPD" >6.12 - Использование OpenNTPD</a>
<li><a href="#Wireless" >6.13 - Использование беспроводных сетей</a>
<li><a href="#Multipath">6.14 - Как мне настроить equal-cost multipath routing?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Перед тем, как начать</h2>

<p>
В понимании этого документа вам поможет хотя бы краткое знакомство с пятой главой
FAQ <a href="faq5.html">Сборка системы из исходников</a>, а также с man-страницами
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> и
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a>.

<p>
Если вы сетевой администратор и настраиваете протоколы маршрутизации, т.е.
используете OpenBSD в качестве маршрутизатора, или если вам
нужно тщательно изучить организацию IP-сетей, мы настроятельно рекомендуем
вам прочитать
<a href="http://www.scribd.com/doc/52483921/3Com-Understanding-IP-Addressing">
Understanding IP Addressing</a>. Это отличный документ. Он содержит
фундаментальную базу, знакомство с которой поможет при расчетах для
работы с IP-сетями, особенно если вы отвечаете за более чем одну сеть.

<p>
Если же вы работаете с web, ftp или почтовыми серверми, вам может помочь
<a href="http://www.rfc-editor.org/rfc.html">RFC</a>. Скорее всего вы не
сможете прочитать его полностью. Но это и не нужно; выберите некоторые темы,
которые вас заинтересовали, или те, которые имеют отношение к тому, что вы
используете в вашей сети. RFC описывет принцип работы очень многих (тысячи)
стандартов Internet-протоколов.

<p>
<a name="Setup"></a>
<h2>6.2 - Настройка сети</h2>

Как правило, процесс настройки сети проходит <a href="faq4.html">во время
установки</a> OpenBSD. Тем не менее, не помешает разобраться в этом процессе
как можно глубже, и иметь четкое  представление о принципах конфигурации сети.
Все сетевые настройки хранятся в конфигурационных файлах в каталоге <i>/etc</i>.

<p>
<a name="Setup.if"></a>
<h3>6.2.1 - Поиск и настройка ваших сетевых интерфейсов</h3>

<p>
В OpenBSD сетевые интерфейсы называются по имени типа карты (используемого им
драйвера), а не по типу соединения. Вы можете увидеть как проходит настройка
вашей сетевой карты во время загрузки, используя команду
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">
dmesg(8)</a>. Вы также можете увидеть имя вашего сетевого интерфейса, используя
команду <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Например, здесь вывод dmesg для сетевой карты Intel Fast Ethernet,
который использует устройство, именуемое fxp.


<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Если вы не знаете имени вашего устройства, пожалуйста посмотрите на
<a href="../../ru/plat.html">список поддерживаемой аппаратуры</a> для вашей платформы.
Вы найдете список множества распространенных имен карт и их OpenBSD имена устройств.
Объедините короткое символьное имя устройства (например fxp) с числом,	 назначенным 
ядром, и вы получите имя интерфейса (например fxp0). 
Номер присваивается на основе различных критериев, в зависимости от карты и других
деталей. Некоторым картам назначаются имена в зависимости от используемой ими шины.
Другим могут быть имена по каким-то hardware-критериям или в зависимости от MAC-адреса.

<p>
Обратите внимание, что для информации обо всех найденных в системе сетевых устройств
используется утилита
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Приведенный ниже пример показывает, что в системе найдено одно сетевое
устройство <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">
fxp(4)</a>.

<blockquote><pre>
$ <b>ifconfig</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33200
        priority: 0
        groups: lo
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x3
        inet 127.0.0.1 netmask 0xff000000
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        lladdr 00:04:ac:dd:39:6a
        priority: 0
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
enc0: flags=0&lt;&gt;
        priority: 0
        groups: enc
        status: active
pflog0: flags=141&lt;UP,RUNNING,PROMISC&gt; mtu 33200
        priority: 0
        groups: pflog
</pre></blockquote>

<p>
Как вы видете,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> дает нам больше информации чем нам сейчас нужно. В примере карта
уже настроена; мы видим имя её интерфейста  - fxp0. О её настройке свидетельствуют
также строка "inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255"
и установленные флаги <b>UP</b> и <b>RUNNING</b>.

<p>
Обратите внимание, что несколько других виртуальных интерфейсов включены по умолчанию.
Информацию о них вы можете найти в man-страницах:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4"
>lo</a> - Loopback Interface 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4"
>pflog</a> - Packet Filter Logging Interface 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Encapsulating Interface 
</ul>

В список других виртуальных интерфейсов, которые автоматически создаются, входят:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4"
>sl</a> - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4"
>ppp</a> - Point to Point Protocol
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4"
>tun</a> - Tunnel Network Interface 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge</a> - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4"
>vlan</a> - IEEE 802.1Q Encapsulation Interface 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=svlan&amp;sektion=4"
>svlan</a> - IEEE 802.1AD Provider Bridges (QinQ) 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4"
>gre</a> - GRE/MobileIP Encapsulation Interface 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4"
>gif</a> - Generic IPv4/IPv6 Tunnel Interface 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4"
>carp</a> - Common Address Redundancy Protocol Interface 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mpe&amp;sektion=4"
>mpe</a> - MPLS Provider Edge 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vether&amp;sektion=4"
>vether</a> - Virtual Ethernet Interface 
</ul>

<p>
Инициализация (создание) сетевых интерфейсов происходит во время загрузки при
помощи /etc/hostname.<i>if</i>-файлов, где <i>if</i> - где имя вашего интерфейса.
Например, как было показанно выше, имя должно быть <i>/etc/hostname.fxp0</i>.

<p>
Формат этого файла прост:

<blockquote><pre>
address_family address netmask broadcast [weitere Optionen]
</pre></blockquote>

Более детальную информацию о формате этого файла вы можете найти в man-страницах 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
hostname.if(5)</a>. Мы рекомендуем ознакомиться также и с более сложными примерами
конфигурационных файлов.

<p>
Типичный интерфейс такого файла, сконфигурированного для адресов IPv4, должен выглядеть
так:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
В данном случае мы задаем адрес IPv4 (inet), IP адрес 10.0.0.38, маска подсети
255.255.255.0, широковещательный адрес не указан (будет установлен для данного
случая по умолчанию в 10.0.0.255).

<p>
Вы должны также определить тип для Ethernet. Например, если бы вы захотели
установить полный дуплексный режим 100baseTX.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Разумеется, работа в полно-дуплексном режиме невозможна, если этот режим не
установлен на обеих сторонах соединения!)

<p>
Возможно вы захотите использовать флаги, специфические на определенных интерфейсах.
Формат файла hostname от этого сильно не изменится!

<blockquote><pre>
$ <b>cat /etc/hostname.vlan0</b>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>


<a name="Setup.gateway"></a>
<h3>6.2.2 - Шлюз по умолчанию</h3>
Поместите IP-адрес вашего шлюза в
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5">
/etc/mygate</a></i>. Это позволит устанавливать его при загрузке. Этот файл
содержит всего одну строку, указывающую адрес шлюза:

<blockquote><pre>
10.0.0.1
</pre></blockquote>

Возможно указать и символические имя, однако следует иметь ввиду: может
получится так, что ваша служба разрешения доменных имен, резолвер, будет
сконфигурирован или доступен только ПОСЛЕ установки шлюза по умолчанию.
Поэтому лучше указывать IP-адрес или что-нибудь, указанное в файле
<i>/etc/hosts</i>.

<p>
<a name="Setup.resolver"></a>
<h3>6.2.3 - Разрешение DNS</h3>
Служба разрешения доменных имен управляется конфигурационным файлом 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">
<i>/etc/resolv.conf</i></a>. Ниже пример файла:

<blockquote><pre>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

В этом примере доменное имя по умолчанию <tt>example.com</tt>;
имеются два сервера DNS с адресами <tt>125.2.3.4</tt> и <tt>125.2.3.5</tt>;
файл <i>/etc/hosts</i> будет использован до получения информации от
DNS-серверов.

<p>
Как и практически во всех UNIX системах (да и многих не UNIX), есть файл
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">
<i>/etc/hosts</i></a>, который может быть использован для указания системы,
которая не должна использоваться как DNS.

<p>
Если вы пользуетесь DHCP, почитайте пункт <a href="#DHCP">6.4 - DHCP</a>,
где рассказывается об использовании файла 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">
resolv.conf.tail(5)</a>.

<p>
<a name="Setup.myname"></a>
<h3>6.2.4 - Имя хоста (Hostname)</h3>
Каждая UNIX машина имеет имя. В OpenBSD имя задается как "Fully Qualified Domain Name"
(FQDN) одной строкой в файле
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=myname&amp;sektion=5">
<i>/etc/myname</i></a>. Если машина имеет имя "puffy" и находится в домене "example.com",
файл будет содержать следующее:


<blockquote><pre>
puffy.example.com
</pre></blockquote>

<a name="Setup.activate"></a>
<h3>6.2.5 - Применение настроек</h3>
Для того, чтобы применить новые настройки (или, как ещё говорят, чтобы они
"вошли в силу"), вы можете или перезагрузиться или запустить скрипт
<b>/etc/netstart</b>. Это можно сделать просто выполнив от root:

<blockquote><pre>
# <b>sh /etc/netstart</b>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Обратите внимание, появилось несколько ошибок. Выполняя этот сценарий
вы изменяете существующие настройки. Например, некоторые маршруты уже присутствуют
в таблице маршрутизации ядра. Начиная с этого момента система должна работать.
Кроме того, вы можете убедиться, что ваш интерфейс был установлен правильно с
помощью
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. 


<p>
Хотя в OpenBSD возможна полная переконфигурация сетевых настроек
системы без перезагрузки, рестарт системы НАСТОЯТЕЛЬНО рекомендуется после
значительного изменения конфигурации. Дело в том, что окружающая нашу
систему среда может оказаться при загрузке несколько иной, чем когда
система полностью запущена и работает. К примеру, вы указали DNS-сервер
символическим именем во всех файлах, и у вас все работает после
переконфигурации, однако после перезагрузки внешний DNS-сервер может
оказаться недоступным, т.е. перенастройка сети окажется неправильной.

<p>
<a name="Setup.chkroute"></a>
<h3>6.2.6 - Проверка маршрутизации</h3>

Настройку маршруты вы можете проверить при помощи 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> или
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">
route(8)</a>. Если у вас есть проблемы маршрутизации, вы можете использовать
флаг -n для команды route(8), который печатает IP-адреса, не делая
DNS-преобразование и имен хостов.
Вот пример просмотра ваших таблиц маршрутизации, используя обе программы:

<blockquote><pre>
$ <b>netstat -rn</b>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <b>route show</b>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.forward"></a>
<h3>6.2.7 - Настройка OpenBSD для работы в качестве шлюза</h3>

<p>
Это основная информация, которая вам понадобится для настройки вашей
OpenBSD системы в качестве шлюза (также называемым маршрутизатором).
Если вы используете OpenBSD в качестве маршрутизатора Internet, мы
советуем прочитать инструкцию по установке пакетного фильтра,
чтобы блокировать потенциально злонамеренный трафик. Также, из-за
низкой доступности адресов
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">
IPv4</a> у местных провайдеров, вам возможно бужет интересно взглянуть
на Network Address Translation (NAT) для получения информации о сохранении
вашего диапазона IP-адресов.

<p>
GENERIC ядро собрано с поддержкой IP Forwarding, вам только нужно включить её.
Вы можете сделать это, используя утилиту 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a>. Чтобы изменения стали постоянными, вы должны отредактировать файл
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">
/etc/sysctl.conf</a>; добавьте в этот файл строку.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Чтобы сохранить изменения, вы должны использовать утилит
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a> до перезагрузки. Запомните: эти изменения не будет действовать
после перезагрузки, и должны быть выполнениы от root.

<blockquote><pre>
# <b>sysctl net.inet.ip.forwarding=1</b>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
Теперь настраивайте маршруты на других хостах (с обеих сторон). Есть много
вариантов настройки OpenBSD в качестве маршрутизатора. Например вы можете
использовать <a href="http://www.openbgpd.org/">OpenBGPD</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ospfd&amp;sektion=8">ospfd(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ospf6d&amp;sektion=8">ospf6d(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldpd&amp;sektion=8">ldpd(8)</a> и
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ripd&amp;sektion=8">ripd(8)</a>.
OpenBSD поддерживает в своей коллекции портов такие инструменты как 
<a href="http://bird.network.cz/">bird</a>,
<a href="http://igmpproxy.sourceforge.net/">igmpproxy</a> и
<a href="http://www.quagga.net">quagga</a>.
OpenBSD поддерживает некоторые T1-, HSSI-, АТМ-, FDDI-, последовательные
(PPP/SLIP) интерфейсы, и конечно же многие Ethernet-устройства (включая 10 Gb).

<p>
<a name="Setup.aliases"></a>
<h3>6.2.8 - Настройка алиасов для сетевых интерфейсов</h3>

<p>
OpenBSD имеет простой механизм для установки IP псевдонимов (алиасов) для
сетевых интерфейсов. Чтобы сделать это, просто отредактируйте файл 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
<i>/etc/hostname.&lt;if&gt;</i></a>.
Этот файл будет считан в процессе загрузки скриптом
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8">
/etc/netstart(8)</a>, который является частью rc-системы загрузки.
Для примера мы предполагаем, что пользователь имеет интерфейс <b>dc0</b>
и находится в сети 192.168.0.0. Другая важная информация:

<ul>
<li>IP для dc0 - 192.168.0.2
<li>NETMASK - 255.255.255.0
</ul>

<p>
Немного замечаний относительно алиасов: в OpenBSD вы используете только
имя интерфейса. Нет различия между первым и вторым псевдонимами. В отличие
от некоторых других операционных систем, OpenBSD не ссылается на них как dc0:0,
dc0:1. Если вы ссылаетесь на специфический адрес IP псевдонима с помощью ifconfig
или добавляете псевдоним, не забываете набирать "<tt>ifconfig int alias</tt>"
вместо просто "<tt>ifconfig int</tt>" в командной строке.
Вы можете удалить псевдонимы с помощью "<tt>ifconfig int delete</tt>".

<p>
Допустим, вы используете многочисленные IP-адреса, которые в той же подсети
с псевдонимами, ваша установка netmask для каждого псевдонима становится
255.255.255.255. Им не нужно следовать за netmask первого связанного IP интерфейса.
В этом примере <i>/etc/hostname.dc0</i> - два псевдонима, которые добавлены к
устройству dc0, которое, было сконфигурировано как 192.168.0.2 с маской сети
255.255.255.0.


<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 NONE media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Как только вы настроили этот файл, можно просто перезагрузиться, чтобы изменения
вступили в силу. Вы можете, кстати, задать псевдонимы и вручную, используя утилиту
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Чтобы создать первый псевдоним, вы должны использовать команду:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

(опять-таки рекомендуется перезагрузить систему, чтобы убедиться в
корректности ваших настроек!)

<p>
Чтобы просмотреть псевдонимы:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="PF"></a>
<h2>6.3 - Как настроить фильтрацию и использовать OpenBSD в качестве фаервола?</h2>

Packet Filter или Пакетный Фильтр (далее именуемый PF) является OpenBSD системой
для фильтрации IP-трафика, а также работой с Сетевой Трансляции Адресов (NAT).
PF допускает нормализацию и ограничение IP-трафика, и обеспечение
контроля пропускной способности, и присваивание приоритетов пакетам, и может быть
использован для создания мощных и гибких фаерволов. Более подробное описание
по настройке вы можете найти в <a href="../pf/ru/index.html">
<b>Руководстве Пользователя PF</b></a>.

<p>
<a name= "DHCP"></a>
<h2>6.4 - Dynamic Host Configuration Protocol (DHCP)</h2>

Dynamic Host Configuration Protocol или Динамический Протокол Конфигурации Хостов
- способ "автоматической" конфигурации сетевых интерфейсов. OpenBSD может быть
сервером DHCP (конфигурируя другие машины), клиентом DHCP (сконфигурированный
другой машиной), а также может сочетать оба случая.

<p>
<a name="DHCPclient"></a>
<h3>6.4.1 - DHCP клиент</h3>

<p>
Для того, чтобы использовать клиент DHCP 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8"
>dhclient(8)</a>, включенного в OpenBSD, отредактируйте <tt>/etc/hostname.xl0</tt>
(в предположении, что ваш основной Ethernet-интерфейс является xl0. Ваш может
называться ep0 или fxp0 или любой другой). Все что вам нужно для настройки -
написать в этом файле <tt>dhcp</tt>.

<blockquote><pre>
# <b>echo dhcp &gt; /etc/hostname.xl0</b>
</pre></blockquote>

<p>
Это скажет OpenBSD автоматически запускать DHCP клиент при загрузке.
OpenBSD получит свои IP-адрес, имя шлюза, а также адреса DNS серверов
от DHCP сервера.

<p>
Если вы хотите запустить DHCP клиент из командной строки, убедитесь,
что существует файл <tt>/etc/dhclient.conf</tt>, а затем сделайте:

<blockquote><pre>
# <b>dhclient fxp0</b>
</pre></blockquote>

<p>
Где <tt>fxp0</tt> – интерфейс, для которого вы хотите получить
сетевые настройки.

<p>
Независимо от того как вы запускаете DHCP клиент, вы можете отредактировать
файл <tt>/etc/dhclient.conf</tt>, чтобы <b>НЕ</b> настраивать ваш DNS.
Сначала раскомментируйте строки 'request' (эти строки - пример установок по
умолчанию, но вам нужно раскомментировать их, чтобы перезаписать значения
dhclient по умолчанию).

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

<p>
и затем удалите <tt>domain-name-servers</tt>. Конечно, вы можете захотеть
удалить <tt>host-name</tt>, или другие установочные параметры тоже.

<p>
Изменяя опции в вашем файле 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5">
dhclient.conf(5)</a>, вы сообщаете DHCP клиенту как формировать ваш файл
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">
resolv.conf(5)</a>. DHCP клиент перезаписывает любую информацию в файле
resolv.conf(5) в соответствии с полученной информацией от DHCP сервера.
Следовательно, вы потеряете любые изменения, которые вы делали вручную в
resolv.conf.

<p>
Есть два доступных механизма избежать этого:

<ul>
<li>
<tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS">
OPTION MODIFIERS</a></tt> (<b>default</b> (по умолчанию), <b>supersede</b> 
(замена), <b>prepend</b> (добавление в начало) и <b>append</b> (и в конец)),
позволят вам перезаписать любую из опций dhclient.conf(5).

<li>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">
<tt>resolv.conf.tail(5)</tt></a> позволяет вам добавлять все, что вы хотите
в файл resolv.conf(5) созданный утилитой dhclient(8).
</ul>

<p>
Пример будет выглядеть так, если вы используете DHCP, но при этом хотите
добавить <tt>lookup file bind</tt> в resolv.conf(5). созданный утилитой
dhclient(8). Для этого нет опции в <tt>dhclient.conf</tt>, так что вы
должны использовать <tt>resolv.conf.tail</tt>, чтобы сохранять это.

<blockquote><pre>
# <b>echo "lookup file bind" &gt /etc/resolv.conf.tail</b>
</pre></blockquote>

Теперь ваш resolv.conf(5) должен содержать в конце "lookup file bind".

<blockquote><pre>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>

<p>
<a name="DHCPserver"></a>
<h3>6.4.2 - DHCP сервер</h3>

<p>
Если вы хотите использовать OpenBSD в качестве сервера DHCP
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">
dhcpd(8)</a>, отредактируйте <tt>/etc/rc.conf.local</tt>, чтобы он
содержал строку <tt>dhcpd_flags=""</tt>.
Например:
<pre>
     # <b>echo 'dhcpd_flags=""' &gt;&gt;/etc/rc.conf.local</b>
</pre>

Это запустит dhcpd, который подхватит все NIC (сетевые интерфейсы), которые
перечислены в <tt>/etc/dhcpd.conf</tt>. Вы можете также указать конкретные
интерфейсы, а не все, назвав их явно, например,
<tt>dhcpd_flags="xl1 xl2 xl3"</tt>.

<p>
Затем, отредактируйте <tt>/etc/dhcpd.conf</tt>.
Опции в достаточной степени очевидны.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Это сообщит вашим клиентам DHCP, что domain = example.com добавлялся к
запросам DNS (так, если пользователь набирает 'telnet joe', тогда запрос
пойдет на joe.example.com) Это укажет им на серверы DNS 192.168.1.3 и
192.168.1.5. Для хостов, которые находятся в той же сети, что и ethernet
интерфейс машины OpenBSD, который лежит в диапазоне 192.168.1.0/24,
он назначит им адрес IP между 192.168.1.32 и 192.168.1.127.
Он установит их шлюз по умолчанию в качестве 192.168.1.1.

<p>
Если вы хотите запустить dhcpd(8) из консоли,
после редактирования <tt>/etc/dhcpd.conf</tt> сделайте:

<pre>
    # <b>/etc/rc.d/dhcpd start</b>
    dhcpd(ok)
</pre>

Если при конфигурации были допущенны ошибки, демон не будет запущен.
Вы получите сообщение о невозможности запуска ("<tt>dhcpd(failed)</tt>").
О причине проблемы вы всегда можете узнать из <tt>/var/log/message</tt>.

<p>
Если вы предоставляете сервис DHCP для Windows, вам возможно понадобится,
чтобы dhcpd(8) давал клиенту адрес 'WINS' сервера. Для этого, просто
добавьте следующую строку к вашему <tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(где <tt>192.168.92.55</tt> - IP вашего Windows или Samba сервера.) Смотрите
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">
dhcp-options(5)</a> для подробностей об опциях, которые могут понадобиться
вашим клиентам DHCP.

<p>
<a name="PPP"></a>
<h2>6.5 - Point to Point Protocol (PPP)</h2>

<p>
Point to Point Protocol (PPP) или протокол "точка-точка" обычно используется
для создания соединения с вашим провайдером через модем. В OpenBSD существует
2 способа сделать это:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
- PPP-демон уровня ядра (the kernel PPP daemon).
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
- PPP-демон уровня пользователя (the userland PPP daemon).
</ul>

<p>
Как ppp так и pppd выполняют аналогичные функции различными путями.
pppd работает с драйвером ядра
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">
ppp(4)</a>, тогда как ppp работает в простанстве пользователя с 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">
tun(4)</a>. В этом документе рассказывается только о пользовательском PPP-демоне,
так как с ним легче работать и отлаживать. Для начала вам нужна некоторая
информация о вашем провайдере:

<ul>
<li>Ваш провайдерский dial-up номер
<li>Ваше имя DNS сервера
<li>Ваш логин и пароль
<li>Ваш шлюз (gateway)
</ul>

<p>
Без некоторой из них вы можете обойтись, но все же она будет полезна в
установке ppp. В качестве конфигурационного файла PPP-демона пользовательского
уровня используется файл
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">
/etc/ppp/ppp.conf</a>. Много полезных файлов вы найдете просматривая каталог
<i>/etc/ppp</i>, который содержит различные конфигурационные файлы.
Мы советуем вам изучить содержимое этого каталога.

<p>
<h3>Начальная настройка PPP(8)</h3>

<p>
Начальная установка PPP-демона сводится к редактированию вашего
<i>/etc/ppp/ppp.conf</i>. Этого файла по умолчанию в системе нет, но есть
файл <i>/etc/ppp/ppp.conf.sample</i>, от которого вы можете оттолкнуться,
чтобы создать ваш новый <i>ppp.conf</i>. Здесь я начну с самой простой и,
вероятно, наиболее используемой установки. Вот простенький файл
<i>ppp.conf</i>, который устанавливает некоторые значения по умолчанию:

<blockquote><pre>
default:
  set log Phase Chat LCP IPCP CCP tun command     
  set device /dev/cua01                           
  set speed 115200     
  set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>

<p>
Секция после метки <tt>default:</tt> выполняться всякий раз.
Здесь мы установили все наши главные настройки. С помощью "set log"
мы задали наш уровень логирования. Он может быть изменен, ознакомьтесь с
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">
ppp(8)</a> для более подробной информации по установке уровней логирования.
Наше устройство устанавливается строкой "set device". Это устройство, на
котором включен модем. В этом примере модем находится на 2-ом com-порту.
Следовательно 1-ый com-порт должен быть на <i>/dev/cua00</i>.
С помощью "set speed" мы установили скорость нашего диалап-соединения,
а с помощью "set dial" мы установили наши диалап-параметры. С их помощью
мы можем изменить наше время тайм-аута, и т.п..
Эта строка должна оставаться почти такой же не смотря ни на что.

<p>
Теперь мы можем идти далее и устанавить информацию специфическую для нашего провайдера.
Мы сделаем это с помощью дополнения другими метками под нашей <tt>default:</tt> секции.
Эта метка может быть названа как угодно - можете просто использовать имя вашего
провайдера. Здесь я использую <tt>myisp:</tt> в качестве нашей метки. Вот простые
настройки, включающие все, что нам нужно для получения нашего соединения:

<blockquote><pre>
myisp:
  set phone 1234567   
  set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
  set timeout 120   
  set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
  add default HISADDR 
  enable dns
</pre></blockquote>

<p>
Здесь мы установили основную информацию специфичную для нашего провайдера.
Первая опция "set phone" устанавливает ваш dial-up номер провайдера.
"set login" устанавливает наши опции входа. Здесь мы установили тайм-аут на 5;
это означает, что мы прервем нашу попытку входа после 5 секунд, если сигнал не
будет обнаружен. В противном случае ждем отправленного "login:" и посылаем ваш
логин и пароль.

<p>
В этом примере наше имя Username = ppp и Password = ppp.
Эти значения должны быть изменены. Строка "set timeout" устанавливает тайм-аут
бездействия для соединения в 120 секунд. Строка "set ifaddr" немного мудрена.
Вот более исчерпывающее объяснение.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
В вышеуказанной строке, мы имеем следующий формат
"<b>set ifaddr [meineAdr[/nn] [seineAdr[/nn] [netzmaske [startAdr]]]]</b>".
Так первый заданный IP это тот, который мы хотим в качестве нашего IP.
Если у вас есть статический IP-адрес, установите его здесь. В нашем примере
мы используем /0, который сообщает, что никакие биты этого IP-адреса не
нуждаются в совпадении, и целая часть может быть заменена.
Второй IP определен таким образом, каким мы его представляем как IP на
другой стороне. Если вы знаете его вы можете установить его. Кроме того,
в нашей строке мы не знаем, что будет назначено, так что мы позволяем им
сообщить его нам. Третья опция - наша маска сети (netmask). Она здесь указана как
255.255.255.0. Тем не менее, только адрес в дипазоне myaddr будет принят.
Это полезно, когда происходит согласование с некоторыми реализациями PPP,
которые не назначат IP, если их peer запрашивают "0.0.0.0".

<p>
Следующая опция "add default HISADDR" используется для установки нашего
маршрута по умолчанию для их IP. Это 'создает проблемы', в смысле, что если
их IP должен изменяться, наш маршрут автоматически будет скорректирован.
С помощью "enable dns" мы сообщаем нашему провайдеру аутентификации наших
nameserver-адресов. НЕ делайте это, если вы запускаете локальный DNS, поскольку
ppp просто обойдет его использование, вводя некоторые nameserver строки в
<i>/etc/resolv.conf</i>.

<p>
Вместо традиционных методов входа (login), многие провайдеры теперь используют
аутентификацию CHAP или PAP. Если это ваш случай, наша конфигурация будет
выглядеть немного иначе:

<blockquote><pre>
myisp:
  set phone 1234567   
  set authname ppp
  set authkey ppp
  set login
  set timeout 120   
  set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
  add default HISADDR 
  enable dns
</pre></blockquote>

<p>
В вышеуказанном примере, мы определяем наше имя пользователя (ppp) и пароль (ppp),
используя authname и authkey, соответственно. Нет необходимости определять какая
из двух аутентификации (CHAP или PAP) использована - это согласовывается автоматически.
"set login" просто определяется для попытки залогиниться, с именем пользователя и
паролем, определенным прежде.

<p>
<h3>Использование PPP(8)</h3>

<p>
Теперь, когда мы настроили наш <i>ppp.conf</i> файл, мы можем
начать попытки соединия с нашим провайдером. Я опишу подробно
некоторые обычно используемые аргументы с ppp:

<ul>
<li><tt>ppp -auto myisp</tt> - запуск ppp, который сконфигурирует ваши
интерфейсы и подключится к вашему провайдеру, затем перейдет в фоновый
режим.
<li><tt>ppp -ddial myisp</tt> - работает аналогично -auto, но, если ваше
соединение обрывается, пытается снова переподключиться.
</ul>

<p>
Если запуск вышеуказанных команд ни к чему не приводит, попробуйте выполнить
<i>/usr/sbin/ppp</i> без опций. Это запустит ppp в интерактивном режиме.
Опции могут передаваться поодиночке, чтобы проанализировать причину возникновения
проблемы, читая сообщения об ошибках. Используя установку определенную выше, ppp
будет вести лог в /var/log/ppp.log. Этот файл, также как и man-страницы,
целиком содержит полезную информацию.

<p>
<h3>Дополнительные возможности ppp(8)</h3>

<p>
В некоторых ситуациях вам может понадобиться запускать ppp непосредственно для
соединения или отключения. Для этих ситуаций вы можете создать два файла:
<i>/etc/ppp/ppp.linkup</i> и <i>/etc/ppp/ppp.linkdown</i>.
Конфигурацию можно посмотреть здесь:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample"
>ppp.linkup</a>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample"
>ppp.linkdown</a>
</ul>

<p>
<h3>Разновидности ppp(8)</h3>

<p>
Много провайдеров теперь предлагают xDSL сервисы, которые быстрее, чем
традиционные dial-up методы. Это включает такие варианты как например,
ADSL и SDSL. Хотя никакого физического набора номера не происходит,
соединение все еще основано на POP-протоколе. Примеры:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
PPPoE - Point to Point Protocol over Ethernet или "протокол точка-точка
поверх Ethernet" представляет из себя метод для посылки PPP-пакетов в фреймах
Ethernet. Point to Point Protocol over ATM (PPPoA) - обычно работает в сетях АТМ,
как например те, которые используются в Великобритании и Бельгии.

<p>
Обычно это означает, что вы можете установить соединение с вашим провайдером,
используя для этого только стандартную Ethernet-карту и основанный на Ethernet
DSL модем (в противоположность к USB модему).

<p>
Если у вас есть модем, который поддерживает работу по протоколу PPPoE/PPPoA,
то возможно сконфигурировать модем таким образом, чтобы он создавал такие
соединения. Кроме того, если модем имеет режим "bridge", то, после его
включения, получаем модем, пропускающий (pass through) пакеты PPPoE.

<p>
Основной программный интерфейс на PPPoE/PPPoA в OpenBSD - это 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8">
pppoe(8)</a>, который является реализацией пользовательского уровня
(почти такой же как и описанный нами
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">
ppp(8)</a> выше). Реализация PPPoE в ядре,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">
pppoe(4)</a>, является частью OpenBSD.

<p>
<h3>PPTP</h3>

<p>
PPTP - Point to Point Tunneling Protocol или "Туннельный протокол точка-точка"
является собственным протоколом компании Майкрософт. Клиент pptp доступен на
интерфейсах с 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8"
>pppd(8)</a> и способен соединяться с основанной на PPTP VPN, используемыми
некоторыми кабельными и xDSL провайдерами. pptp сам должен быть установлен
из <a href="faq15.html#PkgMgmt">пакетов</a> или <a href="faq15.html#Ports">
портов</a>. Дальнейшие инструкции по установке и использованию pptp
доступны в man-страницах, которые устанавливаются вместе с пакетом pptp. 

<p>
<a name="Tuning"></a>
<h2>6.6 - Тюнинг параметров сети</h2>

Одной из целей проекта OpenBSD является создание системы, которая <i>работает
без проблем</i>, устраивающая большинство пользователей. Крутить настройки без
их понимания - самый короткий путь к поломке системы. Всегда начинайте со
стандартных настроек, меняйте их только в том случае, если точно знаете что
делаете, а также <i>если действительно</i> возникают какие-либо проблемы.

<p>
<i>ОЧЕНЬ МАЛОМУ количеству пользователей это действительно необходимо!</i>

<p>
<h3>6.6.1 - Я не хочу, чтобы ядро динамически распределяло определенные порты</h3>

<p>
Из man-руководства для 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8#EXAMPLES">
sysctl(8)</a>:

<blockquote><pre>
Установка списка резервных портов TCP, которые не должны быть распределены ядром
динамически:

      # <b>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</b>

Это может быть использовано для удержания демонов от захвата специфических
портов, которые нужны для функционирования других программ. Элементы cписка могут быть
разделены запятыми и/или интервалом.

Также возможно добавить или удалить порты из текущего списка:

      # <b>sysctl net.inet.tcp.baddynamic=+748</b>
      # <b>sysctl net.inet.tcp.baddynamic=-871</b>
</pre></blockquote>

<p>
<a name="NFS"></a>
<h2>6.7 - Использование NFS</h2>

<p>Network File System (NFS или Сетевая Файловая Система) используется
для совместного использования файловой системы по сети. Перед установкой
NFS-сервера прочитайте следующие man-страницы:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8"
>nfsd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8"
>mountd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>
</ul>

<p>
В этом разделе приводятся шаги по простой установке NFS.
В этом примере описывается NFS-сервер в LAN с клиентами из LAN.
Здесь не обсуждаются вопросы безопасности NFS. Мы считаем, что вы уже установили
фильтрацию пакетов или другую защиту с помощью фаервола для предотвращения
доступа извне. Если вы разрешаете внешний доступ к серверу NFS, вам нужно быть
особенно осторожным к сохранности данных; мы рекомендуем использовать IPSec.
Иначе ваш трафик NFS будет потенциально доступен для посторонних.
Существуют атаки с подменой IP-адреса на адрес, разрешенный сервером NFS.
При правильной настройке IPSec защитит вас от этих видов атак.

<h3>Настройка NFS-сервера</h3>

<p>
Данные сервисы должны быть включены и запущены для работы сервера:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8"
>portmap(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8"
>mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8"
>nfsd(8)</a>
</ul>

<p>
По умолчанию они выключены в OpenBSD. Добавьте следующее в 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"
>rc.conf.local(8)</a> для включения:

<blockquote><pre>
portmap_flags=""
mountd_flags=""
nfsd_flags="-tun 4"
</pre></blockquote>

<p>
Следующим шагом мы настроим список файловых систем, чтобы сделать
доступным для клиентов монтирование.

<p>
В этом примере наш сервер имеет адреc 10.0.0.1 . Этот NFS-сервер обслуживает
только клиентов из своей сети. Первый шаг в установке NFS - настройка файла
/etc/exports. Этот файл содержит список файловых систем, доступных через NFS,
а также определяет, кто имеет к ним доступ. В /etc/exports можно использовать
различные опции, читайте о них в man-странице
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">
exports(5)</a>. Пример файла /etc/exports для рассматриваемого нами сервера:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network=10.0.0 -mask=255.255.255.0
</pre></blockquote>

<p>
Это означает, что локальная файловая система <tt>/work</tt> будет доступна
через NFS. Опция <tt>-alldirs</tt> означает, что клиенты могут монтировать
любую точку внутри <tt>/work</tt> как <tt>/work</tt>. Допустим, существует
каталог <tt>/work/monday</tt>, клиенты могут монтировать <tt>/work</tt>
(и иметь доступ внутри него ко всем файлам и каталогам) или же могут
смонтировать <tt>/work/monday</tt>, получив доступ к файлам и каталогам
только внутри него. Опция <tt>-ro</tt> устанавливает доступ только на чтение.
Последние два аргумента означают, что только клиенты из сети 10.0.0.0 с маской
255.255.255.0 могут монтировать эту файловую систему. Это важно для серверов,
которые доступны из различных сетей.

<p>
Еще одно замечание относительно безопасности. Не добавляйте файловую систему
в /etc/exports без списка разрешенных хостов. Иначе любой, кто может видеть
вашу машину по сети, сможет смонтировать экспортируемые NFS.

<p>
Теперь мы можем запустить сервер. Это можно сделать, включив сервис, используя
инструкцию ниже и перезагрузку или запустив сервис вручную.

<blockquote><pre>
# <b>/etc/rc.d/portmap start</b>
# <b>/etc/rc.d/mountd start</b>
# <b>/etc/rc.d/nfsd start</b>
</pre></blockquote>

<p>
Параметр <tt>nfsd_flags</tt> включает TCP (-t) или UDP (-u) соединения, а также
включает 4 подключения (-n) к запущенному nfsd. В файле rc.conf.local, используя
параметр <tt>nfsd_flags</tt>, вы должны установить требуемое значение количества
подключений к NFS-серверу, чтобы обеспечить возможностью обработки максимально
требуемого количества запросов клиентов.

<p>
Теперь вы готовы к монтированию экспортируемой файловой системы клиентами.

<p>
Запомните: если вы внесли изменения в /etc/exports в то время как NFS уже
работает, вы должны сообщить об этом mountd! Просто пошлите ему сигнал HUP:

<blockquote><pre>
# <b>/etc/rc.d/mountd reload</b>
</pre></blockquote>

<h3>Монтирование NFS файловой системы</h3>

<p>
NFS может быть смонтирована клиентом без запуска дополнительных сервисов
или демонов. Все это монтируется как любая другая файловая система.

<p>
NFS монтируется с помощью mount(8), или, точнее, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8"
>mount_nfs(8)</a>. Для монтирования каталога <tt>/work</tt> хоста 10.0.0.1
(помните, не обязательно использовать IP адрес; mount может использовать
доменное имя хоста) в <tt>/mnt</tt> на локальной машине используйте:

<blockquote><pre>
# <b>mount -t nfs 10.0.0.1:/work /mnt</b>
</pre></blockquote>

<p>
Для монтирования при загрузке добавьте в /etc/fstab примерно следующее:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
Не забывайте использовать <tt>0 0</tt> в конце данной строки файловой системы
NFS, чтобы ваш компьютер не пытался запустить на ней fsck. При необходимости
следует воспользоваться и другими безопасными опциями: 
<tt>noexec</tt>, <tt>nodev</tt> и <tt>nosuid</tt>. К примеру:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
В этом случае устройства и программы setuid с сервера NFS не смогут нарушить
меры безопасности на клиенте NFS. Если вы не планируете запускать программы
на клиенте NFS, добавьте noexec в этот список.

<p>
При обращении к монтируемому каталогу от пользователя root, сервер
автоматически отображает root доступ к имени пользователя "nobody" и группе
"nobody". Это важно знать при рассмотрении прав доступа к файлам.
Например, возьмем файл с таким набором прав:

<blockquote><pre>
-rw-------    1 root     wheel           0 Dec 31 03:00 _daily.B20143
</pre></blockquote>

<p>
Если этот файл находится в NFS, и пользователь root пытается получить доступ
к этому файлу через тот или иной NFS-клиент, доступ будет запрещен.
Это произойдет потому, что сервер использует учетные данные пользователя,
"nobody", когда root пытается получить доступ к файлу. Поскольку пользователь
nobody не имеет разрешения на доступ к файлу, в доступе будет отказано.

<p>
Пользователи и группы, которые должны иметь root-доступ,
настраиваются с помощью файла
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a> (на стороне сервера).

<h3>Получение статистики NFS</h3>

<p>
Для проверки, что сервис NFS работает должным образом, можно поверить RPC,
которая регистрирует все запущенные демоны. Для этого используется rpcinfo(8).

<blockquote><pre>
$ <b>rpcinfo -p 10.0.0.1</b>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Есть также несколько утилит для просмотра происходящего с NFS. Одна из них 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">
showmount(8)</a>, которая показывает, какие файловые системы смонтированы и кем.
Есть также
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsstat&amp;sektion=1">
nfsstat(1)</a>, которая покажет более подробную статистику. Для использования
showmount(8), запустите <tt>/usr/bin/showmount -a host</tt>. Например:


<blockquote><pre>
$ <b>/usr/bin/showmount -a 10.0.0.1</b>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
Как мы видим, машина с IP 10.0.0.37 примонтировала с сервера 10.0.0.1
каталог <tt>/work</tt>. 

<p>
<a name="Bridge"></a>
<h2>6.9 - Настройка сетевого моста в OpenBSD</h2>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">
Bridge</a> или Мост - это соединение между двумя или более раздельными сетями.
В отличие от рутера, пакеты предаются между сетями "невидимо/прозрачно" -
логически, две различных сети объединены в один сегмент с обоих сторон
сетевого моста. Мост обеспечит транспорт перенаправлением пакетов из одной
сети в другую, при этом обеспечив уменьшение трафика за счет перенаправления
только тех пакетов, которые необходимы, при этом упростив схему сети.

<p>
Заметим, что в силу своей "невидимости/прозрачности", интерфейсы моста могут
не иметь собственных IP-адресов. В этом случае интерфейсы могут быть эффективны
в двух режимах работы, как часть моста и как обычный, автономый сетевой адаптер.
Если никакой интерфейс не имеет IP, мост сможет передавать необходимые данные,
но не будет удобен в удаленном управлении (что может использоваться как feature).

<p>
<h3>Пример применения моста</h3>

<p>
Мои старые компьютеры не имеют встроенного сетевого адаптора 10BASE-TX.
В то же время имеются AUI- или AAUI-соединения, у меня нет возможности подключить
их по коаксиалу. Одна из машин - OpenBSD терминал-сервер - имеет постоянное
соединение с высокоскоростной сетью. Добавление дополнительной сетевой карты
с возможностью подключения коаксиалом позволяет сделать мою машину мостом в
коаксиальную сеть.

<p>
Теперь моя система имеет две NIC: Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">
<tt>fxp0</tt></a>) и 3c590-Combo card
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">
<tt>ep0</tt></a>) с коаксиальным портом. <tt>fxp0</tt> обеспечивает связь
с моей сетью и поэтому будет иметь IP-адрес, <tt>ep0</tt> используется
только как мост и не будет иметь IP-адрес. Машины, подключенные к
коаксиальному сегменту будут работать как часть моей сети.
Как мы это сделаем?

<p>
Файл <tt>hostname.fxp0</tt> содержит конфигурационную информацию для
карты <tt>fxp0</tt>. Эта машина использует DHCP, таким образом файл содержит:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE
</pre></blockquote>

<p>
Здесь ничего необычного.

<p>
Карта <tt>ep0</tt> немного отличается:

<blockquote><pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre></blockquote>

<p>
Здесь мы указываем системе поднять интерфейс, используя для этого
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>, и устанавливаем в 10BASE-2 (coax). IP-адрес или какие-либо
дополнительные настройки для интерфейса не указываем. Опции карты <tt>ep</tt>
детально описываются в
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">
man-странице для ep</a>.

<p>
Теперь мы должны создать мост. Мост инициализируется при помощи файла
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
<tt>hostname.bridge0</tt></a>. Здесь приводится пример для нашего случая:

<blockquote><pre>
$ <b>cat /etc/hostname.bridge0</b>
add fxp0
add ep0
up
</pre></blockquote>

<p>
Это означает, что надо создать мост между двумя сетевыми картами, fxp0 и ep0,
и активировать его. Не имеет значение в каком порядке перечислены карты.
Помните, что мост симметричен, т.е. пакеты перенаправляются в обоих
направлениях.

<p>
Ну вот и все! Перегружаемся и наслаждаемся работой моста.

<p>
<h3>Фильтрация на мосте</h3>

Конечно и такой простой мост тоже может найти применение, но, вероятно, вам
захочется ОБРАБОТАТЬ пакеты, поскольку они проходят через ваш мост.
Как вы уже наверное догодались, для фильтрации трафика на мосту может
испльзоваться <a href="#PF">пакетный фильтр PF</a>.

<p>
Имейте ввиду, в силу специфики моста, трафик проходит через оба интерфейса,
таким образом надо настраивать фильтрацию только на одном интерфейсе. Ваши
правила вида "разрешено все" соответствуют нижеприведенному:

<blockquote><pre>
pass in  on ep0  any
pass out on ep0  any
pass in  on fxp0 any
pass out on fxp0 any
</pre></blockquote>

<p>
Теперь, к примеру, мы желаем фильтровать трафик этих старых машин,
пропуская только Web- и SSH-трафик. В этом случае мы собираемся пропускать
весь входящий и исходящий трафик на интерфейсе <tt>ep0</tt>, но фильтруя
его на <tt>fxp0</tt>, с использованием <tt>keep state</tt> для ответного
трафика:

<blockquote><pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre></blockquote>

<p>
Обратите внимание, что этот набор правил предотвращает что-либо, но
поступающий HTTP- и SSH-трафик от любой машины моста или любой из
других узлов находится "за" ним. Другие результаты могут быть получены
путем фильтрации другого интерфейса.

<p>
Для того, чтобы проверять и управлять мостом, который вы создали,
используйте команду 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>, которая может также быть использована, чтобы создавать
мост после загрузки.

<p>
<h3>Рекомендации по настройке моста</h3>

<ul>
<li>НАСТОЯТЕЛЬНО рекомендуется настраивать фильтрацию только на одном интерфейсе.
Хотя возможно фильтровать на обоих интерфейсах, вам действительно нужно понимать
это очень хорошо, чтобы делать все правильно.

<li>Используя опцию <i>blocknonip</i> из
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> или
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
hostname.bridge0</a>, вы можете предотвращать "не IP-трафик" (например, IPX или
NETBEUI) от проскальзывания через ваши фильтры. Это может быть важным в некоторых
ситуациях, но вы должны понять, что мосты работают для всех типов трафика, не
только для IP.

<li>Использование мостов требует, чтобы NIC были в "Promiscuous mode"
(беспорядочный режим) - они слушают ВЕСЬ сетевой трафик, а не только тот, что
направлялся на интерфейс. Это дает более высокую нагрузку на процессор и шину,
чем могло бы ожидаться. Некоторые NIC не работают правильно в этом режиме,
например чип TI ThunderLAN
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">
tl(4)</a>) не может работать как часть моста. 
</ul>

<a name="PXE"></a>
<h2>6.10 - PXE загрузка (i386, amd64)</h2>

PXE (Preboot Execution Environment) или "Дозагрузочная Среда Выполнения"
представляет из себя метод загрузки компьютера по сети, а не с жесткого
диска, флоппи или CD-ROM. Технология первоначально была разработана Intel,
но поддерживается теперь большинством основных сетевых карт и изготовителями
компьютерного железа. Обратите внимание, что есть несколько других сетевых
протоколов загрузки, PXE сравнительно последний. По традиции, для PXE-загрузки
используется память сетевых карт, но доступны загрузочные флоппи-диски
из различных источников, которые также разрешают PXE загрузку. Многие ПЗУ
в более старых сетевых адаптерах поддерживают сетевую загрузку, НО НЕ
поддерживают PXE; OpenBSD/i386 или amd64 не может быть к настоящему времени
загружена через сеть при использовании этих карт.

<p>
<h3>Как работает загрузка через PXE?</h3>

Сначала разберемся как <a href="faq14.html#Boot386">OpenBSD загружается</a>
на i386 и amd64 платформах. При запуске процесса загрузки, "PXE-способный
сетевой адаптер" транслирует DHCP запрос через сеть. DHCP-сервер отправляет
карте (или адаптеру) IP-адрес, а также передает имя файла, который нужно
извлечь из
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1">
tftp(1)</a>-сервера и запустить. В этом файле находятся инструкции для
дальнейшей загрузки. Для OpenBSD, файл
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386">
pxeboot</a>, который заменяет стандартный загрузочный 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">
boot(8)</a> файл. pxeboot(8) затем способен загрузить ядро (например, <tt>bsd</tt> или 
<a href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a>) из того же tftp(1)-сервера.

<h3>Как мне это настроить?</h3>

Вам понадобится компьютер c сетевым адаптером, поддерживающим PXE-загрузку.
В принципе, все современные сетевые карты и компьютеры поддерживают PXE-загрузку,
но не забывайте, что многие дешевые системы все же не поддерживают PXE
ПЗУ или используют более старый сетевой протокол загрузки. Вам также
нужно правильно сконфигурированные <a href="#DHCP">DHCP</a>- и TFTP-серверы.

<p>
Предположим, машина OpenBSD является сервером, т.е. источником загрузочных файлов
(это НЕ обязательно), ваш 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5">
dhcpd.conf</a> файл DHCP-сервера должен иметь следующую строку:

<pre>
    filename "pxeboot";
</pre>
чтобы DHCP-сервер попробовал использовать этот файл для загрузки рабочей станции.
Например:

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
Вы также должны запустить 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8">
tftpd(8)</a>-демон. Это обычно делается через
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">
inetd(8)</a>. По умолчанию в OpenBSD в файле <tt>inetd.conf</tt> есть строка,
которая подходит для вас:
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

в которой просто нужно удалить символ комментария '#' и послать inetd(8)
HUP-сигнал, чтобы перезагрузить <tt>/etc/inetd.conf</tt>. tftpd(8) обслуживает
файлы из конкретного каталога, в случае использования этой строки, имя каталога
- <tt>/tftpboot</tt>, который мы используем для этого примера. Понятное дело,
что этот каталог должен быть создан и там должно быть несколько файлов для
PXE-загрузки:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, загрузчик PXE (подходят те же функции как и при 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>загрузке</a> в базовой дисковой системе).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, установочное ядро <tt>bsd</tt> или ядро,
сконфигурированное пользователем.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
>/etc/boot.conf</a>, файл конфигурации загрузки.
</ul>

Обратите внимание, что <tt>/etc/boot.conf</tt> нужен только в случае, если ядро,
которое вы хотите загрузить, называется не <tt>bsd</tt>, или другие установки
pxeboot по умолчанию не такие, какие вам нужны (например, вы хотите использовать
последовательную [serial] консоль). Вы можете протестировать ваш tftpd(8) сервер,
используя
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a>-клиент, убедитесь, что можете скачивать необходимые файлы.

<p>
Когда ваши DHCP- и TFTP-сервера работают, вы можете проверить как это работает.
Вы должны активизировать PXE-загрузку на вашей сетевой карте; обратитесь для этого к
документации. Как только вы включите этот режим, вы должны увидеть что-то подобное:

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 3.16
    boot>
</pre>

C этого момента, у вас есть стандартное приглашение загрузчика OpenBSD.
Если вы набираете "<tt>bsd.rd</tt>", то просто скачивается файл
<tt>bsd.rd</tt> с TFTP-сервера.

<pre>
    >> OpenBSD/i386 PXEBOOT 3.16
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2012 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

    OpenBSD 5.1 (RAMDISK_CD) #95: Sun Feb 12 10:02:21 MST 2012
      ...
</pre>

Теперь загружается <a href="faq4.html#bsd.rd">ядро bsd.rd</a>.

<p>

<h3>Могу ли я помимо <tt>bsd.rd</tt> загружать другой тип ядрер
с помощью PXE?</h3>

Да, хотя загружаться будут таже инструменты OpenBSD, предназначенные 
для установки других ОС.

<p>
<a name="CARP"></a>
<h2>6.11 - Common Address Redundancy Protocol (CARP)</h2>
<h3>6.11.1 - Что такое CARP и как это работает?</h3>
<!-- This article written by Sunny Raspet, slr@mordac.info, and
released under the BSD license -->

<p>
CARP (Common Address Redundancy Protocol) или "Протокол Избыточности
Общего Адреса" представляет из себя инструмент для достижения резервирования
системы, путем объединения компьютеров в единый виртуальный сетевой сегмент.
Это позвиляет распределять нагрузку между машинами, а также, в случае проблем
с той или иной системой, заменить ее другой из того же сегмента.
CARP является усовершенствованным протоколом VRRP (Virtual Router
Redundancy Protocol). Решение о его разработке было принято из-за того,
что VRRP не достаточно свободен, в связи с патентом Cisco. Для получения
дополнительной информации о происхождении CARP и юридических вопросах,
связанных с VRRP, пожалуйста, посетите <a href="../../lyrics.html#35">эту
страницу</a>.

<p>
Для того чтобы избежать юридических конфликтов, Ryan McBride (с помощью
Michael Shalayeff, Marco Pfatschbacher и Markus Friedl) разработал CARP,
чтобы он коренным образом был другим. Включение криптографии - одно из
множеств изменений, но, пожалуй, наиболее значимое.

<p>
Как это работает: CARP является широковещательным протоколом. Он группирует
несколько физических компьютеров вместе под одним или более виртуальными
адресами. Одна из систем - мастер - отвечает на все пакеты предназначенные
для группы, другие системы действуют как горячее резервирование. Независимо
от IP- и MAC-адреса локального физического интерфейса, пакеты, посылаемые
на CARP-адрес, возвращаются с CARP информацией.

<p>
В конфигурируемых интервалах, мастер оповещает о своей работе по
IP-протоколу с номером 112. Если мастер становится offline, другие системы
в CARP группе начинают оповещение. Хост, способный оповещать наиболее
часто, становится новым мастером. Когда бывший мастер возвращается, она
становится обычной частью сегмента, хотя, если это более желательно для
одного хоста, чтобы он был мастером там, где это возможно (например, один
хост является быстрым Sun Fire V120, а другие - сравнительно медленные
SPARCstation IPCs), вы можете так сконфигурировать их.

<p>
Пока высоко избыточные и отказоустойчивые аппаратные средства минимизируют
потребность в CARP, они не снимают вопрос о потребности в CARP. Отсутствует
аппаратура отказоустойчивости, которая способна помогать, если кто-нибудь
выдергивает шнур питания, или если ваш системный администратор наберет
<tt>reboot</tt> не в том окошке. CARP упрощает процесс наложения заплаток
и перезагрузки, делая этот процесс прозрачным для пользователей, а также 
упрощает процесс тестирования программного обеспечения или аппаратную
модернизацию. Если какое-то железо вышло из строя, вы можете использовать
резервы пока не почините или замените его.

<p>
Есть, тем не менее, ситуации в которых CARP не поможет. CARP спроектирован
таким образом, что требует, чтобы участники группы находились в той же
физической подсети со статическим адресом IP, хотя с введением директивы
carpdev, нет более потребности в IP-адресах на физических интерфейсах.
Аналогично, сервисы, требующие постоянное соединение с сервером (например,
SSH или IRC), не будут точно переброшены в другую систему – все же в этом
случае, CARP может попробовать снизить время простоя. CARP самостоятельно
не синхронизирует данные между приложениями, это должно быть сделано через
"альтернативные каналы", как например, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4">
pfsync(4)</a> (для избыточной фильтрации), вручную дублируя данные между
блоками при помощи <a href="http://rsync.samba.org/">rsync</a>, или все,
что соответствует вашему приложению.

<h3>6.11.2 - Конфигурация</h3>

<p>Элементы управления CARP это
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a> и
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Давайте посмотрим сначала на sysctls.

<p>Первый параметр sysctl, <tt>net.inet.carp.allow</tt>, определяет
может ли хост управлять CARP-пакетами полностью. Естественно, что это
необходимо для использования CARP. Этот прараметр sysctl включен по умолчанию.

<p>Второй, <tt>net.inet.carp.log</tt>, ведет лог изменения состояния CARP,
проблем с пакетами, если такие имеются, и других ошибок. Установите этот
параметр, если хотите иметь подробный журнал сообщений.

<p>Третий, <tt>net.inet.carp.preempt</tt> включает естественный отбор из
числа CARP хостов. Наиболее годный для работы (то есть, способный оповещать
наиболее часто), станет мастером. Выключено по умолчанию, с той целью, чтобы
система, которая не является мастером, не будет пытаться восстановить
(установить) статус мастера.

<p>
Все эти переменные sysctl подробно описаны в man-странице 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">
sysctl(3)</a>.

<p>
В завершении конфигурации CARP мы обращаемся к 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Специфические CARP команды <tt>advbase</tt> и <tt>advskew</tt>
имеют дело с интервалом между CARP оповещениями. Формула (в секундах) - это
<tt>advskew</tt> поделеная на 256, затем добавленая к <tt>advbase</tt>.
<tt>advbase</tt> может быть использована, чтобы уменьшить сетевой трафик или
позволить более длинное время ожидания прежде, чем резервный хост примет эстафету;
<tt>advskew</tt> позволяет вам управлять тем какой хост станет мастером без
большой задержки в случае сбоев (если это потребуется).

<p>
Затем, <tt>pass</tt> устанавливает пароль, а <tt>vhid</tt> - виртуальный
идентификационный номер хоста CARP группы. Вам нужно назначить уникальное
число для каждой CARP группы, даже если бы (для целей балансировки нагрузки),
они разделяют (share) тот же IP адрес. CARP ограничен 255 группами.

<p>
Наконец, <tt>carpdev</tt> определяет какой физический интерфейс принадлежит
к конкретной группе CARP. По умолчанию, какой-либо интерфейс, имеющий IP-адрес
в той же подсети, назначенной CARP интерфейсу, будет использован.

<p>
Давайте поместим все эти настройки вместе в основной конфигурации.
Скажем, вы развертываете два идентично сконфигурированных Web-сервера,
<i>rachael</i> (192.168.0.5) и <i>pris</i> (192.168.0.6), чтобы заменить
более старую систему, которая была по адресу 192.168.0.7. Команды:

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>
создадут carp0-интерфейс и дадут ему vhid равным 1, пароль <i>tyrell</i>,
и IP адрес 192.168.0.7 с маской 255.255.255.0. fxp0 будет назначачен в
качестве элемента интерфейса. Чтобы сделать это постоянным после
перезагрузки, вы можете создать <tt>/etc/hostname.carp0</tt> файл,
который выглядит примерно вот так:

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell carpdev fxp0
</pre></blockquote>

Обратите внимание, что широковещательный адрес определен в этой строке, в
дополнительнении к vhid и паролю. Отсутствие этого является причиной ошибок,
так что это нужно заполнить.

<p>
Сделайте тот же для <i>pris</i>. Какая угодно система, поднимающая
интерфейс CARP впервые, будет мастером (в предположении, что параметр
выключен; в противном случае это тоже истина, когда preempt включен).

<p>

Но скажем, вы не развертываете с нуля. <i>rachael</i> был уже на месте
по адресу 192.168.0.7. Как вам работать с этим? К счастью, CARP может
иметься дело с этой ситуацией. Вы просто назначаете адрес на CARP интерфейс
и оставляете физический интерфейс определенный ключевым словом "carpdev"
без IP адреса. Тем не менее, он стремится быть чистым, чтобы иметь IP
для каждой системы - он делает индивидуальный мониторинг и доступ
значительно проще.

<p>
Давайте добавим другой уровень сложности; мы хотим, чтобы <i>rachael</i>
оставался мастером, когда это возможно. Есть несколько причин, почему
нам это может понадобиться: аппаратные различия, простое предубеждение,
"если эта система не является мастером, значит у нас проблема" или, зная
по умолчанию мастера, не прибегать к помощи сценариев (scripting), чтобы
выполнять анализ и отсылать по электронной почте выходные данные ifconfig.

<p>На <i>rachael</i>, мы будем использовать sysctl, который мы создали
выше, затем отредактируйте <tt>/etc/sysctl.conf</tt>, чтобы сохранить
изменения.


<blockquote><pre>
rachael# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Делаем конфигурацию для <i>pris</i>:

<blockquote><pre>
pris# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

<p>
Это немного задерживает оповещения от <i>pris</i>, чтобы
<i>rachael</i> был мастером, когда жив.

<p>
Обратите внимание, что если вы используете PF на CARP компьютере,
вы должны разрешить пропускать (pass) "proto carp" на всех связанных
интерфейсах, строкой аналогичной этой:

<blockquote><pre>
pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Балансировка нагрузки</h3>

<p>
Пролетело несколько месяцев. Наша компания из предшествующего примера
выросла, где единственный внутренний Web-сервер едва справляется с
нагрузкой. Что делать? CARP спешит на помощь. Пора пробовать балансировку
загрузки. Создайте новый CARP интерфейс и группу на <i>rachael</i>:

<blockquote><pre>
rachael# <b>ifconfig carp1 create</b>
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>На <i>pris</i> мы создадим новую группу и интерфейс, затем
установим sysctl параметр "preempt":

<blockquote><pre>
pris# <b>ifconfig carp1 carp1</b>
pris# <b>ifconfig carp1 vhid 2 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
pris# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Теперь у нас есть две CARP группы с тем же IP адресом.
Каждая группа ассиметрична по отношению к другому хосту, с той целью,
чтобы <i>rachael</i> остался мастером оригинальной группы, а
<i>pris</i> получит власть в новой.

<p>
Пока эти примеры для кластера из двух машин, однако те же принципы
относятся к многим другим системам. Пожалуйста, обратите внимание, что
не стоит ожидать, что вы достигнете идеального 50/50 распределения
между двумя машинами. CARP использует хэш исходящих IP-адресов, чтобы
определять какая система обработает запрос, скорее, чем по нагрузке.

<h3>6.11.4 - Дополнительная информация о CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">Firewall
Failover with pfsync and CARP</a> автор Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - Использование OpenNTPD</h2>

Точное время важно для многих программ. Однако многие наверное замечали,
что, порой, их пятидолларовые часы показывают время точнее, чем их компьютер
за $2000. В дополнение к тому, чтобы просто знать точное время, также бывает
важным синхронизировать его на нескольких компьютерах. Некоторое время на
<a href="http://www.ntp.org">ntp.org</a> применяли программу Network Time
Protocol 
(<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>), доступную
через порты, которую можно использовать для синхронизации времени на
компьютерах через Интернет. Однако её сложно настраивать, сложен и код,
что отражается на его проверке, а также высокие требования к используемой
памяти. Программа играет важную роль для некоторых людей, но далека от
повсеместного использования.

<p>
<a href="http://www.openntpd.org/de">OpenNTPD</a> является попыткой решить
некоторые из этих проблем, сделать программу синхронизации времени на вашем
компьютере простой для администрирования, безопасной и совместимой с NTP. 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8">
ntpd(8)</a> использует легкий в понимании файл конфигурации 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5">
<tt>/etc/ntpd.conf</tt></a>.

<p>
Просто запустив ntpd(8) с помощью <a href="faq10.html#rc">rc.conf.local</a>,
вы включите синхронизацию времени на вашем компьютере с серверами
<a href="http://www.pool.ntp.org/">pool.ntp.org</a> (несколько time-серверов).
Как только ваши часы будут синхронизированны, ntpd будет следить за их
точностью, тем не менее, если ваши часы отстают или спешат на несколько минут,
то вы <i>можете</i> перенастроить их. Это можно сделать вручную с помощью
опции <tt>-s</tt> ntpd(8), либо изменить настройки времени вручную на
аппаратном уровне.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - «Но OpenNTPD не так точен как демон от ntp.org!»</h3>

Да, это возможно. Это не было главной
<a href="http://www.openntpd.org/ru/goals.html">целью проекта OpenNTPD</a>,
он был написан, чтобы быть свободным, простым, надежным и безопасным.
Если точность в микросекундах для вас действительно важнее, не стесняйтесь
использовать демон ntpd от ntp.org, поскольку он останется доступным через
порты и пакеты. Нет планов или желания иметь раздутый OpenNTPD, который
бы был идеален во всем.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - «Кто-то говорит, что OpenNTPD "вреден"!»</h3>

Похоже, что кто-то просто не понял целей проекта OpenNTPD: простота,
безопасность и легкость в настройке. Если важно поддержание точности
времени, некоторые пользователи сообщали о лучших результатах OpenNTPD
по сравнению с ntpd от ntp.org. Если важна безопасность, то код OpenNTPD
более удобочитаемый (и, таким образом, проще проводить его аудит) и был
написан, используя стандартные вызовы OpenBSD, типа
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3">
strlcpy</a>, а не с помощью портируемых функций вроде 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3">
strcpy</a>. OpenNTPD написан, чтобы быть безопасным с самого начала,
а не чтобы быть "сделанным безопасным позже". Если все больше людей
синхронизируют время на компьютере при помощи OpenNTPD, то это здорово,
потому что он делает этот процесс простым. Если это для кого-то "вредно",
ну что ж... возможно так оно и есть.

<p>
Бывают случаи, при которых целесообразнее использовать демон ntpd от ntp.org.
Тем менее, считается, что для подовляющего большинства пользователей OpenNTPD
является более чем достаточным.

<p>
Более полный ответ на этот вопрос был дан одним из разработчиков OpenNTPD.
Вы можете прочитать его
<a href="http://www.advogato.org/person/dtucker/diary.html?start=52">
тут</a>.

<a name="OpenNTPDNoServe"></a>
<h3>6.12.3 - Почему другие мои машины не могут синхронизироваться?</h3>

По умолчанию ntpd(8) демон не прослушает какие-либо адреса. Так для того,
чтобы использовать его как сервер, вы должны раскоментировать строку
"<tt>#listen&nbsp;on&nbsp;*</tt>" в <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"
>/etc/ntpd.conf</a> и перезапустить демон ntpd(8). Конечно, если вы хотите
прослушивать на конкретном IP-адресе, а не на всех доступных адресах и
интерфейсах, замените "*" желаемым адресом.

<p>
Может случиться, что после того как ntpd(8) запущен, другие системы все
равно не могут синхронизироваться с ним. Недавно запущенный ntpd(8) демон
(например, если вы только что перезапустили его после модификации ntpd.conf)
отказывается снабжать информацией клиентов, пока они сначала не отрегулируют
свои собственные часы на разумный уровень точности. В то время как ntpd(8)
рассматривает свою информацию о времени точной, он сообщает "clock now synced"
в <tt>/var/log/daemon</tt>. Даже если системные часы безупречно точны,
процессу синхронизации может порой потребоваться до 10 минут.

<p>
<a name="Wireless"></a>
<h2>6.13 - Использование беспроводных сетей</h2>
К поддерживаемым OpenBSD чипсетам (набором микросхем) беспроводных
устройств можно отнести:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx&amp;sektion=4">acx(4)</a>
TI ACX100/ACX111. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">an(4)</a>
Aironet Communications 4500/4800.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4">ath(4)</a>
driver for Atheros 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=athn&amp;sektion=4">athn(4)</a>
driver for Atheros 80211/a/g/n devices.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4">atu(4)</a>
Atmel AT76C50x USB 802.11b
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">atw(4)</a>
ADMtek ADM8211.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">awi(4)</a>
AMD 802.11 PCnet Mobile.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bwi&amp;sektion=4">bwi(4)</a>
Broadcom AirForce 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cnw&amp;sektion=4">cnwi(4)</a>
Xircom CreditCard Netwave
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4">ipw(4)</a>
Intel PRO/Wireless 2100 802.11b. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4">iwi(4)</a>
Intel PRO/Wireless 2200BG/2225BG/2915ABG 802.11a/b/g. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwn&amp;sektion=4">iwn(4)</a>
Intel WiFi Link 4965/5100/5300 802.11a/b/g/Draft-N wireless.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=malo&amp;sektion=4">malo(4)</a>
Marvell Libertas 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt&amp;sektion=4">pgt(4)</a>
Conexant/Intersil Prism GT Full-MAC 802.11a/b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4">ral(4)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4">ural(4)</a> [USB]
Ralink Technology RT25x0 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ray&amp;sektion=4">ray(4)</a>
Raytheon Raylink/WebGear Aviator 802.11FH
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4">rtw(4)</a>
Realtek 8180 802.11b. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum&amp;sektion=4">rum(4)</a>
Ralink Technology RT2501USB. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=run&amp;sektion=4">run(4)</a>
Ralink Technology USB 802.11a/b/g/Draft-N
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath&amp;sektion=4">uath(4)</a>
Atheros USB 802.11a/b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=upgt&amp;sektion=4">upgt(4)</a>
Conexant/Intersil PrismGT SoftMAC USB 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=urtw&amp;sektion=4">urtw(4)</a>
Realtek RTL8187L USB 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">wi(4)</a>
Prism2/2.5/3. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi&amp;sektion=4">wpi(4)</a>
Intel PRO/Wireless 3945ABG. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=zyd&amp;sektion=4">zyd(4)</a>
ZyDAS ZD1211/ZD1211B USB 802.11b/g
</ul>

<sup>(AP)</sup> означает, что карта может быть использована как точка доступа.<br>
<sup>(NFF)</sup> означает, что чип требует закрытого ПО (firmware) для своей
работы, которое не может быть включено в OpenBSD.

<p>
Устройства, основанные на этих чипах могут быть использованы наравне с
другими сетевыми устройствами для подключения машины с OpenBSD к уже
существующей беспроводной сети (см. соответствующие руководства man
для получения исчерпывающей информации по этому поводу) используя стандартный
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>. Некоторые из устройств, работая в режиме "точки доступа",
могут быть использованы непосредственно для создания полноценной
беспроводной ТД, интегрированной в фаервол.

<p>
Стоит отметить, что при использовании беспроводных сетевых карт
Intel необходимо установить соответствующее аппаратно-программное
обеспечение (firmware), которое <a href="faq1.html#ReallyFree">
не является свободно распространяемым</a> и, таким образом, не
может быть включено в состав OpenBSD. Вы можете связаться с Intel
и высказать им всё, что вы думаете по этому поводу или сообщить
какое устройство вы приобрели взамен.

<p>
Еще один способ включения OpenBSD в беспроводную сеть состоит в
совместном использовании обычной сетевой карты и внешней точки доступа.
Очевидное преимущество: подобная схема позволяет удобно расположить
антенну в месте, где сигнал будет наиболее качественным, что зачастую
отнюдь не является местом непосредственно рядом с машиной. 

<p>
<a name="Multipath"></a>
<h2>6.14 - Как мне настроить equal-cost multipath routing?</h2>

<p>
"Equal-cost multipath routing" означает, что имеется несколько
маршрутов в таблице маршрутизации к данной сети, например маршрут
по умолчанию default route, 0.0.0.0/0. Когда ядро определяет, каким
путем отправить пакет для данной сети, оно может выбрать любой из
equal-cost маршрутов. В большинстве случаев такая маршрутизация
используется для создания резервированного соединения с сетью
логически более "корневого" уровня, например, подключения к сети
Интернет.

<p>
Команда 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8"
>route(8)</a> используется для добавления/удаления/изменения маршрутов
в таблице маршрутизации routing table. Аргумент <tt>-mpath</tt>
используется при добавлении  multipath routes.

<blockquote><pre>
# <b>route add -mpath default 10.130.128.1</b>
# <b>route add -mpath default 10.132.0.1</b>
</pre></blockquote>

<p>
Проверим маршрутизацию:

<blockquote><pre>
# <b>netstat -rnf inet | grep default</b>
default     10.130.128.1      UGS       2      134      -     fxp1
default     10.132.0.1        UGS       0      172      -     fxp2
</pre></blockquote>

<p>
В этом примере мы видим, что маршрут по умолчанию достижим используя
10.130.128.1 через интерфейс fxp1, а другой вариант - 10.132.0.1 и fxp2.

<p>
Используя файл 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5"
>mygate(5)</a> мы не сможем настроить по умолчанию multipath default routes,
нам потребуется еще отредактировать файлы
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a> для интерфейсов fxp1 и fxp2. Файл <tt>/etc/mygate</tt>
нам надо будет удалить.

<dl>
<dt><b>/etc/hostname.fxp1</b></dt>
<dd><tt>!route add -mpath default 10.130.128.1</tt></dd>
<dt><b>/etc/hostname.fxp2</b></dt>
<dd><tt>!route add -mpath default 10.132.0.1</tt></dd>
</dl>

<p>
Не забудьте для использования multipath routes включить нужные опции
sysctl(3).

<blockquote><pre>
# <b>sysctl net.inet.ip.multipath=1</b>
# <b>sysctl net.inet6.ip6.multipath=1</b>
</pre></blockquote>

<p>
Не забудьте отредактировать
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5"
>sysctl.conf(5)</a>, чтобы сохранить изменения.

<p>
А теперь попробуем выполнить трассировку разными маршрутами.
Ядро будет распределять трафик в режиме балансировки (load balance)
multipath route.

<blockquote><pre>
# <b>traceroute -n 154.11.0.4</b>
traceroute to 154.11.0.4 (154.11.0.4), 64 hops max, 60 byte packets
 1  10.130.128.1  19.337 ms  18.194 ms  18.849 ms
 2  154.11.95.170  17.642 ms  18.176 ms  17.731 ms
 3  154.11.5.33  110.486 ms  19.478 ms  100.949 ms
 4  154.11.0.4  32.772 ms  33.534 ms  32.835 ms

# <b>traceroute -n 154.11.0.5</b>
traceroute to 154.11.0.5 (154.11.0.5), 64 hops max, 60 byte packets
 1  10.132.0.1  14.175 ms  14.503 ms  14.58 ms
 2  154.11.95.38  13.664 ms  13.962 ms  13.445 ms
 3  208.38.16.151  13.964 ms  13.347 ms  13.788 ms
 4  154.11.0.5  30.177 ms  30.95 ms  30.593 ms
</pre></blockquote>

<p>
Для дополнительной информации о способе выбора маршрута читайте
<a href="http://www.ietf.org/rfc/rfc2992.txt">RFC2992</a>,
"Analysis of an Equal-Cost Multi-Path Algorithm".

<p>
Стоит заметить, если интерфейс, используемый при multipath route
потеряет соединение (например, нет carrier), ядро тем не менее все
равно будет пытаться отправить через него пакеты. Конечно, этот
трафик никуда не попадет. Очень рекомендуется использовать
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated&amp;sektion=8"
>ifstated(8)</a> для проверки доступности интерфейса и коррекции
таблицы маршрутизации. 

<p>
<font color="#0000e0">
<a href="index.html">[FAQ-Index]</a>
<a href="faq5.html">[Глава 5 - Сборка системы из исходников]</a>
<a href="faq7.html">[Глава 7 - Клавиатура и дисплей]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.304 ]<br>
$Translation: faq6.html,v 1.2 2013/01/17 22:58:40 alex Exp $<br>
-->
$OpenBSD: faq6.html,v 1.2 2013/01/18 07:15:55 ajacoutot Exp $
</small>

</body>
</html>
