
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>7 - Клавиатура и дисплей</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2013 by OpenBSD.">
</head>

<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->


<body bgcolor= "#ffffff" text= "#000000">

<a href="../../ru/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq6.html">[Глава 6 - Сеть]</a>
<a href= "faq8.html">[Глава 8 - Общие вопросы]</a>
</font>

<h1><font color="#e00000">7 - Клавиатура и дисплей</font></h1>
<hr>
<p>
<h3>Содержание</h3>
<ul>
<li><a href="#Keyboard"     >7.1 - Как я могу перенастроить клавиатуру? (wscons)</a>
<li><a href="#ConsoleMouse" >7.2 - Есть ли поддержка мыши в консоли OpenBSD?</a>
<li><a href="#Scrollback"   >7.3 - Доступ к буферу прокрутки консоли (amd64, i386, некоторые Alpha)</a>
<li><a href="#SwitchConsole">7.4 - Как мне переключать консоли? (amd64, i386, Zaurus, некоторые Alpha)
<li><a href="#80x50"        >7.5 - Как изменить разрешение в консоли на 80х50? (amd64, i386, некоторые Alpha)</a>
<li><a href="#SerCon"       >7.6 - Как использовать последовательный порт для доступа к консоли?</a>
<li><a href="#Blanker"      >7.7 - Как мне очистить/отключить экран в консольном режиме? (wscons)</a>
<li><a href="#ALLCAPS"      >7.8 - ВСЕ, ЧТО Я ВВОЖУ, ОТОБРАЖАЕТСЯ В ВЕРХНЕМ РЕГИСТРЕ!</a>
<li><a href="#tmux"         >7.9 - Что такое tmux(1)?</a>
</ul>
<hr>

<br>
<p>
<a name= "Keyboard"></a>
<h2>7.1 - Как я могу перенастроить клавиатуру? <i>(wscons)</i></h2>

<p>
На большинстве платформ OpenBSD использует консольный драйвер
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">
wscons(4)</a>.

<p>
В консолях wscons(4), большинство опций может быть изменено с помощью 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>.
К примеру, что бы изменить маппинг раскладки клавиатуры используя 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>,
вы должны сделать:

<blockquote><pre>
# <strong>wsconsctl keyboard.encoding=ru</strong>
</pre></blockquote>

<p>
В следующем примере мы переназначим функцию клавиши [CAPS LOCK] на [STRG L]
(Control-L):

<blockquote><pre>
# <strong>wsconsctl -w keyboard.map+="keysym Caps_Lock = Control_L"</strong>
</pre></blockquote>

<a name= "ConsoleMouse"></a>
<h2>7.2 - Есть ли поддержка мыши в консоли OpenBSD?</h2>

<p>
Для архитектур <a href="../../ru/alpha.html">alpha</a>,
<a href="../../ru/amd64.html">amd64</a> и
<a href="../../ru/i386.html">i386</a> OpenBSD предоставляет
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsmoused&amp;sektion=8&amp;arch=i386">
wsmoused(8)</a>, который является портом moused(8) из FreeBSD.
Вы можете включить его, изменив соответствующим образом ваш 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">
rc.conf.local(8)</a>.

<p>
<a name= "Scrollback"></a>
<h2>7.3 - Доступ к буферу прокрутки консоли <i>(amd64, i386, некоторые Alpha)</i></h2>

<p>
На некоторых платформах OpenBSD предоставляет буфер прокрутки экрана консоли.
Он позволяет вам увидеть информацию, которая уже скрылась за пределами вашего
экрана. Для перемещания вверх и вниз используйте комбинации клавиш <tt>[SHIFT]
+[PGUP]</tt> и <tt>[SHIFT]+[PGDN]</tt> соответственно.
<p>
По умолчанию, размер буфера прокрутки - 8 экранов. Это стандартная конфигурация
драйвера 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>,
и она будет работать только на VGA-совместимой карте (многие Alpha-системы имеют
TGA).

<p>
Wegen der Speicherbegrenzung unterstützen die Installationskernel
keine Scrollbackfunktion. Ein <a
href="#SwitchConsole">Konsolenwechsel</a> wird den Scrollbackpuffer
löschen.

<p>
<a name= "SwitchConsole"></a>
<h2>7.4 - Как мне переключать консоли? <i>(amd64, i386, Zaurus, некоторые Alpha)</i></h2>

На платформах amd64, i386 и Alpha, при использовании 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>
-карты, OpenBSD предоставляет шесть виртуальных консолей по умолчанию, с
/dev/ttyC0 по /dev/ttyC5. ttyC4 по умолчанию зарезервирована для использования
X Window System. Вы можете переключаться между ними, используя
<tt>[CTRL]+[ALT]+[F1]</tt>, <tt>[CTRL]+[ALT]+[F2]</tt>,
<tt>[CTRL]+[ALT]+[F3]</tt>, <tt>[CTRL]+[ALT]+[F4]</tt> и
<tt>[CTRL]+[ALT]+[F6]</tt>.

<p>
X использует ttyC4, <tt>[STRG]+[ALT]+[F5]</tt>.
Нажав <tt>[STRG]+[ALT]+[F</tt><i>n</i><tt>]</tt>, вы попадете в соответствующую
консоль, нажав <tt>[STRG]+[ALT]+[F5]</tt>, вы попадете в X.

<p>
Если вам понадобится больше чем шесть консолей, используйте 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">
wsconscfg(8)</a>, чтобы создать ttyC6, ttyC7 или более. Пример:

<blockquote>
<pre>
wsconscfg -t 80x25 6
</pre>
</blockquote>

это позволит создать ttyC6, доступный при нажатии на <tt>[STRG]+[ALT]+[F7]</tt>.
Не забудьте добавить эту команду в 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>
rc.local(8)</tt></a>, если вы хотите, что бы эти консоли добавлялись каждый раз
при загрузке системы.

<p>
Заметьте, что вы не получите приглашение <tt>login:</tt> на только-что созданной
виртуальной консоли, пока не установите значение "on" в 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5">
<tt>/etc/ttys(5)</tt></a>, затем перезагрузитесь или пошлите процессу 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">
init(8)</a> сигнал HUP, используя 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">
kill(1)</a>.

<p>
На машинах Zaurus существуют два терминала по-умолчанию (/dev/ttyC0 и /dev/ttyC1),
доступных по нажатию <tt>[ALT]+[CALENDAR]</tt> и <tt>[ALT]+[ADDRESS]</tt>
(Клавиша <tt>[ALT]</tt> находиться справа от левой клавиши <tt>[CTRL]</tt>]).

<a name="80x50"></a>
<h2>7.5 - Как изменить разрешение в консоли на 80х50? 
<i>(amd64, i386, paar Alphas)</i></h2>

Пользователи архитектур amd64, i386 и VGA-Alpha получают вывод на консоль
25 строк по 80 символов. Однако, некоторые VGA видеокарты позволяют выводить
текст с большим текстовым разрешением 50 строк по 80 символов/знаков.

<p>
Первоначально должен быть загружен шрифт для поддержки данного режима с
помощью команды 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsfontload&amp;sektion=8">
wsfontload(8)</a>. Стандартный вывод текста 80x25 использует шрифт размером
8x16 пикселей; для увеличения числа строк в двое мы используем шрифт размером
8x8 пикселей.

<p>
После этого, мы должны удалить и заново создать
<a href="http://www.openbsd.org/faq/faq7.html#SwitchConsole">виртуальные консоли</a>
в нужном нам решении экрана, используя команду 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">
wsconscfg(8)</a>.

<p>
Это может быть сделано автоматически во время загрузки, с помощью добавления 
следующих строк в конец вашего файла 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8">
<tt>rc.local(8)</tt></a>:

<blockquote>
<pre>
wsfontload -h 8 -e ibm /usr/share/misc/pcvtfonts/vt220l.808
wsconscfg -dF 5
wsconscfg -t 80x50 5
</pre>
</blockquote>

Как и при любом другом изменении системной конфигурации, мы рекомендуем вам
провести некоторое время за чтением страниц соответствующих руководств для того,
чтобы вы поняли что делают эти команды.

<p>
Первая строчка загружает шрифты 8x8. Вторая строка удаляет 5 экран
(который будет доступен по комбинации клавиш <tt>[STRG]-[ALT]-[F6]</tt>).
Третья строка заново создает 5 экран с разрешением в 50 строк и 80 символами
на каждой строке. Если вы сделаете это, то увидите, что основной и остальные
три экрана остаются в прежнем стандартном режиме 80x25, но на новую пятую
виртуальную консоль в режиме 80x50 можно будет перейти при нажатии
<tt>[STRG]-[ALT]-[F6]</tt>.

<p>
Запомните, что <tt>[STRG]-[ALT]-[F1]</tt> – это экран 0 (ttyC0).
Если вы желаете изменить другие экраны, просто повторите шаги удаления
и добавления виртуальных консолей для всех экранов, которые вы хотите
перевести в разрешение 80x50.

<p>
Вы должны избегать изменение разрешения экрана 4 (ttyC4,
<tt>[STRG]-[ALT]-[F5]</tt>), который используется X в качестве графического.
Также не рекомендуется изменять разрешение основной консоли (т. е. ttyC0).

<p>
Естественно, все эти команды могут быть введены от имени root, или, что
рекомендуется, используя 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">
sudo(8)</a>.

<p>
<b>Примечание: это не будет работать на всех видеокартах.</b>
К сожалению, не все видеокарты поддерживают загружаемые шрифты, которые
необходимы 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">
wscons(4)</a> для применения разрешения 80x50 в текстовом режиме.
В этих случаях мы рекомендуем использовать X.


<a name="SerCon"></a>
<h2>7.6 - Как использовать последовательный порт для доступа к консоли?</a></h2>

Существует много причин, почему вам может потребоваться использовать
последовательный порт:
<ul>
<li>Запись вывода консоли (для документации).
<li>Удаленное управление.
<li>Удобную поддержку большого числа машин.
<li>Вывод dmesg с машин, который не получить другим путем.
<li>Вывод "trace" и "ps" для разработчиков, в случае краха системы.
</ul>
OpenBSD поддерживает работу консоли через последовательный порт на
большенстве платформ, однако существуют различия в ее работе на разных
платфомах.

<p>
Отметим, что работа с последовательным портом НЕ простая задача - у вас
часто будет возникать необходимость в безполезных проводах, порты не будут
стандартизированы на различных машинах, в некоторых случаях они не будут
совместимы даже на одной. Предположим, что вы знаете как выбрать подходящий
кабель для связи вашего компьютера и устройства, выступающего в роли
последовательного терминала, поэтому не станем заострять на этом внимание.
Полное описание последовательного интерфеса выходит за пределы этой статьи,
скажем лишь, что если разьемы проводов соединены, это еще не значит, что
все будет работать.

<a name="SerContty"></a>
<h3>Изменения в <i>/etc/ttys</i></h3>
Есть две вещи, которые необходимо сделать для того, чтобы заработал
последовательный порт в OpenBSD. Во-первых, у вас должна уже быть машина с
OpenBSD, использующая последовательный порт в качестве консольного для
"status" и однопользовательского режима. Реализация этой части сильно зависит
от платформы. Во-вторых, вы должны разрешить использование последовательного
порта в качестве терминального, чтобы пользователь мог зайти в систему в
многопользовательском режиме. Эта часть в некоторой степени одинаково
выполнима на различных платформах, и описана здесь подробно.

<p>
Терминальные сессии управляются файлом 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5">
<i>/etc/ttys</i></a>. Для того, чтобы OpenBSD вывело приглашение
<tt>login:</tt> на устройство, его (устройство) необходимо разрешить в
<i>/etc/ttys</i>, в конце концов есть другие способы применения
последовательного порта, нежели в качестве терминала. На платформах,
с подключаемыми клавиатурой и монитором, в качестве консоли, последовательный
терминал отключен по-умолчанию. Приведем пример для платформы i386.
В этом случае замение строку:

<pre>
     tty00   "/usr/libexec/getty std.9600"   unknown off
</pre>
на:
<pre>
     tty00   "/usr/libexec/getty std.9600"   vt220   on secure
</pre>

Здесть <tt>tty00</tt> - последовательный порт, используемый в качестве
консольного. <tt>vt220</tt> наден
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=termcap&amp;sektion=5">
termcap(5)</a> для ВАШЕГО терминала (могут быть другие - <tt>vt100</tt>,
<tt>xterm</tt> и т.д.). <tt>on</tt> сообщает 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8">
<i>getty</i></a> вывести приглашение <tt>login:</tt>, а <tt>secure</tt>
разрешает залогиниться пользователю root (uid=0) на этой консоли
(что может соответствовать или не соответствовать вашим желаниям),
и наконец <tt>9600</tt> - это максимальная скорость передачи данных.
Попытка поднять скорость обмена до максимальной величины, поддерживаемой
вашим оборудованием, скорее создаст проблемы, нежели сделает работу более
комфортной. Большинство систем имеют "default" скорость (т.е. ту, которая
поддерживаются по умолчанию boot ROM и/или загрузчиком, часто это 9600),
используйте её, если у вас нет действительно серьезных причин для выбора
другого значения.

<p>
Отметим, что при установке вы можете использовать последовательный порт
без этих шагов, т.к. в это время система работает в однопользовательском
режиме и не использует <i>getty</i> для входа.

<p>
На некоторых платформах и при некоторых конфигурациях, вы должны запустить
систему в однопользовательском режиме для установки этой конфигурации.

<h3>amd64 и i386</h3>
Для того, чтобы сразу, во время загрузки, использовать последовательный порт
в качестве консоли, создайте или отредактируйте файл <i>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386">
/etc/boot.conf</a></i>.
Добавьте туда строку:
<pre>
     set tty com0
</pre>

для использования первого последовательного порта в качестве вашей консоли.
Скорость передачи данных по умолчанию равна 9600bps. Её можно изменить,
отредактировав в <i>/etc/boot.conf</i> строку, использующую опцию stty.
Этот файл помещен на ваш загрузочный носитель, которым может быть и
инсталляционная дискета (флоппи), либо команда может быть введена в
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">
командной строке загрузчика OpenBSD</a> для одноразового (или в первый раз)
использования последовательной консоли.

<p>
<h4>Советы для архитектур amd64 и i386</h4>
<ul>
<li>OpenBSD нумерует последовательные порты начиная с <i>tty00</i>,
DOS/Windows с <i>COM1</i>, поэтому, помните, что <i>tty02</i> это
<i>COM3</i>, а не <i>COM2</i>.

<li>Некоторые системы позволяют работать без видеокарты на машине,
но не все - многие системы рассматривают это как ошибку.
Некоторые машины также отказываются работать без подключенной клавиатуры.

<li>Некоторые системы способны перенаправлять все действия BIOS клавиатуры
на последовательный порт через опцию в конфигурации. Поэтому машина вполне
может работать через последовательный порт. Однако результаты могут измениться
- когда вы используете эту функцию, некоторые BIOS'ы могут мешать загрузчику
видеть последовательный порт, и, таким образом, ядру не будут указывать на
его использование. Некоторые BIOS'ы имеют опцию "Continue Console Redirection
after POST" (Power On Self Test), она должна быть выключена, чтобы загрузчик
и ядро могли использовать их собственную консоль. К сожалению, эта фича не
универсальна.

<li>PC-совместимые компьютеры не проектировались для загрузки при помощи
последовательной консоли, в отличие от некоторых других платформ. Даже те
системы, которые поддерживают такой способ загрузки, обычно имеют это
как опцию в конфигурации BIOS - и, если информация о конфигурации повреждена,
вы получите систему, ищущую стандартный монитор и клавиатуру снова и снова.
Вы должны иметь какой-нибудь способ для получения монитора и клавиатуры на 
amd64 и i386 в критической ситуации.

<li>Вам необходимо редактировать <i>/etc/ttys</i> как это
<a href="#SerContty">рассматривалось выше</a>.

</ul>


<h3>SPARC и UltraSPARC</h3>
Эти машины поддерживают возможность полного управления при помощи
последовательной консоли. Просто отключите клавиатуру, и они будут
искать устройства через последовательный порт.

<h4>Советы для архитектур SPARC и UltraSPARC</h4>
<ul>
<li>Последовательные порты на SPARC называются <i>ttya</i>,
    <i>ttyb</i>, и т. д.

<li>В отличие от некоторых других платформ, вовсе необязательно
    модифицировать файл <i>/etc/ttys</i>, чтобы последовательная
    консоль заработала.

<li>Системы SPARC/UltraSPARC понимают сигнал BREAK как команду
    STOP -A, что останавливает все приложения и операционную систему.
    Это удобно, когда это действительно нужно, но, к сожалению,
    некоторые serial terminal’ы при определенных обстоятельствах
    посылают сигналы, которые компьютер понимает как сигнал прерывания
    операции и останавливает машину. Пожалуйста, протестируйте, прежде
    чем использовать.

<li>Если клавиатура и монитор подключены, вы можете заставить
    использовать вместо них serial console с помощью следующих команд:
 <pre>
     ok <b>setenv input-device ttya</b>
     ok <b>setenv output-device ttya</b>
     ok <b>reset</b>
 </pre>
Если клавиатура и монитор (ttyC0) прописаны в <i>/etc/ttys</i>
(<a href="#SerContty">см. выше</a>), вы можете использовать их в X.
</ul>

<h3>MacPPC</h3>

Для работы с serial console машины MacPPC используют
OpenFirmware. Его работа сводится к следующим командам:

 <pre>
     ok <b>setenv output-device scca</b>
     ok <b>setenv input-device scca</b>
     ok <b>reset-all</b>
 </pre>
Установите скорость передачи данных 57600bps, 8N1.

<h4>Заметки по MacPPC:</h4>
<ul>
<li>К сожалению, использование serial console на всех MacPPC невозможно.
Хотя большинство этих машин действительно имеют последовательные
устройства, они недоступны для использования извне. К счастью, некоторые
компании предложили подключаемые устройства для нескольких моделей
Macintosh, которые позволяют использовать этот порт для serial console
или для других целей. Поищите в вашем любимом поисковике информацию об
этом, используя ключевую фразу »Macintosh internal serial port«.

<li>Вам придется включить устройство <tt>tty00</tt> в <i>/etc/ttys</i>
и установить скорость в 57600, вместо стандартных 9600, в
однопользовательстком режиме, прежде чем произойдет вход в 
многопользователький режим, как это <a href="#SerContty">описывалось
выше</a>. В этом случае serial console будет работать нормально. 
</ul>

<a name="Blanker"></a>
<h2>7.7 - Как мне очистить/отключить экран в консольном режиме? (wscons)</h2>

Если вы хотите, чтобы экран отключался после определенного периода неактивности
консоли (без использования X), можете установить следующие переменные 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">
wscons(4)</a>:

<ul>
<li>Включение <b><tt>display.vblank</tt></b> отключает вертикальное обновление
экрана, что многие мониторы воспринимают как переход в спящий режим или режим
"экономии энергии". После установления этой опции, экрану может потребоваться
значительное время для возврата в обычный режим, но уменьшит потребление энергии
и увеличит производительность. Когда значение этой опции <tt>off</tt>, экран
станет пустым, но монитор будет продолжать горизонтальное и вертикальное
обновление экрана. Таким образом, экран восстановится мгновенно.

<li>Переменная <b><tt>display.screen_off</tt></b> определяет время в тысячных
долях секунды, через которое очищается экран: к примеру, значение 60000
установит таймаут в одну минуту.

<li><b><tt>display.kbdact</tt></b> указывает на то, стоит ли восстанавливать
экран в случае получения активности с клавиатуры. Желательно включить эту опцию.

<li><b><tt>display.outact</tt></b> определяет, будет ли восстанавливаться экран
пустым.
</ul>

Вы можете установить эти переменные в командной строке, используя для этого
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">
wsconsctl(8)</a>:

<pre>
     # <b>wsconsctl display.screen_off=60000</b>
     display.screen_off -> 60000
</pre>

или установить их перманентно, отредактировав 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl.conf&amp;sektion=5">
<i>/etc/wsconsctl.conf</i></a>, и изменения вступят в силу после перезагрузки:

<pre>
     display.vblank=on               # enable vertical sync blank
     display.screen_off=600000       # set screen blank timeout to 10 minutes
     display.kbdact=on               # Restore screen on keyboard input
     display.outact=off              # Restore screen on display output
</pre>

Очищение/отключение экрана включается, если одна из двух переменных - 
<tt>display.kbdact</tt> или <tt>display.outact</tt> - установлена на
<tt>on</tt>.

<a name="ALLCAPS"></a>
<h2>7.8 - ВСЕ, ЧТО Я ВВОЖУ, ОТОБРАЖАЕТСЯ В ВЕРХНЕМ РЕГИСТРЕ!</H2>

Это не баг, а фича.

<p>
Фактически, все Unix-команды и имена пользователей вводятся строчными буквами.
Однако некоторые очень старые терминалы могли писать только заглавными, что
делало невозможным их использование с Unix. Если ввести имя пользователя
полностью заглавными символами, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8">
getty(8)</a> предположит, что вы используете один из подобных старых терминалов
и интерпретирует все, введенное вами, в виде строчных букв, хотя и будет
показывать на экране прописные символы. Если вы используете пароль в разном
регистре или он содержит только прописные буквы, то это сделает невозможным
вход в систему.

<p>
Нажав комбинацию клавиш [CTRL]-D при получении приглашения для входа в систему,
вы прервете работу getty(8), а 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">
init(8)</a> запустит новый процесс, который будет правильно понимать как прописные,
так и строчные буквы.

<a name="tmux"></a>
<h2>7.9 - Was ist tmux?</h2>

Für diejenigen, die mit dem Programm »screen«, das als Paket angeboten
wird, vertraut sind, oder mit window(1), das sich im Basissystem befindet,
mag jene Antwort am einfachsten sein, die besagt, dass
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>tmux(1)</a>
viele Funktionen von screen und window, und darüber hinaus viele weitere
besitzt.

<p>
Für jene, die mit den genannten Programmen nicht vertraut sind,
ist tmux ein <i>Terminal-Multiplexer</i>.
Dies ist ein Programm, dass es einer Anzahl von Programmen erlaubt, denselben
Bildschirm für Eingabe und Ausgabe zu benutzen.
In tmux wird eine solche Kollektion von Programmen »<i>session</i>« (Sitzung)
genannt, wobei jedes Programm in einem tmux »<i>window</i>« (Fenster) läuft.

<p>
Zusätzlich zum Teilen des Terminals erlaubt es tmux, eine Sitzung und ihre
Fenster von der Bildschirmausgabe zu trennen, sie damit einfach im Hintergrund
weiterlaufen zu lassen, und sie später wieder an dieselbe, oder aber eine
andere Konsole »anzuhängen«.
Eine Sitzung kann manuell oder durch ein unerwartetes Ereignis, wie zum
Beispiel einer Unterbrechung des Netzwerks, getrennt werden, in jedem Falle
aber bestehen die Programme fort und laufen weiter wie normal.

<p>
tmux besitzt ebenfalls viele andere Eigenschaften wie zum Beispiel die
Aufteilung des Fensters in verschiedene Sektionen (»<i>panes</i>« genannt;
auf Deutsch: Feld), einer Historie der Bildschirmausgabe jedes Fensters,
konfigurierbaren Tastenkombinationen und der Sperrung des Terminals.
Weitere Informationen offenbart ein Blick in die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>tmux(1)</a>-Handbuchseite.

<h3>Wie benutze ich tmux?</h3>

<p>
Der erste Schritt ist, tmux zu starten:

<blockquote><pre>
$ tmux
</pre></blockquote>

<p>
Dies startet eine neue tmux-Instanz mit einer einzigen neuen Sitzung (»0«
genannt), und erzeugt einen Klienten, der auf dem Bildschirm dargestellt wird.
Der größte Teil des Bildschirms wird ein Fenster mit einem Shell-Prompt zeigen,
und es ist zu sehen, dass die letzte Zeile durch eine Statuszeile eingenommen
wird.
Letztere zeigt linkerhand den Namen der Sitzung in eckigen Klammern, den
Fenstertitel (für Shells normalerweise leer) und die Uhrzeit auf der rechten
Seite, und in der Mitte eine Übersicht der aktuell geöffneten Fenster.
In dieser neuen Sitzung wird die Liste der aktuell geöffneten Fenster nur einen
Eintrag aufweisen, zum Beispiel:

<blockquote><pre>
0:ksh*
</pre></blockquote>

<p>
Ein kurzer Einschub hinsichtlich Terminals: unter OpenBSD werden Anwendungen
auf die Möglichkeiten des Terminals mit Hilfe der Umgebungsvariable TERM
aufmerksam gemacht.
Diese ist auf den Namen eines Eintrags der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=terminfo&amp;sektion=5"
>terminfo(5)</a>-Datenbank gesetzt und erzählt dem Programm das das Terminal,
zum Beispiel, Farbe unterstützt, oder die Möglichkeit des Einschubs von Zeilen
besitzt, oder viele andere Dinge.
Ein wichtige Anmerkung ist, dass der »xterm«-Eintrag der Datenbank keinerlei
Farbunterstützung hat, sodass tmux in xterm standardmäßig keine Farbe benutzt.
TERM sollte auf »xterm-xfree86« gesetzt werden, wenn Farbunterstützung
gewünscht wird (die »XTerm*termName« X-Ressource kann als Eintrag in der
Datei .Xdfaults dazu benutzt werden, dies für alle xterms zu setzen).
Es ist außerdem wesentlich, dass TERM in den Shells, die innerhalb von tmux
gestartet werden, auf »screen« gesetzt ist, da sonst von diesen gestartete
Programme eventuell keine korrekte Bildschirmausgabe produzieren -
tmux setzt diesen Wert selbst, aber es sollte darauf geachtet werden, dass er
in den Shell-Startdateien nicht überschrieben wird.

<p>
Um zu der Statuszeile zurückzukommen - die Nummer »0« ist die Indexzahl des
Fensters, »ksh« sein Name und das »*« indiziert, dass dies das aktuell
dargestellte Fenster oberhalb der Statuszeile ist.
Jedwede Eingabe wird zu der Shell durchgereicht, und jedwede Ausgabe
dargestellt.
Zum Beispiel, startet man
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=top&amp;sektion=1"
>top</a>«:

<blockquote><pre>
$ top
</pre></blockquote>

<p>
Es wird laufen wie normal, und den Bereich des Bildschirms oberhalb der
Statuszeile okkupieren.
Dir wird auch auffallen, dass sich der in der Statuszeile dargestellte
Fenstername von »ksh« zu »top« geändert hat - tmux benennt Fenster so um, dass
ihr Name den des gerade laufenden Programms reflektiert.

<p>
Stellen wir uns vor, dass du tmux vom Bildschirm loslösen, und zu der
ursprünglichen Shell zurückkehren willst, von der es gestartet wurde.
Eine tmux-Sitzung kann durch das gemeinsame Drücken der Tasten <i>Ctrl</i>
(Steuerungstaste) und <i>b</i>, gefolgt von der <i>d</i>-Taste vom Bildschirm
losgelöst werden.
Die <i>Ctrl-b</i> Tastenkombination (in tmux und seiner Handbuchseite zu einem
einfachen »C-b« verkürzt) ist unter dem Namen »<i>prefix key</i>«
(Präfixtaste) bekannt und wird benutzt, um tmux zu zeigen, das die nächste
Taste, die gedrückt wird, als Instruktion interpretiert werden soll, anstatt
sie zu dem im Fenster laufenden Programm durchzureichen.

<p>
Nach dem Drücken von <i>Ctrl-b d</i> und der Rückkehr an den Shell-Prompt kann
die tmux-Sitzung mit Hilfe des »attach«-Kommandos wieder verbunden werden:

<blockquote><pre>
$ tmux attach
</pre></blockquote>

<p>
Die tmux-Sitzung wird wieder erscheinen, und die Statuszeile und »top« werden
immer noch vergnügt laufen.
(Startest du stattdessen tmux ohne Argumente, so wird eine zweite Sitzung
erzeugt, die den Namen »1« tragen wird.)

<p>
Als Nächstes lass uns ein zweites Fenster erzeugen.
Dies wird mit Hilfe der »c«-Taste gemacht: drücke die Präfixtaste
<i>Ctrl-b</i>, gefolgt von der »c«-Taste.
Ein neues Fenster wird erzeugt und wieder wird ein Shell-Prompt auf dem
Bildschirm dargestellt.
Die Statuszeile wird dahingehend aufgefrischt, um das neue Fenster zu zeigen:

<blockquote><pre>
0:top- 1:ksh*
</pre></blockquote>

<p>
Der »-« nach dem »top« zeigt »das vorherige aktuelle Fenster« (das letzte
Fenster) an.
Ein erneutes <i>Ctrl-b c</i> erzeugt eine andere neue Shell:

<blockquote><pre>
0:top  1:ksh- 2:ksh*
</pre></blockquote>

<p>
Es gibt verschiedene Kommandos um zwischen Fenstern hin- und herzuschalten.
Von Fenster 2 aus kann man zum vorherigen Fenster, Nummer 1, wechseln, indem
man <i>Ctrl-b p</i> (»previous«, vorheriges) eingibt.
<i>Ctrl-b n</i> (»next«, nächstes) schaltet zum nächsten Fenster;  In diesem
Falle gibt es kein Fenster 3, sodass die Zählung von vorne beginnt und somit
Fenster 0 das aktuelle Fenster wird.
Man kann auch <i>Ctrl-b w</i> (»windows«, Fenster) drücken um ein interaktives
Menü der offenen Fenster zu erhalten, <i>Ctrl-b l</i> (»last«, letztes) um zum
letzten (das mit »-« markierte) Fenster, oder <i>Ctrl-b 0</i> um Fenster
0 direkt anzuspringen, <i>Ctrl-b 1</i> für Fenster 1 und so weiter bis
einschließlich <i>Ctrl-b 9</i> für Fenster 9.
Also, um zurück zu »top« in Fenster 0 zu gelangen, kann man es entweder mit
<i>Ctrl-b 0</i> direkt anspringen, oder mit zweimal <i>Ctrl-b p</i> in zwei
Schritten über Fenster 1 hinweg erreichen, oder von Fenster 2 aus durch
<i>Ctrl-b n</i> eine neue Zählung erzwingen und dadurch bei 0 landen,
oder aber man drückt <i>Ctrl-b w</i> und wählt Fenster 0 aus der Liste aus.

<p>
Manchmal möchte man auch ein Fenster erzeugen in dem ein Programm direkt läuft,
ohne das zuerst eine Shell gestartet wird.
Dies kann vom tmux <i>Kommandoprompt</i> aus erreicht werden.
Das Drücken der Tastenkombination <i>Ctrl-b :</i> verwandelt die Statuszeile in
einen »:«-Prompt, an dem Kommandos eingegeben werden können.
Alle von tmux unterstützten Kommandos werden auf der Handbuchseite
dokumentiert.
In diesem Fall wird das Kommando »new-window« benötigt.
Jedes Kommando besitzt ein Kürzel, das an seiner statt benutzt werden kann,
für »new-window« ist dies »neww«.
Also, um ein Fenster zu erzeugen in dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tetris&amp;sektion=6"
>tetris(6)</a> läuft, tippe:

<blockquote><pre>
neww tetris
</pre></blockquote>

<p>
Dieses neue Fenster wird geschlossen, wenn sich tetris beendet, oder kann
zwingend mit der Tastenkombination <i>Ctrl-b &</i> vernichtet werden.
Letzteres wird zuerst eine Bestätigung verlangen, und, wenn gegeben, das
Fenster schließen und das darin laufende Programm beenden.

<p>
Ein weiterer häufiger Wunsch ist die Umbenennung eines Fensters.
Die kann mit der Tastenkombination <i>Ctrl-b ,</i> geschehen.
Die Statuszeile wird sich in einen »(rename-window)«-Prompt ändern, an dem der
neue Name eingegeben werden kann.
Das umbenennen eines Fensters schaltet das automatische Umbenennen für dieses
Fenster aus; um diese Eigenschaft wiederzuerlangen, muss mit der
Tastenkombination <i>Ctrl-b :</i> der Kommandoprompt aktiviert-
und Folgendes eingegeben werden (mehr über die Bedeutung im nächsten
Abschnitt):

<blockquote><pre>
setw -u automatic-rename
</pre></blockquote>

<p>
Ein weitere wichtige Tastenkombination ist es wert, erinnert zu werden:
<i>Ctrl-b ?</i>.
Diese zeigt eine Liste aller tmux Tastenkombinationen und der Kommandos, die
sie ausführen.  Zum Beispiel zeigt <i>Ctrl-b ?</i>, dass die Taste <i>c</i> an
das Kommando »new-window« gebunden ist, und die Taste <i>n</i> an das
Kommando »next-window«.

<h3>tmux konfigurieren</h3>

<p>
Viele Benutzer wollen die Art, wie tmux aussieht oder sich verhält, an ihre
Bedürfnisse anpassen.
Dies geschieht mit Hilfe der Konfigurationsdatei <i>~/.tmux.conf</i>.
Diese Datei enthält eine Liste von tmux-Kommandos, die ausgeführt werden, wenn
tmux ursprünglich gestartet, also bevor die erste Sitzung erzeugt wird.
Alle tmux-Kommandos werden auf der Handbuchseite dokumentiert, aber einige
geläufige Beispiele, die du vielleicht in deiner Konfigurationsdatei haben
möchtest, werden weiter unten diskutiert.

<p>
Der geläufigste Bedarf besteht im Setzen von Optionen.
Es gibt zwei Optionstypen in tmux: <i>Sitzungsoptionen</i> und
<i>Fensteroptionen</i>.
Sitzungsoptionen kontrollieren das Verhalten einer Sitzung, und Fensteroptionen
das einzelner Fenster.
Für beide gibt es eine Anzahl globaler Optionen.
Wenn sich tmux für einen Optionswert zwischen dem einer Sitzung und dem eines
Fensters entscheiden muss, so wird es den lokalen Wert für dieses Fenster
vorziehen, und nur dann den globalen Wert benutzen, wenn kein lokaler gefunden
wurde.

<p>
Sitzungsoptionen werden mit dem Kommando »set-option« (Alias: »set«), und
Fensteroptionen mit dem Kommando »set-window-option« (Alias: »setw«) gesetzt.
Um eine globale Option zu setzen, benutze die »-g« Kommandooption; fehlt diese,
so wird die Option für das aktuelle Fenster oder die aktuelle Sitzung gesetzt.
Diese Kommandos akzeptieren auch wenige andere Optionen, wie z.&nbsp;B. »-u«,
dass eine lokale Option löscht und es damit einem Fenster oder einer Sitzung
erlaubt, wieder die globale Option zu erben.

<p>
In der Konfigurationsdatei ist es üblich, globale Optionen zu setzen.
Lass uns einen Blick auf einige Beispiele werfen, die die Statuszeile anpassen:

<blockquote><pre>
set -g status-bg blue
set -g status-right '#(sysctl vm.loadavg)'
setw -g window-status-current-attr underscore
</pre></blockquote>

<p>
Schreibt man diese drei Kommandos in .tmux.conf und startet tmux danach neu,
so ändert sich der Hintergrund der Statuszeile auf blau, wird der
Systemauslastungsdurchschnitt auf der rechten Seite dargestellt, und außerdem
wird das aktuelle Fenster unterstrichen.
Die Statuszeile kann auch komplett ausgeschaltet werden:

<blockquote><pre>
set -g status off
</pre></blockquote>

<p>
Es existiert eine große Anzahl anderer Optionen; eine weitere Praktische ist
der Wechsel hin zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1"
>vi(1)</a>-ähnlichen Tastenkombinationen am Kommandoprompt und in der
Fensterliste und anderen interaktiven tmux-Modi:

<blockquote><pre>
set -g status-keys vi
setw -g mode-keys vi
</pre></blockquote>

<p>
Die aktuell gesetzten Optionen und ihre Werte kann man mit den Kommandos
»show-options« und »show-window-options« auflisten.
Wie die »set«-Kommandos auch akzeptieren diese die Option »-g« zum Zugriff auf
die globalen Optionen.

<p>
Ein weitere geläufige Aufgabe für die Konfigurationsdatei ist das Hinzufügen
von, oder das Modifizieren bestehender Tastenkombinationen für tmux, dass heißt
der Kommandos, die nach dem Drücken von <i>Ctrl-b</i> zusammen mit einer
weiteren Taste ausgeführt werden.
Diese werden mit dem Kommando »bind-key« (Alias: »bind«) hinzugefügt oder
geändert, und mit dem Kommando »unbind-key« (Alias: »unbind«) entfernt.
Zwei Beispiele für »bind-key« sind:

<blockquote><pre>
bind C-d detach
bind / neww 'exec top'
</pre></blockquote>

<p>
Die erste Zeile erzeugt eine Bindung zwischen <i>Ctrl-b Ctrl-d</i> und der
Loslösung von tmux von dem Bildschirm, identisch der standardmäßigen
<i>Ctrl-b d</i>, und die zweite verknüpft <i>Ctrl-b /</i> mit dem Erzeugen
eines neues Fensters, in welchem »top« ausgeführt wird.

<p>
Viele Leute möchten einen anderen Präfix anstelle von <i>Ctrl-b</i> haben.
Dies kann dadurch erzielt werden, dass sowohl die »set-option« als auch die
Tastenkombinationskommandos benutzt werden, um die Präfixtastenoption
dergestalt zu ändern, dass das zweimalige Drücken auch weiterhin den
Originalwert an das Fenster durchreicht.
Um den Präfix auf <i>Ctrl-a</i> zu ändern:

<blockquote><pre>
set -g prefix C-a
unbind C-b
bind C-a send-prefix
</pre></blockquote>

<p>
Die letzte nützliche Sache, die man in der Konfigurationsdatei machen kann, ist
das Erzeugen einer anfänglichen Reihe von Fenstern, wenn tmux startet.
Dies ist ein wenig komplizierter als die vorangegangenen Beispiele.
In tmux müssen Sitzungen Fenster haben, und ohne Sitzung können keine Fenster
erzeugt werden.
Das heißt, um in der Konfigurationsdatei Fenster zu erzeugen, muss es zuerst
eine Sitzung geben, der sie zugeordnet werden können.
Zum Beispiel (beachte, dass »new« der Alias für das Kommando »new-session« ist):

<blockquote><pre>
new -d 'exec top'
neww -d
neww -d
</pre></blockquote>

<p>
Diese Kommandos erzeugen zuerst eine neue Session, in deren erstem Fenster
»top« läuft, und danach zwei weitere Fenster.
Die »-d«-Optionen weisen tmux an, weder zu versuchen, die neue Session an den
Bildschirm anzuhängen, noch die neuen Fenster zu aktuellen Fenstern zu machen.
Bevor man diese Zeilen in die .tmux.conf schreibt, sollte ein weiteres
Problem bedacht werden.
Wenn man tmux ohne Argumente startet, so führt es das Kommando »new-session«
aus, sodass ein per »tmux« von der Shell gestartetes tmux aus der
Konfigurationsdatei die Anweisung erhält, eine Sitzung zu starten, wonach das
gestartete tmux ebenfalls eine andere Sitzung erzeugt, sodass in diesem
Fall am Ende <i>zwei</i> Sitzungen existieren.
Um dies zu vermeiden, sollte tmux mit »tmux attach« gestartet werden, wenn eine
Sitzung aus der Konfigurationsdatei heraus erzeugt werden soll - dies bedeutet,
dass es die Sitzung aus der .tmux.conf erzeugt und sich danach sofort an sie
anhängt, ohne eine zweite Sitzung zu starten.

<h3>Fortgeschrittene Benutzung von tmux</h3>

<p>
Dieser Abschnitt behandelt kurz einige der eher fortgeschrittenen
Möglichkeiten, die tmux bietet.
Lies die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>Handbuchseite</a> für weitere Informationen.

<p>
In tmux kann man zwischen Fenstern das Kopieren und Einfügen von Text
durchführen.  Dazu muss der Text im <i>Kopiermodus</i> kopiert, und dann mit
dem Einfügekommando eingefügt werden.
Um in den Kopiermodus zu gelangen, benutze <i>Ctrl-b [</i>.
Im Kopiermodus (mit der Fensteroption »mode-keys« gesetzt auf »emacs«, siehe
Handbuchseite für »vi«-Tastenkombinationen) ermöglichen die Pfeiltasten eine
Positionierung des Cursors, <i>Ctrl-Space</i> (Leertaste) beginnt die Selektion
und <i>Ctrl-w</i> kopiert.
Man kann den Cursor ebenfalls mit <i>Page up</i> (Seite hoch), <i>Page down</i>
(Seite runter), <i>Ctrl-a</i> und <i>Ctrl-e</i> bewegen.
Drücke <i>g</i> oder <i>Escape</i>, um den Kopiermodus zu verlassen.
Danach wird <i>Ctrl-b ]</i> den kopierten Text in das aktuelle Fenster
einfügen, als ob man ihn direkt getippt hätte.

<p>
tmux läßt sich ganz gut mit Skripten steuern, und die meisten Kommandos, die am
Kommandoprompt eingegeben, oder über eine Tastaturkombination abgerufen werden
können, können ebenfalls von einer Shell aus benutzt werden.
Beinahe alle tmux-Kommandos akzeptieren ein optionales Argument »-t« zur
Spezifizierung einer Sitzung oder eines Fensters als Kommandoziel.
Zum Beispiel wird dieses Kommando:

<blockquote><pre>
$ tmux kill-window -t0:1
</pre></blockquote>

das Fenster 1 der Sitzung 0 vernichten.
Und:

<blockquote><pre>
$ tmux new-window -tmysession
</pre></blockquote>

<p>
erzeugt ein neues Fenster in der Sitzung mit Namen »mysession«.
Viele Kommandos akzeptieren andere Argumente, zum Beispiel akzeptiert das
Kommando »new-window« eine Option »-n« zur Benennung des neuen Fensters, und
»new-session« akzeptiert verschiedene Argumente zur Spezifizierung von
Attributen für das Fenster, das mit der Sitzung erzeugt wird.
Diese Argumente können ebenfalls benutzt werden, wenn ein Kommando an eine
Tastenkombination gebunden-, oder vom Kommandoprompt aus benutzt wird.

<p>
Ein weiteres nützliches Merkmal ist die Möglichkeit, ein einfaches Fenster in
mehrere Sektionen aufzusplitten, die »<i>pane</i>« (Feld) genannt werden.
Mit der Tastenkombination <i>Ctrl-b "</i> kann man Fenster vertikal (von oben
nach unten) aufteilen.
Ein Feld kann nach oben oder unten mit den Tastenkombinationen
<i>Ctrl-b Alt-Up</i> (Meta und Pfeil-hoch) und <i>Ctrl-b Alt-Down</i> (Meta und
Pfeil-runter) in der Größe verändert, und das aktive Feld mit <i>Ctrl-b o</i>
gewechselt werden.
Zusätzlich kann ein Fenster, das derart aufgeteilt wurde, in eine Reihe fester
Layouts überführt werden, durch welche man mit der Tastenkombination
<i>Ctrl-b Space</i> (Leertaste) durchwechseln kann; jedoch können Felder in
einem solchen Layout nicht in der Größe verändert werden.
In -current wurde das Aufteilen erweitert, und unterstützt nun auch die
horizontale Aufteilung (<i>Ctrl-b %</i>); ebenfalls wurden die festen Layouts
geändert, sodass sie nun einmal (mit denselben <i>Ctrl-b Space</i>
Tasteneingaben) angewendet  aber danach frei sowohl in der Größe, als auch
horizontal und vertikal verändert werden können.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq6.html">[Глава 6 - Сеть]</a>
<a href= "faq8.html">[Глава 8 - Общие вопросы]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq7.html,v 1.91 ]<br>
$Translation: faq7.html,v 1.2 2013/05/02 07:22:05 alex Exp $<br>
-->
$OpenBSD: faq7.html,v 1.2 2013/05/03 05:53:48 ajacoutot Exp $
</small>
</body>
</html>
