<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>11 - Performance Tuning</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2003 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq10.html">[To Section 10 - System Administration]</a>
<a href= "faq12.html">[To Section 12 - For Advanced Users]</a>
</font>

<h1><font color="#e00000">11 - Performance Tuning</font></h1>
<hr>

<p>
<h3>Table of Contents</h3>
<ul>
<li><a href="#Network">11.1 - Networking</a>
<li><a href="#Disk"   >11.2 - Disk I/O</a>
<!-- li><a href="#kmem"   >11.3 - Tuning kmem</a></li -->
<li><a href="#HW"     >11.4 - Hardware Choices</a>
<li><a href="#Async"  >11.5 - Why aren't we using async mounts?</a>
<li><a href="#XF86"   >11.6 - Tuning your monitor resolution under
XFree86</a>
</ul>

<hr>

<p>
If you run a busy server, gateway or firewall, you may wish or need to
adjust some of the default parameters to get optimal performance.
The <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a> 
man page talks about the kernel options presented. These options are placed 
in the kernel configuration file before you compile a custom kernel, and some
are settable via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>.
For more details, see <a href="faq5.html">FAQ 5</a>.


<p>
<a name= "Network"></a>
<a name= "11.1"></a>
<h2>11.1 - Networking</h2>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
A parameter you may need to change for a busy server, gateway or firewall is
NMBCLUSTERS.  This controls the size of the kernel mbuf cluster map.
On your computer, if you get messages like "mb_map full",
you need to increase the value of this parameter.  If traffic on a network
interface stops
for no apparent reason, this may also be a sign that you need to increase
the value of NMBCLUSTERS.  A reasonable value on the i386 port with most 100Mbps
ethernet interfaces (no matter how many the machine has) is 8192.  

<blockquote><strong>
option NMBCLUSTERS=8192
</strong></blockquote>

<p>
The default number of NMBCLUSTERS varies from platform to platform, 
ranging from 256 to 2048.  It is set in a platform-dependent header 
file unless overridden by an option line in a kernel config file.

<p>
NMBCLUSTERS can also be set using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>,
which eliminates the need to compile a kernel and reboot solely to
change this option:

<blockquote><pre>
# <b>config -e -o bsd.new /bsd</b>
OpenBSD 3.3 (GENERIC) #44: Sat Mar 29 13:22:05 MST 2003
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
Enter 'help' for information
ukc> <b>nmbclust</b>
nmbclusters = 2048
ukc> <b>nmbclust 8192</b>
nmbclusters = 8192
ukc> <b>quit</b>
Saving modified kernel.
</pre></blockquote>

This will create a new kernel, <tt>bsd.new</tt>, in the current
directory, <i>and</i> modifies the NMBCLUSTERS parameter of the running
kernel.  If all goes well, don't forget to copy <tt>bsd.new</tt> to
<tt>/bsd</tt> before rebooting.


<p>
<a name= "Disk"></a>
<a name= "11.2"></a>
<h2>11.2 - Disk I/O</h2>

<p>
Disk I/O speed is a significant factor in the overall speed of your
computer.  It becomes increasingly important when your computer
is hosting a multi-user environment (users of all kinds, from those
who log-in interactively to those who see you as a file-server or a web-server.)
Data storage constantly needs attention, especially when your partitions run
out of space or when your disks fail.  OpenBSD has several options
to increase the speed of your disk operations and provide fault tolerance.

<p>
Table Of Contents
<ul>
<li><a href="#ccd">CCD</a> - Concatenated Disk Driver.
<li><a href="#raid">RAID</a>
<li><a href="#buf">Filesystem Buffer</a>
<li><a href="#softu">Soft Updates</a>
<li><a href="#maxvnodes">Size of the namei() cache</a>
</ul>

<p>
<a name="ccd"></a>
<h3>11.2.1 - CCD</h3>

<blockquote>
The first option is the use of <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>, the Concatenated Disk Driver.
This allows you to join several partitions into one virtual disk (and thus,
you can make several disks look like one disk).  This concept is
similar to that of LVM (logical volume management), which is found in many commercial Unix flavors.

<p>
If you are running GENERIC, ccd is already enabled (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  If you have customized
your kernel, you may need to return it to your kernel configuration.
Either way, a line such as this should be in your configuration file:

<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
The above example gives you up to 4 ccd devices (virtual disks).
Now you need to figure out which partitions on your real disks you want
to dedicate to ccd.  Use disklabel to mark these partitions as type 'ccd'.
On some architectures, disklabel may not allow you to do this.  In this case,
mark them as 'ffs'.

<p>
If you are using ccd to gain performance by striping, note that you will
not get optimum performance unless you use the same model of disks with
the same disklabel settings.

<p>
Edit /etc/ccd.conf to look something like this:
(for more information on configuring ccd, look at
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
To make your changes take effect, run

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
As long as /etc/ccd.conf exists, ccd will automatically configure itself
upon boot.
Now, you have a new disk, ccd0, a combination of /dev/sd2e and /dev/sd3e.
Just use disklabel on it like you normally would to make the partition 
or partitions you want to use.  Again, don't use the 'c' partition as
an actual partition that you put stuff on.
Make sure your usable partitions are at least one cylinder off from the beginning
of the disk.
</blockquote>

<p>
<a name="raid"></a>
<h3>11.2.2 - RAID</h3>

<blockquote>
Another solution is <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
which will have you use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
to control your raid devices.  OpenBSD's RAID is based upon
Greg Oster's <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD port</a>
of the CMU
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> software.
OpenBSD has support for RAID levels
of 0, 1, 4, and 5.<P> With raid, as with ccd, support must be in the KERNEL.
Unlike ccd, support for RAID is not found in GENERIC, so it must be compiled 
into your kernel (RAID support adds some 500K to the size of an i386 kernel).

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
Setting up RAID on some operating systems is confusing and
painful to say the least.  Not so with RAIDframe.
Read the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a> and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
man pages to get full details. There are many
options and possible configurations available, and a detailed explanation is beyond the scope of this document.
</blockquote>

<p>
<a name="buf"></a>
<h3>11.2.3 - Filesystem Buffer</h3>

<blockquote>
For fileservers with memory to spare, you can increase BUFCACHEPERCENT.
That is, what percentage of your RAM should you use as a file system buffer.
This option may change when the Unified Buffer Cache is completed
and is part of OpenBSD.  In the mean time, to increase BUFCACHEPERCENT,
you should add a line to your kernel configuration like this:
</blockquote>

<blockquote>
<strong>option	BUFCACHEPERCENT=30</strong><BR>
</blockquote>

<blockquote>
Of course you can make it as low as 5 percent (the default) or as high
as 50 percent (or more.)
</blockquote>

<blockquote>
BUFCACHEPERCENT can also be set using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>,
as <a href="#Network">above</a>, which eliminates the need to compile a
kernel solely to change this option.  </blockquote>

<p>
<a name="softu"></a>
<h3>11.2.4 - Soft updates</h3>

<blockquote>
Another tool that can be used to speed up your system is softupdates.  One of the 
slowest operations in the traditional BSD file system is updating metainfo
(which happens, among other times, when you create or delete files and
directories.) Softupdates
attempts to update metainfo in RAM instead of writing
to the hard disk each and every single metainfo update.  Another 
effect of this is that the metainfo on disk should always be complete,
although not always up to date.  So, a system crash should not require
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
upon boot up, but simply a background version of fsck that makes
changes to the metainfo in RAM (a la softupdates).
This means rebooting a server is much faster, as you don't
have to wait for fsck!  (OpenBSD does not have this feature yet.) You can read
more about softupdates in the <a href="faq14.html#SoftUpdates">Softupdates FAQ</a> entry.
</blockquote>

<p>
<a name="maxvnodes"></a>
<h3>11.2.5 - Size of the namei() cache</h3>

<dl>
<dd>
Note: previously, the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>
manual page recommended to set the <tt>NVNODE=integer</tt> kernel option. This
is no longer recommended; you should now use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
command instead. 
<p>
The name-to-inode translation (a.k.a., <!-- need to write the manual
page first... <a href="">namei(3)</a> --> namei()) cache controls
the speed of pathname to 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>
translation. By default, this cache has <tt>NPROC * (80 + NPROC / 8)</tt> 
entries.  <tt>NPROC</tt> is set to <tt>20 + 16 * MAXUSERS</tt>; see the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>
manual page for an explanation on the <tt>maxusers</tt> kernel configuration parameter.
A reasonable way to derive a value for the cache, should a large number of namei()
cache misses be noticed with a tool such as 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>,
is to examine the system's current computed value with 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>,
(which calls this parameter "<tt>kern.maxvnodes</tt>") and to increase this 
value until either the namei() cache hit rate improves or it is determined that 
the system does not benefit substantially from an increase in the size of the 
namei() cache. After the value has been determined, you can  
set it at system startup time with 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>.
</dd>
</dl>


<p>
<!-- a name= "kmem"></a>
<a name= "11.3"></a>
<h2>11.3 - Tuning kmem</h2>
This was moved to the <a href="faq11-2.5.html#11.2">OpenBSD 2.5 information section</a>.
<br>
<p -->
<a name= "HW"></a>
<a name= "11.4"></a>
<h2>11.4 - Hardware choices</h2>
<!-- XXXchanges - check every OpenBSD release -->

<p>
<i>(Note- this section is heavily centered around the i386, or PC, architecture.
That is to say... other architectures don't give you quite as many choices!)</i>

<p>
The performance of your applications depends heavily on your OS and the
facilities it provides.  This 
may be part of the reason that you are using OpenBSD.
The performance of your applications also depends heavily on your hardware.
For many folks, the Price/Performance ratio of a brand new PC with
a Intel Pentium IV or AMD Athlon processor is much better than the
Price/Performance ratio of a Sun UltraSparc 60!
Of course, the price of OpenBSD can't be beaten.

<p>
If you are shopping for a new PC, whether you are buying it
piece by piece or completely pre-built, you want to make sure first
that you are buying reliable parts.  In the PC world, this is not easy.
<b>Bad or otherwise unreliable or mismatched parts can
make OpenBSD run poorly and crash often</b>.  The best advice
we can give is to be careful, and
buy brands and parts that have been reviewed by an authority you trust.
Sometimes, when you skimp on the price of a PC, you lose in quality!

<p>
There are certain things that will help bring
out the maximum performance of your hardware:

<ul>
<li><b>Use multiple disks.</b>
Instead of buying one large disk, buy multiple smaller disks.  While this
may cost more, distributing the load over multiple spindles will decrease
the amount of time necessary to access data on the disks.  And, with more 
spindles, you will get more reliability and faster data access with RAID.
<p>
<li><b>Use SCSI if you need very high disk IO speeds.</b>
IDE disks normally run at 5400 RPM to 7200 RPM.  
Using high end IDE disks, it may be unreasonable to expect
more than 15 to 20 megabytes per second of throughput from a single disk.
Using high end SCSI disks (higher cost 10k RPM to 15k RPM disks), you can 
achieve
performance higher than this.  Conversely, if you are using medium or 
low end SCSI disks, this is a waste of money, and IDE will serve you 
just as well, if not better.
<p>If you are building a server, and you need more than one drive,
you may want to consider SCSI.  IDE limits you to two disks per controller.  Concurrent access to these two disks may have a negative
impact on the I/O performance of these disks.
Wide SCSI limits you to 15 per controller, and has better support for 
concurrent access than IDE. While SCSI costs more, the flexibility and
performance can justify these costs in some environments.
<p>
<li><b>Use SDRAM instead of DRAM.</b>
This option applies mainly to PCs.  Most other architectures don't give
you a choice of what kind of RAM you can use.  Several PCs still do.
You will get better performance with SDRAM versus DRAM (SIMMs).
If your system supports RDRAM, DDR or some other new type of RAM, then
you are even further ahead...
<p>
<li><b>Use ECC or parity RAM.</b>
Parity adds some functionality to see if the data in RAM has been
corrupted.  ECC extends this functionality and attempts to correct
some bit corruption errors on the fly.
This option applies mainly to PCs.  Most other architectures
simply require parity or ECC capable RAM.  Several non-PC computers won't
even boot with non-parity RAM. 
If you aren't using ECC/parity RAM, you may get data corruption and
other abnormalities. Several manufacturers
of "cheap PC RAM" don't even make an ECC variety!  This will help you
avoid them!  PC manufacturers often sell several product lines, 
divided around "servers" and "workstations."  The servers will incorporate
ECC RAM into their architecture.  Unix workstation manufacturers have been
using parity (and now ECC) for several years in all of their product lines.
<p>
<li><b>Avoid ISA devices.</b>
While most folks avoid ISA devices because they are generally hard to configure
and out of date, there are still plenty in existence.  If you are using the ISA
bus for your disk or network controllers, (or even worse, for both) remember
that the ISA bus itself can be a performance bottleneck.  If you need speed,
look into PCI.  Of course, there are still several ISA bus cards that work
just fine.  Unfortunately, most of these are sound cards and serial port cards.
<p>
<li><b>Avoid cheap PCI network adapters.</b>
OpenBSD supports a plethora of cheap PCI network adapters.  These
adapters work great in home systems, and also low or moderate throughput
business and research environments. But, if you
need high throughput and low impact on your server, you are better
off buying a quality PCI network adapter.  Unfortunately, some
expensive brand adapters (such as the 3com XL series) are not much
better than the cheap adapters.  One favourite 10/100Mbps adapter
is the Intel EtherExpress PRO/100.
</ul>


<p>
<a name= "Async"></a>
<a name= "11.5"></a>
<h2>11.5 - Why aren't we using async mounts?</h2>

<p>
Question: "I simply do "mount -u -o async /" which makes one package I use 
(which insists on touching a few hundred things from time to time) usable.

Why is async mounting frowned upon and not on by default (as it is in some
other unixen)? Isn't it a much simpler, and therefore, a safer way of
improving performance in some applications?"

<p>
Answer: "Async mounts is indeed faster than sync mounts, but they are also 
less safe. What happens in case of a power failure? Or a hardware problem?
The quest for speed should not sacrifice the reliability and the stability of 
the system. Check the man page for 
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>."

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
On the other hand, when you are dealing with temp data that you can recreate 
from scratch after a crash, you can gain speed by using a separate 
partition for that data only, mounted async.  Again, do this <i>only if</i> 
you don't mind the loss of all the data in the partition 
when something goes wrong. For this reason,
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
partitions are mounted asynchronously, as
they will get wiped and recreated on a reboot anyway.


<p>
<a name= "XF86"></a>
<a name= "11.6"></a>
<h2>11.6 - Tuning your monitor resolution under XFree86</h2>

<p>
Getting an X server working at an acceptable resolution with many multi-sync
monitors is possible.  If anyone has tried to do this with the standard
xf86config or XF86Setup utilities, they probably didn't get the best possible
results.  One of the more painful aspects is simply getting your monitor running
with your preferred resolution,
and then
getting the vertical scan rate set to at least 72-75 Hz,
a rate where the screen flicker is much less visible to humans.  
Conversely, what if you are trying to set the vertical scan rate so it is very low?
You can set it at 50 Hz so that it can be captured on to video without flicker,
but the methods to do this are non-obvious with the standard XFree86 tools and
documentation.

<p>
Finally, at the resolutions many people normally use with inexpensive VGA monitors
(800x600, 1024x768, 1152x900,
1280x1024), it is possible (at least on newer monitors) to use vertical scan rates of
85Hz and above, to achieve an extremely clean, palatable picture.
The XFree86 X server has a mechanism which allows you to describe in detail the video
mode you want to use, this is the ModeLine.  A ModeLine has four sections, a single number for the pixel clock,
four numbers for horizontal timings, four numbers for vertical timings,
and an optional section with a list of flags specifying other characteristics
of the mode (such as Interlace, DoubleScan, and more... see the
XF86Config(5) manual page for more ModeLine details).

<p>
Generating a ModeLine is a black art... Luckily, there are several scripts
which can do this for you.  One is <a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">
Colas XFree86 ModeLine Generator</a>.  Another is
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline Generator</a>
hosted at SourceForge, and there are several others available on
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Before you can use these ModeLine generators, you need to figure
out the vertical
and horizontal sync limits for your monitor.  This is often documented
in the manual, or on the manufacturer's web site.  If you can't find
either of those, simply search the web for the monitor make and model,
several people have been kind enough to compile lists with this information.

<p>
For example, say you have a Dell D1226H monitor.  You searched in agony
at Dell's web site to find that it has a 30-95 kHz horizontal scan range,
and a 50-160 Hz vertical scan range.  Visit the ModeLine generator page,
enter this information.  Next, you need to enter the minimum
vertical scan rate you want.  Any rate at or above 72 Hz should generally have low
visible flicker.  As you go higher, the clearer and crisper your screen
image becomes.  

<p>
With all of these bits of information, the script will generate a ModeLine
for every possible 4x3 resolution which your monitor can support, above
the minimum vertical scan rate which you enter.  If someone enters the Dell specs above
and a 75 Hz vertical scan minimum, the script gives out something like the
following:

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
Now, this monitor claims to do 1600x1200 @ 75 Hz, but the script does not
say this is within 75 Hz.  So, if you really want exactly 1600x1200, 
go down a notch with your minimum vertical rate... (Here, we go down
to 70 Hz)

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
Here, we see the monitor really does 1600x1200 @ 74 Hz when the dot clock
(bandwidth) is limited to 200MHz.  Set the bandwidth according to the
limits defined by the monitor.

<p>
Once you have your ModeLines, put them into your /etc/X11/XF86Config file. 
Comment out the old ModeLines, so that you can use them again if the new ones
don't work.
Next, choose what resolution you actually want to run at.   First,
figure out if X is running in accelerated mode (which it does with most video
cards), so you know which <tt>"Screen"</tt> section of the XF86Config to modify.
Or, just modify all of the Screen sections.

<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
The first resolution you see after the "Modes" keyword is the resolution that
X is going to start in.  By pressing CTRL-ALT-KEYPAD MINUS, or CTRL-ALT-KEYPAD
PLUS, you can switch between any resolutions that you list here.  According
to the section above, X will try to start in 32-bit color mode (via
the DefaultColorDepth directive, without it X will start in 8-bit color mode.)
The first resolution it will try to use is 1280x1024 (it follows the order
of the Modes line.)  Note that "1280x1024" is just a label for the values in
the ModeLine.

<p>
Note that the ModeLine generator script has options to relax its timings for older
or smaller monitors, and also has the ability to provide ModeLines for
specific resolutions.  Depending on the type of hardware you have, it
may not be very easy to use with the default options.  If the picture is
too tall, too wide, or too small, or is shifted horizontally or vertically,
and the controls of the monitor aren't enough to correct its appearance,
once can use xvidtune(1) to adjust the ModeLine to better fit with the
monitor's timings.

<p>
On most modern monitors, there is no fixed limit on the bandwidth, thus
they are often not listed anymore in the specs. What happens is that the
more you go up in bandwidth, the fuzzier the screen image becomes.
So you may want to put in the bandwidth of your card (also named
"dotclock") to test (you cannot damage your monitor this way), and go
progressively down in BW down to have a nice crisp image.

<p>
If this seems needlessly complex, that's because it is.  XFree86 4.0 addresses
this, and makes this process much easier since it has several built-in
modes and is capable of reading back capabilities from "plug and play" monitors
through DDC and DDC2.

<p>
You can download the Colas XFree86 ModeLine Generator script at:
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>.
You need to grab the Klone interpreter, and compile it.  It is in the
ports as <tt>lang/klone</tt>.  The scripts
exist under the scripts directory in the Klone distribution.  (The
port installs them to /usr/local/lib/klone/scripts.)

<p>
There are two versions of the script included, the first is a CGI version identical
to the web page above.  The second is a non-CGI version
which will take your complete XF86Config file, decode the monitor specs that
you entered into xf86config/XF86Setup (Now, think, did you actually
enter the specs for your monitor or just choose generic ones?),
and fix the existing ModeLines accordingly. 

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq10.html">[To Section 10 - System Administration]</a>
<a href= "faq12.html">[To Section 12 - For Advanced Users]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq11.html,v 1.42 2003/06/22 18:54:12 david Exp $</small>
</body>
</html>
