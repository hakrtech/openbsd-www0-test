<html>
<head>
<title>14.0 - Configuraci&oacute;n del disco</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta name="resource-type" content="documento">
<meta name="description"   content="Preguntas Frecuentes de OpenBSD">
<meta name="keywords"      content="openbsd,faq,documentación">
<meta name="distribution"  content="global">
<meta name="copyright"     content="Este documento es copyright 1998-2000 de OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000" link="#23238e">

<img alt="[OpenBSD]" height="30" width="141" src="../../images/smalltitle.gif">
<p>
<h2><font color="#e00000">14.0 - Configuraci&oacute;n del
disco</font><hr></h2>
</p>

<p>
<ul><h3>Tabla de contenidos</h3>
<li><a href="#14.1">14.1 - C&oacute;mo usar el <i>disklabel</i> de
    OpenBSD</a></li>
<li><a href="#14.2">14.2 - C&oacute;mo usar el <i>fdisk</i> de
    OpenBSD</a></li>
<li><a href="#14.3">14.3 - C&oacute;mo a&ntilde;adir discos adicionales
    en OpenBSD</a></li>
<li><a href="#14.4">14.4 - C&oacute;mo usar un fichero como memoria de
    intercambio (<i>swap</i></a></li>
<li><a href="#14.5">14.5 - &quot;Softupdates&quot;</a></li>
<li><a href="#14.6">14.6 - Cuando arranco el sistema despu&eacute;s de
    la instalaci&oacute;n de OpenBSD/i386, se para en<br>
    &quot;Using partition 3 id 0&quot;.</a></li>
<li><a href="#14.7">14.7 - &iquest;C&oacute;mo obtento un dmesg de un
    disquete de arranque?</a></li>
<li><a href="#14.8">14.8 - Instalaci&oacute;n de bloques de arranque
    (espec&iacute;fico de i386)</a></li>
<li><a href="#14.9">14.9 - Prepararse para el desastre: hacer copias de
    seguridad (respaldo) y restaurar desde la cinta.</a></li>
<li><a href="#14.10">14.10 - C&oacute;mo montar im&aacute;genes de
    disco en OpenBSD.</a></li>
</ul>
</p> 
<hr>

<p>
<a name="14.1"></a>
<h2>C&oacute;mo usar disklabel</h2>
   
<p>
<h3>Tabla de contenidos de disklabel</h3>
<ul>
<li><a href="#14.1.1">&iquest;Qu&eacute; es disklabel(8)?</a>
<li><a href="#14.1.2">Disklabel durante la instalaci&oacute;n de
    OpenBSD</a>
<li><a href="#14.1.3">Usos comunes de disklabel(8)</a>
</ul>
</p>
   
<p>
<a name="14.1.1"></a>
<h3>&iquest;Qu&eacute; es disklabel(8)?</h3>
   
<p>
Las &laquo;clasificaciones del disco&raquo;
(<i>&quot;disklabels&quot;</i>) se crean para permitir una interfaz
eficiente entre su disco y los controladores del disco que contiene el
n&uacute;cleo del sistema (<i>&quot;kernel&quot;</i>).  Estas
clasificaciones contienen cierta informaci&oacute;n sobre su disco,
como la geometr&iacute;a del controlador e informaci&oacute;n sobre sus
sistemas de archivo (<i>&quot;filesystems&quot;</i>).  Esta
informaci&oacute;n la utiliza el programa de arranque para cargar el
controlador y para saber en qu&eacute; parte del controlador se
encuentran los sistemas de archivo.  Las clasificaciones tambi&eacute;n
se usan en conjunto con los sistemas de archivo para crear un entorno
m&aacute;s eficiente.  Puede leer documentaci&oacute;n m&aacute;s a
fondo sobre disklabel en la p&aacute;gina de manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=5&format=html">disklabel(5)</a>.
</p> 

<p>
Adem&aacute;s, el uso de disklabel ayuda a superar las limitaciones de
las arquitecturas al particionar el disco.  Por ejemplo, en i386
s&oacute;lo puede tener cuatro particiones primarias (particiones que
puedan ver otros sistemas operativos como Windows NT o DOS).  Con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>,
usa una de esas particiones primarias para almacenar <b>todas</b> sus
particiones de OpenBSD (<i>swap</i>, <i>/</i>, <i>/usr</i>,
<i>/var</i>, ...), y todav&iacute;a le quedan tres particiones libres
para otros sistemas operativos.
</p>

<p>
<a name="14.1.2"></a>
<h3>disklabel(8) durante la instalaci&oacute;n de OpenBSD</h3>

<p>
Una de las partes principales de la instalaci&oacute;n de OpenBSD es la
creaci&oacute;n inicial de &laquo;clasificaciones&raquo;
(<i>&quot;labels&quot;</i>).  Para los usuarios de plataformas i386,
&eacute;ste es el paso que viene justo despu&eacute;s de usar <a
href="#14.2">fdisk(1)</a>.  Durante la instalaci&oacute;n, el programa
que usa para crear clasificaciones separadas que contengan sus puntos
de montaje separados es disklabel.  Durante este proceso puede
configurar sus puntos de montaje desde dentro de disklabel, pero esto
no es del todo necesario si consideramos que m&aacute;s tarde le
pedir&aacute; que confirme sus elecciones.  De todos modos hace que su
instalaci&oacute;n sea un poco m&aacute;s suave.
</p>

<p>
Ya que esto ocurre durante la instalaci&oacute;n, todav&iacute;a no
tendr&aacute; ninguna clasificaci&oacute;n creada, y por lo tanto deben
ser creadas.  La primera clasificaci&oacute;n que tendr&aacute; que
crear es la clasificaci&oacute;n '<b>a</b>'.  Esta clasificaci&oacute;n
DEBE ser en la que se monte el sistema de archivo <b>/</b>.  Puede ver
las particiones que se recomienda crear y sus respectivos
tama&ntilde;os recomendados en la 
<a href="faq4.html#4.3">secci&oacute;n 4.3</a> de las preguntas
frecuentes.  Para servidores se recomienda que, por lo menos, se creen
estas particiones separadas.  Para los usuarios de computadoras
(ordenadores) de sobremesa, ser&aacute; suficiente con crear un
s&oacute;lo punto de montaje para <b>/</b>.  Cuando cree por primera
vez esta partici&oacute;n ra&iacute;z (clasificaci&oacute;n <b>a</b>),
tenga en cuenta que necesitar&aacute; dejar ALGO de espacio para la
clasificaci&oacute;n de <i>swap</i>.  Ahora que ya hemos explicado lo
m&aacute;s b&aacute;sico, pasemos a un ejemplo de la utilizaci&oacute;n
de disklabel durante la instalaci&oacute;n.  En este primer ejemplo se
asume que OpenBSD va a ser el &uacute;nico sistema operativo en la
m&aacute;quina, y que se llevar&aacute; a cabo una instalaci&oacute;n
completa.
</p>

<p>
<em>N. del T.:  el texto que sigue a continuaci&oacute;n est&aacute;
traducido para el prop&oacute;sito de este documento, pero durante la
instalaci&oacute;n el texto aparecer&aacute; en ingl&eacute;s</em>
</p>

<ul>
<pre>
Si se comparte el disco con otros sistemas operativos, esos sistemas
operativos deben tener una entrada de la partici&oacute;n en la BIOS
que abarque completamente el espacio que ocupen.  Aseg&uacute;rese de
que todos los sistemas de archivo de OpenBSD se encuentren dentro del
tama&ntilde;o especificado en la tabla de particiones de la BIOS 'A6'
(por definici&oacute;n, el editor de disklabel tratar&aacute; de forzar
esto).  Si no est&aacute; seguro de c&oacute;mo usar correctamente
particiones m&uacute;ltiples (o sea, /, /usr, /tmp, /var, /usr/local, y
otras separadas), divida el espacio de momento en una partici&oacute;n
ra&iacute;z y otra <i>swap</i>.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <strong>d a</strong>
&gt; <strong>a a</strong>
offset: [63] <strong>&lt;Intro&gt;</strong>
size: [16386237] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Intro&gt;</strong>
mount point: [none] <strong>/</strong>
fragment size: [1024] <strong>&lt;Intro&gt;</strong>
block size: [8192] <strong>&lt;Intro&gt;</strong>
cpg: [16] <strong>&lt;Intro&gt;</strong>
&gt; <strong>a b</strong>
offset: [131103] <strong>&lt;Intro&gt;</strong>
size: [16255197] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [swap] <strong>&lt;Intro&gt;</strong>
</pre>
</ul>
</p>

<p>
Hasta este punto hemos creado una partici&oacute;n ra&iacute;z de 64MB
montada en <b>/</b>, y una partici&oacute;n <i>swap</i> de 64MB.  Note
que empieza (&quot;offset&quot;) en el sector 63.  En la parte
correspondiente al tama&ntilde;o, disklabel muestra su tama&ntilde;o en
sectores;  sin embargo no es necesario introducirlos en el mismo
formato.  Como en el ejemplo anterior, puede introducir los
tama&ntilde;os de la forma <i>64 Megabytes = 64M</i> y <i>2 Gigabytes =
2G</i>.  Disklabel los redondear&aacute; hasta el cilindro m&aacute;s
cercano.  Tambi&eacute;n notar&aacute; en el ejemplo anterior que
disklabel asume que la clasificaci&oacute;n '<b>b</b>' ser&aacute;
<i>swap</i>.  Esto es correcto ya que el n&uacute;cleo del sistema
GENERIC est&aacute; configurado para buscar <i>swap</i> en la
clasificaci&oacute;n <b>b</b>, y todo lo que usted debe hacer es seguir
esta gu&iacute;a y usar <b>b</b> como su &aacute;rea de <i>swap</i>.
</p>

<p>
El siguiente ejemplo le guiar&aacute; por la creaci&oacute;n de dos
clasificaciones m&aacute;s.  Esto quiere decir que no es una
instalaci&oacute;n completa, ya que el tama&ntilde;o de &eacute;stas no
ser&aacute; suficiente para instalar OpenBSD al completo.  Mostrar otra
vez la creaci&oacute;n de todas las particiones ser&iacute;a
redundante.

<ul>
<pre>
&gt; <strong>a d</strong>
offset: [262143] <strong>&lt;Intro&gt;</strong>
size: [16124157] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Intro&gt;</strong>
mount point: [none] <strong>/tmp</strong>
fragment size: [1024] <strong>&lt;Intro&gt;</strong>
block size: [8192] <strong>&lt;Intro&gt;</strong>
cpg: [16] <strong>&lt;Intro&gt;</strong>
&gt; <strong>a e</strong>
offset: [393183] <strong>&lt;Intro&gt;</strong>
size: [15993117] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Intro&gt;</strong>
mount point: [none] <strong>/var</strong>
fragment size: [1024] <strong>&lt;Intro&gt;</strong>
block size: [8192] <strong>&lt;Intro&gt;</strong>
cpg: [16] <strong>&lt;Intro&gt;</strong>
</pre>
</ul>
</p>

<p>
En este ejemplo puede notar dos diferencias con el anterior.  Una, que
el inicio del sector (&quot;offset&quot;) lo averigua de forma
autom&aacute;tica.  Cuando haga una instalaci&oacute;n de este tipo no
tendr&aacute; que configurar los sectores.  Otra diferencia es que la
clasificaci&oacute;n '<b>c</b>' representa a todo el disco.  Por este
motivo no debe tocar la clasificaci&oacute;n <b>c</b>.
</p>

<p>
Una vez que todas las clasificaciones hayan sido creadas, todo lo
quedar&aacute; por hacer ser&aacute; grabarlas en el disco y pasar al
proceso de instalaci&oacute;n.  Para grabarlo todo y salir de disklabel
(y continuar con la instalaci&oacute;n), haga lo siguiente:

<ul>
<pre>
&gt; <strong>w</strong>
&gt; <strong>q</strong>
</pre>
</ul>
</p>

<p>
<strong>*NOTA*</strong> - Para usuarios con discos grandes.  Si la BIOS
de su equipo no tiene soporte para el tama&ntilde;o de su disco,
OpenBSD tampoco tendr&aacute; soporte para &eacute;ste.  En cualquier
otro caso OpenBSD deber&iacute;a ser capaz de tratar su disco sin
problema alguno.  Si se encuentra en una situaci&oacute;n en la que la
BIOS de su m&aacute;quina no dispone de soporte para su disco, puede
probar Maxtor EZ-Drive u otro producto complementario de similares
caracter&iacute;sticas.
</p>

<p>
<a name="14.1.3"></a>
<h3>Uso general de disklabel(8)</h3>

<p>
Una vez que est&eacute; instalado el sistema, el uso frecuente de
disklabel no deber&iacute;a ser necesario.  Pero a veces tendr&aacute;
que usarlo cuando a&ntilde;ada, elimine, o reestructure sus discos.
Una de las primeras cosas que tendr&aacute; que hacer ser&aacute; ver
su disklabel actual.  Para ello, escriba lo siguiente:

<ul>
<pre>
# <strong>disklabel wd0</strong> <small>&lt;----- O cualquier dispositivo de disco que quiera ver</small>

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>
</ul>
</p>

<p>
La orden anterior le permite ver el disklabel presente, y de este modo
asegurarse de que no l&iacute;a nada (algo que todos necesitamos
algunas veces).  Pero para poder hacer cambios debe usar disklabel con
la opci&oacute;n -E, de este modo:

<ul>
<pre>
# <strong>disklabel -E wd0</strong>
</pre>
</ul>
</p>

<p>
Esto le llevar&aacute; hasta un &laquo;punto de pedido&raquo;
(&quot;prompt&quot;), el mismo que us&oacute; durante la
instalaci&oacute;n de OpenBSD.  Probablemente, la orden m&aacute;s
importante de todas en este punto de pedido sea '?'.  Con esta orden
obtendr&aacute; una lista de posibles opciones relacionadas con
disklabel.  Incluso podr&aacute; ver la p&aacute;gina de manual de
disklabel(8) al completo con la orden 'M'.  Desde este punto
podr&aacute; a&ntilde;adir o eliminar todo lo que desee, o hacer
cambios en las particiones.  Para m&aacute;s informaci&oacute;n al
respecto lea la p&aacute;gina de manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>.
</p>


<p>
<a name="14.2"></a>
<h2>14.2 - C&oacute;mo usar fdisk</h2>

<p>
Antes que nada, aseg&uacute;rese de leer la p&aacute;gina de manual
principal de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
</p>

<p>
Fdisk es un programa de ayuda para el mantenimiento de sus particiones.
Este programa se usa durante la instalaci&oacute;n para configurar la
partici&oacute;n de OpenBSD (esta partici&oacute;n puede contener
<u>varias</u> clasificaciones, cada una de ellas con sistemas de
archivo, <i>swap</i>, etc... ).  Puede dividir el espacio de sus
dispositivos y activar uno de ellos.  Fdisk se suele usar en
&laquo;Modo Monousuario&raquo; (<b>boot -s</b> - &quot;Single User
Mode&quot;).  Fdisk tambi&eacute;n configura el MBR de los discos.
</p>

<p>
Para la instalaci&oacute;n, la mayor&iacute;a de las veces s&oacute;lo
necesitar&aacute; <b>UNA</b> partici&oacute;n de OpenBSD, y a
continuaci&oacute;n usar disklabel para poner en ella una <i>swap</i> y
un sistema de archivo.
</p>

<p>
Para ver s&oacute;lo su tabla de particiones con fdisk, haga lo
siguiente:

<ul>
<pre>
# <strong>fdisk fd0</strong>
</pre>
</ul>
</p>

<p>
lo que le dar&aacute; una salida parecida a &eacute;sta:

<ul>
<pre>
         Disk: fd0       geometry: 80/2/18 [2880 sectors]
         Offset: 0       Signatures: 0xAA55,0x0
                  Starting        Ending
          #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
----------------------------------------------------------------------
         *0: A6    0   0   1 -   79   1  18 [         0 -       2880] OpenBSD
          1: 00    0   0   0 -    0   0   0 [         0 -          0] unused
          2: A7    0   0   2 -   79   1  18 [         1 -       2879] NEXTSTEP
          3: 00    0   0   0 -    0   0   0 [         0 -          0] unused
</pre>
</ul>
</p>

<p>
En este ejemplo estamos viendo la salida de fdisk para el dispositivo
de la disquetera.  Podemos ver la partici&oacute;n de OpenBSD (A6) y su
tama&ntilde;o.  El asterisco (*) nos indica que la partici&oacute;n de
OpenBSD es una partici&oacute;n de arranque.
</p>

<p>
En el ejemplo anterior s&oacute;lo vimos nuestra informaci&oacute;n.
&iquest;Y si quisi&eacute;ramos editar nuestra tabla de particiones?
Pues bien, para ello debemos usar el indicador <b>-e</b>, que nos
trasladar&aacute; a una l&iacute;nea de &oacute;rdenes desde la que
podremos interaccionar con fdisk.

<ul>
<pre>
# <strong>fdisk -e wd0</strong>
Enter 'help' for information
fdisk: 1&gt; <strong>help</strong>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>
</ul>

<p> 
Entrar en fdisk y explorar el disco es totalmente seguro, s&oacute;lo
debe asegurarse de contestar <strong>N</strong> cuando le pregunte si
quiere guardar los cambios, y de que NO usa la orden
<strong>write</strong>.
</p>

<p>
Aqu&iacute; tiene una revisi&oacute;n de las &oacute;rdenes que puede
usar cuando escoja el indicador <b>-e</b>.

<ul>
   <li><strong>help</strong> Mostrar una lista de las &oacute;rdenes
       comprensibles para fdisk en el modo de edici&oacute;n
       interactiva.</li>
   <li><strong>reinit</strong> Iniciar la copia residente en memoria
       del bloque de arranque seleccionado.</li>
   <li><strong>disk</strong> Mostrar la geometr&iacute;a del
       dispositivo que haya verificado fdisk.  Si lo desea, puede
       editarla para aplicarle cambios.</li>
   <li><strong>edit</strong> Editar una cierta entrada en la tabla en
       la copia residente en memoria del bloque de arranque actual.
       Puede editarla en modo de geometr&iacute;a de la BIOS o en modo
       de sectores de inicio y tama&ntilde;os.</li>
   <li><strong>flag</strong> Activar una cierta entrada en la tabla de
       particiones como partici&oacute;n de arranque.  Solamente se
       puede marcar una entrada como partici&oacute;n de arranque.  Si
       quiere arrancar desde una partici&oacute;n extendida,
       tendr&aacute; que marcar la entrada de la partici&oacute;n en la
       tabla como partici&oacute;n de arranque.</li>
   <li><strong>update</strong> Actualizar el c&oacute;digo de la
       m&aacute;quina en la copia residente en memoria del bloque de
       arranque seleccionado.</li>
   <li><strong>select</strong> Seleccionar y cargar en memoria el
       bloque de arranque que se&ntilde;ala a la entrada en la tabla de
       particiones extendidas del bloque de arranque actual.</li>
   <li><strong>print</strong> Mostrar en pantalla la copia residente en 
       memoria del bloque de arranque seleccionado y su tabla MBR.</li>
   <li><strong>write</strong> Grabar la copia residente en memoria del
       bloque de arranque al disco.  Le pedir&aacute; que confirme esta
       operaci&oacute;n.</li>
   <li><strong>exit</strong> Salir del nivel actual de fdisk, volviendo
       al bloque de arranque residente en memoria previamente
       seleccionado, o saliendo completamente del programa si no
       hubiera ninguno.</li>
   <li><strong>quit</strong> Salir del nivel actual de fdisk, volviendo
       al bloque de arranque residente en memoria previamente
       seleccionado, o saliendo completamente del programa si no
       hubiera ninguno.  A diferencia de <strong>exit</strong>, no
       guarda los cambios del bloque modificado.</li>
   <li><strong>abort</strong> Salir del programa sin guardar
       cambios.</li>
</ul>
</p>

<p>
<a name="14.3"></a>
<h2>14.3 - C&oacute;mo a&ntilde;adir discos adicionales</h2>

<p>
Una vez que ya tenga su disco instalado <strong>CORRECTAMENTE</strong>,
deber&aacute; usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a> (<em>s&oacute;lo i386</em>) y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&apropos=0&sektion=8&format=html">disklabel(8)</a>
para configurarlo en OpenBSD.

<p>
Los usuarios de plataformas i386 deben empezar con fdisk.
El resto de plataformas pueden ignorar esta parte.

<ul>
<pre>
# <strong>fdisk -i sd2</strong>
</pre>
</ul>

<p>
De este modo se iniciar&aacute; la tabla de particiones
&laquo;real&raquo; para su uso exclusivo por OpenBSD.  A
continuaci&oacute;n debe crear un disklabel.  Esto le parecer&aacute;
algo confuso.

<ul>
<pre>
# <strong>disklabel -e sd2</strong>

<small><i>(la pantalla se queda en blanco y aparece su $EDITOR)</i></small>
type: SCSI
<small><i>...bla...</i></small>
sectors/track: 63
total sectors: 6185088
<small><i>...bla...</i></small>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>
</ul>

<p>
Ignore la partici&oacute;n <b>c</b>, siempre est&aacute; ah&iacute; y
es para que funcionen programas como disklabel.  Para operaciones
normales, <i>fsize</i> siempre debe ser 1024, <i>bsize</i> siempre debe
ser 8192, y <i>cpg</i> siempre debe ser 16.  <i>fstype</i> es 4.2BSD.
<i>total sectors</i> es el tama&ntilde;o total del disco.  Supongamos
que &eacute;ste es un disco de 3GB;  tres gigabytes, en t&eacute;rminos
del fabricante del disco, son 3000 megabytes.  Divida 6185088 entre
3000 (use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&bc&apropos=0&sektion=1&manpath=OpenBSD+Current&format=html">bc(1)</a>)
y obtendr&aacute; 2061.  Por lo tanto, para crear particiones para a,
d, e, f, g, ... simplemente multiplique X*2061 y obtendr&aacute; el
n&uacute;mero de megabytes de espacio en esa partici&oacute;n.  El
sector de inicio (&quot;<i>offset</i>&quot;) para su primera
partici&oacute;n nueva debe ser el mismo que el
&quot;<i>sectors/track</i>&quot; que le haya dado anteriormente la
salida de disklabel.  En este caso es 63.  El sector de inicio para
cada partici&oacute;n consecutiva debe ser una combinaci&oacute;n del
tama&ntilde;o de cada partici&oacute;n y el sector de inicio de la
misma (excepto la partici&oacute;n <b>c</b>, ya que no juega
ning&uacute;n papel aqu&iacute;).
</p>

<p>
O, si s&oacute;lo quiere tener una partici&oacute;n en el disco (si,
por ejemplo, quisiera usarlo todo para almacenaje de web o como
directorio home), tome el tama&ntilde;o total del disco y
r&eacute;stele los sectores por pista (&quot;sectors/track&quot;).  En
este caso, 6185088-63 = 6185025.  La partici&oacute;n quedar&aacute;
as&iacute;:

<ul>
<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>
</ul>
</p>

<p>
<b>&iexcl;Si todo esto le parece complicado e innecesario, puede usar
disklabel -E para obtener el mismo modo de particiones que tiene en su
disco de instalaci&oacute;n!</b> Ah&iacute; puede usar
&laquo;96M&raquo; para especificar &laquo;96 megabytes&raquo; (o con un
disco lo bastante grande, 96G para 96 gigabytes).  Desafortunadamente,
el modo -E usa la geometr&iacute;a del disco de la BIOS, no la
geometr&iacute;a del disco real, y con frecuencia &eacute;stas no son
las mismas.  Para evitar esta limitaci&oacute;n, escriba 'g d' para la
'geometr&iacute;a del disco'.  Otras opciones son 'g b' para la
'geometr&iacute;a de la bios' y 'g u' para la 'geometr&iacute;a del
usuario', o simplemente lo que indique la
&laquo;clasificaci&oacute;n&raquo; (<i>label</i>) antes de que
disklabel efect&uacute;e alg&uacute;n cambio.
</p>

<p>
Esto ha sido largo, pero todav&iacute;a no ha terminado.  Para
finalizar, debe crear el sistema de archivo en el disco usando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&apropos=0&sektion=8&format=html">newfs(8)</a>.

<ul>
<pre>
bsd# <strong>newfs wd1a</strong>
</pre>
</ul>
</p>

<p>
O cualquiera otra denominaci&oacute;n de su disco de acuerdo con el
esquema de numeraci&oacute;n del disco de OpenBSD (mire la salida de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&apropos=0&sektion=0&manpath=OpenBSD+Current&format=html">dmesg(8)</a> 
para averiguar el nombre que OpenBSD da a su disco).
</p>

<p>
Ahora debe decidir d&oacute;nde va a montar la nueva partici&oacute;n
que acaba de crear.  Digamos que quiere ponerla en /u.  Primero cree el
directorio /u, y luego m&oacute;ntelo.

<ul>
<pre>
mount /dev/wd1a /u
</pre>
</ul>
</p>

<p>
Finalmente, a&ntilde;&aacute;dalo a /etc/fstab

<ul>
<pre>
/dev/wd1a /u ffs rw 1 1
</pre>
</ul>
</p>

<p>
&iexcl;Y si necesitara migrar a un directorio ya existente como
/usr/local?  Entonces deber&iacute;a montar la partici&oacute;n nueva
en /mnt, y usar 'cpio -pdum' para copiar /usr/local al directorio /mnt.
A continuaci&oacute;n editar el fichero /etc/fstab para indicar que la
partici&oacute;n /usr/local es ahora /dev/wd1a (su partici&oacute;n
reci&eacute;n creada).  Por ejemplo:

<ul>
<strong>/dev/wd1a /usr/local ffs rw 1 1</strong>
</ul>
</p>

<p>
Reinicie en modo monousuario... <strong>boot -s</strong> y copie el
/usr/local existente a /usrs/local-backup (eliminando el original
cuando est&eacute; seguro), y cree un directorio /usr/local
vac&iacute;o.  Reinicie el sistema y &iexcl;ya est&aacute;!
&iexcl;ah&iacute; est&aacute;n los ficheros!
</p>


<p>
<a name="14.4"></a>
<h2>14.4 - C&oacute;mo usar un fichero como memoria de <i>swap</i></h2>

<p>
(Nota: si lo que quiere es usar un fichero como memoria de intercambio
(<i>&quot;swap&quot;</i>) porque obtiene errores del tipo &quot;virtual
memory exhausted&quot;, deber&iacute;a intentar antes elevar los
l&iacute;mites por proceso con la utilidad de csh
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&sektion=1&format=html">unlimit(1)</a>,
o de sh
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&sektion=1&format=html">ulimit(1)</a>)
</p>

<p>
Despu&eacute;s de la versi&oacute;n oficial de OpenBSD 2.5
apareci&oacute;
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a>,
con el que es mucho m&aacute;s f&aacute;cil tratar con dispositivos de
<i>swap</i>.  Si est&aacute; usando la versi&oacute;n 2.5 de OpenBSD,
intercambie swapctl por swapon, y use pstart -s para ver una lista de
dispositivos de <i>swap</i>.  El uso de ficheros como memoria de
<i>swap</i> no requiere la compilaci&oacute;n de un n&uacute;cleo del
sistema personalizado, aunque aqu&iacute; explicaremos c&oacute;mo
hacerlo de las dos maneras.
</p>

<p>
<h3>Usar un fichero como <i>swap</i></h3>

<p>
Usar un fichero como memoria de <i>swap</i> es la forma m&aacute;s
f&aacute;cil y r&aacute;pida de obtener una configuraci&oacute;n
adicional del &aacute;rea de <i>swap</i>.  Esto no es para los usuarios
que usen &quot;Softupdates&quot; (que viene desactivado por
definici&oacute;n).  Para empezar, puede ver cu&aacute;nta memoria de
<i>swap</i> tiene en ese momento y cu&aacute;nta est&aacute; usando con
la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a>,
del modo siguiente:

<ul>
<pre>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>
</ul>
</p>

<p>
Esto le mostrar&aacute; los dispositivos que est&aacute;n siendo usados
como memoria de <i>swap</i> y sus estad&iacute;sticas actuales.  En el
ejemplo anterior, s&oacute;lo hay un dispositivo denominado
&quot;swap_device&quot;.  &Eacute;ste es el &aacute;rea predefinida
para <i>swap</i> (si lo vi&eacute;ramos con disklabel, lo
mostrar&iacute;a como la partici&oacute;n b).  Tambi&eacute;n puede ver
en el ejemplo anterior que el dispositivo no est&aacute; siendo muy
usado en ese momento.  Pero para el prop&oacute;sito de este documento,
procederemos como si necesit&aacute;ramos 32MB adicionales.
</p>

<p>
El primer paso para configurar un fichero como un dispositivo de
<i>swap</i> es crear el fichero.  El mejor modo de hacerlo es con la
utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&sektion=1&format=html">dd(1)</a>.
He aqu&iacute; un ejemplo de c&oacute;mo crear el fichero
<i>/var/swap</i>, que tendr&aacute; un tama&ntilde;o de 32MB.

<ul>
<pre>
ericj@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>
</ul>
</p>

<p>
Una vez que lo hayamos creado, podemos activar el uso de ese
dispositivo como memoria de <i>swap</i>.  Para activarlo, use la
siguiente orden:

<ul>
<pre>
ericj@oshibana&gt; <strong>sudo chmod 600 /var/swap</strong>
ericj@oshibana&gt; <strong>sudo swapctl -a /var/swap</strong>
</pre>
</ul>
</p>

<p>
Ahora debemos comprobar si se ha a&ntilde;adido correctamente a la
lista de nuestros dispositivos de <i>swap</i>.

<ul>
<pre>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>
</ul>
</p>

<p>
Ahora que ya est&aacute; activado el fichero y que se est&aacute;
usando como <i>swap</i>, debe a&ntilde;adir una l&iacute;nea a su
fichero <i>/etc/fstab</i>, para que el fichero tambi&eacute;n se active
en el pr&oacute;ximo arranque.  Si no a&ntilde;ade esta l&iacute;nea,
no tendr&aacute; este dispositivo de <i>swap</i> configurado.

<ul>
<pre>
ericj@oshibana&gt; <strong>cat /etc/fstab</strong>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>
</ul>
</p>

<p>
<h3>Usar <em>swap</em> a trav&eacute;s de un dispositivo vnode</h3>

<p>
&Eacute;sta es una soluci&oacute;n m&aacute;s permanente que la de
a&ntilde;adir m&aacute;s espacio de <i>swap</i>.  Para usar
permanentemente un fichero como memoria de <i>swap</i>, primero compile
un n&uacute;cleo con vnd0c como <i>swap</i>.  Si su sistema de archivo
ra&iacute;z es wd0a, entonces wd0b es el <i>swap</i> anterior y debe
usar la siguiente l&iacute;nea en el fichero de configuraci&oacute;n
del n&uacute;cleo (si tiene dudas, lea el
<a href="faq5.html">cap&iacute;tulo 5</a> de las preguntas frecuentes
referente a la compilaci&oacute;n del n&uacute;cleo del sistema):

<ul>
<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>
</ul>
</p>

<p>
Despu&eacute;s de esto, tendr&aacute; que crear el fichero que se
usar&aacute; como memoria de <i>swap</i>.  Debe hacerlo usando la misma
orden que en los ejemplos anteriores.

<ul>
<pre>
ericj@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>
</ul>
</p>

<p>
Ahora el fichero est&aacute; en su sitio y debe a&ntilde;adirlo a
<i>/etc/fstab</i>.  Aqu&iacute; tiene una l&iacute;nea de ejemplo de
c&oacute;mo arrancar con este dispositivo como <i>swap</i>.

<ul>
<pre>
ericj@oshibana&gt; <strong>cat /etc/fstab</strong>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>
</ul>
</p>

<p>
En este punto su m&aacute;quina debe ser reiniciada para que los
cambios en el n&uacute;cleo hagan efecto.  A continuaci&oacute;n
deber&aacute; configurar el dispositivo como memoria de <i>swap</i>.
Para ello usar&aacute;
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8&format=html">vnconfig(8)</a>.

<ul>
<pre>
ericj@oshibana&gt; <strong>sudo vnconfig -c -v vnd0 /var/swap</strong>
vnd0: 33554432 bytes on /var/swap
</pre>
</ul>
</p>

<p>
El &uacute;ltimo paso es activar ese dispositivo como memoria de
<i>swap</i>.  Lo haremos como en los ejemplos anteriores, usando
swapctl(8).  Despu&eacute;s comprobaremos si ha sido correctamente
a&ntilde;adido a nuestra lista de dispositivos de <i>swap</i>.

<ul>
<pre>
ericj@oshibana&gt; <strong>sudo swapctl -a /dev/vnd0c</strong>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>
</ul>
</p>


<p>
<a name="14.5"></a>
<h2>14.5 - Softupdates</h2>
</p>

<p>
Durante los &uacute;ltimos a&ntilde;os, Kirk McKusick ha estado
trabajando en algo llamado &quot;soft updates&quot;.  Esto se basa en
la idea propuesta por Greg Ganger y Yale Patt de imponer un orden
parcial sobre las operaciones en la memoria intermedia para permitir
que los requerimientos de escritura sincr&oacute;nica de entradas de
directorio sean eliminadas del c&oacute;digo FFS.  En resumen, un gran
incremento en el rendimiento de la escritura en disco.
</p>

<p>
Para activar &quot;Softupdates&quot;, el n&uacute;cleo debe tener
configurada la opci&oacute;n<br> <b>NOTA:</b>  Esta opci&oacute;n
est&aacute; activada por definici&oacute;n a partir de la
versi&oacute;n 2.7 de OpenBSD, y vendr&aacute; predefinida en la
versi&oacute;n 2.8.  Sin embargo, debe activarla para cada
partici&oacute;n de disco.

<p>
<strong>option FFS_SOFTUPDATES</strong>
</p>

<p>
y debe arrancar en modo monousuario:

<ul>
<pre>
<strong>
        boot&gt; boot -s
        [snip]
        bsd# tunefs -s enable &lt;raw device&gt;
        bsd# reboot -n
</strong>
</pre>
</ul>
</p>

<p>
<a name="14.6"></a>
<h2>14.6 -  Cuando arranco el sistema despu&eacute;s de la
instalaci&oacute;n de OpenBSD/i386, se para en &quot;Using partition 3
id 0&quot;</h2>

<p>
Esto significa que su &laquo;Registro de Arranque Maestro&raquo; (MBR,
<i>&quot;Master Boot Record&quot;</i>) no ha sido instalado
correctamente, o que la idea que su BIOS tiene sobre la
geometr&iacute;a del disco duro no es compatible con su MBR.  Para
solventarlo, primero intente reinstalar los bloques de arranque de
OpenBSD.  Para ello use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&sektion=8&arch=i386&format=html">installboot(8)</a>.
Para que arranque y funcione la primera vez, necesitar&aacute; usar el
disco de arranque (<i>&quot;boot disk&quot;</i>) como mecanismo de
arranque.  Despu&eacute;s de insertar el disco de instalaci&oacute;n, y
antes de que cargue el n&uacute;cleo y el &quot;ramdisk&quot;,
ver&aacute; un punto de pedido <tt>boot&gt;</tt> desde el disquete.
&Uacute;selo para iniciar OpenBSD fuera de su disco duro.

<ul>
<pre>
booting...
OpenBSD boot 1.2.3
probing hd0 fd0...
boot&gt; <b>boot hd0a:/bsd</b>
</pre>
</ul>
</p>

<p>
Ahora que ya ha iniciado, y asumiendo que haya dedicado todo su disco
duro a OpenBSD, reinicie el MBR con fdisk(8) (de todos modos, si tiene
particiones para otros sistemas operativos en su disco duro, no
podr&aacute; usar <tt>installboot</tt>;  tendr&aacute; que buscar otra
opci&oacute;n como OS-BS, que se describe m&aacute;s adelante).

<ul>
<pre>
# <b>fdisk -i wd0</b>
</pre>
</ul>
</p>

<p>
Ahora debe reescribir los bloques de arranque.

<ul>
<pre>
# <strong>cp /usr/mdec/boot /boot</strong>
# <strong>/usr/mdec/installboot -v /boot /usr/mdec/biosboot wd0</strong>
</pre>
</ul>
</p>

<p>
Para acabar, reinicie y pru&eacute;belo.
</p>

<p>
Si no funcionara, todav&iacute;a tendr&iacute;a unas pocas opciones
adicionales.  La primera ser&iacute;a usar un gestor de arranque como
OS-BS.  El CD de OpenBSD incluye el gestor de arranque OS-BS en el
directorio <i>tools</i>.  Si no ha adquirido el CD-ROM, puede obtener
OS-BS desde cualquiera de los servidores de ftp de OpenBSD.  Debe
bajarse el fichero <i>pub/OpenBSD/2.8/tools/osbs135.exe</i>
</p>

<p>
T&oacute;mese algo de tiempo para leer las p&aacute;ginas en internet
de OS-BS, que se encuentran en
<a href="http://www.prz.tu-berlin.de/~wolf/os-bs.html">http://www.prz.tu-berlin.de/~wolf/os-bs.html</a>
</p>

<p>
Existen otros gestores de arranque comerciales, o libres como lilo, que
puede usar para un arranque m&uacute;ltiple.
</p>

<p>
Aqu&iacute; tiene una breve gu&iacute;a para poner lilo en su sistema.

<ul>
<li>Inicie un disquete de DOS y haga <tt>fdisk /MBR</tt>.
    Aseg&uacute;rese de hacerlo desde el dispositivo con el que vaya
    arrancar.</li>
<li>Inicie desde un disco de linux e instale LILO y m&eacute;talo en la
    cadena de su bloque de arranque de OpenBSD.</li>
</ul>
</p>

<p>
Para m&aacute;s instrucciones, lea 
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/2.8/i386/INSTALL.linux">INSTALL.linux</a>
</p>


<p>
<a name="14.7"></a>
<h2>14.7 - &iquest;C&oacute;mo obtento un dmesg de un disquete de
arranque?</h2>

<p>
Las im&aacute;genes de RAMDISK (disquetes de arranque) no incluyen la
utilidad <code>dmesg</code>.  Sin embargo, tienen el sistema de archivo
<i>/kern</i> montado.  Para copiar la informaci&oacute;n de dmesg a un
fichero, haga lo siguiente:

<ul>
<pre>
# <strong>cat /kern/msgbuf &gt;mydmesg</strong>
</pre>
</ul>
</p>

<p>
Los discos de arranque tambi&eacute;n incluyen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=more&apropos=0&sektion=0&manpath=OpenBSD+Current&format=html">more(1)</a>
como paginador:

<pre>
<ul>
# <strong>more /kern/msgbuf</strong>
</pre>
</ul>
</p>

<p>
Lea tambi&eacute;n la <a href="faq4.html#4.5">secci&oacute;n 4.5</a> de
estas preguntas frecuentes.

<p>
<a name="14.8"></a>
<h2>14.8 - Instalaci&oacute;n de bloques de arranque
(espec&iacute;fico de i386)</h2>

<p>
Las versiones m&aacute;s antiguas de MS-DOS s&oacute;lo pod&iacute;an
reconocer geomtr&iacute;as de disco de 1024 cilindros o menos.  Ya que
casi pr&aacute;cticamente todos los discos modernos tienen m&aacute;s
de 1024 cilindros, la mayor&iacute;a de chips de BIOS SCSI (que vienen
integrados en la tarjeta controladora SCSI) y de BIOS IDE (que son
parte del resto de la BIOS para PCs) disponen de una opci&oacute;n
(algunas veces preactivada) para &laquo;traducir&raquo; la
geometr&iacute;a real del disco en algo que est&eacute; dentro de los
l&iacute;mites de la capacidad de MS-DOS.  Sin embargo, no todos los
chips de BIOS &laquo;traducen&raquo; la geometr&iacute;a del mismo
modo.  Si cambia su BIOS (instalando una nueva placa base o
a&ntilde;adiendo una nueva controladora SCSI) y la nueva usa una
&laquo;traducci&oacute;n&raquo; de la geometr&iacute;a diferente, no
podr&aacute; cargar la segunda fase del gestor de arranque (y por lo
tanto no podr&aacute; cargar el n&uacute;cleo).  Esto se debe a que la
primera fase del gestor de arranque contiene una lista de bloques que
comprende <i>/boot</i> en t&eacute;rminos de la geometr&iacute;a
&laquo;traducida&raquo; original.  Si est&aacute; usando discos IDE y
realiza cambios en la configuraci&oacute;n de su BIOS, tambi&eacute;n
puede cambiar sin saberlo su traducci&oacute;n (la mayor&iacute;a de
BIOS IDE ofrecen 3 traducciones diferentes).  Para que su bloque de
arranque pueda iniciar con normalidad, ponga un disquete de arranque, y
en el punto <kbd>boot&gt;</kbd> escriba <kbd>b hd0a:/bsd</kbd> para
forzar el arranque desde el primer disco duro (y no desde el disquete).
Su m&aacute;quina deber&iacute;a iniciar sin ning&uacute;n problema.
Ahora debe actualizar la primera fase del gestor de arranque para poder
ver la nueva geometr&iacute;a (y reescribir el bloque de arranque de
acuerdo con ella).
<br>
En el ejemplo se asume que su disco de arranque es sd0 (SCSI, pero si
fuera IDE ser&iacute;a wd0, etc... ):

<ul>
<pre>
# <strong>cd /usr/mdec; ./installboot /boot biosboot sd0</strong>
</pre>
</ul>
</p>

<p>
Si installboot protesta porque es incapaz de leer la geometr&iacute;a
de la BIOS, puede invocar la orden 'machine diskinfo' (o su forma
abreviada, 'ma di') desde el punto <kbd>boot&gt;</kbd>, para ver la
informaci&oacute;n que necesite.  Rellene con los valores
&quot;heads&quot; y &quot;secs&quot; los indicadores <code>-h</code> y
<code>-s</code> de installboot respectivamente, para que la orden
modificada de installboot quede como sigue:

<ul>
<pre>
#<strong> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</strong>
</pre>
</ul>
</p>

<p>
Si se requiriera una versi&oacute;n de los bloques de arranque,
tendr&iacute;a que compilarlos usted mismo.

<ul>
<pre>
# <strong>cd /sys/arch/i386/stand/</strong>
# <strong>make &amp;&amp; make install </strong>
# <strong>cd /usr/mdec; cp ./boot /boot</strong>
# <strong>./installboot /boot biosboot sd0</strong> <small>(o cualquier otro 
dispositivo que sea su disco)</small>
</pre>
</ul>
</p>

<p>
<a name="14.9"></a>
<h2>14.9 - Prepararse para el desastre: hacer copias de seguridad
(respaldo) y restaurar desde la cinta</h2>

<p>
<h3>Introducci&oacute;n:</h3>

<p>
Si su instalaci&oacute;n de OpenBSD va a ser lo que se llama un
servidor de producci&oacute;n, es aconsejable disponer de alg&uacute;n
tipo de respaldo por si acaso uno de sus discos fijos fallara.
</p>

<p>
Esta informaci&oacute;n le ayudar&aacute; a usar las utilidades
t&iacute;picas
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a>
disponibles con OpenBSD.  Existe una utilidad para copias de seguridad
m&aacute;s avanzada, llamada &quot;Amanda&quot;, con la que se pueden
hacer copias de seguridad de m&uacute;ltiples servidores en una sola
cinta.  En la mayor&iacute;a de entornos,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a>/<a href=http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a>
es suficiente.  Sin embargo, si necesita hacer copias de seguridad de
m&uacute;ltiples m&aacute;quinas en una sola cinta, vale la pena que
conozca Amanda.
</p>

<p>
Los dispositivos de ejemplo en este documento son para una
configuraci&oacute;n que usa discos y cintas SCSI.  En un entorno de
producci&oacute;n, se recomiendan los discos SCSI sobre los IDE debido
al modo que gestionan los bloques err&oacute;neos, lo que no significa
que esta informaci&oacute;n sea in&uacute;til si est&aacute; usando un
disco IDE u otro tipo de cinta;  en este caso los nombres de sus
dispositivos ser&aacute;n ligeramente diferentes.  Por ejemplo, sd0a
ser&iacute;a wd0a en un sistema basado en IDE.
</p>

<p>
<h3>Hacer copias en cinta</h3>

<p>
Para hacer copias en una cinta es necesario saber de antemano
d&oacute;nde est&aacute;n montados los sistemas de archivo.  Esto se
puede determinar usando la orden <kbd>mount</kbd> desde el punto de
pedido de la shell.  Deber&iacute;a obtener una salida similar a
&eacute;sta:

<ul>
<pre>
shell# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>
</ul>
</p>

<p>
En este ejemplo, el sistema de archivo ra&iacute;z (/) reside
f&iacute;sicamente en sd0a, lo que indica que es la partici&oacute;n a
del disco fijo SCSI 0.  El sistema de archivo /usr reside en sd0h, lo
que indica que es la partici&oacute;n h del disco fijo SCSI 0.
</p>

<p>
Otro ejemplo de una tabla de puntos de montaje m&aacute;s avanzado
ser&iacute;a:

<ul>
<pre>
shell# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>
</ul>
</p>

<p>
En este ejemplo, el sistema de archivo ra&iacute;z reside
f&iacute;sicamente en sd0a, el sistema de archivo <i>/var</i> reside en
sd0d, el sistema de archivo <i>/home</i> en sd0e y finalmente,
<i>/usr</i> en sd0h.
</p>

<p>
Para hacer copias de seguridad de su m&aacute;quina necesitar&aacute;
pasar informaci&oacute;n a dump sobre el nombre de cada
partici&oacute;n del disco fijo.  Aqu&iacute; tiene un ejemplo de las
&oacute;rdenes que se necesitan para hacer copias de la primera tabla
de montaje (la m&aacute;s simple):

<ul>
<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>
</ul>
</p>

<p>
Para la segunda tabla (la m&aacute;s avanzada), usar&iacute;a algo
parecido a esto:

<ul>
<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>
</ul>
</p>

<p>
Puede revisar la p&aacute;gina de manual de dump para averiguar
qu&eacute; es lo que hace exactamente cada uno de los par&aacute;metros
en la l&iacute;nea de &oacute;rdenes.  Aqu&iacute; tiene una breve
descripci&oacute;n de los par&aacute;metros
usados:

<ul>
   <li><b>0</b> - Lleva a cabo un nivel 0 de dump, lo coge todo.
   <li><b>a</b> - Intenta determinar autom&aacute;ticamente el
       tama&ntilde;o de la cinta.
   <li><b>u</b> - Actualiza el fichero <i>/etc/dumpdates</i> para
       indicar cu&aacute;ndo se realiz&oacute; la &uacute;ltima copia
       de seguridad.
   <li><b>f</b> - Indica qu&eacute; dispositivo de cinta se
       usar&aacute; (en este caso <i>/dev/nrst0</i>).
</ul>
</p>

<p>
La &uacute;ltima parte indica la partici&oacute;n de la que se
har&aacute; la copia de seguridad (<i>/dev/rsd0a</i>, etc... ).
</p>

<p>
La orden mt se usa al final para rebobinar el controlador.  Revise la
p&aacute;gina de manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&apropos=0&sektion=0&manpath=OpenBSD+Current&format=html">mt(1)</a>
para ver m&aacute;s opciones (como &quot;eject&quot;).
</p>

<p>
Si no est&aacute; seguro de cu&aacute;l es el nombre de su dispositivo
de cinta, use dmesg para localizarlo.  Un ejemplo de entrada del
dispositivo de cinta en dmesg ser&aacute; parecido al siguiente:

<ul>
<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>
</ul>
</p>

<p>
Es posible que haya notado que al realizar la copia de seguridad, se
accede al controlador de la cinta con el nombre del dispositivo
&quot;nrst0&quot; en lugar de &quot;st0&quot;, que es el nombre que se
ve en dmesg.  Cuando se accede a st0 como nrst0 se est&aacute;
accediendo al mismo controlador f&iacute;sico de la cinta, pero
indicando al controlador que no debe rebobinar al final del proceso y
que acceda al dispositivo en modo virgen.  Para hacer copias de
seguridad de m&uacute;ltiples sistemas de archivo en una sola cinta,
aseg&uacute;rese de usar el dispositivo sin rebobinar;  si usa un
dispositivo de rebobinado (rst0) para hacer copias de seguridad de
m&uacute;ltiples sistemas de archivo, acabar&aacute; anulando el
sistema de archivo anterior cuando el pr&oacute;ximo dump intente
grabar en la cinta.  Puede encontrar una descripci&oacute;n m&aacute;s
elaborada sobre los distintos dispositivos de control de cinta en la
p&aacute;gina de manual de dump.
</p>

<p>
Si quiere escribir un peque&ntilde;o gui&oacute;n (<i>script</i>),
puede hacerlo como el siguiente:

<ul>
<pre>
echo &quot;  Empezando Copia de Seguridad Completa...&quot;
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n &quot;  Rebobinando el Dispositivo, por favor espere...&quot;
mt -f /dev/rst0 rewind
echo &quot;Fin.&quot;
echo                      
</pre>
</ul>
</p>

<p>
Si desea programar las copias de seguridad para que se hagan por la
noche o a cualquier otra hora, puede usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&sektion=8&format=html">cron(8)</a>
para que lance el gui&oacute;n de forma autom&aacute;tica.
</p>

<p>
Tambi&eacute;n puede serle de ayuda documentar (en un trozo de papel)
el tama&ntilde;o necesario para cada sistema de archivo.  Puede usar la
orden <kbd>df -h</kbd> para determinar cu&aacute;nto espacio
est&aacute; usando cada partici&oacute;n.  Esto le ser&aacute;
&uacute;til cuando el dispositivo falle y necesite recrear su
partici&oacute;n en el nuevo dispositivo.
</p>

<p>
Restaurar sus datos tambi&eacute;n le ayudar&aacute; a reducir la
fragmentaci&oacute;n.  Para asegurarse de que tiene todos los ficheros,
la mejor forma de hacer copias de seguridad es reiniciando el sistema
en modo monousuario.  Los sistemas de archivos no necesitan estar
montados para hacer las copias.  Despu&eacute;s de reiniciar no se
olvide de montar la partici&oacute;n ra&iacute;z (/) con permisos de
escritura (r) y lectura (w), o dump fallar&aacute; cuando intente
grabar los &quot;dumpdates&quot;.  Para iniciar en modo monousuario
haga lo siguiente desde el punto de arranque:

<ul>
<pre>
boot&gt; bsd -s
</pre>
</ul>
</p>

<p>
<h3>Ver el contenido de una copia en cinta:</h3>

<p>
Despu&eacute;s de que haya hecho las correspondientes copias de
seguridad por primera vez, es una buena idea que pruebe su cinta y que
se asegure de que los datos en ella sean los que Vd. esperaba que
fueran.
</p>

<p>
Puede usar el siguiente ejemplo para revisar un cat&aacute;logo de
ficheros en una cinta:

<ul>
<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>
</ul>
</p>

<p>
Esto har&aacute; que se muestre una lista con los ficheros existentes
en la primera partici&oacute;n de la cinta.  De acuerdo con los
ejemplos anteriores, 1 ser&iacute;a su sistema de archivo ra&iacute;z
(<i><b>/</b></i>).
</p>

<p>
Para poder ver el contenido de la segunda partici&oacute;n de la cinta y
enviar la salida a un fichero, use una orden como la siguiente:

<ul>
<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></ul>
</p>

<p>
Si tiene una tabla de particiones como la simple de ejemplos
anteriores, 2 ser&iacute;a <i>/usr</i>;  si la tabla es como la
m&aacute;s avanzada, entonces 2 podr&iacute;a ser <i>/var</i> u otro
sistema de archivo.  El n&uacute;mero de secuencia coincide con el
orden en el que se graben los sistemas de archivo en la cinta.

<p>
<h3>Restaurar desde la cinta:</h3>

<p>
El ejemplo que ver&aacute; m&aacute;s adelante podr&iacute;a ser
&uacute;til si su disco fijo fallara totalmente.  En caso de que quiera
restaurar sus sistemas de archivo desde un &uacute;nico fichero de la
cinta, revise la p&aacute;gina de manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&apropos=0&sektion=0&manpath=OpenBSD+Current&format=html">restore(8)</a>
y preste atenci&oacute;n a las instrucciones sobre el modo interactivo.
</p>

<p>
Si se ha preparado bien, substituir un disco y restaurar sus datos
desde la cinta puede ser un proceso muy r&aacute;pido.  El disquete de
instalaci&oacute;n/arranque est&aacute;ndar de OpenBSD contiene la
utilidad que se requiere para restaurar, as&iacute; como los binarios
que se requieren para particionar y hacer que pueda arrancar desde su
dispositivo.  En la mayor&iacute;a de los casos, este disquete y su
cinta con la copia de seguridad m&aacute;s reciente ser&aacute; todo lo
que necesite para restaurar el sistema.
</p>

<p>
Despu&eacute;s de substituir f&iacute;sicamente el dispositivo de disco
err&oacute;neo, los pasos b&aacute;sicos para restaurar sus datos son
los siguientes:
</p>

<ul>
<li>
Inicie desde el disquete de instalaci&oacute;n/arranque de OpenBSD.
Desde el men&uacute; de selecci&oacute;n, escoja Shell.
Prot&eacute;jalo contra la escritura e introduzca su cinta de la copia
de seguridad m&aacute;s reciente en el dispositivo.
</p>

<li>
Use la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
para crear una partici&oacute;n primaria de OpenBSD en el nuevo
dispostivo.  Por ejemplo:

<ul>
<pre>
shell# <b>fdisk -e sd0</b>
</pre>
</ul>

<p>
Revise la <a href="#14.2">secci&oacute;n 14.2</a> sobre fdisk para
m&aacute;s informaci&oacute;n.
</p>

<li>
Use la orden 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
para recrear su tabla de particiones de OpenBSD dentro de la
partici&oacute;n primaria de OpenBSD que acaba de crear con fdisk.  Por
ejemplo:

<ul>
<pre>
shell# <b>disklabel -E sd0</b>
</pre>
</ul>

<p>
No se olvide de la partici&oacute;n de <i>swap</i>.
Revise la <a href="#14.1">secci&oacute;n 14.1</a> sobre disklabel para
m&aacute;s informaci&oacute;n.
</p>

<li>
Use la orden 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&apropos=0&sektion=8&format=html">newfs(8)</a>
en cada una de las particiones que acaba de crear, para construir un
sistema de archivo limpio en cada una de ellas.  Por ejemplo:

<ul>
<pre>
shell# <b>newfs /dev/rsd0a</b>
shell# <b>newfs /dev/rsd0h</b>
</pre>
</ul>

<li>
Monte su reci&eacute;n preparado sistema de archivo ra&iacute;z (/) en
/mnt.  Por ejemplo:

<ul>
<pre>
shell# <b>mount /dev/sd0a /mnt</b>
</pre>
</ul>

<li>
Cambie a ese sistema de archivo ra&iacute;z que acaba de montar y
comience con el proceso de restauraci&oacute;n.  Por ejemplo:

<ul>
<pre>
shell# <b>cd /mnt</b>
shell# <b>restore -rs 1 -f /dev/rst0</b>
</pre>
</ul>

<li>
Como querr&aacute; poder arrancar desde este nuevo disco, haga lo
siguiente para grabar un nuevo MBR en su dispositivo:

<ul>
<pre>
shell# <b>fdisk -i sd0</b>
</pre>
</ul>

<li>
Adem&aacute;s de grabar un nuevo MBR en el controlador,
necesitar&aacute; instalar bloques de arranque para iniciar desde
&eacute;l.  A continuaci&oacute;n puede ver un breve ejemplo:

<ul>
<pre>
shell# <b>cp /usr/mdec/boot /mnt/boot</b>
shell# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>
</ul>

<li>
Su nuevo sistema de archivo ra&iacute;z en el disco fijo deber&iacute;a
estar lo suficientemente preparado como para que pueda iniciar desde
&eacute;l y continuar restaurando el resto de sus sistemas de archivo.
Como su sistema operativo todav&iacute;a no est&aacute; completo,
aseg&uacute;rese de iniciar la copia de seguridad en modo monousuario.
Desde el punto de pedido de la shell, ejecute las siguientes
&oacute;rdenes para desmontar y parar el sistema:

<ul>
<pre>
shell# <b>umount /mnt</b>
shell# <b>halt</b>
</pre>
</ul>

<li>
Elimine el disquete de instalaci&oacute;n/arranque del dispositivo y
reinicie el sistema.  Desde el punto de arranque de OpenBSD
<kbd>boot&gt;</kbd>, ejecute la siguiente orden:

<ul>
<pre>
boot&gt; <b>bsd -s</b>
</pre>
</ul>

<p>
La orden <kbd>bsd -s</kbd> har&aacute; que el n&uacute;cleo del sistema
inicie en modo monousuario, por lo que s&oacute;lo necesitar&aacute; el
sistema de archivo ra&iacute;z (<i><b>/</b></i>).
</p>

<li>
Asumiendo que ha llevado a cabo todos los pasos anteriores
correctamente y que no ha cometido ning&uacute;n error, deber&iacute;a
acabar viendo un punto en el que le pedir&aacute; que introduzca un
camino para la shell o que pulse la tecla <kbd>intro</kbd>.  Pulse
<kbd>&lt;intro&gt;</kbd> si va a usar sh.  A continuaci&oacute;n
tendr&aacute; que volver a montar el sistema de archivo ra&iacute;z en
modo de lectura (r) y escritura (w), al contrario que en modo de
s&oacute;lo lectura como hasta ahora.  Ejecute la siguiente orden:

<ul>
<pre>
shell# <b>mount -u -w /</b>
</pre>
</ul>

<li>
Una vez que lo haya vuelto a montar en modo de lectura y escritura,
puede continuar restaurando sus otros sistemas de archivo.  Por
ejemplo:

<ul>
<pre>
<small>(tabla de particiones simple)</small>
shell# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

<small>(tabla de particiones m&aacute;s avanzada)</small>
shell#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>
</ul>

<p>
Puede usar &quot;<kbd>restore rvsf</kbd>&quot; en lugar de usar
s&oacute;lo &quot;<kbd>rsf</kbd>&quot;, para ver lo nombres de los
objetos mientras los extrae de la copia de seguridad.
</p>

<li>
Por &uacute;ltimo, despu&eacute;s de que acabe de restaurar el resto de
sistemas de archivo al disco, reinicie en modo multiusuario.  Si todo
ha salido como lo ha planeado, su sistema volver&aacute; al estado en
el que se encontraba cuando realiz&oacute; la copia de seguridad, y
volver&aacute; a estar preparado para su uso.
</ul>

<p>
<a name="14.10"></a>
<h2>14.10 - Montar im&aacute;genes de disco en OpenBSD</h2>
</p>

<p>
Para montar una imagen de disco (im&aacute;genes ISO, im&aacute;genes
de disco creadas con ´dd´, etc.. ) en OpenBSD, debe configurar un
dispositivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&sektion=4">vnd(4)</a>.
Por ejemplo, si tuviera una imagen ISO ubicada en
<em>/tmp/ISO.image</em>, deber&iacute;a seguir los siguientes pasos
para montar la imagen:
</p>

<ul>
<table border="0" width="800">
        <tr>
                <td nowrap bgcolor="#eeeeee">
<pre>
# <strong>vnconfig svnd0 /tmp/ISO.image</strong>
# <strong>mount -t cd9660 /dev/svnd0c /mnt</strong>
</pre>
                </td>
        </tr>
</table>
</ul>

<p>
Note que, dado que esta imagen es una imagen de CD, debe especificar el
tipo <em>cd9660</em> al montarla.  Esto se debe aplicar a cualquier
tipo;  v.g. deber&aacute; usar el tipo <em>ffs</em> cuando monte
im&aacute;genes de disco.
</p>

<p>
Para desmontar la imagen use la siguiente orden:
</p>

<ul>
<table border="0" width="800">
        <tr>
                <td nowrap bgcolor="#eeeeee">
<pre>
# <strong>umount /mnt</strong>
# <strong>vnconfig -u svnd0</strong>
</pre>
                </td>
        </tr>
</table>
</ul>

<p>
Para m&aacute;s informaci&oacute;n mire la p&aacute;gina de manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8">vnconfig(8)</a>
</p>

<p>
<font color="#0000e0">
<a href="index.html">[Volver al &iacute;ndice principal]</a>
<a href="faq13.html">[Secci&oacute;n 13.0 - IPsec]</a>
</font>
</p>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[&iacute;ndice]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq14.html,v 1.36 2001/03/26 17:14:09 todd Exp ]<br>
$Translation: faq14.html,v 1.7 2001/04/06 16:41:15 horacio Exp $<br>
$OpenBSD: faq14.html,v 1.7 2001/04/07 07:58:55 jufi Exp $
</small>
</p>
</body>
</html>
