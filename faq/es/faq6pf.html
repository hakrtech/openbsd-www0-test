<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Preguntas Frecuentes de PF (obsoleto)</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="es">
<meta name= "resource-type" content= "documento">
<meta name= "description"   content= "Preguntas Frecuentes de OpenBSD">
<meta name= "keywords"      content= "openbsd,preguntas frecuentes,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "Este documento es copyright 1998-2003 de OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>

<h1><font color="#e00000">PF</font></h1>
<h4>Nota: Este documento ha quedado obsoleto por la
<a href="../pf/index.html">Nueva Gu&iacute;a de Usuarios de PF</a>.</h4>

<hr>

<p>
<h3>&Iacute;ndice de Contenidos</h3>
<ul>
<li><a href="#PF">6.2 - El Filtro de Paquetes PF</a>
<li><a href="#NAT">6.3 - Traducci&oacute;n de Direcciones de Red,
NAT</a>
</ul>

<hr>

<p>
<a name="6.2"></a>
<a name="PF"></a>
<h2>6.2 - El Filtro de Paquetes PF</h2>
<!-- XXXrelease -->

<p>
El subsistema de Filtros de Paquetes, que fue introducido a partir de la
versi&oacute;n 3.0, realiza dos tareas:  se encarga de los permisos de
reenv&iacute;o al nivel del paquete, y asigna anfitriones/subrredes a
una variedad de direcciones externas.  El fichero de
configuraci&oacute;n para este servicio es
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf(5)</a></i>.

<p>
Nota:  en OpenBSD 3.0 y 3.1 hab&iacute;a un fichero de
configuraci&oacute;n adicional, <i>/etc/nat.conf</i>.  Sus funciones se
han incorporado ahora en <i>/etc/pf.conf</i>.

<p>
El fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=
5"><i>/etc/pf.conf(5)</i></a>
consta de cuatro partes:

<ul>
<li><b>Options:</b>  Varias opciones para el control del funcionamiento
de PF.
<li><b>Scrub:</b>  Reprocesamiento de paquetes para normalizarlos y
desfragmentarlos.
<li><b><a href="#NAT">NAT and Redirection Rules:</a></b>  Las reglas de
redireccionamiento de NAT.  NAT permite que muchas m&aacute;quinas
puedan acceder a Internet a trav&eacute;s de una sola direcci&oacute;n
IP.  El redireccionamiento permite reenviar las peticiones entrantes a
una m&aacute;quina particular detr&aacute;s de NAT.
<li><b>Filter Rules:</b>  Las reglas de filtrado permiten el filtrado o
bloqueo selectivo de paquetes a medida que van pasando a trav&eacute;s
de cualquiera de las interfaces.
</ul>

<p>
No es necesario que exista ninguna de estas secciones, pero las que
existan deben aparecer en el mismo orden en el que se ha indicado.

<p>
Para iniciar estos servicios con el sistema, antes es necesario editar
el fichero
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
y activar las siguientes l&iacute;neas:

<blockquote>
<pre>
pf=YES
</pre>
</blockquote>

<p>
Si se va a usar NAT, es probable que tambi&eacute;n haya que
configurar el valor de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>,
<tt>net.inet.ip.forwarding</tt>, a 1.  Para ello se debe activar las
l&iacute;neas relevantes en
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a></tt>
y reiniciar la m&aacute;quina.

<p>
Si PF se encuentra compilado en el n&uacute;cleo, pero no ha sido
activado en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a>,
se puede activar f&aacute;cilmente con la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.3">pfctl(8)</a>.

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

<p>
La primera l&iacute;nea configura el filtrado y NAT, usando
<tt>/etc/pf.conf</tt>, y la segunda activa PF.

<p>
Esto tambi&eacute;n puede combinarse en una sola l&iacute;nea de
&oacute;rdenes:

<blockquote><pre>
# <strong>pfctl -f /etc/pf.conf -e</strong>
</pre></blockquote>

<p>
Si se realiza alg&uacute;n cambio en <tt>/etc/pf.conf</tt>
despu&eacute;s de haber iniciado PF, se pueden volver a cargar sus
reglas recargando el fichero:

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
</pre></blockquote>

<p>
A partir de aqu&iacute; este documento cubrir&aacute; algunos aspectos
b&aacute;sicos de la configuraci&oacute;n de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf(5)</a>
Puede verse el ejemplo del <a href="#sample_pf.conf">juego de reglas
resultante</a> que incluye todos los cambios que se explican a
continuaci&oacute;n en detalle.  Tambi&eacute;n se puede encontrar
m&aacute;s informaci&oacute;n sobre el filtro de paquetes PF en las
<a href="http://www.benzedrine.cx/pf.html">p&aacute;ginas de PF</a> y en
el documento <a href="http://www.inebriated.demon.nl/pf-howto/">Packet
Filter HOWTO</a>.

<p>
<h3>El Filtro de Paquetes PF</h3>

<p>
Para activar PF en el momento del inicio del sistema es necesario
modificar <i>/etc/rc.conf</i> de modo que se lea <tt>pf=YES</tt>.  El
filtro de paquetes IP (PF) est&aacute; controlado por el fichero
<i>/etc/pf.conf</i>, que se leer&aacute; durante el inicio.  Puede
verse una explicaci&oacute;n m&aacute;s detallada en la p&aacute;gina
del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf(5)</a>.
En los siguientes ejemplos, <tt>fxp0</tt> representa la interfaz externa
a Internet.  En otros casos puede ser diferente, dependiendo del
adaptador de ethernet del que se disponga en la m&aacute;quina.  En
estas reglas asumiremos que existe una conexi&oacute;n permanente a
Internet, del mismo tipo que la de un servidor de <i>web</i>.

<p>
Las reglas de PF se procesan de modo secuencial desde el principio hasta
el final, lo que ayuda a visualizar cada uno de los paquetes que tengan
que atravesar cada una de las regla antes de alcanzar su destino.

<p>
Por ejemplo, el grupo de reglas predeterminado permite que entren y
salgan todos los paquetes:

<blockquote><pre>
pass out all 
pass in all
</pre></blockquote>

<p>
que es la forma abreviada de:

<blockquote><pre>
pass in from any to any
pass out from any to any
</pre></blockquote>

<p>
y que se puede leer como &laquo;dejar pasar los paquetes entrantes
procedentes de cualquier parte y hacia cualquier destino&raquo;, y que
implica &laquo;en cualquier interfaz (siempre impl&iacute;cito si no se
especifica una interfaz) de cualquier familia de direcciones de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&amp;sektion=4">
inet (v4)</a> &oacute; <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&amp;sektion=4">inet6 (v6)</a>&raquo;.

<p>
L&oacute;gicamente, estas reglas no representan un buen ejemplo de
filtrado.  Un filtrado m&aacute;s &uacute;til estar&aacute; basado en la
familia de direcciones (IPv4 &oacute; IPv6), en los protocolos y en los
puertos usados por los servicios que se desean filtrar.  Se puede
especificar cualquiera de los protocolos que aparecen en la lista de
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5">/etc/protocols(5)</a></tt>,
bien por su nombre o por su n&uacute;mero, pero nosotros s&oacute;lo
trataremos los protocolos
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4">tcp(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4">udp(4)</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4">icmp(4)</a>.

<p>
Supongamos ahora que no quisi&eacute;ramos permitir ninguna
conexi&oacute;n IPv4 entrante por el puerto TCP 3306 (MySQL) porque la
base de datos s&oacute;lo deber&iacute;a permitir la conexi&oacute;n de
forma local.  En este caso, el grupo de reglas ser&iacute;a como sigue:

<blockquote><pre>
pass out all
pass in all
block in on fxp0 inet proto tcp from any to any port 3306
</pre></blockquote>

<p>
que traducido viene a decir lo siguiente: &laquo;bloquear todos los
paquetes IPv4 entrantes procedentes cualquier sitio y con destino a
cualquier sitio, por el puerto tcp 3306&raquo;.  N&oacute;tese que hay
que especificar un protocolo con cada filtro basado en los puertos, y se
recomienda que se indique la familia de direcciones a la que pertenece.
Para los servicios definidos en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5">/etc/services(5)</a>,
tambi&eacute;n se puede usar los nombres del servicio, como por ejemplo
<i>www</i> o <i>mysql</i>.  Un paquete con destino al puerto tcp 3306 en
una interfaz <tt>fxp0</tt>, pasar&aacute; la primer regla &quot;pass
in&quot;, y a continuaci&oacute;n ser&aacute; bloqueado por la regla
&quot;block in port 3306&quot;.  Si se invirtiera el orden de las reglas
entrantes (recu&eacute;rdese que el orden es importante):

<blockquote><pre>
pass out all
block in on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
los paquetes con destino al puerto tcp 3306 pasar&iacute;an porque la
&uacute;ltima regla en el grupo permite que pasen todos los paquetes.
Cuando se escriban reglas para el filtrado de paquetes es importante
tener en cuenta lo siguiente: <b>La &uacute;ltima regla que concuerde
tendr&aacute; precedencia</b>.

<p>
Y, por supuesto, existen excepciones para toda regla.  La opci&oacute;n
<i>quick</i> filtra el paquete en la primera regla que concuerde.
Veamos de nuevo el defectuoso ejemplo anterior,
a&ntilde;adi&eacute;ndole la opci&oacute;n <i>quick</i> a la regla
&quot;block in&quot;:

<blockquote><pre>
pass out all
block in quick on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
<p>
Un paquete destinado para el puerto tcp 3306 ser&aacute; filtrado por la
regla &quot;block in quick&quot; y bloqueado inmediatamente.  Todos los
paquetes destinados a otros puertos no encontrar&aacute;n una
concordancia en las reglas hasta llegar a la regla &quot;pass in&quot;,
que permite que pasen todos los paquetes.

<p>
<b>Denegaci&oacute;n predefinida</b>
<p>
La pol&iacute;tica de filtrado de p&aacute;quetes m&aacute;s segura es
la de &laquo;denegaci&oacute;n por definici&oacute;n&raquo;.  Esta
pol&iacute;tica es mucho m&aacute;s segura que la denegaci&oacute;n
expl&iacute;cita de cada uno de los servicios protegidos, permite el uso
de grupos de reglas m&aacute;s breves, y puede proteger de un servicio
que haya sido mal configurado de forma accidental y que haya quedado
expuesto.

<p>
Veamos ahora otro ejemplo de un grupo de reglas real, seguido por una
explicaci&oacute;n, l&iacute;nea por l&iacute;nea.  El siguiente ejemplo
es para un servidor de web con una pol&iacute;tica de denegaci&oacute;n
predefinida que s&oacute;lo permita conexiones ssh (para
administraci&oacute;n), y conexiones http (puerto 80) y https (puerto
443).

<blockquote><pre>
block in on fxp0 all
pass  in on fxp0 inet proto tcp from any to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 all
</pre></blockquote>

<p>
Esto permitir&aacute; el paso de conexiones desde cualquier punto de
origen con destino a los puertos tcp 22 (ssh), 80 (http) y 443 (https).
Cualquier otro intento de conexi&oacute;n distinto ser&aacute;
bloqueado, y permitir&aacute; el paso a todas las conexiones salientes,
cualquiera que sea su destino.  Este grupo de reglas es muy estricto.
Pero, &iquest;y si quisi&eacute;ramos que s&oacute;lo puedan conectarse
a ssh los anfitriones internos de nuestro bloque de direcciones 1.1.1.0,
y que al mismo tiempo que se permitan las conexiones externas a http y
https?

<blockquote><pre>
block in on fxp0 all
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 all
</pre></blockquote>

<p>
De acuerdo, pero, &iquest;y si s&oacute;lo quisi&eacute;ramos permitir
la administraci&oacute;n remota de nuestro servidor de web a una sola
m&aacute;quina (1.1.1.1)?  Entonces cambiar&iacute;amos esta regla:

<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>

<p>
por esta otra:

<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
</pre></blockquote>

<p>
<b>Ejemplos de reglas</b>
<p>
He aqu&iacute; algunas ejemplos de reglas que pueden ser de utilidad
para todos (en las que se asume que <tt>fxp0</tt> es la interfaz externa
conectada a Internet).  Primero configuraremos un filtro simple para la
protecci&oacute;n contra la falsificaci&oacute;n de direcciones IP
(<i>ip address spoofing</i>).  Estas direcciones, por lo general, no
deber&iacute;an vagar por Internet y, si lo hacen, lo que es bastante
raro, las bloquearemos:

<blockquote><pre>
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
Nuestro grupo de reglas est&aacute; mejorando;  cuando lo ponemos todo
junto obtenemos lo siguiente:

<blockquote><pre>
# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# only allow our administration machine to connect via ssh
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22

# allow others to use http and https
pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443

# finally lock the rest down with a default deny
block in quick on fxp0 from any to any

# and let out-going traffic out
pass out on fxp0 from any to any
</pre></blockquote>

<p>
<b>Registro de paquetes</b>
<p>
De momento va bastante bien, pero a&uacute;n podr&iacute;a ir mejor.
&iquest;Qu&eacute; har&iacute;amos si quisi&eacute;ramos obtener un
registro de cualquier intento de conexi&oacute;n al puerto 22 (ssh) que
pasara a trav&eacute;s de nuestro cortafuegos?  Ser&iacute;a
f&aacute;cil, ya que PF puede gestionar este caso con la opci&oacute;n
clave:
<i>log</i>:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
block in log quick on fxp0 inet proto tcp from any to any port 22
</pre></blockquote>

<p>
Esta regla permitir&aacute; la conexi&oacute;n remota por el puerto 22 a
nuestra m&aacute;quina de administraci&oacute;n, pero denegar&aacute; y
registrar&aacute; cualquier otro intento de conexi&oacute;n al puerto
22.

<p>
Los paquetes registrados se env&iacute;an a la interfaz pflog0, que
est&aacute; siendo monitorizada por
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">pflogd(8)</a>,
el cual suele volcar los paquetes a <tt>/var/log/pflog</tt> en el
formato binario de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8&amp;manpath=OpenBSD+3.3">tcpdump(8)</a>.
Si pf se encuentra activado en
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></tt>,
pflogd(8) se inicia de modo predefinido desde
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a></tt>.
Estos ficheros de registro se pueden leer usando la siguiente orden:

<blockquote><pre>
# <b>tcpdump -n -e -ttt -r /var/log/pflog</b>
</pre></blockquote>

<p>
Hay que tener en cuenta que la utilizaci&oacute;n de tcpdump para la
monitorizaci&oacute;n del fichero <i>pflog</i> NO ofrece
informaci&oacute;n en tiempo real.  Para ver la informaci&oacute;n en
tiempo real hay que usar la siguiente orden:

<blockquote><pre>
# <b>tcpdump -i pflog0</b>
</pre></blockquote>

<p>
Tambi&eacute;n es posible usar tcpdump para estrechar el objetivo y
facilitar as&iacute; el depurado:

<blockquote><pre>
# <b>tcpdump -e -i pflog0 port 80</b>
</pre></blockquote>

<p>
Esta orden NO altera los datos que se incluyen en el fichero
<tt>/var/log/pflog</tt>.

<p>
Cuando se examinan los registros propios, es aconsejable tener mucho
cuidado con la descodificaci&oacute;n del protocolo (la verbosidad en
los mensajes se activa a&ntilde;adiendole a la orden la opci&oacute;n
<tt>-v</tt>).  Los descodificadores de protocolo de tcpdump no tienen un
historial impecable.  En teor&iacute;a, ser&iacute;a posible un ataque
retrasado a trav&eacute;s de paquetes parciales de carga &uacute;til
(<i>partial packet payload</i>) registrados por el dispositivo de
ingreso.

<p>
Es preciso tener un cuidado especial con el acceso a los registros.
pflogd captura 96 bytes del paquete y los registra.  El acceso a los
registros podr&iacute;a dar acceso parcial a paquetes de carga
&uacute;til de car&aacute;cter reservado (como los registros de ingreso
de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&amp;sektion=1">telnet(1)</a> o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>).

<p>
<b>Registro de paquetes con <tt>syslog</tt></b>
<p>
Hay muchas situaciones en las que es conveniente que los registros
(<i>logs</i>) del cortafuegos est&eacute;n disponibles en formato ASCII
(texto simple) y/o enviarlos a un servidor de registros remoto.  Esto se
puede llevar a cabo mediante dos peque&ntilde;os guiones de
ejecuci&oacute;n del int&eacute;rprete de &oacute;rdenes (<i>shell
scripts</i>) y con unos cambios m&iacute;nimos de los ficheros de
configuraci&oacute;n de OpenBSD.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">Syslogd(8)</a>
es el d&aelig;mon est&aacute;ndar para registros, que los realiza en
formato ASCII y que tambi&eacute;n puede enviarlos a un servidor de
registros remoto.

<p>
Para ello, primero debemos crear un usuario, <i>pflogger</i>, con
<i>.nologin.</i> como int&eacute;rprete.  La forma m&aacute;s
f&aacute;cil de crear este usuario es con la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8&amp;manpath=OpenBSD+3.3">adduser(8)</a>.

<p>
Despu&eacute;s de crear el usuario <i>pflogger</i> crearemos los dos
guiones de ejecuci&oacute;n siguientes:

<p>
<tt>/etc/pflogrotate</tt>

<blockquote><pre>
FILE=/home/pflogger/pflog5min.$(date "+%Y%m%d%H%M")
kill -ALRM $(cat /var/run/pflogd.pid)
if [ $(ls -l /var/log/pflog | cut -d " " -f 8) -gt 24 ]; then
        mv /var/log/pflog $FILE
        chown pflogger $FILE
        kill -HUP $(cat /var/run/pflogd.pid)
fi
</pre></blockquote>


<p>
<tt>/home/pflogger/pfl2sysl</tt>

<blockquote><pre>
#!/bin/sh
# feed rotated pflog file(s) to syslog
for logfile in /home/pflogger/pflog5min* ; do
        tcpdump -n -e -ttt -r $logfile | logger -t pf -p local0.info
        rm $logfile
done
</pre></blockquote>

<p>
A continuaci&oacute;n abriremos la tarea de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
del usuario <i>root</i> en modo de edici&oacute;n mediante la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=1">crontab(1)</a>:

<blockquote><pre>
# <b>crontab -u root -e</b>
</pre></blockquote>

<p>
y le a&ntilde;adiremos las dos l&iacute;neas siguientes:

<blockquote><pre>
# rotate pf log file every 5 minutes
0-59/5 *       *       *       *       /bin/sh /etc/pflogrotate
</pre></blockquote>

<p>
luego crearemos una tarea de cron para el usuario <i>pflogger</i>:

<blockquote><pre>
# <b>crontab -u pflogger -e</b>
</pre></blockquote>

<p>
y le a&ntilde;adiremos la l&iacute;nea siguiente:

<blockquote><pre>
# feed rotated pflog file(s) to syslog
0-59/5 *       *       *       *       /bin/sh /home/pflogger/pfl2sysl
</pre></blockquote>

<p>
y la siguiente l&iacute;nea en <tt>/etc/syslog.conf</tt>:

<blockquote><pre>
local0.info    /var/log/pflog.txt
</pre></blockquote>

<p>
Si queremos que los registros se realicen mediante un servidor de
registros remoto, tambi&eacute;n a&ntilde;adiremos la l&iacute;nea:

<blockquote><pre>
local0.info    @syslogger
</pre></blockquote>

<p>
asegur&aacute;ndonos de que el anfitri&oacute;n <i>syslogger</i> se
encuentre definido en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/hosts(5)</a>.

<p>
Todos los paquetes registrados ser&aacute;n enviados al fichero
<tt>/var/log/pflog.txt</tt>.  Si adem&aacute;s hemos a&ntilde;adido la
segunda l&iacute;nea, tambi&eacute;n ser&aacute;n enviados al
anfitri&oacute;n de registro remoto, <i>syslogger</i>.

<p>
Ahora <tt>/etc/pflogrotate</tt> procesa y luego elimina
<tt>/var/log/pflog</tt>, por lo que la rotaci&oacute;n de <i>pflog</i>
por
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newsyslog&amp;sektion=8&amp;manpath=OpenBSD+3.3">newsyslogd(8)</a>
ya no es necesaria y debe ser desactivada.  Sin embargo,
<tt>/var/log/pflog.txt</tt> sustituye <tt>/var/log/pflog</tt>, y la
rotaci&oacute;n deber&iacute;a permanecer activada.  Para ello
cambiaremos <tt>/etc/newsyslog.conf</tt> de la siguiente forma:

<blockquote><pre>
#/var/log/pflog        600     3       250     *       ZB      /var/run/pflogd.
pid
/var/log/pflog.txt     600     7       *       24
</pre></blockquote>

<p>
Ahora los registros de pf en ASCII ir&aacute;n a
<tt>/var/log/pflog.txt</tt>.  Adem&aacute;s, si lo hemos configurado en
<tt>/etc/syslog.conf</tt>, tambi&eacute;n enviar&aacute; los registros a
un servidor remoto.  El proceso del registro no es inmediato, sino que
tarda entre unos 5 &oacute; 6 minutos (el intervalo de la tarea de cron)
antes de que los paquetes registrados aparezcan en el fichero.

<p>
<b>Protocolos m&uacute;ltiples</b>
<p>
&iquest;Qu&eacute; ocurrir&iacute;a si necesit&aacute;ramos permitir las
conexiones a un servicio que funcionara sobre m&uacute;ltiples
protocolos (como bind, que usa TCP y UDP)?  PF nos permite agrupar
opciones (m&aacute;s adelante volveremos a este tema):

<blockquote><pre>
# Pass DNS traffic for BIND
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

<p>
N&oacute;tese los espacios a ambos lados de los caracteres '{ }'.  Esta
forma es m&aacute;s elegante que la que habr&iacute;a que usar como
alternativa:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from any to any port 53
pass in quick on fxp0 inet proto udp from any to any port 53
</pre></blockquote>

<p>
<a name="normalization"></a>
<b>Normalizaci&oacute;n de paquetes</b>

<p>
La &laquo;normalizaci&oacute;n de paquetes&raquo; implica el
reensamblaje de los paquetes fragmentados y la limpieza de las opciones
de IP.  Algunos sistemas operativos y aplicaciones tienen problemas con
paquetes fragmentados o an&oacute;malos, y en general es bueno
normalizar los paquetes para que los puedan buscar bien las reglas de
filtros y los anfitriones de destino de estos paquetes.  Por lo tanto,
casi siempre es beneficioso normalizar los paquetes antes de que lleguen
a su destino final.  Para esto se utiliza la directiva
<b>scrub</b>, que se usa como sigue:

<blockquote><pre>
scrub in all
</pre></blockquote>

<p>
Esta directiva a&ntilde;ade una peque&ntilde;a carga adicional al
sistema, y requiere de un poco de memoria para los fragmentos del
paquete.  Las ventajas de la normalizaci&oacute;n de paquetes casi
siempre son mayores que este peque&ntilde;o coste.

<p>
<b>Opciones de IP</b>
<p>
En su modo predeterminado, PF bloquea los paquetes que tienen las
opciones de IP activadas.  Esto puede dificultar a&uacute;n m&aacute;s
la tarea a las utilidades de detecci&oacute;n de sistemas como nmap.  Si
se tiene una aplicaci&oacute;n que requiera el paso de estos paquetes,
como puede ser IGMP, puede usarse la directiva <b>allow-opts</b>:

<blockquote><pre>
pass in quick on fxp0 all allow-opts
</pre></blockquote>

<p>
<b>Indicadores de TCP, conexiones establecidas, y mantenimiento del
estado</b>

<p>
PF tambi&eacute;n puede filtrar los paquetes bas&aacute;ndose en los
indicadores de TCP, y mantener as&iacute; las conexiones establecidas y
el estado de la conexi&oacute;n.  Se recomienda que todos los usuarios
que quieran filtrar paquetes bas&aacute;ndose en los indicadores TCP
entiendan antes el papel que desempe&ntilde;a cada indicador.  Por
ejemplo, si un usuario quisiera denegar la conexi&oacute;n a todos los
paquetes con los indicadores FIN, URG, y PSH activados (por ejemplo, en
un intento por obtener la huella digital de un sistema operativo
mediante nmap), podr&iacute;a usar una regla como la siguiente:

<blockquote><pre>
block in quick on fxp0 inet proto tcp from any to any flags FUP/FUP
</pre></blockquote>

<p>
(Gracias a <a href="mailto:halogen@nol.net">Kyle Hargraves</a> por esta
regla)

<p>
El pr&oacute;ximo truco de PF es su capacidad para &laquo;mantener el
estado&raquo; (<i>keep state</i>).  El concepto de &laquo;mantener el
estado&raquo; se puede definir como &laquo;no contestar hasta que no ser
preguntado&raquo; o, en otras palabras, una vez que se ha establecido
una conexi&oacute;n, los paquetes ya no tienen que atravesar grupos de
reglas.  &Eacute;sta es una funcionalidad muy potente que permite
escribir unas reglas mucho m&aacute;s sencillas y seguras.

<p>
Veamos c&oacute;mo se podr&iacute;a aplicar este estado al ejemplo del
grupo de reglas anterior.  &iquest;Confuso?  Revis&eacute;moslo: estamos
permitiendo el acceso para la gesti&oacute;n del sistema desde nuestra
m&aacute;quina de clase C al puerto 22 (ssh), y el acceso al servidor de
<i>web</i> a todo el tr&aacute;fico entrante a los puertos 80 (http) y
443 (https); y estamos bloqueando el resto del tr&aacute;fico.  pero,
&iquest;y si quisi&eacute;ramos establecer una conexi&oacute;n a
trav&eacute;s de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">
ssh(1)</a> fuera del servidor de <i>web</i>? o, &iquest;y si
necesit&aacute;ramos usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&amp;sektion=1">
lynx(1)</a> para buscar algo en los documentos de las preguntas
frecuentes?  No podr&iacute;amos, ya que habr&iacute;amos bloqueado
todas las conexiones entrantes que no fueran dirigidas a los puertos
especificados.  Aunque &eacute;sta es la ruta m&aacute;s segura, puede
ser muy poco conveniente.  a&ntilde;adiendo las opciones clave <i>keep
state</i> a la regla &quot;pass out&quot;, podemos permitir de forma
autom&aacute;tica el paso de los paquetes que sean una respuesta a
conexiones que hayamos iniciado nosotros previamente, como por ejemplo
al navegar por la <i>web</i>.  Recu&eacute;rdese que es necesario
especificar para qu&eacute; protocolo estamos efectuando el
mantenimiento del estado.

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 keep state
pass  out on fxp0 inet proto tcp all keep state
</pre></blockquote>

<p>
Este peque&ntilde;o cambio supondr&aacute; un dram&aacute;tico
incremento en la flexibilidad y seguridad de nuestro grupo de reglas:
por ejemplo, en el grupo de reglas anterior, estamos permitiendo el paso
a todo el tr&aacute;fico tcp hacia los puertos 80 y 443.  A&uacute;n
podemos hacer que sea un poco m&aacute;s estricto.  Para establecer una
conexi&oacute;n tcp s&oacute;lo se necesita permitir que tenga lugar el
saludo inicial (<i>handshake</i>); una vez que esto ocurra, podemos
bloquear el tr&aacute;fico a ese puerto y permitir que la regla
&quot;keep state&quot; gestione la conexi&oacute;n.  Para que se
complete el saludo inicial, s&oacute;lo es necesario que los paquetes
SYNACK est&eacute;n activados.  Dejando pasar s&oacute;lo paquetes con
SYN activado se puede prevenir muchas formas de barridos de puertos
(<i>port scanning</i>), como puede ser el barrido de FIN.  Los
indicadores S/SA del indicador S (SYN) y el indicador A (ACK) indican
que s&oacute;lo se puede activar SYN.  No se investiga sobre otros
paquetes.  Ahora, las reglas est&aacute;n de este modo:

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 \
        flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 \
        flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 \
        flags S/SA keep state
block out on fxp0 inet proto tcp all
pass  out on fxp0 inet proto tcp all flags S/SA keep state
</pre></blockquote>

<p>
Empecemos a poner un poco de orden colocando juntas todas las reglas que
tenemos hasta ahora.  Este grupo de reglas tendr&aacute; soporte para
IPv4, una pol&iacute;tica de denegaci&oacute;n predefinida,
permitir&aacute; conexiones para la gesti&oacute;n del sistema
s&oacute;lo si provienen de una red interna (a trav&eacute;s de ssh), y
permitir&aacute; el paso del tr&aacute;fico entrante hacia los puertos
80 (http) y 443 (https).  Adem&aacute;s, proteger&aacute; contra
direcciones de ip falsificadas no enrutables, y bloquear&aacute; todos
los paquetes que est&eacute;n tan fragmentados que no se puedan
inspeccionar.  Una configuraci&oacute;n bastante completa para un
servidor de <i>web</i> p&uacute;blico.  He aqu&iacute; c&oacute;mo
quedar&iacute;a <tt>/etc/pf.conf</tt>:

<blockquote><pre>
# Clean up fragmented and abnormal packets
scrub in all

# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# by default, block all incoming packets, except those explicitly
# allowed by further rules
block in on fxp0 all

# allow others to use http and https
pass in on fxp0 inet proto tcp from any to any port 80 \
        flags S/SA keep state
pass in on fxp0 inet proto tcp from any to any port 443 \
        flags S/SA keep state

# and let out-going traffic out and maintain state on established connections
# pass out all protocols, including TCP, UDP and ICMP, and create state,
# so that external DNS servers can reply to our own DNS requests (UDP).
block out on fxp0                 all
pass  out on fxp0 inet proto tcp  all flags S/SA keep state
pass  out on fxp0 inet proto udp  all            keep state
pass  out on fxp0 inet proto icmp all            keep state
</pre></blockquote>

<p>
Aunque esto pueda parecer suficiente, todav&iacute;a hay algunas cosas
que PF nos permitir&aacute; realizar para que el fichero
<tt>pf.conf</tt> sea m&aacute;s claro y m&aacute;s f&aacute;cil de
mantener.

<p>
<b><i>Sets</i> (agrupaciones)</b>
<p>
Las agrupaciones son abreviaciones que sirven para escribir reglas
m&aacute;s simples y claras en PF.  Por ejemplo, &iquest;qu&eacute;
har&iacute;amos si quisi&eacute;ramos permitir conexiones a un servicio
que funcionase sobre m&uacute;ltiples protocolos como BIND, que usa TCP
y UDP?

<blockquote><pre>
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

<p>
N&oacute;tense los espacios a ambos lados de los caracteres '{ }'.

<p>
Los grupos de IP relacionadas entre si se pueden reagrupar en
agrupaciones (<i>sets</i>);  estas agrupaciones se pueden utilizar en
cualquier parte en la que se pueda usar una IP.  Por ejemplo, tomando
como partida nuestras reglas contra la falsificaci&oacute;n de IP
anteriores:

<blockquote><pre>
# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
<b>Expansi&oacute;n de variables</b>

<p>
Un problema con el ejemplo del fichero <tt>pf.conf</tt> anterior es que,
si necesit&aacute;ramos cambiar nuestro NIC, o cambiar una
direcci&oacute;n IP, tendr&iacute;amos que modificar muchas
l&iacute;neas.  Para suavizarlo podemos definir variables de
expansi&oacute;n:

<blockquote><pre>
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
ExtIF="fxp0"
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
</pre></blockquote>

<p>
<a name="sample_pf.conf"></a>
<b>Todo junto</b>
<p>
Pongamos todo lo que hemos visto hasta ahora en un fichero y comprobemos
la elegancia de este fichero:

<blockquote><pre>
# Define useful variables
ExtIF="fxp0"              # External Interface
IntNet="1.1.1.0/24"       # Our internal network
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
Services="{ www, https }"

# Clean up fragmented and abnormal packets
scrub in all

# don't allow anyone to spoof non-routeable addresses
block in  quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs

# by default, block all incoming packets, except those explicitly
# allowed by further rules
block in on $ExtIF all

# allow others to use http and https
pass  in on $ExtIF inet proto tcp from any to any port $Services \
        flags S/SA keep state

# and let out-going traffic out and maintain state on established connections
# pass out all protocols, including TCP, UDP and ICMP, and create state,
# so that external DNS servers can reply to our own DNS requests (UDP).
block out on $ExtIF                 all
pass  out on $ExtIF inet proto tcp  all flags S/SA keep state
pass  out on $ExtIF inet proto udp  all            keep state
pass  out on $ExtIF inet proto icmp all            keep state
</pre></blockquote>

<p>
Si se experimenta problemas, puede activarse el registro en reglas
individuales con la clave <i>log</i> para facilitar la
resoluci&oacute;n de los problemas, o sea:

<blockquote><pre>
pass in log quick on fxp0 proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp ;manpath=OpenBSD+3.3">pflogd(8)</a>
escribir&aacute; las entradas de registros de ip a
<tt>/var/log/pflog</tt>.  Recu&eacute;rdese que <tt>/var/log/pflog</tt>
es un fichero binario que debe ser le&iacute;do por medio de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8&amp;manpath=OpenBSD+3.3">tcpdump(8)</a>,
y NO directamente como un fichero normal de texto.

<p>
&iexcl;Cuando se modifique el fichero de configuraci&oacute;n para el
registro de paquetes, no hay que olvidarse de ejecutar <kbd>pfctl -R
/etc/pf.conf</kbd> para que se efect&uacute;en los cambios!

<a name="6.3"></a>
<a name="NAT"></a>
<h2>6.3 - NAT, el sistema de Traducci&oacute;n de Direcciones de
Red</h2>
<!-- XXXrelease -->

<p>
<h4>Nota:  En OpenBSD 3.2 y en versiones posteriores, las funciones de
NAT se han incorporado en el fichero <tt>/etc/pf.conf</tt>, no en el
fichero aparte <tt>/etc/nat.conf</tt> que se usaba en OpenBSD 3.0 y
3.1</h4>

<p>
<a name="nat1.0"></a>
<h3><u>6.3.1 Introducci&oacute;n a NAT</u></h3>

<a name="nat1.1"></a>

<p>
Basado en la especificaci&oacute;n
<a href="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, NAT
provee de un modo f&aacute;cil para la asignaci&oacute;n de redes
internas a una sola direcci&oacute;n de Internet enrutable
(&laquo;real&raquo;).  Es de gran utilidad si no se dispone de
direcciones asignadas oficialmente para cada anfitri&oacute;n en la red
interna.  Cuando se configuren redes privadas/internas se pueden
aprovechar los bloques de direcci&oacute;n reservados (asignados en la
especificaci&oacute;n
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), como:

<p>
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)

<p>
Se asume que el usuario ya disponde de un sistema OpenBSD configurado
con dos tarjetas de red (una conectada a Internet y la otra a la red
local).

<p>
<a name="nat1.3"></a>
<b>Detalles de configuraci&oacute;n</b>

<p>
Usaremos el sistema que se describe a continuaci&oacute;n como ejemplo.
Como la configuraci&oacute;n particular de cada usuario ser&aacute;, con
casi toda seguridad, distinta a &eacute;sta, hay que tener mucho cuidado
con no copiar literalmente todo lo que aqu&iacute; se vea y
despu&eacute;s esperar que funcione correctamente.

<blockquote>
<b>NICs: </b>
<pre>
Intel EtherExpress Pro/100 <b>fxp0</b>
Conectada a la LAN EXTERNA (o WAN)
<b>IP Address: </b>24.5.0.5
<b>Netmask: </b>255.255.255.0

Compaq Netelligent 10/100Mb <b>tl0</b>
Conectada a la LAN INTERNA
<b>IP Address: </b>192.168.1.1
<b>Netmask: </b>255.255.255.0
</pre>
</blockquote>

<blockquote>
<b>IP enrutable por Internet, externo (en este ejemplo, una
conexi&oacute;n por m&oacute;dem anal&oacute;gico a trav&eacute;s de un
proveedor de servicios de Internet)</b><br>
<pre>
<b>IP Address: </b>24.5.0.5
<b>Netmask: </b>255.255.255.0
<b>Gateway: </b>24.5.0.1
</pre>
</blockquote>

<blockquote>
<b>Red de &Aacute;rea Local (LAN)</b><br>
En este entorno de ejemplo las m&aacute;quinas de la LAN usan el esquema
de direcciones IP 192.168.1.xxx (en donde xxx es un n&uacute;mero
&uacute;nico).  Existe una gran variedad de sistemas operativos
diferentes en la red interna, incluidos Windows 98, Windows NT, OpenBSD
y Linux, pero el sistema operativo cliente no es un problema para NAT.
Cada m&aacute;quina est&aacute; conectada a un concentrador
(<i>hub</i>) designado para el uso interno.  Para este documento y sus
ejemplos, se asumir&aacute; que el cliente en la red interna tiene una
direcci&oacute;n de IP 192.168.1.40
</blockquote>

<blockquote>
<b>Diagrama de configuraci&oacute;n</b>
<pre>
+-----+              +---------+          +----------+
| Hub |--------- tl0 |   NAT   | fxp0 ----| Internet |
+-----+              +---------+          +----------+
| |
| +-- Cliente A
+---- Otros clientes 

                      +---------------------------+
                      |          LEYENDA          |
                      +---------------------------+
                      |   NIC fxp0 - 24.5.0.5     |
                      |   NIC tl0  - 192.168.1.1  |
                      | Cliente A  - 192.168.1.40 |
                      +---------------------------+

</pre>
</blockquote>

<p>
<a name="nat2.0"></a>
<h3><u>6.3.2 Traducci&oacute;n de Direcciones de Red</u></h3>

<p>
<a name="nat2.1"></a>
<b>Introducci&oacute;n a NAT</b>

<p>
Cada nodo en Internet requiere una direcci&oacute;n IP &uacute;nica.
Con IPv4 hay un n&uacute;mero finito de direcciones IP diferentes
disponibles, y como resultado no son gratuitas.  La mayor&iacute;a de
proveedores de Internet a &laquo;bajo coste&raquo; limitan un sitio a
cualquier parte desde 1 a 30 direcciones, y mientras organizaciones con
presupuestos m&aacute;s grandes pueden permitirse un bloque mayor, en la
mayor&iacute;a de los casos existen pocos beneficios y demasiados
riesgos al tener cada m&aacute;quina con una direcci&oacute;n individual
en Internet.

<p>
La &laquo;Traducci&oacute;n de Direcciones de Red&raquo; (<i>Network
Address Translation</i>), o NAT, tambi&eacute;n conocida como
&laquo;Enmascaramiento de IP&raquo; en Linux (<i>IP Masquerading</i>),
permite que varias m&aacute;quinas se encuentren <i>detr&aacute;s</i> de
una sola, o de varias, direcci&oacute;n IP.  Cada m&aacute;quina en la
red interna tiene una direcci&oacute;n IP no registrada que se asigna de
forma interna (de acuerdo con las especificaciones del
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), y
todas utilizan la misma direcci&oacute;n IP externa de forma
simult&aacute;nea.

<p>
NAT funciona de un modo bastante simple.  Cuando un cliente dentro de la
LAN quiere conectarse a la m&aacute;quina en Internet, le env&iacute;a
un paquete TCP con un requerimiento de conexi&oacute;n.  Dentro de la
cabecera del paquete TCP se encuentra la direcci&oacute;n IP del cliente
(por ejemplo, 192.168.1.40) y la direcci&oacute;n IP del
anfitri&oacute;n requerido (por ejemplo, 123.45.67.89).  La
m&aacute;quina en la que est&aacute; funcionando NAT intercepta este
paquete TCP y cambia la direcci&oacute;n IP del cliente de 192.168.1.40
a la direcci&oacute;n IP de la m&aacute;quina conectada a Internet (por
ejemplo, 24.5.0.5).  De este modo enga&ntilde;a a la m&aacute;quina
anfitriona, haci&eacute;ndole pensar que la conexi&oacute;n requerida
proviene de la m&aacute;quina con NAT, no de la m&aacute;quina cliente.
Entonces, el anfitri&oacute;n env&iacute;a de vuelta respuestas a la
m&aacute;quina NAT como si &eacute;sta fuera la que se estuviera
conectando.  Cuando la m&aacute;quina NAT recibe las respuestas, las
traduce r&aacute;pidamente y env&iacute;a el paquete al cliente.
Generalmente, el cliente no tiene ni la m&aacute;s remota idea de lo que
est&aacute; ocurriendo, y la supuesta conexi&oacute;n a Internet es
transparente para el usuario y para las aplicaciones del usuario.

<p>
El ejemplo siguiente muestra NAT de un modo m&aacute;s claro:

<blockquote><pre>
Cliente ---------------- tl0 [ NAT ] fxp0 ---------- Internet Host
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

Paquete TCP SALIENTE                             Paquete TCP SALIENTE
Desde: 192.168.1.40  &gt;&gt;=== NAT ===&gt;&gt; Hacia: 24.5.0.5
Hacia: 123.45.67.89                              Hacia: 123.45.67.89

Paquete TCP ENTRANTE                             Paquete TCP ENTRANTE
Desde: 123.45.67.89                              Desde: 123.45.67.89
Hacia: 192.168.1.40  &lt;&lt;=== NAT ===&lt;&lt; Hacia: 24.5.0.5
</pre></blockquote>

<p>
<a name="nat2.2"></a>
<b>&iquest;Por qu&eacute; usar NAT?</b>

<p>
Despu&eacute;s de haber conseguido un m&oacute;dem cable en mi nuevo
apartamento, me d&iacute; cuenta de que ten&iacute;a un peque&ntilde;o
problema:  &iquest;c&oacute;mo podr&iacute;a conseguir acceso a Internet
para mis compa&ntilde;eros de apartamento si el m&oacute;dem estaba en
mi habitaci&oacute;n?  S&oacute;lo hab&iacute;a unas pocas opciones que
pod&iacute;a utilizar, y que iban desde obtener direcciones IP extras,
pasando por instalar un servidor proxy, hasta instalar NAT (el ejemplo
casero del m&oacute;dem cable no debe llevarnos a enga&ntilde;o, NAT es
lo suficientemente potente como para enmascarar un gran red con cientos
o incluso miles de m&aacute;quinas).

<p>
Existen varias razones por las que decid&iacute; instalar NAT, la
primera de ellas fue el ahorro en costes.  En la casa viv&iacute;an dos
compa&ntilde;eros de piso, y compartir gastos es una buena idea.
Adem&aacute;s, cada uno ten&iacute;a su propio PC y yo ten&iacute;a
tres; ten&iacute;amos cinco m&aacute;quinas que conectar, pero mi ISP
s&oacute;lo permit&iacute;a tres direcciones IP por casa, lo que
significaba que no hab&iacute;an direcciones IP suficientes para que
cada m&aacute;quina pudiera acceder a Internet de forma
simult&aacute;nea.

<p>
Usando NAT, cada m&aacute;quina tendr&iacute;a una direcci&oacute;n IP
interna &uacute;nica,  pero todas compartir&iacute;an la &uacute;nica
direcci&oacute;n IP que mi ISP me dio.  El coste se redujo notablemente.

<p>
<a name="nat2.4"></a>
<b>Preconfiguraci&oacute;n</b>

<p>
Para activar NAT en una m&aacute;quina OpenBSD, antes hay que configurar
PF.  Esto se puede hacer f&aacute;cilmente editando los ficheros que
aparecen en la siguiente lista (los cambios al fichero deben hacerse de
tal modo que aparezcan como las opciones que siguen a
continuaci&oacute;n):

<p>
<b>/etc/rc.conf</b> (este fichero se usa para iniciar servicios durante
el arranque)

<blockquote><pre>
pf=YES<br>
</pre></blockquote>

<p>
<b>/etc/sysctl.conf</b>

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Despu&iacute;s de haber realizado estos cambios, la m&aacute;quina
estar&aacute; lista para la configuraci&oacute;n de NAT.

<p>
<a name="nat2.5"></a>
<b>Configuraci&oacute;n</b>

<p>
El primer paso es configurar el fichero de reglas de PF
(<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf</a></tt>).
Para el prop&oacute;sito que persigue este documento, dejaremos que el
tr&aacute;fico pase a trav&eacute;s de este cortafuegos sin que haya
interferencias.  El fichero quedar&aacute; como sigue:

<blockquote><pre>
pass in all
pass out all
</pre></blockquote>

<p>
Se puede ver m&aacute;s informaci&oacute;n en la secci&oacute;n que
trata sobre <a href="#PF"><tt>PF</tt>, el paquete de filtros IP</a> de
OpenBSD.

<p>
La sintaxis de la parte correspondiente a NAT del fichero de
configuraci&oacute;n
(<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf</a></tt>)
es bastante simple.  De acuerdo con el ejemplo de configuraci&oacute;n
anterior, el fichero de configuraci&oacute;n de NAT contendr&aacute; las
siguientes entradas:

<blockquote><pre>
nat on fxp0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
</pre></blockquote>

<p>
He aqu&iacute; el significado de cada una de estas l&iacute;neas.

<dl>
<dt>&quot;nat&quot;
<dd>Indica que la orden que se est&aacute; dando es una regla de NAT.
</dl>

<dl>
<dt>&quot;fxp0&quot;
<dd>&Eacute;sta es la interfaz de red que est&aacute; conectada a
Internet.
</dl>

<dl>
<dt>&quot;192.168.1.0/24&quot;
<dd>La direcci&oacute;n IP y de enmascaramiento de red
(<i>netmask</i>, cuyo formato es CIDR).  La combinaci&oacute;n de ambas
indica que &laquo;se debe asignar cualquier direcci&oacute;n IP con un
valor desde 192.168.1.1 hasta 192.168.1.254&raquo;.
</dl>

<dl>
<dt>&quot;24.5.0.5&quot;
<dd>&Eacute;sta es la direcci&oacute;n IP externa que se asignar&aacute;
a la direcci&oacute;n IP interna.
</dl>

<p>
<a name="nat2.6"></a>
<b>Funcionamiento</b>

<p>
Una vez que se haya acabado de configurar, hay dos formas de activar
NAT.  La primera forma, y la mejor si fuera posible, es reiniciando el
sistema OpenBSD.  Para ello basta con usar la orden <kbd>reboot</kbd>.

<p>
Si se quiere ejecutar NAT desde la l&iacute;nea de &oacute;rdenes,
ser&aacute; necesario usar las siguientes &oacute;rdenes:

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

<p>
La primera l&iacute;nea es para cargar un grupo de reglas de NAT en PF
(y eliminar cualquier regla anterior), y la segunda para activar PF.
Despu&eacute;s de esto, la mejor manera de asegurarse de que todo
iniciar&aacute; como se espera, es reiniciar el sistema.

<p>
<b>Nota:</b> para volver a cargar las configuraciones de NAT (en el caso
en que se cambiaran y no se quisiera reiniciar) debe ejecutarse de nuevo
la primera orden.  Las configuraciones ser&aacute;n descargadas y
cargadas de nuevo.

<p>
<a name="nat3.0"></a>
<h3><u>6.3.3 Base de conocimientos de NAT</u></h3>

<p>
<a name="nat3.1"></a>
<b>Comprobaci&oacute;n del estado de NAT</b>

<p>
Para averiguar c&oacute;mo est&aacute; funcionando NAT o asegurarse de
que las configuraciones hayan hecho efecto, se usa la opci&oacute;n
&quot;-ss&quot;.  Esta opci&oacute;n mostrar&aacute; un listado de todas
las sesiones que NAT est&eacute; usando actualmente:

<blockquote><pre>
# pfctl -ss
TCP  192.168.1.40:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.40:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.40:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
</pre></blockquote>

<p>
A continuaci&oacute;n puede verse una explicaci&oacute;n sobre lo que
significa la primera l&iacute;nea (las otras son similares):

<dl>
<dt>&quot;192.168.1.40:2132&quot;
<dd>Indica la direcci&oacute;n IP de la m&aacute;quina que est&eacute;
usando NAT (192.168.1.40) en la LAN.  El n&uacute;mero del puerto que se
use para realizar la conexi&oacute;n (2132) se mostrar&aacute; a
continuaci&oacute;n.
</dl>

<dl>
<dt>&quot;24.5.0.5:53136&quot;
<dd>Indica que la conexi&oacute;n se dirige hacia Internet a
trav&eacute;s de la direcci&oacute;n 24.5.0.5, usando el puerto 53136.
</dl>

<dl>
<dt>&quot;65.42.33.245:22&quot;
<dd>La direcci&oacute;n IP y el puerto al que se conecta.
</dl>

<dl>
<dt>&quot;TIME_WAIT:TIME_WAIT&quot;
<dd>Indica el estado en que PF cree que se encuentra la conexi&oacute;n
TCP.
</dl>

<p>
<a name="nat3.2"></a>
<b>Consideraciones sobre FTP y NAT</b>

<p>
Existen unas cuantas limitaciones de NAT a tener en cuenta, de las
cuales la m&aacute;s com&uacute;n es con FTP.  FTP se puede usar de dos
modos:  pasivo y activo;  de &eacute;stos, FTP pasivo est&aacute;
considerado como el m&aacute;s seguro en la mayor&iacute;a de los casos.

<p>
Con FTP activo, cuando un usuario se conecta a un servidor de FTP remoto
y pide un fichero o informaci&oacute;n, el cliente de FTP env&iacute;a
al servidor un n&uacute;mero de puerto aleatorio en el que el servidor
establecer&aacute; una conexi&oacute;n para el cliente y por el que
tranmitir&aacute; la informaci&oacute;n requerida.  Esto supone un
problema para los usuarios que intenten acceder a servidores de FTP
desde dentro de la misma red interna.  Cuando el servidor de FTP
env&iacute;a su informaci&oacute;n, la env&iacute;a al NIC externo y a
un puerto aleatorio.  La m&aacute;quina de NAT la recibe, pero debido a
que no tiene asignaciones para el paquete desconocido ni para este
puerto, bloquea el paquete y no lo entrega.

<p>
Con el modo pasivo de FTP (el predeterminado en el cliente de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">
ftp(1)</a> en OpenBSD), el cliente realiza una petici&oacute;n para que
el servidor escoja un puerto aleatorio, y se mantiene a la escucha por
ese puerto en espera de recibir los datos de conexi&oacute;n.  El
servidor informa al cliente del puerto que ha elegido, y el cliente se
conecta a ese puerto para transferir los datos.  Esto,
desafortunadamente, no siempre es posible ni deseable.  ftp(1) usa este
modo por definici&oacute;n;  para forzar el uso del modo activo de FTP
hay que usar el indicador <i>-A</i> con la orden de <kbd>ftp</kbd>, o
desactivar el modo pasivo mediante la orden

<blockquote><pre>
passive off
</pre></blockquote>

<p>
desde el punto de inserci&oacute;n <i>ftp&gt;</i>.

<p>
PF dispone de otra soluci&oacute;n para este caso, redireccionando el
tr&aacute;fico de FTP a trav&eacute;s de un servidor <i>proxy</i> de
FTP, un proceso que &laquo;gu&iacute;a&raquo; el tr&aacute;fico de FTP a
trav&eacute;s de los filtros.  El <i>proxy</i> de FTP utilizado por
OpenBSD y PF es
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.3">ftp-proxy(8)</a>.
Para activarlo hay que a&ntilde;adir al fichero <tt>/etc/pf.conf</tt>
algo parecido a esto:

<blockquote><pre>
rdr on tl0 proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>

<p>
En pocas palabras, esta l&iacute;nea significa que el
&laquo;tr&aacute;fico por el puerto 21 de TCP en la interfaz interna se
redirecciona al servidor de proxy que hay funcionando en esta
m&aacute;quina y que est&aacute; a la escucha por el puerto 8021&raquo;.

<p>
Con suerte, es f&aacute;cil ver que el servidor de proxy se debe iniciar
y ejecutar en la m&aacute;quina OpenBSD, lo que se hace introduciendo la
siguiente l&iacute;nea en el fichero <tt>/etc/inetd.conf</tt>:

<blockquote><pre>
127.0.0.1:8021 stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
</pre></blockquote>

<p>
y reiniciando el sistema o enviando una se&ntilde;al 'HUP' a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>.
Una modo de enviar esta se&ntilde;al 'HUP' es mediante la orden:

<blockquote><pre>
kill -HUP `cat /var/run/inetd.pid`
</pre></blockquote>

<p>
N&oacute;tese que ftp-proxy quedar&aacute; a la escucha por el puerto
8021, el mismo puerto al que rdr estaba enviando el tr&aacute;fico de
FTP.  Hemos escogido el puerto 8021 de forma arbitraria, aunque 8021 es
una buena elecci&oacute;n ya que no est&aacute; asignado para ninguna
otra aplicaci&oacute;n.

<p>
<a name="nat3.3"></a>
<b>Redireccionamiento del tr&aacute;fico</b>

<p>
Con algunas aplicaciones es probable que haya que redireccionar el
tr&aacute;fico entrante o saliente para un cierto protocolo y/o puerto,
hacia una cierta m&aacute;quina que se encuentre detr&aacute;s del
sistema de filtros.  Un ejemplo de esto podr&iacute;a ser el caso de una
m&aacute;quina que se encontrara dentro de la red local y que tuviera un
servidor de <i>web</i> al que hubiera que acceder desde fuera (o, por
supuesto, por el ya consabido ftp-proxy(8)).  Las conexiones entrantes a
nuestra IP v&aacute;lida de Internet se encontrar&aacute;n con que, a
menos que la m&aacute;quina de NAT tambi&eacute;n tenga un servidor de
<i>web</i>, no pondr&aacute;n conectarse.  Para ello usaremos la
directiva 'rdr' de NAT en el fichero de reglas, a fin de dar las
instrucciones sobre hacia d&oacute;nde se debe redireccionar una
conexi&oacute;n concreta.

<p>
Para nuestro ejemplo, supongamos que un servidor de <i>web</i> reside en
la LAN y que su direcci&oacute;n IP es 192.168.1.80.  El fichero de
reglas de NAT necesita una nueva directiva para gestionar esta
situaci&oacute;n.  Hay que a&ntilde;adir una l&iacute;nea parecida a la
siguiente en el fichero <tt>/etc/pf.conf</tt>:

<blockquote><pre>
rdr on fxp0 proto tcp from any to any port 80 -&gt; 192.168.1.80 port 80
</pre></blockquote>

<p>
Desglosando esta l&iacute;nea para ver qu&eacute; signfica cada
componente de ella:

<dl>
<dt>&quot;rdr&quot;
<dd>Es la orden que le est&aacute; pasando a NAT.  Indica a NAT que lo
que viene a continuaci&oacute;n es una entrada para redireccionar una
conexi&oacute;n.
</dl>


<dl>
<dt>&quot;on fxp0&quot;
<dd>Es la interfaz de red que est&aacute; conectada a Internet.
</dl>

<dl>
<dt>&quot;from any to any&quot;
<dd>Indica cu&aacute;l es la direcci&oacute;n IP que hay que
redireccionar (cualquiera de las que entren en fxp0, como se indica
anteriormente, con cualquier IP como destino).
</dl>

<dl>
<dt>&quot;port 80&quot;
<dd>&Eacute;ste es el puerto (80) entrante que debe ser redireccionado.
No es estrictamente necesario indicar el puerto con el n&uacute;mero
&laquo;80&raquo;, tambi&eacute;n se podr&iacute;a indicar como
&laquo;port www&raquo; para especificar una redirecci&oacute;n del
puerto 80.  Si se quiere usar un nombre en lugar de un n&uacute;mero, el
nombre del servicio y el puerto correspondiente deben existir en el
fichero <tt>/etc/services</tt>.
</dl>

<dl>
<dt>&quot;192.168.1.80 port 80&quot;
<dd>La direcci&oacute;n IP de la m&aacute;quina LAN a la que son
redireccionados los paquetes.  N&oacute;tese que el puerto de destino NO
tiene porqu&eacute; coincidir con el puerto entrante.  Por ejemplo, lo
siguiente es v&aacute;lido e incluso puede ser &uacute;til:
<pre>
rdr on fxp0 proto tcp from any to any port 8080 -&gt; 192.168.1.35 port 80
</pre>
Esta l&iacute;nea redireccionar&iacute;a el tr&aacute;fico entrante en
el puerto 8080 a un servidor de <i>web</i> de una m&aacute;quina en la
red interna, en el puerto 80.
</dl>

<p>
Cuando hayamos terminado de a&ntilde;adir todos los datos, recargaremos
las reglas de NAT y el redireccionamiento comezar&aacute; de inmediato.

<p>
<b>Denegaci&oacute;n</b>

<p>
En ocasiones es necesario aplicar excepciones a una regla de
redireccionamiento de NAT.  Un ejemplo de esto ser&iacute;a <i>AOL
Instant Messenger</i>, que suele escabullirse de los cortafuegos a
trav&eacute;s de cualquier puerto disponible.  Es posible que ftp-proxy
interfiera con AIM cuando decide salir por el puerto remoto 21.  Si
alguien que esto puede ser malo (muchas personas pierden bastante tiempo
intentando bloquear AIM), se pueden excluir las direcciones IP utilizada
por los servidores AIM del tr&aacute;fico redireccionado por nuestra
l&iacute;nea de ftp-proxy anterior.  Para ello, se usar&aacute; la
siguiente regla:

<blockquote><pre>
rdr on tl0 proto tcp from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>

<p>
Interpretaci&oacute;n: redireccionar el tr&aacute;fico que entra en tl0
con direcci&oacute;n al puerto 21, pero NO por 64.12.163.199 (por el que
los usuarios del servidor de AIM ten&iacute;an problemas) al puerto 8021
del anfitri&oacute;n local (en donde se supone que estar&aacute;
esperando ftp-proxy).  Pero avisamos que existen muchos servidores de
AIM;  si alguien est&aacute; interesado en esta aplicaci&oacute;n, es
probable que tenga que jugar con estas direcciones IP (64.12.0.0/16
puede ser m&aacute; productiva, aunque es probable que tambi&eacute;n
interfiera con algunos sitios que no sean de AOL).

<p>
<a name="nat3.4"></a>
<b>NAT frente a proxy</b>

<p>
La diferencia entre NAT y una aplicaci&oacute;n basada en <i>proxy</i>
es que el software de <i>proxy</i> act&uacute;a como un intermediario
entre Internet y las m&aacute;quinas conectadas a la LAN.  En
prinicipio, esto no representa ning&uacute;n problema;  sin embargo,
cada aplicaci&oacute;n que se quiera ejecutar en la m&aacute;quina y
conectarla a Internet a trav&eacute;s del servidor de <i>proxy</i>, DEBE
reconocer el <i>proxy</i> (ser capaz de usarlo).  No todas las
aplicaciones son capaces de esto (en especial los juegos).  A&uacute;n
m&aacute;s, no existen aplicaciones para servidores de <i>proxy</i> para
todos los servicios de Internet.  NAT asigna la red interna de un modo
transparente, para que sea posible conectares a Internet.  La
&uacute;nica ventaja de seguridad que proxy tiene sobre NAT es que el
software de <i>proxy</i> puede haber sido programado para funciones de
seguridad, y puede filtrar de acuerdo con el contenido a fin de evitar
que una macro de virus se interne en la m&aacute;quina Windows, o
proteger los programas contra desbordamientos de la memoria intermedia
(<i>buffer overflows</i>) y otros peligros.  El mantenimiento de estos
filtros es, con frecuencia, un trabajo muy pesado.

<p>
<a name="nat3.5"></a>
<b>Redireccionamiento y reflexi&oacute;n</b>

<p>
Con frecuencia, las reglas de redireccionamiento se usan para reenviar
conexiones entrantes desde Internet hacia un servidor local con una
direcci&oacute;n privada en la LAN, como en:

<pre>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server port 80
</pre>

<p>
Pero cuando se comprueba la regla de redireccionamiento desde un cliente
en la LAN, no funciona.  El motivo es que las reglas de
redireccionamiento s&oacute;lo son aplicables a los paquetes que pasan a
trav&eacute;s de la interfaz especificada (<tt>$ext_if</tt>, la interfaz
externa en el ejemplo).  Sin embargo, el conectarse a la
direcci&oacute;n externa del cortafuegos desde un anfitri&oacute;n en la
LAN no significa que los paquetes vayan a pasar a trav&eacute;s de su
interfaz externa.  La pila TCP/IP del cortafuegos compara la
direcci&oacute;n de destino de los paquetes entrantes con su propia
direcci&oacute;n y sus alias, y detecta las conexiones a si misma tan
pronto como pasan la interfaz interna.  Estos paquetes no pasan de
f&iacute;sicamente por la interfaz interna, y la pila no simula un pase
de este tipo de nin&uacute;n modo.  pf nunca ve estos paquetes en la
interfaz externa, y la regla de redireccionamiento especificando la
interfaz interna, no es aplicable.

<p>
Al a&ntilde;adir una segunda regla de redireccionamiento para la
interfaz interna no surte el efecto deseado.  Cuando el cliente local se
conecta a la direcci&oacute;n externa del cortafuegos, el paquete
inicial del saludo de conexi&oacute;n de TCP (<i>TCP handshake</i>)
llega al cortafuegos a trav&eacute;s de la interfaz interna.  La regla
de redirecci&oacute;n es entonces aplicable y la direcci&oacute;n de
destino se sustituye con la del servidor interno.  El paquete se
reenv&iacute;a de vuelta a trav&eacute;s de la interfaz interna y llega
al servidor interno.  Pero la direcci&oacute;n de origen no se ha
traducido y todav&iacute;a contiene la direcci&oacute;n local del
cliente, por lo que el servidor env&iacute;a sus respuestas directamente
al cliente.  El cortafuegos nunca llega a ver la respuesta y por lo
tanto no tiene la oportunidad de invertir correctamente la
traducci&oacute;n.  El cliente recibe una respuesta desde una fuente que
no esperaba, por lo que la bloquea, falla el saludo de conexi&oacute;n
de TCP, y no se llega a establecer ninguna conexi&oacute;n.

<p>
Aun as&iacute;, con frecuencia es deseable que los clientes en la LAN se
conecten al mismo servidor interno como clientes externos, de forma
transparente.  Existen varias soluciones para este problema:

<p>
<b>Dividir el horizonte de DNS</b>
<p>
Es posible configurar los servidores de DNS para que respondan a
requerimientos de anfitriones locales de forma diferente que a
requerimientos externos, para que los clientes locales reciban la
direcci&oacute;n interna del servidor durante la resoluci&oacute;n del
nombre.  Entonces se conectar&aacute;n directamente al servidor local, y
el cortafuegos no formar&aacute; parte en modo alguno.  De este modo se
reduce el tr&aacute;fico local, ya que los paquetes no tienen que ser
enviados a trav&eacute;s del cortafuegos.

<p>
<b>Trasladar el servidor a una red local separada</b>
<p>
Al a&ntilde;adir una interfaz de red adicional al cortafuegos y
trasladar el servidor local desde la red del cliente a una red dedicada
(DMZ), se permite el redireccionamiento de las conexiones desde clientes
locales del mismo modo que el redireccionamiento de conexiones externas.
El uso de redes separadas tiene varias ventajas, incluida la mejora de
la seguridad mediante el aislamiento del servidor del resto de los
anfitriones locales.  Si alguna vez se comprometiera el servidor (que en
nuestro caso es accesible desde Internet), no podr&iacute;a acceder a
otros anfitriones locales de forma directa, ya que todas las conexiones
tienen que pasar a trav&eacute;s del cortafuegos.

<p>
<b>TCP proxying</b>
<p>
Se puede configurar una proxy de TCP en el cortafuegos, bien a la
escucha en el puerto de reenv&iacute;o o bien redireccionando las
conexiones de la interfaz interna al puerto por el que est&eacute; a la
escucha.  Cuando un cliente local se conecta al cortafuegos, la proxy
acepta la conexi&oacute;n, establece una segunda conexi&oacute;n al
servidor interno, y reenv&iacute;a los datos entre esas dos conexiones.

<p>
Se puede crear una proxy simple usando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
y <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1">nc(1)</a>.
La siguiente entrada de <tt>/etc/inetd.conf</tt> crea un conector
(<i>socket</i>) vinculado a la direcci&oacute;n de circuito cerrado
(<i>loopback</i>) y al puerto 5000.  Las conexiones se reenv&iacute;an
al puerto 80 del servidor 192.168.1.10.

<pre>
127.0.0.1:5000 stream tcp wait nobody /usr/bin/nc nc -w 20 192.168.1.10 80
</pre>

<p>
La siguiente regla de redireccionamiento reenv&iacute;a el puerto 80 de
la interfaz interna a la proxy:

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; 127.0.0.1 port 5000
</pre>

<p>
<b>Combinaci&oacute;n de RDR y NAT</b>
<p>
Con una regla adicional de NAT en la interfaz interna se puede obtener
la traducci&oacute;n de la direcci&oacute;n de origen que falta y que se
ha descrito anteriormente.

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; $server
no nat on $int_if proto tcp from $int_if to $int_net
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; $int_if
</pre>

<p>
Esto har&aacute; que el paquete inicial desde el cliente sea traducido
de nuevo cuando se reenv&iacute;e de vuelta a trav&eacute;s de la
interfaz interna, sustituyendo la direcci&oacute;n de origen del cliente
con la direcci&oacute;n interna del cortafuegos.  El servidor interno
enviar&aacute; un respuesta de vuelta al cortafuegos, que puede invertir
las traducciones de NAT y RDR cuando lo reenv&iacute;e al cliente local.
Esta construcci&oacute;n es algo compleja, ya que crea dos estados
separados por cada conexi&oacute;n reflectada.  Hay que tener cuidado de
evitar que la regla de NAT sea aplicable a otro tr&aacute;fico, por
ejemplo a conexiones que provengan de anfitriones externos (a
trav&eacute;s de otros redireccionamientos) o del mismo cortafuegos.
N&oacute;tese que la regla de rdr anterior har&aacute; que la pila
TCP/IP vea los paquetes que lleguen a la interfaz interna con una
direcci&oacute;n de destino de dentro de la red interna.  Para evitar
que la pila lance mensajes de redireccionamiento de ICMP (indicando al
cliente que puede alcanzar su destino directamente y rompiendo la
reflexi&oacute;n), se puede desactivar los redireccionamientos en la
pasarela usando

<pre>
# <strong>sysctl -w net.inet.ip.redirect=0</strong>
</pre>

<p>
En general, se deber&iacute;an utilizar las soluciones que se han
mencionado.

<p>
<a name="nat4.0"></a>
<b>6.3.4 Enlaces y referencias</b>

<p>
Ficheros de OpenBSD:
<ul>
<li><tt>/etc/pf.conf</tt> - fichero de reglas de PF/NAT
<li><tt>/etc/rc.conf</tt> - fichero de configuraci&oacute;n general de
inicio del sistema que hay que editar para iniciar NAT y PF durante el
arranque del sistema
<li><tt>/etc/sysctl.conf</tt> - fichero para activar el reenv&iacute;o
de IP (<i>IP forwarding</i>)
</ul>

<p>
Enlaces sobre NAT en Internet:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">p&aacute;gina del manual de pf.conf</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.3">p&aacute;gina del manual de pfctl</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">
http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>

<p>
<font color="#0000e0">
<a href="index.html">[&Iacute;ndice de documentos]</a>
<a href="faq5.html">[Secci&oacute;n 5 - Compilaci&oacute;n del sistema
con el c&oacute;digo fuente]</a>
<a href="faq7.html">[Secci&oacute;n 7 - Controles de teclado y
pantalla]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq6pf.html,v 1.1 2003/05/05 22:02:49 nick Exp ]<br>
$OpenBSD: faq6pf.html,v 1.1 2003/05/06 21:22:24 jufi Exp $<br>
$Translation: faq6pf.html,v 1.2 2003/05/06 18:07:59 horacio Exp $
</small>

</body>
</html>
