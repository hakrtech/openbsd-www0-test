<html>
<head>
<title>6.0 - Redes</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 1998-2000 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000" link="#23238E">

<img alt="[OpenBSD]" height="30" width="141" src="../../images/smalltitle.gif">
<p>
<h2><font color="#e00000">6.0 - Redes</font><hr></h2>
</p>

<p>
<ul><h3>Tabla de Contenidos</h3>
<li><a href="#6.0.1">6.0.1 - Introducci&oacute;n</a>
<li><a href="#6.1">6.1 - Configuraci&oacute;n inicial de la red</a>
<li><a href="#6.2">6.2 - Filtros IP</a>
<li><a href="#6.3">6.3 - Traducci&oacute;n de Direcciones de Red
    (NAT)</a>
<li><a href="#6.4">6.4 - Protocolo de Configuraci&oacute;n para
    H&uacute;espedes Din&aacute;micos
    (DHCP)</a>
<li><a href="#6.5">6.5 - Protocolo Punto a Punto (PPP)</a>
<li><a href="#6.6">6.6 - Afinar Par&aacute;metros de Red</a>
<li><a href="#6.7">6.7 - Usar NFS</a>
<li><a href= "#6.8">6.8 - Servicio de Nombres de Dominio  - DNS, BIND,
    y named</a>
</ul>
</p>
<hr>

<br>
<p>
<a name="6.0.1"></a>
<h2>6.0.1 - Introducci&oacute;n</h2>
<p>
Para la comprensi&oacute;n de la mayor parte de este documento
ser&aacute; de gran ayuda que haya leido y, por lo menos, asimilado en
parte el cap&iacute;tulo
<a href="faq5.html">&laquo;Configuraci&oacute;n del N&uacute;cleo&raquo;</a> 
de las Preguntas Frecuentes, y las p&aacute;ginas de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&apropos=0&sektion=8&format=html">ifconfig(8)</a> 
y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">netstat(1)</a>.

<p>
Si es Vd. un administrador de redes y est&aacute; configurando
protocolos de enrutamiento, si est&aacute; usando su sistema OpenBSD
como un enrutador, si necesita conocer m&aacute;s a fondo los
protocolos de redes IP, entonces es realmente necesario que lea
<a href="http://www.3com.com/nsc/501302s.html">Understanding IP addressing</a>.
&Eacute;ste es un documento excelente que contiene conocimientos
fundamentales sobre redes de IP.

<p>
Si est&aacute; trabajando con aplicaciones como servidores de http,
servidores de ftp, y servidores de correo, se puede beneficiar en gran
medida de la lectura de los
<a href="http://www.nexor.com/info/rfc/index/rfc.htm?index/rfc.html">RFC</a>

<p>
<i>(Nota: existe un proyecto de traducción de RFCs al castellano
conocido como
<a href="http://www.arrakis.es/~pjleon/rfc-es/index.html">RFC-ES</a>)</i>

<p>
Por supuesto que no podr&aacute; leerlos todos, as&iacute; que elija
algunos temas en los que est&eacute; interesado, o que puedan serle
&uacute;tiles en su entorno de trabajo.  Los RFC definen
much&iacute;simas (miles) de las normativas para protocolos en internet
y c&oacute;mo se supone que deben funcionar.

<a name="6.1"></a>
<h2>6.1 - Configuraci&oacute;n Inicial de la Red</h2>

<ul>Tabla de Contenidos
   <li><a href="#6.1.1">6.1.1 - Idenficaci&oacute;n y
       Configuraci&oacute;n de las Interfaces de Red</a></li>
   <li><a href="#6.1.2">6.1.2 - Configuraci&oacute;n del Sistema
       OpenBSD como Pasarela</a></li>
   <li><a href="#6.1.3">6.1.3 - Configuraci&oacute;n de los Alias en
       una Interfaz de Red</a>
</ul>

<p>
<a name="6.1.1"></a>
<h3>6.1.1 - Idenficación y Configuración de la Interfaces de Red</h3>
</p>

<p>
Lo primero que debe hacer para empezar es identificar su interfaz de red.
En OpenBSD las interfaces se designan por el tipo de tarjeta, no por el tipo
de conexión.
Puede ver su tarjeta de red iniciar durante el arranque, o después del
arranque usando la orden <strong>dmesg(8)</strong>.
También puede ver su interfaz de red usando la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>.
Por ejemplo, vea a continuación la salida originada por dmesg para una 
tarjeta de red ne2k, que usa un nombre de dispositivo ne.
</p>

<ul>
<pre>
ne3 at pcmcia1 function 0 "Linksys, EtherFast 10/100 PC Card (PCMPC100), " port 0x340/16 irq 9
ne3: address 00:e0:98:04:95:ba
</pre>
</ul>

<p>
Si no sabe cuál es el nombre de su dispositivo, aquí tiene una lista de
tarjetas comunes con sus nombres de dispositivo.
</p>

<ul>
<li>ne2000 Network Cards - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ne&sektion=4&format=html">ne</a> 
<li>3Com EtherLink III and Fast EtherLink III Ethernet - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&sektion=4&format=html">ep</a>
<li>3Com EtherLink XL and Fast EtherLink XL Ethernet (3C9xx) - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xl&sektion=4&format=html">xl</a>
<li>Intel 82586 chip Ethernet device driver - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ie&sektion=4&format=html">ie</a>
<ul>Que incluyen tarjetas como:
	<li>3Com 3C507
	<li>AT&amp;T StarLAN 10
	<li>AT&amp;T EN100
	<li>AT&amp;T StarLan Fiber
	<li>Intel EtherExpress 16
</ul>

<li>Controlador DEC/Intel 21142/3 y cl&oacute;nico 10/100 Ethernet - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dc&sektion=4&format=html">dc</a>

<ul>
Que incluye tarjetas como: <b>Nota:</b> Algunos controladores que
estaban en OpenBSD 2.6, como mx, ax, al y pn, han sido substituidos por
este controlador.

   <li>Intel 21142/21143 (antes fabricado por DEC)
   <li>Macronix 98713, 98713A, 98715, 98715A y 98725
   <li>Davicom DM9100 y DM9102
   <li>ASIX Electronics AX88140A y AX88141
   <li>ADMtek AL981 Comet y AN985 Centaur
   <li>Lite-On 82c168 y 82c169 PNIC
   <li>Lite-On/Macronix 82c115 PNIC II

<p>
Cualquier referencia en /etc/ifaliases, /etc/ipf.rules, o
/etc/ipnat.rules a los nombres de interfaz antiguos mx, al, ax, o pn, se
debe substituir por dc.  Adem&aacute;s, cualquier fichero hostname.xxx
con las extensiones de interfaz antiguas, se debe renombrar a
hostname.dcX para que pueda ser reconocido.  Substituya X con el
n&uacute;mero de la interfaz.
</ul>
</ul>

<p>
También puede comprobar qué interfaces han sido identificadas usando la
utilidad <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>.
He aquí la salida que mostraría un dispositivo ne2k.
</p>

<ul>
<pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8009&lt;UP,LOOPBACK,MULTICAST&gt;
        inet 127.0.0.1 netmask 0xff000000
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt;
ne3: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
tun0: flags=10&lt;POINTOPOINT&gt;
tun1: flags=10&lt;POINTOPOINT&gt;
enc0: flags=0&lt;&gt;
bridge0: flags=0&lt;&gt;
bridge1: flags=0&lt;&gt;
</pre>
</ul>

<p>
Como habrá podido comprobar, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a> 
muestra mucha más información de la que necesitamos en este momento.
Pero lo importante aquí es que nos permite ver nuestra interfaz.
En el ejemplo anterior, la tarjeta de la interfaz ya está configurada.
Esto se sabe al ver que los valores ya han sido fijados en 
&quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;, y que los
indicadores <strong>UP</strong> y <strong>RUNNING</strong> están activados.
También podrá notar muchas otras interfaces.
A continuación puede ver una lista de interfaces que se supone que deben
estar ahí.
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&sektion-4&format=html">lo*</a> - Interfaz Loopback
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&sektion=4&format=html">sl*</a> - Interfaz de Red Slip
<li>ppp* - Protocolo Punto a Punto
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&sektion=4&format=html">tun*</a> - Interfaz de Red Tunnel
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4&format=html">enc*</a> - Interfaz de Encapsulamiento
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4&format=html">bridge*</a> - Interfaz Puente Ethernet
</ul>

<p>
Si su interfaz no ha sido configurada, el primer paso será crear el fichero
<strong>/etc/hostname.${IF}</strong>, donde el nombre de su interfaz
substituirá ${IF}.
De acuerdo con la información de los ejemplos anteriores, el nombre sería
<strong>/etc/hostname.ne3</strong>.
La composición de este fichero es como sigue a continuación.
Para leer más sobre el formato de este fichero, tome como referencia la
página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html">hostname.if(5)</a>
</p>

<ul>
<pre>
[address_family] [your_ip] [your_netmask] [media options]
</pre>
</ul>

<p>
Por lo tanto, para el ejemplo anterior, un nombre correcto sería parecido a
este:
</p>

<ul>
<pre>
$ <strong>cat /etc/hostname.ne3</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre>
</ul>

<p>
El siguiente paso será la configuración de su pasarela.
Para ello basta con que ponga el IP de su pasarela en el fichero
<strong>/etc/mygate</strong>.
Esto permitirá que su pasarela se active en el momento del arranque.
A continuación deberá configurar sus nombres de servidores
(&quot;nameservers&quot;) y su fichero <strong>/etc/hosts</strong>.
Para configurar sus nombres de servidores debe crear un fichero con el nombre
<strong>/etc/resolv.conf</strong>.
Puede leer más sobre el formato de este fichero en la página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">resolv.conf(5)</a>.
El siguiente ejemplo es para un uso típico.
En este ejemplo sus servidores de dominio son 125.2.3.4 y 125.2.3.5.
También pertenece al dominio &laquo;sudominio.dom&raquo;.
</p>

<ul>
<pre>
$ <strong>cat /etc/resolv.conf</strong>
search sudominio.dom
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre>
</ul>

<p>
Desde este punto ya puede reiniciar o bien ejecutar el guión de configuración
<strong>/etc/netstart</strong>.
Puede hacerlo escribiendo (como root):
</p>

<ul>
<pre>
$ <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre>
</ul>

<p>
Fíjese en que se producen un pequeño número de errores, pero éstos se
refieren a la interfaz de loopback.
Por lo tanto puede ignorar estos errores.
A partir de aquí su sistema debería funcionar correctamente.
Puede hacer una comprobación con 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>
para asegurarse de que su interfaz se configuró correctamente.
También puede comprobar sus rutas con <strong>netstat(1)</strong> o
<strong>route(8)</strong>.
A continuación puede ver un ejemplo de cómo ver sus tablas de rutas usando
ambas herramientas.
</p>

<ul>
<pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  ne3
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  ne3
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  ne3
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)
$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre>
</ul>

<p>
<a name="6.1.2"></a>
<h3>6.1.2 - Configuración del Sistema OpenBSD como Pasarela</h3>
</p>

<p>
Ésta es la información básica que necesita para configurar su sistema OpenBSD
como una pasarela (también llamada &laquo;enrutador&raquo; o
&laquo;encaminador&raquo;).
Si piensa usar OpenBSD como un enrutador en Internet, le sugerimos que lea
también la sección con las instrucciones sobre la configuración de
<a href="#6.2">Filtros IP</a>, para bloquear tráfico potencialmente
malicioso.
Además, debido a la escasa disponibilidad de direcciones IPv4 en los
proveedores de servicios de redes y registros regionales, es conveniente
leer la sección sobre <a href="#6.3">NAT</a> para información sobre cómo
conservar su espacio de dirección IP.
</p>

<p>
El núcleo GENERIC posee la capacidad de permitir IP Forwarding, pero debe ser
activado.
Para ello debe usar la utilidad <strong>sysctl(8)</strong>.
Para que los cambios sean permanentes, debe editar el fichero
<strong>/etc/sysctl.conf</strong> para habilitar IP Forwarding.
Esto lo puede llevar a cabo añadiendo la siguiente línea en ese fichero de
configuración.
</p>

<ul>
<pre>
net.inet.ip.forwarding=1
</pre>
</ul>

<p>
Para que este cambio surja efecto sin tener que reiniciar el sistema, use
directamente la utilidad <strong>sysctl(8)</strong>.
Recuerde que este cambio todavía no existirá después de reiniciar, y que
necesitará ser ejecutado como root.
</p>

<ul>
<pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre>
</ul>

<p>
A continuación modifique las rutas en los otros huéspedes de ambos lados.
OpenBSD ofrece muchas posibilidades de uso como enrutador, usando software
como 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&apropos=0&sektion=8&format=html">routed(8)</a>, <a href="http://www.gated.org">gated</a>, 
<a href="http://www.mrtd.net">mrtd</a>, y 
<a href="http://www.zebra.org">zebra</a>.
OpenBSD dispone de soporte para gated y mrtd en la colección de portes.
OpenBSD incluye soporte para varias interfaces T1, HSSI, ATM, FDDI, Ethernet,
e interfaces de serie (PPP/SLIP).
</p>

<p>
<a name="6.1.3"></a>
<h3>6.1.3 - Configuración de Alias en una Interfaz.</h3>
</p>

<p>
OpenBSD dispone de un simple mecanismo para configurar alias de ip en una
interfaz.
Para ellos sólo tiene que editar el fichero <i>/etc/ifaliases</i>.
El guión <i>/etc/rc</i>, que forma parte de la 
<a href="faq10.html#10.3">jerarquía de inicio rc</a>, leerá este fichero
durante el proceso de inicio del sistema.
Por ejemplo, supongamos que el usuario tiene una interfaz <b>dc0</b> y
pertenece a la red 192.168.0.0.
Otra información de importancia:
</p>

<ul>
<li>IP para dc0 es 192.168.0.2
<li>NETMASK es 255.255.255.0
</ul>

<p>
El formato del fichero <i>/etc/ifaliases</i> es:
</p>

<ul>
<pre>
[interface] [ip address] [netmask]
</pre>
</ul>

<p>
Unas notas sobre los alias:  en OpenBSD sólo se usa el nombre de la interfaz;
no existen diferencias entre el primer alias y el segundo, por lo tanto, a
diferencia de otros sistemas operativos, no hay que referirse a ellos como
dc0:0 y dc0:1;  asegúrese también de que su netmask para el alias <b>NO</b>
sea el mismo que para el ip actual de la interfaz.
En este ejemplo de <i>/etc/ifaliases</i>, añadiremos dos alias al dispositivo
<b>dc0</b>.
</p>

<ul>
<pre>
$ <b>cat /etc/ifaliases</b>
dc0	192.168.0.3	255.255.255.255
dc0	192.168.0.4	255.255.255.255
</pre>
</ul>

<p>
<b>NOTA</b>:<br>

A partir de OpenBSD 2.7, puede configurar los alias en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html"><i>/etc/hostname.*</i></a>.
Para realizar la misma configuraci&oacute;n que arriba, tendr&iacute;a
un fichero <i>/etc/hostname.dc0</i> que estar&iacute;a estructurado del
siguiente modo:
</p>

<ul>
<pre>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255 NONE
inet alias 192.168.0.4 255.255.255.255 NONE
</pre>
</ul>

<p>
Una vez que haya configurado este fichero será necesario reiniciar para que
los cambios funcionen.
Sin embargo, puede hacer efectivos los alias a mano, usando la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>.
Para hacer efectivo el primer alias use la orden:
</p>

<ul>
<pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre>
</ul>

<p>
Para ver estos alias debe usar la orden:
</p>

<ul>
<pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre>
</ul>


<p>
<a name="6.2"></a>
<h2>6.2 - Filtros IP</h2>
</p>

<p>
El paquete IP Filter se creó con el fin de gestionar dos tareas, tratar con
permisos <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=8&format=html">ipf(8)</a>
para el envío a nivel de paquetes y asignar huéspedes/subrredes a un campo de
direcciones externas <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&apropos=0&sektion=8&format=html">ipnat(8)</a>.
Los ficheros de configuración para estos dos servicios son /etc/ipf.rules y
/etc/ipnat.rules.
</p>

<p>
Para activarlos durante el inicio del sistema es necesario editar
/etc/rc.conf.
También es necesario tener la línea net.inet.ip.forwarding=1 en
/etc/sysctl.conf (o el núcleo de su sistema necesita tener activada la opción
IPFORWARDING o GATEWAY).
Y también se necesita un núcleo compilado con las opciones IPFILTER y
IPFILTER_LOG (los núcleos GENERIC no disponen de estas opciones).
</p>

<p>
Si ha compilado IP Filter en su núcleo pero no lo ha activado en el fichero
/etc/rc.conf, lo puede activar fácilmente.

<ul>
<pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre>
</ul>

<p>
El indicador <tt>-E</tt> en ipf 'activa' IP Filter.
El indicador <tt>-Fa</tt> limpia cualquier regla que pueda tener ahí.<br>
<tt>-f /etc/ipf.rules</tt> carga las reglas desde /etc/ipf.rules.

<p>
Si hace algún cambio en /etc/ipf.rules después de haber cargado ipf, puede
recargar sus reglas muy fácilmente.

<ul>
<pre>
# ipf -Fa -f /etc/ipf.rules
</pre>
</ul>

Lo mismo para ipnat...

<ul>
<pre>
# ipnat -CF -f /etc/ipnat.rules
</pre>
</ul>

<p>
A partir de aquí este documento cubrirá algunos aspectos básicos de
configuraciones de ipf y ipnat.
Existen muchos ejemplos para ipnat y ipf en /usr/share/ipf, le recomendamos
que escoja el que más se acerque a la configuración que Vd. desee, y que lo 
modifique conforme a sus necesidades.
Puede encontrar más información sobre Filtros IP en los archivos de la
<a href="http://false.net/ipfilter/">lista de correo IP Filter</a>, en las
<a href="http://coombs.anu.edu.au/~avalon/">páginas de IP Filter</a>, y en el
<a href="http://www.obfuscation.org/ipf/">IP Filter HOWTO</a>.
</p>

<p>
<h3>IPF</h3>
</p>

<p>
Para activar ipf desde el momento del inicio del sistema necesita modificar
/etc/rc.conf de modo que lea IPFILTER=YES.
IP Filter (ipf) está controlado por /etc/ipf.rules, que se leerá durante el
inicio.
Para una explicación más detallada lea la página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=5&format=html">ipf(5)</a>.
En los siguientes ejemplos, fxp0 representa la interfaz externa a internet.
En su caso puede ser diferente según el adaptador de ethernet de que disponga
en su máquina.
En estas reglas se asumirá que existe una conexión permanente a internet, del
mismo tipo que la de un servidor de web.
</p>

<p>
Las reglas de IP Filter se procesan de modo secuencial desde el principio
hasta el final, siendo de ayuda para visualizar cada paquete que tenga que
atravesar cada regla antes de alcanzar su destino.
</p>

<p>
Por ejemplo, el grupo de reglas predefinido permite que entren y salgan todos
los paquetes:

<ul>
<pre>
pass out from any to any 
pass in from any to any
</pre>
</ul>

Supongamos ahora que no queremos permitir ninguna conexión entrante por el
puerto 3306 (mysql) porque la base de datos sólo debería permitir la conexión
de forma local.
En este caso el grupo de reglas sería así:

<ul>
<pre>
pass out from any to any
pass in from any to any
block in on fxp0 from any to any port = 3306
</pre>
</ul>

Que traducido viene a decir lo siguiente: &laquo;bloquear todos los paquetes
entrantes desde cualquier sitio hasta cualquier sitio cuyo destino sea
3306&raquo;.
Lo que ocurriría es que un paquete destinado al puerto 3306 en la interfaz
fxp0 pasaría la primera regla &quot;pass in&quot;, y acto seguido sería
bloqueado por la regla &quot;block in port = 3306&quot;.
En el caso en que se invirtieran las reglas de entrada (recuerde que el orden
es importante)

<ul>
<pre>
pass out from any to any
block in on fxp0 from any to any port = 3306
pass in from any to any
</pre>
</ul>

los paquetes destinados al puerto 3306 pasarían debido a que la última regla
en el grupo permite que pasen todos los paquetes.
Cuando esté escribiendo reglas para el filtrado de paquetes es importante que
tenga en cuenta lo siguiente:
<b>La última regla que concuerde tendrá precedencia</b>.
</p>

<p>
Por supuesto que existen excepciones para toda regla.
La opción <em>quick</em> filtra el paquete en la primera regla que concuerde.
Veamos el defectuoso ejemplo anterior añadiéndole la opción <em>quick</em> a
la regla &quot;block in&quot;:

<ul>
<pre>
pass out from any to any
block in quick on fxp0 from any to any port = 3306
pass in from any to any
</pre>
</ul>

<p>
Un paquete destinado para el puerto 3306 será filtrado por la regla 
&quot;block in quick&quot; y bloqueado inmediatamente.
Todos los paquetes destinados a otros puertos no encontrarán una concordancia
en las reglas hasta llegar a la regla &quot;pass in&quot; que permite que
pasen todos los paquetes.
</p>

<b>Denegación Predefinida</b>

<p>
La política de filtrado de páquetes más segura es la de &laquo;denegación 
por definición&raquo;.
Esta política es mucho más segura que la denegación explícita de cada
servicio protegido, permite grupos de reglas más breves, y puede proteger de
un servicio que haya sido mal configurado de modo accidental y que haya
quedado expuesto.

<p>
Veamos ahora otro ejemplo de grupo de reglas real, seguido de una explicación
línea por línea.
El siguiente ejemplo es para un servidor de web con una política de
denegación predefinida que sólo permite conexiones ssh (para administración),
y conexiones http (puerto 80) y https (puerto 443).

<ul>
<pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from any to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
##############################
# end ruleset
##############################
</pre>
</ul>

<p>
Esto permitirá las conexiones desde cualquier sitio a los puertos 22 (ssh),
80 (http) y 443 (https).
Cualquier otro intento de conexión distinto será bloqueado, y permitirá todas
las conexiones salientes.
Este grupo de reglas es muy estricto.
Pero, ¿y si Vd. sólo quisiera permitir la conexión a ssh a huéspedes internos
en su bloque de direcciones 1.1.1.0, y al mismo tiempo permitir conexiones
externas a http y https?
</p>

<ul>
<pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
##############################
# end ruleset
##############################
</pre>
</ul>

Muy bien, pero, ¿y si sólo quisiera permitir la administración remota de su
servidor de web a una sola máquina (1.1.1.1)?
En tal caso cambiaría esta regla:

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
</pre>
</ul>

por esta otra:

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
</pre>
</ul>

IP Filter tiene soporte para formas de &quot;netmask address&quot; tanto CIDR
como de punto decimal.
Por tanto podría escribir lo anterior de esta forma:

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.1/255.255.255.255 to any port = 22
</pre>
</ul>

pero, ¿para qué?
</p>

<b>Ejemplos de Reglas</b>

<p>
He aquí algunas buenas reglas para que las pueda usar cualquier persona (se
asume que fxp0 es la interfaz externa conectada a interner).
Para empezar configuraremos una simple protección contra la falsificación de
direcciones.

<ul>
<pre>
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8
</pre>
</ul>

También es una buena idea separar su interfaz de loopback de sus otras
reglas.

<ul>
<pre>
pass out quick on lo0
pass in quick on lo0
</pre>
</ul>

Nuestro grupo de reglas empieza a tener buena pinta;  cuando lo ponemos todo
junto, esto es lo que vemos:

<ul>
<pre>
###########################
# begin ruleset
###########################
# loopback rules

pass out quick on lo0
pass in quick on lo0

# no permitir a nadie falsificar direcciones que no puedan ser enrutadas

block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# permitir la conexión por ssh sólo a nuestra máquina de administración

pass in quick on fxp0 from 1.1.1.1/32 to any port = 22

# permitir que otros usen http y https

pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443

# finalmente, cerrar el resto con una denegación por definición

block in quick on fxp0 from any to any

# y dejar pasar todo el tráfico saliente

pass out on fxp0 from any to any

#############################
# end ruleset
#############################
</pre>
</ul>
</p>

<b>Registro de Paquetes</b>

<p>
De momento va bastante bien, pero podría ir mejor.
¿Qué haríamos si quisiéramos obtener un registro de cualquier intento de
conexión al puerto 22 (ssh) que fuera por nuestro cortafuegos?
Sería fácil, IP Filter puede gestionar este caso con la opción clave 
<em>log</em>:

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
block in log quick on fxp0 from any to any port = 22
</pre>
</ul>

Esta regla permitirá la conexión remota por el puerto 22 a nuestra máquina de
administración, pero denegará y registrará cualquier otro intento de conexión
al puerto 22.
</p>

<b>Filtrado de Paquetes según el Protocolo</b>

<p>
IP Filter puede filtrar cualquier protocolo IP bas&aacute;ndose en su
n&uacute;mero o nombre en 
<a href=file://localhost/etc/protocols>/etc/protocols</a>.  Para que se
entienda con m&aacute;s claridad, s&oacute;lo trataremos aqu&iacute;
con tcp, udp, e icmp.  &Eacute;stos son los protocolos de uso
m&aacute;s com&uacute;n.  Todas las aplicaciones b&aacute;sicas de
internet dependen de la disponibilidad y de la correcta operatibilidad
de estos protocolos.
</p>

<p>
Para que ipf filtre según qué protocolo, se debe usar la opción clave 
<em>proto</em>.
Basándonos en el ejemplo anterior, y puesto que ssh funciona sobre tcp, sólo
deberíamos permitir la conexión a paquetes tcp.
Usando la opción clave <em>proto</em> para permitir sólo conexiones tcp,
obtendremos una regla como esta:

<ul>
<pre>
pass in quick on fxp0 proto tcp from 1.1.1.1/32 to any port = 22
</pre>
</ul>

Pero, ¿y si necesitáramos permitir conexiones a un servicio como bind que
funciona tanto sobre tcp como sobre udp?
En el caso de tcp/udp, IP Filter nos permite agrupar ambos protocolos en un
sólo (Nota: esto sólo es válido para tcp/udp).
Usando el ejemplo de bind, una regla que permita conexiones de tcp y udp en
un entorno de denegación por definición sería:

<ul>
<pre>
pass in quick on fxp0 proto tcp/udp from any to any port = 53
</pre>
</ul>
</p>

<b>Filtrado de Paquetes</b>

<p> 
Además de filtrar según el protocolo, IP Filter también puede gestionar
paquetes de IP fragmentados (un método común para bular filtros de paquetes).
Hay dos opciones claves posibles que se pueden usar para tratar paquetes de
ip fragmentados, <em>frag</em> para paquetes de IP fragmentados normales, o
<em>short</em> para paquetes de IP con cabeceras demasiado pequeñas para
poder compararlas.
Ya que, dependiendo de las condiciones de conexión, los paquetes fragmentados
pueden darse normalmente, es mejor filtrar sólo los paquetes con cabeceras
demasiado pequeñas como para obtener comparaciones válidas.
Esto se puede conseguir con la siguiente regla:

<ul>
<pre>
block in quick proto tcp all with short
</pre>
</ul>

¿Y qué hay de las Opciones de IP?
IP Filter también puede tratar con ese tipo de paquetes.
Los paquetes se pueden bloquear si tienen las opciones de IP activadas, o se
pueden bloquear según las opciones de IP que estén activadas.
Por ejemplo, la siguiente regla bloqueará y creará un registro de todos los
paquetes con las opciones de ip activadas.

<ul>
<pre>
block in log quick on fxp0 all with ipopts
</pre>
</ul>

Sin embargo, esto puede estropear algunas cosas como
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=traceroute&sektion=8&format=html">traceroute(8)</a>.
También es posible especificar qué opciones no serán permitidas.
Por ejemplo, una buena regla es la de bloquear todos los paquetes con
opciones de enrutamiento de fuentes.
Se puede llevar a cabo con esta regla:

<ul>
<pre>
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr
</pre>
</ul>

<b>Indicadores TCP, Conexiones Establecidas, y Mantenimiento del Estado</b>

<p>
La principal fuerza de IP Filter reside en su capacidad para filtrar paquetes
basándose en los indicadores TCP, y mantener conexiones establecidas y el
estado de la conexión.
Se recomienda a todos los usuarios que deseen filtrar paquetes basándose en
indicadores TCP que entiendan antes el papel que desempeña cada indicador.
Por ejemplo, si un usuario quisiera denegar la conexión a todos los paquetes
con los indicadores FIN, URG, y PSH activados (como por ejemplo un intento de
obtener la huella digital de un sistema operativo por nmap), podría usar una
regla como la siguiente:

<ul>
<pre>
block in quick on fxp0 proto tcp from any to any flags FUP
</pre>
</ul>

(Gracias a <a href=mailto:halogen@nol.net>Kyle Hargraves</a> por esa regla)
</p>

<p>
El próximo truco de IP Filter es su capacidad para &laquo;mantener el
estado&raquo;.
Se ha descrito mantener el estado como &laquo;no hablar hasta que no le
hablen&raquo;, o en otras palabras, una vez que se ha establecido una
conexión, los paquetes ya no tienen que atravesar grupos de reglas.
Ésta es una potente característica que permite escribir unas reglas mucho más
sencillas y seguras.
</p>

<p>
Por ejemplo, veamos cómo se puede aplicar este estado al ejemplo del grupo de
reglas anterior.
¿Todavía está confundifo?.
Revisémoslo: estamos permitiendo el acceso de gestión desde nuestra máquina 
de clase C al puerto 22 (ssh), y el acceso web a todo el tráfico a los
puertos 80 (http) y 443 (https).
Estamos bloqueando el resto de tráfico.
Pero, ¿y si quisiera conectar por ssh fuera del servidor de web? o,
¿y si necesitara usar lynx para buscar algo en las páginas de Preguntas
Frecuentes?
No podría, ya que habría bloqueado todas las conexiones entrantes que no
estuvieran dirigidas a los puertos especificados.
Aunque ésta es la ruta más segura, puede ser muy poco conveniente.
Al añadir las opciones clave <em>keep state</em> a la regla &quot;pass
out&quot;, puede permitir el paso de conexiones entrantes que sean respuestas
a conexiones que Vd. haya iniciado, como por ejemplo al navegar por la web.

<ul>
<pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any keep state
##############################
# end ruleset
##############################
</pre>
</ul>
</p>

<p>
Este peque&ntilde;o cambio supondr&aacute; un dram&aacute;tico
incremento en la flexibilidad y seguridad de su grupo de reglas, debido
a que IP Filter es extremadamente flexible.  Por ejemplo, en el grupo
de reglas anterior, est&aacute; permitiendo todo el tr&aacute;fico tcp
a los puertos 80 y 443.  A&uacute;n puede ajustarlo un poco m&aacute;s.
Para establecer una conexión tcp sólo necesita permitir que tenga lugar
el saludo inicial (&quot;handshake&quot;);  una vez que esto ocurra,
puede bloquear el tráfico a ese puerto y permitir a la regla &quot;keep
state&quot; que gestione la conexión.  Para que se complete el saludo
inicial, sólo necesita permitir el paso a los paquetes con los
indicadores SIN y SIN/ACK activados.  Al dejar pasar sólo paquetes con
SIN y SIN/ACK activados puede prevenir muchas formas de escaneos de
puertos como puede ser el escaneo FIN.  Ahora las reglas están de este
modo:

<ul>
<pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA
block in quick on fxp0 from any to any
pass out on fxp0 from any to any keep state
##############################
# end ruleset
##############################
</pre>
</ul>
</p>

<p>
Pongamos ahora todas las reglas que tenemos, poniéndolas en un solo paquete
de reglas.
Este paquete de reglas tendrá una política de denegación predefinida,
permitirá conexiones de gestión sólo desde una red local (mediante ssh), y
permitirá el paso de tráfico entrante en los puertos 80 (http) y 443 (https).
Además, protegerá contra direcciones de ip falsificadas no enrutables, y
bloqueará todos los paquetes que no estén tan fragmentados que no puedan ser
inspeccionados.
Una configuración bastante comprensiva para un servidor de web público.
He aquí cómo quedaría /etc/ipf.rules:

<ul>
<pre>
###########################
# begin ruleset
###########################
# reglas de loopback
pass out quick on lo0
pass in quick on lo0

# bloquear fragmentos diminutos
block in quick proto tcp all with short

# bloquear paquetes enrutados de fuentes
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr

# no permitir a nadie que falsee direcciones no enrutables
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# permitir la conexión por ssh sólo a sus máquinas
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22

# permitir que otros usen http y https
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA

# finalmente, bloquear el resto con una denegación por definición
block in quick on fxp0 from any to any

# y dejar pasar todo el tráfico saliente y mantener el estado
# en conexiones establecidas
pass out on fxp0 from any to any keep state

#############################
# end ruleset
#############################
</pre>
</ul>
</p>

<p>
Para más información sobre ipf, el
<a href=http://www.obfuscation.org/ipf/ipf-howto.txt>IPF howto</a> es una
fuente excelente, como también lo son los recursos disponibles en las páginas
de <a href=http://coombs.anu.edu.au/~avalon/ip-filter.html>IP Filter</a>.
</p>

<p>
<a name="6.3"></a>
<h2>6.3 - IPNAT</h2>
</p>

<p>
Desarrollado sobre un trabajo original de Wayne Fergerstrom 
&lt;wayne@methadonia.net&gt;
</p>

<a name="nat1.0"></a>
<h3><u>6.3.1 Introducci&oacute;n a NAT</u></h3>

<a name="nat1.1"></a>
<b>Secci&oacute;n de Introducci&oacute;n</b>

<p>
Esta secci&oacute;n pretende servir de ayuda para aquellos que instalen
y configuren la &laquo;Traducci&oacute;n de Direcciones de Red&raquo;
(NAT, &quot;Network Address Translation&quot;) en una m&aacute;quina
con OpenBSD.
Se asume que el usuario ya ha configurado y activado una m&aacute;quina
con OpenBSD con dos tarjetas de red (una conectada a Internet y la otra
a la red local).
IP NAT funcionar&aacute; en m&aacute;quinas con s&oacute;lo un NIC, sin
embargo, como los paquetes entrar&aacute;n y saldr&aacute;n de la misma
interfaz, las colisiones de ethernet ralentizar&aacute;n el rendimiento
de forma considerable.
</p>

<p>
Basado en <a href="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>,
ipnat ofrece una forma fácil para la asignación de redes locales a una
dirección única enrutable (&laquo;real&raquo;) de internet.
Esto es de gran utilidad si no dispone de direcciones asignadas oficialmente
para cada huésped en su red interna.
Cuando configura redes privadas/internas, puede aprovechar los bloques de
direcciones reservados (asignados en
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), como:

<pre>
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)
</pre>
</p>

<a name="nat1.2"></a>
<b>Terminología</b>

<p>
Los términos convencionales usados en este documento son bastante claros.
Con el fin de documentarlos, repasaré algunos de estos términos y la acepción
que toman en este documento.
</p>

<ul>
<strong>&quot;NAT&quot;</strong>
<p>
Describe la función de &laquo;Traducción de Direcciones de Red&raquo;.
El proceso de NAT se describirá más adelante en este documento.
</p>
</ul>

<ul>
<strong>&quot;ipnat&quot;</strong>

<p>
Es la abreviación de &laquo;Traducción de Direcciones de Red IP&raquo;.
Se puede utilizar de manera indistinta en substitución de NAT.
Sin embargo, en este documento el térmitno &quot;ipnat&quot; se utilizará tan
sólo para el uso de la línea de órdenes.
</p>
</ul>

<ul>
<strong>&quot;IPF&quot;</strong>
<p>
Es la abreviación de &laquo;Filtro IP&raquo;.
IP Filter es un paquete de software de filtrado portable que se incluye como
parte del sistema OpenBSD.
IP Filter debe estar activado antes de poder activar ipnat.
Se activa de modo fácil, simplemente editando el fichero /etc/rc.conf y
cambiando ipf=NO por ipf=YES.
Esto sólo lo cambiar para la secuencia de inicio, y es necesario ejecutar
'ipf -E' para activar ipf mientras el sistema está en funcionamiento.
Más adelante se describen estos pasos.
</p>
</ul>

<br>
<a name="nat1.3"></a>
<b>Detalles de Configuración</b>

<p>
Esta parte se refiere a los detalles de configuración de las máquinas para
este documento.
Su configuración será distinta de ésta, pero el propósito de este documento
es el de ofrecerle una breve idea de cómo puede ser, con el fin de que pueda
adaptar esta información a su configuración.
</p>

<ul>
<b>Sistema Operativo de la Máquina: </b>OpenBSD v2.7 i386<br>
<br>
<b>NICs: </b>
<ul>
	NetGear 10/100MB <b>dc0</b><br>
	Conectada a una LAN EXTERNA (o WAN)<br>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<br>
	NetGear 10/100MB <b>dc1</b><br>
	Conectada a una LAN INTERNA<br>
	<b>IP Address: </b>192.168.1.1<br>
	<b>Netmask: </b>255.255.255.0<br>	
</ul>
<br>
<b>IP enrutable por Internet, externo (en este ejemplo, una conexión por
módem analógico provista por un Proveedor de Servicios de Internet)<br></b>
<ul>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<b>Gateway: </b>24.5.0.1<br>
</ul>
<br>
<b>Red de Área Local (LAN)</b><br>
<ul>
En este ejemplo, las máquinas de la LAN usan el esquema de direcciones IP
192.168.1.xxx (donde xxx es un número único).
Existe una gran variedad de sistemas operativos diferentes en la LAN interna,
incluidos Windows 98, Windows NT, OpenBSD y Linux.
Cada máquina está conectada a un &quot;hub&quot; designado para uso interno.
Para este documento y sus ejemplos, el cliente en la LAN asumirá una
dirección IP 192.168.1.40
</ul>
<br>
<b>Diagrama de Configuración</b>
<ul><pre>
+-----+              +---------+         +----------+
| Hub |--------- dc1 |   NAT   | dc0 ----| Internet |
+-----+              +---------+         +----------+
  | |
  | +-- Cliente A
  +---- M&aacute;s clientes 

                              +--------------------------+
                              |           LEGEND         |
                              +--------------------------+
                              |   NIC dc0 - 24.5.0.5     |
                              |   NIC dc1 - 192.168.1.1  |
                              | Cliente A - 192.168.1.40 |
                              +--------------------------+

</pre></ul>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Traducción de Direcciones de Red</u></h3>
<br>

<a name="nat2.1"></a>
<b>Introducción a NAT</b>

<p>
Cada día más empresas y usuarios entran en Internet, y cada uno debe tener
una dirección IP, pero las direcciones IP públicas son cada vez más 
difíciles de conseguir.
Para muchas personas la solución ha sido la &laquo;Traducción de Direcciones
de Red&raquo; (o NAT).
NAT es un modo muy simple y a la vez muy potente de conectar una LAN a
Internet sin tener que comprar o alquilar direcciones IP para cada máquina.
NAT también es conocido como &laquo;Enmascaramiento de IP&raquo; entre los
usuarios de Linux.
</p>

<p>
Cuando NAT está funcionando correctamente, permite que los usuarios dentro de
la LAN puedan acceder a Internet a través de diferentes direcciones de IP (la
que haya activado con su proveedor).
Cada máquina conectada a la LAN usa la dirección IP (de forma transparente)
de la máquina que está configurada para usar la dirección de IP asignada por
el Proveedor de Servicion de Internet (ISP).
</p>

<p>
El modo en que funciona NAT es increiblemente simple.
Cuando un cliente dentro de la LAN quiere conectar a la máquina en Internet,
le envía un paquete TCP con un requerimiento de conexión.
Dentro de la cabecera del paquete TCP se encuentra la dirección IP del
cliente (o sea, 192.168.1.40) y la dirección IP del anfitrión requerido (o
sea, 123.45.67.89).
La máquina en la que está funcionando NAT intercepta este paquete TCP y
cambia la dirección IP del cliente de 192.168.1.40 a la dirección IP de la
máquina conectada a Internet (o sea, 24.5.0.5).
De este modo engaña a la máquina anfitriona, haciéndole pensar que la
conexión requerida proviene de la máquina con NAT, no de la máquina cliente.
Entonces el anfitrión envía de vuelta respuestas a la máquina NAT como si
ésta fuera la que se estuviera conectando.
Cuando la máquina NAT recibe las respuestas, las traduce rápidamente y envía
el paquete al cliente.
El cliente no tiene ni la más remota idea de lo que está ocurriendo y la
falsificación de la conectividad a Internet es totalmente transparente.
</p>

<p>
El ejemplo siguiente muestra NAT de un modo más claro:
</p>

<ul><pre>
Cliente ----------------- dc1 [ NAT ] dc0 ---------- Anfitrión de Internet
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

Paquete TCP SALIENTE                            Paquete TCP SALIENTE
Desde: 192.168.1.40      &gt;&gt;=== NAT ===&gt;&gt;        Desde: 24.5.0.5
Hacia: 123.45.67.89                             Hacia: 123.45.67.89

Paquete TCP ENTRANTE				Paquete TCP ENTRANTE
Desde: 123.45.67.89 				Desde: 123.45.67.89
Hacia: 192.168.1.40      &lt;&lt;=== NAT ===&lt;&lt;        Hacia: 24.5.0.5
</pre></ul>

<br>
<a name="nat2.2"></a>
<b>Porqué Usar NAT</b>

<p>
Una vez que ya había conseguido un módem cable en mi nuevo 
apartamento me dí cuenta de que tenía un pequeño problema.
¿Cómo podría conseguir acceso a Internet para mis compañeros de apartamento
si el módem estaba en mi habitación?
Sólo había unas pocas opciones que podían ayudarme, y que iban desde obtener
direcciones IP extras, pasando por instalar un servidor proxy, hasta instalar
NAT (no permita que el ejemplo del módem cable le engañe, NAT es lo 
suficientemente potente como para enmascarar un gran red con cientos o 
incluso miles de máquinas).
</p>

<p>
Existen varias razones por las que decidí instalar NAT, la primera de ellas
mi economía.
En la casa vivían dos compañeros de piso (cada uno con su propio PC) y yo
(con tres PCs).
Mi ISP sólo permitía tres direcciones IP por casa, lo que significaba que no
habían suficientes IPs para que cada máquina pudiera tener acceso a Internet.
</p>

<p>
Usando NAT cada máquina tendría una dirección IP única (interna), pero
compartirían la única dirección IP que mi ISP me dio.
El coste se redujo.
</p>

<br>
<a name="nat2.3"></a>
<b>Preconfiguración</b>

<p>
Para activar NAT en su máquina OpenBSD, necesitará configurar IPF y NAT.
Esto se puede llevar a cabo de una manera fácil editando los ficheros que
aparecen en la siguiente lista (haga los cambios al fichero de modo que
aparezcan como las opciones que siguen a continuación):
</p>

<p>
<b>/etc/rc.conf</b> (este fichero se usa para iniciar servicios durante el
                    arranque)
</p>

<ul>
	ipfilter=YES<br>
	ipnat=YES
</ul>

<p>
<b>/etc/sysctl.conf</b>
</p>

<ul>
	net.inet.ip.forwarding=1
</ul>

<p>
Después de haber hecho estos cambios, la máquina estará lista para la
configuración de NAT.
</p>

<br>
<a name="nat2.4"></a>
<b>Configuración</b>

<p>
El primer paso es configurar el fichero de reglas de IPF
(<i>/etc/ipf.rules</i>).
Para el propósito que persigue este documento, dejaremos que el tráfico pase
a través de esta opción de cortafuegos sin que haya interferencias.
El fichero será como sigue:
</p>

<ul>
<pre>
pass in from any to any
pass out from any to any
</pre>
</ul>

<p>
Para más información puede leer la <a href="#6.2">sección 6.2</a> de estas
Preguntas Frecuentes.
</p>

<p>
La sintaxis del fichero de configuración de NAT (<i>/etc/ipnat.rules</i>) es
bastante simple.
De acuerdo con el ejemplo de configuración anterior, el fichero de
configuración de NAT contendrá las siguientes entradas:
</p>

<ul>
<pre>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32
</pre>
</ul>

<p>
He aquí lo que significan estas líneas.
</p>

<ul>
<strong>&quot;map&quot;</strong>
<p>
Ésta es la orden que se le pasa a ipnat.
Dicha orden indica a ipnat que ésta es una entrada para cambiar la dirección
IP entre la LAN e Internet.
</p>
</ul>

<ul>
<strong>&quot;dc0&quot;</strong>
<p>
Ésta es la interfaz de red que está conectada a Internet.
</p>
</ul>

<ul>
<b>&quot;192.168.1.0/24&quot;</b>
<p>
La dirección IP y de enmascaramiento de red (&quot;netmask&quot;, cuyo
formato es CIDR).
La combinación de ambas indica que &laquo;cualquier dirección IP con un valor
desde 192.168.1.1 hasta 192.168.1.254 debe ser asignado&raquo;.
Si prefiere no usar el formato CIDR, puede substituir &laquo;/24&raquo; por
&laquo;/255.255.255.0&raquo;.
</p>
</ul>

<ul>
<b>&quot;24.5.0.5/32&quot;</b>
<p>
Esta dirección de IP y de enmascaramiento de red indica la dirección IP que
se asignará a la LAN.
/32 indica una sola dirección IP.
También puede asignarle direcciones IP /24, ó 256 (ó /27, ó cualquier otro
número de bits que quiera).
Esto último es muy útil si tiene varios miles de máquinas huéspedes detrás de
su NAT... claro que sólo es de utilidad si ese /24 está siendo enrutado a su
sistema OpenBSD.
</p>
</ul>

<ul>
<b>&quot;portmap tcp/udp 10000:60000&quot;</b>
<p>
Esto asigna todos los paquetes tcp/udp a puertos desde el 10000 hasta el 
60000.
</p>
</ul>

<p>
La segunda línea tiene casi la misma entrada que la primera, exceptuando la
parte final.
En esta línea se indica a ipnat que debe asignar cualquier otra cosa (que no
sea tcp/udp, ya que esos paquetes concuerdan en la primera línea) a cualquier
puerto que requiera (usado por ICMP y otros protocolos).
Una vez que esto está en el fichero, sólo tiene que ejecutar el d&aelig;mon
IPF.
</p>

<br>

<a name="nat2.5"></a>
<b>Funcionamiento</b>

<p>
Ejecutar NAT también es un proceso muy sencillo.
Una vez que haya acabado de configurarlo, hay dos maneras de activar NAT.
La primera manera, y la mejor si fuera posible comprobar la fase de
configuración, es reiniciando su sistema OpenBSD.
Para ello basta que use la orden &laquo;<i>reboot</i>&laquo;.
</p>

<p>
Si quiere ejecutar ipnat desde la línea de órdenes, use las siguiente
órdenes:
</p>

<ul>
<pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre>
</ul>

<p>
Con la primera línea de órdenes se activa IPF (recuerde que NAT depende de 
IPF, y por lo tanto es necesario iniciar IPF y tenerlo en funcionamiento antes 
de poder cargar NAT).
Las opciones en la línea de órdenes &quot;-Fa&quot; limpian cualquier entrada
existente.
&quot;-f /etc/ipf.rules&quot; indica a ipf dónde encontrar el fichero con las
reglas.
&quot;-E&quot; es el interruptor para activar el d&aelig;mon IPF.
</p>

<p>
La segunda línea de órdenes es para activar NAT.
&quot;-CF&quot; limpia y descarga todas las entradas existentes en la tabla
de NAT.
&quot;-f /etc/ipnat.rules&quot; indica a NAT dónde encontrar el fichero con
las reglas de NAT.
Ahora ya tiene NAT funcionando.  Así de sencillo.
</p>

<p>
<b>Nota:</b> para volver a cargar las configuraciones de NAT (en el caso en
que las cambiara y no quisiera reiniciar) ejecute la segunda orden de nuevo.
Las configuraciones serán descargadas y cargadas de nuevo.
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 Base de Conocimientos de NAT</u></h3>

<br>
<a name="nat3.1"></a>
<b>Verificar el Estado de NAT</b>

<p>
Para averiguar cómo está funcionando NAT o asegurarse de que las
configuraciones hayan hecho efecto, use la opción &quot;-l&quot;.
Esta opción le mostrará un listado de todas las opciones de configuración y
sesiones actuales que esté usando ipnat:
</p>

<ul>
<pre>
# <b>ipnat -l</b>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32

List of active sessions:
MAP 192.168.1.40  2473  &lt;- -&gt; 24.5.0.5  13463 [129.128.5.191 80]
</pre>
</ul>

<p>
El propósito de las primeras dos líneas es el de verificar las
configuraciones que se introdujeron anteriormente en /etc/ipnat.rules.
Cualquier línea a partir de esas dos mostrará una lista de las conexiones que
estén siendo actualmente controladas por NAT.
</p>

<ul>
<b>&quot;MAP 192.168.1.40  2473&quot;</b>
<p>
Le indica la dirección IP de la máquina que esté usando NAT en la LAN.
El número del puerto que se use para realizar la conexión se mostrará a
continuación.
</p>
</ul>

<ul>
<b>&quot;&lt;- -&gt;&quot;</b>
<p>
Indica que NAT está gestionando el flujo de tráfico en ambas direcciones.
</p>
</ul>

<ul>
<b>&quot;24.5.0.5  13463&quot;</b>
<p>
Indica que la conexión va a Internet a través de la dirección IP 24.5.0.5 y
que usa el puerto 13463.
</p>
</ul>

<ul>
<b>&quot;129.128.5.191 80&quot;</b>
<p>
La dirección IP y el puerto por el que se está realizando la conexión.
</p>
</ul>

<a name="nat3.2"></a>
<b>Limitaciones de NAT (en FTP)</b>

<p>
NAT tiene unas pocas limitaciones a tener en cuenta.
Cuando un usuario conecta a un servidor de FTP remoto y pide información o un
fichero a éste, el servidor de FTP conectará con el cliente y le transferirá
los datos.
Este proceso se lleva a cabo por un puerto libre aleatorio.
Pero esto representa un problema para los usuarios que intentan obtener
acceso a los servidores de FTP desde dentro de la LAN.
Cuando el servidor de FTP envía sus datos, los envía al NIC externo en un
puerto aleatorio.
La máquina NAT los recibe, pero como no tiene ninguna asignación para el
paquete desconocido ni para ese puerto en concreto, suelta el paquete y no
lo entrega.

<p>
La solución a esto está en que el usuario se ubique en &laquo;modo
pasivo&raquo; en su cliente de FTP.
De este modo indicará al servidor que desea conectarse a éste, y que no
ocurra lo antes mencionado.
Así, al realizar el usuario la conexión, NAT la gestionará correctamente.

<p>
IP Filter ofrece otra solución para esta situación, un &quot;proxy&quot; de
ftp integrado en el código de NAT.
Para activarlo, debe escribir algo parecido a lo siguiente antes de sus otras
asignaciones para NAT.

<pre>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 proxy port ftp ftp/tcp
</pre>

Con esto, el núcleo del sistema observará sus conexiones por FTP para la
orden &quot;PORT&quot; que proceda del cliente de ftp, y substituirá la
dirección IP y el puerto con su propia dirección IP externa y con un puerto
de su elección.
Obviamente, esto requiere de un uso mucho más intensivo de recursos pero, a
menos que su máquina de filtrado NAT/IP esté alcanzando una masa crítica, no
debería darle ningún problema.
<p>


<br>
<a name="nat3.3"></a>
<b>Redireccionamiento del Tráfico</b>

<p>
Es posible que haya momentos en los que necesite redireccionar el tráfico
entrante o saliente hacia cierto protocolo o puerto.
Un buen ejemplo de esto podría ser el caso en el que tuviera un servidor que
residiera dentro de la LAN y que estuviera haciendo la función de servidor de
web.
Las conexiones entrantes a su IP válido de Internet se encontrarían con que, 
a menos que su máquina NAT fuera el servidor de web, no podrían conectar.
Para solventarlo usaremos la directiva `rdr' de NAT en el fichero de reglas,
para darle las instrucciones sobre a dónde debe redireccionar (o enrutar) una
conexión en particular.
</p>

<p>
Para nuestro ejemplo, supongamos que un servidor de web reside en la LAN y
que su dirección IP es 192.168.1.80.
El fichero de reglas de NAT necesita una nueva directiva para gestionar esto.
Añada una línea parecida a la siguiente a su ipnat.con:
</p>

<ul>
<pre>
rdr dc0 24.5.0.5/32 port 80 -&gt; 192.168.1.80 port 80
</pre>
</ul>

<p>
Desglosando esta línea para ver qué signfica cada componente de ella:
</p>

<ul>
<b>&quot;rdr&quot;</b>
<p>
Es la orden que le está pasando a ipnat.
Indica a ipnat que lo que sigue es una entrada para redireccionar una
conexión.
</p>
</ul>


<ul>
<b>&quot;dc0&quot;</b>
<p>
Es la interfaz de red que está conectada a Internet.
</p>
</ul>

<ul>
<b>&quot;24.5.0.5/32&quot;</b>
<p>
Indica que es una conexión entrante a esta dirección IP (sólo en dc0, como
arriba).
</p>
</ul>

<ul>
<b>&quot;port 80&quot;</b>
<p>
Éste es el puerto (80) que debe ser redireccionado.
El número &laquo;80&raquo; no es estrictamente necesario, también podría usar 
&laquo;port www&raquo; para especificar una redirección del puerto 80.
Si desea usar un nombre en lugar de un número, el nombre del servicio y el
puerto correspondiente deben existir en el fichero /etc/services.
</p>
</ul>

<ul>
<b>&quot;192.168.1.80&quot;</b>
<p>
Es la dirección IP y de enmascaramiento de red (&quot;netmask&quot;) de la
máquina LAN a la que redireccionan los paquetes.
El enmascaramiento de red es siempre &laquo;/32&raquo; (y por tanto no es
necesario especificarlo), para que los paquetes puedan ser redirigidos a una
máquina en particular.
</p>
</ul>

<p>
Cuando haya terminado de añadir todos los datos, recargue las reglas de NAT y
el redireccionamiento comezará de inmediato.
</p>

<br>
<a name="nat3.4"></a>
<b>NAT frente a Proxy</b>

<p>
La diferencia entre NAT y una aplicación basada en proxy es que el software
de proxy actúa como un intermediario entre Internet y las máquinas conectadas
a la LAN.
En prinicipio esto no presenta ningún problema, sin embargo cada aplicación
que quiera ejecutar en su máquina y conectarla a Internet a través del
servidor de proxy, DEBE reconocer el proxy (ser capaz de usarlo).
No todas las aplicaciones con capaces de esto (en especial los juegos).
Aún más, no existen aplicaciones para servidores de proxy para todos los
servicios de Internet.
NAT asigna su red interna de un modo transparente, para que pueda conectar a
Internet.
La única ventaja de seguridad que proxy tiene sobre NAT es que el software de
proxy puede haber sido programado para funciones de seguridad, y puede
filtrar según el contenido con el fin de evitar que una macro de virus se 
interne en su máquina Windows, o proteger sus programas contra
desbordamientos de la memoria intermedia (&quot;buffer overflows&quot;), y
otros peligros.
El mantenimiento de estos filtros es a menudo un trabajo muy pesado.
</p>

<a name="nat4.0"></a>
<b>6.3.4 Referencias y Recursos</b>

<p>
Ficheros de OpenBSD:
<ul>
   <li>/etc/ipnat.rules - fichero de reglas de NAT
   <li>/etc/rc.conf - fichero para iniciar ipnat e ipf durante el arranque 
       del sistema
   <li>/etc/sysctl.conf - fichero para activar IP forwarding
   <li>/usr/share/ipf/nat.1 - ejemplos de ipnat.rules
</ul>
</p>

<p>
Enlaces de NAT en Internet:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8">http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=5&format=html">Página de manual que muestra la sintaxis correcta de ipnat.rules</a>
<li><a href="http://coombs.anu.edu.au/~avalon/">http://coombs.anu.edu.au/~avalon/</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>

<p> 
<a name="6.4"></a> <h2>6.4 - DHCP</h2> </p>

<h3>6.4.1 Cliente DHCP</h3>

<p>
Para usar el cliente DHCP incluido en OpenBSD, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&apropos=0&sektion=8&format=html">dhclient(8)</a>,
edite el fichero /etc/hostname.xl0 (suponiendo que su interfaz principal de
ethernet sea xl0;  la suya podría ser ep0, o fxp0, o cualquier otra).
Todo lo que necesita añadir a este fichero es 'dhcp'.

<pre>
# <strong>echo dhcp >/etc/hostname.xl0</strong>
</pre>

Esto hará que OpenBSD inicie el cliente DHCP automáticamente durante el
arranque.
OpenBSD obtendrá la información sobre su dirección IP, pasarela, y servidores
de DNS desde el servidor de DHCP.

<p>
Si quiere iniciar un cliente dhcp desde la línea de órdenes, asegúrese de que
el fichero /etc/dhclient existe, y entonces escriba:

<pre>
# <strong>dhclient fxp0</strong>
</pre>

en donde fxp0 es la interfaz en la que quiere recibir dhcp.

<p>
Sea cual fuere el modo en que inicie dhclient, puede <b>evitar</b> que se
actualice su DNS de acuerdo con la idea que tenga el servidor dhcp sobre la
DNS, comentando las líneas precedidas por 'request' (son ejemplos de la
configuración predefinida, pero necesita activarlos para anular la
configuración predefinida de dhclient)

<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>

y a continuación <b>eliminar</b> domain-name-servers.
También es posible que también desee anular hostname u otras configuraciones.

<p>
<h3>6.4.2 Servidor DHCP</h3>

Si quiere usar OpenBSD como servidor DHCP con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&apropos=0&sektion=8&format=html">dhcpd(8)</a>,
edite el fichero /etc/rc.conf.
Configúrelo poniendo dhcp_flags=&quot;-q&quot; en lugar de dhcp_flags=NO.
Añada en /etc/dhcp.interfaces las interfaces en las que quiera que dhcp esté
&laquo;a la escucha&raquo;

<pre>
# <strong>echo xl1 xl2 xl3 >/etc/dhcpd.interfaces</strong>
</pre>

y edite /etc/dhcpd.conf.
Las opciones son bastante claras:

<pre>
        option  domain-name &quot;xyz.mil&quot;;
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Con esto indicará a sus clientes dhcp que el dominio que deben añadir a sus
requerimientos de DNS es xyz.mil (así, si un usuario escribiera 'telnet joe',
los enviaría a joe.xyz.mil).
Les dirigirá a los servidores de DNS 192.168.1.3 y 192.168.1.5.
Para los huéspedes que se encuentren en la misma red que una interfaz de
ethernet en la máquina de OpenBSD, que está en el rango 192.168.1.0/24, les
asignará una dirección de IP entre 192.168.1.32 y 192.168.1.127, configurando
su pasarela por definición como 192.168.1.1.

<p>
Si quiere iniciar dhcpd desde la línea de órdenes, después de editar
/etc/dhcpd.conf intente lo siguiente:

<pre>
# <strong>dhcpd -q fxp0</strong>
</pre>

En donde fxp0 es la interfaz que Vd. desea que empiece a servir dhcp.
El indicador -q fuerza dhcpd en silencio, de otro modo es muy ruidoso.

<p>
Si está actuando como servidor de DHCP para una máquina Windows, es posible
que quiera que dhcp ofrezca al cliente una dirección de servidor 'WINS'.
Para ello añada la siguiente línea al fichero /etc/dhcpd.conf:

<pre>
option	netbios-name-servers	192.168.92.55;
</pre>

En donde 192.168.92.55 es el IP de su servidor de Windows o Samba.
Para ver más opciones que puedan aceptar sus clientes DHCP, lea
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&apropos=0&sektion=5&format=html">dhcp-options(5)</a>.

<p>
<a name="6.5"></a>
<h2>6.5 - PPP </h2>
</p>

El &laquo;Protocolo Punto a Punto&raquo; es el que se suele usar para crear
una conexión con su ISP a través de un modem.
OpenBSD puede hacer esto de dos maneras:

<ul>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8&format=html">pppd(8)</a> - Es el d&aelig;mon ppp del núcleo del sistema.
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> - Es el d&aelig;mon ppp del modo usuario.
</ul>

<p>
Primero trataremos el d&aelig;mon del modo de usuario.
Para empezar necesitará algo de información sobre su isp.
He aquí una lista de la información que necesitará:
</p>

<ul>
   <li>El número de teléfono de conexión de su proveedor (ISP)
   <li>Su &quot;nameserver&quot; (nombre del servidor) 
   <li>Su nombre de usuario y contraseña
   <li>Su pasarela
</ul>

<p>
Parte de esta información no es estrictamente necesaria, pero será de gran
ayuda para configurar ppp.
El d&aelig;mon PPP de modo usuario utiliza el fichero
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
como fichero de configuración.
Existen muchos ficheros en <b>/etc/ppp</b> de gran utilidad, que pueden
contener diferentes ejemplos de configuración para situaciones distintas.
Le aconsejamos que mire en ese directorio.
</p>

<p>
En caso de no estar usando un núcleo GENERIC, asegúrese de que tiene la
siguiente línea en su fichero de configuración:
</p>

<ul><pre><strong>
pseudo-device   tun             2
</pre></ul></strong>


<h3>Configuración Inicial para PPP(8)</h3>

<p>
La configuración inicial del d&aelig;mon PPP de modo usuario consiste en
editar su fichero <b>/etc/ppp/ppp.conf</b>.
Este fichero no existe y debe ser creado, pero puede tomar el fichero
<b>/etc/ppp/ppp.conf.sample</b>, editarlo, y crear su propio fichero
<b>ppp.conf</b> a partir de ahí.
Aquí empezaré con la más simple, y probablemente más utilizada,
configuración.
A continuación puede ver un pequeño fichero <b>ppp.conf</b> que llevará a
cabo la conexión con su ISP y usará sus rutas predefinidas y su
&quot;nameserver&quot;.
Para este fichero, toda la información que necesitará será el número de
teléfono de su ISP, su nombre de usuario, y su contraseña.
</p>

<ul>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</ul>

<p>
<b>AVISO</b> - En OpenBSD 2.6, el sistema salió con un fichero
<i>/etc/ppp/ppp.conf.example</i> que contenía una configuración errónea para
el dispositivo.
El dispositivo era <i>"set device /dev/cuaa0"</i> cuando en realidad debía
ser <i>/dev/cua00</i>, que corresponde al dispositivo para el puerto de
comunicaciones 1 (COM1).
Su dispositivo podría no estar en COM1, aún así este esquema era erróneo.
</p>

<p>
La sección en la opción <b>default:</b> será ejecutada cada vez.
En ella se configura toda la información crítica.
Con &quot;set log&quot; se configuran los niveles de ingreso.
Esto se puede cambiar;  para más información sobre cómo configurar los
niveles de ingreso lea la página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a>.
El dispositivo se configura con &quot;set device&quot;.
Éste es el dispositivo en el que se encuentra el modem.
En este ejemplo el modem está en el puerto de comunicaciones 2 (COM2),
mientras que el puerto de comunicaciones 1 correspondería a /dev/cua00.
Con &quot;set speed&quot; se configura la velocidad de la conexión por
llamada, y con &quot;set dial&quot; se configura los parámetros de la
llamada.
Con esto se puede cambiar el tiempo muerto, etc...
Es conveniente dejar esta línea más o menos como está.
</p>

<p>
A continuación puede pasar a configurar la información específica para su
ISP.
Para ello debe añadir otra opción en la sección <b>default:</b>.
Puede dar cualquier nombre a esta etiqueta, pero lo más fácil es darle el
nombre de su ISP.
En el ejemplo usaremos <b>myisp:</b> para la opción que hará referencia a
nuestro ISP.
He aquí una configuración simple que incorpora todo lo necesario para
conectar:
<p>

<ul>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</ul>

<p>
Aquí hemos configurado información esencial para un ISP específico.
La primera opción, &quot;set phone&quot;, es para configurar el número de 
teléfono para la conexión de su ISP.
La opción &quot;set login&quot; es para configurar sus opciones de ingreso.
En el ejemplo hemos puesto un tiempo muerto de espera de 5, lo que significa
que terminará nuestro intento de ingreso después de 5 segundos su no hay
transportador.
De lo contrario esperará hasta recibir un &quot;login&quot; para enviar su
nombre de usuario y contraseña.
En el ejemplo, tanto el nombre de usuario como la contraseña son
&quot;ppp&quot;.
Estos valores hay que substituirlos por otros reales.
La opción &quot;set timeout&quot; es para configurar el tiempo de espera para
todo el proceso de ingreso.
La opción &quot;set ifaddr&quot; es algo complicada.
He aquí una explicación más extensa sobre ella:
</p>

<ul><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></ul>

<p>
Hemos configurado la línea anterior con el formato 
&quot;<b>set ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask
[triggeradr]]]]</b>&quot;.
De este modo el primer IP que se especifique es el que querremos como nuestro
IP.
Sin tiene una dirección IP estática, escríbala aquí.
En el ejemplo hemos usado /0, que indica que no es necesario que concuerde
ningún bit de esta dirección ip, y que se puede substituir todo.
El segundo IP que se especifique es el que esperamos como el IP de nuestro
ISP.
Si lo sabe lo puede especificar aquí, pero en la línea no sabemos cuál se
asignará, así que dejaremos que nos lo digan.
Esto es muy útil al negociar con algunas implementaciones PPP que no asignan
un número IP a menos que su conexión les requiera ``0.0.0.0''.
</p>

<p>
La siguiente opción &quot;add default HISADDR&quot; es para configurar la
ruta predefinida a su IP.
Si su IP cambiara, la ruta se actualizaría de forma automática.
Con &quot;enable dns&quot; indicamos a nuestro ISP que autentifique nuestras
direcciones &quot;nameservers&quot;.
No haga esto si está usando una DNS local, ya que ppp circunvalará su uso
introduciendo algunas líneas en /etc/resolv.conf.
</p>

<h3>Cómo Usar PPP(8)</h3>

<p>
Ahora que ya tenemos el fichero <b>ppp.conf</b> configurado, podemos intentar
una conexión con nuestro ISP.
A continuación se darán algunos detalles sobre argumentos de uso común con
ppp.
</p>

<ul>
   <li><b>ppp -auto myisp</b> - Inicia ppp, configura sus interfaces, le
       conecta con su isp, y a continuación pasa a un plano de fondo.
   <li><b>ppp -ddial myisp</b> - Parecido a -auto, pero si su conexión
       cayera volvería a conectar.
</ul>

<p>
Si usa <b>/usr/sbin/ppp</b> sin pasarle ninguna opción, le pasará al modo
interactivo, desde donde podrá interaccionar directamente con el modem.
De este modo puede depurar problemas en su fichero <b>ppp.conf</b>.
</p>

<h3>Acciones extras con ppp(8)</h3>

<p>
Si necesitara ejecutar órdenes al tiempo que conecta o desconecta, puede
hacerlo creando dos ficheros extras.
<b>/etc/ppp/ppp.linkup</b> y <b>/etc/ppp/ppp.linkdown</b>.
Puede ver ejemplos de configuración para estos ficheros en:
</p>

<ul>
   <li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
   <li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Puede encontrar más información en
<a href="http://www.freebsd.org/handbook/userppp.html">http://www.freebsd.org/handbook/userppp.html</a> o en
<a href="http://www.freebsd.org/es/faq/userppp.html">http://www.freebsd.org/es/faq/userppp.html</a>.
</p>

<p>
<a name="6.6"></a>
<h2>6.6 - Afinar Parámetros de Red</h2>

<h3>6.6.1 - ¿Cómo puedo forzar al núcleo del sistema para obtener un mayor
número de reintentos y tiempos de espera mayores en las sesiones TCP?</h3>

Para problemas de conexión o enrutamiento puede usar lo siguiente.
Tenga en cuenta que para que sea más efectivo, ambos lados de la conexión
deben usar valores similares.

<p>
Para forzarlo use <tt>sysctl</tt> e incremente los valores de:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

Si usa sysctl -a podrá ver los valores actuales de estos y muchos otros
parámetros.
Para cambiar cualquiera de ellos, use <tt>sysctl -w</tt>, como por ejemplo en
<tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.

<h3>6.6.2 - ¿Cómo puedo activar emisiones dirigidas?</h3>

Por regla general no es aconsejable hacer esto, ya que si su sistema OpenBSD
es un enrutador, permite que puedan enviar tráfico a la dirección o 
direcciones de emisión de sus redes.

<p>
En algunos casos, como en redes cerradas, puede tener cierta utilidad, en
particular cuando esté usando implementaciones antiguas del protocolo
NetBIOS.
Se puede activar con <tt>sysctl -w net.inet.ip.directed-broadcast=1</tt>.
Para saber porqué se encuentra desactivado por definición, infórmese sobre
<a href="http://www.netscan.org">ataques &quot;smurf&quot;</a>.

<h3>6.6.3 - No quiero que el núcleo haga asignaciones dinámicas de ciertos
puertos</h3>

También existe un sysctl para esto.
De la página de manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:

<pre>
Añada la lista de puertos TCP que no deberían ser asignados dinámicamente por
el núcleo.  Esto se puede usar para evitar que algunos daemons se apropien de
un puerto específico que sea necesario para el funcionamiento de otro
programa.  La lista de elementos puede ir separada por comas y/o espacios en
blanco.

   sysctl -w net.inet.tcp.baddynamic=749,750,751,760,761,871

También se pueden añadir o eliminar puertos de la lista actual.

   sysctl -w net.inet.tcp.baddynamic=+748
   sysctl -w net.inet.tcp.baddynamic=-871
</pre>

<a name="6.7"></a>
<h2>6.7 - Uso simple de NFS</h2>

<p>
El &laquo;Sistema de Archivos de Red&raquo; (NFS, &quot;Network File
System&quot;) se usa para compartir un sistema de archivos en una red.
Algunas páginas de manual que debería leer antes de que intente configurar un
servidor de NFS son:

<p>

<ul>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8&format=html">nfsd(8)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8&format=html">mountd(8)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>
</ul>

<p>
En esta sección se detallarán los pasos para una configuración simple de NFS.
El ejemplo ofrece detalles sobre un servidor en una LAN, con clientes que
tengan acceso NFS en la LAN.
En esta sección no se tratará sobre la seguridad de NFS.
Asumiremos que Vd. ya ha configurado su paquete de filtrado, u otra protección
de cortafuegos, para prevenir el acceso desde el exterior.
Si su configuración permite el acceso desde el exterior a su servidor de NFS,
y si tiene algún tipo de datos confidenciales o importantes, le recomendamos
encarecidamente que haga uso de <a href="faq13.html">IPSec</a>.
De otro modo existe la posibilidad de que extraños puedan ver su tráfico NFS.
También sería posible que alguien pretendiera estar en la dirección IP que
tenga autorizada la entrada en su servidor NFS.
Existen varios tipos de ataques efectivos en este aspecto.
Cuando IPSec está correctamente configurado, protege contra todos estos tipos
de ataques.

<p>
Otra nota importante sobre seguridad.
No se limite a añadir un sistema de archivos a /etc/exports sin algún tipo de
lista de húespedes autorizados.
Sin una lista de huéspedes que puedan montar un directorio particular,
cualquiera que pueda llegar a su huésped podrá montar sus directorios de NFS
en <i>exports</i>.
</p>

<p>
La configuración consiste en un servidor con el ip <b>10.0.0.1</b>, que
servirá NFS sólo a clientes dentro de esa red.
El primer paso para configurar NFS es configurar su fichero 
<i>/etc/exports</i>.
Este fichero se compone de una lista con los sistemas de archivo que quiera
que se encuentren accesibles por medio de NFS, y define quién puede acceder a
cada uno de ellos.
Existen muchas opciones que puede usar en su fichero <i>/etc/exports</i>, y
es conveniente leer la página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>.
En este ejemplo empezaremos con un fichero <i>/etc/exports</i> como el
siguiente:
</p>

<ul><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></ul>

<p>
Esto quiere decir que el sistema de archivo local <b>/work</b> estará
disponible por medio de NFS.
<b>-alldirs</b> indica que los clientes podrán montar en cualquier parte del
punto de montaje <b>/work</b>.
<b>-ro</b> indica que sólo se permitirá montarlo en modo de sólo lectura.
Los dos últimos argumentos indican que sólo los clientes dentro de la red
10.0.0.0 que usen una máscara de red 255.255.255.0, estarán autorizados a
montar este sistema de archivo.
Esto es importante en algunos servidores accesibles desde diferentes redes.
</p>

<p>
Una vez que su fichero <i>/etc/exports</i> haya sido configurado, puede
seguir adelante y configurar su servidor NFS.
Primero debería asegurarse de que las opciones NFSSERVER y NFSCLIENT se
encuentren en la configuración del núcleo de su sistema (el núcleo GENERIC
incluye estas opciones).
A continuación debe configurar <strong>nfs_server=YES</strong> en el fichero
<i>/etc/rc.conf</i>.
De este modo, cuando reinicie el sistema, se activarán nfsd(8) y mountd(8).
Ahora ya puede continuar e iniciar los d&aelig;mons Vd. mismo.
Estos d&aelig;mons deben ser iniciados por root, y debe asegurarse de que
portmap(8) se encuentre funcionando en su sistema.
El ejemplo que sigue sobre cómo iniciar nfsd(8) sirve tanto para TCP como
para UDP usando 4 d&aelig;mons.
Para gestionar el máximo número de requerimientos de clientes concurrentes
a los que quiera dar servicio, debe activar un número apropiado de
d&aelig;mons del servidor NFS.

<p>

<ul>
<pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre>
</ul>

<p>
No sólo debe iniciar el servidor nfsd(8), sino que también necesita iniciar
mountd(8).
Éste es el d&aelig;mon que da servicio a los requerimientos para montar en
NFS.
Para iniciar mountd(8) escriba:
<p>

<ul>
<pre>
# <strong>/sbin/mountd</strong>
</pre>
</ul>

<p>
Si hace algún cambio al fichero /etc/exports mientras NFS esté funcionando,
tendrá que avisar a mountd sobre el cambio pasándole una señal
&quot;HUP&quot;:

<ul>
<pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre>
</ul>

<p>

<h3>Comprobación de estadísticas en NFS</h3>

<p>
Puede llevar a cabo comprobaciones para asegurarse de que estos d&aelig;mons
estén funcionando y registrados con RPC.
Para ello use rcpinfo(8).

<p>

<ul>
<pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre>
</ul>

<p>
Durante su uso normal, existen unas pocas utilidades más que le permitirán
ver lo que está ocurriendo con NFS.
Una de ellas es
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8&format=html">showmount(8)</a>,
que le permite ver qué se encuentra montado y quién lo está montando.
También está nfsstat(8), que muestra una información de las estadísticas
mucho más amplia.
Para usar showmount(8) escriba <b>/usr/bin/showmount -a host</b>.
Por ejemplo:

<p>

<ul>
<pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre>
</ul>

<h3>Cómo montar sistemas de archivo NFS</h3>

<p>
Los sistemas de archivo NFS se deben montar mediante mount(8), o más
exactamente mediante
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8&format=html">mount_nfs(8)</a>.
Para montar un sistema de archivo /work del huésped 10.0.0.1 en un sistema de
archivo local /mnt, haga lo siguiente (no necesita usar una dirección IP,
mount se encargará de la resolución de nombres):
<p>

<ul>
<pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre>
</ul>

<P>
Para que el sistema se monte al iniciar, añada una algo como lo que ve a
continuación en su fichero <i>/etc/fstab</i>:

<p>

<ul><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></ul>

<p>
¡¡Es importante que use <tt>0 0</tt> al final de esta línea para que su 
máquina no intente ejecutar fsck sobre el sistema de archivo NFS durante el
inicio del sistema!!
El resto de opciones de seguridad típicas como noexec, nodev, y nosuid,
también deberían usarse donde sean posibles, como en:

<p>

<ul><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></ul>

<p>
De este modo ningún dispositivo o programa setuid en el servidor NFS podrá
traspasar las medidas de seguridad en el cliente NFS.
Si no está montando programas para ejecutarlos en el cliente NFS, añada
noexec a esta lista.


<a name="6.8"></a>
<h2>6.8 - Servicio de Nombres de Dominio  - DNS, BIND, y named</h2>

<h3>6.8.1 &iquest;Qu&eacute; es DNS?</h3>

<p>
El &laquo;Servicio de Nombres de Dominio&raquo; (DNS, &quot;Domain Name
Service&quot;) es una facilidad de red que permite a los dominios de
redes IP proveer resoluciones de direcciones nombre-a-IP y resoluciones
direcci&oacute;n-a-nombre en respuesta a un requerimiento.  Su
instalaci&oacute;n de OpenBSD est&aacute; configurada por
definici&oacute;n como un cliente de DNS, pero no como un servidor de
DNS.  O sea, su instalaci&oacute;n de OpenBSD puede llevar a cabo un
requerimiento de DNS para la direcci&oacute;n de una m&aacute;quina 
contra un servidor de nombres de dominio, pero no puede responder a uno
de esos requerimientos de DNS de por s&iacute; a menos que la configure
para ello.

<p>
Mi m&aacute;quina con OpenBSD est&aacute; conectada actualmente a
Internet a trav&eacute;s de mi proveedor (ISP &quot;Internet Service
Provider&quot;), y por lo tanto puedo usar la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a>
para ejecutar el requerimiento de DNS:

</p>

<ul>
<pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre>
</ul>

<p>
<b>165.87.201.244</b> es el nombre del servidor que ha contestado,
porque es el &laquo;nombre de servidor&raquo; (&quot;nameserver&quot;)
que mi ISP me dijo que usara con mi cuenta, y cuyo n&uacute;mero se
introduce en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a>.
Pero la respuesta no fue autorizada.  Para una respuesta autorizada,
investiguemos cu&aacute;l es el servidor de DNS autorizado para el
dominio <i>openbsd.org</i>, y pregunt&eacute;mosle por la
direcci&oacute;n de <i>www.openbsd.org</i>:
</p>

<ul>
<pre>
# Identificar el nombre de los servidores de openbsd.org
# con la ayuda del nombre del servidor de mi ISP.
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet address = 199.185.137.3
gandalf.sigmasoft.com   internet address = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Usar la informaci&oacute;n conseguida para requerir una
# resoluci&oacute;n autorizada:
# requerir la autorizaci&oacute;n zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Address:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre>
</ul>

<p>
<i>zues.theos.com</i> es, como puede suponer, una m&aacute;quina que
funciona con OpenBSD y que est&aacute; correctamente configurada para
ser un servidor de DNS para el dominio <i>openbsd.org</i>.
</p>

<a name="6.8.1.1"></a>
<h3>6.8.1.1 &iquest;D&oacute;nde puedo aprender todo sobre DNS y su
implementaci&oacute;n en OpenBSD?</h3>

<ul>
<li>Lea los RFC <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, <a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a>, y <a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> 
para m&aacute;s informaci&oacute;n sobre el sistema de nombres de
dominio en Internet.</li>
<li>Lea el libro de O'Reilly Associates<i><a href="../../es/books.html#dns&bind">DNS and BIND</a></i>.</li>
<li>Lea las <a href="http://www.openbsd.org/cgi-bin/man.cgi">P&aacute;ginas de Manual de OpenBSD</a>,
en especial las p&aacute;ginas de</li>
   <ul>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&sektion=3&format=html">gethostbyname(3)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&sektion=8&format=html">named(8)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=3&format=html">resolver(3)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=5&format=html">resolver(5)</a>
   </ul>
</ul>

<p>
La orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a>
es epecialmente &uacute;til porque puede requerir un dominio y devolver
la informaci&oacute;n pr&aacute;cticamente en el mismo formato
requerido por los ficheros de configuraci&oacute;n de BIND.  Puede usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a>
para examinar nombres de servidores que sepa que est&aacute;n operando
correctamente para comparar su configuraci&oacute;n con la de ellos.
</p>

<h3>6.8.2 &iquest;Necesita mi m&aacute;quina ser un servidor de nombres
de dominio?</h3>

<p>
Si no est&aacute; seguro de si necesita que su m&aacute;quina haga el
papel de servidor de DNS, no la configure de ese modo.  La
instalaci&oacute;n de OpenBSD no activa su m&aacute;quina como servidor
de nombres de dominio por definici&oacute;n, aunque todos los ficheros
necesarios se encuentran instalados.  Para la mayor&iacute;a de
estaciones de trabajo, es suficiente con los ficheros
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5&format=html">/etc/hosts</a>
para indicar las direcciones IP de la m&aacute;quinas locales y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a>
para indicar qu&eacute; servidores de DNS le har&aacute;n el servicio
en la intranet o internet.
</p>

<p>
Por otra parte, podr&iacute;a necesitar configurar su m&aacute;quina
como un servidor de nombres de dominio:

<ul>
<li>Si tiene una LAN IP en la que no quiere replicar los ficheros
    &quot;hosts&quot; de direcciones locales en cada m&aacute;quina,
    puede configurar su m&aacute;quina con OpenBSD como servidor de DNS
    y servir los requerimientos de otras m&aacute;quinas de su
    LAN.</li>

<ul>
<li><b>Nota:</b> No existen restricciones en la pr&aacute;ctica al
    n&uacute;mero de servidores de DNS en una LAN.  Cualquier
    m&aacute;quina o todas las de la LAN puede ofrecer el servicio de
    DNS si se configuran para ello.  Que uno de estos servidores se
    considere autorizado desde fuera de su LAN (o incluso conocido
    desde fuera de la LAN), es un factor de configuraci&oacute;n que
    suele estar controlado por el nivel superior inmediato de su LAn en
    la jerarqu&iacute;a de dominios.</li>
</ul>

<li>Si tiene una LAN IP en la que residen m&aacute;quinas que quiera
    que sean localizables a trav&eacute;s de requerimientos de DNS por
    m&aacute;quinas en otra LAN o WAN.</li>

<li>Si tiene dificultades en resolver el nombre de dominio local a una
    direcci&oacute;n IP, o resolver cualquier otro nombre local a
    direcciones IP aunque tenga los ficheros <i>/etc/hosts</i> y
    <i>/etc/resolv.conf</i> correctamente (v.g., en OpenBSD, Netscape a
    veces se comporta de este modo porque implementa su propia
    herramienta de resoluci&oacute;n, en lugar de usar
    <i>gethostbyname(3)</i> para la b&uacute;squeda de
    direcciones).</li>
</ul>

<p>
Algo m&aacute;s a tener en cuenta es el velocidad de ejecuci&oacute;n.
Como la resoluci&oacute;n de nombres es un proceso repititivo, en el
que el servidor de nombres lleva a cabo repetidos requerimientos de
direcciones en dominios remotos a otros servidores de nombres, la
resoluci&oacute;n de nombres puede tardar algo m&aacute;s si tiene una
conexi&oacute;n por m&oacute;dem a Internet y est&aacute; requiriendo
direcciones remotas a su propio servidor de DNS (que har&aacute;
continuos requerimientos a servidores de nombres remotos a
trav&eacute;s del m&oacute;dem) que si est&aacute; requiriendo el
servidor de nombres de su ISP (que probablemente tenga una
conexi&oacute;n m&aacute;s r&aacute;pida a los servidores de nombres
remotos).
</p>

<h3>6.8.3 &iquest;Cu&aacute;les son los componentes de software del
servidor de DNS?</h3>

<ul>
<li>named <i>(``d&aelig;mon de name'')</i></li>
<li>Los ficheros de configuraci&oacute;n en el directorio bajo la
    jerarqu&iacute;a de <i>/var/named/</i></li>
</ul>

<h4>6.8.3.1 &iquest;Qu&eacute; nivel de BIND tiene soporte?</h4>

<p>
BIND es el nombre de la especificaci&oacute;n del comportamiento de un
servidor de nombres de dominio.  Los componentes de DNS existen para
implementar BIND de forma colectiva.
</p>

<p>
Existen dos especificaciones BIND diferentes:

<ol>
<li>BIND 4</li>
<li>BIND 8</li>
</ol>

<p>
Tal y como queda instalado, OpenBSD <b>named</b> tiene soporte para
BIND 4.x.

<h4>6.8.3.2 &iquest;Cu&aacute;les son algunas de las alternativas a
proveer DNS a trav&eacute;s de la implementaci&oacute;n predefinida de
BIND 4.x?</h4>

<ul>
<li>La implementaci&oacute;n de BIND 8.x en <i>/usr/ports/net/bind8</i> 
    (ver <a href="../../es/ports.html">portes</a>)</li>
<li>Tambi&eacute;n se encuentra disponible
    <a href="http://cr.yp.to/dnscache.html">DNSCache</a>, de D. J.
    Bernstein.  DNSCache tambi&eacute;n se puede encontrar en el
    &aacute;rbol de portes en <i>/usr/ports/net/dnscache/</i>.</li>
</ul>

<h5>6.8.3.2.1 Nota de <u>Seguridad</u></h5>

<p>
Si usa estas implementaciones alternativas del DNS, estar&aacute;
proveyendo un servicio de red cr&iacute;tico mediante el uso de unos
programas que pueden no haber sido sometidos al mismo nivel de
escrutinio que el d&aelig;mon de name en la instalaci&oacute;n
base, <b>named</b>, el cual ha pasado una
<a href="../../es/security.html">auditor&iacute;a de seguridad</a>.
Esta es una consideraci&oacute;n a tener muy en cuenta, ya que si un
servidor de nombres de dominio es puesto en peligro, los
resolucionadores que usen ese servidor de DNS pueden ser
redireccionados al sitio de un impostor.
</p>

<h3>6.8.4 &iquest;Cu&aacute;nto tengo que instalar?</h3>

<p>
Si la configuraci&oacute;n predefinida de la red se instal&oacute;
correctamente durante la instalaci&oacute;n de OpenBSD, tendr&aacute;
todo ya instalado.  S&oacute;lo tiene que configurar el d&aelig;mon de
name (&quot;named&quot;).
</p>

<h3>6.8.5 &iquest;C&oacute;mo configuro DNS?</h3>

<p>
Para configurar DNS en OpenBSD, edite y/o cree los ficheros que
controlan el d&aelig;mon de name, <code>named</code>.  La
ubicaci&oacute;n por definici&oacute;n de estos ficheros es el
directorio <i>/var/named</i> y sus subdirectorios, en especial el
fichero <i>/var/named/named.boot</i> que es el fichero de
inicializaci&oacute;n para <b>named</b>.  Tambi&eacute;n hay un par
m&aacute;s de pasos para la configuraci&oacute;n que se deben llevar a
cabo en <i>/etc</i>.
</p>

<p>
En este documento configuraremos el d&aelig;mon de name en
<i>nemo.yewtopia.com</i> como el nombre nombre primario del servidor
para el dominio (&iexcl;muy peque&ntilde;o!) <i>yewtopia.com</i>.  La
direcci&oacute;n de <i>nemo.yewtopia.com</i> es <i>192.168.1.9</i>.
Otras dos m&aacute;quinas en esa subrred son <i>crater.yewtopia.com</i>
en 192.168.1.1 y <i>earhart.yewtopia.com</i> en 192.168.1.2.
</p>

<h4>6.8.5.1 Configuraci&oacute;n en <i>/etc/named</i></h4>

<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<ul>
<pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain                source host/file
backup file
cache
root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre>
</ul>

<p>
Esto indica al proceso de inicializaci&oacute;n en qu&eacute;
subdirectorio y bajo qu&eacute; nombres encontrar&aacute; los ficheros
de configuraci&oacute;n de <i>yewtopia.com</i>.

<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<ul>
<pre>
; Reverse lookup for localhost interface
@       IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre>
</ul>

<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<ul>
<pre>
; yewtopia.com domain database
yewtopia.com.        IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre>
</ul>

<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<ul>
<pre>
; yewtopia domain reverse lookup database
1.168.192.in-addr.arpa. IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre>
</ul>

<h4>6.8.5.2 Configuraci&oacute;n en <i>/etc</i></h4>

<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>

<p>
Aseg&uacute;rese de que <i>/etc/resolv.conf</i> ahora se&ntilde;ale al
dominio de la m&aacute;quina local (el vez de, por ejemplo, el nombre
del servidor de su ISP), de modo que la resoluci&oacute;n del nombre en
requerimientos sea enviada al <b>named</b> que haya configurado.
+</p>

<ul>
<pre>
domain yewtopia.com
lookup file bind
</pre>
</ul>

<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>
Si anteriormente hubiera a&ntilde;adido las direcciones de varias
m&aacute;quinas al fichero <i>/etc/hosts</i>, puede que le interese
acortar su fichero <i>/etc/hosts</i> al estado en que se encontraba por
definic&oacute;n
</p>

<ul>
<pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre>
</ul>

<p>
de modo que <b>named</b> no sea circunvalado en favor de direcciones
(probablemente caducadas) en el fichero <i>/etc/hosts</i>.
&iexcl;<u>Aseg&uacute;rese de que tiene al menos la entrada predefinida 
de <i>localhost</i></u>, o su red no iniciar&aacute; correctamente!
Note tambi&eacute;n que <i>nemo</i> debe aparecer en su propio fichero
hosts, o de lo contrario ver&aacute; un mensaje de error (no
da&ntilde;ino) durante el arranque cuando <i>/etc/netstart</i> invoque
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8&format=html">route(8)</a>
para a&ntilde;adir <i>nemo</i> (cuyo nombre aparece en
<i>/etc/myname</i>).
</p>

<h4>6.8.5.3 Usar <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> para examinar los resultados.</h4>

<ul>
<pre>
$ <strong>dig @nemo.yewtopia yewtopia any any</strong>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia, type = ANY, class = ANY

;; ANSWERS:
yewtopia.        3600   SOA     nemo.yewtopia.
your_id.nemo.yewtopia. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.        3600   NS      nemo.yewtopia.

;; ADDITIONAL RECORDS:
nemo.yewtopia.   3600   A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre>
</ul>

<h3>6.8.6 &iquest;C&oacute;mo y cu&aacute;ndo inicio y paro DNS?</h3>

<h4>6.8.6.1 Iniciar DNS</h4>

<p>
El d&aelig;mon de name <b>named</b> se lanza durante el inicio del
sistema desde
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8&format=html">/etc/rc</a>
si la l&iacute;nea instalada por definici&oacute;n en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8&format=html">/etc/rc.conf</a>,
</p>

<ul>
<pre>
named_flags=NO          # para uso normal: &quot;&quot;
</pre>
</ul>

<p>
se cambia a
</p>

<ul>
<pre>
named_flags=&quot;&quot;          # para uso normal: &quot;&quot;
</pre>
</ul>

<p>
Examine tambi&eacute;n estas l&iacute;neas en <i>/etc/rc.conf</i>:
</p>

<ul>
<pre>
named_user=named                # named no deber&iacute;a ejecutarse como root a menos que fuera necesario
named_chroot=/var/named         # D&oacute;nde chroot named si no est&aacute; vac&iacute;o
</pre>
</ul>

<p>
Estos valores predefinidos ser&aacute;n v&aacute;lidos para
casi todas las configuraciones.
</p>

<p>
Para iniciar <b>named</b> de forma manual, use la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a>.
Por ejemplo:
</p>

<ul>
<pre>
# <strong>ndc start</strong>
          o
# <strong>ndc restart</strong>
</pre>
</ul>

<h4>6.8.6.2 Parar DNS</h4>

<p>
El mejor modo de parar el d&aelig;mon de name es usando la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a>.
Por ejemplo:
</p>

<ul>
<pre>
# <strong>ndc stop</strong>
</pre>
</ul>

<p>
Si no funcionara, encuentre el id del proceso de <code>named</code> y
use la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&sektion=1&format=html">kill(1)</a>
para finalizar el proceso.  El PID para <code>named</code> mientras
est&eacute; funcionando se encontrar&aacute; como la primera
l&iacute;nea del fichero <i>/var/named/named.pid</i>.
</p>

<ul>
<pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</ul>
</pre>

<h4>6.8.6.3 Reiniciar DNS con una configuraci&aocute;n alterada</h4>

<p>
Para hacer que un proceso en funcionamiento del d&aelig;mon de name se
reinicie recargando su configuraci&oacute;n despu&eacute;s de haberle
hecho cambios, env&iacute;e una se&ntilde;al &quot;hangup&quot;:
</p>

<ul>
<pre>
# <strong>kill -HUP 4608</strong> 
</pre>
</ul>

<p>
o use la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a>.
Por ejemplo:
</p>

<ul>
<pre>
# <strong>ndc restart</strong>
</pre>
</ul>

<h3>6.8.7 &iquest;Qu&eacute; ha quedado en el tintero sobre la
configuraci&oacute;n de DNS?</h3>

<p>
Hay muchas cosas de las que no hemos hablado, como por ejemplo,
c&oacute;mo configurar DNS para que los requerimientos para dominios de
intranet que no sean visibles desde la ra&iacute;z de la
jerarqu&iacute;a del dominio dependan de servidores dentro de su
empresa.  Lea los <a href="#6.8.1.1">documentos que le recomendamos</a>
para m&aacute;s informaci&oacute;n sobre DNS.
</p>

<p>
<p>
<font color="#0000e0">
<a href="index.html">[Volver al &Iacute;ndice Principal]</a>
<a href="faq5.html">[Secci&oacute;n 5.0 - Configuraci&oacute;n del N&uacute;cleo y del Disco]</a>
<a href="faq7.html">[To Secci&oacute;n 7.0 - Controles del Teclado]</a>
</font>
</p>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../back.gif" border="0" alt="[&iacute;ndice]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq6.html,v 1.71 2000/05/16 20:42:16 ericj Exp ]<br>
$Translation: faq6.html,v 1.14 2000/05/17 01:41:59 horacio Exp $<br>
$OpenBSD: faq6.html,v 1.9 2000/05/20 16:28:58 wvdputte Exp $
</small>
</p>
</body>
</html>
