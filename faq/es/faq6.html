<html>
<head>
<title>6.0 - Redes</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 1998-1999 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000" link="#23238E">

<img alt="[OpenBSD]" height="30" width="141" src="../../images/smalltitle.gif">
<p>
<h2><font color="#e00000">6.0 - Redes</font><hr></h2>
</p>

<p>
<ul><h3>Tabla de Contenidos</h3>
<li><a href="#6.0.1">6.0.1 - Introducción</a>
<li><a href="#6.1">6.1 - Configuración Inicial de la Red</a>
<li><a href="#6.2">6.2 - Filtros IP</a>
<li><a href="#6.3">6.3 - Traducción de Direcciones de Red (NAT)</a>
<li><a href="#6.4">6.4 - Protocolo de Configuración para Húespedes Dinámicos
    (DHCP)</a>
<li><a href="#6.5">6.5 - Protocolo Punto a Punto (PPP)</a>
<li><a href="#6.6">6.6 - Afinar Parámetros de Red</a>
<li><a href="#6.7">6.7 - Usar NFS</a>
</ul>
</p>
<hr>

<br>
<p>
<a name="6.0.1"></a>
<h2>6.0.1 - Introducción</h2>
<p>
Para la comprensión de la mayor parte de este documento será de gran ayuda
que haya leido y, por lo menos, asimilado en parte el capítulo
<a href="faq5.html">&laquo;Configuración del Núcleo&raquo;</a> de las
Preguntas Frecuentes, y las páginas de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&apropos=0&sektion=8&format=html">ifconfig(8)</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">netstat(1)</a>.

<p>
Si es Vd. un administrador de redes y está configurando protocolos de
enrutamiento, si está usando su sistema OpenBSD como un enrutador, si
necesita conocer más a fondo los protocolos de redes IP, entonces es
realmente necesario que lea
<a href="http://www.3com.com/nsc/501302s.html">Understanding IP
addressing</a>.
Éste es un documento excelente que contiene conocimientos fundamentales 
sobre redes de IP.

<p>
Si está trabajando con aplicaciones como servidores de http, servidores de
ftp, y servidores de correo, se puede beneficiar en gran medida de la lectura
de los
<a href="http://www.nexor.com/info/rfc/index/rfc.htm?index/rfc.html">RFCs</a>
(Nota: existe un proyecto de traducción de RFCs al castellano conocido como
<a href="http://www.arrakis.es/~pjleon/rfc-es/index.html">RFC-ES</a>).
Por supuesto que no podrá leerlos todos, así que elija algunos temas en los
que esté interesado, o que puedan serle útiles en su entorno de trabajo.
Los RFCs definen muchísimas (miles) de las normativas para protocolos en
internet y cómo se supone que deben funcionar.

<a name="6.1"></a>
<h2>6.1 - Configuración Inicial de la Red</h2>

<ul>Tabla de Contenidos
   <li><a href="#6.1.1">6.1.1 - Idenficación y Configuración de las
       Interfaces de Red</a></li>
   <li><a href="#6.1.2">6.1.2 - Configuración del Sistema OpenBSD como
       Pasarela</a></li>
   <li><a href="#6.1.3">6.1.3 - Configuración de los Alias en una Interfaz de
       Red</a>
</ul>

<p>
<a name="6.1.1"></a>
<h3>6.1.1 - Idenficación y Configuración de la Interfaces de Red</h3>
</p>

<p>
Lo primero que debe hacer para empezar es identificar su interfaz de red.
En OpenBSD las interfaces se designan por el tipo de tarjeta, no por el tipo
de conexión.
Puede ver su tarjeta de red iniciar durante el arranque, o después del
arranque usando la orden <strong>dmesg(8)</strong>.
También puede ver su interfaz de red usando la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>.
Por ejemplo, vea a continuación la salida originada por dmesg para una 
tarjeta de red ne2k, que usa un nombre de dispositivo ne*.
</p>

<ul>
<pre>
ne3 at pcmcia1 function 0 "Linksys, EtherFast 10/100 PC Card (PCMPC100), " port 0x340/16 irq 9
ne3: address 00:e0:98:04:95:ba
</pre>
</ul>

<p>
Si no sabe cuál es el nombre de su dispositivo, aquí tiene una lista de
tarjetas comunes con sus nombres de dispositivo.
</p>

<ul>
<li>ne2000 Network Cards - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ne&sektion=4&format=html">ne*</a> 
<li>3Com EtherLink III and Fast EtherLink III Ethernet - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&sektion=4&format=html">ep*</a>
<li>3Com EtherLink XL and Fast EtherLink XL Ethernet (3C9xx) - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xl&sektion=4&format=html">xl*</a>
<li>Intel 82586 chip Ethernet device driver - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ie&sektion=4&format=html">ie*</a>
<ul>Que incluyen tarjetas como:
	<li>3Com 3C507
	<li>AT&amp;T StarLAN 10
	<li>AT&amp;T EN100
	<li>AT&amp;T StarLan Fiber
	<li>Intel EtherExpress 16
</ul>
</ul>

<p>
También puede comprobar qué interfaces han sido identificadas usando la
utilidad <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>.
He aquí la salida que mostraría un dispositivo ne2k.
</p>

<ul>
<pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8009&lt;UP,LOOPBACK,MULTICAST&gt;
        inet 127.0.0.1 netmask 0xff000000
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt;
ne3: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
tun0: flags=10&lt;POINTOPOINT&gt;
tun1: flags=10&lt;POINTOPOINT&gt;
enc0: flags=0&lt;&gt;
bridge0: flags=0&lt;&gt;
bridge1: flags=0&lt;&gt;
</pre>
</ul>

<p>
Como habrá podido comprobar, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a> 
muestra mucha más información de la que necesitamos en este momento.
Pero lo importante aquí es que nos permite ver nuestra interfaz.
En el ejemplo anterior, la tarjeta de la interfaz ya está configurada.
Esto se sabe al ver que los valores ya han sido fijados en 
&quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;, y que los
indicadores <strong>UP</strong> y <strong>RUNNING</strong> están activados.
También podrá notar muchas otras interfaces.
A continuación puede ver una lista de interfaces que se supone que deben
estar ahí.
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&sektion-4&format=html">lo*</a> - Interfaz Loopback
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&sektion=4&format=html">sl*</a> - Interfaz de Red Slip
<li>ppp* - Protocolo Punto a Punto
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&sektion=4&format=html">tun*</a> - Interfaz de Red Tunnel
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4&format=html">enc*</a> - Interfaz de Encapsulamiento
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4&format=html">bridge*</a> - Interfaz Puente Ethernet
</ul>

<p>
Si su interfaz no ha sido configurada, el primer paso será crear el fichero
<strong>/etc/hostname.${IF}</strong>, donde el nombre de su interfaz
substituirá ${IF}.
De acuerdo con la información de los ejemplos anteriores, el nombre sería
<strong>/etc/hostname.ne3</strong>.
La composición de este fichero es como sigue a continuación.
Para leer más sobre el formato de este fichero, tome como referencia la
página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html">hostname.if(5)</a>
</p>

<ul>
<pre>
[address_family] [your_ip] [your_netmask] [media options]
</pre>
</ul>

<p>
Por lo tanto, para el ejemplo anterior, un nombre correcto sería parecido a
este:
</p>

<ul>
<pre>
$ <strong>cat /etc/hostname.ne3</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre>
</ul>

<p>
El siguiente paso será la configuración de su pasarela.
Para ello basta con que ponga el IP de su pasarela en el fichero
<strong>/etc/mygate</strong>.
Esto permitirá que su pasarela se active en el momento del arranque.
A continuación deberá configurar sus nombres de servidores
(&quot;nameservers&quot;) y su fichero <strong>/etc/hosts</strong>.
Para configurar sus nombres de servidores debe crear un fichero con el nombre
<strong>/etc/resolv.conf</strong>.
Puede leer más sobre el formato de este fichero en la página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">resolv.conf(5)</a>.
El siguiente ejemplo es para un uso típico.
En este ejemplo sus servidores de dominio son 125.2.3.4 y 125.2.3.5.
También pertenece al dominio &laquo;sudominio.dom&raquo;.
</p>

<ul>
<pre>
$ <strong>cat /etc/resolv.conf</strong>
search sudominio.dom
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre>
</ul>

<p>
Desde este punto ya puede reiniciar o bien ejecutar el guión de configuración
<strong>/etc/netstart</strong>.
Puede hacerlo escribiendo (como root):
</p>

<ul>
<pre>
$ <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre>
</ul>

<p>
Fíjese en que se producen un pequeño número de errores, pero éstos se
refieren a la interfaz de loopback.
Por lo tanto puede ignorar estos errores.
A partir de aquí su sistema debería funcionar correctamente.
Puede hacer una comprobación con 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>
para asegurarse de que su interfaz se configuró correctamente.
También puede comprobar sus rutas con <strong>netstat(1)</strong> o
<strong>route(8)</strong>.
A continuación puede ver un ejemplo de cómo ver sus tablas de rutas usando
ambas herramientas.
</p>

<ul>
<pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  ne3
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  ne3
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  ne3
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)
$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre>
</ul>

<p>
<a name="6.1.2"></a>
<h3>6.1.2 - Configuración del Sistema OpenBSD como Pasarela</h3>
</p>

<p>
Ésta es la información básica que necesita para configurar su sistema OpenBSD
como una pasarela (también llamada &laquo;enrutador&raquo; o
&laquo;encaminador&raquo;).
Si piensa usar OpenBSD como un enrutador en Internet, le sugerimos que lea
también la sección con las instrucciones sobre la configuración de
<a href="#6.2">Filtros IP</a>, para bloquear tráfico potencialmente
malicioso.
Además, debido a la escasa disponibilidad de direcciones IPv4 en los
proveedores de servicios de redes y registros regionales, es conveniente
leer la sección sobre <a href="#6.3">NAT</a> para información sobre cómo
conservar su espacio de dirección IP.
</p>

<p>
El núcleo GENERIC posee la capacidad de permitir IP Forwarding, pero debe ser
activado.
Para ello debe usar la utilidad <strong>sysctl(8)</strong>.
Para que los cambios sean permanentes, debe editar el fichero
<strong>/etc/sysctl.conf</strong> para habilitar IP Forwarding.
Esto lo puede llevar a cabo añadiendo la siguiente línea en ese fichero de
configuración.
</p>

<ul>
<pre>
net.inet.ip.forwarding=1
</pre>
</ul>

<p>
Para que este cambio surja efecto sin tener que reiniciar el sistema, use
directamente la utilidad <strong>sysctl(8)</strong>.
Recuerde que este cambio todavía no existirá después de reiniciar, y que
necesitará ser ejecutado como root.
</p>

<ul>
<pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre>
</ul>

<p>
A continuación modifique las rutas en los otros huéspedes de ambos lados.
OpenBSD ofrece muchas posibilidades de uso como enrutador, usando software
como 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&apropos=0&sektion=8&format=html">routed(8)</a>, <a href="http://www.gated.org">gated</a>, 
<a href="http://www.mrtd.net">mrtd</a>, y 
<a href="http://www.zebra.org">zebra</a>.
OpenBSD dispone de soporte para gated y mrtd en la colección de portes.
OpenBSD incluye soporte para varias interfaces T1, HSSI, ATM, FDDI, Ethernet,
e interfaces de serie (PPP/SLIP).
</p>

<p>
<a name="6.1.3"></a>
<h3>6.1.3 - Configuración de Alias en una Interfaz.</h3>
</p>

<p>
OpenBSD dispone de un simple mecanismo para configurar alias de ip en una
interfaz.
Para ellos sólo tiene que editar el fichero <i>/etc/ifaliases</i>.
El guión <i>/etc/rc</i>, que forma parte de la 
<a href="../faq10.html#10.3">jerarquía de inicio rc</a>, leerá este fichero
durante el proceso de inicio del sistema.
Por ejemplo, supongamos que el usuario tiene una interfaz <b>pn0</b> y
pertenece a la red 192.168.0.0.
Otra información de importancia:
</p>

<ul>
<li>IP para pn0 es 192.168.0.2
<li>NETMASK es 255.255.255.0
</ul>

<p>
El formato del fichero <i>/etc/ifaliases</i> es:
</p>

<ul>
<pre>
[interface] [ip address] [netmask]
</pre>
</ul>

<p>
Unas notas sobre los alias:  en OpenBSD sólo se usa el nombre de la interfaz;
no existen diferencias entre el primer alias y el segundo, por lo tanto, a
diferencia de otros sistemas operativos, no hay que referirse a ellos como
pn0:0 y pn0:1;  asegúrese también de que su netmask para el alias <b>NO</b>
sea el mismo que para el ip actual de la interfaz.
En este ejemplo de <i>/etc/ifaliases</i>, añadiremos dos alias al dispositivo
<b>pn0</b>.
</p>

<ul>
<pre>
$ <b>cat /etc/ifaliases</b>
pn0	192.168.0.3	255.255.255.255
pn0	192.168.0.4	255.255.255.255
</pre>
</ul>

<p>
<b>NOTA</b>:<br>

Después del lanzamiento de la versión 2.6, el fichero <i>/etc/ifaliases</i>
perdió valor.
A partir de OpenBSD 2.7 los alias se configurarán en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html"><i>/etc/hostname.*</i></a>.
Para configurarlo como anteriormente, tendrá un fichero
<i>/etc/hostname.pn0</i> estructurado del siguiente modo:
</p>

<ul><pre>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255 NONE
inet alias 192.168.0.4 255.255.255.255 NONE
</ul></pre>

<p>
Una vez que haya configurado este fichero será necesario reiniciar para que
los cambios funcionen.
Sin embargo, puede hacer efectivos los alias a mano, usando la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>.
Para hacer efectivo el primer alias use la orden:
</p>

<ul>
<pre>
# <b>ifconfig pn0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre>
</ul>

<p>
Para ver estos alias debe usar la orden:
</p>

<ul>
<pre>
$ <b>ifconfig -A</b>
pn0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre>
</ul>


<p>
<a name="6.2"></a>
<h2>6.2 - Filtros IP</h2>
</p>

<p>
El paquete IP Filter se creó con el fin de gestionar dos tareas, tratar con
permisos <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=8&format=html">ipf(8)</a>
para el envío a nivel de paquetes y asignar huéspedes/subrredes a un campo de
direcciones externas <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&apropos=0&sektion=8&format=html">ipnat(8)</a>.
Los ficheros de configuración para estos dos servicios son /etc/ipf.rules y
/etc/ipnat.rules.
</p>

<p>
Para activarlos durante el inicio del sistema es necesario editar
/etc/rc.conf.
También es necesario tener la línea net.inet.ip.forwarding=1 en
/etc/sysctl.conf (o el núcleo de su sistema necesita tener activada la opción
IPFORWARDING o GATEWAY).
Y también se necesita un núcleo compilado con las opciones IPFILTER y
IPFILTER_LOG (los núcleos GENERIC no disponen de estas opciones).
</p>

<p>
Si ha compilado IP Filter en su núcleo pero no lo ha activado en el fichero
/etc/rc.conf, lo puede activar fácilmente.

<ul>
<pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre>
</ul>

<p>
El indicador <tt>-E</tt> en ipf 'activa' IP Filter.
El indicador <tt>-Fa</tt> limpia cualquier regla que pueda tener ahí.<br>
<tt>-f /etc/ipf.rules</tt> carga las reglas desde /etc/ipf.rules.

<p>
Si hace algún cambio en /etc/ipf.rules después de haber cargado ipf, puede
recargar sus reglas muy fácilmente.

<ul>
<pre>
# ipf -Fa -f /etc/ipf.rules
</pre>
</ul>

Lo mismo para ipnat...

<ul>
<pre>
# ipnat -CF -f /etc/ipnat.rules
</pre>
</ul>

<p>
A partir de aquí este documento cubrirá algunos aspectos básicos de
configuraciones de ipf y ipnat.
Existen muchos ejemplos para ipnat y ipf en /usr/share/ipf, le recomendamos
que escoja el que más se acerque a la configuración que Vd. desee, y que lo 
modifique conforme a sus necesidades.
Puede encontrar más información sobre Filtros IP en los archivos de la
<a href="http://false.net/ipfilter/">lista de correo IP Filter</a>, en las
<a href="http://coombs.anu.edu.au/~avalon/">páginas de IP Filter</a>, y en el
<a href="http://www.obfuscation.org/ipf/">IP Filter HOWTO</a>.
</p>

<p>
<h3>IPF</h3>
</p>

<p>
Para activar ipf desde el momento del inicio del sistema necesita modificar
/etc/rc.conf de modo que lea IPFILTER=YES.
IP Filter (ipf) está controlado por /etc/ipf.rules, que se leerá durante el
inicio.
Para una explicación más detallada lea la página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=5&format=html">ipf(5)</a>.
En los siguientes ejemplos, fxp0 representa la interfaz externa a internet.
En su caso puede ser diferente según el adaptador de ethernet de que disponga
en su máquina.
En estas reglas se asumirá que existe una conexión permanente a internet, del
mismo tipo que la de un servidor de web.
</p>

<p>
Las reglas de IP Filter se procesan de modo secuencial desde el principio
hasta el final, siendo de ayuda para visualizar cada paquete que tenga que
atravesar cada regla antes de alcanzar su destino.
</p>

<p>
Por ejemplo, el grupo de reglas predefinido permite que entren y salgan todos
los paquetes:

<ul>
<pre>
pass out from any to any 
pass in from any to any
</pre>
</ul>

Supongamos ahora que no queremos permitir ninguna conexión entrante por el
puerto 3306 (mysql) porque la base de datos sólo debería permitir la conexión
de forma local.
En este caso el grupo de reglas sería así:

<ul>
<pre>
pass out from any to any
pass in from any to any
block in on fxp0 from any to any port = 3306
</pre>
</ul>

Que traducido viene a decir lo siguiente: &laquo;bloquear todos los paquetes
entrantes desde cualquier sitio hasta cualquier sitio cuyo destino sea
3306&raquo;.
Lo que ocurriría es que un paquete destinado al puerto 3306 en la interfaz
fxp0 pasaría la primera regla &quot;pass in&quot;, y acto seguido sería
bloqueado por la regla &quot;block in port = 3306&quot;.
En el caso en que se invirtieran las reglas de entrada (recuerde que el orden
es importante)

<ul>
<pre>
pass out from any to any
block in on fxp0 from any to any port = 3306
pass in from any to any
</pre>
</ul>

los paquetes destinados al puerto 3306 pasarían debido a que la última regla
en el grupo permite que pasen todos los paquetes.
Cuando esté escribiendo reglas para el filtrado de paquetes es importante que
tenga en cuenta lo siguiente:
<b>La última regla que concuerde tendrá precedencia</b>.
</p>

<p>
Por supuesto que existen excepciones para toda regla.
La opción <em>quick</em> filtra el paquete en la primera regla que concuerde.
Veamos el defectuoso ejemplo anterior añadiéndole la opción <em>quick</em> a
la regla &quot;block in&quot;:

<ul>
<pre>
pass out from any to any
block in quick on fxp0 from any to any port = 3306
pass in from any to any
</pre>
</ul>

<p>
Un paquete destinado para el puerto 3306 será filtrado por la regla 
&quot;block in quick&quot; y bloqueado inmediatamente.
Todos los paquetes destinados a otros puertos no encontrarán una concordancia
en las reglas hasta llegar a la regla &quot;pass in&quot; que permite que
pasen todos los paquetes.
</p>

<b>Denegación Predefinida</b>

<p>
La política de filtrado de páquetes más segura es la de &laquo;denegación 
por definición&raquo;.
Esta política es mucho más segura que la denegación explícita de cada
servicio protegido, permite grupos de reglas más breves, y puede proteger de
un servicio que haya sido mal configurado de modo accidental y que haya
quedado expuesto.

<p>
Veamos ahora otro ejemplo de grupo de reglas real, seguido de una explicación
línea por línea.
El siguiente ejemplo es para un servidor de web con una política de
denegación predefinida que sólo permite conexiones ssh (para administración),
y conexiones http (puerto 80) y https (puerto 443).

<ul>
<pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from any to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
##############################
# end ruleset
##############################
</pre>
</ul>

<p>
Esto permitirá las conexiones desde cualquier sitio a los puertos 22 (ssh),
80 (http) y 443 (https).
Cualquier otro intento de conexión distinto será bloqueado, y permitirá todas
las conexiones salientes.
Este grupo de reglas es muy estricto.
Pero, ¿y si Vd. sólo quisiera permitir la conexión a ssh a huéspedes internos
en su bloque de direcciones 1.1.1.0, y al mismo tiempo permitir conexiones
externas a http y https?
</p>

<ul>
<pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
##############################
# end ruleset
##############################
</pre>
</ul>

Muy bien, pero, ¿y si sólo quisiera permitir la administración remota de su
servidor de web a una sola máquina (1.1.1.1)?
En tal caso cambiaría esta regla:

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
</pre>
</ul>

por esta otra:

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
</pre>
</ul>

IP Filter tiene soporte para formas de &quot;netmask address&quot; tanto CIDR
como de punto decimal.
Por tanto podría escribir lo anterior de esta forma:

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.1/255.255.255.255 to any port = 22
</pre>
</ul>

pero, ¿para qué?
</p>

<b>Ejemplos de Reglas</b>

<p>
He aquí algunas buenas reglas para que las pueda usar cualquier persona (se
asume que fxp0 es la interfaz externa conectada a interner).
Para empezar configuraremos una simple protección contra la falsificación de
direcciones.

<ul>
<pre>
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8
</pre>
</ul>

También es una buena idea separar su interfaz de loopback de sus otras
reglas.

<ul>
<pre>
pass out quick on lo0
pass in quick on lo0
</pre>
</ul>

Nuestro grupo de reglas empieza a tener buena pinta;  cuando lo ponemos todo
junto, esto es lo que vemos:

<ul>
<pre>
###########################
# begin ruleset
###########################
# loopback rules

pass out quick on lo0
pass in quick on lo0

# no permitir a nadie falsificar direcciones que no puedan ser enrutadas

block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# permitir la conexión por ssh sólo a nuestra máquina de administración

pass in quick on fxp0 from 1.1.1.1/32 to any port = 22

# permitir que otros usen http y https

pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443

# finalmente, cerrar el resto con una denegación por definición

block in quick on fxp0 from any to any

# y dejar pasar todo el tráfico saliente

pass out on fxp0 from any to any

#############################
# end ruleset
#############################
</pre>
</ul>
</p>

<b>Registro de Paquetes</b>

<p>
De momento va bastante bien, pero podría ir mejor.
¿Qué haríamos si quisiéramos obtener un registro de cualquier intento de
conexión al puerto 22 (ssh) que fuera por nuestro cortafuegos?
Sería fácil, IP Filter puede gestionar este caso con la opción clave 
<em>log</em>:

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
block in log quick on fxp0 from any to any port = 22
</pre>
</ul>

Esta regla permitirá la conexión remota por el puerto 22 a nuestra máquina de
administración, pero denegará y registrará cualquier otro intento de conexión
al puerto 22.
</p>

<b>Filtrado de Paquetes según el Protocolo</b>

<p>
IP Filter también puede aplicar filtros basándose en el protocolo que esté
filtrando, de hecho, IP Filter puede filtrar cualquier protocolo que se
encuentre en la lista 
<a href=file://localhost/etc/protocols>/etc/protocols</a>.
Para ver esto con más claridad, sólo trataremos con tcp, udp, e icmp.
</p>

<p>
Para que ipf filtre según qué protocolo, se debe usar la opción clave 
<em>proto</em>.
Basándonos en el ejemplo anterior, y puesto que ssh funciona sobre tcp, sólo
deberíamos permitir la conexión a paquetes tcp.
Usando la opción clave <em>proto</em> para permitir sólo conexiones tcp,
obtendremos una regla como esta:

<ul>
<pre>
pass in quick on fxp0 proto tcp from 1.1.1.1/32 to any port = 22
</pre>
</ul>

Pero, ¿y si necesitáramos permitir conexiones a un servicio como bind que
funciona tanto sobre tcp como sobre udp?
En el caso de tcp/udp, IP Filter nos permite agrupar ambos protocolos en un
sólo (Nota: esto sólo es válido para tcp/udp).
Usando el ejemplo de bind, una regla que permita conexiones de tcp y udp en
un entorno de denegación por definición sería:

<ul>
<pre>
pass in quick on fxp0 proto tcp/udp from any to any port = 53
</pre>
</ul>
</p>

<b>Vudú en el Filtrado de Paquetes</b>

<p> 
Además de filtrar según el protocolo, IP Filter también puede gestionar
paquetes de IP fragmentados (un método común para bular filtros de paquetes).
Hay dos opciones claves posibles que se pueden usar para tratar paquetes de
ip fragmentados, <em>frag</em> para paquetes de IP fragmentados normales, o
<em>short</em> para paquetes de IP con cabeceras demasiado pequeñas para
poder compararlas.
Ya que, dependiendo de las condiciones de conexión, los paquetes fragmentados
pueden darse normalmente, es mejor filtrar sólo los paquetes con cabeceras
demasiado pequeñas como para obtener comparaciones válidas.
Esto se puede conseguir con la siguiente regla:

<ul>
<pre>
block in quick proto tcp all with short
</pre>
</ul>

¿Y qué hay de las Opciones de IP?
IP Filter también puede tratar con ese tipo de paquetes.
Los paquetes se pueden bloquear si tienen las opciones de IP activadas, o se
pueden bloquear según las opciones de IP que estén activadas.
Por ejemplo, la siguiente regla bloqueará y creará un registro de todos los
paquetes con las opciones de ip activadas.

<ul>
<pre>
block in log quick on fxp0 all with ipopts
</pre>
</ul>

Sin embargo, esto puede estropear algunas cosas como
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=traceroute&sektion=8&format=html">traceroute(8)</a>.
También es posible especificar qué opciones no serán permitidas.
Por ejemplo, una buena regla es la de bloquear todos los paquetes con
opciones de enrutamiento de fuentes.
Se puede llevar a cabo con esta regla:

<ul>
<pre>
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr
</pre>
</ul>

<b>Indicadores TCP, Conexiones Establecidas, y Mantenimiento del Estado</b>

<p>
La principal fuerza de IP Filter reside en su capacidad para filtrar paquetes
basándose en los indicadores TCP, y mantener conexiones establecidas y el
estado de la conexión.
Se recomienda a todos los usuarios que deseen filtrar paquetes basándose en
indicadores TCP que entiendan antes el papel que desempeña cada indicador.
Por ejemplo, si un usuario quisiera denegar la conexión a todos los paquetes
con los indicadores FIN, URG, y PSH activados (como por ejemplo un intento de
obtener la huella digital de un sistema operativo por nmap), podría usar una
regla como la siguiente:

<ul>
<pre>
block in quick proto tcp on fxp0 from any to any flags FUP
</pre>
</ul>

(Gracias a <a href=mailto:halogen@nol.net>Kyle Hargraves</a> por esa regla)
</p>

<p>
El próximo truco de IP Filter es su capacidad para &laquo;mantener el
estado&raquo;.
Se ha descrito mantener el estado como &laquo;no hablar hasta que no le
hablen&raquo;, o en otras palabras, una vez que se ha establecido una
conexión, los paquetes ya no tienen que atravesar grupos de reglas.
Ésta es una potente característica que permite escribir unas reglas mucho más
sencillas y seguras.
</p>

<p>
Por ejemplo, veamos cómo se puede aplicar este estado al ejemplo del grupo de
reglas anterior.
¿Todavía está confundifo?.
Revisémoslo: estamos permitiendo el acceso de gestión desde nuestra máquina 
de clase C al puerto 22 (ssh), y el acceso web a todo el tráfico a los
puertos 80 (http) y 443 (https).
Estamos bloqueando el resto de tráfico.
Pero, ¿y si quisiera conectar por ssh fuera del servidor de web? o,
¿y si necesitara usar lynx para buscar algo en las páginas de Preguntas
Frecuentes?
No podría, ya que habría bloqueado todas las conexiones entrantes que no
estuvieran dirigidas a los puertos especificados.
Aunque ésta es la ruta más segura, puede ser muy poco conveniente.
Al añadir las opciones clave <em>keep state</em> a la regla &quot;pass
out&quot;, puede permitir el paso de conexiones entrantes que sean respuestas
a conexiones que Vd. haya iniciado, como por ejemplo al navegar por la web.

<ul>
<pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any keep state
##############################
# end ruleset
##############################
</pre>
</ul>
</p>

<p>
Este pequeño cambio supondrá un dramático incremento en la flexibilidad y
seguridad de su grupo de reglas, ya que le permitirá hacer algo de magia.
Por ejemplo, en el grupo de reglas anterior, está permitiendo todo el tráfico
tcp a los puertos 80 y 443.
Aún puede ajustarlo un poco más.
Para establecer una conexión tcp sólo necesita permitir que tenga lugar el
saludo inicial (&quot;handshake&quot;);  una vez que esto ocurra, puede
bloquear el tráfico a ese puerto y permitir a la regla &quot;keep state&quot;
que gestione la conexión.
Para que se complete el saludo inicial, sólo necesita permitir el paso a los
paquetes con los indicadores SIN y SIN/ACK activados.
Al dejar pasar sólo paquetes con SIN y SIN/ACK activados puede prevenir
muchas formas de escaneos de puertos como puede ser el escaneo FIN.
Ahora las reglas están de este modo:

<ul>
<pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA
block in quick on fxp0 from any to any
pass out on fxp0 from any to any keep state
##############################
# end ruleset
##############################
</pre>
</ul>
</p>

<p>
Pongamos ahora todas las reglas que tenemos, poniéndolas en un solo paquete
de reglas.
Este paquete de reglas tendrá una política de denegación predefinida,
permitirá conexiones de gestión sólo desde una red local (mediante ssh), y
permitirá el paso de tráfico entrante en los puertos 80 (http) y 443 (https).
Además, protegerá contra direcciones de ip falsificadas no enrutables, y
bloqueará todos los paquetes que no estén tan fragmentados que no puedan ser
inspeccionados.
Una configuración bastante comprensiva para un servidor de web público.
He aquí cómo quedaría /etc/ipf.rules:

<ul>
<pre>
###########################
# begin ruleset
###########################
# reglas de loopback
pass out quick on lo0
pass in quick on lo0

# bloquear fragmentos diminutos
block in quick proto tcp all with short

# bloquear paquetes enrutados de fuentes
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr

# no permitir a nadie que falsee direcciones no enrutables
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# permitir la conexión por ssh sólo a sus máquinas
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22

# permitir que otros usen http y https
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA

# finalmente, bloquear el resto con una denegación por definición
block in quick on fxp0 from any to any

# y dejar pasar todo el tráfico saliente y mantener el estado
# en conexiones establecidas
pass out on fxp0 from any to any keep state

#############################
# end ruleset
#############################
</pre>
</ul>
</p>

<p>
Para más información sobre ipf, el
<a href=http://www.obfuscation.org/ipf/ipf-howto.txt>IPF howto</a> es una
fuente excelente, como también lo son los recursos disponibles en las páginas
de <a href=http://coombs.anu.edu.au/~avalon/ip-filter.html>IP Filter</a>.
</p>

<p>
<a name="6.3"></a>
<h2>6.3 - IPNAT</h2>
</p>

<p>
Desarrollado sobre un trabajo original de Wayne Fergerstrom 
&lt;wayne@methadonia.net&gt;
</p>

<ul>
   <li><a href="#nat1.0">6.3.1 Introducción</a>
   <ul>
      <li><a href="#nat1.1">6.3.1.1 Finalidad</a>
      <li><a href="#nat1.2">6.3.1.2 Terminología</a>
      <li><a href="#nat1.3">6.3.1.3 Detalles de Configuración</a>
   </ul>
   <li><a href="#nat2.0">6.3.2 Traducción de Direcciones de Redes (NAT)</a>
   <ul>
      <li><a href="#nat2.1">6.3.2.1 Introducción a NAT</a>
      <li><a href="#nat2.2">6.3.2.2 ¿Por Qué Usar NAT?</a>
      <li><a href="#nat2.3">6.3.2.3 Preconfiguración</a>
      <li><a href="#nat2.4">6.3.2.4 Configuración</a>
      <li><a href="#nat2.5">6.3.2.5 Funcionamiento</a>
   </ul>
   <li><a href="#nat3.0">6.3.3 Base de Conocimientos sobre NAT</a>
   <ul>
      <li><a href="#nat3.1">6.3.3.1 Comprobación del Status de NAT</a>
      <li><a href="#nat3.2">6.3.3.2 Limitaciones de NAT (en FTP)</a>
      <li><a href="#nat3.3">6.3.3.3 Redireccionamiento del Tráfico</a>
      <li><a href="#nat3.4">6.3.3.4 NAT frente a Proxy</a>
   </ul>
   <li><a href="#nat4.0">6.3.4 Referencias y Recursos</a>
</ul>

<hr>

<a name="nat1.0"></a>
<h3><u>6.3.1 Introducción</u></h3>

<a name="nat1.1"></a>
<b>Finalidad</b>

<p>
La finalidad de este documento es la de dar una idea básica y explicar la
instalación y configuración de la &laquo;Traducción de Direcciones de
Redes&raquo; (NAT) en una máquina OpenBSD.
Este documento está dirigido a usuarios con un nivel de conocimientos básico
a intermedio en UNIX, TCP/IP, y tecnologías de redes.
Se asume que el usuario ya ha instalado y configurado un sistema OpenBSD con
dos tarjetas de red (una conectada a internet y la otra a la red local).
</p>

<p>
Basado en <a href="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>,
ipnat ofrece una forma fácil para la asignación de redes locales a una
dirección única enrutable (&laquo;real&raquo;) de internet.
Esto es de gran utilidad si no dispone de direcciones asignadas oficialmente
para cada huésped en su red interna.
Cuando configura redes privadas/internas, puede aprovechar los bloques de
direcciones reservados (asignados en
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), como:

<pre>
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)
</pre>
</p>

<a name="nat1.2"></a>
<b>Terminología</b>

<p>
Los términos convencionales usados en este documento son bastante claros.
Con el fin de documentarlos, repasaré algunos de estos términos y la acepción
que toman en este documento.
</p>

<ul>
<strong>&quot;NAT&quot;</strong>
<p>
Describe la función de &laquo;Traducción de Direcciones de Red&raquo;.
El proceso de NAT se describirá más adelante en este documento.
</p>
</ul>

<ul>
<strong>&quot;ipnat&quot;</strong>

<p>
Es la abreviación de &laquo;Traducción de Direcciones de Red IP&raquo;.
Se puede utilizar de manera indistinta en substitución de NAT.
Sin embargo, en este documento el térmitno &quot;ipnat&quot; se utilizará tan
sólo para el uso de la línea de órdenes.
</p>
</ul>

<ul>
<strong>&quot;IPF&quot;</strong>
<p>
Es la abreviación de &laquo;Filtro IP&raquo;.
IP Filter es un paquete de software de filtrado portable que se incluye como
parte del sistema OpenBSD.
IP Filter debe estar activado antes de poder activar ipnat.
Se activa de modo fácil, simplemente editando el fichero /etc/rc.conf y
cambiando ipf=NO por ipf=YES.
Esto sólo lo cambiar para la secuencia de inicio, y es necesario ejecutar
'ipf -E' para activar ipf mientras el sistema está en funcionamiento.
Más adelante se describen estos pasos.
</p>
</ul>

<br>
<a name="nat1.3"></a>
<b>Detalles de Configuración</b>

<p>
Esta parte se refiere a los detalles de configuración de las máquinas para
este documento.
Su configuración será distinta de ésta, pero el propósito de este documento
es el de ofrecerle una breve idea de cómo puede ser, con el fin de que pueda
adaptar esta información a su configuración.
</p>

<ul>
<b>Sistema Operativo de la Máquina: </b>OpenBSD v2.5 i386<br>
<br>
<b>NICs: </b>
<ul>
	NetGear 10/100MB <b>pn0</b><br>
	Conectada a una LAN EXTERNA (o WAN)<br>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<br>
	NetGear 10/100MB <b>pn1</b><br>
	Conectada a una LAN INTERNA<br>
	<b>IP Address: </b>192.168.1.1<br>
	<b>Netmask: </b>255.255.255.0<br>	
</ul>
<br>
<b>IP enrutable por Internet, externo (en este ejemplo, una conexión por
módem analógico provista por un Proveedor de Servicios de Internet)<br></b>
<ul>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<b>Gateway: </b>24.5.0.1<br>
</ul>
<br>
<b>Red de Área Local (LAN)</b><br>
<ul>
En este ejemplo, las máquinas de la LAN usan el esquema de direcciones IP
192.168.1.xxx (donde xxx es un número único).
Existe una gran variedad de sistemas operativos diferentes en la LAN interna,
incluidos Windows 98, Windows NT, OpenBSD y Linux.
Cada máquina está conectada a un &quot;hub&quot; designado para uso interno.
Para este documento y sus ejemplos, el cliente en la LAN asumirá una
dirección IP 192.168.1.40
</ul>
<br>
<b>Diagrama de Configuración</b>
<ul><pre>
+-----+              +---------+         +----------+
| Hub |--------- pn1 |   NAT   | pn0 ----| Internet |
+-----+              +---------+         +----------+
  | |
  | +-- Cliente A
  +---- Más clientes 

                              +--------------------------+
                              |           LEGEND         |
                              +--------------------------+
                              |   NIC pn0 - 24.5.0.5     |
                              |   NIC pn1 - 192.168.1.1  |
                              | Cliente A - 192.168.1.40 |
                              +--------------------------+

</pre></ul>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Traducción de Direcciones de Red</u></h3>
<br>

<a name="nat2.1"></a>
<b>Introducción a NAT</b>

<p>
Cada día más empresas y usuarios entran en Internet, y cada uno debe tener
una dirección IP, pero las direcciones IP públicas son cada vez más 
difíciles de conseguir.
Para muchas personas la solución ha sido la &laquo;Traducción de Direcciones
de Red&raquo; (o NAT).
NAT es un modo muy simple y a la vez muy potente de conectar una LAN a
Internet sin tener que comprar o alquilar direcciones IP para cada máquina.
NAT también es conocido como &laquo;Enmascaramiento de IP&raquo; entre los
usuarios de Linux.
</p>

<p>
Cuando NAT está funcionando correctamente, permite que los usuarios dentro de
la LAN puedan acceder a Internet a través de diferentes direcciones de IP (la
que haya activado con su proveedor).
Cada máquina conectada a la LAN usa la dirección IP (de forma transparente)
de la máquina que está configurada para usar la dirección de IP asignada por
el Proveedor de Servicion de Internet (ISP).
</p>

<p>
El modo en que funciona NAT es increiblemente simple.
Cuando un cliente dentro de la LAN quiere conectar a la máquina en Internet,
le envía un paquete TCP con un requerimiento de conexión.
Dentro de la cabecera del paquete TCP se encuentra la dirección IP del
cliente (o sea, 192.168.1.40) y la dirección IP del anfitrión requerido (o
sea, 123.45.67.89).
La máquina en la que está funcionando NAT intercepta este paquete TCP y
cambia la dirección IP del cliente de 192.168.1.40 a la dirección IP de la
máquina conectada a Internet (o sea, 24.5.0.5).
De este modo engaña a la máquina anfitriona, haciéndole pensar que la
conexión requerida proviene de la máquina con NAT, no de la máquina cliente.
Entonces el anfitrión envía de vuelta respuestas a la máquina NAT como si
ésta fuera la que se estuviera conectando.
Cuando la máquina NAT recibe las respuestas, las traduce rápidamente y envía
el paquete al cliente.
El cliente no tiene ni la más remota idea de lo que está ocurriendo y la
falsificación de la conectividad a Internet es totalmente transparente.
</p>

<p>
El ejemplo siguiente muestra NAT de un modo más claro:
</p>

<ul><pre>
Cliente ----------------- pn1 [ NAT ] pn0 ---------- Anfitrión de Internet
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

Paquete TCP SALIENTE                            Paquete TCP SALIENTE
Desde: 192.168.1.40      &gt;&gt;=== NAT ===&gt;&gt;        Desde: 24.5.0.5
Hacia: 123.45.67.89                             Hacia: 123.45.67.89

Paquete TCP ENTRANTE				Paquete TCP ENTRANTE
Desde: 123.45.67.89 				Desde: 123.45.67.89
Hacia: 192.168.1.40      &lt;&lt;=== NAT ===&lt;&lt;        Hacia: 24.5.0.5
</pre></ul>

<br>
<a name="nat2.2"></a>
<b>Porqué Usar NAT</b>

<p>
Una vez que ya había conseguido un módem cable en mi nuevo 
apartamento me dí cuenta de que tenía un pequeño problema.
¿Cómo podría conseguir acceso a Internet para mis compañeros de apartamento
si el módem estaba en mi habitación?
Sólo había unas pocas opciones que podían ayudarme, y que iban desde obtener
direcciones IP extras, pasando por instalar un servidor proxy, hasta instalar
NAT (no permita que el ejemplo del módem cable le engañe, NAT es lo 
suficientemente potente como para enmascarar un gran red con cientos o 
incluso miles de máquinas).
</p>

<p>
Existen varias razones por las que decidí instalar NAT, la primera de ellas
mi economía.
En la casa vivían dos compañeros de piso (cada uno con su propio PC) y yo
(con tres PCs).
Mi ISP sólo permitía tres direcciones IP por casa, lo que significaba que no
habían suficientes IPs para que cada máquina pudiera tener acceso a Internet.
</p>

<p>
Usando NAT cada máquina tendría una dirección IP única (interna), pero
compartirían la única dirección IP que mi ISP me dio.
El coste se redujo.
</p>

<br>
<a name="nat2.3"></a>
<b>Preconfiguración</b>

<p>
Para activar NAT en su máquina OpenBSD, necesitará configurar IPF y NAT.
Esto se puede llevar a cabo de una manera fácil editando los ficheros que
aparecen en la siguiente lista (haga los cambios al fichero de modo que
aparezcan como las opciones que siguen a continuación):
</p>

<p>
<b>/etc/rc.conf</b> (este fichero se usa para iniciar servicios durante el
                    arranque)
</p>

<ul>
	ipfilter=YES<br>
	ipnat=YES
</ul>

<p>
<b>/etc/sysctl.conf</b>
</p>

<ul>
	net.inet.ip.forwarding=1
</ul>

<p>
Después de haber hecho estos cambios, la máquina estará lista para la
configuración de NAT.
</p>

<br>
<a name="nat2.4"></a>
<b>Configuración</b>

<p>
El primer paso es configurar el fichero de reglas de IPF
(<i>/etc/ipf.rules</i>).
Para el propósito que persigue este documento, dejaremos que el tráfico pase
a través de esta opción de cortafuegos sin que haya interferencias.
El fichero será como sigue:
</p>

<ul>
<pre>
pass in from any to any
pass out from any to any
</pre>
</ul>

<p>
Para más información puede leer la <a href="#6.2">sección 6.2</a> de estas
Preguntas Frecuentes.
</p>

<p>
La sintaxis del fichero de configuración de NAT (<i>/etc/ipnat.rules</i>) es
bastante simple.
De acuerdo con el ejemplo de configuración anterior, el fichero de
configuración de NAT contendrá las siguientes entradas:
</p>

<ul>
<pre>
map pn0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map pn0 192.168.1.0/24 -&gt; 24.5.0.5/32
</pre>
</ul>

<p>
He aquí lo que significan estas líneas.
</p>

<ul>
<strong>&quot;map&quot;</strong>
<p>
Ésta es la orden que se le pasa a ipnat.
Dicha orden indica a ipnat que ésta es una entrada para cambiar la dirección
IP entre la LAN e Internet.
</p>
</ul>

<ul>
<strong>&quot;pn0&quot;</strong>
<p>
Ésta es la interfaz de red que está conectada a Internet.
</p>
</ul>

<ul>
<b>&quot;192.168.1.0/24&quot;</b>
<p>
La dirección IP y de enmascaramiento de red (&quot;netmask&quot;, cuyo
formato es CIDR).
La combinación de ambas indica que &laquo;cualquier dirección IP con un valor
desde 192.168.1.1 hasta 192.168.1.254 debe ser asignado&raquo;.
Si prefiere no usar el formato CIDR, puede substituir &laquo;/24&raquo; por
&laquo;/255.255.255.0&raquo;.
</p>
</ul>

<ul>
<b>&quot;24.5.0.5/32&quot;</b>
<p>
Esta dirección de IP y de enmascaramiento de red indica la dirección IP que
se asignará a la LAN.
/32 indica una sola dirección IP.
También puede asignarle direcciones IP /24, ó 256 (ó /27, ó cualquier otro
número de bits que quiera).
Esto último es muy útil si tiene varios miles de máquinas huéspedes detrás de
su NAT... claro que sólo es de utilidad si ese /24 está siendo enrutado a su
sistema OpenBSD.
</p>
</ul>

<ul>
<b>&quot;portmap tcp/udp 10000:60000&quot;</b>
<p>
Esto asigna todos los paquetes tcp/udp a puertos desde el 10000 hasta el 
60000.
</p>
</ul>

<p>
La segunda línea tiene casi la misma entrada que la primera, exceptuando la
parte final.
En esta línea se indica a ipnat que debe asignar cualquier otra cosa (que no
sea tcp/udp, ya que esos paquetes concuerdan en la primera línea) a cualquier
puerto que requiera (usado por ICMP y otros protocolos).
Una vez que esto está en el fichero, sólo tiene que ejecutar el d&aelig;mon
IPF.
</p>

<br>

<a name="nat2.5"></a>
<b>Funcionamiento</b>

<p>
Ejecutar NAT también es un proceso muy sencillo.
Una vez que haya acabado de configurarlo, hay dos maneras de activar NAT.
La primera manera, y la mejor si fuera posible comprobar la fase de
configuración, es reiniciando su sistema OpenBSD.
Para ello basta que use la orden &laquo;<i>reboot</i>&laquo;.
</p>

<p>
Si quiere ejecutar ipnat desde la línea de órdenes, use las siguiente
órdenes:
</p>

<ul>
<pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre>
</ul>

<p>
Con la primera línea de órdenes se activa IPF (recuerde que NAT depende de 
IPF, y por lo tanto es necesario iniciar IPF y tenerlo en funcionamiento antes 
de poder cargar NAT).
Las opciones en la línea de órdenes &quot;-Fa&quot; limpian cualquier entrada
existente.
&quot;-f /etc/ipf.rules&quot; indica a ipf dónde encontrar el fichero con las
reglas.
&quot;-E&quot; es el interruptor para activar el d&aelig;mon IPF.
</p>

<p>
La segunda línea de órdenes es para activar NAT.
&quot;-CF&quot; limpia y descarga todas las entradas existentes en la tabla
de NAT.
&quot;-f /etc/ipnat.rules&quot; indica a NAT dónde encontrar el fichero con
las reglas de NAT.
Ahora ya tiene NAT funcionando.  Así de sencillo.
</p>

<p>
<b>Nota:</b> para volver a cargar las configuraciones de NAT (en el caso en
que las cambiara y no quisiera reiniciar) ejecute la segunda orden de nuevo.
Las configuraciones serán descargadas y cargadas de nuevo.
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 Base de Conocimientos de NAT</u></h3>

<br>
<a name="nat3.1"></a>
<b>Verificar el Estado de NAT</b>

<p>
Para averiguar cómo está funcionando NAT o asegurarse de que las
configuraciones hayan hecho efecto, use la opción &quot;-l&quot;.
Esta opción le mostrará un listado de todas las opciones de configuración y
sesiones actuales que esté usando ipnat:
</p>

<ul>
<pre>
# <b>ipnat -l</b>
map pn0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map pn0 192.168.1.0/24 -&gt; 24.5.0.5/32

List of active sessions:
MAP 192.168.1.40  2473  &lt;- -&gt; 24.5.0.5  13463 [129.128.5.191 80]
</pre>
</ul>

<p>
El propósito de las primeras dos líneas es el de verificar las
configuraciones que se introdujeron anteriormente en /etc/ipnat.rules.
Cualquier línea a partir de esas dos mostrará una lista de las conexiones que
estén siendo actualmente controladas por NAT.
</p>

<ul>
<b>&quot;MAP 192.168.1.40  2473&quot;</b>
<p>
Le indica la dirección IP de la máquina que esté usando NAT en la LAN.
El número del puerto que se use para realizar la conexión se mostrará a
continuación.
</p>
</ul>

<ul>
<b>&quot;&lt;- -&gt;&quot;</b>
<p>
Indica que NAT está gestionando el flujo de tráfico en ambas direcciones.
</p>
</ul>

<ul>
<b>&quot;24.5.0.5  13463&quot;</b>
<p>
Indica que la conexión va a Internet a través de la dirección IP 24.5.0.5 y
que usa el puerto 13463.
</p>
</ul>

<ul>
<b>&quot;129.128.5.191 80&quot;</b>
<p>
La dirección IP y el puerto por el que se está realizando la conexión.
</p>
</ul>

<a name="nat3.2"></a>
<b>Limitaciones de NAT (en FTP)</b>

<p>
NAT tiene unas pocas limitaciones a tener en cuenta.
Cuando un usuario conecta a un servidor de FTP remoto y pide información o un
fichero a éste, el servidor de FTP conectará con el cliente y le transferirá
los datos.
Este proceso se lleva a cabo por un puerto libre aleatorio.
Pero esto representa un problema para los usuarios que intentan obtener
acceso a los servidores de FTP desde dentro de la LAN.
Cuando el servidor de FTP envía sus datos, los envía al NIC externo en un
puerto aleatorio.
La máquina NAT los recibe, pero como no tiene ninguna asignación para el
paquete desconocido ni para ese puerto en concreto, suelta el paquete y no
lo entrega.

<p>
La solución a esto está en que el usuario se ubique en &laquo;modo
pasivo&raquo; en su cliente de FTP.
De este modo indicará al servidor que desea conectarse a éste, y que no
ocurra lo antes mencionado.
Así, al realizar el usuario la conexión, NAT la gestionará correctamente.

<p>
IP Filter ofrece otra solución para esta situación, un &quot;proxy&quot; de
ftp integrado en el código de NAT.
Para activarlo, debe escribir algo parecido a lo siguiente antes de sus otras
asignaciones para NAT.

<pre>
map pn0 192.168.1.0/24 -&gt; 24.5.0.5/32 proxy port ftp ftp/tcp
</pre>

Con esto, el núcleo del sistema observará sus conexiones por FTP para la
orden &quot;PORT&quot; que proceda del cliente de ftp, y substituirá la
dirección IP y el puerto con su propia dirección IP externa y con un puerto
de su elección.
Obviamente, esto requiere de un uso mucho más intensivo de recursos pero, a
menos que su máquina de filtrado NAT/IP esté alcanzando una masa crítica, no
debería darle ningún problema.
<p>


<br>
<a name="nat3.3"></a>
<b>Redireccionamiento del Tráfico</b>

<p>
Es posible que haya momentos en los que necesite redireccionar el tráfico
entrante o saliente hacia cierto protocolo o puerto.
Un buen ejemplo de esto podría ser el caso en el que tuviera un servidor que
residiera dentro de la LAN y que estuviera haciendo la función de servidor de
web.
Las conexiones entrantes a su IP válido de Internet se encontrarían con que, 
a menos que su máquina NAT fuera el servidor de web, no podrían conectar.
Para solventarlo usaremos la directiva `rdr' de NAT en el fichero de reglas,
para darle las instrucciones sobre a dónde debe redireccionar (o enrutar) una
conexión en particular.
</p>

<p>
Para nuestro ejemplo, supongamos que un servidor de web reside en la LAN y
que su dirección IP es 192.168.1.80.
El fichero de reglas de NAT necesita una nueva directiva para gestionar esto.
Añada una línea parecida a la siguiente a su ipnat.con:
</p>

<ul>
<pre>
rdr pn0 24.5.0.5/32 port 80 -&gt; 192.168.1.80 port 80
</pre>
</ul>

<p>
Desglosando esta línea para ver qué signfica cada componente de ella:
</p>

<ul>
<b>&quot;rdr&quot;</b>
<p>
Es la orden que le está pasando a ipnat.
Indica a ipnat que lo que sigue es una entrada para redireccionar una
conexión.
</p>
</ul>


<ul>
<b>&quot;pn0&quot;</b>
<p>
Es la interfaz de red que está conectada a Internet.
</p>
</ul>

<ul>
<b>&quot;24.5.0.5/32&quot;</b>
<p>
Indica que es una conexión entrante a esta dirección IP (sólo en pn0, como
arriba).
</p>
</ul>

<ul>
<b>&quot;port 80&quot;</b>
<p>
Éste es el puerto (80) que debe ser redireccionado.
El número &laquo;80&raquo; no es estrictamente necesario, también podría usar 
&laquo;port www&raquo; para especificar una redirección del puerto 80.
Si desea usar un nombre en lugar de un número, el nombre del servicio y el
puerto correspondiente deben existir en el fichero /etc/services.
</p>
</ul>

<ul>
<b>&quot;192.168.1.80&quot;</b>
<p>
Es la dirección IP y de enmascaramiento de red (&quot;netmask&quot;) de la
máquina LAN a la que redireccionan los paquetes.
El enmascaramiento de red es siempre &laquo;/32&raquo; (y por tanto no es
necesario especificarlo), para que los paquetes puedan ser redirigidos a una
máquina en particular.
</p>
</ul>

<p>
Cuando haya terminado de añadir todos los datos, recargue las reglas de NAT y
el redireccionamiento comezará de inmediato.
</p>

<br>
<a name="nat3.4"></a>
<b>NAT frente a Proxy</b>

<p>
La diferencia entre NAT y una aplicación basada en proxy es que el software
de proxy actúa como un intermediario entre Internet y las máquinas conectadas
a la LAN.
En prinicipio esto no presenta ningún problema, sin embargo cada aplicación
que quiera ejecutar en su máquina y conectarla a Internet a través del
servidor de proxy, DEBE reconocer el proxy (ser capaz de usarlo).
No todas las aplicaciones con capaces de esto (en especial los juegos).
Aún más, no existen aplicaciones para servidores de proxy para todos los
servicios de Internet.
NAT asigna su red interna de un modo transparente, para que pueda conectar a
Internet.
La única ventaja de seguridad que proxy tiene sobre NAT es que el software de
proxy puede haber sido programado para funciones de seguridad, y puede
filtrar según el contenido con el fin de evitar que una macro de virus se 
interne en su máquina Windows, o proteger sus programas contra
desbordamientos de la memoria intermedia (&quot;buffer overflows&quot;), y
otros peligros.
El mantenimiento de estos filtros es a menudo un trabajo muy pesado.
</p>

<a name="nat4.0"></a>
<b>6.3.4 Referencias y Recursos</b>

<p>
Ficheros de OpenBSD:
<ul>
   <li>/etc/ipnat.rules - fichero de reglas de NAT
   <li>/etc/rc.conf - fichero para iniciar ipnat e ipf durante el arranque 
       del sistema
   <li>/etc/sysctl.conf - fichero para activar IP forwarding
   <li>/usr/share/ipf/nat.1 - ejemplos de ipnat.rules
</ul>
</p>

<p>
Enlaces de NAT en Internet:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8">http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=5&format=html">Página de manual que muestra la sintaxis correcta de ipnat.rules</a>
<li><a href="http://coombs.anu.edu.au/~avalon/">http://coombs.anu.edu.au/~avalon/</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>

<p> 
<a name="6.4"></a> <h2>6.4 - DHCP</h2> </p>

<h3>6.4.1 Cliente DHCP</h3>

<p>
Para usar el cliente DHCP incluido en OpenBSD, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&apropos=0&sektion=8&format=html">dhclient(8)</a>,
edite el fichero /etc/hostname.xl0 (suponiendo que su interfaz principal de
ethernet sea xl0;  la suya podría ser ep0, o fxp0, o cualquier otra).
Todo lo que necesita añadir a este fichero es 'dhcp'.

<pre>
# <strong>echo dhcp >/etc/hostname.xl0</strong>
</pre>

Esto hará que OpenBSD inicie el cliente DHCP automáticamente durante el
arranque.
OpenBSD obtendrá la información sobre su dirección IP, pasarela, y servidores
de DNS desde el servidor de DHCP.

<p>
Si quiere iniciar un cliente dhcp desde la línea de órdenes, asegúrese de que
el fichero /etc/dhclient existe, y entonces escriba:

<pre>
# <strong>dhclient fxp0</strong>
</pre>

en donde fxp0 es la interfaz en la que quiere recibir dhcp.

<p>
Sea cual fuere el modo en que inicie dhclient, puede <b>evitar</b> que se
actualice su DNS de acuerdo con la idea que tenga el servidor dhcp sobre la
DNS, comentando las líneas precedidas por 'request' (son ejemplos de la
configuración predefinida, pero necesita activarlos para anular la
configuración predefinida de dhclient)

<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>

y a continuación <b>eliminar</b> domain-name-servers.
También es posible que también desee anular hostname u otras configuraciones.

<p>
<h3>6.4.2 Servidor DHCP</h3>

Si quiere usar OpenBSD como servidor DHCP con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&apropos=0&sektion=8&format=html">dhcpd(8)</a>,
edite el fichero /etc/rc.conf.
Configúrelo poniendo dhcp_flags=&quot;-q&quot; en lugar de dhcp_flags=NO.
Añada en /etc/dhcp.interfaces las interfaces en las que quiera que dhcp esté
&laquo;a la escucha&raquo;

<pre>
# <strong>echo xl1 xl2 xl3 >/etc/dhcpd.interfaces</strong>
</pre>

y edite /etc/dhcpd.conf.
Las opciones son bastante claras:

<pre>
        option  domain-name &quot;xyz.mil&quot;;
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Con esto indicará a sus clientes dhcp que el dominio que deben añadir a sus
requerimientos de DNS es xyz.mil (así, si un usuario escribiera 'telnet joe',
los enviaría a joe.xyz.mil).
Les dirigirá a los servidores de DNS 192.168.1.3 y 192.168.1.5.
Para los huéspedes que se encuentren en la misma red que una interfaz de
ethernet en la máquina de OpenBSD, que está en el rango 192.168.1.0/24, les
asignará una dirección de IP entre 192.168.1.32 y 192.168.1.127, configurando
su pasarela por definición como 192.168.1.1.

<p>
Si quiere iniciar dhcpd desde la línea de órdenes, después de editar
/etc/dhcpd.conf intente lo siguiente:

<pre>
# <strong>dhcpd -q fxp0</strong>
</pre>

En donde fxp0 es la interfaz que Vd. desea que empiece a servir dhcp.
El indicador -q fuerza dhcpd en silencio, de otro modo es muy ruidoso.

<p>
Si está actuando como servidor de DHCP para una máquina Windows, es posible
que quiera que dhcp ofrezca al cliente una dirección de servidor 'WINS'.
Para ello añada la siguiente línea al fichero /etc/dhcpd.conf:

<pre>
option	netbios-name-servers	192.168.92.55;
</pre>

En donde 192.168.92.55 es el IP de su servidor de Windows o Samba.
Para ver más opciones que puedan aceptar sus clientes DHCP, lea
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&apropos=0&sektion=5&format=html">dhcp-options(5)</a>.

<p>
<a name="6.5"></a>
<h2>6.5 - PPP </h2>
</p>

El &laquo;Protocolo Punto a Punto&raquo; es el que se suele usar para crear
una conexión con su ISP a través de un modem.
OpenBSD puede hacer esto de dos maneras:

<ul>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8&format=html">pppd(8)</a> - Es el d&aelig;mon ppp del núcleo del sistema.
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> - Es el d&aelig;mon ppp del modo usuario.
</ul>

<p>
Primero trataremos el d&aelig;mon del modo de usuario.
Para empezar necesitará algo de información sobre su isp.
He aquí una lista de la información que necesitará:
</p>

<ul>
   <li>El número de teléfono de conexión de su proveedor (ISP)
   <li>Su &quot;nameserver&quot; (nombre del servidor) 
   <li>Su nombre de usuario y contraseña
   <li>Su pasarela
</ul>

<p>
Parte de esta información no es estrictamente necesaria, pero será de gran
ayuda para configurar ppp.
El d&aelig;mon PPP de modo usuario utiliza el fichero
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
como fichero de configuración.
Existen muchos ficheros en <b>/etc/ppp</b> de gran utilidad, que pueden
contener diferentes ejemplos de configuración para situaciones distintas.
Le aconsejamos que mire en ese directorio.
</p>

<p>
En caso de no estar usando un núcleo GENERIC, asegúrese de que tiene la
siguiente línea en su fichero de configuración:
</p>

<ul><pre><strong>
pseudo-device   tun             2
</pre></ul></strong>


<h3>Configuración Inicial para PPP(8)</h3>

<p>
La configuración inicial del d&aelig;mon PPP de modo usuario consiste en
editar su fichero <b>/etc/ppp/ppp.conf</b>.
Este fichero no existe y debe ser creado, pero puede tomar el fichero
<b>/etc/ppp/ppp.conf.sample</b>, editarlo, y crear su propio fichero
<b>ppp.conf</b> a partir de ahí.
Aquí empezaré con la más simple, y probablemente más utilizada,
configuración.
A continuación puede ver un pequeño fichero <b>ppp.conf</b> que llevará a
cabo la conexión con su ISP y usará sus rutas predefinidas y su
&quot;nameserver&quot;.
Para este fichero, toda la información que necesitará será el número de
teléfono de su ISP, su nombre de usuario, y su contraseña.
</p>

<ul>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</ul>

<p>
<b>AVISO</b> - En OpenBSD 2.6, el sistema salió con un fichero
<i>/etc/ppp/ppp.conf.example</i> que contenía una configuración errónea para
el dispositivo.
El dispositivo era <i>"set device /dev/cuaa0"</i> cuando en realidad debía
ser <i>/dev/cua00</i>, que corresponde al dispositivo para el puerto de
comunicaciones 1 (COM1).
Su dispositivo podría no estar en COM1, aún así este esquema era erróneo.
</p>

<p>
La sección en la opción <b>default:</b> será ejecutada cada vez.
En ella se configura toda la información crítica.
Con &quot;set log&quot; se configuran los niveles de ingreso.
Esto se puede cambiar;  para más información sobre cómo configurar los
niveles de ingreso lea la página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a>.
El dispositivo se configura con &quot;set device&quot;.
Éste es el dispositivo en el que se encuentra el modem.
En este ejemplo el modem está en el puerto de comunicaciones 2 (COM2),
mientras que el puerto de comunicaciones 1 correspondería a /dev/cua00.
Con &quot;set speed&quot; se configura la velocidad de la conexión por
llamada, y con &quot;set dial&quot; se configura los parámetros de la
llamada.
Con esto se puede cambiar el tiempo muerto, etc...
Es conveniente dejar esta línea más o menos como está.
</p>

<p>
A continuación puede pasar a configurar la información específica para su
ISP.
Para ello debe añadir otra opción en la sección <b>default:</b>.
Puede dar cualquier nombre a esta etiqueta, pero lo más fácil es darle el
nombre de su ISP.
En el ejemplo usaremos <b>myisp:</b> para la opción que hará referencia a
nuestro ISP.
He aquí una configuración simple que incorpora todo lo necesario para
conectar:
<p>

<ul>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</ul>

<p>
Aquí hemos configurado información esencial para un ISP específico.
La primera opción, &quot;set phone&quot;, es para configurar el número de 
teléfono para la conexión de su ISP.
La opción &quot;set login&quot; es para configurar sus opciones de ingreso.
En el ejemplo hemos puesto un tiempo muerto de espera de 5, lo que significa
que terminará nuestro intento de ingreso después de 5 segundos su no hay
transportador.
De lo contrario esperará hasta recibir un &quot;login&quot; para enviar su
nombre de usuario y contraseña.
En el ejemplo, tanto el nombre de usuario como la contraseña son
&quot;ppp&quot;.
Estos valores hay que substituirlos por otros reales.
La opción &quot;set timeout&quot; es para configurar el tiempo de espera para
todo el proceso de ingreso.
La opción &quot;set ifaddr&quot; es algo complicada.
He aquí una explicación más extensa sobre ella:
</p>

<ul><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></ul>

<p>
Hemos configurado la línea anterior con el formato 
&quot;<b>set ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask
[triggeradr]]]]</b>&quot;.
De este modo el primer IP que se especifique es el que querremos como nuestro
IP.
Sin tiene una dirección IP estática, escríbala aquí.
En el ejemplo hemos usado /0, que indica que no es necesario que concuerde
ningún bit de esta dirección ip, y que se puede substituir todo.
El segundo IP que se especifique es el que esperamos como el IP de nuestro
ISP.
Si lo sabe lo puede especificar aquí, pero en la línea no sabemos cuál se
asignará, así que dejaremos que nos lo digan.
Esto es muy útil al negociar con algunas implementaciones PPP que no asignan
un número IP a menos que su conexión les requiera ``0.0.0.0''.
</p>

<p>
La siguiente opción &quot;add default HISADDR&quot; es para configurar la
ruta predefinida a su IP.
Si su IP cambiara, la ruta se actualizaría de forma automática.
Con &quot;enable dns&quot; indicamos a nuestro ISP que autentifique nuestras
direcciones &quot;nameservers&quot;.
No haga esto si está usando una DNS local, ya que ppp circunvalará su uso
introduciendo algunas líneas en /etc/resolv.conf.
</p>

<h3>Cómo Usar PPP(8)</h3>

<p>
Ahora que ya tenemos el fichero <b>ppp.conf</b> configurado, podemos intentar
una conexión con nuestro ISP.
A continuación se darán algunos detalles sobre argumentos de uso común con
ppp.
</p>

<ul>
   <li><b>ppp -auto myisp</b> - Inicia ppp, configura sus interfaces, le
       conecta con su isp, y a continuación pasa a un plano de fondo.
   <li><b>ppp -ddial myisp</b> - Parecido a -auto, pero si su conexión
       cayera volvería a conectar.
</ul>

<p>
Si usa <b>/usr/sbin/ppp</b> sin pasarle ninguna opción, le pasará al modo
interactivo, desde donde podrá interaccionar directamente con el modem.
De este modo puede depurar problemas en su fichero <b>ppp.conf</b>.
</p>

<h3>Acciones extras con ppp(8)</h3>

<p>
Si necesitara ejecutar órdenes al tiempo que conecta o desconecta, puede
hacerlo creando dos ficheros extras.
<b>/etc/ppp/ppp.linkup</b> y <b>/etc/ppp/ppp.linkdown</b>.
Puede ver ejemplos de configuración para estos ficheros en:
</p>

<ul>
   <li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
   <li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Puede encontrar más información en
<a href="http://www.freebsd.org/handbook/userppp.html">http://www.freebsd.org/handbook/userppp.html</a> o en
<a href="http://www.freebsd.org/es/faq/userppp.html">http://www.freebsd.org/es/faq/userppp.html</a>.
</p>

<p>
<a name="6.6"></a>
<h2>6.6 - Afinar Parámetros de Red</h2>

<h3>6.6.1 - ¿Cómo puedo forzar al núcleo del sistema para obtener un mayor
número de reintentos y tiempos de espera mayores en las sesiones TCP?</h3>

Para problemas de conexión o enrutamiento puede usar lo siguiente.
Tenga en cuenta que para que sea más efectivo, ambos lados de la conexión
deben usar valores similares.

<p>
Para forzarlo use <tt>sysctl</tt> e incremente los valores de:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

Si usa sysctl -a podrá ver los valores actuales de estos y muchos otros
parámetros.
Para cambiar cualquiera de ellos, use <tt>sysctl -w</tt>, como por ejemplo en
<tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.

<h3>6.6.2 - ¿Cómo puedo activar emisiones dirigidas?</h3>

Por regla general no es aconsejable hacer esto, ya que si su sistema OpenBSD
es un enrutador, permite que puedan enviar tráfico a la dirección o 
direcciones de emisión de sus redes.

<p>
En algunos casos, como en redes cerradas, puede tener cierta utilidad, en
particular cuando esté usando implementaciones antiguas del protocolo
NetBIOS.
Se puede activar con <tt>sysctl -w net.inet.ip.directed-broadcast=1</tt>.
Para saber porqué se encuentra desactivado por definición, infórmese sobre
<a href="http://www.netscan.org">ataques &quot;smurf&quot;</a>.

<h3>6.6.3 - No quiero que el núcleo haga asignaciones dinámicas de ciertos
puertos</h3>

También existe un sysctl para esto.
De la página de manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:

<pre>
Añada la lista de puertos TCP que no deberían ser asignados dinámicamente por
el núcleo.  Esto se puede usar para evitar que algunos daemons se apropien de
un puerto específico que sea necesario para el funcionamiento de otro
programa.  La lista de elementos puede ir separada por comas y/o espacios en
blanco.

   sysctl -w net.inet.tcp.baddynamic=749,750,751,760,761,871

También se pueden añadir o eliminar puertos de la lista actual.

   sysctl -w net.inet.tcp.baddynamic=+748
   sysctl -w net.inet.tcp.baddynamic=-871
</pre>

<a name="6.7"></a>
<h2>6.7 - Uso simple de NFS</h2>

<p>
El &laquo;Sistema de Archivos de Red&raquo; (NFS, &quot;Network File
System&quot;) se usa para compartir un sistema de archivos en una red.
Algunas páginas de manual que debería leer antes de que intente configurar un
servidor de NFS son:

<p>

<ul>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8&format=html">nfsd(8)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8&format=html">mountd(8)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>
</ul>

<p>
En esta sección se detallarán los pasos para una configuración simple de NFS.
El ejemplo ofrece detalles sobre un servidor en una LAN, con clientes que
tengan acceso NFS en la LAN.
En esta sección no se tratará sobre la seguridad de NFS.
Asumiremos que Vd. ya ha configurado su paquete de filtrado, u otra protección
de cortafuegos, para prevenir el acceso desde el exterior.
Si su configuración permite el acceso desde el exterior a su servidor de NFS,
y si tiene algún tipo de datos confidenciales o importantes, le recomendamos
encarecidamente que haga uso de <a href="../faq13.html">IPSec</a>.
De otro modo existe la posibilidad de que extraños puedan ver su tráfico NFS.
También sería posible que alguien pretendiera estar en la dirección IP que
tenga autorizada la entrada en su servidor NFS.
Existen varios tipos de ataques efectivos en este aspecto.
Cuando IPSec está correctamente configurado, protege contra todos estos tipos
de ataques.

<p>
Otra nota importante sobre seguridad.
No se limite a añadir un sistema de archivos a /etc/exports sin algún tipo de
lista de húespedes autorizados.
Sin una lista de huéspedes que puedan montar un directorio particular,
cualquiera que pueda llegar a su huésped podrá montar sus directorios de NFS
en <i>exports</i>.
</p>

<p>
La configuración consiste en un servidor con el ip <b>10.0.0.1</b>, que
servirá NFS sólo a clientes dentro de esa red.
El primer paso para configurar NFS es configurar su fichero 
<i>/etc/exports</i>.
Este fichero se compone de una lista con los sistemas de archivo que quiera
que se encuentren accesibles por medio de NFS, y define quién puede acceder a
cada uno de ellos.
Existen muchas opciones que puede usar en su fichero <i>/etc/exports</i>, y
es conveniente leer la página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>.
En este ejemplo empezaremos con un fichero <i>/etc/exports</i> como el
siguiente:
</p>

<ul><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></ul>

<p>
Esto quiere decir que el sistema de archivo local <b>/work</b> estará
disponible por medio de NFS.
<b>-alldirs</b> indica que los clientes podrán montar en cualquier parte del
punto de montaje <b>/work</b>.
<b>-ro</b> indica que sólo se permitirá montarlo en modo de sólo lectura.
Los dos últimos argumentos indican que sólo los clientes dentro de la red
10.0.0.0 que usen una máscara de red 255.255.255.0, estarán autorizados a
montar este sistema de archivo.
Esto es importante en algunos servidores accesibles desde diferentes redes.
</p>

<p>
Una vez que su fichero <i>/etc/exports</i> haya sido configurado, puede
seguir adelante y configurar su servidor NFS.
Primero debería asegurarse de que las opciones NFSSERVER y NFSCLIENT se
encuentren en la configuración del núcleo de su sistema (el núcleo GENERIC
incluye estas opciones).
A continuación debe configurar <strong>nfs_server=YES</strong> en el fichero
<i>/etc/rc.conf</i>.
De este modo, cuando reinicie el sistema, se activarán nfsd(8) y mountd(8).
Ahora ya puede continuar e iniciar los d&aelig;mons Vd. mismo.
Estos d&aelig;mons deben ser iniciados por root, y debe asegurarse de que
portmap(8) se encuentre funcionando en su sistema.
El ejemplo que sigue sobre cómo iniciar nfsd(8) sirve tanto para TCP como
para UDP usando 4 d&aelig;mons.
Para gestionar el máximo número de requerimientos de clientes concurrentes
a los que quiera dar servicio, debe activar un número apropiado de
d&aelig;mons del servidor NFS.

<p>

<ul>
<pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre>
</ul>

<p>
No sólo debe iniciar el servidor nfsd(8), sino que también necesita iniciar
mountd(8).
Éste es el d&aelig;mon que da servicio a los requerimientos para montar en
NFS.
Para iniciar mountd(8) escriba:
<p>

<ul>
<pre>
# <strong>/sbin/mountd</strong>
</pre>
</ul>

<p>
Si hace algún cambio al fichero /etc/exports mientras NFS esté funcionando,
tendrá que avisar a mountd sobre el cambio pasándole una señal
&quot;HUP&quot;:

<ul>
<pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre>
</ul>

<p>

<h3>Comprobación de estadísticas en NFS</h3>

<p>
Puede llevar a cabo comprobaciones para asegurarse de que estos d&aelig;mons
estén funcionando y registrados con RPC.
Para ello use rcpinfo(8).

<p>

<ul>
<pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre>
</ul>

<p>
Durante su uso normal, existen unas pocas utilidades más que le permitirán
ver lo que está ocurriendo con NFS.
Una de ellas es
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8&format=html">showmount(8)</a>,
que le permite ver qué se encuentra montado y quién lo está montando.
También está nfsstat(8), que muestra una información de las estadísticas
mucho más amplia.
Para usar showmount(8) escriba <b>/usr/bin/showmount -a host</b>.
Por ejemplo:

<p>

<ul>
<pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre>
</ul>

<h3>Cómo montar sistemas de archivo NFS</h3>

<p>
Los sistemas de archivo NFS se deben montar mediante mount(8), o más
exactamente mediante
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8&format=html">mount_nfs(8)</a>.
Para montar un sistema de archivo /work del huésped 10.0.0.1 en un sistema de
archivo local /mnt, haga lo siguiente (no necesita usar una dirección IP,
mount se encargará de la resolución de nombres):
<p>

<ul>
<pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre>
</ul>

<P>
Para que el sistema se monte al iniciar, añada una algo como lo que ve a
continuación en su fichero <i>/etc/fstab</i>:

<p>

<ul><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></ul>

<p>
¡¡Es importante que use <tt>0 0</tt> al final de esta línea para que su 
máquina no intente ejecutar fsck sobre el sistema de archivo NFS durante el
inicio del sistema!!
El resto de opciones de seguridad típicas como noexec, nodev, y nosuid,
también deberían usarse donde sean posibles, como en:

<p>

<ul><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></ul>

<p>
De este modo ningún dispositivo o programa setuid en el servidor NFS podrá
traspasar las medidas de seguridad en el cliente NFS.
Si no está montando programas para ejecutarlos en el cliente NFS, añada
noexec a esta lista.


<p>
<p>
<font color="#0000e0">
<a href="index.html">[Volver al Índice Principal]</a>
<a href="faq5.html">[Sección 5.0 - Configuración del Núcleo y del Disco]</a>
<a href="faq7.html">[To Section 7.0 - Controles del Teclado]</a>
</font>
</p>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../back.gif" border="0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq6.html,v 1.59 2000/04/05 21:49:26 ericj Exp ]<br>
$Translation: faq6.html,v 1.7 2000/04/08 10:45:57 horacio Exp $<br>
$OpenBSD: faq6.html,v 1.2 2000/04/09 12:06:13 wvdputte Exp $
</small>
</p>
</body>
</html>


