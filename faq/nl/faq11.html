<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>11 - Prestatie Tuning</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../nl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq10.html">[Naar Sectie 10 - Systeembeheer]</a>
<a href= "faq12.html">[Naar Sectie 12 - Platform-Specifieke Vragen]</a>
</font>

<h1><font color="#e00000">11 - Prestatie Tuning</font></h1>
<hr>

<p>
<h3>Inhoudstafel</h3>
<ul>
<li><a href="#Disk"   >11.1 - Schijf I/O</a>
<li><a href="#HW"     >11.2 - Hardware Keuzes</a>
<li><a href="#Async"  >11.3 - Waarom gebruiken we geen async mounts?</a>
<li><a href="#XF86"   >11.4 - Uw monitorresolutie tunen onder XFree86</a>
</ul>

<hr>


<p>
<a name= "Disk"></a>
<h2>11.1 - Schijf I/O</h2>

<p>
Schijf I/O snelheid is een veelbetekenende factor in de globale snelheid van
uw computer. Het wordt nog belangrijker wanneer u computer een multi-user
(gebruikers van alle soorten, van zij die interactief inloggen tot zij die
u zien als file-server of web-server) omgeving host.
Gegevensopslag heeft voortdurend aandacht nodig, vooral wanneer uw
partities ruimte tekort komen of als uw schijven het laten afweten.
OpenBSD heeft verscheidene mogelijkheden om de snelheid van uw
schijfoperaties te vergroten en om fouttolerantie te bieden.

<p>
Inhoudstafel
<ul>
<li><a href="#ccd">CCD</a> - Concatenated Disk Driver.
<li><a href="#raid">RAID</a>
<li><a href="#softu">Soft Updates</a>
<li><a href="#maxvnodes">Grootte van de namei() cache</a>
</ul>

<p>
<a name="ccd"></a>
<h3>11.1.1 - CCD</h3>

<blockquote>
De eerste mogelijkheid is het gebruik van <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>, de Concatenated Disk Driver.
Dit laat u toe om verscheidene partities samen te voegen tot één
virtuele schijf (en dus kan u verscheidene schijven er laten uitzien als
één schijf). Dit concept is gelijkaardig aan dat van LVM
(logical volume management), dat men in veel commerciële Unix varianten
vindt.

<p>
Als u GENERIC draait, is ccd reeds ingeschakeld (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  Als u uw kernel hebt aangepast, moet
u het mogelijk opnieuw in uw kernelconfiguratie zetten.
Hoe dan ook, een lijn als deze moet in uw configuratiebestand staan:

<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
Het bovenstaande voorbeeld geeft u tot 4 ccd devices (virtuele schijven).
Nu moet u uitzoeken welke partities op uw werkelijke schijven u aan ccd wil
besteden. Gebruik disklabel om deze partities als type 'ccd' aan te duiden.
Op sommige architecturen kan het zijn dat disklabel u niet toelaat om dit
te doen. Duid ze in dat geval aan als 'ffs'.

<p>
Als u ccd gebruikt om aan prestatie te winnen door striping, merk dan op dat u
geen optimale prestatie zal krijgen tenzij u hetzelfde model van schijven
gebruikt met dezelfde disklabel instellingen.

<p>
Bewerk /etc/ccd.conf zodat het er ongeveer zo uitziet:
(kijk voor meer informatie over het configureren van ccd, naar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
Om uw wijzigingen door te voeren, draait u

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Zolang /etc/ccd.conf bestaat, zal ccd zichzelf automatisch bij het opstarten
configureren.
Nu hebt u een nieuwe schijf, ccd0, een combinatie van /dev/sd2e en /dev/sd3e.
Gebruik hierop gewoon disklabel zoals u normaal zou doen om de partitie(s)
te maken die u wil gebruiken. Opnieuw, gebruik niet de 'c' partitie als
een eigenlijke partitie waarop u dingen wil zetten.
Zorg ervoor dat uw bruikbare partities ten minste één cilinder
van het begin van de schijf staan.
</blockquote>

<p>
<a name="raid"></a>
<h3>11.1.2 - RAID</h3>

<blockquote>
Een andere oplossing is <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
dat u <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
zal laten gebruiken om uw raid devices te controleren.  OpenBSD's RAID is
gebaseerd op
Greg Oster's <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD port</a>
van de CMU
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> software.
OpenBSD heeft ondersteuning voor RAID levels
0, 1, 4, en 5.
<p>
Voor raid moet, net zoals met ccd, ondersteuning in de KERNEL zitten.
In tegenstelling tot ccd, vindt u ondersteuning voor RAID niet in GENERIC,
dus het moet in uw kernel gecompileerd worden (RAID ondersteuning voegt
zo'n 500K toe aan de grootte van een i386 kernel).

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
Een RAID instellen is op sommige besturingssystemen op zijn zachtst gezegd
verwarrend en pijnlijk. Niet zo met RAIDframe.
Lees de <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a> en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
man pagina's om alle details te verkrijgen. Er zijn vele opties en
mogelijke configuraties beschikbaar, en een gedetailleerde uitleg valt
buiten het bestek van dit document.
</blockquote>

<p>
<a name="softu"></a>
<h3>11.1.3 - Soft updates</h3>

<blockquote>
Nog een tool die gebruikt kan worden om uw systeem te versnellen is
softupdates.  Een van de traagste operaties in het traditionele BSD
bestandssysteem is het updaten van metainfo (wat onder meer gebeurt wanneer
u bestanden en directories aanmaakt of verwijdert). Softupdates
probeert metainfo te updaten in RAM in plaats van elke metainfo update
naar de harde schijf te schrijven. Een ander effect hiervan is
dat de metainfo op de schijf altijd volledig zou moeten zijn, hoewel deze
niet altijd up-to-date is. Zodoende zou een systeemcrash geen volledige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
vereisen bij het opstarten, maar slechts een achtergrondversie van fsck die
wijzigingen aan de metainfo in RAM aanbrengt (&agrave; la softupdates).
Dit betekent dat een server rebooten veel sneller gaat, aangezien u niet
hoeft te wachten op fsck!
(OpenBSD heeft deze mogelijkheid nog niet.) U kan meer
lezen over softupdates in de <a href="faq14.html#SoftUpdates">Softupdates FAQ</a> entry.
</blockquote>

<p>
<a name="maxvnodes"></a>
<h3>11.1.4 - Grootte van de namei() cache</h3>

<dl>
<dd>
Opmerking: voorheen beval de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>
manual pagina aan om de <tt>NVNODE=integer</tt> kernel optie in te stellen.
Dit wordt niet langer aanbevolen; u gebruikt nu beter het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
commando in plaats daarvan. 
<p>
De naam-naar-inode vertaling (ook bekend als <!-- need to write the manual
page first... <a href="">namei(3)</a> --> namei()) cache controleert de
snelheid van padnaam naar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>
vertaling.
Een redelijke manier om een waarde voor de cache af te leiden, mocht een
groot aantal namei() "cache misses" opgemerkt worden met een tool zoals 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>,
is om de huidige door het systeem berekende waarden te onderzoeken met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>,
(dat deze parameter "<tt>kern.maxvnodes</tt>" noemt) en om deze waarde te
verhogen tot ofwel de namei() cache hit rate verbetert of het bepaald wordt dat
het systeem geen aanzienlijk voordeel uit een verhoging van de grootte van de
namei() cache. Nadat de waarde bepaald is, kan u ze bij de systeemstart
instellen met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>.
</dd>
</dl>


<p>
<a name= "HW"></a>
<h2>11.2 - Hardware keuzes</h2>
<!-- XXXchanges - check every OpenBSD release -->

<p>
<i>(Opmerking- deze sectie draait vooral om de i386, of PC, architectuur.
Dit om te zeggen... dat andere architecturen u helemaal niet zoveel keuzes
geven!)</i>

<p>
De prestatie van uw toepassingen hangt sterk af van uw besturingssysteem
en de faciliteiten die het biedt. Dit kan een deel van de reden zijn waarom
u OpenBSD gebruikt.
De prestatie van uw toepassingen hangt ook sterk af van uw hardware.
Voor veel mensen is de Prijs/Prestatie verhouding van een splinternieuwe PC
met een Intel Pentium IV of AMD Athlon processor veel beter dan de
Prijs/Prestatie verhouding van een Sun UltraSPARC 60!
Natuurlijk kan de prijs van OpenBSD niet verslagen worden.

<p>
Als u een nieuwe PC gaat kopen, of u hem nu stuk voor stuk of volledig
samengesteld koopt, wil u er eerst zeker van zijn dat u betrouwbare
onderdelen koopt. In de PC wereld is dit niet eenvoudig.
<b>Slechte of anders onbetrouwbare of niet-passende onderdelen kunnen
OpenBSD pover laten draaien en vaak laten crashen</b>. De beste raad die
we kunnen geven is om voorzichtig te zijn, en merken en onderdelen te kopen
die besproken werden door een autoriteit die u vertrouwt.
Soms boet u in aan kwaliteit als u beknibbelt op de prijs van een PC!

<p>
Er zijn bepaalde dingen die de maximale prestatie zullen helpen halen
uit uw hardware:

<ul>
<li><b>Gebruik meerdere schijven.</b>
Koop in plaats van één grote schijf, meerdere kleinere schijven.
Hoewel dit meer kan kosten, zal het verspreiden van de belasting over
meerdere spindels de hoeveelheid tijd verlagen, nodig voor toegang tot
gegevens op de schijf. En, met meer spindels, zal u meer betrouwbaarheid
en snellere gegevenstoegang verkrijgen met RAID.
<p>
<li><b>Gebruik SCSI als u heel hoge schijf I/O snelheden nodig hebt.</b>
IDE schijven draaien normaal met 5400 RPM tot 7200 RPM.  
Met high end IDE schijven kan het onredelijk zijn om meer dan 15 tot 20
megabytes per seconde aan doorvoer te verwachten van een enkele schijf.
Met high end SCSI schijven (duurdere 10k RPM tot 15k RPM schijven), kan u
betere prestaties dan dat bekomen. Als u daarentegen medium of low end
SCSI schijven gebruikt, is dit een verspilling van geld, en zal IDE u
net zo goed bedienen, zoniet beter.
<p>Als u een server bouwt, en u heeft meer dan één schijf nodig,
wil u misschien SCSI overwegen. IDE beperkt u tot twee schijven per
controller. Gelijktijdige toegang tot deze twee schijven kan een negatieve
invloed hebben op de I/O prestaties van deze schijven.
Wide SCSI beperkt u tot 15 per controller, en heeft betere ondersteuning voor
gelijktijdige toegang dan IDE. Hoewel SCSI meer kost, kunnen de flexibiliteit
en prestatie deze kosten in sommige omgevingen rechtvaardigen.
<p>
<li><b>Gebruik SDRAM in plaats van DRAM.</b>
Deze optie is vooral van toepassing op PC's. De meeste andere architecturen
geven u geen keuze voor het type van RAM dat u kan gebruiken. Verscheidene
PC's doen dit nog steeds.
U zal betere prestaties krijgen met SDRAM versus DRAM (SIMMs).
Als uw systeem RDRAM, DDR of nog een ander nieuw type van RAM ondersteunt,
bent u zelfs nog verder vooruit...
<p>
<li><b>Gebruik ECC of parity RAM.</b>
Parity voegt wat functionaliteit toe om te zien of de gegevens in RAM corrupt
geworden zijn. ECC breidt deze functionaliteit uit en probeert sommige
bitcorruptiefouten on the fly te corrigeren.
Deze optie is vooral van toepassing op PC's. De meeste andere architecturen
vereisen gewoonweg parity of ECC capabele RAM. Verscheiden niet-PC computers
willen zelfs niet booten met niet-parity RAM.
Als u geen ECC/parity RAM gebruikt, kan u gegevenscorruptie en andere
abnormaliteiten krijgen. Verscheidene fabrikanten van
"goedkope PC RAM" maken zelfs geen ECC variëteit!  Dit zal u helpen om
ze te vermijden! PC fabrikanten verkopen vaak verscheidene productlijnen,
ingedeeld rond "servers" en "workstations". De servers zullen ECC RAM in
hun architectuur opnemen. Unix workstation fabrikanten gebruiken reeds
verschillende jaren parity (en nu ECC) in al hun productlijnen.
<p>
<li><b>Vermijd ISA devices.</b>
Terwijl de meeste mensen ISA devices vermijden omdat ze in het algemeen
moeilijk te configureren en niet recent zijn, bestaan er nog steeds veel.
Als u de ISA bus voor uw schijf of netwerkcontrollers gebruikt, (of erger nog,
voor allebei) onthou dan dat de ISA bus zelf een prestatieknelpunt kan vormen.
Als u snelheid nodig hebt, kijk dan naar PCI. Natuurlijk zijn er nog steeds
verscheidene ISA bus kaarten die prima werken. Jammer genoeg zijn de meeste
hiervan geluidskaarten en seriële poort kaarten.
<p>
<li><b>Vermijd goedkope PCI netwerkadapters.</b>
OpenBSD ondersteunt een overvloed aan goedkope PCI netwerkadapters. Deze
adapters werken geweldig in thuissystemen, en ook in lage of gemiddelde
doorvoer zaken- en onderzoeksomgevingen. Maar, als u hoge doorvoer en lage
impact op uw server nodig hebt, bent u beter af met een kwaliteits-PCI
netwerkadapter te kopen. Jammer genoeg zijn sommige dure merk adapters
niet veel beter dan de goedkope adapters.
Gigabit adapters presteren vaak beter dan 10Mbps/100Mbps adapters, zelfs
indien ze gebruikt worden op lagesnelheidsnetwerken, dankzij de superieure
buffering.
</ul>


<p>
<a name= "Async"></a>
<h2>11.3 - Waarom gebruiken we geen async mounts?</h2>

<p>
Vraag: "Ik doe gewoon "mount -u -o async /" wat een pakket dat ik gebruik
(dat er op staat om van tijd tot tijd enkele honderden dingen aan te raken)
bruikbaar maakt.

Waarom staat men afkeurend tegenover async mounten en is het niet standaard
ingeschakeld (zoals het op enkele andere unixen wel is)?
Is het niet een veel eenvoudigere, en daarom, veiligere manier om de
prestatie in sommige toepassingen te verbeteren?"

<p>
Antwoord: "Async mounts zijn inderdaad sneller dan sync mounts, maar ze zijn
ook minder veilig. Wat gebeurt er in het geval van een stroompanne? Of een
hardware probleem? De zoektocht naar snelheid zou de betrouwbaarheid en de
stabiliteit van het systeem niet mogen opofferen. Bekijk de man pagina van
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>."

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
Aan de andere kant, wanneer u met tijdelijke gegevens te maken hebt die u
vanaf nul opnieuw kan maken na een crash, kan u snelheid winnen door een
afzonderelijke partitie te gebruiken voor alleen die gegevens en deze async
te mounten. Opnieuw, doe dit <i>alleen als</i> u het verlies van alle gegevens
in de partitie niet erg vindt als er iets verkeerd gaat. Om deze reden worden
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
partities asynchroon gemount, aangezien ze bij een herstart toch gewist en
opnieuw gemaakt worden.


<p>
<a name= "XF86"></a>
<h2>11.4 - Uw monitorresolutie tunen onder XFree86</h2>

<i>Opmerking: De meeste gebruikers hoeven zich GEEN zorgen te maken over het
manueel aanmaken van een ModeLine in moderne versies van X.
NOCHTANS, soms is het nodig voor ongebruikelijke situaties.</i>

<p>
Een X server werkende krijgen bij een aanvaardbare resolutie is met vele
multi-sync monitoren mogelijk.  Als iemand dit heeft proberen te doen met de
standaard xf86config of XF86Setup utilities, hebben ze waarschijnlijk niet
de best mogelijke resultaten verkregen. Een van de meer pijnlijke aspecten is
gewoon uw monitor te laten werken met de resolutie die uw voorkeur geniet, en
vervolgens de verticale scansnelheid ingesteld krijgen op ten minste 72-75 Hz,
een snelheid waarbij het schermgeflikker veel minder zichtbaar is voor mensen.
Daarentegen, wat als u de verticale scansnelheid op heel lage waarden probeert
in te stellen?
U kan ze op 50 Hz instellen zodat het op video kan vastgelegd worden zonder
geflikker, maar de methodes om dit te doen zijn niet vanzelfsprekend met de
standaard XFree86 tools en documentatie.

<p>
Tenslotte, bij de resoluties die veel mensen gewoonlijk gebruiken met
goedkope VGA monitoren (800x600, 1024x768, 1152x900, 1280x1024), is het
mogelijk (althans op nieuwere monitoren) om verticale scansnelheden van 85Hz en
hoger te gebruiken, om een extreem zuiver, aangenaam beeld te bekomen.
De XFree86 X server heeft een mechanisme dat u toelaat om in detail de video
modus die u wil gebruiken, dit is de ModeLine, te beschrijven. Een ModeLine
heeft vier secties, een enkel getal voor de pixelklok, vier getallen voor
horizontale timings, vier getallen voor verticale timings, en een optionele
sectie met een lijst vlaggen die andere eigenschappen van de modus
specificeren (zoals Interlace, DoubleScan, en meer... zie de XF86Config(5)
manual pagina voor meer ModeLine details).

<p>
Een ModeLine genereren is zwarte magie... Gelukkig zijn er verscheidene
scripts die dit voor u kunnen doen. Eén ervan is
<a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">
Colas XFree86 ModeLine Generator</a>.  Een ander is
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline Generator</a>
gehost op SourceForge, en er zijn er verscheidene andere beschikbaar op
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Alvorens u deze ModeLine generators kan gebruiken, moet u de verticale en
horizontale sync limieten voor uw monitor te weten komen. Dit wordt vaak
gedocumenteerd in de handleiding, of op de website van de fabrikant.
Als u geen van die kan vinden, zoek dan gewoon op het web naar het monitor
merk en model, verscheidene mensen zijn zo vriendelijk geweest om lijsten
samen te stellen met deze informatie.

<p>
Stel bijvoorbeeld dat u een Dell D1226H monitor hebt.  U zocht in kwelling
op de website van Dell om te vinden dat hij een 30-95 kHz horizontaal
scanbereik heeft, en een 50-160 Hz verticaal scanbereik.  Bezoek de
ModeLine generator pagina, en voer deze informatie in. Vervolgens moet u de
minimale verticale scan rate ingeven die u wenst. Gelijk welke rate op of
boven 72 Hz zou in het algemeen weinig zichtbaar geflikker moeten hebben.
Naarmate u hoger gaat, wordt het beeld op uw scherm helderder en scherper.

<p>
Met al deze stukjes informatie zal het script een ModeLine genereren voor
elke mogelijke 4x3 resolutie die uw monitor kan ondersteunen, boven de
minimale verticale scan rate die u ingeeft. Als iemand de Dell specs en een
75 Hz verticaal scan minimum ingeeft, geeft het script iets als het volgende:

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
Nu beweert deze monitor 1600x1200 @ 75 Hz te doen, maar het script zegt niet
dat dit binnen 75 Hz valt.  Dus, als u echt precies 1600x1200 wil, ga dan
een stapje naar beneden met uw minimale verticale rate... (Hier gaan we
naar beneden tot 70 Hz)

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
Hier zien we dat de monitor echt 1600x1200 @ 74 Hz doet wanneer de dotclock
(bandbreedte) beperkt is tot 200MHz. Stel de bandbreedte in overeenkomstig
de beperkingen gedefinieerd door de monitor.

<p>
Zodra u uw ModeLines hebt, zet ze dan in uw /etc/X11/XF86Config bestand.
Commentarieer de oude ModeLines, zodat u ze opnieuw kan gebruiken als de
nieuwe niet zouden werken.
Kies vervolgens welke resolutie u eigenlijk wil draaien. Zoek eerst uit of
X in geaccelereerde modus draait (wat het met de meeste videokaarten doet),
zodat u weet welke <tt>"Screen"</tt> sectie van de XF86Config u moet
wijzigen. Of wijzig gewoon al de Screen secties.

<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
De eerste resolutie die u ziet na het "Modes" sleutelwoord is de resolutie
waarmee X gaat starten. Door CTRL-ALT-KEYPAD MIN, of CTRL-ALT-KEYPAD PLUS
te drukken kan u omschakelen tussen de resoluties die u hier opgeeft.
Volgens de bovenstaande sectie zal X proberen te starten in 32-bit
kleurenmodus (via het DefaultColorDepth opdracht, zonder dit zal X starten
in 8-bit kleurenmodus.)
De eerste resolutie die het zal proberen gebruiken is 1280x1024 (het volgt de
volgorde van de Modes lijn.)  Merk op dat "1280x1024" gewoon een label is
voor de waarden in de ModeLine.

<p>
Merk op dat het ModeLine generatorscript opties heeft om de timings te
verzwakken voor oudere of kleinere monitoren, en ook de mogelijkheid heeft om
ModeLines voor specifieke resoluties aan te bieden. Afhankelijk van het type
hardware dat u hebt, kan het misschien niet zo gemakkelijk te gebruiken zijn
met de standaardopties. Als het beeld te groot, te breed, of te klein is, of
horizontaal of verticaal verschoven is, en de bediening van de monitor volstaat
niet om het beeld te corrigeren, kan men xvidtune(1) gebruiken om de ModeLine
aan te passen zodat ze beter past bij de timings van de monitor.

<p>
Op de meeste moderne monitoren staat er geen vaste limiet op de bandbreedte,
dus deze worden vaak niet meer vermeld in de specificaties. Wat er gebeurt is
dat hoe hoger u gaat in bandbreedte, hoe waziger het beeld wordt.
Dus u wil misschien de bandbreedte van uw kaart (ook "dotclock" genoemd)
ingeven om te testen (u kan de monitor op deze manier niet beschadigen) en
gestaag lager gaan in bandbreedte om een mooi scherp beeld te bekomen.

<p>
Als dit nodeloos complex lijkt, dan is dat omdat het zo is. XFree86 4.0
pakt dit aan, en maakt dit proces veel gemakkelijker omdat het verscheidene
ingebouwde modi heeft en mogelijkheden vanuit "plug en play" monitoren kan
inlezen door DDC en DDC2.

<p>
U kan het Colas XFree86 ModeLine Generator script downloaden op:
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>.
U moet de Klone interpreter nemen en hem compileren. Deze zit in de ports als
<tt>lang/klone</tt>.  De scripts staan onder de scripts directory in de Klone
distributie. (De port installeert ze naar /usr/local/lib/klone/scripts.)

<p>
Er zijn twee versies van het script inbegrepen, de eerste is een CGI versie
identiek aan de bovenstaande webpagina. De tweede is een niet-CGI versie die
uw volledig XF86Config bestand neemt, uw monitor specs decodeert die u hebt
ingegeven in xf86config/XF86Setup (Denk nu na, hebt u werkelijk de specs voor
uw monitor ingegeven of gewoon de algemene gekozen?),
en de bestaande ModeLines overeenkomstig opknapt.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq10.html">[Naar Sectie 10 - Systeembeheer]</a>
<a href= "faq12.html">[Naar Sectie 12 - Platform-Specifieke Vragen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[terug]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq11.html,v 1.55 ]<br>
$Translation: faq11.html,v 1.3 2005/02/13 00:34:44 smestdag Exp $<br>
$OpenBSD: faq11.html,v 1.3 2005/02/13 11:15:14 jufi Exp $
</small>
</body>
</html>
