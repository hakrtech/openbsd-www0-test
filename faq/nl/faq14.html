<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Inrichting van de Schijf</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../nl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq13.html">[Naar Sectie 13 - Multimedia]</a>
</font>

<h1><font color="#e00000">14 - Inrichting van de Schijf</font></h1><hr>

<h3>Inhoudsopgave</h3>
<ul>
<li><a href="#disklabel"  >14.1 - OpenBSD's disklabel(8) gebruiken</a>
<li><a href="#fdisk"      >14.2 - OpenBSD's fdisk(8) gebruiken</a>
<li><a href="#NewDisk"    >14.3 - Extra schijven toevoegen in OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - Hoe swappen naar een bestand</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Hoe boot OpenBSD/i386?</a>
<li><a href="#LargeDrive" >14.7 - Wat zijn de problemen met grote schijven
    in OpenBSD?</a>
<li><a href="#InstBoot"   >14.8 - Installeren van Bootblocks - i386
    specifiek</a>
<li><a href="#Backup"     >14.9 - Zich op het ergste voorbereiden: Backup en
    Restore vanaf tape.</a>
<li><a href="#MountImage" >14.10 - Schijfimages mounten in OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - Hulp! Ik krijg fouten met IDE DMA!</a>
<li><a href="#RAID"       >14.13 - RAID opties in OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Waarom vertelt <tt>df(1)</tt> me dat ik
    meer dan 100% van mijn schijf in gebruik heb?</a>
<li><a href="#OhBugger"   >14.15 - Partities herstellen na het verwijderen
    van het disklabel</a>
<li><a href="#foreignfs"  >14.16 - Kan ik gegevens benaderen op andere
    bestandssystemen dan FFS?</a>
<li><a href="#flashmem"   >14.17 - Kan ik een flash geheugentoestel gebruiken
    met OpenBSD?
</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - OpenBSD's disklabel(8) gebruiken</h2>
<h3>Inhoudsopgave</h3>

<ul>
<li><a href="#disklabel.1">Wat is disklabel(8)?</a>
<li><a href="#disklabel.2">disklabel(8) tijdens de OpenBSD installatie</a>
<li><a href="#disklabel.3">Veel voorkomende gebruiken van disklabel(8).</a>
</ul>

   
<a name="disklabel.1"></a>
<h3>Wat is disklabel(8)?</h3>
  
<p>
Lees zeker eerst de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man pagina.

<p>
Disklabels worden aangemaakt om een efficiënte interface toe te laten
tussen uw schijf en de schijfdrivers vervat in de kernel. Labels bevatten
bepaalde informatie over uw schijf, zoals uw schijfgeometrie en informatie
over uw bestandssystemen. Dit wordt dan gebruikt door het bootstrap-programma
om de schijf te laden en om te weten waar de bestandssystemen op de schijf
staan. Labels worden ook gebruikt in combinatie met de bestandssystemen om
een meer efficiënte omgeving te maken. U kan meer gedetailleerde
informatie over disklabel vinden door de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>
man pagina te lezen.

<p>
Als bijkomende winst, helpt het gebruik van disklabel architectuurbeperkingen
i.v.m. schijfpartitionering overkomen. Op i386 bijvoorbeeld, kan u slechts
4 primaire partities hebben. (Partities die andere besturingssystemen zoals
Windows NT of DOS kunnen zien.) Met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
gebruikt u één van deze 'primary' partities om *al* uw OpenBSD
partities (bv. 'swap', '/', '/usr' en '/var') in te bewaren.
En dan hebt u nog 3 partities over, beschikbaar voor andere besturingssystemen!

<a name="disklabel.2"></a>
<h3>disklabel(8) tijdens de OpenBSD installatie</h3>

<p>
Een van de grote onderdelen van de OpenBSD installatie is het initieel
aanmaken van labels. Dit komt (voor i386 gebruikers) direct na het gebruik van
<a href="#fdisk">fdisk(1)</a>.
Tijdens de installatie gebruikt u disklabel om uw afzonderlijke labels aan te
maken, die uw afzonderlijke mount points zullen bevatten. Tijdens de
installatie kan u uw mount points instellen vanuit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
maar dit is niet volstrekt noodzakelijk aangezien u later gevraagd zal worden
om uw keuzes te bevestigen. Maar het laat uw installatie net iets vlotter
verlopen.

<p>
Aangezien dit tijdens de installatie is, zal u geen bestaande labels hebben,
en zullen ze moeten aangemaakt worden. Het eerste label dat u zal aanmaken is
het label 'a'. Dit label MOET zijn waar / gemount zal worden. U kan aanbevolen
partities zien die best aangemaakt zouden worden door
<a href="faq4.html#SpaceNeeded">FAQ 4, Benodigde Ruimte</a> te lezen. Voor
servers wordt het aanbevolen dat u ten minste deze labels afzonderlijk
aanmaakt. Voor desktop gebruikers zal het waarschijnlijk volstaan om
één mount point op / aan te maken. Wanneer u initieel uw root
partitie ('a' label) aanmaakt, hou dan in het achterhoofd dat u NOG WAT
ruimte over moet hebben voor uw swap label. Nu de beginselen zijn uitgelegd,
volgt hier een voorbeeld van het gebruik van disklabel tijdens een installatie.
In dit eerste voorbeeld wordt aangenomen dat OpenBSD het enige
besturingssysteem op deze computer zal zijn, en dat een volledige installatie
gedaan zal worden.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
Op dit punt hebben we een 64M root partitie aangemaakt, gemount op /, en een
64M swap partitie. Bemerk dat de offset begint op sector 63. Dit is wat u
wil. Wat de grootte betreft, zal disklabel uw grootte in sectoren weergeven,
u hoeft groottes echter niet in hetzelfde formaat in te geven.
Zoals in het bovenstaande voorbeeld kan u groottes ingeven op de volgende
manier: <i>64 Megabytes = 64M</i> en <i>2 Gigabytes = 2G</i>. Disklabel zal
dan afronden naar de meest nabije cilinder. In het voorbeeld hierboven zal u
ook opmerken dat disklabel veronderstelt dat label 'b' een swap zal zijn.
Dit is een juiste veronderstelling aangezien de GENERIC kernel ingesteld is
om naar swap te zoeken op label 'b', en u volgt best deze richtlijn door 'b'
als uw swapruimte te gebruiken.

<p>
Het volgende voorbeeld zal u meenemen doorheen het aanmaken van twee of meer
labels. Dit betekent dat het geen volledige installatie is, aangezien de
grootte van deze labels niet genoeg zal zijn om OpenBSD op zijn volledigst te
installeren. Door het aanmaken van al de partities nog eens te tonen, zouden
we in herhaling vallen.

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
In het bovenstaande voorbeeld zijn er twee dingen die u zou kunnen opmerken.
Eén ervan is dat de offset automatisch voor u berkend wordt zodat het
de volgende in volgorde is. Wanneer u deze soort van installatie doet, zal
u helemaal niet hoeven te knoeien met het veranderen van de offsets.
Een ander verschil dat u zou kunnen opmerken, zal zijn dat label 'c'
overgeslagen werd. Dit wordt gedaan om een reden, label 'c' is namelijk een
label dat de hele schijf voorstelt. Om deze reden gaat u beter op geen enkele
manier om met label 'c'.

<p>
Zodra al uw labels aangemaakt zijn, is al wat er nog te doen staat de
labels naar de schijf schrijven, en verder gaan met het installatieproces.
Om alles weg te schrijven en disklabel te verlaten (en verder te gaan met
de installatie), doet u:


<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>

<a name="disklabel.3"></a>
<h3>Veel voorkomende gebruiken van disklabel(8)</h3>

<p>
Zodra uw systeem geïnstalleerd is, zal u disklabel normaal niet zo vaak
nodig hebben. Maar soms zal u disklabel moeten gebruiken voor het toevoegen,
verwijderen of herstructureren van uw schijven. Eén van de eerste
dingen die u zal moeten doen is uw huidig disklabel bekijken. Om dit te doen
typt u gewoon:

<pre>
# <b>disklabel wd0</b> &lt;----- Of welk schijf device u ook graag zou bekijken

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
Het bovenstaande commando laat u eenvoudigweg toe om het bestaande disklabel
te bekijken, en het garandeert daarbij dat u niets om zeep helpt. (Wat we soms
allemaal nodig hebben.) Maar om veranderingen te kunnen maken moet u de -E
optie gebruiken bij disklabel, als volgt:

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
Dit zal u naar een prompt brengen, dezelfde als degene die u gebruikte tijdens
de OpenBSD installatie. Waarschijnlijk is het belangrijkste commando op
deze prompt '?'. Dit zal u een lijst van mogelijke opties geven die te maken
hebben met disklabel. U kan zelfs de volledige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man pagina bekijken met het 'M' commando. Vanaf deze prompt zal u al het
toevoegen, verwijderen en veranderen van partities uitvoeren. Lees voor
bijkomende informatie de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man pagina.

<a name="fdisk"></a>
<h2>14.2 - fdisk(8) gebruiken</h2>

Bekijk zeker eerst de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
man pagina.

<p>
Fdisk is een programma om te helpen bij het onderhoud van uw partities. Dit
programma wordt bij de installatie gebruikt om uw OpenBSD partitie (deze
partitie kan <u>verscheidene</u> labels bevatten, elk met
filesystems/swap/etc.) in te stellen. Het kan ruimte op uw schijven indelen en
er één partitie actief maken. Dit programma zal gewoonlijk
gebruikt worden in Single User Modus (boot -s). Fdisk stelt ook de MBR op
uw verschillende harde schijven in.

<p>
Voor installatiedoeleinden hebt u meestal slechts <b>EEN</b> OpenBSD
partitie nodig, en vervolgens gebruikt u disklabel om er een swap en een
bestandssysteem op te zetten.

<p>
Om gewoon uw partitietabel te bekijken met fdisk, gebruikt u:

<pre># <b>fdisk sd0</b><br>
</pre>

<p>
Dat zal een uitvoer gelijkaardig aan deze geven:

<pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD     
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
</pre>

<p>
In dit voorbeeld bekijken we de fdisk uitvoer van de eerste SCSI schijf.
We kunnen de OpenBSD partitie (A6) en haar grootte zien. De * vertelt ons
dat de OpenBSD partitie een bootable partitie is.

<p>
In het voorgaande voorbeeld bekeken we alleen onze informatie. Wat als we
onze partietabel willen bewerken? Wel, om dat te doen moeten we de <b>-e</b>
vlag gebruiken. Dit zal een commandoregel prompt tevoorschijn brengen om met
fdisk te interageren.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p>
Het is volkomen veilig om in fdisk te gaan en te verkennen, zorg er alleen
voor dat u <b>N</b> antwoordt op de vraag om de wijzigingen te bewaren en
gebruik *NIET* het <b>write</b> commando.

<p>Hier is een overzicht van de commando's die u kan gebruiken wanneer u de
<b>-e</b> vlag kiest.

<ul>
<li><b>help</b>  Toon een lijst van commando's die fdisk gebruikt in de
interactieve edit modus.
<li><b>reinit</b>  Initialiseer de momenteel geselecteerde, in-het-geheugen
kopie van de boot block.
<li><b>disk</b>  Toon de huidige schijfgeometrie die fdisk onderzocht heeft.
U krijgt de gelegenheid om deze te bewerken indien u dat wenst.
<li><b>setpid</b>  Verander de partitie identifier van de gegeven partitietabel
entry. Dit commando is bepaald handig om een bestaande partitie opnieuw toe
te kennen aan OpenBSD.
<li><b>edit</b>  Bewerk een gegeven tabel entry in de geheugenkopie van de
huidige boot block. U kan bewerken ofwel in BIOS geometrie modus, of in
sector offsets en groottes.
<li><b>flag</b>  Maak de gegeven partitietabel entry bootable. Slechts
één entry kan bootable gemarkeerd worden. Als u van een
"extended" partitie wenst te booten, zal u de partitietabel entry voor de
extended partitie bootable moeten markeren.
<li><b>update</b>  Update de machinecode in de geheugenkopie van de
momenteel geselecteerde boot block.
<li><b>select</b>  Selecteer en laad in het geheugen de boot block waarnaar
verwezen wordt door de extended partitie tabel entry in de huidige boot block.
<li><b>print</b>   Vertoon de momenteel geselecteerde in-het-geheugen kopie
van de boot block en zijn MBR tabel op het scherm.
<li><b>write</b>   Schrijf de in-het-geheugen kopie van de boot block naar
de schijf. U zal gevraagd worden om deze handeling te bevestigen.
<li><b>exit</b>  Verlaat het huidige niveau van fdisk, ofwel door terug te keren
naar de voorheen geselecteerde in-het-geheugen kopie van een boot block, ofwel
door het programma te verlaten indien er geen is.
<li><b>quit</b>  Verlaat het huidige niveau van fdisk, ofwel door terug te keren
naar de voorheen geselecteerde in-het-geheugen kopie van een boot block, ofwel
door het programma te verlaten indien er geen is. In tegenstelling tot exit
schrijft dit de gewijzigde block weg.
<li><b>abort</b>   Verlaat het programma zonder de huidige wijzigingen te
bewaren.
</ul>

<a name="NewDisk"></a>
<h2>14.3 - Extra schijven toevoegen in OpenBSD</h2>

<p>
Zodra u uw schijf <b>JUIST</b> geïnstalleerd krijgt, moet u
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>alleen i386</i>) en
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
gebruiken om uw schijf in te stellen in OpenBSD.

<p>
Voor i386 mensen, begin met fdisk. Andere architecturen kunnen dit negeren.
In het onderstaande voorbeeld voegen we een derde SCSI schijf toe aan het
systeem.
<pre>
# <b>fdisk -i sd2</b>
</pre>
Dit zal de "echte" partitietabel van de schijf initialiseren voor exclusief
gebruik door OpenBSD.
Vervolgens moet u er een disklabel voor aanmaken. Dit zal verwarrend lijken.
<pre>
# <b>disklabel -e sd2</b>

<i>(scherm wordt leeg, uw $EDITOR verschijnt)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

Ten eerste, negeer de 'c' partitie, die is er altijd en dient om programma's
als disklabel te laten functioneren!
Fstype voor OpenBSD is 4.2BSD.
Total sectors is de totale grootte van de schijf.  Stel dat dit
een 3 gigabyte schijf is.  Drie gigabytes betekent in schijffabrikant-termen
3000 megabytes.  Deel dus 6185088/3000 (gebruik
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1))</a>.
U bekomt 2061. Om dus partitiegroottes te verzinnen voor a, d, e, f, g, ...
vermenigvuldigt u gewoon X*2061 om X megabytes ruimte te krijgen op die
partitie.
De offset voor uw eerste nieuwe partitie moet hetzelfde zijn als de
"sectors/track" eerder vermeld in de uitvoer van disklabel. Voor ons is dit
63.  De offset voor elke volgende partitie moet een combinatie zijn van de
grootte van elke partiite en de offset van elke partitie (Behalve de 'c'
partitie, aangezien die geen rol speelt in deze vergelijking.)

<p>
Of, als u gewoon één partitie op de schijf wil, stel dat u
het hele ding voor webruimte of een home directory of zoiets wil gebruiken,
neem dan gewoon de totale grootte van de schijf en trek het aantal sectoren
per track ervan af.
6185088-63 = 6185025.  Uw partitie is

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>Als dit allemaal nodeloos complex lijkt, kan u gewoon disklabel -E gebruiken
om dezelfde paritioneringsmodus te krijgen die u op uw installatieschijf heeft
verkregen!</b>
Daar kan u gewoon "96M" gebruiken om "96 megabytes" te specificeren. (Of, als
u een voldoende grote schijf hebt, 96G voor 96 gigs!) Jammer genoeg gebruikt
de -E modus de BIOS schijfgeometrie, niet de werkelijke schijfgeometrie, en vaak
zijn die twee niet hetzelfde. Om over deze beperking heen te geraken, typt u
'g d' voor 'geometry disk'. (Andere opties zijn 'g b' voor 'geometry bios'
en 'g u' voor 'geometry user', of gewoon wat het label zei voordat disklabel
veranderingen aanbracht.)

<p>
Dat was veel. Maar u bent nog niet klaar. Tenslotte moet u een bestandssysteem
aanmaken op die schijf met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
Of hoe uw schijf ook werd genoemd door OpenBSD's schijfnummeringsschema.
(Kijk naar de uitvoer van
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
om te zien hoe uw schijf genoemd werd door OpenBSD.)

<p>
Zoek nu uit waar u deze nieuwe partitie die u net gemaakt hebt, gaat mounten.
Stel dat u ze op /u wil plaatsen. Maak eerst de directory /u. Mount ze
vervolgens.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Voeg dit tenslotte toe aan
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>.

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
Wat als u een bestaande directory zoals /usr/local moet migreren? U kan
best de nieuwe schijf in /mnt mounten en <tt>cpio -pdum</tt> gebruiken om de
/usr/local naar de /mnt directory te kopiëren. Bewerk het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
bestand om aan te geven dat de /usr/local partitie nu /dev/sd2a is (uw
vers geformatteerde partitie.) Voorbeeld:

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Herstart in single user modus met <b>boot -s</b>, verplaats de bestaande
/usr/local naar /usr/local-backup (of verwijder het als het vandaag uw
geluksdag is)
en maak een lege directory /usr/local aan. Herstart vervolgens het systeem,
en voila, de bestanden zijn er!


<a name="SwapFile"></a>
<h2>14.4 - Hoe swappen naar een bestand</h2>

<p>
(Opmerking: als u naar een bestand wil swappen omdat u
&quot;virtual memory exhausted&quot; fouten krijgt, kan u best eerst de
per-proces limieten proberen te verhogen met
csh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>,
of
sh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>.)

<p>
Swappen naar een bestand vereist geen aangepaste kernel, hoewel dat nog
steeds gedaan kan worden, zal deze faq u tonen hoe u swapruimte toevoegt
op beide manieren.

<h3>Swappen naar een bestand.</h3>

<p>
Swappen naar een bestand is de gemakkelijkste en snelste manier om extra
swapruimte in te stellen. Het bestand mag niet op een bestandssysteem staan
dat SoftUpdates ingeschakeld heeft (dit is standaard uitgeschakeld). Om te
beginnen kan u zien hoeveel swap u momenteel hebt en hoeveel u gebruikt met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
utility. U kan dit doen met het commando:

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
Dit toont de devices die momenteel gebruikt worden om te swappen en hun
huidige statistieken. In het bovenstaande voorbeeld is er slechts
één device, met name &quot;swap_device&quot;.
Dit is het voorgedefinieerde gebied op de schijf dat gebruikt wordt om te
swappen. (Verschijnt als partitie b bij het bekijken van disklabels.) Zoals
u ook kan zien in het bovenstaande voorbeeld, wordt dat device momenteel
niet veel gebruikt. Maar voor de bedoeling van dit document, zullen we doen
alsof er 32M extra benodigd is.

<p>
De eerste stap om een bestand als een swap device in te stellen, is om een
bestand aan te maken. Het beste is om dit te doen met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
utility. Hier is een voorbeeld van het aanmaken van het bestand
<i>/var/swap</i> dat 32M groot is.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Zodra dit gebeurd is, kunnen we swappen naar dat device aanzetten. Gebruik
het volgende commando om het swappen naar dit device aan te zetten

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
Nu moeten we controleren om te zien of het juist werd toegevoegd aan de lijst
van onze swap devices.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Nu het bestand is ingesteld en het swappen gebeurt, moet u een lijn toevoegen
aan uw <i>/etc/fstab</i> bestand zodat dit bestand geconfigureerd wordt ook
de volgende keer als u start. Als deze lijn niet toegevoegd wordt, zal dit
swap device niet geconfigureerd worden.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>Swappen via een vnode device</h3>

<p>
Dit is een meer permanente oplossing om meer swapruimte toe te voegen.
Om permanent naar een bestand te swappen, maakt u eerst een kernel met
vnd0c als swap. Als u wd0a als root bestandssysteem hebt, is wd0b de
vorige swap, gebruik deze lijn in het kernelconfiguratiebestand
(raadpleeg het compileren van een nieuwe kernel indien u twijfelt):

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
Nadat dit gebeurd is, moet het bestand dat zal gebruikt worden om te swappen,
aangemaakt worden. U doet dit best door hetzelfde commando te gebruiken als
in de bovenstaande voorbeelden.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Nu uw bestand op zijn plaats staat, moet u het bestand toevoegen aan uw
<i>/etc/fstab</i>. Hier is een voorbeeldlijn om met dit device als swap te
starten bij het booten.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
Op dit punt moet uw computer herstart worden zodat de kernelveranderingen
kunnen plaatsvinden. Zodra dit gebeurd is, is het tijd om het device als
swap te configureren. Om dit te doen zal u
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a> gebruiken.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
En dan nu de laatste stap, het swappen naar dat device aanzetten. We zullen
dit gewoon doen zoals in de bovenstaande voorbeelden, met swapctl(8). Daarna
zullen we controleren om te zien of het juist werd toegevoegd aan onze lijst
van swap devices.

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>


<p>
Soft Updates is gebaseerd op een idee voorgesteld door
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
en Yale Patt</a> en ontwikkeld voor FreeBSD door
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a>.
SoftUpdates legt een gedeeltelijke schikking op aan de buffer cache operaties
die toelaat de vereiste voor het synchroon schrijven van directory entries
te verwijderen uit de FFS code. Dus, een grote performantiestijging wordt
waargenomen in schijf-schrijfprestatie.

<p>
Om Soft Updates te gebruiken, moet in uw kernel

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
gecompileerd zijn, dit is reeds zo bij GENERIC.

<p>
Soft updates inschakelen moet gedaan worden met een mount-optie. Bij het
mounten van een partitie met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a> 
utility, kan u specificeren dat u soft updates wenst in te schakelen op die
partitie. Hieronder is een voorbeeld
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
lijn die één partitie <i>sd0a</i> heeft die we graag zouden
mounten met soft updates.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Opmerking voor sparc gebruikers: Schakel soft updates niet in op sun4 of
sun4c machines. Deze architecturen ondersteunen slechts een heel beperkte
hoeveelheid kernelgeheugen en kunnen deze functionaliteit niet gebruiken.
sun4m machines zijn echter wel goed.

<a name="Boot386"></a>
<h2>14.6 - Hoe boot OpenBSD/i386?</h2>
Het bootproces voor OpenBSD/i386 is niet triviaal, en begrijpen hoe het werkt,
kan nuttig zijn om een probleem te onderzoeken wanneer er dingen niet werken.
Er zijn vier sleutelelementen voor het bootproces:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> De Master Boot Record is de
eerste fysische sector (512 bytes) op de schijf.
Deze bevat de primaire partitietabel en een klein programma om de
Partition Boot Record (PBR) te laden.
Merk op dat in sommige omgevingen, de term "MBR" gebruikt wordt om alleen
naar het code-gedeelte van dit eerste blok op de schijf te verwijzen,
veeleer dan naar het volledige eerste blok (inclusief de partietabel).
Het is cruciaal om de betekenis te begrijpen van "de MBR initaliseren" -- in
de terminologie van OpenBSD zou dit het herschrijven van de volledige MBR
sector inhouden, niet alleen de code, zoals het op sommige systemen zou kunnen
betekenen.
U zal dit zelden willen doen.
Gebruik in de plaats fdisk(8)'s "-u" commandoregeloptie
("<tt>fdisk -u wd0</tt>").

<p>
Hoewel OpenBSD een MBR bevat, bent u niet verplicht om deze te gebruiken,
aangezien praktisch gelijk welke MBR OpenBSD kan booten.
De MBR wordt gemanipuleerd door het fdisk(8) programma, dat gebruikt wordt
zowel om de partitietabel de bewerken, als om de MBR code op de schijf te
installeren.

<p>
OpenBSD's MBR kondigt zichzelf aan met de boodschap:
<pre>
    Using drive 0, partition 3.
</pre>
wat de schijf en de partitie toont waar het de PBR vandaan zal laden.
Bovenop het vanzelfsprekende, toont dit ook een punt (".") achteraan, wat
aangeeft dat de machine LBA vertaling kan gebruiken om te booten.
Als de machine geen LBA translatie kon gebruiken, zou het bovenstaande
punt vervangen geweest zijn door een kommapunt (";"), dat CHS vertaling
aangeeft:
<pre>
    Using Drive 0, Partition 3;
</pre>
Merk op dat het punt of kommapunt achteraan gebruikt kan worden als een
indicator van de "nieuwe" OpenBSD MBR, geïntroduceerd in OpenBSD 3.5.

<li><b><i>Partition Boot Record (PBR):</i></b>
De Partition Boot Record, ook PBR genoemd of
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(volgens de naam van het bestand dat de code bevat) is de eerste fysische
sector van de OpenBSD partitie op de schijf.
De PBR is de "first-stage boot loader" voor OpenBSD.
Deze wordt geladen door de MBR code,
en heeft de taak om de OpenBSD second-stage boot loader,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a> in te laden.
Net als de MBR is de PBR een heel kleine sectie van code en gegevens,
in totaal slechts 512 bytes.
Dat is niet voldoende om een volledige bestandssysteem-bewuste toepassing
te hebben, dus veeleer dan de PBR <tt>/boot</tt> te laten lokaliseren op de
schijf, wordt de BIOS-toegankelijke locatie van <tt>/boot</tt> fysisch
in de PBR gecodeerd bij de installatie.

<p>
De PBR wordt geïnstalleerd door
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>,
dat <a href="faq14.html#InstBoot">verder in dit document</a>
nader beschreven wordt.
De PBR kondigt zichzelf aan met de boodschap:
<pre>
    Loading...
</pre>
en geeft daarbij een punt weer voor elk bestandssysteem-blok dat het probeert
te laden.
Ook hier, de PBR toont of hij LBA of CHS gebruikt om te laden, als hij CHS
vertaling moet gebruiken, toont hij een boodschap met een kommapunt:
<pre>
    Loading;... 
</pre>
De oudere (pre v3.5) biosboot(8) vertoonde de boodschap "<tt>reading
boot...</tt>".


<li><b><i>Second Stage Boot Loader, <tt>/boot</tt>:</i></b> <tt>/boot</tt>
wordt geladen door de PBR, en heeft de taak om toegang te krijgen tot het
OpenBSD bestandssysteem via de BIOS van de machine, en om de eigenlijke
kernel te localiseren en te laden.
boot(8) geeft ook verscheidene opties en informatie door aan de kernel.
<p>
boot(8) is een interactief programma. Nadat het laadt, probeert het
<tt>/etc/boot.conf</tt> te localiseren en te lezen, indien het bestaat (dit
is niet het geval op een standaardinstallatie), en verwerkt de commando's
daarin. Tenzij anders opgelegd door <tt>/etc/boot.conf</tt>, geeft het
vervolgens een prompt aan de gebruiker:

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.06
     boot>
</pre>
Het geeft de gebruiker (standaard) vijf seconden om het andere taken te
geven, maar als er geen gegeven worden voor de timeout, begint het zijn
standaardgedrag: de kernel, <tt>bsd</tt>, inladen vanaf de root partitie
van de eerste harde schijf.
De second-stage boot loader onderzoekt uw systeem hardware via de BIOS
(aangezien de OpenBSD kernel niet geladen is).
Hierboven kan u enkele dingen zien die het gezocht en gevonden heeft:
<ul>
<li><b>pc0</b> - de standaard toetsenbord en video display van een i386 systeem.
<li><b>com0, com1</b> - Twee seriële poorten
<li><b>apm</b> - Advanced Power Management BIOS functies
<li><b>636k 190M</b> - De hoeveelheid conventioneel (onder 1M) en
extended (boven 1M) geheugen die het gevonden heeft
<li><b>fd0 hd0+</b> - De gevonden BIOS schijf devices, in dit geval, een
diskette en een harde schijf.
</ul>

Het '+' teken na de "hd0" geeft aan dat de BIOS tegen <tt>/boot</tt> gezegd
heeft dat deze schijf toegankelijk is via LBA.
Bij het uitvoeren van een eerste installatie zult u soms een '*' zien na een
harde schijf -- dit geeft een schijf aan die geen geldige OpenBSD disklabel
heeft.


<li><b><i>Kernel: <tt>/bsd</tt></i>:</b>  Dit is het doel van het bootproces,
om de OpenBSD kernel in RAM te laden en juist te laten draaien.
Zodra de kernel geladen is, heeft OpenBSD rechtstreeks toegang tot de
hardware, niet langer via de BIOS.

</ol>

Dus, het prille begin van het bootproces kan er als volgt uitzien:
<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.06
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.7 (GENERIC) #50: Sun Mar 20 00:01:57 MST 2005
   ...
</pre></blockquote>


<h3>What kan er verkeerd gaan</h3>
<ul>
<li><b>Slechte/ongeldige/incompatibele MBR:</b>
Gewoonlijk heeft een gebruikte harde schijf al wat MBR code op zijn plaats,
maar als de schijf nieuw is of verplaatst wordt vanuit een verschillend
platform, EN u antwoordt niet "Yes" op de "Use entire disk" vraag van het
<a href="faq4.html#Disks">installatieproces</a>, kan u komen te zitten met
een schijf zonder geldige MBR, en deze zal dus niet bootable zijn, ook al
heeft ze een geldige partitietabel.

<p>
U kan de OpenBSD MBR op uw schijf installeren met het fdisk programma.
Boot vanaf uw installatiemedium, kies "Shell" om een commandoprompt te krijgen:

<pre>
    # <b>fdisk -u wd0</b>
</pre>

U kan met fdisk ook een specieke MBR naar de schijf schrijven:
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre> 

dit zal het bestand <tt>/usr/mdec/mbr</tt> installeren als MBR van uw systeem.
Dit welbepaald bestand is op een standaard OpenBSD installatie toevallig de
standaard MBR die ook in fdisk ingebouwd zit, maar gelijk welke andere
MBR zou hier kunnen gespecificeerd worden.

<li><b>Ongeldige <tt>/boot</tt> locatie geïnstalleerd in PBR:</b>
Wanneer installboot(8) de partition boot record installeert, schrijft het het
bloknummer en offset van de inode van <tt>/boot</tt> in de PBR.
Daarom zal het verwijderen en vervangen van <tt>/boot</tt> zonder opnieuw
<a href="faq14.html#InstBoot">installboot(8)</a> uit te voeren, ervoor zorgen
dat uw systeem niet bootable is, aangezien de PBR zal inladen wat er toevallig
aangeduid wordt door de inode die er in gespecificeerd is, wat bijna zeker
niet langer de gewenste second-stage boot loader zal zijn!

Aangezien <tt>/boot</tt> gelezen wordt met BIOS aanroepen, waren oude versies
van de PBR gevoelig aan BIOS schijfvertaling. Als u de schijfgeometrie
veranderde (bv. u nam ze uit een computer die CHS vertaling gebruikt en
verplaatste ze naar een die LBA vertaling gebruikt, of u veranderde zelfs
een vertalingsoptie in uw BIOS), dan zou het <i>voor de BIOS lijken</i>
alsof het op een andere locatie stond (een ander numeriek blok moet
opgevraagd worden om dezelfde gegevens van de schijf te krijgen), dus u had
installboot(8) moeten uitvoeren alvorens het systeem kon herstart worden.
De nieuwe (vanaf OpenBSD 3.5 en later) PBR is veel toleranter voor
veranderingen in vertaling.
</ul>

Aangezien de PBR heel klein is, is zijn bereik van foutboodschappen vrij
beperkt, en een beetje cryptisch. De meest waarschijnlijke boodschappen zijn:

<ul>
<li><b>ERR R</b> -- BIOS gaf een fout bij het proberen lezen van een blok
vanaf de schijf.
Gewoonlijk betekent dit precies wat het zegt: uw schijf was niet leesbaar.
<li><b>ERR M</b> -- Er werd een ongeldig
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>
nummer gelezen in de hoofding van de second-stage bootloader's.
Dit betekent in het algemeen dat wat er ook ingelezen werd, NIET
<tt>/boot</tt> was, wat gewoonlijk betekent dat installboot(8) niet juist
werd uitgevoerd, het /boot bestand aangepast werd, of u de mogelijkheid
van uw BIOS om een <a href="#LargeDrive">grote schijf</a> te lezen, oversteeg.

</ul>
Andere foutboodschappen worden uitgebreid uitgelegd in de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">biosboot(8)
manual pagina</a>.


Voor meer informatie over het i386 bootproces, zie
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
  Hale Landis' "How it Works" documenten.
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - Wat zijn de problemen met grote schijven in OpenBSD?</h2>

<p>
OpenBSD ondersteunt een individueel bestandssysteem van maximaal
2<sup>31</sup>-1, of 2,147,483,647 sectoren, en aangezien elke sector
512 bytes is, is dat een kleine hoeveelheid minder dan 1T.

<p>
Natuurlijk zijn de mogelijkheden van bestandssystemen en de mogelijkheden van
bepaalde hardware twee verschillende dingen.
Een nieuwe 250G harde schijf zal niet werken op oudere (pre >137G
standaarden) interfaces, en bij sommige heel oude SCSI adapters werden
problemen gezien met meer moderne schijven, en sommige oudere BIOSen zullen
vasthangen wanneer ze een harde schijf met moderne grootte tegenkomen.
U moet natuurlijk de mogelijkheden van uw hardware respecteren.

<h3>Partitiegrootte en -locatie beperkingen</h3>
Jammer genoeg is de volledige mogelijkheid van het besturingssysteem niet
beschikbaar tot NADAT het besturingssysteem in het geheugen geladen is.
Het boot proces moet het boot RAM van het systeem gebruiken (en wordt
er dus door beperkt).
 
<p>
Om deze reden moet het volledige /bsd bestand (de kernel) op de schijf staan
binnen de door het boot ROM adresseerbare gebied.
Dit betekent dat op sommige oudere i386 systemen, de root partitie volledig
binnen de eerste 504M moet vallen, maar nieuwere computers kunnen beperkingen
van 2G, 8G, 32G, 128G of meer hebben.
Het is de moeite waard om op te merken dat vele relatief nieuwe computers die
schijven groter dan 128G ondersteunen, in feite BIOS beperkingen hebben
waardoor ze enkel van binnen de eerste 128G kunnen booten.
U kan deze systemen met grotere schijven gebruiken, maar uw root partitie
moet binnen de eerste 128G vallen.
 
<p>
Merk op dat het mogelijk is om een 40G schijf op een oude 486 te installeren
en OpenBSD er op te laden als één grote partitie, en te denken
dat u met succes de bovenstaande regel overtreden hebt. Het kan u echter
op de meest onaangename manier komen kwellen:

<ul>
  <li>U installeert op de 40G / partitie.  Het werkt, omdat het basis
besturingssysteem en alle bestanden ervan (/bsd inbegrepen) binnen de eerste
504M staan.
  <li>U gebruikt het systeem, en bekomt hierop uiteindelijk meer dan 504M aan
bestanden.
  <li>U doet een upgrade, bouwt uw eigen kernel, wat dan ook, en kopieert
uw nieuwe /bsd over de oude.
  <li>U herstart.
  <li>U krijgt een boodschap als "ERR M" of andere problemen bij het booten.
</ul>
<p>
Waarom? Omdat wanneer u het nieuwe /bsd bestand "over" kopieerde, dit niet
het oude overschreef, het werd een nieuwe locatie toegekend op de schijf,
waarschijnlijk buiten het 504M bereik dat het BIOS ondersteunt. De
boot loader kon het bestand /bsd niet opvragen, en het systeem hing vast.

<p>
Om OpenBSD te kunnen booten, moeten de boot loaders (biosboot(8) en
<tt>/boot</tt> in het geval van i386) en de kernel (<tt>/bsd</tt>) binnen
het door het BIOS ondersteunde bereik zitten, en binnen hun eigen
mogelijkheden.
Om op veilig te spelen, is de regel eenvoudig:

<p>
<b>de volledige root partitie moet binnen de door het BIOS van de computer
(of door het boot ROM) adresseerbare ruimte vallen.</b>

<p>
Sommige niet-i386 gebruikers denken dat ze hier immuun voor zijn, maar
de meeste platformen hebben een vorm van boot ROM beperking voor schijfgrootte.
Helemaal zeker te weten komen wat die beperking is, kan echter moeilijk zijn.

<p>
Dit is nog een andere goede reden om <a href="faq4.html#SpaceNeeded">uw schijf
te partitioneren</a>, veeleer dan één grote partitie te
gebruiken.

<h3>fsck(8) tijd- en geheugenvereisten</h3>
Een andere overweging i.v.m. grote bestandssystemen is de tijd en het
geheugen vereist om
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
uit te voeren op het bestandssysteem na een crash of stroomonderbreking.
Men kan beter niet een 120G bestandssysteem zetten op een systeem met 32M RAM
en verwachten dat het met succes fsck(8) uitvoert na een crash.
Een grove richtlijn is dat het systeem ten minste 1M beschikbaar geheugen
zou moeten hebben voor elke 1G aan schijfruimte om met succes fsck uit te
voeren op de schijf.
De tijd vereist om fsck op de schijf uit te voeren, kan een probleem worden
naarmate het bestandssysteem uitbreidt.


<a name="InstBoot"></a>
<h2>14.8 - Installeren van Bootblocks - i386 specifiek</h2>

<p>
Oudere versies van MS-DOS kunnen enkel omgaan met schijfgeometrieën van
1024 cilinders of minder. Aangezien bijna alle moderne schijven meer dan
1024 cilinders hebben, hebben de meeste SCSI BIOS chips (die op een SCSI
controller kaart zitten) en IDE BIOS (dat onderdeel is van de rest van het
PC BIOS) een optie (soms standaard) om de werkelijke schijfgeometrie te
"vertalen" naar iets dat binnen de mogelijkheden van MS-DOS past. Niet alle
BIOS chips "vertalen" echter de geometrie op dezelfde wijze. Als u uw BIOS
verandert (met een nieuw moederbord of een nieuwe SCSI controller), en de
nieuwe gebruikt een verschillende "vertaalde" geometrie, dan zal u de
second-stage boot loader niet kunnen laden (en dus ook de kernel niet kunnen
laden).
(Dit is zo omdat de first-stage boot loader een lijst van de blokken bevat die
/boot uitmaken, in termen van de oorspronkelijke "vertaalde" geometrie).
Als u IDE schijven gebruikt, en u brengt veranderingen aan in uw BIOS
instellingen, kan u (zonder het te weten) ook de vertaling veranderen (de
meeste IDE BIOSen bieden 3 verschillende vertalingen). Om uw boot block
te herstellen zodat u normaal kan booten, steek dan eerst een bootdiskette
in uw diskettestation (of gebruik een bootable CD-ROM) en typ op de boot
prompt "b hd0a:/bsd" om het te dwingen vanaf de eerste harde schijf (en
niet vanaf de diskette) te booten. Uw machine zou zoals normaal moeten
opstarten. U moet de first-stage boot loader updaten opdat die de nieuwe
geometrie zou zien (en de boot block overeenkomstig herschrijven).
<br>Ons voorbeeld zal veronderstellen dat uw boot schijf sd0 is (maar voor
IDE zou het wd0, enz. zijn):

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
Als een nieuwere versie van bootblocks vereist is, zal u deze zelf moeten
compileren. Hiervoor doet u eenvoudigweg:

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (of welk device uw harde schijf ook is)
</pre>

<a name="Backup"></a>
<h2>14.9 - Zich op het ergste voorbereiden: Backup en Restore vanaf tape</h2>

<h3>Inleiding:</h3>

<p>
Als u van plan bent om iets te draaien dat een productieserver zou kunnen
genoemd worden, is het aan te raden om een vorm van backup te hebben voor
het geval één van uw vaste schijven het begeeft.

<p>
Deze informatie zal u de standaard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
utilities helpen gebruiken die voorzien zijn in OpenBSD.
Een meer geavanceerde backup utility,
"<a href="http://www.amanda.org">Amanda</a>" genoemd, is ook beschikbaar via
<a href="faq8.html#Ports">ports</a> om meerdere servers naar één
tape drive te backup'en.
In de meeste omgevingen is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
voldoende. Als u echter meerdere machines moet backupen, kan
het de moeite lonen om Amanda te bekijken.

<p>
De device voorbeelden in dit document zijn voor een configuratie die
SCSI schijven en tape gebruikt. In een productie-omgeving worden SCSI schijven
aanbevolen eerder dan IDE vanwege de manier waarop ze slechte blokken
behandelen.
Dat wil niet zeggen dat deze informatie nutteloos is als u een IDE schijf
of een ander type van tape drive gebruikt, uw device-namen zullen gewoon
lichtjes verschillen. Zo zou sd0a bijvoorbeeld wd0a zijn in een
IDE-gebaseerd systeem.

<h3>Backup naar tape:</h3>

<p>
Backup naar tape vereist kennis van waar uw bestandssystemen gemount zijn.
U kan te weten komen hoe uw bestandssystemen gemount zijn met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
commando op uw shell prompt. U zou uitvoer moeten krijgen gelijkaardig aan:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
In dit voorbeeld staat het root (/) bestandssysteem fysisch op sd0a
dat aangeeft: SCSI vaste schijf 0, partitie a. Het /usr bestandssysteem
verblijft op sd0h, wat aangeeft: SCSI vaste schijf 0, partitie h.

<p>
Een ander voorbeeld van een meer geavanceerde mount-tabel zou kunnen zijn:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
In dit meer geavanceerde voorbeeld staat het root (/) bestandssysteem
fysisch op sd0a. Het /var bestandssysteem staat op sd0d, het /home
bestandssysteem op sd0e en tenslotte /usr op sd0h.

<p>
Om uw machine te backup'en zal u dump de naam moeten meegeven van elke
vaste schijfpartitie. Hier is een voorbeeld van de commando's nodig voor
een backup van de eenvoudigere mount-tabel die hoger getoond werd:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Voor het voorbeeld van de meer geavanceerde mount tabel, zou u iets gebruiken
dat lijkt op:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
U kan de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
man pagina bekijken om precies te leren wat elke commandolijn-optie doet. Hier
is een korte omschrijving van de parameters die hierboven gebruikt werden:

<ul>
<li><b>0</b> - Voer een level 0 dump uit, neem alles
<li><b>a</b> - Probeer automatisch de lengte van het tape medium te bepalen
<li><b>u</b> - Update het bestand /etc/dumpdates om aan te geven wanneer de
laatste backup uitgevoerd werd
<li><b>f</b> - Welk tape device te gebruiken (/dev/nrst0 in dit geval)
</ul>

<p>
Tenslotte welke partitie te backup'en (/dev/rsd0a, etc)

<p>
Aan het einde wordt het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
commando gebruikt om de tape terug te spoelen. Bekijk de mt man
pagina voor meer opties (zoals eject).

<p>
Als u niet zeker bent van uw tape devicenaam, gebruik dan dmesg om hem te
localiseren. Een voorbeeld van een tape drive entry in dmesg zou hierop
kunnen lijken:

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
U hebt misschien opgemerkt dat bij de backup, toegang tot de tape gebeurt
via de devicenaam "<tt>nrst0</tt>" in plaats van de "<tt>st0</tt>" naam die
in dmesg gezien wordt.
Wanneer u <tt>st0</tt> als <tt>nrst0</tt> benadert, benadert u dezelfde
fysische tape maar zegt u daarbij dat hij niet moet terugspoelen aan het
einde van de taak en benadert u het device in "raw" modus. Om meerdere
bestandssystemen naar een enkele tape te backup'en, gebruik dan zeker het
non-rewind device, als u een rewind device (<tt>rst0</tt>) gebruikt om
meerdere bestandssystemen te backup'en, zal u uiteindelijk het vorige door
het volgende bestandssysteem overschrijven dat dump naar tape probeert te
schrijven. U kan een meer uitgebreide beschrijving van verschillende tape
devices terugvinden in de dump man pagina.

<p>
Als u een klein script met de naam "backup" wou schrijven, zou dit er
ongeveer zou kunnen uitzien:

<pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre>

<p>
Als geplande nachtelijke backups gewenst zijn, zou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
gebruikt kunnen worden om uw backup script automatisch te starten.

<p>
Het zal ook nuttig zijn om te documenteren (op een stukje papier) hoe groot
elk bestandssysteem moet zijn. U kan "<tt>df -h</tt>" gebruiken om te bepalen
hoeveel ruimte elke partitie momenteel gebruikt. Dit zal handig zijn als de
schijf het begeeft en u uw partitietabel op de nieuwe schijf opnieuw moet
maken.

<p>
Uw gegevens herstellen zal ook fragmentatie helpen reduceren. Om er zeker
van te zijn dat u alle bestanden meeneemt, is de beste manier voor een backup
het systeem rebooten in single user modus. Bestandssystemen hoeven niet
gemount te zijn om gebackupt te worden. Vergeet niet om root (/) r/w te
mounten na het booten van uw systeem in single user modus of uw dump zal
mislukken wanneer hij dumpdata probeert weg te schrijven. Geef
"<tt>bsd -s</tt>" in op de boot&gt; prompt voor single user modus.

<h3>De inhoud van een dump tape bekijken:</h3>


<p>
Nadat u voor het eerst uw bestandssystemen gebackupt hebt, zou het een
goed idee zijn om kort uw tape te testen en er zeker van te zijn dat de
gegevens er op staan zoals u verwacht.

<p>
U kan het volgende voorbeeld gebruiken om een catalogus van bestanden op
een dump tape te na te kijken:

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
Dit zorgt ervoor dat een lijst van bestanden verschijnt die op de 1ste
partitie van de dump tape staan. Volgens de bovenstaande voorbeelden,
zou 1 uw root (/) bestandssysteem zijn.

<p>
Om te zien wat er op de 2de tape partitie staat en de uitvoer naar een
bestand te sturen, zou u een commando gelijkaardig aan dit gebruiken:

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
Als u een mount-tabel hebt zoals de eenvoudige, zou 2 /usr zijn, als de uwe
een meer geavanceerde mount-tabel is, zou 2 /var of een ander fs kunnen zijn.
Het sequentienummer stemt overeen met de volgorde waarin de bestandssystemen
naar tape geschreven worden.


<h3>Restore vanaf tape:</h3>

<p>
Het voorbeeldscenario hieronder zou nuttig zijn als uw vaste schijf het
volledig heeft laten afweten. Voor het geval u een enkel bestand vanaf
tape wil restoren, kijk de restore man pagina na en let daarbij op de
interactive mode instructies.

<p>
Als u zich goed hebt voorbereid, kan een schijf vervangen en uw gegevens
restoren een heel snel proces zijn. De standaard OpenBSD installatie/boot
diskette bevat reeds de vereiste restore utility en ook de binaries vereist
om uw nieuwe schijf te partitioneren en bootable te maken. In de meeste
gevallen zijn deze diskette en uw meest recente dump tape al wat u zal nodig
hebben om weer aan de slag te geraken.

<p>
Na het fysisch vervangen van de kapotte schijf, zijn de basisstappen om uw
gegevens te restoren de volgende:

<ul>
<li>
<p>
Boot vanaf de OpenBSD installatie/boot diskette. Bij de menuselectie kiest
u Shell. Bescherm uw tape tegen overschrijven en plaats hem in de lezer.
<br>
<li>
<p>
Maak met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
commando een primaire OpenBSD partitie op deze nieuw geïnstalleerde
schijf. Voorbeeld:

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
Zie <a href="#fdisk">fdisk FAQ</a> voor meer info.

<li>
<p>
Maak met het disklabel commando opnieuw uw OpenBSD partitietabel binnen die
primaire OpenBSD partitie die u net met fdisk hebt aangemaakt.
Voorbeeld:

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(Vergeet swap niet, zie <a href="#disklabel">disklabel FAQ</a> voor meer info)

<li>
<p>
Gebruik het newfs commando om een proper bestandssysteem te bouwen op elke
partitie die u in de vorige stap aanmaakte. Voorbeeld:

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
Mount uw zonet voorbereid root (/) bestandssysteem op /mnt. Voorbeeld:

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
Ga naar dat gemounte root bestandssysteem en start het restore proces.
Voorbeeld:

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
U zal willen dat deze nieuwe schijf bootable is, gebruik het volgende om
een nieuwe MBR naar uw schijf te schrijven. Voorbeeld:

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
<p>
Bovenop het wegschrijven van een nieuwe MBR naar de schijf, zal u er
boot blocks moeten op installeren. Het volgende is een kort voorbeeld:

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
Uw nieuw root bestandssysteem op de vaste schijf zou moeten klaar zijn zodat
u het kan booten en verder gaan met de rest van uw bestandssystemen te
restoren. Aangezien uw besturingssysteem nog niet volledig is, zorgt u er
voor om in single user modus te booten. Voer op de shell prompt de volgende
commando's uit om het systeem te unmounten en te stoppen:

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
Verwijder de installatie/boot diskette uit het station en herstart uw systeem.
Voer op de OpenBSD boot&gt; prompt het volgende commando uit:

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
De bsd -s zal ervoor zorgen dat de kernel in single user modus gestart wordt,
wat alleen een root (/) bestandssysteem vereist.

<li>
<p>
In de veronderstelling dat u de bovenstaande stappen correct hebt uitgevoerd
en er niets verkeerd gegaan is, zou u moeten terechtkomen op een prompt die
u vraagt om een shell pad in te geven of return te duwen. Duw return om sh
te gebruiken. Vervolgens zal u root in r/w willen hermounten in tegenstelling
tot read only. Voer het volgende commando uit:

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
Zodra u / in r/w modus gehermount hebt kan u verdergaan met uw andere
bestandssystemen te restoren. Voorbeeld:

<pre>
(eenvoudige mount-tabel)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(meer geavanceerde mount-tabel)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
U zou "<b>restore rvsf</b>" kunnen gebruiken in plaats van gewoon rsf om
de namen van objecten te zien terwijl ze vanaf de dump set uitgepakt worden.

<li>
<p>
Tenslotte, nadat u klaar bent met al uw andere bestandssystemen op schijf
te restoren, kan u herstarten in multi-user modus. Als alles ging zoals
gepland, zal uw systeem weer in de toestand zijn waarin het zich bevond
ten tijde van uw meest recente backup, en opnieuw klaar om te gebruiken.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Schijfimages mounten in OpenBSD</h2>

<p>
Om een schijfimage (ISO images, schijfimages gemaakt met dd, enz.) te mounten
in OpenBSD, moet u een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>
device configureren. Bijvoorbeeld, als u een ISO image hebt staan in
<i>/tmp/ISO.image</i>, zou u de volgende stappen volgen om de image te mounten.

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
Merk op dat, aangezien deze image een CD image is, u als type <i>cd9660</i>
moet specificeren bij het mounten. Dit geldt ongeacht het type, u moet bv.
type <i>ext2fs</i> gebruiken bij het mounten van Linux schijfimages.

<p>
Gebruik de volgende commando's om de image te unmounten.

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
Raadpleeg voor meer informatie de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
man pagina.


<a name="pciideErr"></a>
<h2>14.11 - Hulp! Ik krijg fouten met IDE DMA!</h2>

<p>
DMA IDE transfers, ondersteund door
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>
zijn onbetrouwbaar bij vele combinaties van hardware. Tot voor kort werden
de meeste "mainstream" besturingssystemen die beweerden DMA transfers met
IDE schijven te ondersteunen, niet geleverd met die functionaliteit
standaard ingeschakeld, vanwege onbetrouwbare hardware.
Nu worden veel van diezelfde machines gebruikt voor OpenBSD.

<p>
OpenBSD is aggressief en probeert de hoogste DMA Mode die het kan configureren.
Dit zal corruptie van gegevenstransfers veroorzaken in sommige configuraties
vanwege buggy moederbord chipsets, buggy schijven, en/of ruis op de
kabels. Gelukkig beschermt Ultra-DMA gegevenstransfers met een CRC om
corruptie te detecteren. Wanneer de Ultra-DMA CRC mislukt, zal OpenBSD
een foutboodschap geven en de operatie opnieuw proberen.

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
Na enkele keren te falen, zal OpenBSD "downgraden" naar een tragere
(hopelijk meer betrouwbare) Ultra-DMA mode. Als Ultra-DMA mode 0 bereikt
is, dan zal de schijf downgraden naar PIO mode.

<p>
UDMA fouten worden vaak veroorzaakt door lage kwaliteits- of beschadigde kabels.
Kabelproblemen zouden gewoonlijk de eerste verdachte moeten zijn indien u
veel DMA fouten of onverwacht lage DMA prestatie krijgt.
Het is ook een slecht idee om de CD-ROM op hetzelfde kanaal als een harde
schijf te zetten.

<p>
Als het vervangen van de kabels het probleem niet oplost en OpenBSD niet
met succes downgrade't, of het proces zorgt ervoor dat uw machine hard
vasthangt, of veroorzaakt buitensporig veel boodschappen op de console en
in de logs, dan wil u misschien het systeem dwingen tot het standaard
gebruiken van een lager DMA of UDMA level.
Dit kan gedaan worden met <a href="faq5.html#BootConfig">UKC</a> of
<a href="faq5.html#config">config(8)</a> om de vlaggen van het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>
device te veranderen.


<a name="RAID"></a>
<h2>14.13 - RAID opties voor OpenBSD</h2>
RAID (Redundant Array of Inexpensive Disks) biedt een mogelijkheid om meerdere
schijven te gebruiken om betere prestaties, capaciteit en/of redundantie te
geven dan men uit een enkele schijf alleen kan verkrijgen. Hoewel een
volledige discussie van de voordelen en risico's van RAID buiten het bestek
van dit artikel vallen, zijn er enkele punten die belangrijk zijn om hier
uit te leggen:

<ul>
<li>RAID heeft niets te maken met backup.
<li>Op zichzelf zal RAID down-tijd niet elimineren.
</ul>

Als deze informatie nieuw is voor u, is dit geen goed vertrekpunt voor
uw verkenning van RAID.

<h3>Software Opties</h3>
OpenBSD bevat RAIDframe, een software RAID oplossing. Documentatie ervoor
kan op de volgende plaatsen gevonden worden:

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe Homepagina</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">man
     pagina voor raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">man
     pagina voor raid(4)</a>
</ul>

<p>
De root partitie kan direct
door OpenBSD gemirrored worden met de "Autoconfiguration" optie van RAIDframe.

<p>
OpenBSD 3.7-stable en later bevat ook mirroring als een functionaliteit van de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
driver.
Het wordt niet aangeraden dat men hiervoor 3.7-release gebruikt, er was een bug
die hersteld werd in 3.7-stable.
Dit systeem is ingebouwd in de GENERIC kernel en zit in de bsd.rd kernel,
dus het kan veel gemakkelijker te gebruiken zijn, hoewel het enkele beperkingen
heeft wat betreft het herbouwen van de array.
Zie:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)
man pagina</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)
man pagina</a>
</ul>

<h3>Hardware Opties</h3>
<p>
Veel OpenBSD <a href="../../nl/plat.html">platformen</a> bevatten ondersteuning voor
verschillende hardware RAID producten. De opties variëren volgens
platform, zie de gepaste hardware support pagina
(<a href="../../nl/plat.html">hier</a> getoond).

<p>
Een andere optie die beschikbaar is voor vele platformen is een van de vele
producten die meerdere schijven zich als een enkele IDE of SCSI schijf laten
voordoen, en vervolgens in een standaard IDE of SCSI adapter gestoken worden.
Deze apparaten kunnen werken op bijna gelijk welk hardware platform dat ofwel
SCSI of IDE ondersteunt.

<p>
Enkele fabricanten van deze producten:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Opmerking: dit zijn gewoon producten waarvan OpenBSD gebruikers hun gebruik
gemeld hebben -- dit is helemaal geen steunbetuiging, noch een volledige
lijst.)


<h3>Niet-Opties</h3>
<p>
Een vaak gestelde vraag op de <a href="../../nl/mail.html">mailinglijsten</a> is
"Worden de goedkope IDE of SATA RAID controllers (zoals degene die Highpoint,
Promise of Adaptec HostRAID chips gebruiken) ondersteund?". Het antwoord
is "Neen". Deze kaarten en chips zijn geen echte hardware RAID controllers,
maar eerder BIOS-geassisteerde boot van een software RAID. Aangezien
OpenBSD reeds software RAID ondersteunt op een hardware-onafhankelijke
manier, is er niet veel verlangen onder OpenBSD ontwikkelaars om speciale
ondersteuning voor deze kaarten te implementeren.

<p>
Bijna alle on-board SATA of IDE "RAID" controllers zijn van deze
software-gebaseerde stijl, en zullen typisch goed werken als een SATA of
IDE controller met de standaard IDE driver
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>),
maar zullen niet werken als een hardware RAID systeem op OpenBSD.

<a name="NegSpace"></a>
<h2>14.14 - Waarom vertelt <tt>df(1)</tt> me dat ik meer dan 100% van mijn
schijf in gebruik heb?</h2>
Mensen worden soms verrast om te ontdekken dat ze <i>negatieve</i>
beschikbare schijfruimte hebben, of meer dan 100% van een partitie in gebruik,
zoals getoond door
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>.

<p>
Wanneer een partitie gemaakt wordt met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>,
wordt een beetje van de beschikbare ruimte op reserve gehouden weg van
normale gebruikers. Dit biedt een foutenmarge wanneer u per ongeluk de
schijf vult, en helpt om schijffragmentering tot een minimum te beperken.
Standaard hiervoor is 5% van de schijfcapaciteit, dus als de root gebruiker
achteloos de schijf aan het vullen geweest is, kan u tot 105% van de
beschikbare capaciteit in gebruik zien.

<p>
Als de waarde van 5% niet gepast is voor u, kan u ze veranderen met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>
commando.

<a name="OhBugger"></a>
<h2>14.15 - Partities herstellen na het verwijderen van het disklabel</h2>

<p>
Als u een beschadigde partitietabel hebt, zijn er verschillende dingen die
u kan proberen om ze te herstellen.

<p>
Ten eerste, panikeer.
Dit doet u gewoonlijk toch, dus u kan er maar beter komaf mee maken.
Doe gewoon niets doms.
Panikeer weg van uw machine.
Ontspan vervolgens, en kijk of de onderstaande stappen u niet helpen.

<p>
Sinds OpenBSD 3.6 wordt een kopie van het disklabel voor elke schijf bewaard
in <tt>/var/backups</tt> als onderdeel van het dagelijkse systeemonderhoud.
In de veronderstelling dat u nog steeds de var partitie hebt, kan u
eenvoudigweg de uitvoer lezen en terugplaatsen in het disklabel.

<p>
In het geval u die partitie niet langer kan zien, zijn er twee opties.
Herstel voldoende van de schijf zodat u ze kan zien, of herstel voldoende
van de schijf zodat u uw gegevens er kan afhalen.

Afhankelijk van wat er gebeurde, kan het ene of het andere te verkiezen zijn
(bij stervende schijven wil u eerst de data, met vuile vingers kan u gewoon
het label hebben).

<p>
De eerste tool die u nodig hebt is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(bemerk de underscore, het heet niet "scanffs").
scan_ffs(8) zal een schijf bekijken, en proberen partities te vinden en u ook
zeggen welke informatie het erover terugvindt.
U kan deze informatie gebruiken om het disklabel te reconstrueren.
Als u gewoon <tt>/var</tt> terug wil, kan u de partitie voor <tt>/var</tt>
opnieuw aanmaken, en dan het backup-label herstellen en de rest van daar uit
toevoegen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
zal de kernel zijn begrip van het disklabel updaten, en
ook het label naar de schijf proberen te schrijven.
Daarom zal u, zelfs als het gebied van de schijf dat het disklabel bevat
onleesbaar is, het kunnen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>en
tot de volgende reboot.


<a name="foreignfs"></a>
<h2>14.16 - Kan ik gegevens benaderen op andere bestandssystemen dan FFS?</h2>
<!-- This article written by Steven Mestdagh,
steven.mestdagh@esat.kuleuven.be, and released under the BSD license -->

Ja. Andere ondersteunde bestandssystemen zijn: ext2 (Linux), ISO9660 (CD-ROM,
DVD media), FAT (MS-DOS en Windows), NFS, NTFS (Windows), AmigaDOS.
Sommige ervan hebben beperkte, bijvoorbeeld read-only, ondersteuning.

<p>
We zullen een algemeen overzicht geven van het gebruik van één van deze
bestandssystemen onder OpenBSD.
Om een bestandssysteem te kunnen gebruiken, moet het gemount worden.
Raadpleeg voor details en mountopties alstublieft de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
manual pagina, en die van het mount commando voor het bestandssysteem dat u
zal mounten, bv. mount_msdos, mount_ext2fs, ...

<p>
Eerst moet u weten op welk device uw bestandssysteem zich bevindt. Dit kan
gewoon uw eerste harde schijf, <tt>wd0</tt> of <tt>sd0</tt>, zijn maar het
kan ook minder voor de hand liggend zijn.
Alle herkende en geconfigureerde devices op uw systeem worden vermeld in
de uitvoer van het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
commando: een devicenaam, gevolgd door een beschrijving op één lijn van het
device.
Mijn eerste CD-ROM lezer wordt bijvoorbeeld als volgt herkend:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Op dit punt is het tijd om te weten te komen welke partities er op het device
zijn, en in welke partitie het gewenste bestandssysteem zit.
Daarvoor onderzoeken we het device met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
De disklabel bevat een lijst van partities, met een maximum aantal van 16.
Partitie c duidt altijd het volledige device aan.
Partities a-b en d-p worden gebruikt door OpenBSD.
Partities i-p kunnen automatisch toegewezen worden aan bestandssystemen van
andere besturingssystemen.
In dit geval zal ik de disklabel van mijn harde schijf bekijken, die een
aantal verschillende bestandssystemen bevat.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A       
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581 
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206 
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544 
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367 
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773 
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176 
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>

<p>
Zoals gezien kan worden in de bovenstaande uitvoer, worden eerst de OpenBSD
partities opgesomd.
Daarbuiten zijn er een aantal ext2 partities en één MSDOS partitie, en ook
enkele 'onbekende' partities. Op i386 en amd64 systemen kan u daarover
gewoonlijk meer te weten komen met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
utility.
Voor de nieuwsgierige lezer: partitie i is een onderhoudspartitie aangemaakt
door de verkoper, partitie j is een NTFS partitie en partitie l is een Linux
swappartitie.

<p>
Zodra u bepaald hebt welke partitie het is die u wil gebruiken, kan u
overgaan tot de laatste stap: het bestandssysteem dat er in zit mounten.
De meeste bestandssystemen worden ondersteund in de GENERIC kernel: kijk
maar eens naar het kernelconfiguratiebestand, te vinden in de
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt> directory.
Sommige zijn echter niet ondersteund, bv. de NTFS ondersteuning is
experimenteel en daarom niet opgenomen in GENERIC.
Als u één van de bestandssystemen wil gebruiken die niet ondersteund zijn
in GENERIC, zal u <a href="faq5.html#Options">een aangepaste kernel moeten
bouwen</a>.

<p>
Wanneer u de benodigde informatie hebt verzameld zoals hierboven vermeld,
is het tijd om het bestandssysteem te mounten.
Laten we aannemen dat een directory <tt>/mnt/anderfs</tt> bestaat, die we
zullen gebruiken als mountpunt waar we het gewenste bestandssysteem zullen
mounten.
In dit voorbeeld zullen we het ext2 bestandssysteem in partitie m mounten:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/anderfs</b>
</pre></blockquote>

<p>
Als u van plan bent dit bestandssysteem regelmatig te gebruiken, kan u
uzelf wat tijd besparen door er een lijn voor in <tt>/etc/fstab</tt> te
plaatsen, bijvoorbeeld iets als:

<blockquote><pre>
/dev/wd0m /mnt/anderfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Bemerk de 0 waarden in het vijfde en zesde veld.
Dit betekent dat we niet vereisen dat het bestandssysteem gedumpt moet
worden, en gecontroleerd met fsck.
In het algemeen zijn dat dingen die u wil laten afhandelen door het
moeder-besturingssyssteem geassocieerd met het bestandssysteem.


<a name="flashmem"></a>
<h2>14.17 - Kan ik een flash geheugentoestel gebruiken met OpenBSD?</h2>
<!-- This article written by Steven Mestdagh,
steven.mestdagh@esat.kuleuven.be, and released under the BSD license -->

Normaal moet het geheugentoestel herkend worden wanneer u het in een poort
van uw machine steekt.
Kort na het insteken worden door de kernel een aantal boodschappen naar de
console geschreven.
Wanneer ik bijvoorbeeld mijn USB flash geheugentoestel insteek, zie ik het
volgende op mijn console:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Deze lijnen geven aan dat de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>
(USB mass storage) driver vastgehangen werd aan het geheugentoestel, en dat
hij het SCSI systeem gebruikt.
De laatste twee lijnen zijn de belangrijkste: ze zeggen op welke device node
het geheugentoestel vastgemaakt werd, en wat de totale hoeveelheid
opslagruimte is.
Als u op één of andere manier deze lijnen gemist hebt, kan u ze nadien nog
steeds zien met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
commando.
De gerapporteerde CHS geometrie is eerder fictief, aangezien het flash
geheugen behandeld wordt als gelijk welke gewone SCSI schijf.

<p>
We zullen hieronder twee scenario's bespreken.

<h3>Het toestel is nieuw/leeg en u wil het alleen met OpenBSD gebruiken</h3>

U zal een disklabel op het toestel moeten initialiseren, en ten minste
één partitie aanmaken.
Lees alstublieft <a href="#disklabel">OpenBSD's disklabel gebruiken</a> en de 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
manual pagina voor details hierover.

<p>
In dit voorbeeld maakte ik gewoon één partitie <i>a</i> waarin ik een FFS
bestandssysteem zal plaatsen:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Laten we het bestandssysteem dat we in de <i>a</i> partitie aanmaakten,
mounten op <tt>/mnt/flashmem</tt>.
Maak het mountpunt eerst aan als het niet bestaat.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h3>U kreeg het geheugentoestel van iemand met wie u gegevens wil uitwisselen</h3>

<p>
Er is een aanzienlijke kans dat de andere persoon niet OpenBSD gebruikt,
dus er kan een vreemd bestandssysteem op het geheugentoestel staan.
Daarom zullen we eerst moeten te weten komen welke partities er op het toestel
staan, zoals beschreven in
<a href="#foreignfs">FAQ 14 - Vreemde Bestandssystemen</a>.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122 
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Zoals kan gezien worden in de disklabel uitvoer hierboven, is er slechts
één partitie <i>i</i>, die een FAT bestandssysteem bevat, aangemaakt op een
Windows machine.
Zoals gewoonlijk geeft de <i>c</i> partitie de volledige device weer.

<p>
Laten we nu het bestandssysteem in de <i>i</i> partitie mounten op
<tt>/mnt/flashmem</tt>.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Nu kan u het beginnen gebruiken net zoals gelijk welke andere schijf.

<p>
<b>WAARSCHUWING:</b>
U moet het bestandssysteem <b>altijd unmounten</b> <b>voor het uittrekken</b>
van het geheugentoestel.
Als u dit niet doet, kan het bestandssysteem in een inconsistente toestand
achterblijven, wat kan leiden tot corrupte gegevens.

<p>
Bij het uittrekken van het geheugentoestel uit uw machine zal u opnieuw
zien dat de kernel hierover boodschappen naar de console schrijft:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq13.html">[Naar Sectie 13 - Multimedia]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[terug]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.133 ]<br>
$Translation: faq14.html,v 1.15 2005/07/28 06:29:24 smestdag Exp $<br>
-->
$OpenBSD: faq14.html,v 1.13 2005/07/28 09:54:34 saad Exp $
</small>

</body>
</html>
