<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Configuração dos Discos</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2009 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Índice da FAQ]</a>
<a href= "faq13.html">[Seção 13 - Multimídia]</a>
<a href= "faq15.html">[Seção 15 - Pacotes e Portes]</a>
</font>

<h1><font color="#e00000">14 - Configuração dos Discos</font></h1><hr>

<h3>Conteúdo</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Uso do disklabel(8) do OpenBSD</a>
<li><a href="#fdisk"      >14.2 - Uso do fdisk(8) do OpenBSD</a>
<li><a href="#NewDisk"    >14.3 - Adição de discos extras no OpenBSD</a>
<li><a href="#Swap"       >14.4 - Como a swap é controlada?</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Como é o processo de inicialização do
    OpenBSD/i386?</a>
<li><a href="#LargeDrive" >14.7 - Quais são os problemas em relação a
    discos de grande capacidade no OpenBSD?</a>
<li><a href="#InstBoot"   >14.8 - Instalação dos blocos de inicialização
    ("Bootblocks") - específico para i386/amd64</a>
<li><a href="#Backup"     >14.9 - Se preparando para um desastre:
    Backup em fita e Restauração.</a>
<li><a href="#MountImage" >14.10 - Como montar imagens de disco no
    OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - Socorro! Estou recebendo erros de
    IDE DMA!</a>
<li><a href="#RAID"       >14.13 - Opções de RAID no OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Por que o <tt>df(1)</tt> me diz que
    mais de 100% do espaço em disco está utilizado?</a>
<li><a href="#OhBugger"   >14.15 - Recuperação de partições após excluir
    o disklabel</a>
<li><a href="#foreignfs"  >14.16 - Posso acessar dados em sistemas de
    arquivos diferentes do FFS?</a>
<ul>
  <li><a href="#foreignfsafter">14.16.1 - As partições não estão no meu
      disklabel! O que devo fazer?</a>
</ul>
<li><a href="#flashmem"   >14.17 - Posso usar um dispositivo de memória
    flash no OpenBSD?</a>
<li><a href="#DiskOpt"    >14.18 - Otimização do desempenho do disco</a>
<li><a href="#Async"      >14.19 - Por que nós não utilizamos montagem
    assíncrona?</a>

</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Uso do disklabel(8) do OpenBSD</h2>
<a name="disklabel.1"></a>
<h3>O que é disklabel(8)?</h3>
  
<p>
Para começar, leia a página de manual do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Os detalhes da configuração de discos no OpenBSD varia um pouco entre
as plataformas.
Para <a href="../../i386.html">i386</a>,
<a href="../../amd64.html">amd64</a>,
<a href="../../macppc.html">macppc</a>,
<a href="../../zaurus.html">zaurus</a>
e <a href="../../armish.html">armish</a>,
a configuração do disco é feita em dois estágios.
Primeiro, a fatia do OpenBSD no disco rígido é definida usando o
fdisk(8), então a fatia é subdividida em partições do OpenBSD usando
o disklabel(8).

<p>
Todas as plataformas do OpenBSD, entretanto, usam o disklabel(8)
para o gerenciamento completo das partições do OpenBSD.
As plataformas que também usam o fdisk(8) colocam todas as partições
disklabel(8) em uma única partição fdisk.

<p>
Os labels contêm certas informações sobre o seu disco, como a
geometria do disco e informações sobre os sistemas de arquivos no
disco.
Eles também contém informações sobre o próprio disco, como a velocidade
de rotação, "interleave", etc., que estão presentes por razões
históricas, e frequentemente estão incorretas.
Não se preocupe com isso.
O disklabel então é usado pelo programa de bootstrap para acessar o
disco e saber quais sistemas de arquivos estão contidos no disco.
Você pode ler informações amplas a respeito do disklabel na
página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>.

<p>
Em algumas plataformas, o disklabel ajuda a superar limitações da
arquitetura no particionamento do disco.
Por exemplo, no i386, você pode ter 4 partições primárias, mas com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
você usa uma dessas partições 'primárias' para guardar *todas* as
suas partições do OpenBSD (por exemplo, 'swap', '/', '/usr', '/var',
etc.), e você ainda terá mais 3 partições disponíveis para outros
sistemas operacionais.

<a name="disklabel.2"></a>
<h3>disklabel(8) durante a instalação do OpenBSD</h3>

<p>
Uma parte importante na instalação do OpenBSD é a criação inicial dos
labels.
Durante a instalação, você usa o disklabel(8) para criar partições
separadas.
Como parte do processo de instalação, você pode definir seus pontos
de montagem a partir do disklabel(8), mas você pode mudar mais tarde
durante a instalação ou também após a instalação.

<p>
Não existe um jeito "certo" de criar um label em um disco, mas existem
muitos jeitos errados.
Antes de tentar criar um label no seu disco, veja
<a href="faq4.html#Partitioning">esta discussão</a> sobre
particionamento e tamanho da partição.

<p>
Para um exemplo de uso do disklabel(8) durante a instalação, veja a
parte
<a href="faq4.html#Disks">Configuração dos discos</a> do
<a href="faq4.html">Guia de instalação</a>.


<p>

<a name="disklabel.3"></a>
<h3>Uso do disklabel(8) após a instalação</h3>

<p>
Após instalar, um dos usos mais comuns do disklabel(8) é para verificar
o layout do seu disco.
O seguinte comando mostra a você o disklabel atual sem modificá-lo:

<blockquote><pre>
# <b>disklabel wd0</b> &lt;-- <i>Disco que você quer ver</i>
# Inside MBR partition 3: type A6 start 63 size 29880837
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2  
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 29888820
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        614817            63  4.2BSD   2048 16384  328 # Cyl     0*-   609 
  b:        409248        614880    swap                   # Cyl   610 -  1015 
  c:      29888820             0  unused      0     0      # Cyl     0 - 29651*
  d:       6291936       1024128  4.2BSD   2048 16384  328 # Cyl  1016 -  7257 
  e:        409248       7316064  4.2BSD   2048 16384  328 # Cyl  7258 -  7663 
  f:       1024128       9822960  4.2BSD   2048 16384  328 # Cyl  9745 - 10760 
  h:       2097648       7725312  4.2BSD   2048 16384  328 # Cyl  7664 -  9744 
</pre></blockquote>

<p>
Note como esse disco tem somente uma parte do espaço em disco alocada
no momento.

Disklabel oferece dois modos diferentes para a edição, um
modo de comandos (utilizado na instalação do OpenBSD) e um editor
completo, como o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">vi(1)</a>.
Você pode achar o modo de comandos mais fácil, já que ele o guia através
de todas as etapas e fornece uma ajuda integrada, mas o modo de editor
em tela cheia possui uma utilidade definida, também.

<p>
Vamos adicionar uma partição ao sistema acima.

<p>
<blockquote>
<i>Aviso: Em qualquer momento que você manipula o seu disklabel,
você está colocando em risco todos os dados no seu disco rígido.
Tenha certeza que você possui um backup dos dados antes de editar um
disklabel existente!</i>
</blockquote>

<p>
Nós usaremos o modo de comandos integrado, que é executado usando a
opção "-E" do disklabel(8).

<blockquote><pre>
# <b>disklabel -E wd0</b>
...
> a k
offset: [10847088] 
size: [19033812] 2g
Rounding to nearest cylinder: 4194288
FS type: [4.2BSD] 
> p m
device: /dev/rwd0c
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2  
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total bytes: 14594.2M
free bytes: 7245.9M
rpm: 3600

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        300.2M          0.0M  4.2BSD   2048 16384  328 # Cyl     0*-   609 
  b:        199.8M        300.2M    swap                   # Cyl   610 -  1015 
  c:      14594.2M          0.0M  unused      0     0      # Cyl     0 - 29651*
  d:       3072.2M        500.1M  4.2BSD   2048 16384  328 # Cyl  1016 -  7257 
  e:        199.8M       3572.3M  4.2BSD   2048 16384  328 # Cyl  7258 -  7663 
  f:        500.1M       4796.4M  4.2BSD   2048 16384  328 # Cyl  9745 - 10760 
  h:       1024.2M       3772.1M  4.2BSD   2048 16384  328 # Cyl  7664 -  9744 
  k:       2048.0M       5296.4M  4.2BSD   2048 16384   16 # Cyl 10761 - 14921 
> q
Write new label?: [y] 
</pre></blockquote>

Nesse caso, o disklabel(8) calculou um bom ponto de partida para a
partição.
Em muitos casos, ele é capaz de fazer isso, mas se você tem "buracos"
no disklabel (ou seja, você excluiu uma partição, ou você apenas gosta
de tornar a sua vida complicada), você pode precisar ter que sentar com
um papel e uma caneta para calcular um offset correto.
Note que, embora o disklabel(8) faça algumas verificações de sanidade,
é possível fazer coisas muito erradas aqui.
Seja cuidadoso, entenda o significado dos valores que você está
utilizando.

<p>
Na maioria das plataformas do OpenBSD, existem dezesseis partições
disponíveis, marcadas de "a" até "p".
(alguns sistemas "especializados" podem ter somente oito).
Todo disklabel deve ter uma partição 'c', com um "fstype" de valor
"unused", que cobre todo o disco físico.
Se o seu disklabel não é assim, ele precisa ser consertado; a opção
"D" (a seguir) pode ajudar.
Nunca tente usar a partição "c" para nenhuma outra coisa além de
acessar os setores brutos do disco; não tente criar um sistema de
arquivos em "c".
No dispositivo de inicialização, "a" é reservado para a partição raiz,
e "b" é a partição de swap, mas somente o dispositivo de inicialização
faz essas distinções.
Outros dispositivos podem usar todas as quinze partições, exceto "c",
como sistemas de arquivos.

<p>
<h3>Truques e dicas sobre disklabel</h3>
<ul>
<li><b>Obtendo ajuda:</b> No modo de comandos, digitar "?" mostra uma
    lista de comandos disponíveis.
    "M" mostra a página de manual do disklabel(8).

<li><b>Valores por padrão:</b> Em alguns casos, talvez você deseje
    começar do zero e excluir todas as informações existentes do
    disklabel.
    O comando "D" retorna o disklabel de volta para o padrão, como
    se nunca tivesse existido um disklabel no disco.

<li><b>Duplicando um disklabel:</b> Em alguns casos, talvez você deseje
    duplicar o particionamento de um disco para outro, mas não
    precisamente (por exemplo, você deseja ter as mesmas partições, mas
    em diferentes tamanhos de disco).
    Use o modo '-e' (editor em tela cheia) do disklabel(8) para capturar
    as partições do disco "fonte", e cole no novo disco, remova a
    partição 'c' do disco "fonte", salve, e você já tem copiado o
    layout do disco em outro disco sem alterar os parâmetros básicos.

<li>(sparc/sparc64) <b>Não coloque a swap no começo do seu disco.</b>

<li>(i386, amd64) <b>Deixe a primeira trilha ("track") livre:</b>
    Em certas plataformas, você deve deixar a primeira trilha lógica
    inutilizada, tanto no disklabel(8) quanto no fdisk(8).
    Essa recomendação é algumas vezes dita incorretamente como "comece
    as partições no setor 63", mas isso é verdadeiro SOMENTE se aquele é
    o tamanho de uma trilha no seu hardware.
    Não assuma aquela suposição, ela nem sempre é verdadeira, e o
    disklabel informa a você sobre o que ele acredita ser o número
    de setores por trilha.
    Muitas outras plataformas esperam que as partições do OpenBSD
    comecem no setor 0.

<li><b>Dispositivos sem um disklabel:</b>
    Se um dispositivo atualmente não tem um disklabel do OpenBSD,
    mas tem um outro sistema de arquivos (por exemplo, um disco com um
    sistema de arquivos FAT32 pré-existente), o kernel do OpenBSD
    "cria" um na memória, e este pode formar a base de um disklabel
    formal do OpenBSD para ser guardado no disco.
    No entanto, se um disklabel é criado e salvo no disco, e um sistema
    de arquivos não-OpenBSD é adicionado mais tarde, o disklabel não
    será atualizado automaticamente.
    Você precisa fazer isso você mesmo se deseja que o OpenBSD possa
    acessar esse sistema de arquivos.
    Mais sobre isso
    <a href="faq14.html#foreignfsafter">abaixo</a>.

<li><b>"q" ou "x":</b>
    Por razões históricas, no modo de comandos, "q" salva as mudanças e
    termina o programa, e "x" termina sem salvar.
    Isso é o oposto do que muitas pessoas estão acostumadas em outros
    ambientes.
    O disklabel(8) não avisa antes de salvar as mudanças, e também não
    gera nenhum alerta se "x" é utilizado.

</ul>


<a name="fdisk"></a>
<h2>14.2 - Uso do fdisk(8)</h2>

Antes de começar, leia a página de manual do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.

<p>
O fdisk(8) é usado em algumas plataformas (i386, amd64, macppc, zaurus e
armish) para criar uma partição reconhecida pela ROM de inicialização
do sistema, onde as partições disklabel do OpenBSD possam ser colocadas.
Outras plataformas não precisam ou não usam o fdisk(8).
O fdisk(8) também pode ser usado para manipulações do MBR ("Master Boot
Record"), que pode afetar todos os sistemas operacionais em um
computador.
Ao contrário de alguns programas do tipo fdisk em alguns outros sistemas
operacionais, o fdisk do OpenBSD assume que você sabe o que você quer
fazer, e te ajuda a fazer o que você precisa fazer, tornando-o uma
ferramenta poderosa para se ter em mãos.
Ele também ajuda você a fazer coisas que você não deve ou não tem
intenção de fazer, então ele precisa ser usado com cuidado.

<p>
Normalmente, somente uma partição fdisk do OpenBSD é colocada em um
disco.
Aquela partição é subdividida pelo
<a href="#disklabel">disklabel</a> em partições de sistemas de arquivos
do OpenBSD.

<p>

<p>
Para ver sua tabela de partição usando fdisk, use:

<blockquote><pre>
# <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Que nos mostra uma saída similar a esta:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD     
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
</pre></blockquote>

<p>
Neste exemplo, nós estamos visualizando a saída do fdisk do primeiro
drive SCSI.
Nós podemos ver a partição OpenBSD (A6) e seu tamanho. O * indica que a
partição OpenBSD é uma partição inicializável.

<p>
No exemplo anterior nós apenas visualizamos nossa informação. E se
quisermos editar a nossa tabela de partições? Bem, para fazer isso nós
usamos o sinalizador <b>-e</b>.
Isso nos leva a um prompt de linha de comando para interagir com o
fdisk.

<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        swap            Swap two partition entries
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre></blockquote>

<p> 

<p>Esta é uma visão geral dos comandos que você pode usar quando
escolhe o sinalizador <b>-e</b>.

<ul>
<li><b>help</b> Mostra uma lista de comandos que o fdisk entende no modo
    de edição interativo.
<li><b>reinit</b> Inicializa a cópia atualmente selecionada, que está na
    memória, do bloco de inicialização.
    Essa é uma forma manual para rapidamente colocar uma partição
    OpenBSD que cobre o disco todo, atualizar o código de inicialização,
    e, resumidamente, tornar o sistema pronto para o OpenBSD (e nada
    exceto o OpenBSD).
<li><b>disk</b> Mostra a geometria atual do drive detectada pelo fdisk.
    Você tem a chance de editá-la, se desejar.
<li><b>setpid</b> Muda o identificador de partição de uma determinada
    entrada na tabela de partição. Esse comando é particularmente útil
    para reinstalar uma partição existente do OpenBSD.
<li><b>edit</b> Edita uma determinada entrada na tabela, na cópia
    guardada na memória, do bloco de inicialização atual.
    Você pode editar tanto no modo de geometria do BIOS, ou em setor,
    offsets e tamanhos.
<li><b>flag</b> Torna inicializável uma determinada entrada de partição
    na tabela. Somente uma entrada pode ser marcada como inicializável.
    Se você deseja inicializar a partir de uma partição estendida, você
    precisa marcar como inicializável a entrada de partição da
    partição estendida.
    (O OpenBSD somente pode ser inicializado a partir de partições
    primárias, mas você pode marcar qualquer partição como
    inicializável.)
<li><b>update</b> Atualiza o código de máquina, na cópia guardada na
    memória, do bloco de inicialização atualmente selecionado.
<li><b>select</b> Seleciona e carrega na memória o bloco de
    inicialização apontado pela entrada estendida na tabela de partição
    no bloco de inicialização atual.
<li><b>swap</b> Troca duas entradas MBR, então você pode reordenar a
    MBR.
<li><b>print</b> Exibe no terminal a cópia guardada na memória do
    bloco de inicialização atual e sua tabela MBR.
<li><b>write</b> Grava no disco a cópia do bloco de inicialização
    guardada na memória. Você será questionado para confirmar essa
    operação.
<li><b>exit</b> Termina o nível atual do fdisk, retornando para uma
    cópia, guardada na memória, do bloco de inicialização selecionado
    anteriormente, ou terminando o programa se não existe nenhum.
<li><b>quit</b> Termina o nível atual do fdisk, retornando para uma
    cópia, guardada na memória, do bloco de inicialização selecionado
    anteriormente, ou terminando o programa se não existe nenhum.
    Diferentemente do "exit", ele não grava o bloco modificado.
<li><b>abort</b> Termina o programa sem salvar as mudanças atuais.
</ul>

<h3>Truques e dicas sobre fdisk</h3>
<ul>
<!-- <li>On OpenBSD platforms which use fdisk, you should leave the first
track free.
This leaves room for the Master Boot Record, which is where the fdisk
partition table resides.  (not sure if this is true) -->
<li>O fdisk(8) oferece a habilidade de editar partições tanto no formato
    em setores brutos quanto em Cilindros/Cabeças/Setores.
    Ambas as opções são fornecidas por uma razão -- algumas tarefas são
    mais fáceis de uma maneira, e outras de outra maneira.
    Não fique preso ao uso de somente uma opção.
<li>Um disco totalmente vazio precisa ter o código de inicialização do
    MBR escrito no disco antes de poder inicializar.
    Você pode usar as opções "reinit" ou "update" para fazer isso.
    Se você errar ao fazer isso, você pode gravar uma tabela de
    partições válida com o fdisk, mas não pode ter um disco
    inicializável.
    Você talvez deseje atualizar o código de inicialização existente se
    você não está certo da sua origem.
<li>Se o seu sistema tem uma partição de "manutenção" ou "diagnóstico",
    é recomendado que você deixe-a no lugar ou instale-a ANTES de
    instalar o OpenBSD.
<li>Por razões históricas, "q" salva as mudanças e termina o programa,
    e "x" termina sem salvar.
    Isso é o oposto do que muitas pessoas estão acostumadas em outros
    ambientes.
    O fdisk(8) não avisa antes de salvar as mudanças, então use com
    cuidado.

</ul>


<a name="NewDisk"></a>
<h2>14.3 - Adição de discos extras no OpenBSD</h2>
<!-- XXX whoa. this section needs rework -->
<p>
Após instalar <b>CORRETAMENTE</b> o disco, você precisa usar o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>somente para i386</i>) e o
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
para configurar o disco no OpenBSD.

<p>
Para os usuários do i386, comece com o fdisk. As outras arquiteturas
podem ignorar esta etapa.
No exemplo a seguir, nós estamos adicionando um terceiro drive
SCSI no sistema.

<blockquote><pre>
# <b>fdisk -i sd2</b>
</pre></blockquote>

Isso inicializa a tabela de partições "real" do disco para uso
exclusivo pelo OpenBSD.
Em seguida, você precisa criar um disklabel para ele. Isso parecerá
confuso.

<blockquote><pre>
# <b>disklabel -e sd2</b>

<i>(a tela fica vazia e seu $EDITOR aparece)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></blockquote>

Primeiro, ignore a partição 'c', ela sempre está ali e é para que
programas como o disklabel funcionem!
O Fstype para o OpenBSD é 4.2BSD.
O número total de setores ("total sectors") é o tamanho total do disco.
Digamos que ele é um disco de 3 gigabytes; três gigabytes em termos do
fabricante do disco são 3000 megabytes. Então divida 6185088 por 3000
(use o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1)</a>).
Você obtém 2061. Então, para decidir o tamanho para as partições
a, d, e, f, g, ... simplesmente multiplique X por 2061, a fim de
conseguir X megabytes de espaço para aquela partição.
O offset para a sua primeira partição deve ser o mesmo que o valor
relatado na saída do disklabel como "sectors/track". Para nós, esse
valor é 63. O offset de cada partição seguinte deve ser uma combinação
do tamanho de cada partição e o offset de cada partição (exceto a
partição 'c', já que ela não entra nessa equação.)

<p>
Ou, se você quer apenas uma partição no disco, a fim de usar o espaço
para armazenamento Web ou um diretório pessoal ou outra coisa, apenas
pegue o tamanho total do disco e subtraia o valor de "sectors/track"
dele. 6185088-63 = 6185025. Sua partição é:

<blockquote><pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre></blockquote>

<b>Se tudo isso lhe aparenta ser inutilmente complexo, você pode
simplesmente usar disklabel -E para pegar o mesmo modo de
particionamento que você usou no seu disco de instalação!</b>
Lá você pode simplesmente usar "96M" para especificar "96 megabytes",
ou 96G para 96 gigabytes.

<p>
Muita coisa foi feita. Mas você ainda não terminou. Você agora precisa
criar um sistema de arquivos no disco usando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<blockquote><pre>
# <b>newfs sd2d </b>
</pre></blockquote>

<p>
Ou outro nome que o seu disco foi nomeado pelo esquema de numeração
de discos do OpenBSD.
(Olhe a saída do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
para ver como o seu disco foi nomeado pelo OpenBSD.)

<p>
Agora determine onde você vai montar a nova partição que você criou.
Digamos que você queira colocá-la em /u. Primeiro, crie o diretório /u.
Depois monte-a.

<blockquote><pre>
# <b>mount /dev/sd2d /u</b>
</pre></blockquote>

<p>
Enfim, adicione-a no
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>.

<blockquote><pre>
/dev/sd2d /u ffs rw 1 1
</pre></blockquote>

<p>
O que acontece se você precisa migrar um diretório existente, como o
/usr/local? Você deve montar o novo drive em /mnt e usar
<tt>cpio -pdum</tt> para copiar /usr/local para o diretório /mnt.
Edite o arquivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
para mostrar que a partição /usr/local agora está em /dev/sd2d (sua
partição recém-formatada). Exemplo:

<blockquote><pre>
<b>/dev/sd2d /usr/local ffs rw 1 1</b>
</pre></blockquote>

<p>
Reinicialize em modo usuário único com <b>boot -s</b>, mova o
/usr/local para /usr/local-backup (ou se você se sente bem, remova-o)
e crie um diretório /usr/local vazio. Então reinicialize o sistema, e,
pronto, os arquivos estão lá!


<a name="SwapFile"></a>
<a name="Swap"></a>
<h2>14.4 - Como a swap é controlada?</h2>

<h3>14.4.1 - Sobre a swap</h3>
Historicamente, todos os tipos de regras têm sido propostas para
guiar administradores na questão sobre quanta memória swap usar
em suas máquinas.
O problema, naturalmente, é que existem poucas aplicações "normais".

<p>
Um uso não óbvio da swap é ser um local onde o kernel pode fazer
uma descarga de uma cópia daquilo que estava no núcleo, em um evento de
pânico do sistema, para uma análise posterior.
Para isso funcionar, você deve ter uma partição swap (e não um arquivo
de swap) tão grande quanto a sua memória RAM.
Por padrão, o sistema salva uma cópia dessa descarga em
<tt>/var/crash</tt> na reinicialização; assim, se você deseja ser
capaz de fazer isso automaticamente, você precisa de espaço
<i>livre</i> suficiente em <tt>/var</tt>.
No entanto, você pode também carregar o sistema em modo usuário
único e usar o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8">savecore(8)</a>
para fazer a descarga em algum outro lugar.

<p>
Muitos tipos de sistemas podem ser configurados apropriadamente sem
nenhuma swap.
Por exemplo, firewalls não devem fazer swap em uma operação normal.
Máquinas com armazenamento flash geralmente não devem fazer swap.
Se o seu firewall é baseado em flash, você pode se beneficiar
(levemente) por não alocar uma partição swap, embora na maioria
dos outros casos, uma partição swap não vai causar nenhum dano;
a maioria dos discos possuem espaço mais do que suficiente para
alocar uma pequena área para a swap.

<p>
Existem todos os tipos de dicas sobre otimizar a swap (em que lugar
do disco colocá-la, discos separados, etc.), mas se você se achar
em uma situação onde otimizar a swap é um problema, você provavelmente
precisa de mais memória RAM.
Geralmente, a melhor otimização para a swap é não precisar dela.

<p>
No OpenBSD, a swap é gerenciada pelo programa
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>,
que adiciona, remove, lista e prioriza os dispositivos e arquivos de
swap.


<h3>14.4.2 - Fazendo swap em uma partição</h3>
<p>
No OpenBSD, a partição 'b' do drive de inicialização é usada por padrão
e automaticamente para a swap.
Nenhuma configuração é necessária para isso funcionar.
Se você não deseja usar swap no disco de inicialização, não defina
uma partição "b".
Se você deseja usar a swap em outras partições ou em outros discos,
você precisa definir essas partições no <tt>/etc/fstab</tt>, com linhas
parecidas com estas:

<blockquote><pre>
/dev/sd3b none swap sw 0 0
/dev/sd3d none swap sw 0 0
</pre></blockquote>


<h3>14.4.3 - Fazendo swap em um arquivo</h3>

(Nota: se você está tentando fazer swap em um arquivo porque está
recebendo erros do tipo &quot;virtual memory exhausted&quot;, você deve
tentar aumentar os limites dos processos com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>
para o csh, ou com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>
para o sh.)

<p>
Algumas vezes, seu palpite inicial sobre quanta swap você precisa prova
estar errada, e você tem que adicionar um espaço swap, ocasionalmente,
durante um momento de pressão (como em: "Geez, na velocidade em que isto
está queimando swap, estaremos em uma situação difícil em cinco
minutos").
Se você se encontrar nessa posição, adicionar um espaço swap como um
arquivo em um sistema de arquivos existente pode ser uma correção
rápida.

<p>
O arquivo não pode residir em um sistema de arquivos que possui
SoftUpdates ativado (isso está desabilitado por padrão). Para começar,
você pode ver o quanto de swap você possui atualmente, e o quanto você
está usando, com o utilitário
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>.
Você pode fazer isso usando o comando:

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></blockquote>

<p>
Isso mostra os dispositivos que estão sendo usados para swap e suas
estatísticas atuais. No exemplo acima, existe somente um dispositivo,
chamado &quot;swap_device&quot;. Essa é a área pré-definida no disco
que é usada para swap (mostrada como a partição b na visualização de
disklabels). Como você pode ver no exemplo acima, aquele dispositivo
não está tendo muito uso naquele momento, mas para os propósitos desse
documento, vamos agir como se um espaço extra de 32 MB seja necessário.

<p>
O primeiro passo para configurar um arquivo como dispositivo swap é
criar o arquivo. O melhor jeito de se fazer isso é com o utilitário
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Este é um exemplo da criação do arquivo <i>/var/swap</i>, que possui
32M de tamanho.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Após isso ser feito, nós podemos ativar o swap naquele dispositivo. Use
o seguinte comando para ativar o swap neste dispositivo

<blockquote><pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre></blockquote>

<p>
Agora nós precisamos verificar para ver se ele foi adicionado
corretamente na lista de dispositivos de swap.

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>

<p>
Agora que o arquivo está configurado e o swap está sendo feito, você
precisa adicionar uma linha no seu arquivo <i>/etc/fstab</i>, assim
aquele arquivo é configurado na próxima inicialização. Se esta linha
não é adicionada, você não terá este dispositivo swap configurado.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></blockquote>


<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>

<p>
Os "Soft Updates" são baseados em uma ideia proposta por
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg
Ganger e Yale Patt</a>, e desenvolvida para o FreeBSD por
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a>.
Os SoftUpdates impõem um ordenamento parcial nas operações no cache de
buffer, o que permite que o requerimento para gravação assíncrona de
entradas de diretório seja removido do código FFS. Assim, um aumento
de desempenho é observado na gravação no disco.

<p>
A ativação dos soft updates precisa ser feita com uma opção em tempo
de montagem. Ao montar uma partição com o utilitário
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>,
você pode especificar que deseja ativar os soft updates naquela
partição. A seguir, uma entrada de exemplo em
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i>
que possui uma partição, <i>sd0a</i>, que nós desejamos que seja montada
com soft updates.

<blockquote><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></blockquote>

<p>
Nota para usuários sparc: Não ative os soft updates em máquinas sun4 ou
sun4c. Essas arquiteturas suportam somente uma pequena quantidade de
memória do kernel e não podem usar essa funcionalidade. No entanto,
em máquinas sun4m não existe nenhum problema.

<a name="Boot386"></a>
<h2>14.6 - Como é o processo de inicialização do OpenBSD/i386?</h2>
O processo de inicialização do OpenBSD/i386 não é trivial, e entender
como ele funciona pode ser útil para descobrir algum problema quando
as coisas não funcionam.
Existem quatro partes fundamentais do processo de inicialização:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> O "Master Boot Record"
(Registro de Inicialização Mestre) é o primeiro setor
(512 bytes) físico do disco.
Ele contém a tabela de partições primárias e um pequeno programa para
carregar o PBR ("Partition Boot Record", ou Registro de Inicialização
de Partição).
Note que em alguns ambientes, o termo "MBR" é usado para se referir
somente à porção de código desse primeiro bloco no disco, em vez de
todo o primeiro bloco (incluindo a tabela de partições).
É primordial entender o significado de "inicializar o MBR" -- na
terminologia do OpenBSD, isso envolve reescrever o setor MBR
inteiro, e não apenas o código, como é feito em alguns sistemas.
Você utilizará isso raramente. Para fazer, use a opção
"-u" do comando fdisk(8) ("<tt>fdisk -u wd0</tt>").

<p>
Embora o OpenBSD inclua um MBR, você não é obrigado a usá-lo, já que
praticamente qualquer MBR pode inicializar o OpenBSD.
O MBR é manipulado pelo programa fdisk(8), que é usado na edição da
tabela de partições, e também para instalar o código MBR no disco.

<p>
O MBR do OpenBSD se anuncia com a mensagem:

<blockquote><pre>
Using drive 0, partition 3.
</pre></blockquote>

mostrando o disco e a partição de onde ele espera carregar o PBR.
Em adição ao óbvio, ele também mostra um ponto ("."), que indica que
esta máquina é capaz de usar a conversão LBA para inicializar.
Se a máquina é incapaz de usar a conversão LBA, o ponto será trocado
por um ponto-e-vírgula (";"), indicando a conversão CHS:

<blockquote><pre>
Using Drive 0, Partition 3;
</pre></blockquote>

Note que o ponto ou o ponto-e-vírgula pode ser usado como um indicador
do "novo" MBR do OpenBSD, introduzido a partir da versão 3.5.

<li><b><i>Partition Boot Record (PBR):</i></b> O "Partition Boot Record"
(Registro de Inicialização de Partição), também chamado de PBR ou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(depois do nome do arquivo contendo o código), é o primeiro setor físico
da partição OpenBSD do disco.
O PBR é o "first-stage boot loader" (carregador de inicialização de
primeiro estágio) do OpenBSD. Ele é carregado pelo código MBR, e tem a
função de carregar o "second-stage boot loader" (carregador de
inicialização de segundo estágio)
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
Como o MBR, o PBR é uma seção pequena de código e dados, com um total
de 512 bytes.
Não é o suficiente para abrigar uma aplicação com um sistema de arquivos
completo, então no lugar de um PBR localizado em <tt>/boot</tt> no
disco, a localização <tt>/boot</tt>, acessível pelo BIOS, é codificada
fisicamente no PBR, no momento da instalação.

<p>
O PBR é instalado pelo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>,
que é descrito <a href="faq14.html#InstBoot">em mais detalhes
neste documento</a>.
O PBR se anuncia com a mensagem:
<blockquote><pre>
Loading...
</pre></blockquote>
mostrando um ponto para cada bloco de sistema de arquivos que ele tenta
carregar.
Novamente, o PBR mostra se ele está usando LBA ou CHS para carregar; se
ele está usando a conversão CHS, ele mostra uma mensagem com um
ponto-e-vírgula:
<blockquote><pre>
Loading;...
</pre></blockquote>
O antigo biosboot(8) (anterior à versão 3.5) mostrava a mensagem
"<tt>reading boot...</tt>".


<li><b><i>Second Stage Boot Loader, <tt>/boot</tt>:</i></b>
<tt>/boot</tt> é carregado pelo PBR, e tem a função de acessar o sistema
de arquivos do OpenBSD pelo BIOS da máquina, a fim de localizar e
carregar o verdadeiro kernel. boot(8) também permite passar várias
opções e informações para o kernel.
<p>
boot(8) é um programa interativo. Depois de carregar, ele tenta
localizar e ler o arquivo <tt>/etc/boot.conf</tt>; se ele existir (ele
não está presente em uma instalação padrão), processa os comandos
contidos nele. A menos que seja instruído de forma diferente pelo
<tt>/etc/boot.conf</tt>, ele mostra ao usuário o prompt:

<blockquote><pre>
probing: pc0 com0 com1 apm mem[636k 190M a20=on]
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.02
boot>
</pre></blockquote>

Por padrão, o usuário tem cinco segundos para digitar um comando, mas
se nenhum é fornecido antes do tempo se esgotar, ele começa seu
comportamento padrão: carregar o kernel, <tt>bsd</tt>, da partição raiz
do primeiro disco rígido.
O "second-stage boot loader" (carregador de inicialização de segundo
estágio) detecta (e examina) o hardware do seu sistema através do BIOS
(o kernel do OpenBSD ainda não está carregado).
Acima, você pode ver algumas coisas que ele procurou e encontrou:
<ul>
<li><b>pc0</b> - o teclado e vídeo de um sistema i386 padrão.
<li><b>com0, com1</b> - Duas portas do tipo serial
<li><b>apm</b> - BIOS compatível com APM ("Advanced Power Management",
ou Gestão Avançada de Energia).
<li><b>636k 190M</b> - O total de memória convencional (menos de 1M) e
estendida (mais de 1M) encontrado
<li><b>fd0 hd0+</b> - Os discos acessíveis pelo BIOS, nesse caso, um
disquete e um disco rígido.
</ul>

O caractere '+', que aparece depois do "hd0", significa que o BIOS
indicou ao <tt>/boot</tt> que esse disco pode ser acessado por LBA.
Ao fazer uma primeira instalação, você verá algumas vezes um '*' depois
de um disco rígido -- isso significa que o disco não aparenta possuir
um label OpenBSD válido.


<li><b><i>Kernel: <tt>/bsd</tt></i>:</b> Esse é o objetivo do processo
de inicialização, ter o kernel OpenBSD carregado na memória RAM e
funcionando corretamente.
Uma vez que o kernel está carregado, o OpenBSD acessa diretamente o
hardware, sem passar pelo BIOS.

</ol>

Assim, o começo do processo de inicialização se parece com isto:

<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.02
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2008 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 4.6 (GENERIC.MP) #89: Thu Jul  9 21:32:39 MDT 2009
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC.MP
   ...
</pre></blockquote>


<h3>O que pode estar errado</h3>
<ul>
<li><b>Bad/invalid/incompatible MBR:</b>
Normalmente, um disco rígido usado tem algum código MBR, mas se o
disco é novo ou foi movido a partir de uma plataforma diferente E você
não respondeu "w" na questão "Use (W)hole disk or (E)dit the MBR?"
durante o <a href="faq4.html#InstDisks">processo de instalação</a>,
você pode estar com um disco sem um MBR válido, e, assim, não será
inicializável, mesmo que ele possua uma tabela de partições válida.

<p>
Você pode instalar o MBR do OpenBSD no seu disco rígido através do
programa fdisk. Inicialize a partir da mídia de instalação, escolha
"Shell" para receber uma linha de comandos:

<blockquote><pre>
# <b>fdisk -u wd0</b>
</pre></blockquote>

Usando o fdisk, você também pode instalar um MBR específico no disco:
<blockquote><pre>
# <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre></blockquote>

que instala o arquivo <tt>/usr/mdec/mbr</tt> como seu MBR do
sistema.
Em uma instalação padrão do OpenBSD, esse arquivo representa o MBR
padrão que também é usado pelo fdisk, mas qualquer outro MBR pode ser
especificado.

<li><b>Invalid <tt>/boot</tt> location installed in PBR:</b>
Quando o installboot(8) instala o registro de inicialização da partição,
ele grava o offset e o número do bloco do nó-i de <tt>/boot</tt> no
PBR.
Assim, remover e trocar <tt>/boot</tt> sem executar novamente o
<a href="faq14.html#InstBoot">installboot(8)</a> impede que o seu
sistema inicialize, já que o PBR carrega qualquer coisa que esteja
apontada pelo nó-i especificado nele, e que certamente não é o
gerenciador de inicialização de segundo estágio desejado!

Sendo que o <tt>/boot</tt> está sendo lido usando chamadas do BIOS,
versões antigas do PBR eram dependentes da conversão do BIOS do disco.
Se você alterou a geometria do disco (ou seja, pegou um disco de um
computador que usa conversão CHS e o moveu para um outro que usa
conversão LBR, ou mesmo mudou a opção de conversão no seu BIOS), ele
<i>aparece ao nível do BIOS</i> como estando em uma localização
diferente (um bloco numérico diferente precisa ser acessado a fim de
recuperar as mesmas informações do disco), então você precisa executar o
installboot(8) antes que o sistema possa ser reinicializado.
O novo PBR (OpenBSD 3.5 e posteriores) é muito mais
tolerante a mudanças na conversão.
</ul>

Como o PBR é muito pequeno, seu leque de mensagens de erro é limitado,
e um pouco complexo. As mensagens mais comuns são:

<ul>
<li><b>ERR R</b> - O BIOS retornou um erro ao tentar ler um bloco do
    disco.
    Normalmente, isso significa explicitamente que: seu disco não estava
    legível.
<li><b>ERR M</b> - Um número
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>
    inválido foi lido no cabeçalho do carregador de inicialização de
    segundo estágio. Isso significa que qualquer coisa que foi lida NÃO
    era o <tt>/boot</tt>, significando normalmente que o installboot(8)
    foi executado incorretamente, o arquivo /boot foi alterado, ou você
    excedeu a capacidade de seu BIOS de ler
    <a href="#LargeDrive">discos de grande capacidade</a>.

</ul>
Outras mensagens de erro são explicadas em detalhes na página de manual
do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>.

<p>
Para mais informações sobre o processo de inicialização da plataforma
i386, veja:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.html">http://www.ata-atapi.com/hiw.html</a>
    - Documentos "How it Works", de Hale Landis.
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - Quais são os problemas em relação a discos de grande
capacidade no OpenBSD?</h2>

<p>
O OpenBSD suporta os sistemas de arquivos FFS e FFS2 (também conhecidos
como UFS e UFS2).
O FFS é o sistema de arquivos histórico do OpenBSD, e a partir do
OpenBSD 4.3 foi introduzido o novo FFS2.
Antes de olhar os limites de cada sistema, nós precisamos olhar em
alguns limites de sistema mais gerais.

<p>
Naturalmente, a habilidade do sistema de arquivos e as habilidades de
um hardware em particular são duas coisas diferentes.
Um disco rígido IDE de 250G pode ter problemas em interfaces (com uma
capacidade máxima de 137G) antigas (embora, na maioria das vezes, eles
funcionam bem), alguns adaptadores SCSI muito antigos aparentam ter
problemas com drives modernos, e alguns BIOS antigos travam
ao encontrar um disco rígido com um tamanho moderno.
Você precisa respeitar as habilidades do seu hardware.

<h3>Tamanho da partição e limitações de alocação</h3>
Infelizmente, a habilidade completa do SO não está disponível até que
o SO esteja carregado na memória.
O processo de inicialização tem que utilizar (e, assim, ele é limitado
pela) a ROM de inicialização do sistema.

<p>
Por essa razão, o arquivo /bsd (o kernel) inteiro precisa estar
localizado dentro da área endereçável, no disco, pela ROM de
inicialização.
Isso significa que em alguns sistemas i386 antigos, a partição raiz
precisa estar completamente dentro dos primeiros 504M, mas os
computadores mais novos podem ter limites de 2G, 8G, 32G, 128G ou
maiores.
É importante notar que muitos computadores, relativamente novos, que
suportam drives com capacidade maior que 128G, atualmente possuem
limitações no BIOS para inicialização somente a partir de dentro dos
primeiros 128G.
Você pode usar esses sistemas com drives grandes, mas sua partição raiz
precisa estar dentro do espaço suportado pela ROM de inicialização.

<p>
Note que é possível instalar um drive de 40G em um 486 antigo,
carregar o OpenBSD a partir de uma grande partição, e achar que você
violou com sucesso a regra acima. No entanto, ela pode voltar para
assombrar você de um modo desagradável:

<ul>
  <li>Você instalou na partição / de 40G. Ele funciona, porque a base do
      SO e todos os arquivos (incluindo o /bsd) estão dentro dos
      primeiros 504M.
  <li>Você usa o sistema, e acaba com mais de 504M de arquivos nele.
  <li>Você faz uma atualização de versão, compila seu próprio kernel,
      e copia seu novo /bsd no lugar do antigo.
  <li>Você reinicializa.
  <li>Você recebe uma mensagem do tipo "ERR M" ou outros problemas na
      inicialização.
</ul>
<p>
Por que? Porque quando você copiou o novo arquivo /bsd, ele não
sobrescreveu o antigo, ele foi realocado em um novo local no disco,
provavelmente fora da faixa de 504M que o BIOS suporta. O carregador
de inicialização foi incapaz de encontrar o arquivo /bsd, e o sistema
travou.

<p>
Para fazer o OpenBSD inicializar, os carregadores de inicialização
(biosboot(8) e <tt>/boot</tt>, no caso das plataformas i386 e amd64) e o
kernel (<tt>/bsd</tt>) precisam estar dentro da faixa suportada pela ROM
de inicialização, e dentro de suas próprias habilidades.
Para manter tudo seguro, a regra é simples:

<p>
<b>a partição raiz, inteira, precisa estar dentro do espaço endereçável
pelo BIOS do computador (ou a ROM de inicialização).</b>

<p>
Alguns usuários de sistemas diferentes do i386 acham que estão imunes
a isso; no entanto, a maioria das plataformas têm alguma espécie de
limitação na ROM de inicialização em relação ao tamanho do disco.
Procurar qual é o limite, no entanto, pode ser difícil.

<p>
Essa é outra boa razão para <a href="faq4.html#Partitioning">particionar
o seu disco rígido</a> em vez de usar uma grande partição.

<h3>Tempo do fsck(8) e requerimentos de memória</h3>
Outra consideração sobre sistemas de arquivos grandes é o tempo e a
memória requerida para verificar o sistema de arquivos com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
depois de um travamento ou queda de energia.
Ninguém deve colocar um sistema de arquivos de 120G em um sistema com
32M de RAM e esperar que ele execute o fsck(8) com sucesso após um
travamento.
Uma regra simples a ser aplicada é que o sistema deve ter no mínimo 1M
de memória disponível para cada 1G de espaço em disco, para executar
a verificação do disco corretamente.
Swap pode ser usada aqui, mas com um desempenho muito ruim; tão
ruim que chega a ser inaceitável, exceto em casos especiais.

<p>
O tempo necessário para verificar o drive com o fsck pode se tornar
um problema quando o sistema de arquivos cresce, mas você somente
precisa verificar o espaço em disco que está atualmente alocado para os
sistemas de arquivos montados.
Essa é outra razão para NÃO alocar todo o seu espaço em disco apenas
porque existe espaço.
Manter sistemas de arquivos montados como RO ("Read-Only", apenas para
leitura), ou não montados, ajuda a mantê-los sem a necessidade de
serem verificados com o fsck(8) após um tropeção no cabo de alimentação.

<p>
Não se esqueça que se você tem múltiplos discos no sistema, todos eles
podem acabar sendo verificados com o fsck(8) após um travamento na mesma
hora, então eles podem precisar de mais RAM do que um disco único.

<p>
No momento em que alguém usar algo maior que um sistema de arquivos de
1TB com o tamanho padrão de fragmento e bloco, o fsck precisa de 1GB
de RAM para funcionar, que é o limite de aplicação no OpenBSD.
Fragmentos e/ou blocos grandes reduzem o número de nós-i, e
permitem sistemas de arquivos de grande capacidade.

<h3>FFS vs. FFS2</h3>
Usando FFS, o OpenBSD suporta um sistema de arquivos individual de até
2<sup>31</sup>-1, ou 2.147.483.647 setores, e como cada setor tem 512
bytes, essa é uma quantidade menor que 1T.
Com o FFS2, é possível ter sistemas de arquivos muito maiores, embora
outros limites serão alcançados antes que os limites do sistema de
arquivos sejam alcançados.

<p>
Os kernels de inicialização/instalação <i>somente suportam o FFS</i>,
e não o FFS2, então as partições principais do sistema
(<tt>/, /usr, /var, /tmp</tt>) não devem ser FFS2, ou problemas severos
de manutenção podem surgir (de qualquer forma, não deve existir uma
razão para essas partições serem grandes).
Por essa razão, partições muito grandes devem somente ser usadas como
partições que "não sejam do sistema", por exemplo, <tt>/home, /var/www/,
/bigarray</tt>, etc.

<p>
Antes de fazer atualizações de versão, você deve marcar as partições
FFS2 como "noauto", para mantê-las seguras de uma manipulação incorreta
pelo kernel de instalação (que não suporta partições FFS2).

<p>
Note que nem todos os controladores e drivers suportam discos de grande
capacidade.
Por exemplo,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ami&amp;sektion=4">ami(4)</a>
tem um limite de 2TB por volume lógico.
Muitos ainda não foram testados; por exemplo, durante a escrita deste
documento, não existem drives IDE ou SATA, disponíveis para testes,
com mais de 1TB, então nós ainda não podemos ter certeza de que tudo
funciona perfeitamente.

<a name="InstBoot"></a>
<h2>14.8 - Instalação dos blocos de inicialização ("Bootblocks") -
específico para i386/amd64</h2>

<p>
Versões modernas do OpenBSD (3.5 e posteriores) possuem um carregador
de inicialização muito robusto, que é mais indiferente às geometrias
do drive do que o antigo carregador de inicialização era; no entanto,
eles são sensíveis em relação a onde o arquivo
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>/boot</a></tt> se encontra no disco.
Se você fizer algo que mova o boot(8) para um novo lugar no disco
(na verdade, um novo nó-i), você "quebra" o seu sistema, fazendo com
que ele não inicialize corretamente.
Para corrigir o seu bloco de inicialização, coloque um disquete de
inicialização no seu drive (ou use um CD-ROM inicializável), e, no
prompt de inicialização, digite "b hd0a:/bsd" para forçá-lo a
inicializar a partir do primeiro disco rígido (e não o disquete). Sua
máquina deve carregar normalmente.
Você agora precisa reinstalar o carregador de inicialização de primeiro
estágio
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>) baseando-se na posição do arquivo <tt>/boot</tt>,
usando o programa
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386"
>installboot(8)</a>.

<p>
No nosso exemplo, nós assumimos que seu disco de inicialização é
sd0 (se for IDE, ele deve ser wd0, etc.):

<blockquote><pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre></blockquote>

<p>
Se uma nova versão dos blocos de inicialização é requerida, você
precisa compilá-los. Para fazer isso, use os comandos:

<blockquote><pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (ou qualquer outro nome de
dispositivo designado para o seu disco rígido)
</pre></blockquote>

<a name="Backup"></a>
<h2>14.9 - Se preparando para um desastre: Backup em fita e Restauração</h2>

<h3>Introdução:</h3>

<p>
Se você planeja executar o que possa ser chamado de servidor de
produção, é recomendado possuir alguma forma de backup no caso de um dos
seus discos rígidos falhar.

<p>
Esta documentação ajuda você na utilização dos utilitários padrão
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>,
fornecidos com o OpenBSD.
Um utilitário de backup mais avançado, chamado
"<a href="http://www.amanda.org">Amanda</a>",
para backup de múltiplos servidores em um drive de fita, está
disponível através de <a href="faq15.html#PkgMgmt">pacotes</a>.
Na maioria dos ambientes,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
é o suficiente. No entanto, se você tem a necessidade de fazer backup
de várias máquinas, pode ser útil procurar a documentação sobre Amanda.

<p>
Os exemplos de dispositivos, neste documento, são para uma configuração
que usa discos SCSI e fita. Em um ambiente de produção, discos SCSI
são recomendados no lugar de IDE, devido ao modo como eles controlam
blocos defeituosos.
Isso não significa que esta informação não tem uso se você está usando
um disco IDE ou outro tipo de drive de fita; os nomes dos dispositivos
são ligeiramente diferentes. Por exemplo, sd0a é wd0a em um
sistema baseado em IDE.

<h3>Fazendo backup em uma fita:</h3>

<p>
Fazer backup em uma fita requer que você saiba onde seus sistemas de
arquivos estão montados. Você pode determinar como seus sistemas de
arquivos estão montados, usando o comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
no seu terminal. Você deve obter uma saída similar a esta:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
Nesse exemplo, o sistema de arquivos raiz (/) reside fisicamente em
sd0a, que indica a partição a do disco SCSI fixo 0. O sistema de
arquivos /usr reside em sd0h, que indica a partição h do disco
SCSI fixo 0.

<p>
Um outro exemplo, de uma tabela de montagem mais avançada, pode ser:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
Nesse exemplo mais avançado, o sistema de arquivos raiz (/) reside
fisicamente em sd0a. O sistema de arquivos /var reside em sd0d, o
sistema de arquivos /home em sd0e e, finalmente, /usr em sd0h.

<p>
Para fazer o backup da sua máquina, você precisa alimentar o dump com
o nome de cada partição fixa do disco.
Veja um exemplo dos comandos necessários para fazer um backup da tabela
de montagem simples, listada acima:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Para o exemplo de tabela de montagem mais avançada, você usará algo
similar a:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Você pode olhar a página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
para aprender exatamente o que cada opção de linha de comando faz. Esta
é uma descrição breve dos parâmetros usados acima:

<ul>
<li><b>0</b> - Efetua um dump de nível 0, fazendo o backup de tudo
<li><b>a</b> - Tenta detectar automaticamente o tamanho da fita
<li><b>u</b> - Atualiza o arquivo /etc/dumpdates para indicar quando o
    backup foi feito pela última vez
<li><b>f</b> - Qual dispositivo de fita usar (neste caso, /dev/nrst0)
</ul>

<p>
E finalmente, a partição a ser feito o backup (/dev/rsd0a, etc.).

<p>
O comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
é usado no final para rebobinar o drive. Veja a página de manual do
mt para mais opções (como a eject).

<p>
Se você não tem certeza sobre o nome de dispositivo do seu drive de
fita, use o dmesg para localizá-lo. Um drive de fita, por exemplo,
aparece no dmesg como:

<blockquote><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></blockquote>

<p>
Você pode ter notado que durante o backup, o drive de fita é acessado
com o nome de dispositivo "<tt>nrst0</tt>" em vez do nome
"<tt>st0</tt>", que é visto no dmesg.
Quando você acessa <tt>st0</tt> como <tt>nrst0</tt>, você está acessando
o mesmo drive de fita físico, mas está dizendo ao drive para não
rebobinar no final da tarefa e para acessar o dispositivo no modo "raw".
Para fazer backup de múltiplos sistemas de arquivos em uma única fita,
tenha certeza de usar o dispositivo de não-rebobinagem; se você usa o
dispositivo de rebobinagem (<tt>rst0</tt>) para fazer backup de
múltiplos sistemas de arquivos, você acabará sobrescrevendo o sistema
de arquivos anterior com o próximo dump que escrever na fita.
Você pode achar uma descrição mais elaborada sobre os vários
dispositivos de drive de fita na página de manual do dump.

<p>
Se você quer escrever um pequeno script chamado "backup", ele se
parecerá com isto:

<blockquote><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre></blockquote>

<p>
Se backups noturnos planejados são necessários, o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
pode ser usado para executar automaticamente o seu script de backup.

<p>
É útil documentar também (num pedaço de papel) o tamanho que cada
sistema de arquivos precisa ter. Você pode usar o "<tt>df -h</tt>" para
determinar o quanto de espaço cada partição está usando atualmente.
Isso será útil quando o seu drive falhar e você precisar recriar sua
tabela de partições em um novo drive.

<p>
Restaurar seus dados ajuda também a reduzir a fragmentação. Para
assegurar que você pegou todos os arquivos, o melhor jeito de fazer
backup é reinicializar o sistema em modo usuário único. Sistemas
de arquivos não precisam ser montados para o backup. Não se esqueça
de montar a partição raiz (/) em modo r/w (leitura/escrita) depois de
reinicializar em modo usuário único, ou seu dump falha ao tentar
escrever as "dumpdates". Ao inicializar, digite "<tt>bsd -s</tt>" no
prompt boot&gt; para carregar o sistema em modo usuário único.

<h3>Visualizando o conteúdo de um backup em fita:</h3>


<p>
Após você ter feito o backup dos seus sistemas de arquivos pela primeira
vez, pode ser uma boa ideia testar sua fita e ter certeza que os dados
estão presentes.

<p>
Você pode usar o exemplo seguinte para ver o catálogo de arquivos
presentes em uma fita:

<blockquote><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></blockquote>

<p>
Isso mostra uma lista dos arquivos presentes na primeira partição da
fita. Seguindo os exemplos acima, 1 é o seu sistema de arquivos raiz
(/).

<p>
Para ver o que está na segunda partição da fita e enviar a saída para
um arquivo, você usará um comando similar a este:

<blockquote><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></blockquote>

<p>
Se você possui uma tabela de montagem igual à tabela simples, 2 é
/usr; se a sua tabela de montagem é mais avançada, 2 é /var ou outro
sistema de arquivos. O número de sequência corresponde à ordem em
que os sistemas de arquivos são escritos na fita.


<h3>Restaurando a partir da fita:</h3>

<p>
O cenário do exemplo listado abaixo será útil se o seu drive fixo falhou
completamente. Em um evento onde você quer restaurar a partir de um
único arquivo da fita, leia a página de manual do restore e preste
atenção nas instruções do modo interativo.

<p>
Se você se preparou corretamente, trocar um disco e restaurar seus dados
a partir da fita pode ser um processo rápido. O disquete padrão do
OpenBSD para instalação/inicialização contém o utilitário restore, e
também os binários necessários para particionar e tornar o seu novo
drive inicializável. Na maioria dos casos, esse disquete e o dump
mais recente em uma fita é tudo o que você precisa para colocar sua
máquina em produção novamente.

<p>
Após trocar fisicamente o drive de disco defeituoso, os passos básicos
para restaurar seus dados são os seguintes:

<ul>
<li>
<p>
Inicialize usando o disquete de instalação/inicialização do OpenBSD.
No menu de seleção, escolha Shell. Insira a fita do seu backup mais
recente, apenas para leitura, no drive.
<br>
<li>
<p>
Usando o comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>,
crie uma partição primária do OpenBSD neste novo drive instalado.
Exemplo:

<blockquote><pre>
# <b>fdisk -e sd0</b>
</pre></blockquote>

<p>
Veja a <a href="#fdisk">FAQ do fdisk</a> para mais informações.

<li>
<p>
Usando o comando disklabel, crie novamente a sua tabela de partições
do OpenBSD dentro da partição primária do OpenBSD que você criou usando
o fdisk.
Exemplo:

<blockquote><pre>
# <b>disklabel -E sd0</b>
</pre></blockquote>

<p>
(Não se esqueça da partição swap, veja a <a href="#disklabel">FAQ do
disklabel</a> para mais informações)

<li>
<p>
Use o comando newfs para criar um sistema de arquivos limpo em cada
partição que você criou no passo acima. Exemplo:

<blockquote><pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre></blockquote>

<li>
<p>
Monte seu novo sistema de arquivos raiz (/) em /mnt. Exemplo:

<blockquote><pre>
# <b>mount /dev/sd0a /mnt</b>
</pre></blockquote>

<li>
<p>
Entre no sistema de arquivos raiz montado e comece o processo de
restauração.
Exemplo:

<blockquote><pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre></blockquote>

<li>
<p>
Você quer que este disco seja inicializável, então use o seguinte
comando para gravar um novo MBR no seu drive. Exemplo:

<blockquote><pre>
# <b>fdisk -i sd0</b>
</pre></blockquote>

<li>
<p>
Em adição à gravação de um novo MBR no drive, você precisa instalar
blocos de inicialização para inicializar a partir dele. A seguir,
um exemplo rápido:

<blockquote><pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></blockquote>

<li>
<p>
Seu novo sistema de arquivos raiz, no novo disco, deve estar
suficientemente pronto, assim você pode inicializá-lo e continuar a
restauração do resto dos seus sistemas de arquivos.
Já que seu sistema operacional não está completo ainda, tenha certeza
de inicializar em modo usuário único. Na linha de comandos, digite os
seguintes comandos para desmontar e desligar o sistema:

<blockquote><pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre></blockquote>

<li>
<p>
Remova o disquete de instalação/inicialização do drive e reinicialize
o seu sistema. No prompt boot&gt; do OpenBSD, digite o seguinte comando:

<blockquote><pre>
boot&gt; <b>bsd -s</b>
</pre></blockquote>

<p>
O comando "bsd -s" faz com que o kernel seja carregado em modo
usuário único, que somente necessita do sistema de arquivos raiz (/).

<li>
<p>
Assumindo que você executou corretamente os passos acima e nada
de errado aconteceu, você deve ver um prompt perguntando por um caminho
para um shell ou pedindo para pressionar "enter". Pressione "enter" para
usar o sh. Agora você deve remontar a raiz em modo r/w (leitura e
escrita) em vez de apenas para leitura. Digite o seguinte comando:

<blockquote><pre>
# <b>mount -u -w /</b>
</pre></blockquote>

<li>
<p>
Após remontar em modo r/w, você pode continuar a restauração dos seus
outros sistemas de arquivos. Exemplo:

<blockquote><pre>
<i>(tabela de montagem simples)</i>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

<i>(tabela de montagem avançada)</i>
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></blockquote>

<p>
Você pode usar "<b>restore rvsf</b>", em vez de apenas rsf, para
visualizar os nomes dos objetos conforme eles são extraídos do backup.

<li>
<p>
Finalmente, após a restauração de todos os seus outros sistemas de
arquivos no disco, reinicialize em modo multiusuário. Se tudo ocorreu
como planejado, seu sistema estará de volta ao estado em que ele estava
durante o backup mais recente, e pronto para ser usado novamente.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Como montar imagens de disco no OpenBSD</h2>

<p>
Para montar uma imagem de disco (imagens ISO, imagens de disco criadas
com o dd, etc.) no OpenBSD, você precisa configurar um dispositivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>.
Por exemplo, se você possui uma imagem ISO localizada em
<i>/tmp/ISO.image</i>, você deve usar os seguintes comandos para montar
a imagem.

<blockquote><pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre></blockquote>

<p>
Note que essa é uma imagem ISO-9660, usada por CDs e DVDs, e você
precisa especificar o tipo <i>cd9660</i> ao montá-la. Isso precisa
ser feito, independente do tipo; por exemplo, você precisa usar o tipo
<i>ext2fs</i> ao montar imagens de disco do Linux.

<p>
Para desmontar a imagem, use os seguintes comandos.

<blockquote><pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre></blockquote>

<p>
Para mais informação, leia a página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>.


<a name="pciideErr"></a>
<h2>14.11 - Socorro! Estou recebendo erros de IDE DMA!</h2>

<p>
Transferências IDE DMA, suportadas por
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>,
não são confiáveis em muitas combinações de hardware. Até recentemente,
a maioria dos sistemas operacionais "principais" que diziam suportar
transferências DMA com drives IDE, não eram fornecidos com aquele
recurso ativado por padrão, devido a hardware não confiável.
Agora, muitas dessas máquinas estão sendo usadas com o OpenBSD.

<p>
O OpenBSD é agressivo e tenta usar o Modo DMA mais alto que ele pode
configurar. Isso causa a corrupção na transferência de dados em
algumas configurações por causa de chipsets problemáticos da placa-mãe,
drives problemáticos e/ou problemas nos cabos. Felizmente,
modos Ultra-DMA protegem as transferências de dados com um CRC para
detectar a corrupção. Quando o CRC de Ultra-DMA falha, o OpenBSD
mostra uma mensagem de erro e tenta efetuar a operação novamente.

<blockquote><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></blockquote>

<p>
Após falhar algumas vezes, o OpenBSD faz o "downgrade" para um modo
Ultra-DMA mais lento (que se espera ser mais confiável). Se o modo
Ultra-DMA 0 é atingido, será feito o downgrade para o modo PIO.

<p>
Erros UDMA são frequentemente causados por cabos danificados ou de
baixa qualidade.
Problema com cabos normalmente deve ser o primeiro suspeito se você
está recebendo muitos erros DMA ou tendo um desempenho de DMA baixo.
Também é uma péssima ideia colocar o CD-ROM junto com o disco rígido
no mesmo canal.

<p>
Se trocar os cabos não resolver o problema e o OpenBSD não fizer
corretamente o downgrade, ou o processo causa o travamento da sua
máquina, ou causa mensagens excessivas no console e nos registros, você
talvez queira forçar o sistema para usar um nível baixo de DMA ou UDMA
por padrão. Isso pode ser feito usando o
<a href="faq5.html#BootConfig">UKC</a> ou
<a href="faq5.html#config">config(8)</a> para mudar as opções do
dispositivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>.


<a name="RAID"></a>
<h2>14.13 - Opções de RAID no OpenBSD</h2>
Um conjunto redundante de discos independentes (RAID - "Redundant Array
of Inexpensive Disks") nos dá uma oportunidade de usar múltiplos drives
para alcançar um melhor desempenho, capacidade e/ou redundância que
um drive sozinho não é capaz de fornecer. Embora uma descrição das
vantagens ou dos riscos do RAID não seja o propósito deste artigo, é
importante notar os seguintes pontos:

<ul>
<li>RAID não é um sistema de backup.
<li>Sozinho, um RAID não elimina o tempo de indisponibilidade.
</ul>

Se essas são informações novas para você, este não é um bom ponto de
partida para sua exploração do RAID.

<h3>Opções de Software</h3>
O OpenBSD suporta o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">softraid(4)</a>,
um framework que suporta muitos tipos de transformações de E/S,
incluindo as disciplinas de RAID e encriptação.
Softraid(4) é gerenciado através do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8">bioctl(8)</a>.

<p>
O OpenBSD também inclui o RAIDframe
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
requer um kernel personalizado) e o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
como meios históricos de implementação de RAID, mas no momento o OpenBSD
não sugere nenhum dos dois como uma solução RAID em novas instalações
ou reinstalações.

<h3>Opções de Hardware</h3>
<p>
Muitas <a href="../../pt/plat.html">plataformas</a> do OpenBSD incluem
o suporte para vários produtos de hardware RAID. As opções variam por
plataforma; veja a página de suporte de hardware apropriada (listada
<a href="../../pt/plat.html">aqui</a>).

<p>
Note que muitos controladores RAID suportados podem ser gerenciados
através do driver
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bio&amp;sektion=4">bio(4)</a>
e do aplicativo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8">bioctl(8)</a>.
Isso permite a monitoração e o controle do sistema RAID de uma maneira
padronizada a partir de dentro do OpenBSD.

<p>
Outra opção disponível para muitas plataformas é um dos muitos produtos
que fazem com que múltiplos drives atuem como um único drive IDE ou
SCSI, e são então conectados em um adaptador IDE ou SCSI padrão. Esses
dispositivos podem funcionar praticamente em qualquer plataforma de
hardware que suporte tanto SCSI quanto IDE.

<p>
Alguns fabricantes desses produtos:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Nota: esses são apenas os produtos que alguns usuários do OpenBSD
relataram usar -- não é nenhuma propaganda, nem uma lista exaustiva.)


<h3>Opções não válidas</h3>
<p>
Uma pergunta feita com frequência nas
<a href="../../mail.html">listas de discussão</a> é
"Os controladores RAID IDE ou SATA de baixo custo (como aqueles que usam
chips Highpoint, Promise ou Adaptec HostRAID) são suportados?".
A resposta é "Não". Essas placas e chips não são controladores de
hardware RAID de verdade, são dispositivos de inicialização de
RAID de software ajudados pelo BIOS. Como o OpenBSD já suporta RAID
de software de uma maneira independente de hardware, não há muito desejo
entre os desenvolvedores de implementar o suporte para essas placas.

<p>
Praticamente todos os controladores SATA ou IDE "RAID" onboard são
desse estilo baseado em software, e funcionam bem como controlador
SATA ou IDE usando o driver IDE padrão
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>),
mas não funcionam como um sistema RAID de hardware no OpenBSD.

<a name="NegSpace"></a>
<h2>14.14 - Por que o <tt>df(1)</tt> me diz que mais de 100% do espaço
em disco está utilizado?</h2>
As pessoas às vezes ficam surpresas ao descobrir que possuem um
espaço em disco de valor <i>negativo</i>, ou mais que 100% de um sistema
de arquivos em uso, como mostrado pelo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>.

<p>
Quando um sistema de arquivos é criado com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>,
uma parte do espaço disponível é guardada e fica inacessível pelos
usuários.
Isso fornece uma margem de erro quando o disco é acidentalmente
preenchido, e ajuda a manter mínima a fragmentação.
O padrão para isso é 5% da capacidade do disco, então se o usuário
root foi preenchendo imprudentemente o disco, você pode ver até
105% da capacidade disponível em uso.

<p>
Se o valor de 5% não é apropriado, você pode mudá-lo com o comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>.

<a name="OhBugger"></a>
<h2>14.15 - Recuperação de partições após excluir o disklabel</h2>

<p>
Se você tem uma tabela de partições danificada, existem várias formas de
tentar recuperá-la.

<p>
Primeiramente, pânico.
Você normalmente faz isso, e você deve saber que isso passa.
Apenas não faça nada de estúpido.
Entre em pânico longe da sua máquina.
Então relaxe, e veja se os passos a seguir podem ajudá-lo.

<p>
Uma cópia do disklabel de cada disco é salva em
<tt>/var/backups</tt> como parte da manutenção diária do sistema.
Assumindo que você ainda tem a partição var, você pode simplesmente
ler a saída e colocá-la de volta no disklabel.

<p>
Caso você não veja mais aquela partição, existem duas opções.
Corrigir uma parte suficiente do disco para vê-la, ou corrigir uma
parte suficiente do disco para recuperar os seus dados.
Dependendo do que aconteceu, uma alternativa ou outra pode ser
preferível (com discos ruins, você quer os dados em primeiro lugar;
com dedos preguiçosos, você pode querer apenas o label).

<p>
A primeira ferramenta que você precisa é o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(note o sublinhado, ela não se chama "scanffs").
scan_ffs(8) pesquisa o disco, tenta encontrar partições e também
mostra as informações encontradas sobre elas.
Você pode usar essas informações para recriar o disklabel.
Se você quer apenas a <tt>/var</tt>, você pode recriar a partição
<tt>/var</tt> e então recuperar o label salvo e adicionar o resto a
partir de lá.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
atualiza a visão do kernel sobre o disklabel, e então tenta escrever
o label no disco.
Dessa forma, mesmo se a área do disco contendo o disklabel está
ilegível, você será capaz de montá-la com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
antes da próxima reinicialização.


<a name="foreignfs"></a>
<h2>14.16 - Posso acessar dados em sistemas de arquivos diferentes do
FFS?</h2>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Sim. Os sistemas de arquivos suportados são: ext2 (Linux), ISO9660 e UDF
(CD-ROM, DVD), FAT (MS-DOS e Windows), NFS, NTFS (Windows), AmigaDOS.
Alguns possuem um suporte limitado; por exemplo, acesso apenas
para leitura. Note que o sistema de arquivos UFS2 do FreeBSD não é
suportado.

<p>
Nós vamos fazer uma demonstração geral sobre como usar um desses
sistemas de arquivos no OpenBSD. Para ser possível o uso de um sistema
de arquivos, ele precisa estar montado.
Para mais detalhes e opções de montagem, consulte a página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
e a página de manual referente ao comando de montagem do sistema de
arquivos que você montará; por exemplo, mount_msdos, mount_ext2fs, ...

<p>
Para começar, você precisa saber em qual dispositivo o seu sistema de
arquivos está localizado. Este pode ser o seu primeiro disco rígido,
<tt>wd0</tt> ou <tt>sd0</tt>, mas ele pode ser menos óbvio.
Todos os dispositivos reconhecidos e configurados no seu sistema são
mencionados na saída do comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>:
um nome de dispositivo seguido de uma descrição de uma linha.
Por exemplo, meu primeiro drive de CD-ROM é reconhecido como:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Para uma lista curta de discos disponíveis, você pode usar o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.
O comando

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

mostra todos os discos conhecidos atualmente no seu sistema; por
exemplo:

<blockquote><pre>
hw.disknames=cd0,cd1,wd0,fd0,cd2
</pre></blockquote>

<p>
Neste ponto, é hora de procurar quais partições estão no dispositivo e
em qual partição o sistema de arquivos desejado reside.
Nós examinamos o dispositivo usando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
O disklabel contém uma lista de partições, com um número máximo de 16.
A partição c sempre indica o dispositivo inteiro.
As partições a-b e d-p são usadas pelo OpenBSD.
As partições i-p podem ser alocadas automaticamente para sistemas de
arquivos de outros sistemas operacionais.
Nesse caso, analisarei o disklabel do meu disco rígido, que contém
alguns sistemas de arquivos diferentes.

<p>
<b>NOTA: O OpenBSD foi instalado neste sistema depois dos outros
sistemas operacionais</b>, e durante a instalação um disklabel
contendo as partições nativas e os sistemas de arquivos externos foi
instalado no disco.
No entanto, se você instalar sistemas de arquivos externos depois que
o disklabel do OpenBSD já foi instalado no disco, você precisa
adicioná-los ou modificá-los manualmente. Isso será explicado
<a href="#foreignfsafter">nesta subseção</a>.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A       
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581 
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206 
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544 
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367 
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773 
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176 
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>

<p>
Como pode ser visto na saída acima, as partições OpenBSD são listadas
primeiro. Em seguida estão várias partições ext2 e uma partição MSDOS,
e também algumas partições desconhecidas ('unknown'). Em sistemas i386
e amd64, você pode encontrar mais informações sobre isso usando o
utilitário
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.
Para o leitor curioso: a partição i é uma partição de manutenção criada
pelo fabricante, a partição j é uma partição NTFS, e a partição l é uma
partição swap do Linux.

<p>
Após ter determinado que partição você quer usar, você pode ir para o
passo final: montar o sistema de arquivos contido nela.
A maioria dos sistemas de arquivos são suportados no kernel GENERIC:
dê uma olhada no arquivo de configuração do kernel, localizado no
diretório <tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt>.
No entanto, alguns não são; por exemplo, o suporte ao NTFS é
experimental e, portanto, não está incluído no GENERIC.
Se você quer usar um dos sistemas de arquivos não suportados no GENERIC,
você precisa
<a href="faq5.html#Options">compilar um kernel personalizado</a>.

<p>
Uma vez com as informações necessárias nas mãos, é hora de montar o
sistema de arquivos.
Vamos assumir que o diretório <tt>/mnt/otherfs</tt> existe, e que será
usado como um ponto de montagem para o sistema de arquivos desejado.
Neste exemplo, montaremos o sistema de arquivos ext2 da partição m:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

<p>
Se você planeja usar o sistema de arquivos regularmente, você pode
ganhar tempo inserindo uma linha no <tt>/etc/fstab</tt>; por exemplo,
algo como:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Note o valor 0 no quinto e sexto campo.
Isso significa que não queremos que o sistema de arquivos seja salvo
(com o dump), nem verificado com o fsck.
Geralmente, essas são coisas que você quer que sejam controladas pelo
sistema operacional nativo, associado ao sistema de arquivos.

<a name="foreignfsafter"></a>
<h3>14.16.1 - As partições não estão no meu disklabel! O que devo fazer?</h3>

Se você instalou sistemas de arquivos externos no seu sistema (o
resultado da adição de um novo sistema operacional, na maioria das
vezes) depois de ter instalado o OpenBSD, um disklabel já estará
presente, e ele não será atualizado automaticamente para conter as novas
partições dos sistemas de arquivos externos.
Se você deseja usá-las, você precisa adicionar ou modificar manualmente
essas partições usando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Como um exemplo, eu modifiquei uma das minhas partições ext2: usando o
programa fdisk do Linux, eu reduzi o tamanho da partição 'o' (veja a
saída do disklabel acima) para 1G.
Somos capazes de reconhecê-la facilmente pela sua posição de início
(offset: 64372518) e pelo seu tamanho (13783707).
Note que esses valores são números de setores, e que usar número de
setores (e não megabytes ou outra forma de medida qualquer) é o modo
mais exato e seguro de ler essa informação.

<p>
Antes da mudança, a partição se parecia com isto (usando o utilitário
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
e deixando somente a parte que nos interessa):

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Como você pode ver, a posição de início e o tamanho são exatamente
aqueles mostrados anteriormente pelo disklabel(8).
(Não se confunda com o valor indicado por "Offset": ele está se
referindo à posição de início da partição extendida onde a partição ext2
está contida.)

<p>
Após ter alterado o tamanho da partição usando o Linux, ela se parece
com isto:

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Agora isso precisa ser alterado usando o disklabel(8).
Por exemplo, você pode digitar <tt>disklabel -e wd0</tt>, que chama
um editor especificado pela variável de ambiente EDITOR (o padrão é o
vi).
Dentro do editor, mude a última linha do disklabel para combinar com o
novo tamanho:

<blockquote><pre>
  o:       2104452      64372518  ext2fs
</pre></blockquote>

Salve o disklabel no disco após ter terminado.
Agora que o disklabel está atualizado novamente, você deve ser capaz de
montar as suas novas partições como descrito acima.

<p>
Você pode seguir um procedimento bastante similar para adicionar novas
partições.


<a name="flashmem"></a>
<h2>14.17 - Posso usar um dispositivo de memória flash no OpenBSD?</h2>
<h3>14.17.1 - Memória flash como um dispositivo portátil de
armazenamento</h3>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Normalmente, o dispositivo de memória deve ser reconhecido após plugá-lo
em uma porta da sua máquina.
Logo após inserir o dispositivo, algumas mensagens são escritas no
console pelo kernel.
Por exemplo, quando eu plugo meu dispositivo USB de memória flash, eu
vejo em meu console:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Essas linhas indicam que o driver
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>
("USB mass storage", ou dispositivo de massa USB) foi ligado ao
dispositivo de memória, e que ele está usando o sistema SCSI.
As últimas duas linhas são as mais importantes: elas estão dizendo qual
nó de dispositivo está ligado ao dispositivo de memória, e qual é o
tamanho total de espaço de armazenamento.
Se você não viu essas linhas, você pode vê-las novamente com o comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>.
A geometria CHS mostrada é fictícia, já que a memória flash está sendo
tratada como qualquer outro disco SCSI comum.

<p>
Vamos discutir dois cenários a seguir.

<h4>O dispositivo está novo/vazio e você quer usá-lo somente com o
OpenBSD</h4>

Você precisa criar um disklabel no dispositivo, e criar ao menos uma
partição.
Leia <a href="#disklabel">Uso do disklabel do OpenBSD</a> e a página
de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
para obter detalhes sobre isso.

<p>
Neste exemplo, eu criei apenas uma partição <i>a</i>, onde eu colocarei
um sistema de arquivos FFS:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Vamos agora montar em <tt>/mnt/flashmem</tt> o sistema de arquivos que
criamos na partição <i>a</i>.
Crie primeiro o ponto de montagem, se ele não existe.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h4>Você recebeu o dispositivo de memória de alguém que você quer trocar
dados</h4>

<p>
Existe uma chance considerável de que a outra pessoa não use o
OpenBSD, então pode existir um sistema de arquivos externo no
dispositivo de memória.
Dessa forma, primeiro nós vamos determinar quais partições estão no
dispositivo, como descrito em
<a href="#foreignfs">FAQ 14 - Sistemas de Arquivos Externos</a>.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122 
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Como pode ser visto na saída do disklabel, existe somente uma partição
<i>i</i>, contendo um sistema de arquivos FAT, criado em uma máquina
Windows.
Como de hábito, a partição <i>c</i> indica o dispositivo inteiro.

<p>
Agora vamos montar o sistema de arquivos da partição <i>i</i> em
<tt>/mnt/flashmem</tt>.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Agora você pode usá-lo como qualquer outro disco.

<p>
<b>AVISO:</b>
Você deve <b>sempre desmontar</b> o sistema de arquivos <b>antes de
desplugar</b> o dispositivo de memória.
Se você não o faz, o sistema de arquivos pode ser deixado em um estado
inconsistente, que pode resultar em corrupção de dados.

<p>
Após remover o dispositivo de memória da sua máquina, você novamente
vai ver o kernel escrevendo mensagens sobre isso no console:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<a name="flashmemBoot"></a>
<h3>14.17.2 - Memória flash como armazenamento inicializável</h3>
<!-- This article written by Nick Holland
nick@openbsd.org, and released under the BSD license -->
É possível usar memória flash como disco inicializável de várias formas
no OpenBSD.
Isso pode ser feito tanto com dispositivos USB (assumindo que seu
computador pode inicializar a partir de um dispositivo flash USB; nem
todos podem), ou com um dispositivo não-USB (ou seja, CF) com um
adaptador IDE ou SATA
(dispositivos não-USB ligados com um adaptador USB são tratados como
dispositivos USB). Em alguns casos, você pode usar um dispositivo de
ambos os modos (carregar a mídia em um adaptador USB, mas rodá-lo em
um adaptador IDE).

<p>
Um dispositivo flash conectado a uma porta USB será mostrado como um
dispositivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4">sd(4)</a>
do tipo SCSI.
Quando conectado a um adaptador IDE, ele será mostrado como um
dispositivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>.

<p>
No caso da mídia flash em um adaptador IDE, ele pode ser inicializado
a partir de qualquer sistema que possa inicializar a partir de um
disco rígido IDE.
Em todo caso, o sistema vê a mídia flash como um disco IDE.
Simplesmente configure o hardware apropriadamente, e então instale o
OpenBSD no disco flash.

<p>
No caso de inicializar a partir de um dispositivo USB, seu sistema
precisa ser capaz de inicializar a partir de um dispositivo USB sem
ser distraído pelos outros dispositivos no seu sistema.
Note que se a sua intenção é fazer um ambiente de inicialização portátil
em um dispositivo USB, o dispositivo USB será mostrado como um disco
SCSI, normalmente sd0.
No entanto, se você pluga esse dispositivo em um sistema que já possui
alguns discos do tipo SCSI, ele vai acabar com um identificador
diferente, e isso pode dificultar o uso do dispositivo flash de
sistema para sistema, já que você terá que atualizar o
<tt>/etc/fstab</tt>.

<p>
Algumas notas:
<ul>
<li><b>Velocidade:</b> De maneira geral, os dispositivos flash são muito
    mais lentos que discos rígidos, especialmente quando algo é escrito.
    Usar <a href="#SoftUpdates">soft updates</a> ajuda
    consideravelmente, como também usar a opção de montagem "noatime".

<li><b>"Fadiga de escrita":</b>
    Muita coisa já foi escrita sobre o número finito de vezes que uma
    célula flash individual pode ser reescrita antes de falhar.
    Falando de maneira prática, existem vários meios de um dispositivo
    flash falhar, fadiga de escrita é apenas um deles.
    Dispositivos flash modernos verificam a escrita, e em um evento
    de falha remapeiam automaticamente os setores falhos com um dos
    muitos setores reserva.
    A maioria dos usuários da maioria dos dispositivos flash não
    precisa se preocupar com "fadiga de escrita".
    Você provavelmente vai experimentar mais momentos fora do ar devido
    à falhas de "truques" espertos feitos para evitar a escrita no
    drive flash do que por apenas usar os drives como mídia em
    leitura/escrita.

<li><b>Confiança:</b>
    O fato de que uma mídia flash não tem partes móveis faz com que
    muitas pessoas assumam a mídia flash como mais confiável que os
    discos rígidos.
    Provavelmente, não é prudente assumir que mudando para flash
    significa que você não precisa se preocupar com perdas de dados
    ou falhas de drive.
    Pessoas relatam uma considerável variação na qualidade da mídia
    flash; e é melhor considerar o armazenamento flash como uma
    alternativa silenciosa e de baixo consumo em relação ao disco, em
    vez de uma mídia de armazenamento livre de falhas.

<li><b>Criação de um drive flash USB inicializável:</b>
    Enquanto um dispositivo USB somente pode ser inicializado em uma
    máquina que pode inicializar a partir de drives USB, ele pode ser
    criado em qualquer máquina com hardware USB suportado.
    Você estará, naturalmente, impossibilitado de testar o seu trabalho
    até conseguir um sistema capaz de inicializar a partir da USB.

<li><b>Indo de IDE para interfaces USB:</b>
    Como a mídia pode ser lida e escrita a partir de adaptadores USB
    e IDE, você pode criar a mídia para a inicialização em um adaptador
    IDE, mas mantê-la em um adaptador USB em uma máquina diferente
    (ou o inverso).

<li><b>Misturar o OpenBSD e outras partições em um dispositivo:</b>
    O OpenBSD trata o disco flash como qualquer outro disco, então você
    pode usar o
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8">fdisk(8)</a>
    para particionar um dispositivo flash, como você faria com qualquer
    disco rígido.
    Você pode ter sistemas de arquivos OpenBSD em uma partição, e usar
    outra partição para outro sistema de arquivos; como o FAT32, por
    exemplo.
    No entanto, nem todos os SOs tratam os dispositivos USB como
    "iguais".
    O Windows, no mínimo, não tenta usar ou criar uma partição que
    não comece no começo do dispositivo, nem as ferramentas de
    particionamento permitem que você particione o disco, embora
    ele respeite as partições existentes.
    Então, se você deseja criar um drive flash USB que é inicializável
    com o OpenBSD, mas que também funcione como um dispositivo que
    suporta FAT32 em outros SOs, você vai precisar fazer algo assim:

    <ol>
    <li>Particionar a mídia com o fdisk do OpenBSD, criando uma partição
        do tipo desejado, no começo do disco, para o Windows usar, e
        uma partição OpenBSD no final do disco.
    <li>Instale o OpenBSD, como de hábito, na sua partição fdisk
        OpenBSD, e não se esqueça de marcar a partição OpenBSD como
        "Active" (Ativa) para inicialização.
    <li>Formate a outra partição.
        Isso pode ser (e talvez deva ser) feito no SO "alvo" (Windows,
        neste caso).
    </ol>

Note que se o segundo tipo de partição é escolhido apropriadamente, é
possível que o OpenBSD acesse ambas as partições no dispositivo.
Então, um usuário Windows pode encher a partição FAT32 com arquivos MP3,
que podem ser tocados ao inicializar a partir da partição OpenBSD.

</ul>


<p>
<a name= "DiskOpt"></a>
<h2>14.18 - Otimização do desempenho do disco</h2>

<p>
O desempenho do disco é um fator significante na velocidade geral do
seu computador.
Ele se torna mais importante quando o seu computador está hospedando
um ambiente multiusuário (usuários de todas as espécies, desde
aqueles que iniciam sessões interativas até aqueles que veem você como
um servidor de arquivos ou um servidor Web).
Armanezamento de dados precisa de atenção constante, especialmente
quando suas partições ficam cheias ou quando seus discos falham.
O OpenBSD possui algumas opções para aumentar a velocidade das suas
operações em disco e para fornecer uma tolerância a faltas.

<p>
<ul>
<li><a href="#Optsoftu">Soft Updates</a>
<li><a href="#Optmaxvnodes">Tamanho do cache namei()</a>
</ul>

<p>
<p>
<a name="Optsoftu"></a>
<h3>14.18.1 - Soft updates</h3>

Uma importante ferramenta que pode ser utilizada para aumentar a
velocidade do seu sistema é o softupdates.
Uma das operações mais lentas no sistema de arquivos tradicional do BSD
é a atualização de metainfo (que acontece, entre outras situações,
quando você cria ou exclui arquivos e diretórios).
Softupdates tenta atualizar a metainfo na RAM, em vez de escrever no
disco rígido toda vez que uma única metainfo é atualizada.
Outro efeito disso é que a metainfo no disco deve sempre estar completa,
embora nem sempre atualizada.
Você pode ler mais sobre softupdates na
<a href="#SoftUpdates">FAQ Softupdates</a>.

<p>
<a name="Optmaxvnodes"></a>
<h3>14.18.2 - Tamanho do cache namei()</h3>

O cache de tradução nome-para-nó-i (também conhecido como
"name-to-inode" ou
<!-- need to write the manual page first... <a href="">namei(3)</a>
--> namei()) controla a velocidade da tradução do nome de caminho
para o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>.
Um modo razoável de determinar um valor para o cache, se um grande
número de atrasos de cache namei() é notado com uma ferramenta como a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>,
é examinar o valor atual, calculado pelo sistema, com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
(que chama esse parâmetro de "<tt>kern.maxvnodes</tt>"), e aumentar
esse valor até o cache namei() atingir melhores taxas ou determinar que
o sistema não teve benefício substancial ao incrementar o tamanho do
cache namei().
Após o valor ser determinado, você pode defini-lo no momento da
inicialização do sistema com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>.

<p>
<a name= "Async"></a>
<h2>14.19 - Por que nós não utilizamos montagem assíncrona?</h2>

<p>
Questão: "Eu digito "mount -u -o async /" e isso torna um pacote que
eu uso (que insiste em usar várias coisas de tempos em tempos) mais
eficiente.
Por que a montagem assíncrona não é vista com bons olhos e não está
ativada por padrão (como é o caso nas outras versões do Unix)? Ela não
é um modo simples e, dessa forma, seguro de melhorar o desempenho em
algumas aplicações?"

<p>
Resposta: "Montagens assíncronas são mais rápidas que montagens
síncronas, mas elas também são menos seguras. O que acontece no caso
de uma queda de energia? Ou de um problema de hardware? A busca pela
velocidade não deve sacrificar a confiabilidade e a estabilidade do
sistema. Leia a página de manual do
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>."

<pre>
             async   All I/O to the file system should be done asynchronously.
                     This is a dangerous flag to set since it does not guaran-
                     tee to keep a consistent file system structure on the
                     disk.  You should not use this flag unless you are pre-
                     pared to recreate the file system should your system
                     crash.  The most common use of this flag is to speed up
                     restore(8) where it can give a factor of two speed in-
                     crease.
</pre>

<p>
De outra forma, quando você está lidando com dados temporários, que você
pode recriar a partir do zero após um travamento, você pode ganhar
velocidade usando uma partição separada somente para aqueles dados, e
montada como assíncrona. Novamente, faça isso <i>somente se</i>
você não se importa que todos os dados na partição sejam perdidos caso
algo de errado aconteça. Por essa razão, partições
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
são montadas assincronamente, já que elas são removidas e recriadas
em uma reinicialização.


<p>
<font color= "#0000e0">
<a href= "index.html">[Índice da FAQ]</a>
<a href= "faq13.html">[Seção 13 - Multimídia]</a>
<a href= "faq15.html">[Seção 15 - Pacotes e Portes]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[voltar]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.192 ]<br>
$Translation: faq14.html,v 1.10 2009/10/30 13:31:34 alan Exp $<br>
-->
$OpenBSD: faq14.html,v 1.7 2009/10/31 07:55:59 ajacoutot Exp $
</small>

</body>
</html>
