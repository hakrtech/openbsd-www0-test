<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>7 - Controle do Teclado e da Tela</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
</head>

<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Índice da FAQ]</a>
<a href= "faq6.html">[Seção 6 - Redes]</a>
<a href= "faq8.html">[Seção 8 - Questões Gerais]</a>
</font>

<h1><font color="#e00000">7 - Controle do Teclado e da Tela</font></h1>
<hr>
<p>
<h3>Conteúdo</h3>
<ul>
<li><a href= "#Keyboard"     >7.1 - Como remapear o teclado? (wscons)</a>
<li><a href= "#ConsoleMouse" >7.2 - O OpenBSD suporta o mouse no modo
    console?</a>
<li><a href= "#Scrollback"   >7.3 - Como acessar a memória de retrocesso
    de páginas ("scrollback") do console. (amd64, i386, qualquer Alpha)</a>
<li><a href= "#SwitchConsole">7.4 - Como mudar de console? (amd64, i386,
    Zaurus, qualquer Alpha)</a>
<li><a href= "#80x50"        >7.5 - Como usar a resolução 80x50 no
    console? (amd64, i386, qualquer Alpha)</a>
<li><a href= "#SerCon"       >7.6 - Como usar um console serial?</a>
<li><a href= "#Blanker"      >7.7 - Como deixar o console em branco?
    (wscons)</a>
<li><a href= "#ALLCAPS"      >7.8 - TUDO QUE EU DIGITO NO PROMPT DE
    LOGIN ESTÁ EM MAIÚSCULO!</a>
<li><a href= "#tmux"         >7.9 - O que é o tmux(1)?</a>
</ul>
<hr>

<br>
<p>
<a name= "Keyboard"></a>
<h2>7.1 - Como remapear o teclado? <i>(wscons)</i></h2>

<p>
As arquiteturas que usam o driver de console
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a>
são: <a href="../../alpha.html">alpha</a>,
<a href="../../amd64.html">amd64</a>,
<a href="../../hppa.html">hppa</a>,
<a href="../../i386.html">i386</a>,
<a href="../../mac68k.html">mac68k</a>,
<a href="../../macppc.html">macppc</a>,
<a href="../../sparc.html">sparc</a>,
<a href="../../sparc64.html">sparc64</a>,
<a href="../../vax.html">vax</a>
e <a href="../../zaurus.html">zaurus</a>.

<p>
Com o wscons(4), a maioria das opções podem ser controladas usando o
utilitário
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>.
Por exemplo, para mudar o mapa do teclado com o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>,
você deve executar o seguinte:

<blockquote><pre>
# <strong>wsconsctl keyboard.encoding=uk</strong>
</pre></blockquote>

<p>
No próximo exemplo, nós remapeamos a &quot;Caps Lock&quot; para ser
&quot;Control L&quot;:

<blockquote><pre>
# <strong>wsconsctl keyboard.map+="keysym Caps_Lock = Control_L"</strong>
</pre></blockquote>


<a name= "ConsoleMouse"></a>
<h2>7.2 - O OpenBSD suporta o mouse no modo console?</h2>

<p>
Para as plataformas <a href="../../alpha.html">alpha</a>,
<a href="../../amd64.html">amd64</a>
e <a href="../../i386.html">i386</a>,
o OpenBSD fornece o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsmoused&amp;sektion=8&amp;arch=i386">wsmoused(8)</a>,
um porte do moused(8) do FreeBSD.
Ele pode ser ativado automaticamente na inicialização, basta copiar e
editar a linha apropriada do rc.conf no
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a>.

<p>
<a name= "Scrollback"></a>
<h2>7.3 - Como acessar a memória de retrocesso de páginas ("scrollback")
do console <i>(amd64, i386, qualquer Alpha)</i></h2>

<p>
Em algumas plataformas,
o OpenBSD fornece uma memória de retrocesso de páginas ("scrollback").
Isso permite que você veja informações que foram mostradas anteriormente
na sua tela.
Para mover para cima e para baixo na memória, simplesmente use a
combinação de teclas
<tt>[SHIFT]+[PGUP]</tt> e <tt>[SHIFT]+[PGDN]</tt>.

<p>
A memória de retrocesso de páginas padrão, ou o número de páginas que
você pode movimentar e visualizar, é 8.
Essa é uma característica do driver
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>,
dessa forma ele não funciona sem uma placa VGA em plataforma alguma
(muitos sistemas Alpha possuem uma placa de vídeo TGA).

<p>
Devido à limitação de espaço, os kernels de instalação não fornecem
a função de retrocesso de páginas. A
<a href="#SwitchConsole">mudança de console</a> limpa a memória
de retrocesso de páginas.

<p>
<a name= "SwitchConsole"></a>
<h2>7.4 - Como mudar de console? <i>(amd64, i386, Zaurus, qualquer
Alpha)</i></h2>

Nos sistemas amd64, i386 e Alpha com placas
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>,
o OpenBSD dispõe de seis terminais virtuais por padrão,
/dev/ttyC0 até /dev/ttyC5.
O terminal ttyC4 é reservado para uso do sistema X Window, deixando
cinco consoles de texto.
Você pode passear entre eles usando
<tt>[CTRL]+[ALT]+[F1]</tt>, <tt>[CTRL]+[ALT]+[F2]</tt>,
<tt>[CTRL]+[ALT]+[F3]</tt>, <tt>[CTRL]+[ALT]+[F4]</tt> e
<tt>[CTRL]+[ALT]+[F6]</tt>.

<p>
O ambiente X usa o terminal ttyC4, <tt>[CTRL]+[ALT]+[F5]</tt>.
Quando estiver usando o X,
as teclas <tt>[CTRL]+[ALT]+[F</tt><i>n</i><tt>]</tt> levam você até
as telas de texto;
<tt>[CTRL]+[ALT]+[F5]</tt> leva você de volta ao ambiente gráfico.

<p>
Se você quer ter mais consoles virtuais do que o número padrão, use o
comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg(8)</a>
para criar as telas para ttyC6, ttyC7 e seguintes. Por exemplo:

<blockquote>
<pre>
wsconscfg -t 80x25 6
</pre>
</blockquote>

cria o terminal virtual para ttyC6, acessado por
<tt>[CTRL]+[ALT]+[F7]</tt>.
Não se esqueça de adicionar esse comando no seu arquivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local(8)</tt></a>
se você quer a tela extra na próxima vez que você inicializar o
computador.

<p>
Note que você não terá um prompt "<tt>login:</tt>" no
console virtual recém-criado, a menos que você defina-o como "on"
(ligado) no
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><tt>/etc/ttys(5)</tt></a>,
e reinicialize o computador ou envie um sinal HUP ao
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
usando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">kill(1)</a>.

<p>
Na plataforma Zaurus, dois terminais virtuais
(/dev/ttyC0 e /dev/ttyC1) estão disponíveis por padrão, acessados
com <tt>[ALT]+[CALENDAR]</tt> e <tt>[ALT]+[ADDRESS]</tt>
(A tecla <tt>[ALT]</tt> situa-se à direita da tecla <tt>[CTRL]</tt>
esquerda).

<a name="80x50"></a>
<h2>7.5 - Como usar a resolução 80x50 no console? <i>(amd64, i386,
qualquer Alpha)</i></h2>

Usuários de amd64, i386, e da arquitetura Alpha com VGA, normalmente
têm uma tela de console com 25 linhas de 80 caracteres.
Entretanto, muitas placas de vídeo VGA são capazes de mostrar uma
resolução maior, com 50 linhas de 80 caracteres.

<p>
Primeiro, uma fonte que suporta a resolução desejada precisa ser
carregada usando o comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsfontload&amp;sektion=8">wsfontload(8)</a>.
As telas de texto 80x25 padrão usam fontes de 8x16 pixels; para dobrar
o número de linhas nós teremos que usar fontes de 8x8 pixels.

<p>
Depois disso, nós temos que excluir e recriar um
<a href="#SwitchConsole">console virtual</a> com a resolução de tela
desejada, usando o comando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg(8)</a>.

<p>
Isso pode ser feito automaticamente na inicialização, adicionando as
seguintes linhas no final do seu arquivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local(8)</tt></a>:
<blockquote>
<pre>
wsfontload -h 8 -e ibm /usr/share/misc/pcvtfonts/vt220l.808
wsconscfg -dF 5
wsconscfg -t 80x50 5
</pre>
</blockquote>

Como em qualquer modificação na configuração do seu sistema, é
recomendado que você gaste algum tempo lendo as páginas de manual para
entender o que esses comandos fazem.

<p>
A primeira linha acima carrega a fonte 8x8. A segunda linha exclui a
tela 5 (que pode ser acessada com <tt>[CTRL]+[ALT]+[F6]</tt>). A
terceira linha cria uma nova tela 5 com 50 linhas de 80 caracteres cada.
Se você fizer isso, você verá sua tela primária, e os outros três
consoles virtuais por padrão, no modo 80x25 padrão, mas uma nova
tela 5 em 80x50 estará acessível via <tt>[CTRL]+[ALT]+[F6]</tt>.

<p>
Lembre-se que <tt>[CTRL]+[ALT]+[F1]</tt> é a tela 0 (ttyC0).
Se você deseja alterar outras telas, simplesmente repita os passos de
excluir e adicionar para cada tela que você quer usar na resolução
80x50.

<p>
Você deve evitar a mudança da tela 4
(ttyC4, <tt>[CTRL]+[ALT]+[F5]</tt>), que é usada pelo X como uma tela
gráfica. Também não é possível mudar a resolução do dispositivo de
console primário (ou seja, ttyC0).

<p>
Como era de se esperar, todos esses comandos também podem ser
digitados na linha de comando, como root ou (melhor) usando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>.

<p>
<b>Nota: isso não funciona em todas as placas de vídeo.</b>
Infelizmente, nem todas as placas de vídeo suportam o carregamento de
fontes que o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a>
necessita para executar no modo texto 80x50. Nesses casos, você deve
considerar o uso do X.


<a name="SerCon"></a>
<h2>7.6 - Como usar um console serial?</h2>

Há várias razões pelas quais você pode querer usar um console serial
no seu sistema OpenBSD:
<ul>
<li>Gravar as mensagens de saída do console (para documentação).
<li>Gerenciamento remoto.
<li>Fácil manutenção de uma grande quantidade de máquinas.
<li>Conseguir um dmesg útil de máquinas que de outra forma seria difícil
    conseguir um.
<li>Conseguir a saída exata do "trace" e do "ps" se seu sistema trava,
    assim os desenvolvedores podem ter uma chance de resolver o
    problema.
</ul>
O OpenBSD suporta console serial na maioria das plataformas, entretanto,
os detalhes variam bastante entre as plataformas.

<p>
Note que trabalhar com interface serial NÃO é uma tarefa fácil -- você
frequentemente precisa de cabos pouco usuais e portas que não são
padronizadas entre as máquinas, em alguns casos elas são incompatíveis
em uma máquina. Nós assumimos que você sabe como selecionar o cabo
apropriado para conectar seu computador e o dispositivo atuando como
um terminal serial. Um tutorial completo sobre interface serial está
longe do escopo deste artigo, entretanto, nós damos uma dica: só
porque as extremidades do cabo se encaixaram não quer dizer que vai
funcionar.

<a name="SerContty"></a>
<h3>Modificação do <i>/etc/ttys</i></h3>
O processo para ter um console serial funcionando no OpenBSD divide-se
em duas partes. Primeiro, você precisa ter o OpenBSD usando sua porta
serial como um console para os modos status e usuário único. Essa
parte é dependente de plataforma. Segundo, você precisa ativar a
porta serial para ser usada como um terminal interativo, assim um
usuário pode iniciar sessão nele quando em execução no modo
multiusuário.  Essa parte é similar entre as plataformas e é detalhada
aqui.

<p>
Sessões de terminal são controladas pelo arquivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><i>/etc/ttys</i></a>.
Antes do OpenBSD dar-lhe um prompt "<tt>login:</tt>" no dispositivo, ele
tem que ser ativado no <i>/etc/ttys</i>; depois de tudo, existem outros
usos para uma porta serial além de terminal. Em plataformas que têm
um teclado e uma tela como console, o terminal serial é tipicamente
desativado por padrão. Nós usaremos a plataforma i386 como um exemplo.
Nesse caso, você precisa trocar a linha:

<pre>
     tty00   "/usr/libexec/getty std.9600"   unknown off
</pre>
por esta outra:
<pre>
     tty00   "/usr/libexec/getty std.9600"   vt220   on secure
</pre>

Nesse caso, <tt>tty00</tt> é a porta serial que nós estamos usando como
um console. <tt>vt220</tt> é a entrada
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=termcap&amp;sektion=5">termcap(5)</a>
equivalente ao SEU terminal (outras opções são <tt>vt100</tt>,
<tt>xterm</tt>, etc.).
O "<tt>on</tt>" ativa o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8"><i>getty</i></a>
para aquela porta serial, assim um prompt "<tt>login:</tt>" será
apresentado, o "<tt>secure</tt>" permite que o root (uid 0) inicie
uma sessão neste console (que pode ou não ser algo desejado), e o
"<tt>9600</tt>" é a velocidade do terminal em bauds.
Resista à tentação de colocar a velocidade em bauds no máximo que seu
hardware pode suportar, você está mais apto a criar problemas do que
benefícios. A maioria dos sistemas possuem uma velocidade "padrão"
(suportada por padrão pela ROM e/ou pelo carregador de inicialização,
na maioria das vezes esse valor é 9600); use esse valor, a menos que
você tenha uma boa razão para usar algo diferente.

<p>
Note que você pode usar um console serial para a instalação sem ter que
fazer essa etapa, porque o sistema está em execução no modo usuário
único e não está usando o <i>getty</i> para o início de sessão.

<p>
Em algumas plataformas e configurações, você precisa colocar o sistema
em modo usuário único para fazer essa alteração se um console serial
é tudo que você tem disponível.

<h3>amd64 e i386</h3>
Para que o processo de inicialização use a porta serial como console,
crie ou edite seu arquivo
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386">/etc/boot.conf</a></i>
para incluir a linha:
<pre>
     set tty com0
</pre>

para usar a primeira porta serial como seu console. A velocidade em
bauds é 9600bps por padrão, isso pode ser alterado com uma linha em
<i>/etc/boot.conf</i> usando a opção stty. Esse arquivo é colocado
no seu disco de inicialização, que também pode ser um disquete de
instalação, ou o comando pode ser digitado no prompt <tt>boot></tt>
do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">carregador de inicialização de segundo estágio do OpenBSD</a>
para uma primeira utilização do console serial.


<p>
<h4>Notas para amd64 e i386:</h4>
<ul>
<li>O OpenBSD numera as portas seriais começando em <i>tty00</i>, o
    DOS/Windows nomeia-as começando em <i>COM1</i>. Então, mantenha em
    mente que <i>tty02</i> é <i>COM3</i>, e não <i>COM2</i>.

<li>Alguns sistemas podem estar configurados para funcionar sem uma
    placa de vídeo na máquina, mas certamente não são todos -- muitos
    sistemas consideram isso como um erro. Algumas máquinas se recusam
    a funcionar sem um teclado conectado.

<li>Alguns sistemas são capazes de redirecionar as atividades do BIOS
    do teclado e tela para uma porta serial através de uma opção de
    configuração, assim a máquina pode ser completamente mantida através
    de uma porta serial.
    Seus resultados podem variar -- ao usar essa funcionalidade,
    alguns BIOS podem impedir o carregador de inicialização de ver
    a porta serial, e dessa forma o kernel não saberá usá-la.
    Alguns BIOS possuem uma opção para "Continuar o redirecionamento
    do console após o POST" ("Power On Self Test"); isso deve ser
    configurado para "OFF", assim o carregador de inicialização e o
    kernel podem controlar seu próprio console.
    Infelizmente, essa funcionalidade não é universal.

<li>Os computadores compatíveis com PC não são projetados para funcionar
    a partir de um console serial, diferente de algumas outras
    plataformas. Mesmo aqueles sistemas que suportam um console serial
    precisam que alguma configuração esteja ativada no BIOS -- e se essa
    informação de configuração estiver corrompida, você terá
    novamente um sistema procurando por um monitor padrão e um teclado.
    Você deve, geralmente, ter um modo de obter um teclado e um monitor
    para seus sistemas amd64 e i386, em caso de emergência.

<li>Você deve editar o arquivo <i>/etc/ttys</i> como descrito
<a href="#SerContty">acima</a>.

</ul>


<h3>SPARC e UltraSPARC</h3>
Essas máquinas são construídas para serem completamente mantidas com
um console serial. Simplesmente remova o teclado de uma máquina, e o
sistema funcionará na serial.

<h4>Notas para SPARC e UltraSPARC</h4>
<ul>
<li>As portas seriais em um SPARC são nomeadas como <i>ttya</i>,
    <i>ttyb</i>, etc.

<li>Diferente de algumas outras plataformas, não é necessário fazer
    quaisquer mudanças no <i>/etc/ttys</i> para usar um console serial.

<li>Os sistemas SPARC/UltraSPARC interpretam o sinal BREAK na porta
    serial da mesma maneira que o comando STOP-A e coloca o sistema
    de novo no prompt "Forth", parando qualquer aplicativo e Sistema
    Operacional neste ponto. Isso é útil quando desejado, mas,
    infelizmente, alguns terminais seriais e alguns dispositivos de
    comutação RS-232 enviam algo ao computador que é interpretado como
    um sinal "break", desligando a máquina. Faça testes antes de usar a
    máquina em um ambiente de produção.

<li>Se você tem conectado um teclado e um monitor, você pode forçar o
    uso do console serial mediante os seguintes comandos no prompt
    <tt>ok</tt>:
 <pre>
     ok <b>setenv input-device ttya</b>
     ok <b>setenv output-device ttya</b>
     ok <b>reset</b>
 </pre>
    Se o teclado e o monitor (ttyC0) estão ativos em <i>/etc/ttys</i>
    (<a href="#SerContty">acima</a>), você pode usar o teclado e o
    monitor no X.
</ul>

<h3>MacPPC</h3>
As máquinas MacPPC são configuradas para utilizar um console serial
através do "OpenFirmware". Use os comandos:
 <pre>
     ok <b>setenv output-device scca</b>
     ok <b>setenv input-device scca</b>
     ok <b>reset-all</b>
 </pre>
Configure seu console serial para 57600bps, 8N1.

<h4>Notas para MacPPC</h4>
<ul>
<li>Infelizmente, utilizar console serial não é diretamente possível na
    maioria dos MacPPCs. Enquanto a maior parte dessas máquinas possuem
    um "hardware" serial, ele não é acessível fora da máquina.
    Felizmente, algumas companhias disponibilizam dispositivos
    adicionais para vários modelos de Macintosh, que faz esse porte
    disponível para o uso como um console serial (ou outros usos). Use
    sua ferramenta de buscas favorita e procure por
    "Macintosh internal serial port".

<li>Você tem que mudar <tt>tty00</tt> em <i>/etc/ttys</i> para
    <tt>on</tt> e configurar a velocidade para 57600 em vez do padrão
    de 9600, como detalhado <a href="#SerContty">acima</a>, em modo
    usuário único antes de inicializar em modo multiusuário e ter um
    console serial funcionando.</ul>


<h3>Mac68k</h3>
O console serial é selecionado no programa <i>Booter</i>, no menu
"<tt>Options</tt>" em "<tt>Serial Ports</tt>". Marque a caixa
"Serial Console", então escolha a porta "Modem" ou "Printer". Você
precisa de um cabo de impressora ou modem Macintosh para fazer a
conexão na porta serial do seu Mac. Se você deseja ter isso como padrão,
mande o programa Booter salvar suas opções.


<h4>Notas para Mac68k</h4>
<ul>
<li>A porta do modem é <i>tty00</i>, a porta da impressora é
    <i>tty01</i>.

<li>O Mac68k não ativa a porta serial até que seja chamada; assim, sua
    máquina não vai mostrar quaisquer sinais na porta serial do Mac
    até que o processo de inicialização do OpenBSD tenha começado.

<li>Você tem que ativar a porta (<i>tty00</i> ou <i>tty01</i>) como
    indicado <a href="#SerContty">acima</a>.  </ul>

<a name="Blanker"></a>
<h2>7.7 - Como deixar o console em branco? (wscons)</h2>
Se você deseja deixar seu console em branco depois de um período de
inatividade sem uso do X, você pode alterar as seguintes variáveis do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a>:

<ul>
<li><b><tt>display.vblank</tt></b> definida como <tt>on</tt>
    desabilita o pulso de sincronização vertical, o que faz com que
    muitos monitores entrem em modo de "economia de energia". Isso
    requer mais tempo para ativar a tela novamente, mas reduz o
    consumo de energia e o aquecimento de monitores mais novos. Quando
    definida com o valor <tt>off</tt>, a tela vai ficar em branco,
    porém o monitor continuará recebendo os pulsos de sincronização
    horizontal e vertical normalmente, assim a volta ao estado anterior
    será quase que instantânea.

<li><b><tt>display.screen_off</tt></b> determina o tempo de expiração em
    milésimos de segundo até o console ficar em branco, ou seja, 60000
    configura o tempo limite para um minuto.

<li><b><tt>display.kbdact</tt></b> determina se a atividade do teclado
    deve restaurar a tela ao estado anterior. Normalmente, isso é
    desejado.

<li><b><tt>display.outact</tt></b> determina se a saída de informação
    pode restaurar a tela ao seu estado anterior.
</ul>

Você pode configurar essas variáveis com uma linha de comando usando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>:
<pre>
     # <b>wsconsctl display.screen_off=60000</b>
     display.screen_off -> 60000
</pre>

ou configurá-las permanentemente editando o arquivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl.conf&amp;sektion=5"><i>/etc/wsconsctl.conf</i></a>,
assim essas mudanças terão efeito na próxima inicialização:

<pre>
     display.vblank=on               # Deixa em branco a sincronização
                                     # vertical
     display.screen_off=600000       # Define o tempo de expiração para
                                     # a tela em branco para 10 minutos
     display.kbdact=on               # Restaura a tela na entrada de
                                     # dados pelo teclado
     display.outact=off              # Restaura a tela com a saída
                                     # no monitor
</pre>

A tela em branco é ativada a partir do momento que
<tt>display.kbdact</tt> ou <tt>display.outact</tt> estejam definidas
como "<tt>on</tt>".

<a name="ALLCAPS"></a>
<h2>7.8 - TUDO QUE EU DIGITO NO PROMPT DE LOGIN ESTÁ EM MAIÚSCULO!</H2>
Na realidade, essa é uma funcionalidade, não um problema.

<p>
Virtualmente todos os comandos do Unix e nomes de usuários são digitados
em minúsculo.
No entanto, alguns terminais muito velhos suportam somente caracteres
em maiúsculo, tornando a utilização difícil, ou então impossível de ser
usado com o Unix. Se você digitou todo seu nome de usuário em maiúsculo,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8">getty(8)</a>
assume que seu terminal não suporta caracteres minúsculos, e
interpreta tudo que você digitar como caracteres minúsculos enquanto
mostra os caracteres em maiúsculo.
Se você tem uma senha composta de caracteres maiúsculos e minúsculos,
o início de sessão será impossível.

<p>
Pressionar CTRL-D no prompt de login faz com que o getty(8) seja
terminado e o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
mostre um novo prompt, que aceita corretamente as maiúsculas e
minúsculas.


<a name="tmux"></a>
<h2>7.9 - O que é o tmux?</h2>

Para aqueles(as) familiares com o programa "screen", fornecido como um
pacote, ou com o window(1), que era parte da base do sistema, pode ser
mais fácil responder a essa pergunta dizendo que o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>tmux(1)</a>
realiza muitas das funções do screen e do window, com muitos recursos
adicionais.

<p>
Para aqueles(as) que não são familiares com esses programas, tmux é um
<i>multiplexador de terminal</i>.
Esse é um programa que permite que um número de outros processos
compartilhem a mesma tela por entrada e por saída.
No tmux, tal coleção de programas é conhecida como uma <i>sessão</i>,
com cada programa contido em uma <i>janela</i> do tmux.

<p>
Em adição ao compartilhamento do terminal, o tmux permite a você
desconectar da tela uma sessão e suas janelas, deixando-as continuar
em execução no segundo plano, e mais tarde reconectá-las a mesma tela
ou a uma tela diferente.
Uma sessão pode ser desconectada manualmente ou através de um evento
inesperado, como uma desconexão de rede, em ambos os casos os programas
sobrevivem e continuam em execução normalmente.

<p>
O tmux também tem muitos outros recursos, como a divisão de uma única
janela em múltiplas seções (conhecidas como <i>painéis</i>), um
histórico de texto exibido em cada janela, cópia e cola de texto entre
as janelas, atalhos de teclas configuráveis e trancamento de terminal.
Dê uma olhada na página de manual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>tmux(1)</a>
para obter mais informações.

<h3>Como eu uso o tmux?</h3>

<p>
O primeiro passo é executar o tmux:

<blockquote><pre>
$ tmux
</pre></blockquote>

<p>
Isso inicia um novo tmux com uma única nova sessão
(chamada sessão "0") e cria um cliente mostrando-a na tela.
A maior parte da tela mostra uma janela contendo um prompt de shell,
e você pode notar que a última linha é ocupada por uma linha de status.
Esta mostra o nome da sessão entre colchetes na esquerda, o título da
janela (normalmente vazio para shells) e o horário na direita, e um
sumário das janelas abertas atualmente no meio.
Na sua nova sessão, as janelas abertas atualmente contêm uma entrada,
por exemplo:

<blockquote><pre>
0:ksh*
</pre></blockquote>

<p>
Uma breve nota sobre terminais: no OpenBSD, aplicativos conhecem as
capacidades do terminal através da variável de ambiente TERM.
Esta é definida com o nome de uma entrada no banco de dados
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=terminfo&amp;sektion=5">terminfo(5)</a>
e diz aos programas que o terminal, por exemplo, suporta cores, ou tem
a habilidade de inserir linhas, ou muitas outras coisas.
Uma coisa importante a notar é que a entrada "xterm" no banco de dados
não inclui cores, então o tmux por padrão não utiliza cores no xterm;
TERM deve ser definida como "xterm-xfree86" se as cores são desejadas
(o recurso do X "XTerm*termName" pode ser definido em .Xdefaults para
utilizar isso em todos os xterms).
Também é importante que TERM em shells iniciados dentro do tmux
esteja definida como "screen", ou os programas executados a partir
deles podem não ser mostrados corretamente - o tmux define-a por
si mesmo, mas cuidado deve ser tomado para não sobrescrevê-la nos
arquivos de inicialização do shell.

<p>
Voltando à linha de status, o número "0" é o índice das janelas, "ksh"
o nome da janela, e o "*" indica que esta é a janela atual mostrada
acima da linha de status.
Toda digitação é passada para o shell e toda saída é mostrada.
Por exemplo, se você inicia o
"<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=top&amp;sektion=1">top</a>":

<blockquote><pre>
$ top
</pre></blockquote>

<p>
Ele é executado normalmente, ocupando a parte da tela acima da linha
de status.
Você também pode notar que o nome da janela na linha de status mudou
de "ksh" para "top" - o tmux renomeia as janelas para refletir o
programa que está atualmente em execução nelas.

<p>
Agora, digamos que você queira desconectar o tmux da tela e retornar
ao shell original de onde você o iniciou.
Uma sessão do tmux pode ser desconectada através da digitação das teclas
<i>Ctrl</i> e <i>b</i> juntas, e então a tecla <i>d</i>.
A combinação de teclas <i>Ctrl-b</i> (abreviada no tmux e em sua
página de manual como "C-b") é conhecida com <i>tecla de prefixo</i>
e é utilizada para dizer ao tmux que a próxima tecla pressionada é
uma instrução de que ele deve realizar alguma ação em vez de passar
a tecla para o programa na janela.


<p>
Após pressionar <i>Ctrl-b d</i> e retornar para o prompt de shell,
reconecte a sessão do tmux utilizando o comando "attach":

<blockquote><pre>
$ tmux attach
</pre></blockquote>

<p>
A sessão do tmux vai reaparecer, com a linha de status e o "top" ainda
em execução.
(Se no lugar você executa o tmux novamente, e sem argumentos, uma
segunda sessão será criada, nomeada como "1".)

<p>
Continuando, vamos criar uma segunda janela.
Isso é feito utilizando a tecla "c": pressione a tecla de prefixo,
<i>Ctrl-b</i>, então a tecla "c".
Uma nova janela é criada e, novamente, um prompt de shell é mostrado
na tela.
A linha de status é atualizada para mostrar a nova janela:

<blockquote><pre>
0:top- 1:ksh*
</pre></blockquote>

<p>
O "-" depois do nome mostra a janela que foi a atual previamente
(a última janela).
Pressionar <i>Ctrl-b c</i> novamente cria um outro novo shell:

<blockquote><pre>
0:top  1:ksh- 2:ksh*
</pre></blockquote>

<p>
Existem diversos comandos para a movimentação entre as janelas.
Da janela 2 você pode se mover para a janela anterior, número 1,
digitando <i>Ctrl-b p</i>.
<i>Ctrl-b n</i> movimenta-o para a próxima janela: nesse caso não
existe a janela 3, então a janela atual passa a ser a janela 0.
Você também pode pressionar <i>Ctrl-b w</i> para obter um
menu interativo das janelas abertas,
<i>Ctrl-b l</i> para movimentá-lo para a última janela utilizada
(a marcada com "-"), ou <i>Ctrl-b 0</i> para movimentá-lo para a
janela 0, <i>Ctrl-b 1</i> para a janela 1, e assim vai até
<i>Ctrl-b 9</i> para a janela 9.
Então para voltar para o "top" na janela 0 você pode pressionar
<i>Ctrl-b 0</i> para ir diretamente para a janela 0, pressionar
<i>Ctrl-b p</i> duas vezes para mover-se passando pela janela 1,
<i>Ctrl-b n</i> para ir da janela 2 para a janela 0, ou pressionar
<i>Ctrl-b w</i> e selecionar a janela 0 na lista.

<p>
Algumas vezes você pode querer criar uma janela executando um
programa diretamente, sem antes utilizar um shell.
Isso pode ser feito a partir do <i>prompt de comandos</i> do tmux.
Pressionar a sequência de teclas <i>Ctrl-b :</i> muda a linha de status
para mostrar um prompt ":" no qual comandos podem ser especificados.
Todos os comandos do tmux estão documentados na página de manual.
Nesse caso o comando "new-window" é necessário.
Cada comando tem um apelido de abreviação que pode ser utilizado
no lugar da digitação do nome completo; para "new-window" o apelido é
"neww".
Então, para criar uma nova janela executando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tetris&amp;sektion=6">tetris(6)</a>,
digite:

<blockquote><pre>
neww tetris
</pre></blockquote>

<p>
A nova janela fecha-se quando o tetris termina sua execução, ou pode
ser excluída, forçosamente, utilizando o atalho de teclas
<i>Ctrl-b &</i>.
Isso primeiro exibe um prompt pedindo a confirmação e, se a confirmação
é dada, fecha a janela e termina o programa que está em execução nela.

<p>
Um outro requerimento comum é renomear uma janela.
Isso pode ser feito com o atalho de teclas <i>Ctrl-b ,</i>.
A linha de status muda para mostrar um prompt "(rename-window)" no qual
o novo nome pode ser especificado.
Renomear uma janela desliga o renomeamento automático para aquela
janela; para reativar aquele recurso, pressione <i>Ctrl-b :</i> para
ir para o prompt de comandos e especifique o seguinte (mais informações
sobre o que isso significa estão na próxima seção):

<blockquote><pre>
setw -u automatic-rename
</pre></blockquote>

<p>
Uma outra importante tecla que vale a pena lembrar: <i>Ctrl-b ?</i>.
Isso mostra uma lista de todas as teclas do tmux e os comandos que
elas executam.
Por exemplo, <i>Ctrl-b ?</i> mostra que a tecla <i>c</i> está
vinculada ao comando "new-window" e a tecla <i>n</i> ao comando
"next-window".

<h3>Configuração do tmux</h3>

<p>
Muitos usuários querem personalizar a aparência ou comportamento do
tmux.
Isso é feito através do arquivo de configuração <i>~/.tmux.conf</i>.
Esse arquivo é uma lista de comandos do tmux que são executados quando
o tmux é iniciado, antes da primeira sessão ser criada.
Todos os comandos do tmux estão documentados na página de manual,
mas alguns exemplos comuns que talvez você queira colocar no seu
arquivo de configuração são discutidos abaixo.

<p>
O requerimento mais comum é definir opções.
Existem dois tipos de opção no tmux: <i>opções de sessão</i> e
<i>opções de janela</i>.
Opções de sessão controlam o comportamento de uma sessão, e
opções de janela o comportamento de uma janela individual.
Para ambas existe um conjunto de opções globais.
Quando o tmux vai decidir o valor de uma opção para uma sessão ou
janela particular, ele olha primeiro nas opções locais daquela janela;
se a opção não foi definida, o valor da opção global é utilizado.

<p>
Opções de sessão são definidas com o comando
"set-option" (apelido "set"), e opções de janela com o comando
"set-window-option" (apelido "setw").
Para definir uma opção global utilize o sinalizador "-g"; se esse
sinalizador não é utilizado a opção é definida para a janela ou sessão
atual.
Esses comandos também aceitam alguns outros sinalizadores, tal como o
"-u" para indefinir uma opção local e permitir que uma janela ou sessão
herde a opção global novamente.

<p>
No arquivo de configuração a definição de opções globais é simples.
Vamos dar uma olhada em alguns exemplos de personalização da
linha de status:


<blockquote><pre>
set -g status-bg blue
set -g status-right '#(sysctl vm.loadavg)'
setw -g window-status-current-attr underscore
</pre></blockquote>

<p>
Colocar esses três comandos no arquivo .tmux.conf e reiniciar o tmux
muda a cor de segundo plano da linha de status para azul, coloca a
carga média atual do sistema no lado direito e sublinha a janela atual.
A linha de status pode ser desativada totalmente com:

<blockquote><pre>
set -g status off
</pre></blockquote>

<p>
Existe um grande número de outras opções; uma outra opção útil é mudar
os atalhos de teclas no prompt de comandos, na lista de janelas e em
outros modos interativos do tmux para o estilo do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">vi(1)</a>:

<blockquote><pre>
set -g status-keys vi
setw -g mode-keys vi
</pre></blockquote>

<p>
As opções atuais e seus valores podem ser listados com os comandos
"show-options" e "show-window-options".
Igual aos comandos de definição, estes aceitam "-g" para mostrar as
opções globais.

<p>
Uma outra tarefa comum para o arquivo de configuração é adicionar ou
modificar atalhos de teclas dos comandos do tmux, isto é, os comandos
que são executados após você pressionar <i>Ctrl-b</i> com outra tecla.
Esses são adicionados ou alterados com o comando
"bind-key" (apelido "bind") e removidos com o comando
"unbind-key" (apelido "unbind").
Dois exemplos de uso do "bind-key":

<blockquote><pre>
bind C-d detach
bind / neww 'exec top'
</pre></blockquote>

<p>
A primeira linha cria um atalho em <i>Ctrl-b Ctrl-d</i> para desconectar
o tmux, o mesmo que o padrão <i>Ctrl-b d</i>, e o segundo vincula
<i>Ctrl-b /</i> para criar uma nova janela com o programa top
em execução.

<p>
Muitas pessoas gostam de utilizar uma tecla de prefixo diferente de
<i>Ctrl-b</i>.
Isso pode ser alcançado utilizando os comandos de "set-option" e de
vinculação de teclas para alterar a tecla de prefixo e mudar de modo
que, ao pressionar duas vezes o prefixo, a mesma tecla continue
passando através da janela.
Para mudar a tecla de prefixo para <i>Ctrl-a</i>:

<blockquote><pre>
set -g prefix C-a
unbind C-b
bind C-a send-prefix
</pre></blockquote>

<p>
A última coisa útil para se fazer no arquivo de configuração é criar
um conjunto inicial de janelas quando o tmux inicia.
Isso é um pouco mais complicado que os exemplos anteriores.
No tmux uma sessão não pode não ter janelas, e você não pode criar
janelas sem uma sessão.
Então, para ter as janelas criadas pelo arquivo de configuração você
deve primeiro criar uma sessão para contê-las.
Por exemplo (note que "new" é o apelido para o comando "new-session"):

<blockquote><pre>
new -d 'exec top'
neww -d
neww -d
</pre></blockquote>

<p>
Esses comandos criam uma nova sessão com o "top" em execução na primeira
janela, e então cria duas janelas adicionais.
Os sinalizadores "-d" instruem o tmux a não tentar conectar a nova
sessão ou tornar as novas janelas a janela atual.
Antes de colocar essas linhas no .tmux.conf, existe um outro problema.
Quando executado sem argumentos, o tmux executa o comando "new-session",
então ao iniciar o tmux com um "tmux" a partir do shell, o arquivo
de configuração diz ao tmux para criar uma sessão, então o comando do
shell diz a ele para criar uma outra, e assim você acaba com
<i>duas</i> sessões.
Para evitar isso, o tmux deve ser iniciado com "tmux attach" ao
criar uma sessão a partir do arquivo de configuração - isso
significa que ele cria uma nova sessão a partir do .tmux.conf e
então conecta-se imediatamente a ela sem criar uma segunda sessão.

<h3>Utilização avançada do tmux</h3>

<p>
Esta seção cobre brevemente alguns dos recursos mais avançados
disponíveis no tmux.
Veja a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>página de manual</a>
para obter mais informações.

<p>
No tmux você pode copiar e colar texto entre as janelas.
Isso é feito copiando o texto no <i>modo de cópia</i> e então colando
com o comando de colar.
Para entrar no modo de cópia, pressione <i>Ctrl-b [</i>.
No modo de cópia (com a opção de janela "mode-keys" definida como emacs;
para teclas vi, veja a página de manual) as teclas direcionais podem
ser utilizadas para posicionar o cursor, <i>Ctrl-Espaço</i> inicia a
seleção e <i>Ctrl-w</i> copia.
Você também pode utilizar <i>Page Up</i>, <i>Page Down</i>,
<i>Ctrl-a</i> e <i>Ctrl-e</i> para movimentar o cursor ao redor.
Pressione <i>q</i> ou <i>Escape</i> para sair do modo de cópia.
Depois disso, <i>Ctrl-b ]</i> cola o texto copiado na janela atual
como se você tivesse digitado diretamente.

<p>
tmux pode ser utilizado com facilidade em scripts, e a maioria dos
comandos que podem ser especificados a partir do prompt de comandos
ou vinculados a uma tecla podem ser executados a partir do shell.
Praticamente todos os comandos do tmux aceitam um argumento "-t"
opcional que especifica a sessão ou janela onde o comando deve atuar.
Por exemplo, este comando:

<blockquote><pre>
$ tmux kill-window -t0:1
</pre></blockquote>

exclui a janela 1 na sessão 0.
E:

<blockquote><pre>
$ tmux new-window -tmysession
</pre></blockquote>

<p>
cria uma nova janela na sessão nomeada "mysession".
Muitos comandos aceitam outros argumentos; por exemplo, o comando
"new-window" aceita uma opção "-n" para dar nome a nova janela, e
"new-session" aceita diversos argumentos para especificar os atributos
da janela inicial criada com a sessão.
Esses argumentos também podem ser utilizados quando um comando
está vinculado a uma tecla ou quando é executado a partir de um
prompt de comando.

<p>
Um outro recurso útil é a capacidade de dividir uma única janela em
várias seções, chamadas de <i>painéis</i>.
Você pode dividir uma janela verticalmente
(do topo para a base) com a combinação de teclas <i>Ctrl-b "</i>.
Um painel pode ser redimensionado acima e abaixo com
<i>Ctrl-b Alt-Up</i> e <i>Ctrl-b Alt-Down</i>, e o painel ativo pode
ser mudado com <i>Ctrl-b o</i>.
Adicionalmente, uma janela dividida daquela forma pode ser alterada
para um dos vários layouts fixos, que podem ser alternados
ciclicamente com <i>Ctrl-b Espaço</i>; mas painéis em um desses
layouts não podem ser redimensionados.
No OpenBSD -current a divisão foi estendida para suportar a divisão
horizontal (<i>Ctrl-b %</i>), e layouts fixos foram alterados para
que eles fossem aplicados uma vez (com o mesmo atalho nas teclas
<i>Ctrl-b Espaço</i>), mas então pudessem ser livremente redimensionados
e modificados, tanto horizontalmente quanto verticalmente.

<p>
<font color= "#0000e0">
<a href= "index.html">[Índice da FAQ]</a>
<a href= "faq6.html">[Seção 6 - Redes]</a>
<a href= "faq8.html">[Seção 8 - Questões Gerais]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[voltar]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq7.html,v 1.89 ]<br>
$Translation: faq7.html,v 1.13 2010/06/14 16:24:49 renato Exp $<br>
-->
$OpenBSD: faq7.html,v 1.12 2010/06/19 07:38:08 ajacoutot Exp $
</small>
</body>
</html>
