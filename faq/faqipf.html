<html>
<head>
<title>IPF - IP Filter (OpenBSD 2.9 and earlier)</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2002 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<h2><font color=#e00000>IPF - IP Filter (OpenBSD 2.9 and earlier)</font><hr></h2>
</p>

<p>
<h4>Note that IPF has been replaced with Packet Filter in OpenBSD 3.0
and later. This is provided as a reference to those using
older versions of OpenBSD</h4>
</p>

<p>
<ul><h3>Table of Contents</h3>
<li><a href= "#6.2">6.2 - IP Filter</a>
<li><a href= "#6.3">6.3 - Network Address Translation</a>
</ul>
</p>
<hr>

<br>

<p>
<a name= "6.2"></a>
<h2>6.2 - IP Filter</h2>
</p>

<p>
The IPFilter package was created to handle two tasks, dealing with packet level forwarding permissions 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=8&manpath=OpenBSD+2.7">ipf(8)</a> and mapping hosts/subnets 
to a range of external addresses <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a>. 
The configuration files for these two services are <i>/etc/ipf.rules</i> and <i>/etc/ipnat.rules</i>.
</p>

<p>
To start these services with your system, you need to edit <i>/etc/rc.conf</i> and set the lines to:
</p>

<ul><pre>
ipfilter=YES
ipnat=YES
</pre></ul>

<p>
<b>NOTE:</b> You do not need both options activated always, unless you are using both. However, if you are using 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a>, ipfilter must also be activated.
</p>

<p>
If you are using <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a>, you will most 
likely also need to set the sysctl value &quot;net.inet.ip.forwarding&quot; to 1. You can do this by uncommenting 
the pertaining lines in <i>/etc/sysctl.conf</i>.
</p>

<P>
If you have IP Filter compiled into your kernel, but you don't have 
it turned on in your <i>/etc/rc.conf</i> file, you can still activate it easily. 

<ul><pre>
# <strong>ipf -Fa -f /etc/ipf.rules -E</strong>
# <strong>ipnat -CF -f /etc/ipnat.rules</strong>
</pre></ul>

<P>
The <tt>-E</tt> flag on ipf 'enables' IP Filter.  <Tt>-Fa</tt> clears out any rules that you may have in there.  <tt>-f /etc/ipf.rules</tt> loads the rules from
<i>/etc/ipf.rules</i>.
<p>
If you make changes to <i>/etc/ipf.rules</i> after ipf is loaded, you can reload your rules pretty easily!

<ul><pre>
# <strong>ipf -Fa -f /etc/ipf.rules</strong>
</pre></ul>
Same for ipnat...

<ul><pre>
# <strong>ipnat -CF -f /etc/ipnat.rules</strong>
</pre></ul>
You will also want to enable <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipmon&sektion=8&manpath=OpenBSD+2.7">ipmon(8)</a> for debugging.
<ul><pre>
# <strong>ipmon -Ds</strong>
</pre></ul>
<p>
This document will cover some basic <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=8&manpath=OpenBSD+2.7">ipf(8)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a> configurations below.
There are a lot of nice examples in <i>/usr/share/ipf/</i> for ipnat and ipf. We recommend
you choose the one closest to what you want, and modify it to fit your needs.  You can find other IP Filter information
at the IP Filter <A HREF="http://false.net/ipfilter/">mailing list archive</a>, the <A HREF="http://coombs.anu.edu.au/~avalon/">IP Filter web site</a>, and finally the <A
HREF="http://www.obfuscation.org/ipf/">IP Filter HOWTO</a>. 
</p>

<p>
<h3>IPF</h3>
</p>

<p>
In order to enable ipf at boot, you will need to modify /etc/rc.conf so it reads IPFILTER=YES.
IP Filter (ipf) is controlled by /etc/ipf.rules, which is read at boot. For a more detailed explanation, see <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=5&manpath=OpenBSD+2.7">ipf(5)</a>. In the examples that follow, 
fxp0 will represent the external interface to the internet. It will be different for you, based on the
ethernet adaptor present in your computer. These rules will assume full-time internet connectivity, such as you would see on a webserver.
</p>

<p>
IP Filter rules are processed sequentially from top to bottom, it helps to visualize each packet having to traverse every rule before it reaches it's destination.
</p>

<p>
For example, the default ruleset provided allows all packets to travel in, and all packets to travel out:

<ul><pre>
pass out from any to any 
pass in from any to any
</pre></ul>

Now lets say we don't want to allow any incoming connections to port 3306 (mysql) because the database should only be connected to from localhost. Our ruleset would look like this:

<ul><pre>
pass out from any to any
pass in from any to any
block in on fxp0 from any to any port = 3306
</pre></ul>

This says &quot;block in all incoming packets, from anywhere to anywhere whose destination is 3306.&quot;
Essentially a packet destined for port 3306 on interface fxp0 will pass the first &quot;pass in&quot; rule and then be dropped by the &quot;block in port = 3306&quot; rule. If you reversed the order of our incoming rules (remember, order is important):

<ul><pre>
pass out from any to any
block in on fxp0 from any to any port = 3306
pass in from any to any
</pre></ul>

Packets destined for port 3306 would pass because the last rule in the set allows all packets to pass. It is important to keep this in mind when writing packet filter rules:
 <b> The last matching rule wins</b>.
</p>

<p>
Of course, there are exceptions to every rule. the <em>quick</em> option drops the packet at the first rule that matches. Let's look at our above flawed example, if we add <em>quick</em> to the &quot;block in&quot; rule:

<ul><pre>
pass out from any to any
block in quick on fxp0 from any to any port = 3306
pass in from any to any
</pre></ul>

<p>
A packet destined for our host on port 3306 will hit the &quot;block in quick&quot; rule and be dropped immediately. All packets destined for other ports wont find a rule match until they reach our &quot;pass in&quot; rule that allows all packets to pass.
</p>

<b>Default Deny</b>
<p> The safest packet filtering policy is a default deny policy. All traffic not explicitly allowed is denied. This policy is far safer than explicitly denying each protected service, allows for smaller rulesets, and can protect from an accidentally misconfigured service that has been left exposed.
<p>
Let's now look at another real world example ruleset and explain things line by line. Here's an example for a webserver with a default deny policy that only allows ssh connections (for administration) and connections to http (port 80) and https (port 443).
<ul><pre>
pass in quick on fxp0 from any to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre></ul>

<p>
This will allow incoming connections from anywhere to ports 22(ssh), 80(http), and 443(https). It will drop all other connection attempts, and allow all outgoing connections. This is a pretty tight ruleset.
But what if you only wanted to allow internal hosts on your 1.1.1.0 address block to connect to ssh, but allow outside connections to http and https?
</p>

<ul><pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre></ul>

Pretty good, but what if we only want to allow one machine (1.1.1.1) to administer the web server remotely?
In that case, we can change this:

<ul><pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
</pre></ul>
to this:
<ul><pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
</pre></ul>
IP Filter supports both CIDR and dotted decimal forms of netmask address. You could also write the above as:
<ul><pre>
pass in quick on fxp0 from 1.1.1.1/255.255.255.255 to any port = 22
</pre></ul>
but why would you?
</p>
<b>Sample Rules</b>
<p>
Here are some good rules for everyone to use (assuming that fxp0 is the external internet-connected interface). First we will set up simple address spoofing protection.
<ul><pre>
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8
</pre></ul>
It's also a good idea to separate your loopback interface from your other rules. 
<ul><pre>
pass out quick on lo0
pass in quick on lo0
</pre></ul>
Our ruleset is starting to look pretty good, when we put it together, here's what it looks like:
<ul><pre>
# Loopback Rules
pass out quick on lo0
pass in quick on lo0

# don't allow anyone to spoof non-routeable addresses

block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# only allow our administration machine to connect via ssh

pass in quick on fxp0 from 1.1.1.1/32 to any port = 22

# allow others to use http and https

pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443

# finally lock the rest down with a default deny

block in quick on fxp0 from any to any

# and let out-going traffic out

pass out on fxp0 from any to any
</pre></ul>
</p>

<b>Packet logging</b>
<p>
Now that's pretty good, but it could be better. What if we want to log any connection attempts to port 22(ssh) that get blocked by our firewall? Easy, IP Filter can handle this with the <em>log</em> keyword:
<ul><pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
block in log quick on fxp0 from any to any port = 22
</pre></ul>
This rule will allow our remote administration machine to connect to port 22, but deny and log all other attempts to connect to port 22.
</p>
<b> Protocol based packet filtering</b>
<p>
IP Filter can filter any IP protocol based on its number or name from <a href=file://localhost/etc/protocols>/etc/protocols</a>. For the sake of clarity, we will only concern ourselves with tcp, udp, and icmp.  These are the
most commonly used protocols.  All basic internet applications
rely on the availability and correct operation of these protocols.</p>
<p>
In order for ipf to filter based on protocol, the keyword <em>proto</em> must be used. To examine our earlier ssh example rule, since ssh runs over tcp, we should only allow tcp packets to connect. by using the <em>proto</em> keyword to allow only tcp, we get a rule that looks like this:
<ul><pre>
pass in quick on fxp0 proto tcp from 1.1.1.1/32 to any port = 22
</pre></ul>
But what if we need to allow connections to a service running over both tcp and udp like bind? Well, in the case of tcp/udp, IP Filter allows you to group both protocols together. Note: this only applies to tcp/udp. Using the bind example, a rule allowing tcp and udp connections in a default deny environment would look like:
<ul><pre>
pass in quick on fxp0 proto tcp/udp from any to any port = 53
</pre></ul>
</p>
<b> Packet Filtering</b>
<p> 
In addition to filtering based on protocol, IP Filter is also capable of managing fragmented IP packets (a common method of defeating packet filters). There are two possible keywords that can be used when dealing with fragmented ip packets, <em>frag</em> for commonly fragmented IP packets, or <em>short</em> for IP packets with headers too small for comparison. Since fragmented packets can occur normally, depending on link conditions, it is best to only filter packets with headers too small for valid comparison. This can be accomplished with the following rule:
<ul><pre>
block in quick proto tcp all with short
</pre></ul>
What about IP Options? IP Filter can handle those packets too. Packets can either be dropped if they have IP options set, or they can be dropped based on the specific IP options that are set. For example, the following rule will drop and log all packets with ip options set.
<ul><pre>
block in log quick on fxp0 all with ipopts
</pre></ul>
This may however break some things such as <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=traceroute&sektion=8&format=html">traceroute(8)</a>. You can also specify which options not to allow. For instance a good rule is to block all packets with source routing options. This is accomplished with this rule:
<ul><pre>
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr
</pre></ul>
<b>TCP Flags, established connections and keeping state</b>
<p>
Now the filtering begins in earnest. IP Filter's greatest strengths are it's ability to filter packets based on TCP flags and to maintain established connections and connection state. It is recommend that all users who wish to filter packets based on TCP flags understand what role each flag plays. For instance, if you wanted to deny all packets with the FIN, URG, and PSH flags set (like for instance an nmap OS fingerprinting attempt) you could use a rule like this:
<ul><pre>
block in quick on fxp0 proto tcp from any to any flags FUP
</pre></ul>
(Thanks to <a href=mailto:halogen@nol.net>Kyle Hargraves</a> for that tip)
</p>
<p>
IP Filter's next cool trick is it's ability to maintain state. Maintaining state has been described as &quot;not speaking until spoken to&quot;, in other words, once a connection is established, packets no longer have to traverse rulesets. This is a very powerful feature allowing much simpler and more secure rule writing.</p>
<p>
For example, let's see how we can apply state to our previous example ruleset (confused yet?). To review, we are allowing management access from our Class C to port 22(ssh) and allowing all incoming web traffic on ports 80(http) and 443(https). We are blocking all other traffic. But what if I want to ssh out of the webserver? What if I need to use lynx to look up something in the FAQ? Well, I can't because I have blocked all incoming connections other than on the specified ports. While this is the safest route, it can be quite inconvenient. By adding the <em>keep state</em> keywords to our &quot;pass out&quot; rule, we can automagically allow incoming connections in response to connections we initiate, such as when web browsing.  Remember, we do need to specify what protocol we are keeping state for.
<ul><pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
</pre></ul>
</p>
<p>
This little change will dramatically increase the flexibility and security of our ruleset because IP Filter is extremely flexible. For instance, in the above ruleset, we are allowing all tcp traffic into ports 80 &amp; 443. We can tighten this up even more. In order for a tcp connection to be established, we only need to allow the initial handshake to occur, once that occurs, we can block traffic to that port and allow our &quot;keep state&quot; rule to manage the connection. To allow the initial handshake to complete, we need only allow packets with the SYN and SYNACK flags set. By passing only packets with SYN and SYNACK set, we can prevent many forms of portscanning such as FIN scanning. The rules now look like this:
<ul><pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
</pre></ul>
</p>
<p>
Let's wrap this up by putting all of the rules we have so far into a ruleset. This ruleset will have a default deny policy, allow management connections from an internal network only (via ssh) and allow incoming traffic on ports 80(http) and 443(https). It will also protect against spoofed non-routeable ip addresses, and drop all packets that are too fragmented to inspect. A pretty comprehensive setup for a public webserver. Here's what /etc/ipf.rules should look like:
<ul><pre>
# loopback rules
pass out quick on lo0
pass in quick on lo0

# drop itsy bitsy frags
block in quick proto tcp all with short

# drop source routed packets
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr

# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# only allow our machines to connect via ssh
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22

# allow others to use http and https
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA

# finally lock the rest down with a default deny
block in quick on fxp0 from any to any

# and let out-going traffic out and maintain state on established connections
# -- The flags S on the keep state is to ensure that state tracking starts
#    only on the first outbound packet in a tcp session. 
#    unnecessary consumption of state table entries.
# -- The flag s only works on the tcp protocol, so three entries are required to 
#    to cover all three protocols (tcp, udp, icmp).

pass out	quick on fxp0 proto tcp  from any to any flags S keep state
pass out 	quick on fxp0 proto udp  from any to any         keep state
pass out 	quick on fxp0 proto icmp from any to any         keep state
</pre></ul>
</p>
<p>
If you experience problems, you may want to enable logging on individual rules to effectively troubleshoot. ie: pass in log quick on fxp0 from 1.1.1.0/24 to any port = 22<br> 
When you modify the configuration file to log packets, don't forget to ipf -Fa -f /etc/ipf.rules for the changes to take affect! 
<br>ipmon will write to ip log entries to /var/log/ipflog.<br>

For further information on ipf, the <a href=http://www.obfuscation.org/ipf/ipf-howto.txt>IPF how-to</a> is an excellent source, as are the resources available at the <a href=http://coombs.anu.edu.au/~avalon/ip-filter.html>IP Filter</a> homepage.
</p>

<p>
<a name="6.3"></a>
<h2>6.3 - IPNAT</h2>
</p>

<p>
Initial work done by Wayne Fergerstrom &lt;wayne@methadonia.net&gt;
</p>

<a name="nat1.0"></a>
<h3><u>6.3.1 NAT Introduction</u></h3>

<a name="nat1.1"></a>
<b>Section Introduction</b>
<p>
This section attempts to aid for those
installing and configuring Network Address Translation ("NAT")
on an OpenBSD machine. 

The user is assumed to have already set up
and configured an OpenBSD machine with two network cards (one
connected to the Internet and the other to the local network).
IP Network Address Translation will work on machines with only one NIC,
however since packets will be going in and out of the same interface,
ethernet collisions will slow down performance considerably.  
</p>

<p>
Based on <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, ipnat provides an easy way to
map internal networks to a single routeable ("real") internet address. This is very useful if you don't have
officially assigned addresses for every host on your internal network. When
you set up private/internal networks, you can take advantage of reserved
address blocks (assigned in <A HREF="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), such as:
<P>

10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>

</p>

<a name="nat1.2"></a>
<b>Terminology</b>

<p>
The conventions used in this document are fairly straightforward.
For documentation purposes I will review some of the terms and format
for which this document adheres to.
</p>

<ul>
<strong>"NAT"</strong>
<p>
This describes the function of "Network Address Translation."
The process of NAT is described later in this document.
</p>
</ul>

<ul>
<strong>"ipnat"</strong>

<p>
This is short for "IP Network Address Translation." In-and-of
itself, it can be used interchangeably with NAT. However, in
this document the term "ipnat" will be used solely for
command-line only use.
</p>
</ul>

<ul>
<strong>"IPF"</strong>

<p>
This is short for "IP Filter." IP Filter is a portable packet filtering
software that is included as part of OpenBSD.   IP Filter must be enabled
before you can turn on ipnat.  This is easy, just edit /etc/rc.conf
and change ipfilter=NO to ipfilter=YES.  That only changes it for the boot up sequence,
you also need to do 'ipf -E' to turn on ipf while you are booted.  Of course,
this is described further, below.
</p>
</ul>

<br>
<a name="nat1.3"></a>
<b>Configuration</b>

<p>
This is how the computers are setup concerning this document. Your setup will vary from this, but 
the purpose of the document is to give you an overview so you can conform this information to your setup.
</p>

<ul>
<b>Computer Operating System: </b>OpenBSD v2.7 i386<br>
<br>
<b>NICs: </b>
<ul>
	NetGear 10/100MB <b>dc0</b><br>
	Connected to the EXTERNAL LAN (or WAN)<br>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<br>
	NetGear 10/100MB <b>dc1</b><br>
	Connected to the INTERNAL LAN<br>
	<b>IP Address: </b>192.168.1.1<br>
	<b>Netmask: </b>255.255.255.0<br>	
</ul>
<br>
<b>External, Internet-routeable IP (provided by ISP, in this example, a cable modem provider)<br></b>
<ul>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<b>Gateway: </b>24.5.0.1<br>
</ul>
<br>
<b>Local Area Network</b><br>
<ul>
In this example,
machines on the LAN use the IP addressing scheme 192.168.1.xxx
(where xxx is a unique number). There are a variety of different
operating systems on the internal LAN including Windows 98,
Windows NT, OpenBSD and Linux. Each machine is connected to a hub
that is designated for internal use. For this document and its
examples the client on the LAN will assume IP address 192.168.1.40
</ul>
<br>
<b>Diagram of Configuration</b>
<ul><pre>
+-----+              +---------+         +----------+
| Hub |--------- dc1 |   NAT   | dc0 ----| Internet |
+-----+              +---------+         +----------+
  | |
  | +-- Client A
  +---- More clients 

                              +-------------------------+
                              |          LEGEND         |
                              +-------------------------+
                              |  NIC dc0 - 24.5.0.5     |
                              |  NIC dc1 - 192.168.1.1  |
                              | Client A - 192.168.1.40 |
                              +-------------------------+

</pre></ul>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Network Address Translation</u></h3>
<br>

<a name="nat2.1"></a>
<b>Introduction to NAT</b>

<p>
As more and more businesses and users get on the Internet, each one
must have an IP address. Public IP addresses are becoming harder and
harder to get. The solution for a lot of people has been Network
Address Translation (or "NAT"). NAT is a very simple, yet powerful way
to get your LAN connected to the Internet without having to purchase
or lease IP addresses for each machine. NAT is also known as "IP
Masquerading" if you're a Linux user.
</p>

<p>
When NAT is up and running correctly, it allows users on the internal
LAN to access the Internet through a different IP address (the one you
set up with your provider). Each machine on the LAN uses the one IP
address (transparently) of the one machine that is set up to use the
ISP assigned IP address.
</p>

<p>
The way NAT works is amazingly simple. When a client on the LAN
wants to connect to a machine on the Internet, it sends out a TCP
packet with a request to connect. Inside the TCP packet header is the
client's IP address (i.e. 192.168.1.40) and the requested host's IP
address (i.e. 123.45.67.89). The machine running NAT intercepts this
TCP packet and changes the client's IP address from 192.168.1.40 to
the IP address of the Internet-connected machine (i.e. 24.5.0.5). This
effectively tricks the host machine into thinking the actual connection
is from the NAT machine, not the actual client's machine. The host then
sends back responses to the NAT machine like it was the one connecting.
When the NAT machine receives the responses it quickly translates the
destination IP address back from itself to the client's machine and
sends the packet to the client. The client didn't have any idea of
what happened and spoofed Internet connectivity is totally transparent.
</p>

<p>
The example below shows NAT a little more clearly:
</p>

<ul><pre>
Client ----------------- dc1 [ NAT ] dc0 ---------- Internet Host
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

OUTGOING TCP Packet                     OUTGOING TCP Packet
From: 192.168.1.40  &gt;&gt;=== NAT ===&gt;&gt;     From: 24.5.0.5
To: 123.45.67.89                        To: 123.45.67.89

INCOMING TCP Packet                     INCOMING TCP Packet
From: 123.45.67.89 			From: 123.45.67.89
To:   192.168.1.40  &lt;&lt;=== NAT ===&lt;&lt;     To: 24.5.0.5
</pre></ul>

<br>
<a name="nat2.2"></a>
<b>Why to use NAT</b>

<p>
When presented with a cable modem in my new apartment I was also
presented with another minor problem. How to get Internet access to
my roommates, when the cable modem resides in my room? There were a
few options I could implement ranging from obtaining extra IP
addresses, to setting up a proxy server, to setting up NAT.
(Don't let the cable modem example fool you.  NAT is powerful enough
to masquerade a large network with hundreds or even thousands of computers!)
</p>

<p>
There are many reasons why I wanted to set up NAT. The number one
reason is for saving money. There
are two roommates in my house (each with their own PC) and myself with
3 computers. My ISP only allows for three IP addresses per household.
This means that there weren't enough IPs to allow every machine
internet access.
</p>

<p>
By using NAT each machine will have a unique (internal) IP address
but share the one IP address given to me by my ISP. The cost goes down.
</p>

<br>
<a name="nat2.3"></a>
<b>Setup</b>

<p>
In order to enable NAT on your OpenBSD machine you will need to turn on
IPF and NAT. This is easily accomplished by editing the files listed
below (make the changes to the file so it looks like the options below):
</p>

<p>
<b>/etc/rc.conf</b> (this file used to start services at boot time)
</p>

<ul>
	ipfilter=YES<br>
	ipnat=YES
</ul>

<p>
<b>/etc/sysctl.conf</b>
</p>

<ul>
	net.inet.ip.forwarding=1
</ul>

<p>
After these changes are made, the machine is now ready to for the
configuration of NAT.
</p>

<br>
<a name="nat2.4"></a>
<b>Configuration</b>

<p>
The first step is to configure the IPF rules file (<i>/etc/ipf.rules</i>).
For the purposes of this document we will allow traffic to pass
through this firewall option without any interference. The file
should look like this:
</p>

<ul><pre>
pass in from any to any
pass out from any to any
</pre></ul>

<p>
Again for more information you can read <a href="#6.2">FAQ 6.2</a>
</p>

<p>
The NAT configuration file (<i>/etc/ipnat.rules</i>) has a very simple syntax.
For the configuration set forth above, the file should contain the
following entry:
</p>

<ul><pre>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32
</pre></ul>

<p>
Here is an explanation for the above lines.
</p>

<ul>
<strong>"map"</strong>
<p>
This is the command you are giving ipnat. It is telling ipnat
that this entry is an entry to change IP addresses between the LAN
and the Internet.
</p>
</ul>

<ul>
<strong>"dc0"</strong>
<p>
This is the network interface that is connected to the Internet.
</p>
</ul>

<ul>
<b>"192.168.1.0/24"</b>
<p>
the IP address and netmask (the netmask is in
CIDR format). Combined they state "any IP address of value
192.168.1.1 through 192.168.1.254" should be mapped. If you would
prefer not to use CIDR notation you can substitute "/24" for
"/255.255.255.0".
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
This IP address and netmask state the IP address
that the LAN IP addresses will be mapped to.  /32 means one single
IP address.  You can also map to a /24, or 256 IP addresses (or a /27,
or whatever number of bits you'd like)!! This is
useful if you have several thousand client machines behind your NAT....
(Of course, this is only useful if that /24 is being routed to your OpenBSD
box!)
</p>
</ul>

<ul>
<b>"portmap tcp/udp 10000:60000"</b>
<p>
This maps all tcp/udp packets
to ports in the range of 10000 to 60000.
</p>
</ul>

<p>
The second line has almost the same entry except for the last portion.
This tells ipnat to map anything else (not tcp/udp, those packets are already
matched by the first line) to whatever port
it requests (used for ICMP, and other protocols). Once this
is in the file, all that's needed is to run the IPF daemon.
</p>

<br>

<a name="nat2.5"></a>
<b>Selective NAT</b>

<p>
You might want to prevent NAT to some range of addresses on the outside.
Continuing the example above, suppose that there are hosts on the 24.5.0.0/28
network for which you would like your NAT gateway to act as a simple router,
without address translation.
You can suppress address translation for traffic going from dc0 to this subnet
with the following:
</p>

<ul><pre>
map dc0 from 192.168.1.0/24 ! to 24.5.0.0/28 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 from 192.168.1.0/24 ! to 24.5.0.0/28 -&gt; 24.5.0.5/32
</pre></ul>

<a name="nat2.6"></a>
<b>Running</b>

<p>
Executing NAT is a very simple process also. Once the configuration is
complete, there are two ways to enable NAT. The first (and best way if
possible-to test the setup stage) is to reboot your OpenBSD machine.
This is accomplished with the command "<i>reboot</i>"
</p>

<p>
If you would like to run ipnat from the command line, use the following
commands:
</p>

<ul><pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre></ul>

<p>
The first line is to enable IPF (remember that NAT piggy-backs on IPF
therefore IPF must be initialized and running before NAT can be loaded).
The options on the command line "-Fa" clear out any existing entries
already in effect. "-f /etc/ipf.rules" tells ipf where the rules file
can be found. "-E" is the switch to enable the IPF daemon.
</p>

<p>
The second command line is to enable NAT. "-CF" clears and flushes all

existing entries in the NAT table. "-f /etc/ipnat.rules" tells NAT where

the NAT rules file is at. NAT is now running. It's as simple as that.
</p>


<p>
<b>Note:</b> in order to reload the NAT settings (in case you edit the file
but don't want to reboot) just execute the 2nd command over again. The
settings will be flushed and reloaded.
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 Nat Knowledge Base</u></h3>

<br>
<a name="nat3.1"></a>
<b>Checking NAT Status</b>

<p>
To find out how NAT is doing or make sure the settings have taken
effect, you use the "-l" option. This option will list all the
settings and current sessions that ipnat is running:
</p>

<ul><pre>
# <b>ipnat -l</b>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32

List of active sessions:
MAP 192.168.1.40  2473  &lt;- -&gt; 24.5.0.5  13463 [129.128.5.191 80]
</pre></ul>

<p>
The purpose of the first two lines is to confirm the settings that
were entered in /etc/ipnat.rules earlier. The line(s) below will show
you a list of the current NAT controlled connections.
</p>

<ul>
<b>"MAP 192.168.1.40  2473"</b>
<p>
This tells you the IP address of the
machine on the LAN that is using NAT. The port number used to make
the connection is displayed afterwards.
</p>
</ul>

<ul>
<b>"&lt;- -&gt;"</b>
<p>
This shows that NAT is handling the flow of traffic
in both directions.
</p>
</ul>

<ul>
<b>"24.5.0.5  13463"</b>
<p>
This denotes that the connection is going
to the Internet via IP address 24.5.0.5 and using port 13463.
</p>
</ul>

<ul>
<b>"129.128.5.191 80"</b>
<p>
The IP address and the port being connected
to are listed last.
</p>
</ul>

<a name="nat3.2"></a>
<b> Limitations of NAT (in FTP)</b>

<p>
There are a few limitations of NAT. One is with FTP. When a user connects
to a remote FTP server and requests information or file, the FTP server
will make a connection to the client and transfer the info. This is done
on a random free port. This is a problem for users attempting to gain
access to FTP servers from within the LAN. When the FTP server sends its
information it sends it to the external NIC at a random port. The NAT
machine will receive this, but because it has no mappings for the unknown
packet and doesn't have any mappings for that port, it will drop the
packet and won't deliver it.

<p>
The solution to this is to place yourself in "passive mode" in your
FTP client. This will tell the server that you want to connect to the
server, and not what you just read. Then when you make that connection out
NAT will correctly handle your connection.
<P>
IP Filter provides another solution for this situation,
that is, an ftp proxy which is built-in to the NAT code.
To activate it, put something like this before your other NAT mappings.
<PRE>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 proxy port ftp ftp/tcp
</pre>
With this in place, the kernel will watch your FTP connections
for the "PORT" command coming from the ftp client, and it will
replace the IP address and port with it's own outside IP address, and a port
of its own choosing.  Then it will open up that port and tunnel the
data to the port your ftp client asked for.  Obviously, this is slightly
more resource intensive.  But, unless your NAT/IP Filter box is reaching
critical mass, you should be fine.
<P>


<br>
<a name="nat3.3"></a>
<b>Redirecting Traffic</b>

<p>
        At times you may need to redirect incoming or outgoing traffic for
        a certain protocol or port. A good example of this is if there were a
        server residing inside the LAN running a web server. Incoming connections
        to your valid Internet IP will find that unless your NAT box is running
        a web server, no connection can be made. For this purpose we use the
        NAT 'rdr' directive in the rules file to instruct where to redirect
        (or route) a particular connection to.
</p>

<p>

        For our example, lets say a web server resides on the LAN with IP address
        of 192.168.1.80. The NAT rules file needs a new directive to handle this.
        Add a line similar to the following one to your ipnat.rules:
</p>

<ul><pre>
rdr dc0 24.5.0.5/32 port 80 -&gt; 192.168.1.80 port 80
</pre></ul>

<p>
The reason for each line is this:
</p>

<ul>
<b>"rdr"</b>
<p>
This is the command you are giving ipnat. It is telling ipnat
that this entry is an entry to redirect a connection. 
</p>
</ul>


<ul>
<b>"dc0"</b>
<p>
This is the network interface that is connected to the Internet.
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
This means an incoming connection to this IP address (only on dc0, as above)
</p>
</ul>

<ul>
<b>"port 80"</b>
<p>
This is the port (80) that should be redirected. The number
"80" didn't have to be used. You can use "port www" also to specify
a redirection of port 80. If you would like to use a name instead of
a number, the service name and corresponding port, must exist in the
file /etc/services.
</p>
</ul>

<ul>
<b>"192.168.1.80"</b>
<p>
The IP address and netmask of the LAN machine
which the packets are redirected to. The netmask is always "/32"
(and therefore not needed to be specified) so
the packets can be redirected to a particular machine.
</p>
</ul>

<p>
When the addition is complete reload the NAT rules, and the redirection
will start immediately.
</p>

<br>
<a name="nat3.4"></a>
<b>NAT versus Proxy</b>

<p>
The difference between NAT and an application-based proxy is that the proxy
software acts as a middle-man between the Internet and the machines connected
on the LAN. This is fine, however each application you want to run on
your machine and connect to the Internet through the proxy server MUST
be proxy-aware (be able to use a proxy server). Not all applications are
able to do this (especially games). Furthermore, there simply are not
proxy server applications for all of the Internet services out there.
NAT transparently maps
your internal network so that it may connect to the Internet.  The only
security advantage to using a proxy software over NAT is that the proxy
software may have been made security aware, and can filter based on content,
to keep your Windows machine from getting a macro virus, it can protect
against buffer overflows to your client software, and more.  To maintain
these filters is often a high-maintenance job.
</p>

<a name="nat4.0"></a>
<b>6.3.4 Links and X-References</b>

<p>
OpenBSD files:
<ul>
<li>/etc/ipnat.rules - NAT rules file
<li>/etc/rc.conf - need to edit to start up ipnat and ipf at boot time
<li>/etc/sysctl.conf - need to edit to enable IP forwarding
<li>/usr/share/ipf/nat.1 - samples of ipnat.rules
</ul>
</p>

<p>
NAT Internet Links:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=5&manpath=OpenBSD+2.7">Man page showing correct ipnat.rules syntax</a>
<li><a href="http://coombs.anu.edu.au/~avalon/">http://coombs.anu.edu.au/~avalon/</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>







<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq6.html">[Back To Section 6.0]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faqipf.html,v 1.2 2002/01/21 20:28:26 nick Exp $</small>
</p>
</body>
</html>
