<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Konfiguracja dysku</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[Spis tre¶ci]</a>
<a href= "faq12.html">[Do sekcji 13 - Multimedia]</a>
<a href= "faq15.html">[Do sekcji 15 - Pakiety i Porty]</a>
</font>

<h1><font color="#e00000">14 - Konfiguracja dysku</font></h1>

<!--
UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Uwaga:</font></b>Zawarto¶æ tego pliku
jest ju¿ bardzo nieaktualna w stosunku do
<a href="../faq14.html">bie¿±cej wersji anglojêzycznej</a>.

<p>
Je¶li chcesz pomóc w aktualizacji tego pliku, zajrzyj na
<a href="../../translation.html">stronê t³umaczeñ</a>.
-->

<hr>

<h3>Spis tre¶ci</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Program disklabel(8) w OpenBSD</a>
<li><a href="#fdisk"      >14.2 - Program fdisk(8) w OpenBSD</a>
<li><a href="#NewDisk"    >14.3 - Dodawanie nowych dysków w OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - Plik wymiany</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Jak wygl±da bootowanie OpenBSD?</a>
<li><a href="#LargeDrive" >14.7 - O czym nale¿y wiedzieæ u¿ywaj±c du¿ych 
                           dysków w OpenBSD?</a>
<li><a href="#InstBoot"   >14.8 - Instalacja bootbloku - tylko i386</a>
<li><a href="#Backup"     >14.9 - Zapobieganie katastrofie: archwizowanie 
                           i odtwarzanie z ta¶my.</a>
<li><a href="#MountImage" >14.10 - Montowanie obrazów dysków w OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - Pomocy! Otrzymuje komunikaty o b³êdach
                           podczas pracy z urz±dzeniami IDE DMA!</a>
<li><a href="#RAID"       >14.13 - Macierze RAID dla OpenBSD</a>
<li><a href="#NegSpace"       >14.14 - Dlaczego <tt>df(1)</tt> pokazuje, 
			    ¿e u¿ywam wiêcej ni¿ 100% dysku</a>
<li><a href="#OhBugger"   >14.15 - Przywracanie partycji po skasowaniu etykiety dysku</a>
<li><a href="#foreignfs"  >14.16 - Czy mogê dostaæ siê do danych na systemach plików
			    innych ni¿ FFS?</a>
<ul>
<li><a href="#foreignfsafter">14.16.1 - Partycje nie istniej± w moim disklabel! 
			    Co powinienem zrobiæ?</a>
</ul>
<li><a href="#flashmem"   >14.17 - Czy mogê u¿ywaæ pamiêci flash w OpenBSD?</a>

</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Program disklabel(8) w OpenBSD</h2>
<h3>Spis tre¶ci</h3>

<ul>
<li><a href="#disklabel.1">Co to jest disklabel(8)?</a>
<li><a href="#disklabel.2">disklabel(8) podczas instalacji OpenBSD</a>
<li><a href="#disklabel.3">Zastosowanie programu disklabel(8)</a>
</ul>

   
<a name="disklabel.1"></a>
<h3>Co to jest disklabel(8)?</h3>
  
<p>
Na pocz±tku proszê przeczytaæ stronê podrêcznika systemowego 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Etykiety dyskowe (ang. disklabels) tworzone s± po to, aby zapewniæ
efektywny interfejs pomiêdzy dyskiem, a znajduj±cym siê w j±drze systemu 
operacyjnego sterownikiem dysku. Etykiety zawieraj± informacje
o dysku, np. jego geometriê i systemy plików znajduj±ce siê na dysku.
Dane te s± wykorzystywane przez program ³adowania pocz±tkowego
(ang. bootstrap program) do zainicjowania dysku oraz do identyfikacji
systemu plików na dysku.  Etykiety dyskowe s± rownie¿ u¿ywane w po³±czeniu
z systemami plików do tworzenia bardziej wydajnych ¶rodowisk. Wiêcej na
ten temat mo¿na dowiedzieæ siê poprzez lekturê strony podrêcznika systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>.


<p>
Dodatkow± zalet± etykiet dyskowych jest fakt, ¿e pozwalaj± one omin±æ 
ograniczenia danej architektury w dziedzinie partycjonowania dysków.
Dla przyk³adu, w architekturze i386 mo¿na mieæ tylko 4 partycje 
podstawowe (czyli partycje, które inne systemy operacyjne, takie jak
Windows NT czy DOS bed± poprawnie rozpoznawaæ). Dziêki
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
na tylko jednej podstawowej partycji pomie¶ciæ mo¿na *wszystkie*
partycje systemu OpenBSD (np. 'swap', '/', '/usr' i '/var'). Dziêki
temu pozosta³e 3 podstawowe partycje dostêpne dla innych OS!


<a name="disklabel.2"></a>
<h3>disklabel(8) podczas instalacji OpenBSD</h3>

<p>
Jedn± z g³ównych czynno¶ci dokonywanych podczas instalacji
OpenBSD jest tworzenie etykiet. Krok ten nastêpuje po skonfigurowaniu
partycji programem <a href="#fdisk">fdisk(1)</a>.
Podczas instalacji u¿ywa siê etykiet dyskowych aby wskazaæ
punkty montowania. Mo¿na je ustawiæ z poziomu programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
ale nie jest to czynno¶æ obowi±zkowa, jako ¿e w nastêpnym kroku instalator
poprosi o potwierdzenie podanych ¶cie¿ek. Jednak wykonanie wszystkiego
ju¿ podczas edycji etykiety dysku programem disklabel(8) czyni instalacjê
nieco przyjemniejsz±.

<p>
Oczywi¶cie podczas pierwszego instalowania OpenBSD nie bêdzie jeszcze 
¿adnych etykiet. Nale¿y je stworzyæ. Pierwsz± etykiet±, jaka
powinna znale¼æ siê na dysku jest etykieta 'a'. POWINNA ona
identyfikowaæ partycjê '/'. O tym jakie partycje utworzyæ i jakie s±
zalecane minimalne wielko¶ci dla nich mo¿na przeczytaæ w rodziale 
<a href="faq4.html#SpaceNeeded">FAQ 4.7 Jak du¿o miejsca potrzeba aby
zainstalowaæ OpenBSD?</a>. Dla serwerów zaleca siê podzia³ dysku w sposób
tam podany. Dla u¿ytku domowego mo¿na stworzyæ tylko jeden punkt
 montowania - '/'. Deycduj±c siê na tylko jedn± partycje '/' 
(o etykiecie 'a') nale¿y pamiêtaæ o pozostawieniu TROCHÊ wolnego miejsca na
partycjê swap. Teraz, gdy ju¿ wyja¶nili¶my podstawy, przejdziemy do 
przyk³adu, pokazuj±cego w jaki sposób u¿ywaæ program disklabel(8) podczas
instalacji OpenBSD. Pierwszy przyk³ad zak³ada, ¿e OpenBSD
bêdzie jedynym systemem operacyjnym na danym komputerze oraz ¿e 
dokonywana bêdzie pe³na instalacja.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
W tym momencie mamy ju¿ stworzon± g³ówn± partycjê, zamontowan±
w <tt>/</tt>, oraz partycjê wymiany (swap) - obydwie o wielko¶ci 64 MB.
Proszê zauwa¿yæ, ¿e przeusniêcie (offset) pierwszej partycji w stosunku
do pocz±tku dysku wynosi 63 sektory. Oto w³a¶nie chodzi. OpenBSD 
pokazuje wielko¶æ w sektorach, jednak nie trzeba wpisywaæ wielko¶ci
w tym formacie. Jak widaæ w powy¿szym przyk³adzie, akceptowane s±
wpisy w stylu <i>64 Megabytes = 64M</i> oraz <i>2 Gigabytes = 2G</i>.
Program disklabel zaokr±gli te wielko¶ci do najbli¿szego cylindra. W
opisanej sytacji widaæ tak¿e, ¿e OpenBSD zak³ada, i¿ etykieta 'b'
okre¶la partycjê wymiany. Jest tak, poniewa¿ j±dro GENERIC szuka
partycji wymiany w³a¶nie pod etykiet± 'b' i nie nale¿y tego zmieniaæ.

<p>
W nastepnym przyk³adzie stworzymy dwie kolejne etykiety. To jeszcze
nie bêdzie pe³na instalacja, jako ¿e ich rozmiar nie bêdzie 
wystarczaj±cy dla wszystkich plików systemu OpenBSD. Pozosta³e partycje
tworzy siê analogicznie, wiêc nie ma potrzeby udzielania dodatkowych
wyja¶nieñ.

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
Uwa¿ny Czytelnik dostrze¿e zapewne dwie rzeczy. Po piewsze, dla ka¿dej 
nowo tworznej partycji offset obliczany jest automatycznie, zatem w ogóle
nie trzeba go wyliczaæ czy zmieniaæ. Po drugie, etykieta 'c' zosta³a
pominiêta. Sta³o siê tak dlatego, i¿ reprezentuje ona ca³y dysk i nie
powinno siê jej u¿ywaæ.

<p>
Gdy ju¿ utworzymy etykiety, nale¿y je jeszcze zapisaæ na dysk. Nastepnie
mo¿na ju¿ kontynuowaæ proces instalacji. Aby zachowaæ wszystkie zmiany
oraz opu¶ciæ program disklabel(8) (ale kontynuowaæ instalacjê) wpisujemy:

<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>
<a name="disklabel.3"></a>
<h3>Zastosowanie programu disklabel(8)</h3>

<p>
Po instalcji systemu nie powinno byæ zbyt wiele okazji na u¿ywanie
disklabel(8). Czasem jednak mo¿e zaj¶æ taka konieczno¶æ, w przypadku 
dodawania, usuwania czy restrukturyzacji dysków. Jedn± z pierwszych
rzeczy, jak± wykonuje siê przy ka¿dej pracy z disklabel(8) jest
wy¶wietlenie obecnej etykiety dyskowej. Mo¿na to zrobiæ wpisuj±c po prostu:

<pre>
# <b>disklabel wd0</b> &gt;----- albo jakiekolwiek inne urz±dzenie 

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
Powy¿sze polecenie pozwala obejrzeæ istniej±c± etykietê dysku, bez 
zmieniania czegokolwiek. Aby móc wprowadzaæ zmiany, nale¿y u¿yæ flagi
<tt>-E</tt>. Przyk³ad:

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
Pojawi siê znak zachêty, taki sam, jak podczas instalacji OpenBSD.
Prawdopodobnie najwa¿niejszym poleceniem jest tutaj '?'. Wy¶wietli
ono listê wszystkich dostêpnych komend. Stronê podrêcznika systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
mo¿na wy¶wietliæ poleceniem 'M'. W tym momencie mo¿na dodawaæ, usuwaæ
i zmieniaæ partycje. Szczegó³owy opis poleceñ dostêpny jest na stronie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<a name="fdisk"></a>
<h2>14.2 - Program fdisk(8) w OpenBSD</h2>

Na pocz±tku proszê przeczytaæ stronê podrêcznika systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.

<p>
fdisk jest programem s³u¿±cym do zarz±dzania partycjami. Podczas
instalacji przy pomocy fdisk tworzy siê partycjê OpenBSD (która
pó¼niej podzielona jest na <u>kilka</u> etykiet, zawieraj±cych
systemy plików/partycjê wymiany/itd.). fdisk mo¿e podzieliæ
dysk na partycje i ustawiæ jedn± z nich jako aktywn±. U¿ywa
siê go najczê¶ciej w trybie jednego u¿ytkownika (boot -s). fdisk 
umo¿liwia tak¿e utworzenie MBR na dyskach.

<p>
Podczas instalacji najczê¶ciej tworzy sie tylko <b>JEDN¡</b> partycjê
OpenBSD, a nastêpnie przy pomocy disklabel dzieli siê j± na etykiety
zawieraj±ce systemy plików i partycjê wymiany.

<p>
Tablicê partycji mo¿na wy¶wietliæ przy pomocy nastêpuj±cego polecenia:

<pre># <b>fdisk sd0</b><br>
</pre>

<p>
Wynik dzia³ania bêdzie podobny do tego przedstawionego poni¿ej:

<pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre>

<p>
W powy¿szym przyk³adzie pokazana jest tablica partycji pierwszego
dysku SCSI. Jak mo¿na zauwa¿yæ jest tam partycja OpenBSD (A6).
Gwiazdka (*) przy jej opisie oznacza, ¿e jest ona aktywna.

<p>
W poprzednim przyk³adnie wy¶wietlili¶my tylko informacje o partycjach.
A co je¶li chcemy zmieniæ tablicê partycji? S³u¿y do tego opcja <b>-e</b> -
uruchomi ona program fdisk w trybie interaktywnym.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p> 
Absolutnie bezpieczne w progamie fdisk jest jego uruchomienie, obejrzenie
dostêpnych opcji, udzielenie odpowiedzi <b>N</b> na pytania i *NIE U¯YWANIE*
polecenia <b>write</b>.

<p>
Poni¿ej znajduje siê przegl±d poleceñ dostêpnych dla trybu interaktywnego:

<ul>
<li><b>help</b>   Wy¶wietla listê wszystkich komend trybu interaktywnego.
<li><b>reinit</b> Tworzy now± tablicê partycji, zawieraj±ca jedn± partycjê
                  OpenBSD oznaczon± jako aktywn±.
<li><b>disk</b>   Wy¶wietla geometriê dysku rozpoznan± przez program fdisk.
                  Istnieje mo¿liwo¶æ zmiany parametrów, które wykry³ fdisk.
<li><b>setpid</b> Pozwala na zmianê typu partycji. To polecenie jest
                  u¿yteczne w przypadku przydzielenia istniej±cej partycji
                  dla OpenBSD.
<li><b>edit</b>   Edycja partycji (wszystkie zmiany przeprowadzane s± na
                  kopii tablicy partycji w pamiêci, a nie bezpo¶rednio na
                  dysku). Podczas zmiany jako jednostek mo¿na u¿yæ geometrii
                  BIOS-u lub przesuniêcia i rozmiaru podanego w sektorach.
<li><b>flag</b>   Ustawia partycjê jako aktywn±. Tylko jedna partycja mo¿e
                  mieæ ustawion± t± flagê.
<li><b>update</b> Uaktualnienie "machine code" w kopii akutalnie wybranego
                  bootbloku.
<li><b>select</b> Wybór i za³adowanie do pamiêci tablicy partycji partycji
                  rozszerzonej.
<li><b>print</b>  Wy¶wietla tablicê partycji. 
<li><b>write</b>  Zapisuje zmiany z kopii tablicy partycji w pamiêci komputera
                  na dysk. Zostaniesz poproszony o potwierdzenie tej operacji.
<li><b>exit</b>   Przej¶cie z edycji boot bloku wybranego poleceniem
                  <tt>select</tt> do edycji poprzedniej tablicy partycji,
                  je¶li taka nie istnieje, nast±pi wyj¶cie z programu.
<li><b>quit</b>   Polecenie analogiczne do polecenia <tt>exit</tt> z t±
                  ró¿nic±, ¿e wszystkie zmiany zapisane zostaj± na dysk.
<li><b>abort</b>  Wyj¶cie z programu bez zapisania tablicy partycji.
</ul>

<a name="NewDisk"></a>
<h2>14.3 - Dodawanie nowych dysków w OpenBSD</h2>

<p>
Programy potrzebne do <b>PRAWID£OWEJ</b> instalacji dysku w OpenBSD to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>tylko i386</i>) i
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Na platformie i386 pracê rozpoczyna siê od narzêdzia fdisk(8). Posiadacze
innych architekutr mog± zignorowaæ ten krok. Poni¿ej opisane bêdzie
dodanie trzeciego dysku SCSI do systemu.

<pre>
# <b>fdisk -i sd2</b>
</pre>
To polecenie zaincjalizuje tablicê partycji. Stworzona zostanie tylko
jedna partycja, obejmuj±ca ca³y dysk i przeznaczona dla OpenBSD.
W nastêpnym kroku nale¿y utworzyæ etykietê dysku. Ta czyno¶æ mo¿e
wydawaæ siê nieco zagmatwana.

<pre>
# <b>disklabel -e sd2</b>

<i>(screen goes blank, your $EDITOR comes up)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

Po pierwsze, nie nale¿y zmieniaæ partycji 'c' - opisuje ona ca³y dysk i
jest niezbêdna do prawid³owej pracy disklabel.
£±czna liczba sektorów odpowiada liczbie sektorów na dysku. Dysk
ma 3 GB. Trzy gigabajty wed³ug producentów dysków to 3000 MB. Dziel±c
6185088 przez 3000 (mo¿na wspomóc siê programem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1)</a>)
otrzymasz 2061. Aby obliczyæ wielko¶æ w sektorach dla partycji a, d,
e, f, g, ... wystarczy pomno¿yæ ¿adany rozmiar w megabajtach przez 2061.
Offset dla pierwszej partycji powinien byæ taki sam jak pokazana
wcze¶niej warto¶æ <tt>sector/track</tt>. W tym przypadku bêdzie to
63. Przesuniêcie ka¿dej nastêpnej partycji winno byæ sum± przesuniêcia
i rozmiaru partycji j± poprzedzaj±cej (wyj±tkiem jest etykieta 'c', która
nie bierze udzia³u w takim wyrównywaniu).

<p>
W sytacji gdy na dysku ma byæ tylko jedna partycja, np. zamierzasz u¿ywaæ jej
do przechowywania stron WWW lub katalogów domowych u¿ytkowników, wystarczy
od ca³kowitego rozmiaru dysku odj±æ ilo¶æ sektorów przypadaj±cych na jedn±
¶cie¿kê (w tym przypadku 63), tak wiêc 6185088 - 63 = 6185025. A ostateczny
wygl±d etykiety dysku bêdzie przedstawia³ sie nastêpuj±co:

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>Je¶li to wszystko wydaje siê zbyt skomplikowane, mo¿na u¿yæ
opcji <tt>-E</tt> programu <tt>disklabel</tt>, a uruchomi siê on
w takim samym trybie jak podczas instalacji systemu!</b> W tym trybie
mo¿na u¿ywaæ oznaczeñ takich jak "96M" do okre¶lenia "96 megabajtów".
(Je¶li twój dysk jest wystarczaj±co du¿y mo¿na u¿yæ "96G" do okre¶lenia
96 gigabajtów!). Na nieszczê¶cie tryb <tt>-E</tt> u¿ywa geometrii BIOS-u,
a nie prawdziwej geometrii dysku, a w bardzo wielu przypadkach nie jest
to zupe³nie to samo. By omin±æ to ograniczenie i u¿ywaæ geometrii dysku 
wpisz 'g d'. (Innymi opcjami sa 'g b' - geometria zgodnie z BIOS-em oraz
'g u', czyli po prostu to, co "label" mial ustawione przed
dokonaniem jakichkolwiek zmian przez disklabel.)

<p>
Zosta³o zrobione ju¿ du¿o, ale to jeszcze nie koniec. Nale¿y jeszcze utworzyæ
system plików na partycjach u¿ywaj±c do tego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
Oczywi¶cie parametr dla tej komendy zale¿ny jest od tego jak dyski s±
nazywane i numerowane przez OpenBSD. (Spojrz na wynik dzia³ania polecenia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
aby dowiedzieæ siê jak nazywaj± siê dyski w twoim systemie.)

<p>
Teraz mo¿na ju¿ zamontowaæ nowoutworzon± partycjê. Punktem montowania bêdzie
katalog <tt>/u</tt>. Tak wiêc, najpierw nale¿y za³o¿yæ katalog <tt>/u</tt>,
a dopiero pó¼niej zamonotwaæ partycjê.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Je¶li wszystko posz³o sprawnie mo¿na dopisaæ now± partycjê do 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>.

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
Je¶li chcesz przenie¶æ istniej±cy katalog, jak np. /usr/local na now± partycjê
wystarczy zamontowaæ nowy system plików w katalogu /mnt i u¿yæ polecenia
<tt>cpio -pdum</tt>. Zawarto¶æ /usr/local zostanie przeniesiona do /mnt.
W pliku
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
nale¿y zaznaczyæ, ¿e /usr/local jest teraz na partycji /dev/sd2a.

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Uruchom komputer w trybie jednego u¿ytkownika (<b>boot -s</b>), przenie¶
istniej±cy katalog /usr/local do /usr/local-backup (lub po prostu go
skasuj, je¶li uwa¿asz siê za szczê¶ciarza) i stwórz pusty katalog
/usr/local. Uruchom komputer ponownie, i voila, pliki s± na swoim miejscu!

<a name="SwapFile"></a>
<h2>14.4 - Plik wymiany</h2>

<p>
(Uwaga: je¶li szukasz dodatkowej przestrzeni wymiany poniewa¿ otrzymujesz
komunikat &quot;brak pamiêci wirtualnej&quot; (ang. &quot;virtual memory
exhausted&quot;), powniniene¶ najpierw spróbowaæ ograniczyæ jej
zu¿ycie przez procesy przy pomocy poleceñ
<tt>csh</tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>,
lub <tt>sh</tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>.)

<p>
Korzystanie z pliku wymiany nie wymaga specjalnych opcji przy kompilacji
kernela. Istnieje jeszcze druga metoda, która wymaga zmian w j±drze.
Ten dokument opisze oba sposoby.

<h3>Plik wymiany</h3>

<p>
Wymiana do pliku jest najprostszym i najszybszym sposobem na zdobycie
dodatkowej pamiêci wirtualnej. Plik, który bêdzie wykorzystywany do tego
celu, nie mo¿e znajdowaæ siê na partycji wykorzystuj±cej SoftUpdates
(domy¶lnie jest to wy³±czone). Zanim zaczniesz przygotowywaæ plik wymiany
mo¿esz chcieæ zobaczyæ jak du¿o pamiêci wirtualnej posiadasz i jak
du¿o jest aktualnie wykorzystywane. S³u¿y do tego polecenie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">
swapctl(8)</a>.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
Powy¿sza komenda wy¶wietla wszystkie urz±dzenia wykorzystywane jako pamiêæ
wirtualna oraz podstawowe statystki ich dotycz±ce. W tym przyk³adzie jest
tylko jedno urz±dzenie nazwane &qout;swap_device&quot; - to partycja
wymiany (na etykiecie dysku oznaczona liter± <tt>b</tt>). Jak mo¿na
zauwa¿yæ przestrzeñ wymiany nie jest wykorzystywana jednak, na potrzeby tego
dokumentu, utorzymy dodatkowe 32 MB pamiêci wirtualnej.

<p>
Pierwszym krokiem, niezbêdnym do wykorzystania pliku jako pamiêci wirtualnej
jest utworzenie tego pliku. Najlepszym narzêdziem do tego bêdzie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Oto przyk³ad stworzenia pliku <t>/var/swap</i> o rozmiarze 32 MB.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Kiedy plik bêdzie gotowy nale¿y oznaczyæ go jako dodatkow± przestrzeñ
wymiany. U¿yj poni¿szych poleceñ aby dodaæ do systemu plik jako urz±dzenie
pamiêci wirtualnej.

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
Teraz nale¿y siê upewniæ czy dodatkowa pamiêæ wirtualna jest dostêpna.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Po prawid³owym utworzeniu i skonfigurowaniu pliku wymiany mo¿na umie¶ciæ 
odpowiedni wpis w <i>/etc/fstab</i> aby przy ka¿dym starcie systemu
automatycznie w³±czyæ wykorzystanie dodatkowej pamiêci wirtualnej.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>Plik wymiany poprzez urz±dzenie vnode</h3>

<p>
Opisana poni¿ej metoda jest trwa³ym sposobem na dodatkow± pamiêæ wirtualn±.
Po pierwsze nale¿y przygotowaæ j±dro z urz±dzeniem vnd0c jako plikiem
wymiany. Je¶li na wd0a znajduje siê g³ówny system plików, a wd0b jest
dotychczas wykorzystywan± partycj± wymiany, wystarczy zmieniæ jedn±
liniê w pliku konfiguracyjnym kernela, w sposób pokazany poni¿ej, a nastêpnie
skompilowaæ j±dro:

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
Po odpowiednim przygotowaniu j±dra, niezbêdne bêdzie utorzenie pliku wymiany.
Pos³u¿ymy siê w tym celu identycznym poleceniem jak w poprzednim przyk³adzie.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Nastêpnie nale¿y umie¶ciæ odpowiedni wpis w pliku <i>/etc/fstab</i>.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
W tym momencie niezbêdne jest ponowne uruchomienie komputera, tak
aby wykorzystywa³ ju¿ nowe j±dro. Po tym przychodzi czas na konfiguracjê
urz±dzenia wymiany. Wykonuje siê to przy pomocy narzêdzia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
Ostatni krok polega na w³±czeniu dodatkowej pamiêci wirtualnej. Wykorzystamy
do tego, podobnie jak w poprzednim przyk³adzie, polecenie swapctl(8).
Po wszystkim, komend± <tt>swapctl -l</tt> warto sprawdziæ czy wszystko
przebieg³o zgodnie z naszym ¿yczeniem.

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>


<p>
Soft Updates, w swej pierotnej wersji, zosta³o opracowane przez
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a> dla FreeBSD,
który bazowa³ na ideii wysnutej przez
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
i Yale Patt</a>.
SoftUpdates narzuca konieczno¶æ uprzedniego zamówienia operacji w buforze
pamiêci podrêcznej co pozwala zrezygnowac z kodu FFS odpowiedzialnego za
synchroniczne zapisywanie wpisów katalogow. Dzieki temu daje siê zauwa¿yæ
bardzo du¿y przyrost wydajno¶ci dla operacji zapisu.

<p>
Aby korzystaæ z dobrodziejstw Soft Updates, j±dro musi mieæ wkompilowan± ich
obs³ugê:

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
Kernel GENERIC ma t± opcjê w³±czon±.

<p>
Soft Updates w³±czane jest podczas montowania systemów plików. Montuj±c
partycjê poleceniem  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a> 
nale¿y zaznaczyæ, ¿e chcemy korzystaæ z Soft Updates.
Poni¿ej znajduje siê przyk³adowy wpis w pliku
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
pokazuj±cy u¿ycie Soft Updates dla partycji <i>sd0a</i>.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Uwaga dla u¿ytkowników architektury <tt>sparc</tt>: Nie nale¿y w³±czaæ
Soft Updates na maszynach sun4 i sun4c. Pozwalaj± one na wykorzystanie
przez j±dro jedynie niewielkiej ilo¶ci pamiêci, przez co nie mog±
wykorzystywaæ Soft Updates. Problem ten nie dotyczy komputerów sun4m.
  
<a name="Boot386"></a>
<h2>14.6 - Jak wygl±da bootowanie OpenBSD?</h2>
Proces uruchamiania OpenBSD/i386 nie jest rzecz± banaln±, a zrozumienie jej
bêdzie pomocne przy rozwi±zywaniu ró¿norakich problemów. Bootowanie
OpenBSD sk³ada siê czterech g³ównych czê¶ci.
<ol>
<li><b><i>Master Boot Record (MBR):</i></b>
Master Boot Record jest to pierwszy fizyczny sektor (512 bajtów) dysku.
Zawarta jest w nim tablica partycji oraz niewielki program który ³aduje
PBR (ang. Partition Boot Record). Proszê zwróciæ uwagê, ¿e w niektórych
¶rodowiskach termin "MBR" u¿ywany jest do okre¶lenia jedynie czê¶ci, w której
zawarty jest kod ³aduj±cy, a nie ca³ego pierwszego bloku na dysku (w³±cznie
z tablic± partycji). Szczególnie istotne jest zrozumienia znaczenia
"inicjalizacji MBR" - co w terminologii OpenBSD oznacza nadpisanie od nowa
ca³ego sektora MBR, a nie tylko programu ³aduj±cego, jak to spotyka siê
w niektórych systemach operacyjnych. Nie jest to zbyt czêsto przeprowadzana
operacja. Zamiast tego czê¶ciej u¿ywa siê opcji "-u" programu fdisk(8)
("<tt>fdisk -u wd0</tt>").

<p>
Chocia¿ OpenBSD dostarcza w³asny MBR nie jest konieczne instalowanie go na
dysku - generalnie dowolny MBR jest w stanie za³adowaæ OpenBSD. Do
zarz±dzania MBR-em s³u¿y program fdisk(8), który u¿ywany jest zarówno do
edycji tablicy partycji, a tak¿e do instalacji kodu MBR na dysku.

<p>
MBR OpenBSD przy uruchomieniu wy¶wietla komunikat podobny do poni¿szego:
<pre>
    Using drive 0, partition: 3.
</pre>
Okre¶la on numer dysku oraz partycji z której zostanie za³adowany PBR.
Rzecz±, która rzuca siê w oczy jest kropka na koñcu powy¿szej linijki
(".") - oznacza ona, ¿e maszyna umo¿liwia bootowanie w trybie LBA. W
przypadku, gdy sprzêt nie pozwala na u¿ywanie translacji LBA, znak
kropki zostanie zast±piony ¶rednikiem (";"), który oznacza translacjê CHS:
<pre>
    Using Drive 0, Partition 3;
</pre>
Proszê zauwa¿yæ, ¿e ostatni znak w postaci kropki lub przecinka zosta³
wprowadzony w "nowym" MBR, dostêpnym od wersji OpenBSD 3.5.

<li><b><i>Partition Boot Record (PBR):</i></b>
Partition Boot Record w skrócie PBR, nazywany tak¿e 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(od kiedy plik o tej nazwie przechowuje program ³aduj±cy) jest to pierwszy
fizyczny sektor na partycji OpenBSD na dysku. PBR to "program ³aduj±cy
pierwszego poziomu". Sam PBR wczytywany jest do pamiêci przez kod znajduj±cy
siê w MBR, a jego zadaniem jest uruchomienie programu ³aduj±cego drugiego
poziomu -
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
Podobnie jak MBR, PBR jest bardzo ma³ym programem: kod i dane to nie wiêcej
jak 512 bajtów. Ta ilo¶æ nie wystarczy do stworzenia aplikacji obs³uguj±cej
system plików, tak wiêc umiejscowienie <tt>/boot</tt> na dysku, w miejscu
dostêpnym dla BIOS-u komputera, zakodowywane jest na sta³e w PBR podczas
jego instalacji.

<p>
Instalacja PBR odbywa siê przy pomocy programu
+<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>,
który szczególowo opisany jest <a href="faq14.html#InstBoot">w dalszej czêsci
tego dokumentu</a>.
Podczas uruchamiania PBR wy¶wietla komunikat podobny do poni¿szego:
<pre>
    Loading...
</pre>
wypisuj±c na ekranie kropkê wraz z ka¿dym odczytanym sektorem. Podobnie
jak w przypadku MBR, PBR zaznacza czy u¿ywa translacji LBA czy CHS. W
przypadku wykorzystania CHS, do powy¿szego komunikatu do³±czony jest
¶rednik:
<pre>
    Loading;...
</pre>
Poprzednie wersje (sprzed OpenBSD 3.5) wy¶wietlaj± komunikat "<tt>reading
boot...</tt>".

<li><b><i>Program £aduj±cy Drugiego Poziomu (ang. Second Stage Boot Loader)
 <tt>/boot</tt>:</i></b> <tt>/boot</tt> jest ³adowany przez PBR, a jego
zadaniem jest uzyskanie dostêpu do systemu plików OpenBSD, a nastêpnie
odszukanie i za³adowanie j±dra do pamiêci. Dziêki boot(8) mo¿liwe jest
tak¿e przekazanie ró¿nych opcji i informacji do kernela.

<p>
boot(8) jest programem interaktywnym. Po za³adowaniu przystêpuje on do
odczytania swojego pliku konfiguracyjnego <tt>/etc/boot.conf</tt> i wykonania
zawartych w nim poleceñ (domy¶lna instalacja OpenBSD nie tworzy jednak
takiego pliku). Je¶li brak pliku <tt>/etc/boot.conf</tt> lub zawarte
w nim polecenia nie za³aduj± j±dra OpenBSD, przed u¿ytkownikiem uka¿e siê
znak zachêty:

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.10
     boot>
</pre>

W tym momencie u¿ytkownik ma (w domy¶lnej instalcji) piêæ sekund aby wydaæ
polecenie inne polecenie, je¶li tego nie zrobi, boot(8) za³aduje j±dro
nazwane <tt>bsd</tt> znajduj±ce siê na g³ównej partycji pierwszego dysku
twardego. Program ³aduj±cy drugiego poziomu rozpoznaje sprzêt zainstalowany
w komputerze na podstawie danych odczytanych z BIOS-u (jako, ¿e j±dro
OpenBSD nie jest jeszcze za³adowane). Powy¿ej mo¿na zobaczyæ, ¿e boot(8)
odnalaz³:
<ul>
<li><b>pc0</b> - standartowa klawiatura oraz karta graficzna dla komputerów
i386.
<li><b>com0, com1</b> - dwa poty szeregowe.
<li><b>apm</b> - Funkcje zarz±dzania energi± (ang. Advanced Power Management).
<li><b>636k 190M</b> - Rozmiar dostêpnej konwencjonalnej (poni¿ej 1 MB)
oraz rozsze¿onej (powy¿ej 1 MB) pamiêci.
<li><b>fd0 hd0+</b> - Napêdy dysków - w tym przypadku jedna stacja
dyskietek oraz dysk twardy.
</ul>

Znak '+' po "hd0" oznacza, ¿e dostêp do dysku odbywa siê w trybie LBA.
Podczas pierwszej instalacji OpenBSD, mo¿na zauwa¿yæ znak '*' po symbolu
dysku twardego - oznacza to, ¿e na tym dysku nie znaleziono poprawnej
etykiety dysku.

<li><b><i>J±dro: <tt>/bsd</tt></i>:</b> celem bootowania jest za³adowanie
j±dra OpenBSD do pamiêci i poprawne uruchomienie go. W momencie gdy
j±dro znajdzie siê w pamiêci komputera OpenBSD zaczyna komunikowaæ siê
bezpo¶rednio ze sprzêtem bez pomocy BIOS-u.
</ol>

Poni¿szy przyk³ad przedstawia najczêstszy przebieg bootowania OpenBSD:
<blockquote><pre>
Using drive 0, partition: 3.                     <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.10
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2005 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.8 (GENERIC) #138: Sat Sep 10 15:41:37 MDT 2005
   ...
</pre></blockquote>


<h3>Jakie przeszkody mo¿na napotkaæ podczas bootowania OpenBSD/i386?</h3>
<ul>
<li><b>B³êdny lub niekompatybilny MBR:</b>
W najczêstszych przypadkach dysk posiada ju¿ jaki¶ MBR, zdarzyæ siê mo¿e
jednak, ¿e dysk jest zupe³nie nowy lub zosta³ przeniesiony z innej platformy
sprzêtowej, a na pytanie "Czy u¿yæ ca³y dysk" (ang. "Use entire disk") podczas
<a href="faq4.html#Disks">instalcji systemu</a> udzieli³e¶ odpowiedzi
przecz±cej mo¿e okazaæ siê, ¿e na dysku nie istnieje MBR, a tym samym
za³adowanie systemu nie jest mo¿liwe (pomimo tego, ¿e dysk posiada
prawid³ow± tablicê partycji).

<p>
Mo¿na zainstalowaæ OpenBSD MBR na dysku przy pomocy programu fdisk(8).
Wystarczy uruchomiæ system z medium instalacyjnego, wybraæ opcjê
"Shell", a po ukazaniu siê znaku zachêty wpisaæ:

<pre>
    # <b>fdisk -u wd0</b>
</pre>

Mo¿na równie¿ okre¶liæ jaki MBR ma byæ zapisany na dysku:
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre>

Powy¿sze polecenie spowoduje zapisanie pliku <tt>/usr/mdec/mbr</tt> jako
MBR na dysku. Ten plik jest standartowym MBR OpenBSD i jest on tak¿e
wbudowany w polecenie fdisk, ale nic nie stoi na przeszkodzie by w tym
miejscu wskazaæ inny, prawid³owy kod MBR.

<li><b>B³êdna lokalizacja <tt>/boot</tt> w PBR:</b>
Podczas instalacji Partition Boot Record, program installboot(8) zapisuje
numer bloku i offset iwêz³a w którym znajduje siê plik <tt>/boot</tt>. Tak wiêc
usuniêcie b±dz zamiamiana pliku <tt>/boot</tt> bez ponownego uruchomienia
<a href="faq14.html#InstBoot">installboot(8)</a> spowoduje, ¿e zabootowanie
systemu stanie siê niemo¿liwe, jako ¿e PBR spróbuje za³adowaæ z dysku dane,
które z pewno¶ci± nie s± programem ³aduj±cym drugiego poziomu.

Z racji tego, ¿e <tt>/boot</tt> jest ³adowany przy u¿yciu wywo³añ
BIOS-u, starsze wersje PBR by³y bardzo wra¿liwe na zmiany geometrii
dysku (np. przeniesienie napêdu z jednego komputera, u¿ywaj±cego
translacji CHS do drugiego, który wykorzystuje translacjê LBA, lub
nawet zmiana sposobu t³umaczenia geometrii dysku w BIOS-ie) spowoduje, ¿e
wg BIOS-u plik <tt>/boot</tt> znajdzie siê w zupe³nie innym miejscu dysku,
tak wiêc konieczne bêdzie wykorzystanie programu installboot(8) przed 
ponownym uruchomieniem systemu. Nowy PBR (dostêpny w OpenBSD 3.5 i
pó¼niejszych) jest bardziej tolerancyjny na zmiany translacji.
</ul>

Jako ¿e PBR jest bardzo ma³y, tak i komunikaty o b³êdach s± bardzo
lakoniczne i troche tajemnicze:
<ul>
<li><b>ERR</b> - BIOS zwróci³ b³±d podczas próby odczytu z dysku.
Najczê¶ciej oznacza to po prostu to, ¿e z dysku nie uda³o siê nic odczytaæ.
<li><b>ERR M</b> - nieprawid³owy magiczny numer (zobacz stronê podrêcznika
systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">
magic(5)</a>) odczytany z nag³ówka programu ³aduj±cego drugiego poziomu.
Zasadniczo oznacza to, ¿e cokolwiek zosta³o odczytane z dysku napewno
nie jest to <tt>/boot</tt>. Najczê¶ciej zwi±zane jest to ze niew³a¶ciwym
uruchomieniem programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8">installboot(8)</a>
lub plik <tt>/boot</tt> zosta³ zmieniony.
</ul>

Bardziej szczegó³owe informacje o procesie ³adowania OpenBSD/i386 mo¿na
znale¼æ w poni¿szych dokumentach:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
Dokument Hala Landisa pt. "How it Works".
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - O czym nale¿y wiedzieæ u¿ywaj±c du¿ych dysków w OpenBSD?</h2>

<p>
OpenBSD obs³uguje do 2<sup>31</sup>-1 (czyli 2,147,483,647) sektorów,
a poniewa¿ jeden sektor to 512 bajtów, otrzymamy odrobinê mniej ni¿ 1T.

</p><p>
Oczywi¶cie mo¿liwo¶ci systemu plików i mo¿liwo¶ci sprzêtu to dwie ró¿ne
sprawy. Nowy, 250 gigabajtowy, dysk IDE nie bêdzie pracowa³ ze starym 
(obs³uguj±cym napêdy &gt;137 GB) kontrolerem. Podobne problemy mog± 
dotyczyæ adapterów SCSI, czasem tak¿e niektóre starsze BIOS-y mog± 
odmówiæ wspó³pracy z nowymi du¿ymi dyskami.

<h3>Ograniczenia pojemno¶ci i rozmieszczenia partycji</h3>
Na nieszczê¶cie wszystkie mo¿liwo¶ci danego OS nie s± dostêpne zanim
zostanie on za³adowany do pamiêci. Podczas bootowania wykorzystywany
jest BIOS komputara i co za tym idzie ograniczenia BIOS-u.
 
<p>
Z tej w³a¶nie przyczyny, ca³y plik /bsd (czyli j±dro) musi znajdowaæ
siê wewn±trz obszaru, który jest dostêpny dla procedur bootuj±cych
z BIOS-u. Oznacza to, ¿e niektóre stare komputer i386, musz± posiadaæ
g³ówn± partycjê znajduj±c± siê w pierwszych 504 MB, ale nowsze
maszyny mog± mieæ limit 2G, 8G, 32G, 128G lub wiêcej. Warto zauwa¿yæ, ¿e
nowe komputery, które umo¿liwiaj± u¿ywanie dysków wiêkszych niz 128G,
posiadaj± ograniczenie uniemo¿liwiaj±ce bootowanie powy¿ej tej granicy.
Je¶li u¿ywasz takiech systemów zmuszony bêdziesz umie¶ciæ g³ówn± partycjê
we wnêtrzu pierwszych 128G.

<p>
Zauwa¿, ¿e mo¿liwe jest zinstalowanie 40 GB dysku i za³adowanie OpenBSD
z jednej wielkiej partycji na starej maszynie i486. Mo¿esz pomy¶leæ, ¿e
uda³o siê pomy¶lnie z³amaæ opisane powy¿ej ograniczenia. Jednak do¶æ
szybko prawda mo¿e wyj¶æ na jaw i to w ca³kiem nieprzyjemny sposób:

<ul>
  <li>System zosta³ zainstalowany na 40 GB partycji <tt>/</tt>. Bêdzie
      dzia³a³ dlatego, ¿e bazowa instalacja OpenBSD wraz z wszystkimi
      plikami (w³±czaj±c w to <tt>/bsd</tt>) zmie¶ci siê w pierwszych
      504 MB.
  <li>Z czasem, w miare jak system bêdzie siê rozrasta³, pliki zaczn±
      byæ zapisywane powy¿ej 504 MB.
  <li>Po aktualizacji, przychodzi moment na kompilacjê kernela.
      Stary plik <tt>/bsd</tt> nie jest ju¿ potrzebny, wiêc zostanie
      on nadpisany przez nowe j±dro.
  <li>Ponowne uruchomienie komputera ...
  <li>... i zamiast ulubionego systemu twoim oczom ukazuje siê
      komunikat "ERR M" lub podobny!
</ul>

<p>
Dlaczego? Nawet je¶li stary plik <tt>/bsd</tt> zosta³ zast±piony
nowym, jego nowa wersja nie znajduje siê dok³adnie w tym samym
miejscu co poprzednik. Najprawdopodobniej gdzie¶ powy¿ej granicy
504 MB obs³ugiwanej przez BIOS. Program ³aduj±cy nie jest w stanie
odczytaæ pliku j±dra i system zatrzymuje siê.

<p>
Proces bootowania OpenBSD wymaga, aby programy ³aduj±ce (biosboot(8) i
<tt>/boot</tt> w przypadku i386) oraz j±dro (<tt>/bsd</tt>) znajdowa³y
siê w obszarze, który jest obs³ugiwany przez BIOS. Mo¿na to
rozwi±zaæ w bardzo prosty sposób:

<p>
<b>Ca³a partycja '/' musi znajdowaæ sie wewn±trz obszaru, który jest
dostêpny dla BIOS-u (lub boot ROM-u) komputera.</b>

<p>
Niektóre platformy inne ni¿ i386 mog± zadawæ siê byæ odporne na tego
typu problemy, jednak i one posiadaj± ograniczenia wynikaj±ce z
ograniczeñ boot ROM-ów. Jednak dok³adne okre¶lenie tych limitów mo¿e
byæ nieco k³opotliwe.

<p>
Opisane wy¿ej problemy s± jeszcze jednym dobrym powodem, aby
<a href="faq4.html#SpaceNeeded">podzieliæ dysk na partycje</a>, zamiast
u¿ywaæ jednej du¿ej partycji.

<h3>Wymagania odno¶cie pamiêci i czasu dla fsck(8)</h3>
Problemem, który wymaga omówienia, a dotyczy du¿ych systemów plików,
jest ilo¶æ pamiêci i czasu niezbêdnego do sprawdzenia go programem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
po zawieszeniu siê systemu lub przerwy w dop³ywie pr±du. Nie mo¿na
zainstalowaæ OpenBSD na 120G systemie plików w maszynie wyposa¿onej
w 32M pamiêci RAM, a nastêpnie oczekiwaæ pomy¶lnego uruchomienia
fsck(8) po za³amaniu siê systemu. Dobr± zasad± jest za³o¿enie, ¿e
komputer powinien posiadaæ przynajmniej 1M pamiêci RAM na ka¿dy
1G przestrzeni dyskowej do poprawnego sprawdzenia systemu plików.
Wraz ze wzrostem rozmiaru partycji zwiêksza siê tak¿e czas niezbêdny
do uruchomienia fsck.

<a name="InstBoot"></a>
<h2>14.8 - Instalacja bootbloku - tylko i386</h2>

<p>
Starsze wersje systemu MS-DOS poprawnie radzi³y sobie tylko z dyskami
posiadaj±cymi nie wiêcej jak 1024 cylindry. Poniewa¿ wszystkie nowsze
dyski posiadaj± wiêcej niz 1024 cylindry, wiêkszo¶æ BIOS-ów, czy to
z kontrolerów SCSI, czy te¿ IDE (w tym wypadku BIOS kontrolera jest
zazwyczaj czê¶ci± BIOS-u ca³ego komputera) posiadaj± opcjê
"t³umacz±c±" prawdziw± geometriê dysku na co¶, co jest zrozumia³e
przez MS-DOS. Jednak¿e nie wszystkie BIOS-y dokonuj± translacji w ten
sam sposób. Po zmianie BIOS-u (np.: gdy wymienisz p³ytê g³ówn± lub
kontroler SCSI), a sposób "t³umaczenia" geometrii dysku bêdzie ró¿ni³
siê od poprzednika, niemo¿liwe stanie siê uruchomienie programu
³aduj±cego drugiego poziomu, a w efekcie wczytanie j±dra do pamiêci.
(Dzieje siê tak dlatego, ¿e boot loader pierwszego poziomu zawiera
listê sektorów zawieraj±cych w sobie program /boot zapisanych w
zgodnie z wcze¶niejszym sposobem translacji.) W przypadku dysków
IDE, przy okazji zmian w ustawieniach BIOS-u, mo¿na (w sposób
przypadkowy) zmieniæ tak¿e sposób translacji (wiêkszo¶æ BIOS-ów IDE
oferuje trzy ró¿ne metody). W takich sytuacjach konieczne bêdzie
uaktalnienie bootbloku aby umo¿liwiæ ponowny start systemu. Nale¿y
pos³u¿yæ siê dyskietk± bootuj±c± (lub p³yt± CD) i przy znaku zachêty
programu ³aduj±cego napisaæ: "b hd0a:/bsd", by wymusiæ start
z pierwszego dysku twardego, a nie dyskietki. OpenBSD powinno
uruchomiæ siê w normalny sposób. W tym momencie nale¿y uaktualniæ
program ³aduj±cy pierwszego poziomu aby móg³ poprawnie odczytaæ
now± geometriê dysku (i od nowa zapisa³ bootblok).
<br> Poni¿szy przyk³ad zak³ada, ¿e dyskiem startowym bêdzie sd0 (je¶li
posiadasz interfejs IDE bêdzie to wd0, itd.):

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
Je¶li potrzebujesz nowszej wersji bootbloku, mo¿esz j± samodzielnie
skompilowaæ. To bardzo proste:

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (lub jakiekolwiek inne urz±dzenie)
</pre>

<a name="Backup"></a>
<h2>14.9 - Zapobieganie katastrofie: archiwizowanie i odtwarzanie z ta¶my</h2>

<h3>Wstêp:</h3>

<p>
Je¶li uruchomi³e¶ w³a¶nie maszynê wykorzystywan± jako serwer produkcyjny
zalecane jest posiadanie kopii bezpieczeñstwa na wypadek, gdyby który¶
z dysków zawiód³.

<p>
Poni¿sze informacje pomog± zaznajomiæ Czytelnika z programami 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>,
znajduj±cymi siê w standartowej instalacji OpenBSD. Bardziej zaawansowane
narzêdzie do robienia kopii zapasowych, 
"<a href="http://www.amanda.org">Amanda</a>" dostêpne
w <a href="faq8.html#Ports">kolekcji portów</a>, pozwala tak¿e
archiwizowaæ dane z wielu serwerów na jednej ta¶mie. W wiêkszo¶ci
przypadków, narzêdzia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
wystarcz±. Jednak, jak ju¿ zosta³o wcze¶niej napisane, je¶li chesz
zarchiwizowaæ dane z kilku, Amanda mo¿e byæ godna uwagi.

<p>
Urz±dzenia opisane w tym dokumencie, zarówno dyski jak i streamery, to
urz±dzenia wykorzystuj±ce interfejs SCSI. W ¶rodowisku produkcyjnym,
zaleca siê raczej u¿ycie dysków SCSI ni¿ IDE. Wynika to ze sposobu w
jaki oba interefejsy radz± sobie z uszkodzonymi sektorami. Nie znaczy to
jednak, ¿e informacje tutaj zawarte s± bezu¿yteczne je¶li wykorzystujesz
dyski IDE lub ta¶my innego rodzaju, po prostu urz±dzenia bêd± nosi³y
troszke inne nazwy. Na przyk³ad odpowiednikiem sd0a w przypadku IDE
bêdzie wd0a.

<h3>Archiwizowanie danych na ta¶mê</h3>

<p>
Aby zarchiwizowaæ dane na ta¶mê, nale¿y najpierw sprawdziæ, gdzie s± 
podmontowane systemy plików. Mo¿na siê tego dowiedzieæ u¿ywaj±c
z poziomu konsoli polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
Wynik powinien wygl±daæ mniej wiêcej tak:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
W naszym przypadku, partycja root (/), istnieje fizycznie na sd0a,
co oznacza dysk twardy SCSI nr 0, partycjê a. System plików /usr
jest na sd0h, czyli na dysku twardym SCSI nr 0, na partycji h.

<p>
Inny, bardziej zaawansowany przyk³ad:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
W tym przyk³adzie, system plików root (/), rezyduje na sd0a,
/var na sd0d, /home na sd0e za¶ /usr na sd0h.

<p>
Aby zarchiwizowaæ swoje dane, nale¿y podaæ programowi dump nazwê ka¿dej
partycji twardego dysku. Oto, jak nale¿a³oby zarchiwizowaæ maszynê z 
naszego pierwszego, prostszego przyk³adu:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Z kolei w przypadku drugiego, bardziej zaawansowanego przyk³adu,
nale¿a³o by u¿yæ poleceñ:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Proszê zajrzeæ do strony podrêcznika systemowego polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>,
aby dowiedzieæ siê, jakie znaczenie maj± poszczególne flagi tego programu.
My przedstawimy jedynie krótki opis opcji u¿ytych w naszym przypadku:

<ul>
<li><b>0</b> - Dokonaj archiwizacji na poziomie 0, czyli skopiuj
               wszystkie pliki.
<li><b>a</b> - Próbuj automatycznie wykryæ pojemno¶æ ta¶my.
<li><b>u</b> - Zaktualizuj plik /etc/dumpdates, aby zaznaczyæ datê archiwizacji.
<li><b>f</b> - Okre¶la, wykorzystywane urz±dzenie ta¶mowe 
               (w naszym przypadku /dev/nrst0).
</ul>

<p>
I, ostatecznie, któr± partycjê zarchiwizowaæ (/dev/rsd0a, itd.).

<p>
Polecenie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
s³u¿y do przewijania ta¶my. Proszê przeczytaæ stronê podrêcznika systemowego
polecenia mt, by zapoznaæ siê jego opcjami (takimi jak <tt>eject</tt>).

<p>
Je¶li istnieje niepewno¶æ co do nazwy urz±dzenia ta¶mowego, proszê pos³u¿yæ
siê poleceniem dmesg. Przyk³adowy opis urz±dzenia ta¶mowego w dmesg mo¿e
wygl±daæ tak:

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
Uwa¿ny Czytelnik zapewne dostrzeg³, ¿e przy archiwizowaniu urz±dzenie 
ta¶mowe nazywa siê <tt>nrst0</tt>, a nie <tt>st0</tt>, jak podaje
dmesg. Odwo³uj±c siê do <tt>st0</tt> jako do <tt>nrst0</tt> zaznaczamy,
¿e nie chcemy przewijaæ ta¶my po dokonaniu archiwizacji, a ¿±damy
dostêpu do urz±dzenia w trybie surowym. Jest to niezbêdne by
zarchiwizowaæ kilka systemów plików na jednej ta¶mie. W przeciwnym
przypadku, drugi archiwizowany system plików nadpisze pierwszy, trzeci
drugi itd. Dok³adniejszy opis ró¿nych urz±dzeñ ta¶mowych znale¼æ
mo¿na w podrêczniku systemowym polecenia dump.

<p>
Napiszemy teraz ma³y skrypt archiwizuj±cy (nazwiemy go "backup")

<pre>
echo "  Rozpoczynam pelna archiwizacje..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Przewijanie tasmy, prosze czekac..."
mt -f /dev/rst0 rewind
echo "Gotowe."
echo
</pre>

<p>
Je¶li chcemy tworzyæ kopie zapasowe np. codziennie w nocy, to
mo¿na u¿yæ programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
który bêdzie urchamia³ nasz skrypt "backup" automatycznie.


<p>
Bardzo pomocne jest zapisanie sobie (np. na skrawku papieru) jak du¿o
miejsca na dysku zajmuje ka¿da partycja. Mo¿na do tego celu u¿yæ komendy
<tt>df -h</tt>. Bêdzie to przydatne, je¶li napêd zawiedzie i trzeba bêdzie
odtworzyæ tablicê partycji na nowym dysku.

<p>
Przywracanie danych spowoduje równie¿ zmniejszenie siê fragmentacji.
Aby na pewno zarchiwizowaæ wszystkie pliki, najlepiej jest zrestartowaæ
komputer i uruchomiæ system w trybie pojedyñczego u¿ytkownika. Nie 
trzeba podmontowywaæ systemów plików, aby je zarchiwizowaæ. Po 
zalogowaniu siê w trybie pojedynczego u¿ytkownika trzeba jednak 
podmontowaæ partycjê root (/) w trybie r/w. W przeciwnym przypadku
program dump zg³osi b³±d przy zapisywaniu danych o zrzutach. Aby 
zalogowaæ siê w trybie pojedynczego u¿ytkownika, nale¿y wpisaæ
"<tt>bsd -s</tt>" po znaku zachety "boot&gt;", pojawiaj±cym siê
w trakcie uruchamiania systemu.

<h3>Wy¶wietlanie zawarto¶ci ta¶my</h3>

<p>
Po dokonaniu pierwszej archiwizacji, dobrze jest upewniæ siê, ¿e na
ta¶mie jest rzeczywi¶cie to, czego oczekiwali¶my.

<p>
Mo¿na wydaæ nastêpuj±c± komendê by wy¶wietliæ zawarto¶æ ta¶my, na któr±
dokonali¶my zrzutu:

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
Wypisze to listê plików istniej±cych na pierwszej partycji ta¶my. Zazwyczaj
jest to system plików root (/).

<p>
Aby sprawdziæ, co zawiera druga partycja i zapisaæ wynik do pliku,
wystarczy u¿yæ nastêpuj±cego polecenia:

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
W przypadku naszego prostszego przyk³adu, numer 2 oznacza³by /usr, za¶
w przypadku trudniejszego - /var. Jak widaæ, partycje s± zapisywane
na ta¶mê w takiej kolejno¶ci, w jakiej s± na dysku.


<h3>Przywracanie danych z ta¶my</h3>

<p>
Przyk³adowy scenariusz przedstawiony poni¿ej jest przydatny w przypadku,
gdy dysk twardy kompletnie zawiedzie. Je¿eli naszym celem jest 
odtworzenie pojedynczego pliku, to nale¿y zaznajomiæ siê ze stron±
podrêcznika systemowego programu restore, zwracaj±c podczas lektury 
szczególn± uwagê na instrukcje trybu interaktywnego.

<p>
Wymiana dysku i przywracanie danych z ta¶my jest zwykle procesem szybkim
i ³atwym. Standardowa dyskietka instalacyjna (bootuj±ca) OpenBSD zawiera
zarówno wymagane narzêdzie "restore", jak i binaria wymagane do 
zpartycjonowania i ustawienia nowego dysku jako bootowalny. W wiêkszo¶ci
przypadków, dyskietka ta i ta¶ma ze zrzutem zawarto¶ci dysku s± wszystkim,
co potrzeba mieæ, aby odtworzyæ system.


<p>
Po fizycznej wymianie zepsutego dysku na nowy, nale¿y postêpowaæ w
nastêpuj±cy sposób:

<ul>
<li>
<p>
Bootujemy komputer z dyskieti instalacyjnej OpenBSD. W menu 
wybieramy "Shell". Nastêpnie zabezpieczamy przed zapisem i wk³adamy 
nasz± najbardziej aktualn± ta¶mê z kopi± zapasow± systemu.

<br>
<li>
<p>
U¿ywaj±c programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>,
tworzy siê podstawow± partycjê OpenBSD na nowym dysku. Przyk³ad:

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
Wiêcej informacji na temat <tt>fdisk</tt> znajduje siê w
<a href="#fdisk">rozdziale o programie fdisk</a>.

<li>
<p>
U¿ywaj±c polecenia disklabel, odtwarzamy nasze tablicê partycji OpenBSD
wewn±trz naszej podstawowej partycji, któr± przed chwil± stworzyli¶my
za pomoc± fdiska. Przyk³ad:

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(Proszê nie zapomnieæ o partycji swap, wiêcej informacji znajduje siê w 
<a href="#disklabel">rozdziale o disklabel FAQ</a>).

<li>
<p>
U¿ywaj±c polecenia newfs, budujemy czysty system plików na ka¿dej partycji
stworzonej w poprzednim kroku. Przyk³ad:

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
Montujemy nowoprzygotowany system plików root (/) na /mnt. Przyk³ad:

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
Wchodzimy do partycji root i zaczynamy proces przywracania danych.
Przyk³ad:

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
Trzeba jeszcze ustawiæ dysk jako bootowalny. Trzeba wiêc zapisaæ
na dysku nowy MBR. S³u¿y do tego polecenie:

<pre>
# <b>fdisk -i sd0</b>
</pre>


<li>
<p>
Oprócz zapisania nowego MBR, aby móc z niego bootowaæ, nale¿y jeszcze 
zainstalowaæ bootblock. Oto krótki przyk³ad:

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
W tym momencie nowy system plików root na dysku twardym powinien byæ
ju¿ przygotowany, mo¿na wiêc z niego uruchomiæ system i 
kontynuowaæ przywracanie reszty systemów plików. Poniewa¿ system 
operacyjny nie jest w tym momencie jeszcze do koñca odtworzony, nale¿y
ponownie uruchomiæ go w trybie pojedynczego u¿ytkownika. Oto przyk³ad
jak z poziomu pow³oki odmontowaæ system plików, a nastêpnie wy³±czyæ 
komputer.

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
Usuñ dyskietkê instalacyjn± z napêdu i ponownie uruchom komputer. Po
pojawieniu siê znaku zachêty programu ³aduj±cego OpenBSD, wpisz poni¿sz±
komendê:

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
<tt>bsd -s</tt> spowoduje, ¿e kernel uruchomi siê w trybie jednego
u¿ytkownika (do pracy w tym trybie wymagana jest tylko partycja root (/)).

<li>
<p>
Zak³adaj±c, ¿e wszystkie opisane do tej pory czynno¶ci zosta³y poprawnie
wykonane i nie wyst±pi³y ¿adne b³êdy, po uruchomieniu systemu pojawi siê
pytanie o ¶cie¿kê do pow³oki. Naci¶niêcie return uruchomi pow³oke sh.
Nastêpnie mo¿esz chcieæ zamonotowaæ g³ówny system plików w trybie
do odczytu/zapisu (w tym momencie mo¿liwy jest tylko odczyt).

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
Je¶li jest ju¿ mo¿liwy zapis na partycji root (/), mo¿na przyst±piæ do
dalszej czê¶ci odtwarzania systemu z kopii zapasowej.

<pre>
(prostszy przyk³ad )
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(bardziej zaawansowany przyk³ad)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
U¿ycie opcji <b>rvsf</b> zamiast <b>rsf</b> polecenia <b>restore</b>
spowoduje, ¿e na ekranie bêd± wy¶wietlane nazwy aktualnie rozpakowywanych
plików.

<li>
<p>
Po przywróceniu wszystkich systemów plików na dysku, nale¿y ponownie uruchomiæ
komputer, tym razem ju¿ w trybie wielou¿ytkownikowym. Je¶li wszystko
posz³o zgodnie z planem dostêpny bêdzie system dok³adnie w takim stanie
w jakim znajdowa³ siê chwili wykonywania kopii.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Montowanie obrazów dysków w OpenBSD</h2>


<p>
Aby zamontowaæ obraz dysku (np. obraz ISO, obraz dysku stworzony za pomoc±
dd itp.), nale¿y najpierw skonfigurowaæ urz±dzenie 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&sektion=4">vnd(4)</a>.

Na przyk³ad, je¿eli obraz ISO jest umieszczony w pliku <i>/tmp/ISO.image</i>,
to aby go zamontowaæ nale¿y wydaæ nastêpujace polecenia:

<table border=0 width="650">
<tr>
<td nowrap bgcolor="#EEEEEE">
<pre># <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
</td>
</tr>
</table>

<p>
Proszê zauwa¿yæ, ¿e poniewa¿ obraz ten jest obrazem p³yty CD, to
typem zamontowanego urz±dzenia jest <i>cd9660</i>. To prawda,
nie ma znaczenia jaki typ, musisz podaæ <i>ext2fs</i> gdy
montujesz linuksowy obraz dysku.

<p>
Do odmontowywania obrazów s³u¿± nastêpuj±ce dwa polecenia:

<table border=0 width="650">
<tr>
<td nowrap="nowrap" bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
</td>
</tr>
</table>

<p>
Wiêcej informacji znajduje siê w
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8">
podrêczniku systemowym programu vnconfig(8)</a>.

<a name="pciideErr"></a>
<h2>14.11 - Pomocy! Otrzymuje komunikaty b³êdów podczas pracy z urz±dzeniami IDE DMA!</h2>

<p>
Transfery IDE DMA, obs³ugiwane przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">
pciide(4)</a>, s± niestabilne w wielu konfiguracjach sprzêtowych. Do
niedawna, wiêkszo¶æ "mainstreamowych" systemów operacyjnych, które 
chwali³y siê obs³ug± tranferów DMA na dyskach IDE, nie mia³y domy¶lnie
w³±czonej tej opcji z powodu problemów ze sprzêtem. Teraz jednak
wiele z tych maszyn mo¿e byæ u¿ywanych z OpenBSD.

<p>
OpenBSD jest agresywny i zawsze próbuje uzywaæ najwy¿szych trybów DMA jakie
s± dostêpne. W przypadku niektórych konfiguracji sprzêtowych jest to jednak
przyczyn± niszczenia danych w trakcie ich transferu. Jest to spowodowane
b³êdami w chipsetach p³yt g³ównych, b³êdami w dyskach, a tak¿e
zak³óceniem na ³±czach. Na szczê¶cie, tryb Ultra-DMA za pomoc± CRC wykrywa
uszkodzenia danych powsta³e podczas ich transferu. Kiedy Ultra-DMA CRC 
zawiedzie, pojawia siê komunikat o b³êdzie i ca³a operacja jest powtarzana. 
Oto przyk³ad takiego komunikatu:

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
Je¶li operacja transferu nie powiedzie siê kilka razy z rzêdu, OpenBSD
prze³±czy tryb Ultra-DMA na wolniejszy (a co za tym idzie, bardziej
niezawodny). Je¶li tryb Ultra-DMA osi±gnie w koñcu warto¶æ 0, to napêd 
przechodzi w tryb PIO.

<p>
B³êdy w obs³udze UDMA bardzo czêsto powodowane s± przez uszkodzone
lub kiepskiej jako¶ci kable. I w³a¶nie one powinny byæ brane pod
uwagê jako g³ówni podejrzani w sprawie b³êdów DMA lub te¿ niskiej
wydajno¶ci przy transferach. Nie jest tak¿e dobrym pomys³em umieszczanie
na tym samym kanale dysku twardego i CD-ROM-u.

<p>
Je¶li wymiana kabli nie rozwi±¿e problemu, a OpenBSD nie bêdzie móg³
zmniejszyæ szybko¶ci transmisji lub proces ten spowoduje zawieszenie
komputera lub wy¶wietlenie ogromnej ilo¶ci komunikatów systemowych,
mo¿na spróbowaæ wymusiæ na systemie domy¶lne u¿ywanie ni¿szego poziomu
DMA lub UDMA. Mo¿na to osi±gn±æ zmieniaj±c domy¶lne flagi urz±dzenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">
wd(4)</a> przy pomocy <a href="faq5.html#BootConfig">UKC</a> lub
<a href="faq5.html#config">config(8)</a>

<a name="RAID"></a>
<h2>14.13 - Macierze RAID dla OpenBSD</h2>

Dziêki macierzom RAID (Redundant Array of Inexpensive Disks) mo¿na
u¿ywaæ wielu dysków w celu zwiêkszenia wydajno¶ci, pojemno¶ci i/lub 
redundacji. Pe³ne przedyskutowanie zalet i niebezpieczeñstw zwi±zanych 
z macierzami RAID nie jest zadaniem tego rozdzia³u. Nale¿y jednak 
podkre¶liæ dwa wa¿ne fakty:

<ul>
<li>Macierze RAID nie maj± nic wspólnego z kopiami zapasowymi.
<li>Same w sobie, macierze RAID nie wyeliminuj± czasu przestoju serwera.
</ul>

Je¶li te dwie rzeczy s± dla Czytelnika nowo¶ci±, to artyku³ ten nie jest 
dla niego dobrym miejscem na rozpoczêcie przygody z macierzami RAID.


<h3>Opcje programowe</h3>
OpenBSD zawiera narzêdzie RAIDframe, który programowo symuluje RAID. 
Dokumentacja tego programu znajduje siê w nastêpuj±cych miejscach:

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">Strona domowa RAIDframe</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">strona podrêcznika systemowego raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">strona podrêcznika systemowego raid(4)</a>
</ul>


<p>
Partycja root mo¿e byæ mirrorowana bezpo¶rednio przez system. Wystarczy
u¿yæ opcji "Autoconfiguration" porogramu RAIDframe.

<p>
OpenBSD 3.7-stable, i pó¼niejsze zawieraj± obs³ugê mirroringu jako opcjê
dla sterownika
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>.
Ten system wbudowano w j±dro GENERIC oraz w j±dro bsd.rd, zatem mo¿e byæ znacznie
prostrzy w u¿yciu, aczkolwiek posiada pewne ograniczenia odno¶nie przebudowywania
szyku.

Zobacz:
<ul>
<li>stronê manuala <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
<li>stronê manuala <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>
</ul>

<h3>Opcje sprzêtowe</h3>
<p>
Wiele wspieranych przez OpenBSD <a href="../../pl/plat.html">platform</a>
obs³uguje wszelakie (sprzêtowe) macierze RAID. Jakie dok³adnie, mo¿na
sprawdziæ na stronie danej platformy (mo¿na siê tam
dostaæ <a href="../../pl/plat.html">st±d</a>).

<p>
Inn± mo¿liwo¶ci±, dostêpn± dla wielu platform, jest zakup jednego z 
wielu istniej±cych na rynku urz±dzeñ, które powoduj±, ¿e kilka dysków 
IDE czy SCSI dzia³a jako jeden du¿y dysk. Takie urz±dzenia dzia³aj± 
praktycznie na ka¿dej platformie, warunkiem koniecznym jest obs³uga
interfejsu SCSI lub IDE przez ni±.

<p>
Oto niektórzy producenci takiego sprzêtu:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Uwaga: to jest tylko lista firm, których produkty, z pozytywnym skutkiem,
zosta³y przetestowane przez u¿ytkowników OpenBSD. Nie zmuszamy nikogo
do korzystania z tylko z tych urz±dzeñ!)

<h3>Opcje "nie"</h3>
<p>
Na <a href="../../pl/mail.html">listach mailingowych</a> czêsto pojawia siê
pytanie o obs³ugê przez OpenBSD tanich kontrolerów IDE RAID lub SATA RAID 
(opartych na chipsetach firm Promise, HighPoint lub Adaptec HostRAID).
Odpowiedz brzmi: nie.  Te karty i chipsety nie s± prawdziwymi sprzêtowymi
kontrolerami RAID. Jest to programowo realizowany RAID dziêki odpowiednim
procedurom zapisanym w BIOS-ie urz±dzenia. Jako ¿e OpenBSD obs³uguje RAID w
sposób niezale¿ny od sprzêtu, nie widzimy potrzeby implementacji obs³ugi
dla tych kart.

</p><p>
Prawie wszystkie kontrolery SATA lub IDE "RAID" wbudowane w p³yty g³ówne
s± tylko rozwi±zaniami softwarowymi i powinny pracowaæ poprawnie jako SATA
lub IDE wykorzystuj±c standardowy sterownik IDE 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">
pciide(4)</a>), nie bed± jednak pracowa³y jako sprzêtowy RAID w OpenBSD.


<a name="NegSpace"></a>
<h2>14.14 - Dlaczego <tt>df</tt> pokazuje, ¿e u¿ywam wiêcej ni¿ 100% dysku?</h2>
<p>
Ludzie s± zazwyczaj zaskoczeni odkrywaj±c, ¿e maj± <i>ujemn±</i> ilo¶æ 
wolnego miejsca, lub wiêcej ni¿ 100% zu¿ycia partycji, polazywane przez 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;=sektion=1">df(1)</a>.

W trakcie tworzenia partycji przy pomocy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;=sektion=8">newfs(8)</a>,
czê¶æ dostêpnej przestrzeni jest zachowywana jako rezerwa.
Zapewnia to margines b³êdu w gdy przepe³nisz dysk, oraz 
pozwala utrzymaæ minimaln± fragmentacjê.
Domy¶lnie jest to 5% pojemno¶ci dysku, zatem je¶li u¿ytkownik root
nêdznie wype³ni dysk, mo¿esz zobaczyæ 105% dostêpnej pojemno¶ci.

</p><p>
Je¿eli warto¶æ 5% nie jest w³a¶ciwa dla ciebie, mo¿esz j± zmieniæ przy pomocy
polecenia <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;=sektion=8">tunefs(8)</a>.
</p>

<a name="OhBugger"></a>
<h2>14.15 - Przywracanie partycji po skasowaniu etykiety dysku.</h2>

<p>
Je¿eli posiadasz uszkodzon± tablicê partycji, jest kilka ró¿nych
rzeczy którymi mo¿esz usi³owaæ j± odzyskaæ.

<p>
Na pocz±tek - panikuj.
Zwykle i tak siê to robi, wiêc mo¿e byæ dobrze mieæ to ju¿ za sob±.
Po prostu nie rób g³upich rzeczy.
Pozostaw panikê poza swoim komputerem.
Nastêpnie zrelaksuj siê i zobacz czy kroki opisane poni¿ej nie bed± pomocne.

<p>
Kopie etykiet ka¿dego dysku s± przechowywane w
w <tt>/var/backups</tt> jako efekt pracy dziennych narzêdzi zarz±dzaj±cych.
Za³ó¿my, ¿e wci±¿ posiadasz partycjê var, mo¿esz po prostu przeczytaæ 
wyj¶cie i umie¶ciæ je w etykiecie dysku.

<p>
W przypadku w którym nie mo¿esz zobaczyæ tej partycji, s± dwie 
opcje.
Naprawiæ dysk wystarczaj±co, tak byæ móg³ j± zobaczyæ, lub naprawiæ dysk
tak by¶ mog³ zabraæ z niego zwoje dane.

W zale¿no¶ci od tego co siê wydarzy³o, pierwsza lub druga opcja mo¿e byæ 
lepsza (z umieraj±cym dyskiem najpierw chcesz dane, z niestarannymi rêkami
mo¿esz po prostu mieæ etykietê).

<p>
Pierwszym narzêdziem którego potrzebujesz jest 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(zwróæ uwagê na podkre¶lenie: to nie jest "scanffs").
scan_ffs(8) przej¿y ca³y dysk i spróbuje znale¼æ partycje a tak¿e poda 
informacje jakie na ich temat znajdzie.
Mo¿esz u¿yæ tych informacji do ponownego stworzenia etykiet dysku.
Je¿eli po prostu chcesz odzyskaæ <tt>/var</tt>, mo¿esz odtworzyæ
partycjê <tt>/var</tt>, a pó¼niej odzyskaæ zbakapowan± etykietê i dodaæ 
resztê.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
uaktualni zarówno informacje j±dra o etykietach dysków, jak równie¿ spróbuje
zapisaæ etykietê na dysk.
Zatem, nawet je¿eli obszar dysku zawieraj±cy etykietê jest nieczytelny, 
bedziesz móg³ u¿yæ polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
i czytaæ dane a¿ do nastêpnego restartu.


<a name="foreignfs"></a>
<h2>14.16 - Czy mogê dostaæ siê do danych na systemach plików
innych ni¿ FFS?</h2>
<!-- Artyku³ ten zosta³ napisany przez Stevena Mestdagh 
steven.mestdagh@esat.kuleuven.be, i udostêpniony na licencji BSD -->

Tak. Pozosta³e wspierane systemy plików zawieraj±: ext2 (Linux), ISO9660 i UDF
(CD-ROM,DVD), FAT (MS-DOS oraz Windows), NFS, NTFS (Windows), AmigaDOS.
Niektóre z nich maj± ograniczone wsparcie, np. tylko-odczyt.

<p>
Podamy tutaj ogólne wprowadzenie jak korzystaæ z tych systemów plików w 
OpenBSD. Aby korzystaæ z systemu plików musi on zostaæ podmontowany.
Po szczegó³owe opcje montowania, zobacz stronê manuala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>,
oraz te dotycz±ce montowania systemów plików które zamierzasz montowaæ,
tj. mount_msdos, mount_ext2fs, ...

<p>
Przede wszystkim musisz wiedzieæ na jakim urz±dzeniu znajduje siê twój
system plików. To mo¿e byæ twój pierwszy dysk twardy, <tt>wd0</tt> lub <tt>sd0</tt>,
lub co¶ mniej oczywistego.
Wszystkie rozpoznane i skonfigurowane urz±dzenia w twoim systemie s± podane
na wyj¶ciu polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>:
nazwa urz±dzenia poprzedzona jedn± lini± jego opisu.
Dla przyk³adu, moj pierwszy napêd CD-ROM jest rozpoznawany jako:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Chc±c uzyskaæ znacznie krótsz± listê dostêpnych dysków, mo¿esz skorzystaæ z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.

Polecenie:

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

poka¿e dyski aktualnie znane przez twój system, dla przyk³adu:

<blockquote><pre>
hw.disknames=cd0,cd1,wd0,fd0,cd2
</pre></blockquote>


<p>
W tym momencie, nadszed³ czas by dowiedzieæ siê jakie partycje znajduj± 
siê na tym urz±dzeniu, oraz na której z nich znajduje siê po¿±dany 
system plików. 
Dlatego te¿ sprawdzimy urz±dzenie korzystaj±c z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Disklabel zawiera listê partycji, z maksymaln± ich liczb± równ± 16.
Partycja c zawsze oznacza ca³y dysk.
Partycje a-b oraz d-p s± wykorzystywane przez OpenBSD.
Partycje i-p mog± byæ automatycznie przeznaczone na systemy plików
innych systemów operacyjnych.
W tym przypadku, bêdziemy ogl±daæ etykiety (disklabel) mojego dysku twardego,
zawieraj±cego kilka ró¿nych systemów plików.

<p>
<b>Uwaga: OpenBSD zosta³ zainstalowany po zainstalowaniu wcze¶niej innych systemów</b>,
i podczas instalacji disklabel zawiera³ natywny system plików jak i inne systemy plików
innych systemów operacyjnych.
Jednak¿e, je¿eli instalujesz inne systemy plików po tym jak zosta³ zainstalowany
disklabel OpenBSD, bêdziesz potrzebowa³ pó¼niej dodaæ lub zmodyfikowaæ je rêcznie.
Zosta³o to opisane w <a href="#foreignfsafter">tej sekcji</a>.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A      
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0


16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581
b:       1638000      20746656    swap                   # Cyl 20582 - 22206
c:      78165360             0  unused      0     0      # Cyl     0 - 77544
d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367
e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773
f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176
g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
i:         64197            63 unknown                   # Cyl     0*-    63*
j:      20274030         64260 unknown                   # Cyl    63*- 20176*
k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>


<p>
Jak mo¿emy zobaczyæ na powy¿szym wyj¶ciu partycje OpenBSD s± wylistowane
jako pierwsze. Nastêpne jest szereg partycji ext2 oraz jedna partycja
MSDOS, podobnie jak kilka partycji "unknown". Na systemach i386 oraz amd64
mo¿esz zazwyczaj dowiedzieæ siê wiêcej o tych partycjach korzystaj±c 
z narzêdzia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.
Dla ciekawskich czytelników: partycja i jest partycj± konserwacyjn±
utworzon± przez producenta, partycja j jest partycj± NTFS, natomist
partycja l jest linuksow± partycj± wymiany.

<p>
Kiedy ju¿ okre¶li³e¶ jak± partycjê chcesz u¿yæ, mo¿esz przej¶æ do ostatniego
kroku: zamontowania znajduj±cego siê na niej systemu plików.
Wiêkszo¶æ systemów plików jest wspierana w j±drze GENERIC: po prostu
przyj¿yj siê konfiguracji j±dra znajduj±cej siê w katalogu
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt>.
Jednak¿e niektóre nie s± wspierane, np. wsparcie NTFS jest eksperymentalne,
dlatego te¿ nie jest w³±czone w GENERIC.
Je¿eli chcesz wykorzystaæ jeden z systemów plików nie wspierany w GENERIC,
bêdziesz musia³ <a href="faq5.html#Options">zbudowaæ w³asne j±dro</a>.

<p>
Kiedy ju¿ zebra³e¶ informacje wspomniane powy¿ej, nadszed³ czas na zamontowanie
systemu plików.
Przypu¶æmy ze istnieje katalog <tt>/mnt/otherfs</tt>, który u¿yjemy jako
punkt montowania rz±danego systemu plików.
W tym przypadku bêdziemy chcieli zamontowaæ system ext2 na partycji m:


<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>


<p>
Je¿eli zamierzasz korzystaæ z tego systemu plików regularnie, mo¿esz
zaoszczêdziæ sobie nieco czasu poprzes wpisanie do <tt>/etc/fstab</tt>,
na przyk³ad co¶ takiego:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>


Zwróæmy uwagê na zero wpisane w polach pi±tym i szóstym.
Oznaczaja to ¿e nie wymagamy by ten system plików by³ zrzucany oraz
sprawdzany przy u¿yciu fsck.
Zazwyczaj te rzeczy chcemy by by³y wykonywane przez natywny system
operacyjny wspó³pracuj±cy z danym systemem plików.


<a name="foreignfsafter"></a>
<h3>14.16.1 - Partycje nie istniej± w moim disklabel! Co powinienem zrobiæ?</h3>

Je¿eli instalujesz inny system plików w twoim systemie (w rezulatacie dodawania
nowego systemu operacyjnego), po tym jak zainstalowa³e¶ OpenBSD,
etykiety dysków, zachowana zostanie aktualna zawarto¶æ disklabel, i nie bêdzie 
ona aktualizowana automatycznie by zawiera³a nowe partycje z tymi systemami plików.
Je¿eli chcesz z nich korzystaæ, konieczna bêdzie rêczna modyfikacja lub dodanie
tych partycji przy pomocy narzêdzia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Jako przyk³ad, zmodyfikowa³em jedn± z moich partycji ext2: korzystaj±c z linuksowego
programu fdisk, zmniejszy³em rozmiar partycji "o" (zobacz wynik disklabel powy¿ej)
do 1G.
Bêdziemy mogli to ³atwo rozpoznaæ dziêki pozycji startowej (offset: 64372518)
oraz rozmiarze (13783707).
Zauwa¿my, ¿e te warto¶ci to numery sektorów, i takie wykorzystanie numerów sektorów
(nie megabajtów lub innych miar) jest najbardziej w³a¶ciw± i bezpieczn± metod± 
do czytania tych informacji.

<p>
Zanim przyst±pimy do zmian, partycja ogl±dana przy pomocy dostêpnego w OpenBSD programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
wygl±da tak (pozostawi³em tylko istotn± informacjê):

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
        Starting       Ending       LBA Info:
#: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Jak mo¿esz siê przekonaæ, pozycja pocz±tkowa partycji oraz rozmiar dok³adnie
odpowiada warto¶ciom podanym wcze¶niej przez program disklabel(8).
(Nie b±d¼ zmieszany warto¶ci± wskazywan± przez "Offset": jest to odniesienie
do pozycji startowej partycji rozszerzonej na której znajduje siê omawiana
partycja ext2).


<p>
Po zmianie partycji w linuksowym programie fdisk, wygl±da to tak:

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
#: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Teraz musi zostaæ to zmienione przy pomocy disklabel(8).
Przyk³adowo, mo¿esz wydaæ polecenie <tt>disklabel -e wd0</tt>, które wywo³a edytor
okre¶lony w zmiennej ¶rodowiskowej EDITOR (domy¶lnie jest vi).
W tym edytorze zmieñ ostatni± liniê disklabel by pasowa³a do nowego rozmiaru:

<blockquote><pre>
o:       2104452      64372518  ext2fs
</pre></blockquote>

Zapisz disklabel na dysk gdy skoñczysz.
Teraz gdy disklabel jest aktualny, powinieneæ móc podmontowaæ twoj± partycjê jak 
opisano wcze¶niej.

<p>
Mo¿esz podobn± procedur± dodawaæ nowe partycje.


<a name="flashmem"></a>
<h2>14.17 - Czy mogê u¿ywaæ pamiêci flash w OpenBSD?</h2>
<!-- Artyku³ ten zosta³ napisany przez Stevena Mestdagh,
steven.mestdagh@esat.kuleuven.be, i udostêpniony na licencji BSD -->

Zazwyczaj no¶nik pamiêci powinien zostaæ rozpoznany zaraz po w³o¿eniu go
w port twojego komputera.
Krótko po w³o¿eniu, na konsoli powinny siê wy¶wietliæ wiadomo¶ci z j±dra.
Dla przyk³adu, kiedy pod³±czam moj± pamiêæ flash USB, widzê poni¿sze
komunikaty na konsoli:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>  

Linie te oznaczaj±, ¿e sterownik 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>
(USB mass storage) zosta³ podczepiony do urz±dzenia pamiêci, oraz korzysta
z systemu SCSI.
Najwa¿niejsze s± dwie ostatnie linie: mowi± do jakiego wêz³a zosta³a pod³±czona
pamiêæ i jaki jest ca³kowity rozmiar przestrzeni na niej.
Je¿eli w jaki¶ sposób zgubi³e¶ te linie, wci±¿ mo¿esz je zobaczyæ pó¿niej
dziêki poleceniu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>.
Zg³oszona warto¶æ geometrii CHS jest raczej fikcyjna, poniewa¿ pamiêci flash
s± traktowane jak zwyk³e dyski SCSI.

<p>
Poni¿ej rozwa¿ymy dwa scenariusze.

<h3>Urz±dzenie jest nowe/puste i chcesz je u¿ywaæ tylko z OpenBSD</h3>

Bêdziesz potrzebowa³ za³o¿yæ etykietê dysku na tym urz±dzeniu, oraz
stworzyæ przynajmniej jedn± partycjê.
Proszê przeczytaj a href="#disklabel">korzystanie z disklabel w OpenBSD</a>
oraz stronê manuala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
W tym przypadku utworzy³em jedn± partycjê <i>a</i> i za³o¿y³em na niej
system plików FFS:

blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
 cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
     122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Podmontujmy utworzony na partycji <i>a</i> system plików w 
<tt>/mnt/flashmem</tt>.
Wcze¶niej utwórz ten punkt montowania.


<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>
	         

<h3>Otrzyma³e¶ pamiêæ flash do kogo¶ innego z kim chcesz wymieniaæ siê danymi.</h3>

<p>
Istnieje znaczne prawdopodobieñstwo ze osoba ta nie korzysta z OpenBSD,
zatem na pamiêci mo¿e znajdowaæ siê obcy system plików.
Dlatego na pocz±tek sprawdzimy jakie partycje znajduj± siê na tym urz±dzeniu,
tak jak to opisano w <a href="#foreignfs">FAQ 14 - Czy mogê dostaæ siê
do danych na systemach plików innych ni¿ FFS?</a>.


<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
 c:        251904             0  unused      0     0      # Cyl     0 -   122
 i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Jak widzimy na etykietach dyskowych za³±czonych powy¿ej, jest tylko jedna
partycja <i>i</i>, zawieraj±ca system plików FAT utworzony na maszynie
windowsowej.
Jak zwykle partycja <i>c</i> oznacza ca³y dysk.

<p>
Podmontujmy system plików z partycji <i>i</i> w 
<tt>/mnt/flashmem</tt>.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>


Mo¿esz teraz zacz±æ korzystaæ z niego jak z ka¿dego innego dysku.

<p>
<b>OSTRZE¯ENIE:</b>
Powiniene¶ <b>zawsze odmontowywaæ</b> system plików <b>zanim od³±czysz</b>
no¶nik pamiêci. 
Je¿eli tego nie zrobisz, system plików mo¿e pozostaæ w niezgodnym stanie,
co mo¿e oznaczaæ uszkodzenie danych.

<p>
Po od³±czeniu no¶nika pamiêci z twojej maszyny, ponownie zobaczysz komunikaty
z j±dra o tym zdarzeniu na konsoli.

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<p>
<font color= "#0000e0">
<a href= "index.html">[Spis tre¶ci]</a>
<a href= "faq12.html">[Do sekcji 13 - Multimedia]</a>
<a href= "faq15.html">[Do sekcji 15 - Pakiety i Porty]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[wstecz]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.138 ]<br>
$Translation: faq14.html,v 1.22 2005/11/03 21:31:21 tkniaz Exp $<br>
-->
$OpenBSD: faq14.html,v 1.19 2005/11/04 20:24:24 jufi Exp $
</small>

</body>
</html>
