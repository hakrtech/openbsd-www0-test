<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Konfiguracja dysku</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[Spis tre¶ci]</a>
<a href= "faq12.html">[Do sekcji 12 - Pytania dotycz±ce poszczególnych
platform]</a>
</font>

<h1><font color="#e00000">14 - Konfiguracja dysku</font></h1>

<!--
UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Uwaga:</font></b>Zawarto¶æ tego pliku
jest ju¿ bardzo nieaktualna w stosunku do
<a href="../faq14.html">bie¿±cej wersji anglojêzycznej</a>.

<p>
Je¶li chcesz pomóc w aktualizacji tego pliku, zajrzyj na
<a href="../../translation.html">stronê t³umaczeñ</a>.
-->

<hr>

<h3>Spis tre¶ci</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Program disklabel(8) w OpenBSD</a>
<li><a href="#fdisk"      >14.2 - Program fdisk(8) w OpenBSD</a>
<li><a href="#NewDisk"    >14.3 - Dodawanie nowych dysków w OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - Plik wymiany</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Jak wygl±da bootowanie OpenBSD?</a>
<li><a href="#LargeDrive" >14.7 - O czym nale¿y wiedzieæ u¿ywaj±c du¿ych 
                           dysków w OpenBSD?</a>
<li><a href="#InstBoot"   >14.8 - Instalacja bootbloku - tylko i386</a>
<li><a href="#Backup"     >14.9 - Zapobieganie katastrofie: archwizowanie 
                           i odtwarzanie z ta¶my.</a>
<li><a href="#MountImage" >14.10 - Montowanie obrazów dysków w OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - Pomocy! Otrzymuje komunikaty o b³êdach
                           podczas pracy z urz±dzeniami PCIIDE!</a>
<li><a href="#RAID"       >14.13 - Macierze RAID dla OpenBSD</a>
</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Program disklabel(8) w OpenBSD</h2>
<h3>Spis tre¶ci</h3>

<ul>
<li><a href="#disklabel.1">Co to jest disklabel(8)?</a>
<li><a href="#disklabel.2">disklabel(8) podczas instalacji OpenBSD</a>
<li><a href="#disklabel.3">Zastosowanie programu disklabel(8)</a>
</ul>

   
<a name="disklabel.1"></a>
<h3>Co to jest disklabel(8)?</h3>
  
<p>
Na pocz±tku proszê przeczytaæ stronê podrêcznika systemowego 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Etykiety dyskowe (ang. disklabels) tworzone s± po to, aby zapewniæ
efektywny interfejs pomiêdzy dyskiem, a znajduj±cym siê w j±drze systemu 
operacyjnego sterownikiem dysku. Etykiety zawieraj± informacje
o dysku, np. jego geometriê i systemy plików znajduj±ce siê na dysku.
Dane te s± wykorzystywane przez program ³adowania pocz±tkowego
(ang. bootstrap program) do zainicjowania dysku oraz do identyfikacji
systemu plików na dysku.  Etykiety dyskowe s± rownie¿ u¿ywane w po³±czeniu
z systemami plików do tworzenia bardziej wydajnych ¶rodowisk. Wiêcej na
ten temat mo¿na dowiedzieæ siê poprzez lekturê strony podrêcznika systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>.


<p>
Dodatkow± zalet± etykiet dyskowych jest fakt, ¿e pozwalaj± one omin±æ 
ograniczenia danej architektury w dziedzinie partycjonowania dysków.
Dla przyk³adu, w architekturze i386 mo¿na mieæ tylko 4 partycje 
podstawowe (czyli partycje, które inne systemy operacyjne, takie jak
Windows NT czy DOS bed± poprawnie rozpoznawaæ). Dziêki
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
na tylko jednej podstawowej partycji pomie¶ciæ mo¿na *wszystkie*
partycje systemu OpenBSD (np. 'swap', '/', '/usr' i '/var'). Dziêki
temu pozosta³e 3 podstawowe partycje dostêpne dla innych OS!


<a name="disklabel.2"></a>
<h3>disklabel(8) podczas instalacji OpenBSD</h3>

<p>
Jedn± z g³ównych czynno¶ci dokonywanych podczas instalacji
OpenBSD jest tworzenie etykiet. Krok ten nastêpuje po skonfigurowaniu
partycji programem <a href="#fdisk">fdisk(1)</a>.
Podczas instalacji u¿ywa siê etykiet dyskowych aby wskazaæ
punkty montowania. Mo¿na je ustawiæ z poziomu programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
ale nie jest to czynno¶æ obowi±zkowa, jako ¿e w nastêpnym kroku instalator
poprosi o potwierdzenie podanych ¶cie¿ek. Jednak wykonanie wszystkiego
ju¿ podczas edycji etykiety dysku programem disklabel(8) czyni instalacjê
nieco przyjemniejsz±.

<p>
Oczywi¶cie podczas pierwszego instalowania OpenBSD nie bêdzie jeszcze 
¿adnych etykiet. Nale¿y je stworzyæ. Pierwsz± etykiet±, jaka
powinna znale¼æ siê na dysku jest etykieta 'a'. POWINNA ona
identyfikowaæ partycjê '/'. O tym jakie partycje utworzyæ i jakie s±
zalecane minimalne wielko¶ci dla nich mo¿na przeczytaæ w rodziale 
<a href="faq4.html#SpaceNeeded">FAQ 4.7 Jak du¿o miejsca potrzeba aby
zainstalowaæ OpenBSD?</a>. Dla serwerów zaleca siê podzia³ dysku w sposób
tam podany. Dla u¿ytku domowego mo¿na stworzyæ tylko jeden punkt
 montowania - '/'. Deycduj±c siê na tylko jedn± partycje '/' 
(o etykiecie 'a') nale¿y pamiêtaæ o pozostawieniu TROCHÊ wolnego miejsca na
partycjê swap. Teraz, gdy ju¿ wyja¶nili¶my podstawy, przejdziemy do 
przyk³adu, pokazuj±cego w jaki sposób u¿ywaæ program disklabel(8) podczas
instalacji OpenBSD. Pierwszy przyk³ad zak³ada, ¿e OpenBSD
bêdzie jedynym systemem operacyjnym na danym komputerze oraz ¿e 
dokonywana bêdzie pe³na instalacja.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
W tym momencie mamy ju¿ stworzon± g³ówn± partycjê, zamontowan±
w <tt>/</tt>, oraz partycjê wymiany (swap) - obydwie o wielko¶ci 64 MB.
Proszê zauwa¿yæ, ¿e przeusniêcie (offset) pierwszej partycji w stosunku
do pocz±tku dysku wynosi 63 sektory. Oto w³a¶nie chodzi. OpenBSD 
pokazuje wielko¶æ w sektorach, jednak nie trzeba wpisywaæ wielko¶ci
w tym formacie. Jak widaæ w powy¿szym przyk³adzie, akceptowane s±
wpisy w stylu <i>64 Megabytes = 64M</i> oraz <i>2 Gigabytes = 2G</i>.
Program disklabel zaokr±gli te wielko¶ci do najbli¿szego cylindra. W
opisanej sytacji widaæ tak¿e, ¿e OpenBSD zak³ada, i¿ etykieta 'b'
okre¶la partycjê wymiany. Jest tak, poniewa¿ j±dro GENERIC szuka
partycji wymiany w³a¶nie pod etykiet± 'b' i nie nale¿y tego zmieniaæ.

<p>
W nastepnym przyk³adzie stworzymy dwie kolejne etykiety. To jeszcze
nie bêdzie pe³na instalacja, jako ¿e ich rozmiar nie bêdzie 
wystarczaj±cy dla wszystkich plików systemu OpenBSD. Pozosta³e partycje
tworzy siê analogicznie, wiêc nie ma potrzeby udzielania dodatkowych
wyja¶nieñ.

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
Uwa¿ny Czytelnik dostrze¿e zapewne dwie rzeczy. Po piewsze, dla ka¿dej 
nowo tworznej partycji offset obliczany jest automatycznie, zatem w ogóle
nie trzeba go wyliczaæ czy zmieniaæ. Po drugie, etykieta 'c' zosta³a
pominiêta. Sta³o siê tak dlatego, i¿ reprezentuje ona ca³y dysk i nie
powinno siê jej u¿ywaæ.

<p>
Gdy ju¿ utworzymy etykiety, nale¿y je jeszcze zapisaæ na dysk. Nastepnie
mo¿na ju¿ kontynuowaæ proces instalacji. Aby zachowaæ wszystkie zmiany
oraz opu¶ciæ program disklabel(8) (ale kontynuowaæ instalacjê) wpisujemy:

<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>
<a name="disklabel.3"></a>
<h3>Zastosowanie programu disklabel(8)</h3>

<p>
Po instalcji systemu nie powinno byæ zbyt wiele okazji na u¿ywanie
disklabel(8). Czasem jednak mo¿e zaj¶æ taka konieczno¶æ, w przypadku 
dodawania, usuwania czy restrukturyzacji dysków. Jedn± z pierwszych
rzeczy, jak± wykonuje siê przy ka¿dej pracy z disklabel(8) jest
wy¶wietlenie obecnej etykiety dyskowej. Mo¿na to zrobiæ wpisuj±c po prostu:

<pre>
# <b>disklabel wd0</b> &gt;----- albo jakiekolwiek inne urz±dzenie 

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
Powy¿sze polecenie pozwala obejrzeæ istniej±c± etykietê dysku, bez 
zmieniania czegokolwiek. Aby móc wprowadzaæ zmiany, nale¿y u¿yæ flagi
<tt>-E</tt>. Przyk³ad:

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
Pojawi siê znak zachêty, taki sam, jak podczas instalacji OpenBSD.
Prawdopodobnie najwa¿niejszym poleceniem jest tutaj '?'. Wy¶wietli
ono listê wszystkich dostêpnych komend. Stronê podrêcznika systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
mo¿na wy¶wietliæ poleceniem 'M'. W tym momencie mo¿na dodawaæ, usuwaæ
i zmieniaæ partycje. Szczegó³owy opis poleceñ dostêpny jest na stronie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<a name="fdisk"></a>
<h2>14.2 - Program fdisk(8) w OpenBSD</h2>

Na pocz±tku proszê przeczytaæ stronê podrêcznika systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.

<p>
fdisk jest programem s³u¿±cym do zarz±dzania partycjami. Podczas
instalacji przy pomocy fdisk tworzy siê partycjê OpenBSD (która
pó¼niej podzielona jest na <u>kilka</u> etykiet, zawieraj±cych
systemy plików/partycjê wymiany/itd.). fdisk mo¿e podzieliæ
dysk na partycje i ustawiæ jedn± z nich jako aktywn±. U¿ywa
siê go najczê¶ciej w trybie jednego u¿ytkownika. fdisk umo¿liwia
tak¿e utworzenie MBR na dyskach.

<p>
Podczas instalacji najczê¶ciej tworzy sie tylko <b>JEDN¡</b> partycjê
OpenBSD, a nastêpnie przy pomocy disklabel dzieli siê j± na etykiety
zawieraj±ce systemy plików i partycjê wymiany.

<p>
Tablicê partycji mo¿na wy¶wietliæ przy pomocy nastêpuj±cego polecenia:

<pre># <b>fdisk sd0</b><br>
</pre>

<p>
Wynik dzia³ania bêdzie podobny do tego przedstawionego poni¿ej:

<pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre>

<p>
W powy¿szym przyk³adzie pokazana jest tablica partycji pierwszego
dysku SCSI. Jak mo¿na zauwa¿yæ jest tam partycja OpenBSD (A6).
Gwiazdka (*) przy jej opisie oznacza, ¿e jest ona aktywna.

<p>
W poprzednim przyk³adnie wy¶wietlili¶my tylko informacje o partycjach.
A co je¶li chcemy zmieniæ tablicê partycji? S³u¿y do tego opcja <b>-e</b> -
uruchomi ona program fdisk w trybie interaktywnym.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p> 
Absolutnie bezpieczne w progamie fdisk jest jego uruchomienie, obejrzenie
dostêpnych opcji, udzielenie odpowiedzi <b>N</b> na pytania i *NIE U¯YWANIE*
polecenia <b>write</b>.

<p>
Poni¿ej znajduje siê przegl±d poleceñ dostêpnych dla trybu interaktywnego:

<ul>
<li><b>help</b>   Wy¶wietla listê wszystkich komend trybu interaktywnego.
<li><b>reinit</b> Tworzy now± tablicê partycji, zawieraj±ca jedn± partycjê
                  OpenBSD oznaczon± jako aktywn±.
<li><b>disk</b>   Wy¶wietla geometriê dysku rozpoznan± przez program fdisk.
                  Istnieje mo¿liwo¶æ zmiany parametrów, które wykry³ fdisk.
<li><b>setpid</b> Pozwala na zmianê typu partycji. To polecenie jest
                  u¿yteczne w przypadku przydzielenia istniej±cej partycji
                  dla OpenBSD.
<li><b>edit</b>   Edycja partycji (wszystkie zmiany przeprowadzane s± na
                  kopii tablicy partycji w pamiêci, a nie bezpo¶rednio na
                  dysku). Podczas zmiany jako jednostek mo¿na u¿yæ geometrii
                  BIOS-u lub przesuniêcia i rozmiaru podanego w sektorach.
<li><b>flag</b>   Ustawia partycjê jako aktywn±. Tylko jedna partycja mo¿e
                  mieæ ustawion± t± flagê.
<li><b>update</b> Uaktualnienie "machine code" w kopii akutalnie wybranego
                  bootbloku.
<li><b>select</b> Wybór i za³adowanie do pamiêci tablicy partycji partycji
                  rozszerzonej.
<li><b>print</b>  Wy¶wietla tablicê partycji. 
<li><b>write</b>  Zapisuje zmiany z kopii tablicy partycji w pamiêci komputera
                  na dysk. Zostaniesz poproszony o potwierdzenie tej operacji.
<li><b>exit</b>   Przej¶cie z edycji boot bloku wybranego poleceniem
                  <tt>select</tt> do edycji poprzedniej tablicy partycji,
                  je¶li taka nie istnieje, nast±pi wyj¶cie z programu.
<li><b>quit</b>   Polecenie analogiczne do polecenia <tt>exit</tt> z t±
                  ró¿nic±, ¿e wszystkie zmiany zapisane zostaj± na dysk.
<li><b>abort</b>  Wyj¶cie z programu bez zapisania tablicy partycji.
</ul>

<a name="NewDisk"></a>
<h2>14.3 - Dodawanie nowych dysków w OpenBSD</h2>

<p>
Programy potrzebne do <b>PRAWID£OWEJ</b> instalacji dysku w OpenBSD to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>tylko i386</i>) i
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Na platformie i386 pracê rozpoczyna siê od narzêdzia fdisk(8). Posiadacze
innych architekutr mog± zignorowaæ ten krok. Poni¿ej opisane bêdzie
dodanie trzeciego dysku SCSI do systemu.

<pre>
# <b>fdisk -i sd2</b>
</pre>
To polecenie zaincjalizuje tablicê partycji. Stworzona zostanie tylko
jedna partycja, obejmuj±ca ca³y dysk i przeznaczona dla OpenBSD.
W nastêpnym kroku nale¿y utworzyæ etykietê dysku. Ta czyno¶æ mo¿e
wydawaæ siê nieco zagmatwana.

<pre>
# <b>disklabel -e sd2</b>

<i>(screen goes blank, your $EDITOR comes up)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

Po pierwsze, nie nale¿y zmieniaæ partycji 'c' - opisuje ona ca³y dysk i
jest niezbêdna do prawid³owej pracy disklabel.
£±czna liczba sektorów odpowiada liczbie sektorów na dysku. Dysk
ma 3 GB. Trzy gigabajty wed³ug producentów dysków to 3000 MB. Dziel±c
6185088 przez 3000 (mo¿na wspomóc siê programem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1)</a>)
otrzymasz 2061. Aby obliczyæ wielko¶æ w sektorach dla partycji a, d,
e, f, g, ... wystarczy pomno¿yæ ¿adany rozmiar w megabajtach przez 2061.
Offset dla pierwszej partycji powinien byæ taki sam jak pokazana
wcze¶niej warto¶æ <tt>sector/track</tt>. W tym przypadku bêdzie to
63. Przesuniêcie ka¿dej nastêpnej partycji winno byæ sum± przesuniêcia
i rozmiaru partycji j± poprzedzaj±cej (wyj±tkiem jest etykieta 'c', która
nie bierze udzia³u w takim wyrównywaniu).

<p>
W sytacji gdy na dysku ma byæ tylko jedna partycja, np. zamierzasz u¿ywaæ jej
do przechowywania stron WWW lub katalogów domowych u¿ytkowników, wystarczy
od ca³kowitego rozmiaru dysku odj±æ ilo¶æ sektorów przypadaj±cych na jedn±
¶cie¿kê (w tym przypadku 63), tak wiêc 6185088 - 63 = 6185025. A ostateczny
wygl±d etykiety dysku bêdzie przedstawia³ sie nastêpuj±co:

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>Je¶li to wszystko wydaje siê zbyt skomplikowane, mo¿na u¿yæ
opcji <tt>-E</tt> programu <tt>disklabel</tt>, a uruchomi siê on
w takim samym trybie jak podczas instalacji systemu!</b> W tym trybie
mo¿na u¿ywaæ oznaczeñ takich jak "96M" do okre¶lenia "96 megabajtów".
(Je¶li twój dysk jest wystarczaj±co du¿y mo¿na u¿yæ "96G" do okre¶lenia
96 gigabajtów!). Na nieszczê¶cie tryb <tt>-E</tt> u¿ywa geometrii BIOS-u,
a nie prawdziwej geometrii dysku, a w bardzo wielu przypadka nie jest
to zupe³nie to samo.

(Innymi opcjami sa 'g b' - geometria zgodnie z BIOS-em oraz
'g u', czyli po prostu to, co "label" mial ustawione przed
dokonaniem jakichkolwiek zmian przez disklabel.)

<p>
Zosta³o zrobione ju¿ du¿o, ale to jeszcze nie koniec. Nale¿y jeszcze utworzyæ
system plików na partycjach u¿ywaj±c do tego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
Oczywi¶cie parametr dla tej komendy zale¿ny jest od tego jak dyski s±
nazywane i numerowane przez OpenBSD. (Spojrz na wynik dzia³ania polecenia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
aby dowiedzieæ siê jak nazywaj± siê dyski w twoim systemie.)

<p>
Teraz mo¿na ju¿ zamontowaæ nowoutworzon± partycjê. Punktem montowania bêdzie
katalog <tt>/u</tt>. Tak wiêc, najpierw nale¿y za³o¿yæ katalog <tt>/u</tt>,
a dopiero pó¼niej zamonotwaæ partycjê.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Je¶li wszystko posz³o sprawnie mo¿na dopisaæ now± partycjê do 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>.

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
Je¶li chcesz przenie¶æ istniej±cy katalog, jak np. /usr/local na now± partycjê
wystarczy zamontowaæ nowy system plików w katalogu /mnt i u¿yæ polecenia
<tt>cpio -pdum</tt>. Zawarto¶æ /usr/local zostanie przeniesiona do /mnt.
W pliku
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
nale¿y zaznaczyæ, ¿e /usr/local jest teraz na partycji /dev/sd2a.

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Uruchom komputer w trybie jednego u¿ytkownika (<b>boot -s</b>), przenie¶
istniej±cy katalog /usr/local do /usr/local-backup (lub po prostu go
skasuj, je¶li uwa¿asz siê za szczê¶ciarza) i stwórz pusty katalog
/usr/local. Uruchom komputer ponownie, i voila, pliki s± na swoim miejscu!

<a name="SwapFile"></a>
<h2>14.4 - Plik wymiany</h2>

<p>
(Uwaga: je¶li szukasz dodatkowej przestrzeni wymiany poniewa¿ otrzymujesz
komunikat &quot;brak pamiêci wirtualnej&quot; (ang. &quot;virtual memory
exhausted&quot;), powniniene¶ najpierw spróbowaæ ograniczyæ jej
zu¿ycie przez procesy przy pomocy poleceñ
<tt>csh</tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>,
lub
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>.)

<p>
Korzystanie z pliku wymiany nie wymaga specjalnych opcji przy kompilacji
kernela. Istnieje jeszcze druga metoda, która wymaga zmian w j±drze.
Ten dokument opisze oba sposoby.

<h3>Plik wymiany</h3>

<p>
Wymiana do pliku jest najprostszym i najszybszym sposobem na zdobycie
dodatkowej pamiêci wirtualnej. Plik, który bêdzie wykorzystywany do tego
celu, nie mo¿e znajdowaæ siê na partycji wykorzystuj±cej SoftUpdates
(domy¶lnie jest to wy³±czone). Zanim zaczniesz przygotowywaæ plik wymiany
mo¿esz chcieæ zobaczyæ jak du¿o pamiêci wirtualnej posiadasz i jak
du¿o jest aktualnie wykorzystywane. S³u¿y do tego polecenie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
Powy¿sza komenda wy¶wietla wszystkie urz±dzenia wykorzystywane jako pamiêæ
wirtualna oraz podstawowe statystki ich dotycz±ce. W tym przyk³adzie jest
tylko jedno urz±dzenie nazwane &qout;swap_device&quot; - to partycja
wymiany (na etykiecie dysku oznaczona liter± <tt>b</tt>). Jak mo¿na
zauwa¿yæ przestrzeñ wymiany nie jest wykorzystywana jednak, na potrzeby tego
dokumentu, utorzymy dodatkowe 32 MB pamiêci wirtualnej.

<p>
Pierwszym krokiem, niezbêdnym do wykorzystania pliku jako pamiêci wirtualnej
jest utworzenie tego pliku. Najlepszym narzêdziem do tego bêdzie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Oto przyk³ad stworzenia pliku <t>/var/swap</i> o rozmiarze 32 MB.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Kiedy plik bêdzie gotowy nale¿y oznaczyæ go jako dodatkow± przestrzeñ
wymiany. U¿yj poni¿szych poleceñ aby dodaæ do systemu plik jako urz±dzenie
pamiêci wirtualnej.

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
Teraz nale¿y siê upewniæ czy dodatkowa pamiêæ wirtualna jest dostêpna.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Po prawid³owym utworzeniu i skonfigurowaniu pliku wymiany mo¿na umie¶ciæ 
odpowiedni wpis w <i>/etc/fstab</i> aby przy ka¿dym starcie systemu
automatycznie w³±czyæ wykorzystanie dodatkowej pamiêci wirtualnej.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>Plik wymiany poprzez urz±dzenie vnode</h3>

<p>
Opisana poni¿ej metoda jest trwa³ym sposobem na dodatkow± pamiêæ wirtualn±.
Po pierwsze nale¿y przygotowaæ j±dro z urz±dzeniem vnd0c jako plikiem
wymiany. Je¶li na wd0a znajduje siê g³ówny system plików, a wd0b jest
dotychczas wykorzystywan± partycj± wymiany, wystarczy zmieniæ jedn±
liniê w pliku konfiguracyjnym kernela, w sposób pokazany poni¿ej, a nastêpnie
skompilowaæ j±dro:

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
Po odpowiednim przygotowaniu j±dra, niezbêdne bêdzie utorzenie pliku wymiany.
Pos³u¿ymy siê w tym celu identycznym poleceniem jak w poprzednim przyk³adzie.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Nastêpnie nale¿y umie¶ciæ odpowiedni wpis w pliku <i>/etc/fstab</i>.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
W tym momencie niezbêdne jest ponowne uruchomienie komputera, tak
aby wykorzystywa³ ju¿ nowe j±dro. Po tym przychodzi czas na konfiguracjê
urz±dzenia wymiany. Wykonuje siê to przy pomocy narzêdzia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
Ostatni krok polega na w³±czeniu dodatkowej pamiêci wirtualnej. Wykorzystamy
do tego, podobnie jak w poprzednim przyk³adzie, polecenie swapctl(8).
Po wszystkim, komend± <tt>swapctl -l</tt> warto sprawdziæ czy wszystko
przebieg³o zgodnie z naszym ¿yczeniem.

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>


<p>
Soft Updates, w swej pierotnej wersji, zosta³o opracowane przez
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a> dla FreeBSD,
który bazowa³ na ideii wysnutej przez
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
i Yale Patt</a>.
SoftUpdates narzuca konieczno¶c uprzedniego zamawienie operacji w buforze
pamiêci podrêcznej co pozwala zrezygnowac z kodu FFS odpowiedzialnego za
synchroniczne zapisywanie wpisów katalogow. Dzieki temu daje siê zauwa¿yæ
bardzo du¿y przyrost wydajno¶ci dla operacji zapisu.

<p>
fsck(8) wykonywany w tle, podczas u¿ywania Soft Updates w OpenBSD nie
jest jeszcze zaimplementowany. Nadal konieczne jest u¿ywanie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
po ka¿dym nieprawid³owym zamkniêciu systemu. Byæ mo¿e zmieni siê to
w kolejnych wydaniach.

<p>
Aby korzystaæ z dobrodziejstw Soft Updates, j±dro musi mieæ wkompilowan± ich
obs³ugê:

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
Kernel GENERIC ma t± opcjê w³±czon±.

<p>
Soft Updates w³±czane jest podczas montowania systemów plików. Montuj±c
partycjê poleceniem  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a> 
nale¿y zaznaczyæ, ¿e chcemy korzystaæ z Soft Updates.
Poni¿ej znajduje siê przyk³adowy wpis w pliku
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
pokazuj±cy u¿ycie Soft Updates dla partycji <i>sd0a</i>.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Uwaga dla u¿ytkowników architektury <tt>sparc</tt>: Nie nale¿y w³±czaæ
Soft Updates na maszynach sun4 i sun4c. Pozwalaj± one na wykorzystanie
przez j±dro jedynie niewielkiej ilo¶ci pamiêci, przez co nie mog±
wykorzystywaæ Soft Updates. Problem ten nie dotyczy komputerów sun4m.
  
<a name="Boot386"></a>
<h2>14.6 - Jak wygl±da bootowanie OpenBSD?</h2>
Proces uruchamiania OpenBSD/i386 nie jest rzecz± banaln±, a zrozumienie jej
bêdzie pomocne przy rozwi±zywaniu ró¿norakich problemów. Bootowanie
OpenBSD sk³ada siê czterech g³ównych czê¶ci.
<ol>
<li><b><i>Master Boot Record (MBR):</i></b>
Master Boot Record jest to pierwszy fizyczny sektor (512 bajtów) dysku.
Zawarta jest w nim tablica partycji oraz niewielki program który ³aduje
PBR (ang. Partition Boot Record). Proszê zwróciæ uwagê, ¿e w niektórych
¶rodowiskach termin "MBR" u¿ywany jest do okre¶lenia jedynie czê¶ci, w której
zawarty jest kod ³aduj±cy, a nie ca³ego pierwszego bloku na dysku (w³±cznie
z tablic± partycji). Szczególnie istotne jest zrozumienia znaczenia
"inicjalizacji MBR" - co w terminologii OpenBSD oznacza nadpisanie od nowa
ca³ego sektora MBR, a nie tylko programu ³aduj±cego, jak to spotyka siê
w niektórych systemach operacyjnych. Nie jest to zbyt czêsto przeprowadzana
operacja. Zamiast tego czê¶ciej u¿ywa siê opcji "-u" programu fdisk(8)
("<tt>fdisk -u wd0</tt>").

<p>
Chocia¿ OpenBSD dostarcza w³asny MBR nie jest konieczne instalowanie go na
dysku - generalnie dowolny MBR jest w stanie za³adowaæ OpenBSD. Do
zarz±dzania MBR-em s³u¿y program fdisk(8), który u¿ywany jest zarówno do
edycji tablicy partycji, a tak¿e do instalacji kodu MBR na dysku.

<p>
MBR OpenBSD przy uruchomieniu wy¶wietla komunikat podobny do poni¿szego:
<pre>
    Using Drive: 0 Partition: 3
</pre>
Okre¶la on numer dysku oraz partycji z której zostanie za³adowany PBR.

<li><b><i>Partition Boot Record (PBR):</i></b>
Partition Boot Record w skrócie PBR, nazywany tak¿e 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(od kiedy plik o tej nazwie przechowuje program ³aduj±cy) jest to pierwszy
fizyczny sektor na partycji OpenBSD na dysku. PBR to "program ³aduj±cy
pierwszego poziomu". Sam PBR wczytywany jest do pamiêci przez kod znajduj±cy
siê w MBR, a jego zadaniem jest uruchomienie programu ³aduj±cego drugiego
poziomu -
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
Podobnie jak MBR, PBR jest bardzo ma³ym programem: kod i dane to nie wiêcej
jak 512 bajtów. Ta ilo¶æ nie wystarczy do stworzenia aplikacji obs³uguj±cej
system plików, tak wiêc umiejscowienie <tt>/boot</tt> na dysku, w miejscu
dostêpnym dla BIOS-u komputera, zakodowywane jest na sta³e w PBR podczas
jego instalacji.

<p>
Instalacja PBR odbywa siê przy pomocy programu
+<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>,
który szczególowo opisany jest <a href="faq14.html#InstBoot">w dalszej czêsci
tego dokumentu</a>.
Podczas uruchamiania PBR wy¶wietla komunikat podobny do poni¿szego:
<pre>
    reading boot....
</pre>
wypisuj±c na ekranie kropkê wraz z ka¿dym odczytanym sektorem.

<li><b><i>Program £aduj±cy Drugiego Poziomu (ang. Second Stage Boot Loader)
 <tt>/boot</tt>:</i></b> <tt>/boot</tt> jest ³adowany przez PBR, a jego
zadaniem jest uzyskanie dostêpu do systemu plików OpenBSD, a nastêpnie
odszukanie i za³adowanie j±dra do pamiêci. Dziêki boot(8) mo¿liwe jest
tak¿e przekazanie ró¿nych opcji i informacji do kernela.

<p>
boot(8) jest programem interaktywny. Po za³adowaniu przystêpuje on do
odczytania swojego pliku konfiguracyjnego <tt>/etc/boot.conf</tt> i wykonania
zawartych w nim poleceñ (domy¶lna instalacja OpenBSD nie tworzy jednak
takiego pliku). Je¶li brak pliku <tt>/etc/boot.conf</tt> lub zawarte
w nim polecenia nie za³aduj± j±dra OpenBSD, przed u¿ytkownikiem uka¿e siê
znak zachêty:

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.02
     boot>
</pre>

W tym momencie u¿ytkownik ma (w domy¶lnej instalcji) piêæ sekund aby wydaæ
polecenie inne polecenie, je¶li tego nie zrobi, boot(8) za³aduje j±dro
nazwane <tt>bsd</tt> znajduj±ce siê na g³ównej partycji pierwszego dysku
twardego. Program ³aduj±cy drugiego poziomu rozpoznaje sprzêt zainstalowany
w komputerze na podstawie danych odczytanych z BIOS-u (jako, ¿e j±dro
OpenBSD nie jest jeszcze za³adowane). Powy¿ej mo¿na zobaczyæ, ¿e boot(8)
odnalaz³:
<ul>
<li><b>pc0</b> - standartowa klawiatura oraz karta graficzna dla komputerów
i386.
<li><b>com0, com1</b> - dwa poty szeregowe.
<li><b>apm</b> - Funkcje zarz±dzania energi± (ang. Advanced Power Management).
<li><b>636k 190M</b> - Rozmiar dostêpnej konwencjonalnej (poni¿ej 1 MB)
oraz rozsze¿onej (powy¿ej 1 MB) pamiêci.
<li><b>fd0 hd0+</b> - Napêdy dysków - w tym przypadku jedna stacja
dyskietek oraz dysk twardy.
</ul>

Znak '+' po "hd0" oznacza, ¿e dostêp do dysku odbywa siê w trybie LBA.
Podczas pierwszej instalacji OpenBSD, mo¿na zauwa¿yæ znak '*' po symbolu
dysku twardego - oznacza to, ¿e na tym dysku nie znaleziono poprawnej
etykiety dysku.

<li><b><i>J±dro: <tt>/bsd</tt></i>:</b> celem bootowania jest za³adowanie
j±dra OpenBSD do pamiêci i poprawne uruchomienie go. W momencie gdy
j±dro znajdzie siê w pamiêci komputera OpenBSD zaczyna komunikowaæ siê
bezpo¶rednio ze sprzêtem bez pomocy BIOS-u.
</ol>

Poni¿szy przyk³ad przedstawia najczêstszy przebieg bootowania OpenBSD:
<blockquote><pre>
Using Drive: 0 Partition: 3                      <b><i>&lt;- MBR</i></b>
reading boot....                                 <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.02
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i><- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.4 (GENERIC) #18: Wed Sep 17 03:34:47 MDT 2003
   ...
</pre></blockquote>


<h3>Jakie przeszkody mo¿na napotkaæ podczas bootowania OpenBSD/i386?</h3>
<ul>
<li><b>B³êdny lub niekompatybilny MBR:</b>
W najczêstszych przypadkach dysk posiada ju¿ jaki¶ MBR, zdarzyæ siê mo¿e
jednak, ¿e dysk jest zupe³nie nowy lub zosta³ przeniesiony z innej platformy
sprzêtowej, a na pytanie "Czy u¿yæ ca³y dysk" (ang. "Use entire disk") podczas
<a href="faq4.html#Disks">instalcji systemu</a> udzieli³e¶ odpowiedzi
przecz±cej mo¿e okazaæ siê, ¿e na dysku nie istnieje MBR, a tym samym
za³adowani systemu nie jest mo¿liwe (pomimo tego, ¿e dysk posiada
prawid³ow± tablicê partycji).

<p>
Mo¿na zainstalowaæ OpenBSD MBR na dysku przy pomocy programu fdisk(8).
Wystarczy uruchomiæ system z medium instalacyjnego, wybraæ opcjê
"Shell", a po ukazaniu siê znaku zachêty wpisaæ:

<pre>
    # <b>fdisk -u wd0</b>
</pre>

Mo¿na równie¿ okre¶liæ jaki MBR ma byæ zapisany na dysku:
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre>

Powy¿sze polecenie spowoduje zapisanie pliku <tt>/usr/mdec/mbr</tt> jako
MBR na dysku. Ten plik jest standartowym MBR OpenBSD i jest on tak¿e
wbudowany w polecenie fdisk, ale nic nie stoi na przeszkodzie by w tym
miejscu wskazaæ inny, prawid³owy kod MBR.

<li><b>B³êdna lokalizacja <tt>/boot</tt> w PBR:</b>
Podczas instalacji Partition Boot Record, program installboot(8) zapisuje
w nim fizyczne umiejscowienie na dysku pliku <tt>/boot</tt>. Tak wiêc
usuniêcie b±dz zamiamiana pliku <tt>/boot</tt> bez ponownego uruchomienia
<a href="faq14.html#InstBoot">installboot(8)</a> spowoduje, ¿e zabootowanie
systemu stanie siê niemo¿liwe, jako ¿e PBR spróbóje za³adowaæ z dysku dane,
które z pewno¶ci± nie s± programem ³aduj±cym drugiego poziomu. Z racji
tego, ¿e <tt>/boot</tt> jest ³adowany przy u¿yciu wywo³añ BIOS-u, zmiana
geometrii dysku (np. przeniesienie napêdu z jednego komputera, u¿ywaj±cego
translacji CHS do drugiego, który wykorzystuje translacjê LBA, lub nawet
zmiana sposobu t³umaczenia geometrii dysku w BIOS-ie) spowoduje, ¿e
wg BIOS-u plik <tt>/boot</tt> znajdzie siê w zupe³nie innym miejscu dysku,
tak wiêc konieczne bêdzie wykorzystanie programu installboot(8) przed 
ponownym uruchomieniem systemu.

Jako ¿e PBR jest bardzo ma³y, tak i komunikaty o b³êdach s± bardzo lakoniczne:
<ul>
<li><b>Read Error</b> - BIOS zwróci³ b³±d podczas próby odczytu z dysku.
Mo¿e byæ to spowodowane uszkodzeniem dysku b±d¼ prób± odwo³ania siê do
nieistniej±cego sektora (np. w wyniku niew³a¶ciwego ustawienia geometrii dysku).
<li><b>Bad magic</b> - nieprawid³owy magiczny numer (zobacz stronê podrêcznika
systemowego <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>)
odczytany z nag³ówka programu ³aduj±cego drugiego poziomu. Zasadniczo oznacza
to, ¿e cokolwiek zosta³o odczytane z dysku napewno nie jest to <tt>/boot</tt>.
Najczê¶ciej zwi±zane jest to ze zmian± geometrii dysku, zmian± pliku
<tt>/boot</tt> lub zignorowaniem <a href="faq14.html#LargeDrive">
ograniczenia 8GB</a> w danym systemie.
</ul>
</ul>

Bardziej szczegó³owe informacje o procesie ³adowania OpenBSD/i386 mo¿na
znale¼æ w poni¿szych dokumentach:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
Dokument Hala Landisa pt. "How it Works".
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - O czym nale¿y wiedzieæ u¿ywaj±c du¿ych dysków w OpenBSD?</h2>
<!-- XXX version i386 changes for 3.5 -->

<p>
OpenBSD obs³uguje systemy plików o wiele wiêksze ni¿ wynosi pojemno¶æ 
dysków, które mo¿na kupiæ ju¿ dzi¶ lub te, które znajd± siê na rynku w
niedalekiej przysz³o¶ci. Jednak pewne ograniczenia, dotycz±ce niektórych
kontrolerów, powoduj±, ¿e rzeczywista granica pojemno¶ci dysków jest
mniejsza ni¿ teoretyczne maksimum dla OpenBSD.

<p>
Nie wszystkie mo¿liwe kombinacje sprzêtu bêd± poprawnie obs³ugiwane. Nowy,
250 gigabajtowy, dysk IDE nie bêdzie pracowa³ ze starym (obs³uguj±cym
napêdy &gt;137 GB) kontrolerem. Podobne problemy mog± dotyczyæ adapterów
SCSI.

<h3>Ograniczenia pojemno¶ci i rozmieszczenia partycji</h3>
Na nieszczê¶cie wszystkie mo¿liwo¶ci danego OS nie s± dostêpne zanim
zostanie on za³adowany do pamiêci i ju¿ sam proces bootowania wprowadza
ograniczenia. Podczas rozruch komputera wykorzystywane s± procedury
umieszczone w BIOS-ie (i to w³a¶nie jest przyczyn± niektórych ograniczeñ).
Program ³aduj±ce pierwszego poziomu dla platformy i386
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>)
posiadaja wewnetrzne ograniczenie pojemno¶ci do 8 GB, zwi±zane
w³a¶nie z ograniczeniami starszych BIOS-ów.
 
<p>
Z tej w³a¶nie przyczyny, ca³y plik /bsd (czyli j±dro) musi znajdowaæ
siê wewn±trz obszaru, który jest dostêpny dla procedur bootuj±cych
z BIOS-u, lub wewn±trz pierwszych 8 GB dysku, w zale¿no¶ci od tego,
która granica jest mniejsza. Oznacza to, ¿e niektóre stare komputer
i386, musz± posiadaæ g³ówn± partycjê znajduj±c± siê w pierwszych
504 MB, a dla wiêkszo¶ci nowych maszyn partycja '/' musi znajdowaæ
siê poni¿ej 8 GB.

<p>
Zauwa¿, ¿e mo¿liwe jest zinstalowanie 40 GB dysku i za³adowanie OpenBSD
z jednej wielkiej partycji na starej maszynie i486. Mo¿esz pomy¶leæ, ¿e
uda³o siê pomy¶lnie z³amaæ opisane powy¿ej ograniczenia. Jednak do¶æ
szybko prawda mo¿e wyj¶æ na jaw i to w ca³kiem nieprzyjemny sposób:

<ul>
  <li>System zosta³ zainstalowany na 40 GB partycji <tt>/</tt>. Bêdzie
      dzia³a³ dlatego, ¿e bazowa instalacja OpenBSD wraz z wszystkimi
      plikami (w³±czaj±c w to <tt>/bsd</tt>) zmie¶ci siê w pierwszych
      504 MB.
  <li>Z czasem, w miare jak system bêdzie siê rozrasta³, pliki zaczn±
      byæ zapisywane powy¿ej 504 MB.
  <li>Po aktualizacji, przychodzi moment na kompilacjê kernela.
      Stary plik <tt>/bsd</tt> nie jest ju¿ potrzebny, wiêc zostanie
      on nadpisany przez nowe j±dro.
  <li>Ponowne uruchomienie komputera ...
  <li>... i zamiast ulubionego systemu twoim oczom ukazuje siê
      komunikat "bsd magic"!
</ul>

<p>
Dlaczego? Nawet je¶li stary plik <tt>/bsd</tt> zosta³ zast±piony
nowym, jego nowa wersja nie znajduje siê dok³adnie w tym samym
miejscu co poprzednik. Najprawdopodobniej gdzie¶ powy¿ej granicy
504 MB obs³ugiwanej przez BIOS. Program ³aduj±cy nie jest w stanie
odczytaæ pliku j±dra i system zatrzymuje siê.

<p>
Proces bootowania OpenBSD wymaga, aby programy ³aduj±ce (biosboot(8) i
<tt>/boot</tt> w przypadku i386) oraz j±dro (<tt>/bsd</tt>) znajdowa³y
siê w obszarze, który jest obs³ugiwany przez BIOS. Mo¿na to
rozwi±zaæ w bardzo prosty sposób:

<p>
<b>Ca³a partycja '/' musi znajdowaæ sie wewn±trz obszaru, który jest
dostêpny dla BIOS-u komputera lub wen±trz pierwszych 8 GB, w zale¿no¶ci,
która warto¶æ jest mniejsza.</b>
<br><i>Uwaga: ograniczenie 8 GB dla OpenBSD/i386 zosta³o usuniête w wersji
-current systemu. Nadal jednak nale¿y respektowaæ ograniczenia BIOS-u.</i>

<p>
Opisane wy¿ej problemy s± jeszcze jednym dobrym powodem, aby
<a href="faq4.html#SpaceNeeded">podzieliæ dysk na partycje</a>, zamiast
u¿ywaæ jednej du¿ej partycji.

+<h3>fsck(8) time and memory requirements</h3>
+Another consideration with large file systems is the time and memory
+required to
+<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
+the file system after a crash or power interruption.
+One should not put a 120G file system on a system with 32M of RAM and
+expect it to successfully fsck(1) after a crash.
+A rough guideline is the system should have at least 1M of available
+memory for every 1G of disk space to successfully fsck the disk.
+The time required to fsck the drive may become a problem as the file
+system size expands.

<a name="InstBoot"></a>
<h2>14.8 - Instalacja bootbloku - tylko i386</h2>

<p>
Starsze wersje systemu MS-DOS poprawnie radzi³y sobie tylko z dyskami
posiadaj±cymi nie wiêcej jak 1024 cylindry. Poniewa¿ wszystkie nowsze
dyski posiadaj± wiêcej niz 1024 cylindry, wiêkszo¶æ BIOS-ów, czy to
z kontrolerów SCSI, czy te¿ IDE (w tym wypadku BIOS kontrolera jest
zazwyczaj czê¶ci± BIOS-u ca³ego komputera) posiadaj± opcjê
"t³umacz±c±" prawdziw± geometriê dysku na co¶, co jest zrozumia³e
przez MS-DOS. Jednak¿e nie wszystkie BIOS-y dokonuj± translacji w ten
sam sposób. Po zmianie BIOS-u (np.: gdy wymienisz p³ytê g³ówn± lub
kontroler SCSI), a sposób "t³umaczenia" geometrii dysku bêdzie ró¿ni³
siê od poprzednika, niemo¿liwe stanie siê uruchomienie programu
³aduj±cego drugiego poziomu, a w efekcie wczytanie j±dra do pamiêci.
(Dzieje siê tak dlatego, ¿e boot loader pierwszego poziomu zawiera
listê sektorów zawieraj±cych w sobie program /boot zapisanych w
zgodnie z wcze¶niejszym sposobem translacji.) W przypadku dysków
IDE, przy okazji zmian w ustawieniach BIOS-u, mo¿na (w sposób
przypadkowy) zmieniæ tak¿e sposób translacji (wiêkszo¶æ BIOS-ów IDE
oferuje trzy ró¿ne metody). W takich sytuacjach konieczne bêdzie
uaktalnienie bootbloku aby umo¿liwiæ ponowny start systemu. Nale¿y
pos³u¿yæ siê dyskietk± bootuj±c± (lub p³yt± CD) i przy znaku zachêty
programu ³aduj±cego napisaæ: "b hd0a:/bsd", by wymusiæ start
z pierwszego dysku twardego, a nie dyskietki. OpenBSD powinno
uruchomiæ siê w normalny sposób. W tym momencie nale¿y uaktualniæ
program ³aduj±cy pierwszego poziomu aby móg³ poprawnie odczytaæ
now± geometriê dysku (i od nowa zapisa³ bootblok).
<br> Poni¿szy przyk³ad zak³ada, ¿e dyskiem startowym bêdzie sd0 (je¶li
posiadasz interfejs IDE bêdzie to wd0, itd.):

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
Je¶li installbot(8) nie zdo³a odczytaæ geometrii z BIOS-u, mo¿na
wykorzystaæ polecenie programu ³aduj±cego &quot;machine diskinfo&quot;
(w skrócie &quot;ma di&quot;) aby uzyskaæ interesuj±ce nas informacje.
Wpisz warto¶ci podane w polach &quot;heads&quot; i &quot;secs&quot;
jako parametry programu installboot(8), odpowiednio -h i -s. Nowe
polecenie bêdzie teraz wygl±daæ w ten sposób:

<pre>
#<b> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</b>
</pre>

<p>
Je¶li potrzebujesz nowszej wersji bootbloku, mo¿esz j± samodzielnie
skompilowaæ. To bardzo proste:

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (lub jakiekolwiek inne urz±dzenie)
</pre>

<a name="Backup"></a>
<h2>14.9 - Zapobieganie katastrofie: archiwizowanie i odtwarzanie z ta¶my</h2>

<h3>Wstêp:</h3>

<p>
Je¶li uruchomi³e¶ w³a¶nie maszynê wykorzystywan± jako serwer produkcyjny
zalecane jest posiadanie kopii bezpieczeñstwa na wypadek, gdyby który¶
z dysków zawiód³.

<p>
Poni¿sze informacje pomog± zaznajomiæ Czytelnika z programami 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>,
znajduj±cymi siê w standartowej instalacji OpenBSD. Bardziej zaawansowane
narzêdzie do robienia kopii zapasowych, "Amanda" dostêpne
w <a href="faq8.html#Ports">kolekcji portów</a>, pozwala tak¿e
archiwizowaæ dane z wielu serwerów na jednej ta¶mie. W wiêkszo¶ci
przypadków, narzêdzia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
wystarcz±. Jednak, jak ju¿ zosta³o wcze¶niej napisane, je¶li chesz
zarchiwizowaæ dane z kilku maszyn na jedn± ta¶mê, Amanda mo¿e byæ
godna uwagi.

<p>
Urz±dzenia opisane w tym dokumencie, zarówno dyski jak i streamery, to
urz±dzenia wykorzystuj±ce interfejs SCSI. W ¶rodowisku produkcyjnym,
zaleca siê raczej u¿ycie dysków SCSI ni¿ IDE. Wynika to ze sposobu w
jaki oba interefejsy radz± sobie z uszkodzonymi sektorami. Nie znaczy to
jednak, ¿e informacje tutaj zawarte s± bezu¿yteczne je¶li wykorzystujesz
dyski IDE lub ta¶my innego rodzaju, po prostu urz±dzenia bêd± nosi³y
troszke inne nazwy. Na przyk³ad odpowiednikiem sd0a w przypadku IDE
bêdzie wd0a.

<h3>Archiwizowanie danych na ta¶mê</h3>

<p>
Aby zarchiwizowaæ dane na ta¶mê, nale¿y najpierw sprawdziæ, gdzie s± 
podmontowane systemy plików. Mo¿na siê tego dowiedzieæ u¿ywaj±c
z poziomu konsoli polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
Wynik powinien wygl±daæ mniej wiêcej tak:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
W naszym przypadku, partycja root (/), istnieje fizycznie na sd0a,
co oznacza dysk twardy SCSI nr 0, partycjê a. System plików /usr
jest na sd0h, czyli na dysku twardym SCSI nr 0, na partycji h.

<p>
Inny, bardziej zaawansowany przyk³ad:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
W tym przyk³adzie, system plików root (/), rezyduje na sd0a,
/var na sd0d, /home na sd0e za¶ /usr na sd0h.

<p>
Aby zarchiwizowaæ swoje dane, nale¿y podaæ programowi dump nazwê ka¿dej
partycji twardego dysku. Oto, jak nale¿a³oby zarchiwizowaæ maszynê z 
naszego pierwszego, prostszego przyk³adu:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Z kolei w przypadku drugiego, bardziej zaawansowanego przyk³adu,
nale¿a³o by u¿yæ poleceñ:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Proszê zajrzeæ do strony podrêcznika systemowego polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>,
aby dowiedzieæ siê, jakie znaczenie maj± poszczególne flagi tego programu.
My przedstawimy jedynie krótki opis opcji u¿ytych w naszym przypadku:

<ul>
<li><b>0</b> - Dokonaj archiwizacji na poziomie 0, czyli skopiuj
               wszystkie pliki.
<li><b>a</b> - Próbuj automatycznie wykryæ pojemno¶æ ta¶my.
<li><b>u</b> - Zaktualizuj plik /etc/dumpdates, aby zaznaczyæ datê archiwizacji.
<li><b>f</b> - Okre¶la, wykorzystywane urz±dzenie ta¶mowe 
               (w naszym przypadku /dev/nrst0).
</ul>

<p>
I, ostatecznie, któr± partycjê zarchiwizowaæ (/dev/rsd0a, itd.).

<p>
Polecenie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
s³u¿y do przewijania ta¶my. Proszê przeczytaæ stronê podrêcznika systemowego
polecenia mt, by zapoznaæ siê jego opcjami (takimi jak <tt>eject</tt>).

<p>
Je¶li istnieje niepewno¶æ co do nazwy urz±dzenia ta¶mowego, proszê pos³u¿yæ
siê poleceniem dmesg. Przyk³adowy opis urz±dzenia ta¶mowego w dmesg mo¿e
wygl±daæ tak:

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
Uwa¿ny Czytelnik zapewne dostrzeg³, ¿e przy archiwizowaniu urz±dzenie 
ta¶mowe nazywa siê "nrst0", a nie "st0", jak podaje dmesg. Odwo³uj±c
siê do st0 jako do nrst0 zaznaczamy, ¿e nie chcemy przewijaæ ta¶my
po dokonaniu archiwizacji, a ¿±damy dostêpu do urz±dzenia w trybie
surowym. Jest to niezbêdne by zarchiwizowaæ kilka systemów plików na 
jednej ta¶mie. W przeciwnym przypadku, drugi archiwizowany system
plików nadpisze pierwszy, trzeci drugi itd. Dok³adniejszy opis ró¿nych
urz±dzeñ ta¶mowych znale¼æ mo¿na w podrêczniku systemowym polecenia 
dump.

<p>
Napiszemy teraz ma³y skrypt archiwizuj±cy (nazwiemy go "backup")

<pre>
echo "  Rozpoczynam pe³n± archiwizacjê..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Przewijanie ta¶my, proszê czekaæ..."
mt -f /dev/rst0 rewind
echo "Gotowe."
echo
</pre>

<p>
Je¶li chcemy tworzyæ kopie zapasowe np. codziennie w nocy, to
mo¿na u¿yæ programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
który bêdzie urchamia³ nasz skrypt "backup" automatycznie.


<p>
Bardzo pomocne jest zapisanie sobie (np. na skrawku papieru) jak du¿o
miejsca na dysku zajmuje ka¿da partycja. Mo¿na do tego celu u¿yæ komendy
df -h. Bêdzie to przydatne, je¶li napêd zawiedzie i trzeba bêdzie
odtworzyæ tablicê partycji na nowym dysku.

<p>
Przywracanie danych spowoduje równie¿ zmniejszenie siê fragmentacji.
Aby na pewno zarchiwizowaæ wszystkie pliki, najlepiej jest zrestartowaæ
komputer i uruchomiæ system w trybie pojedyñczego u¿ytkownika. Nie 
trzeba podmontowywaæ systemów plików, aby je zarchiwizowaæ. Po 
zalogowaniu siê w trybie pojedynczego u¿ytkownika trzeba jednak 
podmontowaæ partycjê root (/) w trybie r/w. W przeciwnym przypadku
program dump zg³osi b³±d przy zapisywaniu danych o zrzutach. Aby 
zalogowaæ siê w trybie pojedynczego u¿ytkownika, nale¿y wpisaæ
"bsd -s" po znaku zachety "boot&gt;", pojawiaj±cym siê w trakcie
uruchamiania systemu.

<h3>Wy¶wietlanie zawarto¶ci ta¶my</h3>

<p>
Po dokonaniu pierwszej archiwizacji, dobrze jest upewniæ siê, ¿e na
ta¶mie jest rzeczywi¶cie to, czego oczekiwali¶my.

<p>
Mo¿na wydaæ nastêpuj±c± komendê by wy¶wietliæ zawarto¶æ ta¶my, na któr±
dokonali¶my zrzutu:

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
Wypisze to listê plików istniej±cych na pierwszej partycji ta¶my. Zazwyczaj
jest to system plików root (/).

<p>
Aby sprawdziæ, co zawiera druga partycja i zapisaæ wynik do pliku,
wystarczy u¿yæ nastêpuj±cego polecenia:

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
w przypadku naszego prostszego przyk³adu, numer 2 oznacza³by /usr, za¶
w przypadku trudniejszego - /var. Jak widaæ, partycje s± zapisywane
na ta¶mê w takiej kolejno¶ci, w jakiej s± na dysku.


<h3>Przywracanie danych z ta¶my</h3>

<p>
Przyk³adowy scenariusz przedstawiony poni¿ej jest przydatny w przypadku,
gdy dysk twardy kompletnie zawiedzie. Je¿eli naszym celem jest 
odtworzenie pojedynczego pliku, to nale¿y zaznajomiæ siê ze stron±
podrêcznika systemowego programu restore, zwracaj±c podczas lektury 
szczególn± uwagê na instrukcje trybu interaktywnego.

<p>
Wymiana dysku i przywracanie danych z ta¶my jest zwykle procesem szybkim
i ³atwym. Standardowa dyskietka instalacyjna (bootuj±ca) OpenBSD zawiera
zarówno wymagane narzêdzie "restore", jak i binaria wymagane do 
zpartycjonowania i ustawienia nowego dysku jako bootowalny. W wiêkszo¶ci
przypadków, dyskietka ta i ta¶ma ze zrzutem zawarto¶ci dysku s± wszystkim,
co potrzeba mieæ, aby odtworzyæ system.


<p>
Po fizycznej wymianie zepsutego dysku na nowy, nale¿y postêpowaæ w
nastêpuj±cy sposób:

<ul>
<li>
<p>
Bootujemy komputer z dyskieti instalacyjnej OpenBSD. W menu 
wybieramy "Shell". Nastêpnie zabezpieczamy przed zapisem i wk³adamy 
nasz± najbardziej aktualn± ta¶mê z kopi± zapasow± systemu.

<br>
<li>
<p>
U¿ywaj±c programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>,
tworzy siê podstawow± partycjê OpenBSD na nowym dysku. Przyk³ad:

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
Wiêcej informacji na temat <tt>fdisk</tt> znajduje siê w
<a href="#fdisk">rozdziale o programie fdisk</a>.


<li>
<p>
U¿ywaj±c polecenia disklabel, odtwarzamy nasze tablicê partycji OpenBSD
wewn±trz naszej podstawowej partycji, któr± przed chwil± stworzyli¶my
za pomoc± fdiska. Przyk³ad:

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(Proszê nie zapomnieæ o partycji swap, wiêcej informacji znajduje siê w 
<a href="#disklabel">rozdziale o disklabel FAQ</a>).

<li>
<p>
U¿ywaj±c polecenia newfs, budujemy czysty system plików na ka¿dej partycji
stworzonej w poprzednim kroku. Przyk³ad:

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
Montujemy nowoprzygotowany system plików root (/) na /mnt. Przyk³ad:

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
Wchodzimy do partycji root i zaczynamy proces przywracania danych.
Przyk³ad:

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
Trzeba jeszcze ustawiæ dysk jako bootowalny. Trzeba wiêc zapisaæ
na dysku nowy MBR. S³u¿y do tego polecenie:

<pre>
# <b>fdisk -i sd0</b>
</pre>


<li>
<p>
Oprócz zapisania nowego MBR, aby móc z niego bootowaæ, nale¿y jeszcze 
zainstalowaæ bootblock. Oto krótki przyk³ad:

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
W tym momencie nowy system plików root na dysku twardym powinien byæ
ju¿ przygotowany, mo¿na wiêc z niego uruchomiæ system i 
kontynuowaæ przywracanie reszty systemów plików. Poniewa¿ system 
operacyjny nie jest w tym momencie jeszcze do koñca odtworzony, nale¿y
ponownie uruchomiæ go w trybie pojedynczego u¿ytkownika. Oto przyk³ad
jak z poziomu pow³oki odmontowaæ system plików, a nastêpnie wy³±czyæ 
komputer.

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
Usuñ dyskietkê instalacyjn± z napêdu i ponownie uruchom komputer. Po
pojawieniu siê znaku zachêty programu ³aduj±cego OpenBSD, wpisz poni¿sz±
komendê:

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
<tt>bsd -s</tt> spowoduje, ¿e kernel uruchomi siê w trybie jednego
u¿ytkownika (do pracy w tym trybie wymagana jest tylko partycja root (/)).

<li>
<p>
Zak³adaj±c, ¿e wszystkie opisane do tej pory czynno¶ci zosta³y poprawnie
wykonane i nie wyst±pi³y ¿adne b³êdy, po uruchomieniu systemu pojawi siê
pytanie o ¶cie¿kê do pow³oki. Naci¶niêcie return uruchomi pow³oke sh.
Nastêpnie mo¿esz chcieæ zamonotowaæ g³ówny system plików w trybie
do odczytu/zapisu (w tym momencie mo¿liwy jest tylko odczyt).

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
Je¶li jest ju¿ mo¿liwy zapis na partycji root (/), mo¿na przyst±piæ do
dalszej czê¶ci odtwarzania systemu z kopii zapasowej.

<pre>
(prostszy przyk³ad )
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(bardziej zaawansowany przyk³ad)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
U¿ycie opcji <b>rvsf</b> zamiast <b>rsf</b> polecenia <b>restore</b>
spowoduje, ¿e na ekranie bêd± wy¶wietlane nazwy aktualnie rozpakowywanych
plików.

<li>
<p>
Po przywróceniu wszystkich systemów plików na dysku, nale¿y ponownie uruchomiæ
komputer, tym razem ju¿ w trybie wielou¿ytkownikowym. Je¶li wszystko
posz³o zgodnie z planem dostêpny bêdzie system dok³adnie w takim stanie
w jakim znajdowa³ siê chwili wykonywania kopii.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Montowanie obrazów dysków w OpenBSD</h2>


<p>
Aby zamontowaæ obraz dysku (np. obraz ISO, obraz dysku stworzony za pomoc±
dd itp.), nale¿y najpierw skonfigurowaæ urz±dzenie 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&sektion=4">vnd(4)</a>.

Na przyk³ad, je¿eli obraz ISO jest umieszczony w pliku <i>/tmp/ISO.image</i>,
to aby go zamontowaæ nale¿y wydaæ nastêpujace polecenia:

<table border=0 width="650">
<tr>
<td nowrap bgcolor="#EEEEEE">
<pre>

# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
</td>
</tr>
</table>

<p>
Proszê zauwa¿yæ, ¿e poniewa¿ obraz ten jest obrazem p³yty CD, to
typem zamontowanego urz±dzenia jest <i>cd9660</i>.

<p>
Do odmontowywania obrazów s³u¿± nastêpuj±ce dwa polecenia:

<table border=0 width="650">
<tr>
<td nowrap bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
</td>
</tr>
</table>

<p>
Wiêcej informacji znajduje siê w
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8">
podrêczniku systemowym programu vnconfig(8)</a>.

<a name="pciideErr"></a>
<h2>14.11 - Pomocy! Otrzymuje komunikaty o b³êdach podczas pracy z urz±dzeniami
PCIIDE!</h2>

<p>
PCI IDE DMA jest niestabilne w wielu konfiguracjach sprzêtowych. Do
niedawna, wiêkszo¶æ "mainstreamowych" systemów operacyjnych, które 
chwali³y siê obs³ug± tranferów DMA na dyskach IDE, nie mia³y domy¶lnie
w³±czonej te opcji.

<p>
OpenBSD jest agresywny i zawsze próbuje uzywaæ najwy¿szych trybów DMA jakie
s± dostêpne. W przypadku niektórych konfiguracji sprzêtowych jest to jednak
przyczyn± niszczenia danych w trakcie ich transferu. Jest to spowodowane
b³êdami w chipsetach p³yt g³ównych, b³êdami w dyskach, a tak¿e
zak³óceniem na ³±czach. Na szczê¶cie, tryb Ultra-DMA za pomoc± CRC wykrywa
uszkodzenia danych powsta³e podczas ich transferu. Kiedy sprawdzenie sumy
kontrolnej Ultra-DMA CRC zawiedzie, pojawia siê komunikat o b³êdzie i
ca³a operacja jest powtarzana. Oto przyk³ad takiego komunikatu:

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
Je¶li operacja transferu nie powiedzie siê kilka razy z rzêdu, OpenBSD
prze³±czy tryb Ultra-DMA na wolniejszy (a co za tym idzie, bardziej
niezawodny). Je¶li tryb Ultra-DMA osi±gnie w koñcu warto¶æ 0, to napêd 
przechodzi w tryb PIO.

<p>
Je¶li nie powiedzie siê operacja zmiany trybu na wolniejszy, lub je¶li
proces ten powoduje, ¿e maszyna siê zawiesza, proszê przes³aæ nam
<a href="../../pl/report.html">raport o b³êdzie</a>.

<a name="RAID"></a>
<h2>14.13 - Macierze RAID dla OpenBSD</h2>

Dziêku macierzom RAID (Redundant Array of Inexpensive Disks) mo¿na
u¿ywaæ wielu dysków w celu zwiêkszenia wydajno¶ci, pojemno¶ci i/lub 
redundacji. Pe³ne przedyskutowanie zalet i niebezpieczeñstw zwi±zanych 
z macierzami RAID nie jest zadaniem tego rozdzia³u. Nale¿y jednak 
podkre¶liæ dwa wa¿ne fakty:

<ul>
<li>Macierze RAID nie maj± nic wspólnego z kopiami zapasowymi.
<li>Same w sobie, macierze RAID nie wyeliminuj± czasu przestoju serwera.
</ul>

Je¶li te dwie rzeczy s± dla Czytelnika nowo¶ci±, to artyku³ ten nie jest 
dla niego dobrym miejscem na rozpoczêcie przygody z macierzami RAID.


<h3>Opcje programowe</h3>
OpenBSD zawiera narzêdzie RAIDframe, który programowo symuluje RAID. 
Dokumentacja tego programu znajduje siê w nastêpuj±cych miejscach:

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">Strona domowa RAIDframe</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">strona podrêcznika systemowego raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">strona podrêcznika systemowego raid(4)</a>
</ul>


<p>
Partycja root mo¿e byæ mirrorowana bezpo¶rednio przez system. Wystarczy
u¿yæ opcji "Autoconfiguration" porogramu RAIDframe.


<h3>Opcje sprzêtowe</h3>
<p>
Wiele wspieranych przez OpenBSD <a href="../../pl/plat.html">platform</a>
obs³uguje wszelakie (sprzêtowe) macierze RAID. Jakie dok³adnie, mo¿na
sprawdziæ na stronie danej platformy (mo¿na siê tam
dostaæ <a href="../../pl/plat.html">st±d</a>).

<p>
Inn± mo¿liwo¶ci±, dostêpn± dla wielu platform, jest zakup jednego z 
wielu istniej±cych na rynku urz±dzeñ, które powoduj±, ¿e kilka dysków 
IDE czy SCSI dzia³a jako jeden du¿y dysk. Takie urz±dzenia dzia³aj± 
praktycznie na ka¿dej platformie, warunkiem koniecznym jest obs³uga
interfejsu SCSI lub IDE przez ni±.

<p>
Oto niektórzy producenci takiego sprzêtu:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Uwaga: to jest tylko lista firm, których produkty, z pozytywnym skutkiem,
zosta³y przetestowane przez u¿ytkowników OpenBSD. Nie zmuszamy nikogo
do korzystania z tylko z tych urz±dzeñ!)

<h3>Opcje "nie"</h3>
<p>
Na <a href="../../pl/mail.html">listach mailingowych</a> czêsto pojawia siê
pytanie o obs³ugê przez OpenBSD kontrolerów IDE RAID firm Promise i HighPoint
Odpowiedz brzmi: nie.  Te karty i chipsety nie s± prawdziwymi sprzêtowymi
kontrolerami RAID. Jest to programowo realizowany RAID dziêki odpowiednim
procedurom zapisanym w BIOS-ie urz±dzenia. Jako ¿e OpenBSD obs³uguje RAID w
sposób niezale¿ny od sprzêtu, nie widzimy potrzeby implementacji obs³ugi
dla tych kart.

<p>
<font color= "#0000e0">
<a href= "index.html">[Spis tre¶ci]</a>
<a href= "faq12.html">[Do Sekcji 12 - Pytania dotycz±ce poszczególnych platform]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[wstecz]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq14.html,v 1.103 ]<br>
$Translation: faq14.html,v 1.10 2004/04/24 09:48:50 pl-team Exp $<br>
$OpenBSD: faq14.html,v 1.8 2004/04/26 18:16:25 jufi Exp $
</small>

</body>
</html>
