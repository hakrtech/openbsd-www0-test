<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Konfiguracja dysków</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2006 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../pl/index.html">                                                                                                                                                                        
<img alt="[OpenBSD]" src="../../images/smalltitle.gif" border="0" height="30" width="141">                                                                                                            
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Spis tre¶ci]</a>
<a href= "faq13.html">[Do sekcji 13 - Multimedia]</a>
<a href= "faq15.html">[Do sekcji 15 - Pakiety i Porty]</a>
</font>

<h1><font color="#e00000">14 - Konfiguracja dysków</font></h1>

<!--
UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Uwaga:</font></b>Zawarto¶æ tego pliku
jest ju¿ bardzo nieaktualna w stosunku do
<a href="../faq14.html">bie¿±cej wersji anglojêzycznej</a>.

<p>
Je¶li chcesz pomóc w aktualizacji tego pliku, zajrzyj na
<a href="../../translation.html">stronê t³umaczeñ</a>.
-->

<hr>

<h3>Spis tre¶ci</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Program disklabel(8) w OpenBSD</a>
<li><a href="#fdisk"      >14.2 - Program fdisk(8) w OpenBSD</a>
<li><a href="#NewDisk"    >14.3 - Dodawanie nowych dysków w OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - Plik wymiany</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Jak wygl±da bootowanie OpenBSD?</a>
<li><a href="#LargeDrive" >14.7 - O czym nale¿y wiedzieæ u¿ywaj±c du¿ych 
                           dysków w OpenBSD?</a>
<li><a href="#InstBoot"   >14.8 - Instalacja bootbloku - tylko i386/amd64</a>
<li><a href="#Backup"     >14.9 - Zapobieganie katastrofie: archiwizowanie 
                           i odtwarzanie z ta¶my.</a>
<li><a href="#MountImage" >14.10 - Montowanie obrazów dysków w OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - Pomocy! Otrzymuje komunikaty o b³êdach
                           podczas pracy z urz±dzeniami IDE DMA!</a>
<li><a href="#RAID"       >14.13 - Macierze RAID dla OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Dlaczego <tt>df(1)</tt> pokazuje, 
			    ¿e u¿ywam wiêcej ni¿ 100% dysku</a>
<li><a href="#OhBugger"   >14.15 - Przywracanie partycji po skasowaniu etykiety dysku</a>
<li><a href="#foreignfs"  >14.16 - Czy mogê dostaæ siê do danych na systemach plików
			    innych ni¿ FFS?</a>
<ul>
<li><a href="#foreignfsafter">14.16.1 - Partycje nie istniej± w moim disklabel! 
			    Co powinienem zrobiæ?</a>
</ul>
<li><a href="#flashmem"   >14.17 - Czy mogê u¿ywaæ pamiêci flash w OpenBSD?</a>
<li><a href="#DiskOpt"    >14.18 - Optymalizacja wydajno¶ci dysków</a>
<li><a href="#Async"      >14.19 - Dlaczego nie nale¿y u¿ywaæ asynchronicznego montowania dysków?</a>
</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Program disklabel(8) w OpenBSD</h2>
   
<a name="disklabel.1"></a>
<h3>Co to jest disklabel(8)?</h3>
  
<p>
Na pocz±tku proszê przeczytaæ stronê podrêcznika systemowego 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Szczegó³y konfiguracji dysków w OpenBSD ró¿ni± siê pomiêdzy ró¿nymi platformami.
Dla <a href="../../pl/i386.html">i386</a>,
<a href="../../amd64.html">amd64</a>,
<a href="../../macppc.html">macppc</a>,
<a href="../../zaurus.html">zaurus</a>,
oraz <a href="../../cats.html">cats</a>,
konfiguracja dysku nastêpuje w dwóch etapach.
Na pocz±tku okre¶lany jest "plaster" dysku przydzielony OpenBSD przy pomocy fdisk(8),
pó¼niej fragment ten jest dzielony na partycje OpenBSD przy pomocy disklabel(8).

<p>
Jednak¿e dla wszystkich platform OpenBSD, disklabel(8) jest podstawow± metod±
do zarz±dzania partycjami OpenBSD.
Platformy dla których wykorzystuje siê fdisk(8), umieszczaj± partycje disklabel(8)
na jednej partycji w rozumieniu programu fdisk(8).

<p>
Etykiety przechowuj± pewne informacje o twoim dysku, takie jak jego geometriê, 
i informacje o systemach plików na danym dysku.
Zawieraj± tak¿e informacje dotycz±ce samego dysku, takie jak prêdko¶æ obrotow±,
rozmiar przestrzeni miedzy sektorami, itd., jest tak ze wzglêdów historycznych
i czêsto dane te s± niepoprawne.
Nie przejmuj siê tym.
Dane te s± wykorzystywane przez program ³adowania pocz±tkowego
(ang. bootstrap program) do zainicjowania dysku oraz do identyfikacji
systemu plików na dysku. 
Wiêcej na ten temat mo¿na dowiedzieæ siê poprzez lekturê strony podrêcznika systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>.

<p>
Na niektórych platformach, etykiety pozwalaj± omin±æ ograniczenia danej
architektury w zakresie partycjonowania dysków.
Przyk³adowo na maszynach i386, mo¿na mieæ tylko 4 partycje podstawowe,
ale z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8),</a>
na tylko jednej podstawowej partycji pomie¶ciæ mo¿na *wszystkie*
partycje systemu OpenBSD (np. 'swap', '/', '/usr' i '/var'). Dziêki
temu pozosta³e 3 podstawowe partycje dostêpne dla innych OS.


<a name="disklabel.2"></a>
<h3>disklabel(8) podczas instalacji OpenBSD</h3>

<p>
Jedn± z g³ównych czynno¶ci dokonywanych podczas instalacji
OpenBSD jest tworzenie etykiet. 
Podczas instalacji u¿ywa siê disklabel(8) do tworzenia 
partycji.
Jako czê¶æ procesu instalacji, mo¿esz zdefiniowaæ punkty montowania
poprzez disklabel(8), ale mo¿esz to zmieniæ pó¼niej podczas instalacji
lub post-instalacji.

<p>
Nie istnieje "jedyna w³a¶ciwa" droga do tworzenia etykiet na dysku,
istnieje jednak wiele z³ych dróg.
Zanim przyst±pisz do tworzenia etykiet na dysku, zobacz 
<a href="faq4.html#Partitioning">t± dyskusjê</a> o partycjonowaniu
i rozmiarach partycji.

<p>
Jako przyk³ad korzystania z disklabel(8) podczas instalacji, zobacz
czê¶æ dotycz±c± <a href="faq4.html#Disks">Konfiguracji dysków</a>
w <a href="faq4.html">Instalacja OpenBSD</a>.

<p>
<a name="disklabel.3"></a>
<h3>Korzystanie z disklabel(8) po instalacji</h3>

<p>
Po instalacji, jednym z najczêstszych powodów korzystania z disklabel(8)
jest sprawdzenie jak twój dysk zosta³ podzielony.
Poni¿sze polecenie poka¿e ci aktualny uk³ad etykiet bez ich modyfikacji:

<blockquote><pre>
# <b>disklabel wd0</b> &lt;-- <i>albo jakiekolwiek inne urz±dzenie</i>
# Inside MBR partition 3: type A6 start 63 size 29880837
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 29888820
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size   offset    fstype   [fsize bsize   cpg]
  a:       2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:         65520       63      swap                        # (Cyl.    0*- 65)
  c:       2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  d:  	   6291936       1024128  4.2BSD   2048 16384  328 # Cyl  1016 -  7257
  e:        409248       7316064  4.2BSD   2048 16384  328 # Cyl  7258 -  7663
  f:       1024128       9822960  4.2BSD   2048 16384  328 # Cyl  9745 - 10760
  h:       2097648       7725312  4.2BSD   2048 16384  328 # Cyl  7664 -  9744
</pre></blockquote>

<p>
Zauwa¿, ¿e dysk ten ma w tej chwili przypisan± tylko czê¶æ przestrzeni dyskowej.

Disklabel zapewnia dwa ró¿ne tryby edycji etykiet dyskowych, wbudowan±
obs³ugê z wiersza poleceñ, oraz pe³ny edytor, podobny do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">vi(1)</a>.
Mo¿esz stwierdziæ, ¿e obs³uga z wiersza poleceñ jest "³atwiejsza", poniewa¿ 
prowadzi ciê poprzez wszystkie kroki i dostarcza pomoc na ¿±danie, ale
pe³noekranowy edytor posiada równie¿ jasn± u¿yteczno¶æ.

<p>
Dodajmy partycjê do powy¿szego systemu.

<p>
<blockquote>
<i>Ostrze¿enie: Za ka¿dym razem gdy bawisz siê bezmy¶lnie z etykietami dysków,
nara¿asz wszystkie swoje dane na dysku na ryzyko.
Upewnij siê ¿e posiadasz kopiê zapasow± swoich danych zanim rozpoczniesz edycjê
istniej±cych etykiet!</i>
</blockquote>

<p>
Bêdziemy korzystaæ w wbudowanego edytora, wywo³ywanego poprzez opcjê
"-E" polecenia disklabel(8).

<blockquote><pre>
# <b>disklabel -E wd0</b>
...
> a k
offset: [10847088]
size: [19033812] 2g
Rounding to nearest cylinder: 4194288
FS type: [4.2BSD]
> p m
device: /dev/rwd0c
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2 
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total bytes: 14594.2M
free bytes: 7245.9M
rpm: 3600


16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        300.2M          0.0M  4.2BSD   2048 16384  328 # Cyl     0*-   609
  b:        199.8M        300.2M    swap                   # Cyl   610 -  1015
  c:      14594.2M          0.0M  unused      0     0      # Cyl     0 - 29651*
  d:       3072.2M        500.1M  4.2BSD   2048 16384  328 # Cyl  1016 -  7257
  e:        199.8M       3572.3M  4.2BSD   2048 16384  328 # Cyl  7258 -  7663
  f:        500.1M       4796.4M  4.2BSD   2048 16384  328 # Cyl  9745 - 10760
  h:       1024.2M       3772.1M  4.2BSD   2048 16384  328 # Cyl  7664 -  9744
  k:       2048.0M       5296.4M  4.2BSD   2048 16384   16 # Cyl 10761 - 14921

> q
Write new label?: [y]
</pre></blockquote>


W tym przypadku, disklabel(8) by³ na tyle uprzejmy ¿e obliczy³ dobr± 
warto¶æ pocz±tkowego offsetu dla partycji.
W wielu przypadkach, bêdzie móg³ tak robiæ, lecz je¿eli posiadasz "dziury"
w etykietach dysków (np. usun±³e¶ partycjê, lub po prostu lubisz czyniæ swoje
¿ycie przykrym), bêdziesz musia³ usi±¶æ nad kartk± papieru z o³ówkiem o obliczyæ
w³a¶ciw± warto¶æ.
Zwróæmy uwagê, ¿e disklabel(8) wykonuje pewne sprawdzenia kondycji, jest bardzo mo¿liwe
¿e sprawy mog± pój¶æ bardzo ¼le w tym punkcie.
B±d¼ ostro¿ny oraz staraj siê zrozumieæ znaczenie liczb które wprowadzasz.

<p>
Na wiêkszo¶ci platform OpenBSD, dostêpne jest szesna¶cie partycji disklabel,
oznaczanych od "a" do "p"
(niektóre "specjalizowane" systemy mog± posiadaæ tylko osiem).
Ka¿de etykiety dysku powinny zawieraæ partycjê "c", z "fstype" 
"unused" obejmuj±c± ca³± fizyczn± wielko¶æ dysku.
Je¿eli twój disklabel do takich nie nale¿y, musisz to poprawiæ, opcja "D"
(poni¿ej) mo¿e byæ pomocna.
Staraj siê nigdy nie u¿ywaæ partycji "c" do czegokolwiek innego ni¿ dostêp 
do surowych sektorów dysku, nie próbuj tworzyæ systemu plików na "c".
Na urz±dzeniu startowym, partycja "a" jest zarezerwowana na g³ówny (root) system plików,
oraz "b" jako partycjê swap, ale tylko urz±dzenie bootuj±ce ma takie ograniczenia.
Inne dyski mog± korzystaæ z wszystkich piêtnastu partycji innych ni¿ "c" na systemy plików.   

<p>
<h3>Sztuczki i kruczki w disklabel</h3>
<ul>
<li><b>Uzyskiwanie pomocy:</b> W trybie wiersza poleceñ, naci¶niêcie "?" wy¶wietli
listê dostêpnych poleceñ.
"M" wy¶wietli stronê manuala dla disklabel(8).

<li><b>Reset do warto¶ci domy¶lnych:</b> W niektórych przypadkach, mo¿esz chcieæ 
kompletnie zresetowaæ wszystkie informacje w disklabel.
Polecenie "D" zresetuje wszystkie ustawienia do warto¶ci domy¶lnych, tak jakby
etykiety partycji nigdy nie istnia³y na dysku.

<li><b>Kopiowanie etykiet:</b> W niektórych przypadkach, mo¿esz chcieæ skopiowaæ
partycje z jednego dysku na inny, lecz nie dok³adnie (przyk³adowo: chcesz mieæ
takie same partycje, ale o innych rozmiarach).
Skorzystaj z trybu '-e' (pe³nowymiarowy edytor) by pobraæ partycje z dysku 
"wzorcowego", wkleiæ je na nowym dysku, usun±æ wzorcow± partycjê 'c', zachowaæ,
i uzyskaæ kopiê podzia³u dysku na innym napêdzie bez wprowadzania 
jego podstawowych parametrów.

<li>(sparc/sparc64) <b>Nie umieszczaj partycji swap na samym pocz±tku dysku.</b>

<li>(i386, amd64) <b>Pozostaw pierwsz± ¶cie¿kê pust±:</b>
Na niektórych platformach, powiniene¶ pozostawiæ pierwsz± ¶cie¿kê logiczn± 
niewykorzystan± zarówno w disklabel(8) jak i w fdisk(8).
Wskazówka ta jest czasem fa³szywa w przypadkach "pocz±tków partycji na sektorze
63", jest to jednak prawdziwe TYLKO je¶li taki jest rozmiar ¶cie¿ki w twoim 
sprzêcie.
Nie czyñ z tego za³o¿enia, nie jest to zawsze prawdziwe, disklabel
poinformuje ciê o swoich przypuszczeniach odno¶nie liczby sektorów
na ¶cie¿kê.
Wiele innych platform oczekuje ¿e partycje OpenBSD bêd± zaczynaæ siê na 
sektorze 0.

<li><b>Urz±dzenia bez etykiet:</b>
Je¿eli urz±dzenie nie posiada aktualnie etykiet dysków OpenBSD, lecz posiada
inny system plików (przyk³adowo: dysk z systemem plików FAT32), j±dro
systemu OpenBSD "utworzy" jedn± w pamiêci, i mo¿e byæ podstaw± do 
utworzenia etykiet na dysku.
Jednak¿e, je¿eli etykieta dysku zosta³a utworzona i zachowana na dysku, oraz 
dodano pó¼niej system plików ró¿ny ni¿ OpenBSD, etykieta nie zostanie
automatycznie zaktualizowana.
Musisz to zrobiæ rêcznie je¿eli chcesz by OpenBSD mia³ dostêp do tej partycji.
Wiêcej informacji znajdziesz <a href="faq14.html#foreignfsafter">poni¿ej</a>.

<li><b>"q" vs. "x":</b>
Ze wzglêdów historycznych, podczas pracy w trybie wewnêtrznego edytora, 
"q" zachowuje zmiany i wychodzi z programu, natomiast "x" wychodzi bez
zachowywania zmian.
Jest to odmienne zachowanie do tego co wielu ludzi wykorzystuje w innych
¶rodowiskach.
disklabel(8) ostrzega zanim zachowa zmiany, jednak wychodzi przy "x" szybko
i cicho.

</ul>


<a name="fdisk"></a>
<h2>14.2 - Program fdisk(8) w OpenBSD</h2>

Proszê przeczytaæ stronê podrêcznika systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.

<p>
fdisk(8) jest u¿ywany na niektórych platformach (i386, amd64, macppc, 
zaurus i cats) do tworzenia partycji rozpoznawalnych przez umieszczony w 
pamiêci ROM system bootuj±cy, w których umieszczane s± etykiety partycji
OpenBSD.
Inne platformy nie potrzebuj± lub nie korzystaj± z fdisk(8).
Mo¿na tak¿e wykorzystaæ fdisk(8) do manipulacji MBR (Master Boot Record),
co mo¿e mieæ wp³yw na ka¿dy system operacyjny w komputerze.
W przeciwieñstwie do innych narzêdzi fdisko-podobnych w niektórych systemach
operacyjnych, fdisk w OpenBSD zak³ada ¿e wiesz co zamierzasz zrobiæ i, 
przez wiêkszo¶æ czasu, pozwala ci robiæ to czego potrzebujesz, tym
samym staj±c siê potê¿nym narzêdziem w twoich rêkach.
Pozwoli ci tak¿e robiæ rzeczy których nie powiniene¶ robiæ lub których
nie zamierza³e¶ zrobiæ, zatem u¿ywaj go ostro¿nie.

<p>
Zazwyczaj tylko jedna partycja OpenBSD jest umieszczana na dysku twardym.
Partycja ta zostanie podzielona przez narzêdzie <a href="#disklabel">disklabel</a>
na w³a¶ciwe partycje systemu plików OpenBSD.
<p>

<p>
Tablicê partycji mo¿na wy¶wietliæ przy pomocy nastêpuj±cego polecenia:

<blockquote><pre>
# <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Wynik dzia³ania bêdzie podobny do tego przedstawionego poni¿ej:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre></blockquote>

<p>
W powy¿szym przyk³adzie pokazana jest tablica partycji pierwszego
dysku SCSI. Jak mo¿na zauwa¿yæ jest tam partycja OpenBSD (A6).
Gwiazdka (*) przy jej opisie oznacza, ¿e jest ona aktywna.

<p>
W poprzednim przyk³adnie wy¶wietlili¶my tylko informacje o partycjach.
A co je¶li chcemy zmieniæ tablicê partycji? S³u¿y do tego opcja <b>-e</b> -
uruchomi ona program fdisk w trybie interaktywnym.

<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MB
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre></blockquote>

<p>

<p>
Poni¿ej znajduje siê przegl±d poleceñ dostêpnych w momencie uruchomienia
z flag± <b>-e</b>:

<ul>
<li><b>help</b>   Wy¶wietla listê wszystkich komend trybu interaktywnego.
<li><b>reinit</b> Tworzy now± tablicê partycji, zawieraj±ca jedn± partycjê
                  OpenBSD oznaczon± jako aktywn±.
		  Jest to bardzo wygodny sposób by szybko utworzyæ 
		  jedn± partycjê OpenBSD na ca³ym dysku i generalnie 
		  przygotowaæ system dla OpenBSD (i nic poza OpenBSD).
<li><b>disk</b>   Wy¶wietla geometriê dysku rozpoznan± przez program fdisk.
                  Istnieje mo¿liwo¶æ zmiany parametrów, które wykry³ fdisk.
<li><b>setpid</b> Pozwala na zmianê typu partycji. To polecenie jest
                  u¿yteczne w przypadku przydzielenia istniej±cej partycji
                  dla OpenBSD.
<li><b>edit</b>   Edycja partycji (wszystkie zmiany przeprowadzane s± na
                  kopii tablicy partycji w pamiêci, a nie bezpo¶rednio na
                  dysku). Podczas zmiany jako jednostek mo¿na u¿yæ geometrii
                  BIOS-u lub przesuniêcia i rozmiaru podanego w sektorach.
<li><b>flag</b>   Ustawia partycjê jako aktywn±. Tylko jedna partycja mo¿e
                  mieæ ustawion± t± flagê.
<li><b>update</b> Aktualizacja "machine code" w kopii aktualnie wybranego
                  bootbloku.
<li><b>select</b> Wybór i za³adowanie do pamiêci tablicy partycji partycji
                  rozszerzonej.
<li><b>swap</b>   Zmienia dwa wpisy MBR, tak ¿e mo¿esz porz±dkowaæ MBR.
<li><b>print</b>  Wy¶wietla tablicê partycji. 
<li><b>write</b>  Zapisuje zmiany z kopii tablicy partycji w pamiêci komputera
                  na dysk. Zostaniesz poproszony o potwierdzenie tej operacji.
<li><b>exit</b>   Przej¶cie z edycji boot bloku wybranego poleceniem
                  "select" do edycji poprzedniej tablicy partycji,
                  je¶li taka nie istnieje, nast±pi wyj¶cie z programu.
<li><b>quit</b>   Polecenie analogiczne do polecenia "exit" z t±
                  ró¿nic±, ¿e wszystkie zmiany zapisane zostaj± na dysk.
<li><b>abort</b>  Wyj¶cie z programu bez zapisania tablicy partycji.
</ul>

<h3>Sztuczki i kruczki w fdisk</h3>
<ul>
<!-- <li>On OpenBSD platforms which use fdisk, you should leave the first
track free.
This leaves room for the Master Boot Record, which is where the fdisk
partition table resides. (not sure if this is true) -->
<li>fdisk(8) daje mo¿liwo¶æ edycji partycji zarówno w formacie surowych
sektorów jak równie¿ w formacie Cylinder/Head/Sector.
Obie opcje dostarczane s± z pewnego powodu -- niektóre zadania staj±
siê ³atwiejsze do wykonania w jeden sposób inne w drugi.
Nie ograniczaj siê do korzystania tylko z jednej z tych opcji.
<li>Zupe³nie czysty dysk wymaga zapisania na nim kodu MBR (Master Boot 
Record) zanim bêdzie mo¿na z niego bootowaæ system.
Mo¿esz u¿yæ do tego celu opcji "reinit" lub "update".
W przypadku gdy to siê nie powiedzie, mo¿esz zapisaæ w³a¶ciw± tablicê
partycji korzystaj±c z fdisk, ale nie bêdziesz móg³ z niego uruchamiaæ
systemu.
Mo¿esz chcieæ równie¿ zaktualizowaæ "boot code" je¿eli nie jeste¶ 
pewien jego pochodzenia.
<li>Je¶li twój system posiada partycje "maintenance" lub "diagnostic",
zalecane jest by pozostawiæ je tak jak s±, lub zainstalowaæ je ZANIM
zostanie zainstalowany OpenBSD.
<li>Z powodów historycznych, "q" zapisuje zmiany i wychodzi z programu
podczas gdy "x" wychodzi bez zapisywania. 
Jest to odmienne zachowania od tego jakie wiele osób stosowa³o
w innych ¶rodowiskach.
fdisk(8) nie ostrzega przed zapisaniem zmian, zatem nale¿y korzystaæ
z niego ostro¿nie.

</ul>


<a name="NewDisk"></a>
<h2>14.3 - Dodawanie nowych dysków w OpenBSD</h2>

<p>
Programy potrzebne do <b>PRAWID£OWEJ</b> instalacji dysku w OpenBSD to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>tylko i386</i>) i
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Na platformie i386 pracê rozpoczyna siê od narzêdzia fdisk(8). Posiadacze
innych architektur mog± zignorowaæ ten krok. Poni¿ej opisane bêdzie
dodanie trzeciego dysku SCSI do systemu.

<blockquote><pre>
# <b>fdisk -i sd2</b>
</pre></blockquote>

To polecenie spowoduje inicjalizacjê  tablicy partycji. Stworzona zostanie tylko
jedna partycja, obejmuj±ca ca³y dysk i przeznaczona dla OpenBSD.
W nastêpnym kroku nale¿y utworzyæ etykietê dysku. Ta czyno¶æ mo¿e
wydawaæ siê nieco zagmatwana.

<blockquote><pre>
# <b>disklabel -e sd2</b>

<i>(screen goes blank, your $EDITOR comes up)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></blockquote>

Po pierwsze, nie nale¿y zmieniaæ partycji 'c' - opisuje ona ca³y dysk i
jest niezbêdna do prawid³owej pracy disklabel.
£±czna liczba sektorów odpowiada liczbie sektorów na dysku. Dysk
ma 3 GB. Trzy gigabajty wed³ug producentów dysków to 3000 MB. Dziel±c
6185088 przez 3000 (mo¿na wspomóc siê programem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1)</a>)
otrzymasz 2061. Aby obliczyæ wielko¶æ w sektorach dla partycji a, d,
e, f, g, ... wystarczy pomno¿yæ ¿±dany rozmiar w megabajtach przez 2061.
Offset dla pierwszej partycji powinien byæ taki sam jak pokazana
wcze¶niej warto¶æ "sector/track". W tym przypadku bêdzie to
63. Przesuniêcie ka¿dej nastêpnej partycji winno byæ sum± przesuniêcia
i rozmiaru partycji j± poprzedzaj±cej (wyj±tkiem jest etykieta 'c', która
nie bierze udzia³u w takim wyrównywaniu).

<p>
W sytuacji gdy na dysku ma byæ tylko jedna partycja, np. zamierzasz u¿ywaæ jej
do przechowywania stron WWW lub katalogów domowych u¿ytkowników, wystarczy
od ca³kowitego rozmiaru dysku odj±æ ilo¶æ sektorów przypadaj±cych na jedn±
¶cie¿kê (w tym przypadku 63), tak wiêc 6185088 - 63 = 6185025. A ostateczny
wygl±d etykiety dysku bêdzie przedstawia³ siê nastêpuj±co:

<blockquote><pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre></blockquote>

<b>Je¶li to wszystko wydaje siê zbyt skomplikowane, mo¿na u¿yæ
opcji -E programu disklabel, a uruchomi siê on
w takim samym trybie jak podczas instalacji systemu!</b> W tym trybie
mo¿na u¿ywaæ oznaczeñ takich jak "96M" do okre¶lenia "96 megabajtów".
(Je¶li twój dysk jest wystarczaj±co du¿y mo¿na u¿yæ "96G" do okre¶lenia
96 gigabajtów!). Na nieszczê¶cie tryb -E u¿ywa geometrii BIOS-u,
a nie prawdziwej geometrii dysku, a w bardzo wielu przypadkach nie jest
to zupe³nie to samo. By omin±æ to ograniczenie i u¿ywaæ geometrii dysku 
wpisz 'g d'. (Innymi opcjami s± 'g b' - geometria zgodnie z BIOS-em oraz
'g u', czyli po prostu to, co "label" mia³ ustawione przed
dokonaniem jakichkolwiek zmian przez disklabel.)

<p>
Zosta³o zrobione ju¿ du¿o, ale to jeszcze nie koniec. Nale¿y jeszcze utworzyæ
system plików na partycjach u¿ywaj±c do tego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<blockquote><pre>
# <b>newfs sd2a </b>
</pre></blockquote>

<p>
Oczywi¶cie parametr dla tej komendy zale¿ny jest od tego jak dyski s±
nazywane i numerowane przez OpenBSD. (Spójrz na wynik dzia³ania polecenia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
aby dowiedzieæ siê jak nazywaj± siê dyski w twoim systemie.)

<p>
Teraz mo¿na ju¿ zamontowaæ nowoutworzon± partycjê. Punktem montowania bêdzie
katalog /u. Tak wiêc, najpierw nale¿y za³o¿yæ katalog /u,
a dopiero pó¼niej zamontwaæ partycjê.

<blockquote><pre>
# <b>mount /dev/sd2a /u</b>
</pre></blockquote>

<p>
Je¶li wszystko posz³o sprawnie mo¿na dopisaæ now± partycjê do 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>.

<blockquote><pre>
/dev/sd2a /u ffs rw 1 1
</pre></blockquote>

<p>
Je¶li chcesz przenie¶æ istniej±cy katalog, jak np. /usr/local na now± partycjê
wystarczy zamontowaæ nowy system plików w katalogu /mnt i u¿yæ polecenia
<tt>cpio -pdum</tt>. Zawarto¶æ /usr/local zostanie przeniesiona do /mnt.
W pliku
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
nale¿y zaznaczyæ, ¿e /usr/local jest teraz na partycji /dev/sd2a.

<blockquote><pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre></blockquote>

<p>
Uruchom komputer w trybie jednego u¿ytkownika (<b>boot -s</b>), przenie¶
istniej±cy katalog /usr/local do /usr/local-backup (lub po prostu go
skasuj, je¶li uwa¿asz siê za szczê¶ciarza) i stwórz pusty katalog
/usr/local. Uruchom komputer ponownie, i voila, pliki s± na swoim miejscu!

<a name="SwapFile"></a>
<h2>14.4 - Plik wymiany</h2>

<p>
(Uwaga: je¶li szukasz dodatkowej przestrzeni wymiany poniewa¿ otrzymujesz
komunikat &quot;brak pamiêci wirtualnej&quot; (ang. &quot;virtual memory
exhausted&quot;), powiniene¶ najpierw spróbowaæ ograniczyæ jej
zu¿ycie przez procesy przy pomocy poleceñ
csh
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>,
lub sh
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>.)

<p>
Korzystanie z pliku wymiany nie wymaga specjalnych opcji przy kompilacji
kernela. Istnieje jeszcze druga metoda, która wymaga zmian w j±drze.
Ten dokument opisze oba sposoby.

<h3>Plik wymiany</h3>

<p>
Wymiana do pliku jest najprostszym i najszybszym sposobem na zdobycie
dodatkowej pamiêci wirtualnej. Plik, który bêdzie wykorzystywany do tego
celu, nie mo¿e znajdowaæ siê na partycji wykorzystuj±cej SoftUpdates
(domy¶lnie jest to wy³±czone). Zanim zaczniesz przygotowywaæ plik wymiany
mo¿esz chcieæ zobaczyæ jak du¿o pamiêci wirtualnej posiadasz i jak
du¿o jest aktualnie wykorzystywane. S³u¿y do tego polecenie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">
swapctl(8)</a>.

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></blockquote>

<p>
Powy¿sza komenda wy¶wietla wszystkie urz±dzenia wykorzystywane jako pamiêæ
wirtualna oraz podstawowe statystki ich dotycz±ce. W tym przyk³adzie jest
tylko jedno urz±dzenie nazwane &qout;swap_device&quot; - to partycja
wymiany (na etykiecie dysku oznaczona liter± b). Jak mo¿na
zauwa¿yæ przestrzeñ wymiany nie jest wykorzystywana jednak, na potrzeby tego
dokumentu, utworzymy dodatkowe 32 MB pamiêci wirtualnej.

<p>
Pierwszym krokiem, niezbêdnym do wykorzystania pliku jako pamiêci wirtualnej
jest utworzenie tego pliku. Najlepszym narzêdziem do tego bêdzie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Oto przyk³ad stworzenia pliku <i>/var/swap</i> o rozmiarze 32 MB.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Kiedy plik bêdzie gotowy nale¿y oznaczyæ go jako dodatkow± przestrzeñ
wymiany. U¿yj poni¿szych poleceñ aby dodaæ do systemu plik jako urz±dzenie
pamiêci wirtualnej.

<blockquote><pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre></blockquote>

<p>
Teraz nale¿y siê upewniæ czy dodatkowa pamiêæ wirtualna jest dostêpna.

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>

<p>
Po prawid³owym utworzeniu i skonfigurowaniu pliku wymiany mo¿na umie¶ciæ 
odpowiedni wpis w <i>/etc/fstab</i> aby przy ka¿dym starcie systemu
automatycznie w³±czyæ wykorzystanie dodatkowej pamiêci wirtualnej.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></blockquote>

<h3>Plik wymiany poprzez urz±dzenie vnode</h3>

<p>
Opisana poni¿ej metoda jest trwa³ym sposobem na dodatkow± pamiêæ wirtualn±.
Po pierwsze nale¿y przygotowaæ j±dro z urz±dzeniem vnd0c jako plikiem
wymiany. Je¶li na wd0a znajduje siê g³ówny system plików, a wd0b jest
dotychczas wykorzystywan± partycj± wymiany, wystarczy zmieniæ jedn±
liniê w pliku konfiguracyjnym kernela, w sposób pokazany poni¿ej, a nastêpnie
skompilowaæ j±dro:

<blockquote><pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre></blockquote>

<p>
Po odpowiednim przygotowaniu j±dra, niezbêdne bêdzie utworzenie pliku wymiany.
Pos³u¿ymy siê w tym celu identycznym poleceniem jak w poprzednim przyk³adzie.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Nastêpnie nale¿y umie¶ciæ odpowiedni wpis w pliku <i>/etc/fstab</i>.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre></blockquote>

<p>
W tym momencie niezbêdne jest ponowne uruchomienie komputera, tak
aby wykorzystywa³ ju¿ nowe j±dro. Po tym przychodzi czas na konfiguracjê
urz±dzenia wymiany. Wykonuje siê to przy pomocy narzêdzia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>.

<blockquote><pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre></blockquote>

<p>
Ostatni krok polega na w³±czeniu dodatkowej pamiêci wirtualnej. Wykorzystamy
do tego, podobnie jak w poprzednim przyk³adzie, polecenie swapctl(8).
Po wszystkim, warto sprawdziæ czy wszystko
przebieg³o zgodnie z naszym ¿yczeniem.

<blockquote><pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>



<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>

<p>
Soft Updates, w swej pierwotnej wersji, powsta³o na podstawie pomys³u
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Grega Gangera i 
Yale'a Patt'a</a>, i napisane przez
<a href="http://www.mckusick.com/softdep/">Kirka McKusick'a</a>.

SoftUpdates narzuca konieczno¶æ uprzedniego zamówienia operacji w buforze
pamiêci podrêcznej co pozwala zrezygnowaæ z kodu FFS odpowiedzialnego za
synchroniczne zapisywanie wpisów katalogów. Dziêki temu daje siê zauwa¿yæ
bardzo du¿y przyrost wydajno¶ci dla operacji zapisu.

<p>
Soft Updates w³±czane jest podczas montowania systemów plików. Montuj±c
partycjê poleceniem  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a> 
nale¿y zaznaczyæ, ¿e chcemy korzystaæ z Soft Updates.
Poni¿ej znajduje siê przyk³adowy wpis w pliku
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
pokazuj±cy u¿ycie Soft Updates dla partycji <i>sd0a</i>.

<blockquote><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></blockquote>

<p>
Uwaga dla u¿ytkowników architektury sparc: Nie nale¿y w³±czaæ
Soft Updates na maszynach sun4 i sun4c. Pozwalaj± one na wykorzystanie
przez j±dro jedynie niewielkiej ilo¶ci pamiêci, przez co nie mog±
wykorzystywaæ Soft Updates. Problem ten nie dotyczy komputerów sun4m.
  
<a name="Boot386"></a>
<h2>14.6 - Jak wygl±da bootowanie OpenBSD?</h2>
Proces uruchamiania OpenBSD/i386 nie jest rzecz± banaln±, a zrozumienie jej
bêdzie pomocne przy rozwi±zywaniu ró¿norakich problemów. Bootowanie
OpenBSD sk³ada siê czterech g³ównych czê¶ci.
<ol>
<li><b><i>Master Boot Record (MBR):</i></b>
Master Boot Record jest to pierwszy fizyczny sektor (512 bajtów) dysku.
Zawarta jest w nim tablica partycji oraz niewielki program który ³aduje
PBR (ang. Partition Boot Record). Proszê zwróciæ uwagê, ¿e w niektórych
¶rodowiskach termin "MBR" u¿ywany jest do okre¶lenia jedynie czê¶ci, w której
zawarty jest kod ³aduj±cy, a nie ca³ego pierwszego bloku na dysku (w³±cznie
z tablic± partycji). Szczególnie istotne jest zrozumienia znaczenia
"inicjalizacji MBR" - co w terminologii OpenBSD oznacza nadpisanie od nowa
ca³ego sektora MBR, a nie tylko programu ³aduj±cego, jak to spotyka siê
w niektórych systemach operacyjnych. Nie jest to zbyt czêsto przeprowadzana
operacja. Zamiast tego czê¶ciej u¿ywa siê opcji "-u" programu fdisk(8)
("<tt>fdisk -u wd0</tt>").

<p>
Chocia¿ OpenBSD dostarcza w³asny MBR nie jest konieczne instalowanie go na
dysku - generalnie dowolny MBR jest w stanie za³adowaæ OpenBSD. Do
zarz±dzania MBR-em s³u¿y program fdisk(8), który u¿ywany jest zarówno do
edycji tablicy partycji, a tak¿e do instalacji kodu MBR na dysku.

<p>
MBR OpenBSD przy uruchomieniu wy¶wietla komunikat podobny do poni¿szego:

<blockquote><pre>
    Using drive 0, partition: 3.
</pre></blockquote>

Okre¶la on numer dysku oraz partycji z której zostanie za³adowany PBR.
Rzecz±, która rzuca siê w oczy jest kropka na koñcu powy¿szej linijki
(".") - oznacza ona, ¿e maszyna umo¿liwia bootowanie w trybie LBA. W
przypadku, gdy sprzêt nie pozwala na u¿ywanie translacji LBA, znak
kropki zostanie zast±piony ¶rednikiem (";"), który oznacza translacjê CHS:

<blockquote><pre>
    Using Drive 0, Partition 3;
</pre></blockquote>

Proszê zauwa¿yæ, ¿e ostatni znak w postaci kropki lub przecinka zosta³
wprowadzony w "nowym" MBR, dostêpnym od wersji OpenBSD 3.5.

<li><b><i>Partition Boot Record (PBR):</i></b>
Partition Boot Record w skrócie PBR, nazywany tak¿e 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(od kiedy plik o tej nazwie przechowuje program ³aduj±cy) jest to pierwszy
fizyczny sektor na partycji OpenBSD na dysku. PBR to "program ³aduj±cy
pierwszego poziomu". Sam PBR wczytywany jest do pamiêci przez kod znajduj±cy
siê w MBR, a jego zadaniem jest uruchomienie programu ³aduj±cego drugiego
poziomu -
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
Podobnie jak MBR, PBR jest bardzo ma³ym programem: kod i dane to nie wiêcej
jak 512 bajtów. Ta ilo¶æ nie wystarczy do stworzenia aplikacji obs³uguj±cej
system plików, tak wiêc PBR zamiast przeszukiwaæ dysk w poszukiwaniu <tt>/boot</tt>,
dostêpne z poziomu BIOS-u komputera po³o¿enie <tt>/boot</tt> jest fizycznie
zakodowane w PBR podczas instalacji.

<p>
Instalacja PBR odbywa siê przy pomocy programu
+<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>,
który szczegó³owo opisany jest <a href="faq14.html#InstBoot">w dalszej czê¶ci
tego dokumentu</a>.
Podczas uruchamiania PBR wy¶wietla komunikat podobny do poni¿szego:
<blockquote><pre>
    Loading...
</pre></blockquote>
wypisuj±c na ekranie kropkê wraz z ka¿dym odczytanym sektorem. Podobnie
jak w przypadku MBR, PBR zaznacza czy u¿ywa translacji LBA czy CHS. W
przypadku wykorzystania CHS, do powy¿szego komunikatu do³±czony jest
¶rednik:
<blockquote><pre>
    Loading;...
</pre></blockquote>
Poprzednie wersje (sprzed OpenBSD 3.5) wy¶wietlaj± komunikat "<tt>reading
boot...</tt>".

<li><b><i>Program £aduj±cy Drugiego Poziomu (ang. Second Stage Boot Loader)
 <tt>/boot</tt>:</i></b> <tt>/boot</tt> jest ³adowany przez PBR, a jego
zadaniem jest uzyskanie dostêpu do systemu plików OpenBSD, a nastêpnie
odszukanie i za³adowanie j±dra do pamiêci. Dziêki boot(8) mo¿liwe jest
tak¿e przekazanie ró¿nych opcji i informacji do kernela.

<p>
boot(8) jest programem interaktywnym. Po za³adowaniu przystêpuje on do
odczytania swojego pliku konfiguracyjnego <tt>/etc/boot.conf</tt> i wykonania
zawartych w nim poleceñ (domy¶lna instalacja OpenBSD nie tworzy jednak
takiego pliku). Je¶li brak pliku <tt>/etc/boot.conf</tt> lub zawarte
w nim polecenia nie za³aduj± j±dra OpenBSD, przed u¿ytkownikiem uka¿e siê
znak zachêty:

<blockquote><pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.10
     boot>
</pre></blockquote>

W tym momencie u¿ytkownik ma (w domy¶lnej instalacji) piêæ sekund aby wydaæ
polecenie inne polecenie, je¶li tego nie zrobi, boot(8) za³aduje j±dro
nazwane <tt>bsd</tt> znajduj±ce siê na g³ównej partycji pierwszego dysku
twardego. Program ³aduj±cy drugiego poziomu rozpoznaje sprzêt zainstalowany
w komputerze na podstawie danych odczytanych z BIOS-u (jako, ¿e j±dro
OpenBSD nie jest jeszcze za³adowane). Powy¿ej mo¿na zobaczyæ, ¿e boot(8)
odnalaz³:
<ul>
<li><b>pc0</b> - standartowa klawiatura oraz karta graficzna dla komputerów
i386.
<li><b>com0, com1</b> - dwa poty szeregowe.
<li><b>apm</b> - Funkcje zarz±dzania energi± (ang. Advanced Power Management).
<li><b>636k 190M</b> - Rozmiar dostêpnej konwencjonalnej (poni¿ej 1 MB)
oraz rozszerzonej (powy¿ej 1 MB) pamiêci.
<li><b>fd0 hd0+</b> - Napêdy dysków - w tym przypadku jedna stacja
dyskietek oraz dysk twardy.
</ul>

Znak '+' po "hd0" oznacza, ¿e BIOS przekaza³ do <tt>/boot</tt>, ¿e  
dostêp do dysku odbywa siê w trybie LBA.
Podczas pierwszej instalacji OpenBSD, mo¿na zauwa¿yæ znak '*' po symbolu
dysku twardego - oznacza to, ¿e na tym dysku nie znaleziono poprawnej
etykiety dysku.

<li><b><i>J±dro: <tt>/bsd</tt></i>:</b> celem bootowania jest za³adowanie
j±dra OpenBSD do pamiêci i poprawne uruchomienie go. W momencie gdy
j±dro znajdzie siê w pamiêci komputera OpenBSD zaczyna komunikowaæ siê
bezpo¶rednio ze sprzêtem bez pomocy BIOS-u.
</ol>

Poni¿szy przyk³ad przedstawia najczêstszy przebieg bootowania OpenBSD:

<blockquote><pre>
Using drive 0, partition: 3.                     <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.10
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2006 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 4.0 (GENERIC) #1107: Sat Sep 16 19:15:58 MDT 2006
   ...
</pre></blockquote>


<h3>Jakie przeszkody mo¿na napotkaæ podczas bootowania OpenBSD/i386?</h3>
<ul>
<li><b>B³êdny lub niekompatybilny MBR:</b>
W najczêstszych przypadkach dysk posiada ju¿ jaki¶ MBR, zdarzyæ siê mo¿e
jednak, ¿e dysk jest zupe³nie nowy lub zosta³ przeniesiony z innej platformy
sprzêtowej, a na pytanie "Czy u¿yæ ca³y dysk" (ang. "Use entire disk") podczas
<a href="faq4.html#Disks">instalacji systemu</a> udzieli³e¶ odpowiedzi
przecz±cej mo¿e okazaæ siê, ¿e na dysku nie istnieje MBR, a tym samym
za³adowanie systemu nie jest mo¿liwe (pomimo tego, ¿e dysk posiada
prawid³ow± tablicê partycji).

<p>
Mo¿na zainstalowaæ OpenBSD MBR na dysku przy pomocy programu fdisk(8).
Wystarczy uruchomiæ system z medium instalacyjnego, wybraæ opcjê
"Shell", a po ukazaniu siê znaku zachêty wpisaæ:

<blockquote><pre>
    # <b>fdisk -u wd0</b>
</pre></blockquote>

Mo¿na równie¿ okre¶liæ jaki MBR ma byæ zapisany na dysku:
<blockquote><pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre></blockquote>

Powy¿sze polecenie spowoduje zapisanie pliku <tt>/usr/mdec/mbr</tt> jako
MBR na dysku. Ten plik jest standartowym MBR OpenBSD i jest on tak¿e
wbudowany w polecenie fdisk, ale nic nie stoi na przeszkodzie by w tym
miejscu wskazaæ inny, prawid³owy kod MBR.

<li><b>B³êdna lokalizacja <tt>/boot</tt> w PBR:</b>
Podczas instalacji Partition Boot Record, program installboot(8) zapisuje
numer bloku i offset iwêz³a w którym znajduje siê plik <tt>/boot</tt>. Tak wiêc
usuniêcie b±d¼ zamiana pliku <tt>/boot</tt> bez ponownego uruchomienia
<a href="faq14.html#InstBoot">installboot(8)</a> spowoduje, ¿e zabootowanie
systemu stanie siê niemo¿liwe, jako ¿e PBR spróbuje za³adowaæ z dysku dane,
które z pewno¶ci± nie s± programem ³aduj±cym drugiego poziomu.

Z racji tego, ¿e <tt>/boot</tt> jest ³adowany przy u¿yciu wywo³añ
BIOS-u, starsze wersje PBR by³y bardzo wra¿liwe na zmiany geometrii
dysku (np. przeniesienie napêdu z jednego komputera, u¿ywaj±cego
translacji CHS do drugiego, który wykorzystuje translacjê LBA, lub
nawet zmiana sposobu t³umaczenia geometrii dysku w BIOS-ie) spowoduje, ¿e
<i>wg BIOS-u</i> znajdzie siê on w zupe³nie innym miejscu dysku,
tak wiêc konieczne bêdzie wykorzystanie programu installboot(8) przed 
ponownym uruchomieniem systemu. Nowy PBR (dostêpny w OpenBSD 3.5 i
pó¼niejszych) jest bardziej tolerancyjny na zmiany translacji.
</ul>

Jako ¿e PBR jest bardzo ma³y, tak i komunikaty o b³êdach s± bardzo
lakoniczne i trochê tajemnicze:
<ul>
<li><b>ERR</b> - BIOS zwróci³ b³±d podczas próby odczytu z dysku.
Najczê¶ciej oznacza to po prostu to, ¿e z dysku nie uda³o siê nic odczytaæ.
<li><b>ERR M</b> - nieprawid³owy magiczny numer (zobacz stronê podrêcznika
systemowego
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>) 
odczytany z nag³ówka programu ³aduj±cego drugiego poziomu.
Zasadniczo oznacza to, ¿e cokolwiek zosta³o odczytane z dysku na pewno
nie jest to <tt>/boot</tt>. Najczê¶ciej zwi±zane jest to ze niew³a¶ciwym
uruchomieniem programu installboot(8), plik /boot zosta³ zmieniony, lub
przekroczeniem dostêpnego dla BIOSu <a href="#LargeDrive">rozmiaru dysku</a>.

</ul>
Inne komunikaty b³êdów zosta³y opisane na stronie manuala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">biosboot(8)</a>.


Bardziej szczegó³owe informacje dotycz±ce procesu ³adowania OpenBSD/i386 mo¿na
znale¼æ w poni¿szych dokumentach:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
Dokument Hala Landisa pt. "How it Works".
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - O czym nale¿y wiedzieæ u¿ywaj±c du¿ych dysków w OpenBSD?</h2>

<p>
OpenBSD obs³uguje do 2<sup>31</sup>-1 (czyli 2,147,483,647) sektorów,
a poniewa¿ jeden sektor to 512 bajtów, otrzymamy odrobinê mniej ni¿ 1T.

<p>
Istnieje wprawdzie limit 1T na fizyczny rozmiar dysku, aczkolwiek w
*pewnych* warunkach nie powinno byæ problemów a¿ do 2T, <b>nie</b>
jest to jednak gwarantowane.

<p>
Oczywi¶cie mo¿liwo¶ci systemu plików i mo¿liwo¶ci sprzêtu to dwie ró¿ne
sprawy. Nowy, 250GB dysk IDE mo¿e mieæ problemy z prac± na starym 
(obs³uguj±cym napêdy &gt;137 GB) kontrolerze. Podobne problemy mog± 
dotyczyæ adapterów SCSI, czasem tak¿e niektóre starsze BIOS-y mog± 
odmówiæ wspó³pracy z nowymi du¿ymi dyskami.

<h3>Ograniczenia pojemno¶ci i rozmieszczenia partycji</h3>
Na nieszczê¶cie wszystkie mo¿liwo¶ci danego OS nie s± dostêpne zanim
zostanie on za³adowany do pamiêci. Podczas bootowania wykorzystywany
jest BIOS komputara i co za tym idzie ograniczenia BIOS-u.
 
<p>
Z tej w³a¶nie przyczyny, ca³y plik /bsd (czyli j±dro) musi znajdowaæ
siê wewn±trz obszaru, który jest dostêpny dla procedur bootuj±cych
z BIOS-u. Oznacza to, ¿e niektóre stare komputer i386, musz± posiadaæ
g³ówn± partycjê znajduj±c± siê w pierwszych 504 MB, ale nowsze
maszyny mog± mieæ limit 2G, 8G, 32G, 128G lub wiêcej. Warto zauwa¿yæ, ¿e
nowe komputery, które umo¿liwiaj± u¿ywanie dysków wiêkszych ni¿ 128G,
posiadaj± ograniczenie uniemo¿liwiaj±ce bootowanie powy¿ej tej granicy.
Je¶li u¿ywasz takiech systemów zmuszony bêdziesz umie¶ciæ g³ówn± partycjê
we wnêtrzu pierwszych 128G.

<p>
Zauwa¿, ¿e mo¿liwe jest zainstalowanie 40 GB dysku i za³adowanie OpenBSD
z jednej wielkiej partycji na starej maszynie i486. Mo¿esz pomy¶leæ, ¿e
uda³o siê pomy¶lnie z³amaæ opisane powy¿ej ograniczenia. Jednak do¶æ
szybko prawda mo¿e wyj¶æ na jaw i to w ca³kiem nieprzyjemny sposób:

<ul>
  <li>System zosta³ zainstalowany na 40 GB partycji /. Bêdzie
      dzia³a³ dlatego, ¿e bazowa instalacja OpenBSD wraz z wszystkimi
      plikami (w³±czaj±c w to /bsd) zmie¶ci siê w pierwszych
      504 MB.
  <li>Z czasem, w miarê jak system bêdzie siê rozrasta³, pliki zaczn±
      byæ zapisywane powy¿ej 504 MB.
  <li>Po aktualizacji, przychodzi moment na kompilacjê kernela.
      Stary plik /bsd nie jest ju¿ potrzebny, wiêc zostanie
      on nadpisany przez nowe j±dro.
  <li>Ponowne uruchomienie komputera ...
  <li>... i zamiast ulubionego systemu twoim oczom ukazuje siê
      komunikat "ERR M" lub podobny!
</ul>

<p>
Dlaczego? Nawet je¶li stary plik /bsd zosta³ zast±piony
nowym, jego nowa wersja nie znajduje siê dok³adnie w tym samym
miejscu co poprzednik. Najprawdopodobniej gdzie¶ powy¿ej granicy
504 MB obs³ugiwanej przez BIOS. Program ³aduj±cy nie jest w stanie
odczytaæ pliku j±dra i system zatrzymuje siê.

<p>
Proces bootowania OpenBSD wymaga, aby programy ³aduj±ce (biosboot(8) i
<tt>/boot</tt> w przypadku i386) oraz j±dro (<tt>/bsd</tt>) znajdowa³y
siê w obszarze, który jest obs³ugiwany przez BIOS. Mo¿na to
rozwi±zaæ w bardzo prosty sposób:

<p>
<b>Ca³a partycja '/' musi znajdowaæ siê wewn±trz obszaru, który jest
dostêpny dla BIOS-u (lub boot ROM-u) komputera.</b>

<p>
Niektóre platformy inne ni¿ i386 mog± zdawaæ siê byæ odporne na tego
typu problemy, jednak i one posiadaj± ograniczenia wynikaj±ce z
ograniczeñ boot ROM-ów. Jednak dok³adne okre¶lenie tych limitów mo¿e
byæ nieco k³opotliwe.

<p>
Opisane wy¿ej problemy s± jeszcze jednym dobrym powodem, aby
<a href="faq4.html#Partitioning">podzieliæ dysk na partycje</a>, zamiast
u¿ywaæ jednej du¿ej partycji.

<h3>Wymagania odno¶cie pamiêci i czasu dla fsck(8)</h3>
Problemem, który wymaga omówienia, a dotyczy du¿ych systemów plików,
jest ilo¶æ pamiêci i czasu niezbêdnego do sprawdzenia go programem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
po zawieszeniu siê systemu lub przerwy w dop³ywie pr±du. Nie mo¿na
zainstalowaæ OpenBSD na 120G systemie plików w maszynie wyposa¿onej
w 32M pamiêci RAM, a nastêpnie oczekiwaæ pomy¶lnego uruchomienia
fsck(8) po za³amaniu siê systemu. Dobr± zasad± jest za³o¿enie, ¿e
komputer powinien posiadaæ przynajmniej 1M pamiêci RAM na ka¿dy
1G przestrzeni dyskowej do poprawnego sprawdzenia systemu plików.
Mo¿na u¿yæ pamiêci swap, jednak zostanie to okupione znacznym spadkiem
wydajno¶ci i uci±¿liwo¶æ taka jest czêsto nieakceptowalna, oczywi¶cie
poza kilkoma wyj±tkami.
Wraz ze wzrostem rozmiaru partycji zwiêksza siê tak¿e czas niezbêdny
do uruchomienia fsck, jednak sprawdzenie fsck nale¿y wykonaæ tylko
dla przestrzeni dyskowej przydzielonej do zamontowanych partycji.
Pamiêtaj, ¿e w sytuacji gdy posiadasz kilka dysków w systemie, wszystkie
powinny byæ sprawdzone fsck(8) w tym samym czasie i mo¿e to wymagaæ
wiêcej pamiêci RAM ni¿ dla pojedynczego dysku.

<a name="InstBoot"></a>
<h2>14.8 - Instalacja bootbloku - tylko i386/amd64</h2>

<p>
Wspó³czesne wersje OpenBSD (3.5 i pó¼niejsze) maj± bardzo rozbudowanego
"programu ³aduj±cego" ("boot loader"), który jest znacznie bardziej 
niezale¿ny od geometrii dysków ni¿ poprzednie wersje, tym nie mniej s± 
one wra¿liwe na polo¿enie pliku
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">/boot</a></tt>
na dysku.
Je¶li zrobisz co¶ co spowoduje przeniesienie boot(8) na inne miejsce
na dysku (czyli do nowego inode-a), "zepsujesz" swój system uniemo¿liwiaj±c
jego poprawne uruchomienie.
W takich sytuacjach konieczne bêdzie uaktalnienie bootbloku aby umo¿liwiæ 
ponowny start systemu. Nale¿y pos³u¿yæ siê dyskietk± bootuj±c± (lub 
p³yt± CD) i przy znaku zachêty programu ³aduj±cego napisaæ: "b hd0a:/bsd", 
by wymusiæ start z pierwszego dysku twardego, a nie dyskietki. 
OpenBSD powinno uruchomiæ siê w normalny sposób. 
Teraz musisz przeinstalowaæ program ³aduj±cy pierwszego poziomu
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>) w oparciu o po³o¿enie pliku <tt>/boot</tt>, korzystaj±c
z programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>.

<p>
Poni¿szy przyk³ad zak³ada, ¿e dyskiem startowym bêdzie sd0 (je¶li
posiadasz interfejs IDE bêdzie to wd0, itd.):

<blockquote><pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre></blockquote>

<p>
Je¶li potrzebujesz nowszej wersji bootbloku, mo¿esz j± samodzielnie
skompilowaæ. To bardzo proste:

<blockquote><pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (lub jakiekolwiek inne urz±dzenie)
</pre></blockquote>

<a name="Backup"></a>
<h2>14.9 - Zapobieganie katastrofie: archiwizowanie i odtwarzanie z ta¶my</h2>

<h3>Wstêp:</h3>

<p>
Je¶li uruchomi³e¶ w³a¶nie maszynê wykorzystywan± jako serwer produkcyjny
zalecane jest posiadanie kopii bezpieczeñstwa na wypadek, gdyby który¶
z dysków zawiód³.

<p>
Poni¿sze informacje pomog± zaznajomiæ Czytelnika z programami 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>,
znajduj±cymi siê w standartowej instalacji OpenBSD. Bardziej zaawansowane
narzêdzie do robienia kopii zapasowych, 
"<a href="http://www.amanda.org">Amanda</a>" dostêpne
w <a href="faq15.html#PkgMgmt">kolekcji pakietów</a>, pozwala tak¿e
archiwizowaæ dane z wielu serwerów na jednej ta¶mie. W wiêkszo¶ci
przypadków, narzêdzia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
wystarcz±. Jednak, jak ju¿ zosta³o wcze¶niej napisane, je¶li chcesz
zarchiwizowaæ dane z kilku, Amanda mo¿e byæ godna uwagi.

<p>
Urz±dzenia opisane w tym dokumencie, zarówno dyski jak i streamery, to
urz±dzenia wykorzystuj±ce interfejs SCSI. W ¶rodowisku produkcyjnym,
zaleca siê raczej u¿ycie dysków SCSI ni¿ IDE. Wynika to ze sposobu w
jaki oba interfejsy radz± sobie z uszkodzonymi sektorami. Nie znaczy to
jednak, ¿e informacje tutaj zawarte s± bezu¿yteczne je¶li wykorzystujesz
dyski IDE lub ta¶my innego rodzaju, po prostu urz±dzenia bêd± nosi³y
troszkê inne nazwy. Na przyk³ad odpowiednikiem sd0a w przypadku IDE
bêdzie wd0a.

<h3>Archiwizowanie danych na ta¶mê</h3>

<p>
Aby zarchiwizowaæ dane na ta¶mê, nale¿y najpierw sprawdziæ, gdzie s± 
podmontowane systemy plików. Mo¿na siê tego dowiedzieæ u¿ywaj±c
z poziomu konsoli polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
Wynik powinien wygl±daæ mniej wiêcej tak:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
W naszym przypadku, partycja root (/), istnieje fizycznie na sd0a,
co oznacza dysk twardy SCSI nr 0, partycjê a. System plików /usr
jest na sd0h, czyli na dysku twardym SCSI nr 0, na partycji h.

<p>
Inny, bardziej zaawansowany przyk³ad:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
W tym przyk³adzie, system plików root (/), rezyduje na sd0a,
/var na sd0d, /home na sd0e za¶ /usr na sd0h.

<p>
Aby zarchiwizowaæ swoje dane, nale¿y podaæ programowi dump nazwê ka¿dej
partycji twardego dysku. Oto, jak nale¿a³oby zarchiwizowaæ maszynê z 
naszego pierwszego, prostszego przyk³adu:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Z kolei w przypadku drugiego, bardziej zaawansowanego przyk³adu,
nale¿a³o by u¿yæ poleceñ:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Proszê zajrzeæ do strony podrêcznika systemowego polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>,
aby dowiedzieæ siê, jakie znaczenie maj± poszczególne flagi tego programu.
My przedstawimy jedynie krótki opis opcji u¿ytych w naszym przypadku:

<ul>
<li><b>0</b> - Dokonaj archiwizacji na poziomie 0, czyli skopiuj
               wszystkie pliki.
<li><b>a</b> - Próbuj automatycznie wykryæ pojemno¶æ ta¶my.
<li><b>u</b> - Zaktualizuj plik /etc/dumpdates, aby zaznaczyæ datê archiwizacji.
<li><b>f</b> - Okre¶la, wykorzystywane urz±dzenie ta¶mowe 
               (w naszym przypadku /dev/nrst0).
</ul>

<p>
I, ostatecznie, któr± partycjê zarchiwizowaæ (/dev/rsd0a, itd.).

<p>
Polecenie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
s³u¿y do przewijania ta¶my. Proszê przeczytaæ stronê podrêcznika systemowego
polecenia mt, by zapoznaæ siê jego opcjami (takimi jak eject).

<p>
Je¶li istnieje niepewno¶æ co do nazwy urz±dzenia ta¶mowego, proszê pos³u¿yæ
siê poleceniem dmesg. Przyk³adowy opis urz±dzenia ta¶mowego w dmesg mo¿e
wygl±daæ tak:

<blockquote><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></blockquote>

<p>
Uwa¿ny Czytelnik zapewne dostrzeg³, ¿e przy archiwizowaniu urz±dzenie 
ta¶mowe nazywa siê <tt>nrst0</tt>, a nie <tt>st0</tt>, jak podaje
dmesg. Odwo³uj±c siê do <tt>st0</tt> jako do <tt>nrst0</tt> zaznaczamy,
¿e nie chcemy przewijaæ ta¶my po dokonaniu archiwizacji, a ¿±damy
dostêpu do urz±dzenia w trybie surowym. Aby zarchiwizowaæ kilka systemów 
plików na jednej ta¶mie, upewnij siê, ¿e korzystasz z urz±dzenia non-rewind,
poniewa¿ je¿eli u¿yjesz urz±dzenia przewijaj±cego (<tt>rst0/</tt>) do archiwizacji
wielu systemów plików, drugi archiwizowany system plików nadpisze pierwszy, trzeci
drugi itd. Dok³adniejszy opis ró¿nych urz±dzeñ ta¶mowych znale¼æ
mo¿na w podrêczniku systemowym polecenia dump.

<p>
Napiszemy teraz ma³y skrypt archiwizuj±cy (nazwiemy go "backup")

<blockquote><pre>
echo "  Rozpoczynam pelna archiwizacje..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Przewijanie tasmy, prosze czekac..."
mt -f /dev/rst0 rewind
echo "Gotowe."
echo
</pre></blockquote>

<p>
Je¶li chcemy tworzyæ kopie zapasowe np. codziennie w nocy, to
mo¿na u¿yæ programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
który bêdzie uruchamia³ nasz skrypt "backup" automatycznie.


<p>
Bardzo pomocne jest zapisanie sobie (np. na skrawku papieru) jak du¿o
miejsca na dysku zajmuje ka¿da partycja. Mo¿na do tego celu u¿yæ komendy
<tt>df -h</tt>. Bêdzie to przydatne, je¶li napêd zawiedzie i trzeba bêdzie
odtworzyæ tablicê partycji na nowym dysku.

<p>
Przywracanie danych spowoduje równie¿ zmniejszenie siê fragmentacji.
Aby na pewno zarchiwizowaæ wszystkie pliki, najlepiej jest zrestartowaæ
komputer i uruchomiæ system w trybie pojedyñczego u¿ytkownika. Nie 
trzeba podmontowywaæ systemów plików, aby je zarchiwizowaæ. Po 
zalogowaniu siê w trybie pojedynczego u¿ytkownika trzeba jednak 
podmontowaæ partycjê root (/) w trybie r/w. W przeciwnym przypadku
program dump zg³osi b³±d przy zapisywaniu danych o zrzutach. Aby 
zalogowaæ siê w trybie pojedynczego u¿ytkownika, nale¿y wpisaæ
"<tt>bsd -s</tt>" po znaku zachêty "boot&gt;", pojawiaj±cym siê
w trakcie uruchamiania systemu.

<h3>Wy¶wietlanie zawarto¶ci ta¶my</h3>

<p>
Po dokonaniu pierwszej archiwizacji, dobrze jest upewniæ siê, ¿e na
ta¶mie jest rzeczywi¶cie to, czego oczekiwali¶my.

<p>
Mo¿na wydaæ nastêpuj±c± komendê by wy¶wietliæ zawarto¶æ ta¶my, na któr±
dokonali¶my zrzutu:

<blockquote><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></blockquote>

<p>
Wypisze to listê plików istniej±cych na pierwszej partycji ta¶my. Zazwyczaj
jest to system plików root (/).

<p>
Aby sprawdziæ, co zawiera druga partycja i zapisaæ wynik do pliku,
wystarczy u¿yæ nastêpuj±cego polecenia:

<blockquote><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></blockquote>

<p>
W przypadku naszego prostszego przyk³adu, numer 2 oznacza³by /usr, za¶
w przypadku trudniejszego - /var. Jak widaæ, partycje s± zapisywane
na ta¶mê w takiej kolejno¶ci, w jakiej s± na dysku.


<h3>Przywracanie danych z ta¶my</h3>

<p>
Przyk³adowy scenariusz przedstawiony poni¿ej jest przydatny w przypadku,
gdy dysk twardy kompletnie zawiedzie. Je¿eli naszym celem jest 
odtworzenie pojedynczego pliku, to nale¿y zaznajomiæ siê ze stron±
podrêcznika systemowego programu restore, zwracaj±c podczas lektury 
szczególn± uwagê na instrukcje trybu interaktywnego.

<p>
Wymiana dysku i przywracanie danych z ta¶my jest zwykle procesem szybkim
i ³atwym. Standardowa dyskietka instalacyjna (bootuj±ca) OpenBSD zawiera
zarówno wymagane narzêdzie "restore", jak i binaria wymagane do 
partycjonowania i ustawienia nowego dysku jako bootowalny. W wiêkszo¶ci
przypadków, dyskietka ta i ta¶ma ze zrzutem zawarto¶ci dysku s± wszystkim,
co potrzeba mieæ, aby odtworzyæ system.


<p>
Po fizycznej wymianie zepsutego dysku na nowy, nale¿y postêpowaæ w
nastêpuj±cy sposób:

<ul>
<li>
<p>
Bootujemy komputer z dyskietki instalacyjnej OpenBSD. W menu 
wybieramy "Shell". Nastêpnie zabezpieczamy przed zapisem i wk³adamy 
nasz± najbardziej aktualn± ta¶mê z kopi± zapasow± systemu.

<br>
<li>
<p>
U¿ywaj±c programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>,
tworzy siê podstawow± partycjê OpenBSD na nowym dysku. Przyk³ad:

<blockquote><pre>
# <b>fdisk -e sd0</b>
</pre></blockquote>

<p>
Wiêcej informacji na temat fdisk znajduje siê w
<a href="#fdisk">rozdziale o programie fdisk</a>.

<li>
<p>
U¿ywaj±c polecenia disklabel, odtwarzamy nasze tablicê partycji OpenBSD
wewn±trz naszej podstawowej partycji, któr± przed chwil± stworzyli¶my
za pomoc± fdiska. Przyk³ad:

<blockquote><pre>
# <b>disklabel -E sd0</b>
</pre></blockquote>

<p>
(Proszê nie zapomnieæ o partycji swap, wiêcej informacji znajduje siê w 
<a href="#disklabel">rozdziale o disklabel FAQ</a>).

<li>
<p>
U¿ywaj±c polecenia newfs, budujemy czysty system plików na ka¿dej partycji
stworzonej w poprzednim kroku. Przyk³ad:

<blockquote><pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre></blockquote>

<li>
<p>
Montujemy nowoprzygotowany system plików root (/) na /mnt. Przyk³ad:

<blockquote><pre>
# <b>mount /dev/sd0a /mnt</b>
</pre></blockquote>

<li>
<p>
Wchodzimy do partycji root i zaczynamy proces przywracania danych.
Przyk³ad:

<blockquote><pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre></blockquote>

<li>
<p>
Trzeba jeszcze ustawiæ dysk jako bootowalny. Trzeba wiêc zapisaæ
na dysku nowy MBR. S³u¿y do tego polecenie:

<blockquote><pre>
# <b>fdisk -i sd0</b>
</pre></blockquote>


<li>
<p>
Oprócz zapisania nowego MBR, aby móc z niego bootowaæ, nale¿y jeszcze 
zainstalowaæ bootblock. Oto krótki przyk³ad:

<blockquote><pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></blockquote>

<li>
<p>
W tym momencie nowy system plików root na dysku twardym powinien byæ
ju¿ przygotowany, mo¿na wiêc z niego uruchomiæ system i 
kontynuowaæ przywracanie reszty systemów plików. Poniewa¿ system 
operacyjny nie jest w tym momencie jeszcze do koñca odtworzony, nale¿y
ponownie uruchomiæ go w trybie pojedynczego u¿ytkownika. Oto przyk³ad
jak z poziomu pow³oki odmontowaæ system plików, a nastêpnie wy³±czyæ 
komputer.

<blockquote><pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre></blockquote>

<li>
<p>
Usuñ dyskietkê instalacyjn± z napêdu i ponownie uruchom komputer. Po
pojawieniu siê znaku zachêty programu ³aduj±cego OpenBSD, wpisz poni¿sz±
komendê:

<blockquote><pre>
boot&gt; <b>bsd -s</b>
</pre></blockquote>

<p>
bsd -s spowoduje, ¿e kernel uruchomi siê w trybie jednego
u¿ytkownika (do pracy w tym trybie wymagana jest tylko partycja root (/)).

<li>
<p>
Zak³adaj±c, ¿e wszystkie opisane do tej pory czynno¶ci zosta³y poprawnie
wykonane i nie wyst±pi³y ¿adne b³êdy, po uruchomieniu systemu pojawi siê
pytanie o ¶cie¿kê do pow³oki. Naci¶niêcie return uruchomi pow³okê sh.
Nastêpnie mo¿esz chcieæ zamontowaæ g³ówny system plików w trybie
do odczytu/zapisu (w tym momencie mo¿liwy jest tylko odczyt).

<blockquote><pre>
# <b>mount -u -w /</b>
</pre></blockquote>

<li>
<p>
Je¶li jest ju¿ mo¿liwy zapis na partycji root (/), mo¿na przyst±piæ do
dalszej czê¶ci odtwarzania systemu z kopii zapasowej.

<blockquote><pre>
<i>(prostszy przyk³ad )</i>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

<i>(bardziej zaawansowany przyk³ad)</i>
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></blockquote>

<p>
U¿ycie opcji <b>rvsf</b> zamiast rsf polecenia restore
spowoduje, ¿e na ekranie bêd± wy¶wietlane nazwy aktualnie rozpakowywanych
plików.

<li>
<p>
Po przywróceniu wszystkich systemów plików na dysku, nale¿y ponownie uruchomiæ
komputer, tym razem ju¿ w trybie wielou¿ytkownikowym. Je¶li wszystko
posz³o zgodnie z planem dostêpny bêdzie system dok³adnie w takim stanie
w jakim znajdowa³ siê chwili wykonywania kopii.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Montowanie obrazów dysków w OpenBSD</h2>


<p>
Aby zamontowaæ obraz dysku (np. obraz ISO, obraz dysku stworzony za pomoc±
dd itp.), nale¿y najpierw skonfigurowaæ urz±dzenie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>.
Na przyk³ad, je¿eli obraz ISO jest umieszczony w pliku <i>/tmp/ISO.image</i>,
to aby go zamontowaæ nale¿y wydaæ nastêpuj±ce polecenia:

<blockquote><pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre></blockquote>

<p>
Proszê zauwa¿yæ, ¿e poniewa¿ obraz ten jest obrazem ISO-9660, wykorzystywanym
w p³ytach CD i DVD, musisz okre¶liæ typ na <i>cd9660</i> gdy go podmontowujesz. 
To prawda, nie ma znaczenia jaki typ, musisz podaæ <i>ext2fs</i> gdy
montujesz linuksowy obraz dysku.

<p>
Do odmontowywania obrazów s³u¿± nastêpuj±ce dwa polecenia:

<blockquote><pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre></blockquote>

<p>
Wiêcej informacji znajduje siê w
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">
podrêczniku systemowym programu vnconfig(8)</a>.

<a name="pciideErr"></a>
<h2>14.11 - Pomocy! Otrzymuje komunikaty b³êdów podczas pracy z urz±dzeniami IDE DMA!</h2>

<p>
Transfery IDE DMA, obs³ugiwane przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">
pciide(4)</a>, s± niestabilne w wielu konfiguracjach sprzêtowych. Do
niedawna, wiêkszo¶æ "mainstreamowych" systemów operacyjnych, które 
chwali³y siê obs³ug± transferów DMA na dyskach IDE, nie mia³y domy¶lnie
w³±czonej tej opcji z powodu problemów ze sprzêtem. Teraz jednak
wiele z tych maszyn mo¿e byæ u¿ywanych z OpenBSD.

<p>
OpenBSD jest agresywny i zawsze próbuje u¿ywaæ najwy¿szych trybów DMA jakie
s± dostêpne. W przypadku niektórych konfiguracji sprzêtowych jest to jednak
przyczyn± niszczenia danych w trakcie ich transferu. Jest to spowodowane
b³êdami w chipsetach p³yt g³ównych, b³êdami w dyskach, a tak¿e
zak³óceniem na ³±czach. Na szczê¶cie, tryb Ultra-DMA za pomoc± CRC wykrywa
uszkodzenia danych powsta³e podczas ich transferu. Kiedy Ultra-DMA CRC 
zawiedzie, pojawia siê komunikat o b³êdzie i ca³a operacja jest powtarzana. 
Oto przyk³ad takiego komunikatu:

<blockquote><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></blockquote>

<p>
Je¶li operacja transferu nie powiedzie siê kilka razy z rzêdu, OpenBSD
prze³±czy tryb Ultra-DMA na wolniejszy (a co za tym idzie, bardziej
niezawodny). Je¶li tryb Ultra-DMA osi±gnie w koñcu warto¶æ 0, to napêd 
przechodzi w tryb PIO.

<p>
B³êdy w obs³udze UDMA bardzo czêsto powodowane s± przez uszkodzone
lub kiepskiej jako¶ci kable. I w³a¶nie one powinny byæ brane pod
uwagê jako g³ówni podejrzani w sprawie b³êdów DMA lub te¿ niskiej
wydajno¶ci przy transferach. Nie jest tak¿e dobrym pomys³em umieszczanie
na tym samym kanale dysku twardego i CD-ROM-u.

<p>
Je¶li wymiana kabli nie rozwi±¿e problemu, a OpenBSD nie bêdzie móg³
zmniejszyæ szybko¶ci transmisji lub proces ten spowoduje zawieszenie
komputera lub wy¶wietlenie ogromnej ilo¶ci komunikatów systemowych,
mo¿na spróbowaæ wymusiæ na systemie domy¶lne u¿ywanie ni¿szego poziomu
DMA lub UDMA. Mo¿na to osi±gn±æ przy pomocy <a href="faq5.html#BootConfig">UKC</a>
lub <a href="faq5.html#config">config(8)</a> zmieniaj±c domy¶lne flagi urz±dzenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>.
 

<a name="RAID"></a>
<h2>14.13 - Macierze RAID dla OpenBSD</h2>

Dziêki macierzom RAID (Redundant Array of Inexpensive Disks) mo¿na
u¿ywaæ wielu dysków w celu zwiêkszenia wydajno¶ci, pojemno¶ci i/lub 
redundancji. Pe³ne przedyskutowanie zalet i niebezpieczeñstw zwi±zanych 
z macierzami RAID nie jest zadaniem tego rozdzia³u. Nale¿y jednak 
podkre¶liæ dwa wa¿ne fakty:

<ul>
<li>Macierze RAID nie maj± nic wspólnego z kopiami zapasowymi.
<li>Same w sobie, macierze RAID nie wyeliminuj± czasu przestoju serwera.
</ul>

Je¶li te dwie rzeczy s± dla Czytelnika nowo¶ci±, to artyku³ ten nie jest 
dla niego dobrym miejscem na rozpoczêcie przygody z macierzami RAID.


<h3>Opcje programowe</h3>
OpenBSD zawiera narzêdzie RAIDframe, który programowo symuluje RAID. 
Dokumentacja tego programu znajduje siê w nastêpuj±cych miejscach:

<ul>
<li><a href="#Optraid">Optymalizacja dysków, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">Strona domowa RAIDframe</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">strona podrêcznika systemowego raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">strona podrêcznika systemowego raid(4)</a>
</ul>


<p>
Partycja root mo¿e byæ mirrorowana bezpo¶rednio przez system. Wystarczy
u¿yæ opcji "Autoconfiguration" programu RAIDframe.

<p>
OpenBSD 3.7-stable, i pó¼niejsze zawieraj± obs³ugê mirroringu jako opcjê
dla sterownika
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>.
Ten system wbudowano w j±dro GENERIC oraz w j±dro bsd.rd dla niektórych platform
(amd64, hppa, hppa64, i386), zatem mo¿e byæ znacznie
prostszy w u¿yciu, aczkolwiek posiada pewne ograniczenia odno¶nie przebudowywania
macierzy.

Zobacz:
<ul>
<li>stronê manuala <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
<li>stronê manuala <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>
</ul>

<h3>Opcje sprzêtowe</h3>
<p>
Wiele wspieranych przez OpenBSD <a href="../../pl/plat.html">platform</a>
obs³uguje wszelakie (sprzêtowe) macierze RAID. Jakie dok³adnie, mo¿na
sprawdziæ na stronie danej platformy (mo¿na siê tam
dostaæ <a href="../../pl/plat.html">st±d</a>).

<p>
Inn± mo¿liwo¶ci±, dostêpn± dla wielu platform, jest zakup jednego z 
wielu istniej±cych na rynku urz±dzeñ, które powoduj±, ¿e kilka dysków 
IDE czy SCSI dzia³a jako jeden du¿y dysk. Takie urz±dzenia dzia³aj± 
praktycznie na ka¿dej platformie, warunkiem koniecznym jest obs³uga
interfejsu SCSI lub IDE przez ni±.

<p>
Oto niektórzy producenci takiego sprzêtu:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Uwaga: to jest tylko lista firm, których produkty, z pozytywnym skutkiem,
zosta³y przetestowane przez u¿ytkowników OpenBSD. Nie zmuszamy nikogo
do korzystania z tylko z tych urz±dzeñ!)

<h3>Opcje "nie"</h3>
<p>
Na <a href="../../pl/mail.html">listach mailingowych</a> czêsto pojawia siê
pytanie o obs³ugê przez OpenBSD tanich kontrolerów IDE RAID lub SATA RAID 
(opartych na chipsetach firm Promise, HighPoint lub Adaptec HostRAID).
Odpowiedz brzmi: nie.  Te karty i chipsety nie s± prawdziwymi sprzêtowymi
kontrolerami RAID. Jest to programowo realizowany RAID dziêki odpowiednim
procedurom zapisanym w BIOS-ie urz±dzenia. Jako ¿e OpenBSD obs³uguje RAID w
sposób niezale¿ny od sprzêtu, nie widzimy potrzeby implementacji obs³ugi
dla tych kart.

<p>
Prawie wszystkie kontrolery SATA lub IDE "RAID" wbudowane w p³yty g³ówne
s± tylko rozwi±zaniami softwarowymi i powinny pracowaæ poprawnie jako SATA
lub IDE wykorzystuj±c standardowy sterownik IDE 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">
pciide(4)</a>), nie bêd± jednak pracowa³y jako sprzêtowy RAID w OpenBSD.


<a name="NegSpace"></a>
<h2>14.14 - Dlaczego <tt>df</tt> pokazuje, ¿e u¿ywam wiêcej ni¿ 100% dysku?</h2>
Ludzie s± zazwyczaj zaskoczeni odkrywaj±c, ¿e maj± <i>ujemn±</i> ilo¶æ 
wolnego miejsca, lub wiêcej ni¿ 100% zu¿ycia systemu plików, pokazywane przez 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>.

<p>
W trakcie tworzenia systemu plików przy pomocy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>,
czê¶æ dostêpnej przestrzeni jest zachowywana jako rezerwa.
Zapewnia to margines b³êdu w gdy przepe³nisz dysk, oraz 
pozwala utrzymaæ minimaln± fragmentacjê.
Domy¶lnie jest to 5% pojemno¶ci dysku, zatem je¶li u¿ytkownik root
nêdznie wype³ni dysk, mo¿esz zobaczyæ 105% dostêpnej pojemno¶ci.

<p>
Je¿eli warto¶æ 5% nie jest w³a¶ciwa dla ciebie, mo¿esz j± zmieniæ przy pomocy
polecenia <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>.

<a name="OhBugger"></a>
<h2>14.15 - Przywracanie partycji po skasowaniu etykiety dysku.</h2>

<p>
Je¿eli posiadasz uszkodzon± tablicê partycji, jest kilka ró¿nych
rzeczy którymi mo¿esz usi³owaæ j± odzyskaæ.

<p>
Na pocz±tek - panikuj.
Zwykle i tak siê to robi, wiêc mo¿e byæ dobrze mieæ to ju¿ za sob±.
Po prostu nie rób g³upich rzeczy.
Pozostaw panikê poza swoim komputerem.
Nastêpnie zrelaksuj siê i zobacz czy kroki opisane poni¿ej nie red± pomocne.

<p>
Kopie etykiet ka¿dego dysku s± przechowywane w
w <tt>/var/backups</tt> jako efekt pracy dziennych narzêdzi zarz±dzaj±cych.
Za³ó¿my, ¿e wci±¿ posiadasz partycjê var, mo¿esz po prostu przeczytaæ 
wyj¶cie i umie¶ciæ je w etykiecie dysku.

<p>
W przypadku w którym nie mo¿esz zobaczyæ tej partycji, s± dwie 
opcje.
Naprawiæ dysk wystarczaj±co, tak byæ móg³ j± zobaczyæ, lub naprawiæ dysk
tak by¶ móg³ zabraæ z niego zwoje dane.

W zale¿no¶ci od tego co siê wydarzy³o, pierwsza lub druga opcja mo¿e byæ 
lepsza (z umieraj±cym dyskiem najpierw chcesz dane, z niestarannymi rêkami
mo¿esz po prostu mieæ etykietê).

<p>
Pierwszym narzêdziem którego potrzebujesz jest 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(zwróæ uwagê na podkre¶lenie: to nie jest "scanffs").
scan_ffs(8) przejrzy ca³y dysk i spróbuje znale¼æ partycje a tak¿e poda 
informacje jakie na ich temat znajdzie.
Mo¿esz u¿yæ tych informacji do ponownego stworzenia etykiet dysku.
Je¿eli po prostu chcesz odzyskaæ <tt>/var</tt>, mo¿esz odtworzyæ
partycjê <tt>/var</tt>, a pó¼niej odzyskaæ zarchiwizowan± etykietê i dodaæ 
resztê.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
zaktualizuje zarówno informacje j±dra o etykietach dysków, jak równie¿ spróbuje
zapisaæ etykietê na dysk.
Zatem, nawet je¿eli obszar dysku zawieraj±cy etykietê jest nieczytelny, 
bêdziesz móg³ u¿yæ polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
i czytaæ dane a¿ do nastêpnego restartu.


<a name="foreignfs"></a>
<h2>14.16 - Czy mogê dostaæ siê do danych na systemach plików
innych ni¿ FFS?</h2>
<!-- Artyku³ ten zosta³ napisany przez Stevena Mestdagh 
steven@openbsd.org, i udostêpniony na licencji BSD -->

Tak. Pozosta³e wspierane systemy plików zawieraj±: ext2 (Linux), ISO9660 i UDF
(CD-ROM,DVD), FAT (MS-DOS oraz Windows), NFS, NTFS (Windows), AmigaDOS.
Niektóre z nich maj± ograniczone wsparcie, np. tylko-odczyt.
Zwróæ uwagê ¿e UFS2 z FreeBSD nie jest wspierany.

<p>
Podamy tutaj ogólne wprowadzenie jak korzystaæ z tych systemów plików w 
OpenBSD. Aby korzystaæ z systemu plików musi on zostaæ podmontowany.
Po szczegó³owe opcje montowania, zobacz stronê manuala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>,
oraz te dotycz±ce montowania systemów plików które zamierzasz montowaæ,
tj. mount_msdos, mount_ext2fs, ...

<p>
Przede wszystkim musisz wiedzieæ na jakim urz±dzeniu znajduje siê twój
system plików. To mo¿e byæ twój pierwszy dysk twardy, <tt>wd0</tt> lub <tt>sd0</tt>,
lub co¶ mniej oczywistego.
Wszystkie rozpoznane i skonfigurowane urz±dzenia w twoim systemie s± podane
na wyj¶ciu polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>:
nazwa urz±dzenia poprzedzona jedn± lini± jego opisu.
Dla przyk³adu, mój pierwszy napêd CD-ROM jest rozpoznawany jako:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Chc±c uzyskaæ znacznie krótsz± listê dostêpnych dysków, mo¿esz skorzystaæ z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.

Polecenie:

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

poka¿e dyski aktualnie znane przez twój system, dla przyk³adu:

<blockquote><pre>
hw.disknames=cd0,cd1,wd0,fd0,cd2
</pre></blockquote>


<p>
W tym momencie, nadszed³ czas by dowiedzieæ siê jakie partycje znajduj± 
siê na tym urz±dzeniu, oraz na której z nich znajduje siê po¿±dany 
system plików. 
Dlatego te¿ sprawdzimy urz±dzenie korzystaj±c z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Disklabel zawiera listê partycji, z maksymaln± ich liczb± równ± 16.
Partycja c zawsze oznacza ca³y dysk.
Partycje a-b oraz d-p s± wykorzystywane przez OpenBSD.
Partycje i-p mog± byæ automatycznie przeznaczone na systemy plików
innych systemów operacyjnych.
W tym przypadku, bêdziemy ogl±daæ etykiety (disklabel) mojego dysku twardego,
zawieraj±cego kilka ró¿nych systemów plików.

<p>
<b>Uwaga: OpenBSD zosta³ zainstalowany po zainstalowaniu wcze¶niej innych systemów</b>,
i podczas instalacji disklabel zawiera³ natywny system plików jak i inne systemy plików
innych systemów operacyjnych.
Jednak¿e, je¿eli instalujesz inne systemy plików po tym jak zosta³ zainstalowany
disklabel OpenBSD, bêdziesz potrzebowa³ pó¼niej dodaæ lub zmodyfikowaæ je rêcznie.
Zosta³o to opisane w <a href="#foreignfsafter">tej sekcji</a>.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A      
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0


16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581
b:       1638000      20746656    swap                   # Cyl 20582 - 22206
c:      78165360             0  unused      0     0      # Cyl     0 - 77544
d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367
e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773
f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176
g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
i:         64197            63 unknown                   # Cyl     0*-    63*
j:      20274030         64260 unknown                   # Cyl    63*- 20176*
k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>


<p>
Jak mo¿emy zobaczyæ na powy¿szym wyj¶ciu partycje OpenBSD s± wylistowane
jako pierwsze. Nastêpne jest szereg partycji ext2 oraz jedna partycja
MSDOS, podobnie jak kilka partycji "unknown". Na systemach i386 oraz amd64
mo¿esz zazwyczaj dowiedzieæ siê wiêcej o tych partycjach korzystaj±c 
z narzêdzia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.
Dla ciekawskich czytelników: partycja i jest partycj± konserwacyjn±
utworzon± przez producenta, partycja j jest partycj± NTFS, natomiast
partycja l jest linuksow± partycj± wymiany.

<p>
Kiedy ju¿ okre¶li³e¶ jak± partycjê chcesz u¿yæ, mo¿esz przej¶æ do ostatniego
kroku: zamontowania znajduj±cego siê na niej systemu plików.
Wiêkszo¶æ systemów plików jest wspierana w j±drze GENERIC: po prostu
przyj¿yj siê konfiguracji j±dra znajduj±cej siê w katalogu
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt>.
Jednak¿e niektóre nie s± wspierane, np. wsparcie NTFS jest eksperymentalne,
dlatego te¿ nie jest w³±czone w GENERIC.
Je¿eli chcesz wykorzystaæ jeden z systemów plików nie wspierany w GENERIC,
bêdziesz musia³ <a href="faq5.html#Options">zbudowaæ w³asne j±dro</a>.

<p>
Kiedy ju¿ zebra³e¶ informacje wspomniane powy¿ej, nadszed³ czas na zamontowanie
systemu plików.
Przypu¶æmy ze istnieje katalog <tt>/mnt/otherfs</tt>, który u¿yjemy jako
punkt montowania rz±danego systemu plików.
W tym przypadku bêdziemy chcieli zamontowaæ system ext2 na partycji m:


<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>


<p>
Je¿eli zamierzasz korzystaæ z tego systemu plików regularnie, mo¿esz
zaoszczêdziæ sobie nieco czasu poprzez wpisanie do <tt>/etc/fstab</tt>,
na przyk³ad co¶ takiego:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>


Zwróæmy uwagê na zero wpisane w polach pi±tym i szóstym.
Oznacza to ¿e nie wymagamy by ten system plików by³ zrzucany oraz
sprawdzany przy u¿yciu fsck.
Zazwyczaj te rzeczy chcemy by by³y wykonywane przez natywny system
operacyjny wspó³pracuj±cy z danym systemem plików.


<a name="foreignfsafter"></a>
<h3>14.16.1 - Partycje nie istniej± w moim disklabel! Co powinienem zrobiæ?</h3>

Je¿eli instalujesz inny system plików w twoim systemie (w rezultacie dodawania
nowego systemu operacyjnego), po tym jak zainstalowa³e¶ OpenBSD,
etykiety dysków, zachowana zostanie aktualna zawarto¶æ disklabel, i nie bêdzie 
ona aktualizowana automatycznie by zawiera³a nowe partycje z tymi systemami plików.
Je¿eli chcesz z nich korzystaæ, konieczna bêdzie rêczna modyfikacja lub dodanie
tych partycji przy pomocy narzêdzia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Jako przyk³ad, zmodyfikowa³em jedn± z moich partycji ext2: korzystaj±c z linuksowego
programu fdisk, zmniejszy³em rozmiar partycji "o" (zobacz wynik disklabel powy¿ej)
do 1G.
Bêdziemy mogli to ³atwo rozpoznaæ dziêki pozycji startowej (offset: 64372518)
oraz rozmiarze (13783707).
Zauwa¿my, ¿e te warto¶ci to numery sektorów, i takie wykorzystanie numerów sektorów
(nie megabajtów lub innych miar) jest najbardziej w³a¶ciw± i bezpieczn± metod± 
do czytania tych informacji.

<p>
Zanim przyst±pimy do zmian, partycja ogl±dana przy pomocy dostêpnego w OpenBSD programu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
wygl±da tak (pozostawi³em tylko istotn± informacjê):

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
        Starting       Ending       LBA Info:
#: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Jak mo¿esz siê przekonaæ, pozycja pocz±tkowa partycji oraz rozmiar dok³adnie
odpowiada warto¶ciom podanym wcze¶niej przez program disklabel(8).
(Nie b±d¼ zmieszany warto¶ci± wskazywan± przez "Offset": jest to odniesienie
do pozycji startowej partycji rozszerzonej na której znajduje siê omawiana
partycja ext2).


<p>
Po zmianie partycji w linuksowym programie fdisk, wygl±da to tak:

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
#: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Teraz musi zostaæ to zmienione przy pomocy disklabel(8).
Przyk³adowo, mo¿esz wydaæ polecenie <tt>disklabel -e wd0</tt>, które wywo³a edytor
okre¶lony w zmiennej ¶rodowiskowej EDITOR (domy¶lnie jest vi).
W tym edytorze zmieñ ostatni± liniê disklabel by pasowa³a do nowego rozmiaru:

<blockquote><pre>
o:       2104452      64372518  ext2fs
</pre></blockquote>

Zapisz disklabel na dysk gdy skoñczysz.
Teraz gdy disklabel jest aktualny, powiniene¶ móc podmontowaæ twoj± partycjê jak 
opisano wcze¶niej.

<p>
Mo¿esz podobn± procedur± dodawaæ nowe partycje.


<a name="flashmem"></a>
<h2>14.17 - Czy mogê u¿ywaæ pamiêci flash w OpenBSD?</h2>
<!-- Artyku³ ten zosta³ napisany przez Stevena Mestdagh,
steven@openbsd.org, i udostêpniony na licencji BSD -->

Zazwyczaj no¶nik pamiêci powinien zostaæ rozpoznany zaraz po w³o¿eniu go
w port twojego komputera.
Krótko po w³o¿eniu, na konsoli powinny siê wy¶wietliæ wiadomo¶ci z j±dra.
Dla przyk³adu, kiedy pod³±czam moj± pamiêæ flash USB, widzê poni¿sze
komunikaty na konsoli:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Linie te oznaczaj±, ¿e sterownik 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>
(USB mass storage) zosta³ podczepiony do urz±dzenia pamiêci, oraz korzysta
z systemu SCSI.
Najwa¿niejsze s± dwie ostatnie linie: mówi± do jakiego wêz³a zosta³a pod³±czona
pamiêæ i jaki jest ca³kowity rozmiar przestrzeni na niej.
Je¿eli w jaki¶ sposób zgubi³e¶ te linie, wci±¿ mo¿esz je zobaczyæ pó¼niej
dziêki poleceniu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>.
Zg³oszona warto¶æ geometrii CHS jest raczej fikcyjna, poniewa¿ pamiêci flash
s± traktowane jak zwyk³e dyski SCSI.

<p>
Poni¿ej rozwa¿ymy dwa scenariusze.

<h3>Urz±dzenie jest nowe/puste i chcesz je u¿ywaæ tylko z OpenBSD</h3>

Bêdziesz potrzebowa³ za³o¿yæ etykietê dysku na tym urz±dzeniu, oraz
stworzyæ przynajmniej jedn± partycjê.
Proszê przeczytaj <a href="#disklabel">korzystanie z disklabel w OpenBSD</a>
oraz stronê manuala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
W tym przypadku utworzy³em jedn± partycjê <i>a</i> i za³o¿y³em na niej
system plików FFS:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
 cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
     122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Podmontujmy utworzony na partycji <i>a</i> system plików w 
<tt>/mnt/flashmem</tt>.
Wcze¶niej utwórz ten punkt montowania.


<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>
	         

<h3>Otrzyma³e¶ pamiêæ flash do kogo¶ innego z kim chcesz wymieniaæ siê danymi.</h3>

<p>
Istnieje znaczne prawdopodobieñstwo ze osoba ta nie korzysta z OpenBSD,
zatem na pamiêci mo¿e znajdowaæ siê obcy system plików.
Dlatego na pocz±tek sprawdzimy jakie partycje znajduj± siê na tym urz±dzeniu,
tak jak to opisano w <a href="#foreignfs">FAQ 14 - Czy mogê dostaæ siê
do danych na systemach plików innych ni¿ FFS?</a>.


<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
 c:        251904             0  unused      0     0      # Cyl     0 -   122
 i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Jak widzimy na etykietach dyskowych za³±czonych powy¿ej, jest tylko jedna
partycja <i>i</i>, zawieraj±ca system plików FAT utworzony na maszynie
windowsowej.
Jak zwykle partycja <i>c</i> oznacza ca³y dysk.

<p>
Podmontujmy system plików z partycji <i>i</i> w 
<tt>/mnt/flashmem</tt>.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>


Mo¿esz teraz zacz±æ korzystaæ z niego jak z ka¿dego innego dysku.

<p>
<b>OSTRZE¯ENIE:</b>
Powiniene¶ <b>zawsze odmontowywaæ</b> system plików <b>zanim od³±czysz</b>
no¶nik pamiêci. 
Je¿eli tego nie zrobisz, system plików mo¿e pozostaæ w niezgodnym stanie,
co mo¿e oznaczaæ uszkodzenie danych.

<p>
Po od³±czeniu no¶nika pamiêci z twojej maszyny, ponownie zobaczysz komunikaty
z j±dra o tym zdarzeniu na konsoli.

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<p>
<a name= "DiskOpt"></a>
<h2>14.18 - Optymalizacja operacji dyskowych</h2>


<p>
Szybko¶æ operacji wej¶cia/wyj¶cia systemów dyskowych ma znacz±cy wp³yw na 
ca³kowit± wydajno¶æ komputera. 
Ma to szczególne znaczenie wtedy, gdy twój komputer pracuje w ¶rodowisku 
wielodostêpnym (z systemu korzysta wielu u¿ytkowników ró¿nego rodzaju, 
tacy którzy loguj± siê do niego interaktywnie, tacy którzy korzystaj± z 
niego jako serwera plików albo serwera www). 
Dane przechowywane wymagaj± ci±g³ej uwagi, szczególnie wtedy, gdy na partycjach 
zaczyna brakowaæ miejsca lub wtedy, gdy dysk ulegnie uszkodzeniu. 
OpenBSD posiada wiele mechanizmów na zwiêkszenie szybko¶ci systemów dyskowych 
czy te¿ zapewniaj±cych odporno¶æ na uszkodzenia.

<p>
<ul>
<li><a href="#Optccd">CCD</a> - Driver dysków po³±czonych. 
<li><a href="#Optraid">RAID</a> 
<li><a href="#Optsoftu">Soft Updates</a>
<li><a href="#Optmaxvnodes">Rozmiar pamiêci podrêcznej namei()</a>
</ul>

<p>
<a name="Optccd"></a>
<h3>14.18.1 - CCD</h3>

Pierwsz± mo¿liwo¶ci± jest u¿ycie 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>, 
czyli sterownika dysków po³±czonych (Concatenated Disk Driver). Pozwala to na 
po³±czenie wielu partycji w jeden wirtualny dysk (oznacza to i¿ mo¿esz sprawiæ by 
wiele dysków widziane jest jako jeden). Jest to rozwi±zanie podobne do LVM 
(logical volume management), które zaimplementowane jest w wielu 
komercyjnych wersjach Uniksa.

<p>
Je¶li twój system pracuje na j±drze GENERIC, sterownik ccd jest w nim zawarty (w pliku 
<tt>/usr/src/sys/conf/GENERIC</tt>). Je¶li jednak przebudowa³e¶ kernel, byæ 
mo¿e bêdziesz potrzebowa³ w³±czyæ odpowiedni± opcjê w pliku konfiguracyjnym. 
Innymi s³owy, w pliku konfiguracyjnym musi znale¼æ siê wpis wygl±daj±cy w 
nastêpuj±cy sposób:

<blockquote><pre>
<strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre></blockquote>

<p>
Powy¿sza linia daje Ci mo¿liwo¶æ utworzenia maksymalnie 4 urz±dzeñ ccd 
(dysków wirtualnych, logicznych). 
Teraz musisz zdecydowaæ, które partycje z zainstalowanych w systemie 
dysków w³±czysz do urz±dzenia ccd. Nastêpn± czynno¶ci± jest u¿ycie narzêdzia 
disklabel, w celu oznaczenia tych partycji jako dostêpnych dla ccd. 
Na niektórych platformach sprzêtowych, narzêdzie disklabel mo¿e nie 
zezwoliæ na wykonanie tej czynno¶ci. W tym wypadku oznacz je jako ffs. 

<p>
Je¶li u¿ywasz ccd w celu zwiêkszenia wydajno¶ci poprzez zastosowanie 
stripingu, zwróæ uwagê na fakt, ¿e optymaln± wydajno¶æ uzyskasz 
tylko wtedy, gdy zastosujesz te same modele dysków z identycznymi 
ustawieniami wprowadzonymi programem disklabel. 

<p>
Plik /etc/ccd.conf powinien wygl±daæ podobnie do tego: 
(wiêcej informacji o konfiguracji ccd znajdziesz w podrêczniku 
man pod has³em 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>) 

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>


<p>
Aby zastosowaæ wprowadzone ustawienia wykonaj nastêpuj±ce polecenie 

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Tak d³ugo jak istnieje plik /etc/ccd.conf, tak d³ugo ccd bêdzie automatycznie 
konfigurowaæ siê podczas startu systemu. Od tego momentu masz w systemie nowy 
dysk nazwany ccd bêd±cy kombinacj± urz±dzeñ /dev/sd2e oraz /dev/sd3e. Wystarczy 
ponownie u¿yæ polecenia disklabel na urz±dzeniu ccd0, jak zwykle wtedy, 
gdy tworzysz partycjê lub partycje, które chcesz u¿ywaæ. Nie u¿ywaj partycji 'c' 
jako aktualnej partycji tworzonej na nowym urz±dzeniu. Upewnij siê, ¿e pocz±tek 
nowo tworzonej partycji rozpoczyna siê co najmniej 1 cylinder za pocz±tkiem dysku.


<p>
<a name="Optraid"></a>
<h3>14.18.2 - RAID</h3>

Innym rozwi±zaniem jest 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>. 
Aby kontrolowaæ macierze RAID u¿yj narzêdzia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>. 
System macierzy dyskowych RAID w systemie OpenBSD bazuje na opracowanym przez Grega Ostera
<a href="http://www.cs.usask.ca/staff/oster/raid.html">porcie dla NetBSD</a>
oprogramowamia CMU <a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a>. OpenBSD
wspiera nastêpuj±ce poziomy RAID: 0, 1, 4, oraz 5.

<p>
Mo¿liwo¶æ u¿ycia RAID, podobnie jak i ccd, definiuje siê w pliku konfiguracyjnym kernela. Niestety 
j±dro GENERIC nie wspiera systemu RAID, dlatego te¿ musi on byæ wkompilowany w j±dro. 
(obs³uga RAID zwiêksza rozmiar j±dra o oko³o 500K na platformie i386)

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
Wiêcej informacji uzyskasz, je¶li przeczytasz nastêpuj±ce tematy, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a> 
oraz <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>, 
w podrêczniku man. 
Podsystem RAID posiada wiele opcji konfiguracyjnych, 
a szczegó³owe przedstawienie wszystkich wykracza poza ramy tego dokumentu.


<p>
<a name="Optsoftu"></a>
<h3>14.18.3 - Soft updates</h3>

Innym narzêdziem, które mo¿e byæ u¿yte do poprawienia wydajno¶ci 
twojego systemu s± softupdates'y. Jedn± z najwolniejszych operacji w tradycyjnym
systemie plików systemu BSD jest aktualizacja informacji metainfo (co ma miejsce 
miêdzy innymi wtedy, gdy kasujesz lub tworzysz&nbsp; pliki/katalogi). Softupdates 
próbuj± aktualizowaæ informacje metainfo w pamiêci RAM zamiast zapisywaæ na dysk 
ka¿d± pojedyncz± aktualizacjê. Innym efektem tego dzia³anie jest fakt, ¿e 
informacje metainfo zapisane na dysku powinny zawsze byæ kompletne, jednak¿e 
nie oznacza to i¿ s± one najbardziej aktualne. Tak wiêc po padzie systemu, 
system nie powinien uruchomiæ 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a> 
w trakcie ponownego startu, wymaga tylko aby fsck dokona³ zmian metainfo w 
RAM'ie (przy pomocy softupdates). Skutkuje to szybszym startem serwera po 
awarii, jako ¿e nie musi on czekaæ na zakoñczenie fsck. (OpenBSD nie posiada 
jeszcze zaimplementowanych softupdates'ów.) Wiêcej mo¿esz dowiedzieæ siê 
czytaj±c o softupdates'ach w 
<a href="#SoftUpdates">Softupdates FAQ</a>.

<p>
<a name="Optmaxvnodes"></a>
<h3>14.18.4 - Rozmiar pamiêci podrêcznej namei()</h3>

Rozmiar pamiêci podrêcznej konwersji name-inode ( znanej tak¿e jako, 
<!-- need to write the manual page first... <a href="">namei(3)</a> -->
namei()) determinuje szybko¶æ translacji ¶cie¿ek do inode'ów 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>). 
Ma³y rozmiar tej pamiêci podrêcznej skutkuje du¿± ilo¶ci± 'cache misses', 
któr± mo¿na odczytaæ  pomoc± odpowiednich narzêdzi np. 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>, 
który wywo³uje
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>,
(sprawdzaj±cy parametr "<tt>kern.maxvnodes</tt>").
Równie¿ tym programem mo¿na dokonaæ zmiany tego parametru. Po zmianie nale¿y 
obserwowaæ wydajno¶æ komputera. Je¿eli zmiany s± 
satysfakcjonuj±ce mo¿emy ustawiæ ten parametr na sta³e tak, aby by³ stosowany 
przy ka¿dym starcie systemu. W tym celu nale¿y w pliku 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a> 
dodaæ odpowiedni wpis.

<p>
<a name= "Async"></a>
<h2>14.19 - Dlaczego nie u¿ywaæ asynchronicznego montowania dysków?</h2>

<p>
Pytanie: "Robiê tak "mount -u -o async /", co powoduje, 
¿e u¿ywana przeze mnie paczka (oprogramowanie przyp. t³um.)
(które posiada od czasu do czasu dostêp do ró¿nych danych) jest w dalszym ci±gu zdatna do u¿ycia.

Dlaczego montowanie asynchroniczne nie jest zalecane 
i nie jest w³±czone domy¶lnie (jak to jest w innych uniksach)? 
Czy¿ nie jest to prostsze oraz nie zwiêksza wydajno¶ci niektórych aplikacji?

<p>
Odpowied¼: "W rzeczy samej, asynchroniczne montowanie jest szybsze ni¿ synchroniczne, 
lecz jest mniej bezpieczne. Co stanie siê w przypadku zaniku zasilania? Czy te¿ problemu z hardwarem? 
D±¿enie do uzyskanie wiêkszej szybko¶ci nie powinno byæ okupione kosztem integralno¶ci i stabilno¶ci 
systemu. Przeczytaj opis polecenia 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a> w podrêczniku man." 


<pre>
	async    Wszystkie operacje wej¶cia/wyj¶cia w systemie plików 
        	 powinny byæ wykonane asynchronicznie. Jest to niebezpieczne,
	     	 poniewa¿ nie gwarantuje to spójno¶ci struktury systemu plików 
		 na dysku. Nie powiniene¶ u¿ywaæ tej opcji, chyba, ¿e jeste¶ 
		 przygotowany do ponownego utworzenia systemu plików w przypadku
		 awarii systemu. Najczê¶ciej u¿ywa siê tej flagi w celu przy¶pieszenia 
		 przywracania systemu plików poleceniem restore(8), co mo¿e przyczyniæ siê
		 do nawet dwukrotnego przy¶pieszenia operacji dyskowych.
</pre>

<p>
Z innej strony, kiedy masz do czynienia z danymi tymczasowymi, które mo¿esz odtworzyæ 
po awarii systemu, mo¿esz zwiêkszyæ szybko¶æ u¿ywaj±c odrêbnej, asynchronicznie montowanej partycji
tylko i wy³±cznie dla tego typu danych. Rób to jednak <i>tylko je¶li</i> nie poniesiesz straty wszystkich danych 
w przypadku, gdy co¶ pójdzie nie tak jak by¶ siê tego spodziewa³. W tym celu, partycje <a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a> 
s± montowane asynchronicznie, jako ¿e s± one czyszczone i ponownie tworzone po ka¿dym reboocie systemu.



<p>
<font color= "#0000e0">
<a href= "index.html">[Spis tre¶ci]</a>
<a href= "faq13.html">[Do sekcji 13 - Multimedia]</a>
<a href= "faq15.html">[Do sekcji 15 - Pakiety i Porty]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[wstecz]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.162 ]<br>
$Translation: faq14.html,v 1.42 2006/11/10 19:09:16 tkniaz Exp $<br>
-->
$OpenBSD: faq14.html,v 1.37 2006/11/12 16:09:22 jufi Exp $
</small>

</body>
</html>
