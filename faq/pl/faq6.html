<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Sieæ</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2006 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../pl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color="#0000e0">
<a href="index.html">[Spis Tre¶ci]</a>
<a href="faq5.html">[Sekcja 5 - Tworzenie systemu ze ¼róde³]</a>
<a href="faq7.html">[Sekcja 7 - Ustawienia klawiatury i wy¶wietlania]</a>
</font>


<h1><font color="#e00000">6 - Sieæ</font></h1>

<!--
UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Uwaga:</font></b>Zawarto¶æ tego pliku
jest ju¿ bardzo nieaktualna w stosunku do
<a href="../faq6.html">bie¿±cej wersji anglojêzycznej</a>.

<p>
Je¶li chcesz pomóc w aktualizacji tego pliku, zajrzyj na
<a href="../../translation.html">stronê t³umaczeñ</a>.

-->

<hr>

<p>
<h3>Spis Tre¶ci</h3>
<ul>
<li><a href= "#Intro" >6.1 - Wprowadzenie</a>
<li><a href= "#Setup" >6.2 - Inicjalizacja sieci</a>
<ul>
 <li><a href="#Setup.1" >6.2.1 - Identyfikacja i konfiguracja interfejsów
    sieciowych</a>
 <li><a href="#Setup.2" >6.2.2 - Konfiguracja OpenBSD jako bramy 
    sieciowej</a>
 <li><a href="#Setup.3" >6.2.3 - Ustawianie aliasów na interfejsie 
    sieciowym</a>
</ul>
<li><a href= "#PF"    >6.3 - Filtrowanie ruchu i budowa firewalli
                             przy pomocy OpenBSD</a>
<li><a href= "#DHCP"  >6.4 - Konfiguracja DHCP</a>
<ul>
 <li><a href="#DHCPclient">6.4.1 - Klient DHCP</a>
 <li><a href="#DHCPserver">6.4.2 - Server DHCP</a>
</ul>
<li><a href= "#PPP"   >6.5 - Protokó³ PPP</a>
<li><a href= "#Tuning">6.6 - Tuning parametrów sieciowych</a>
<li><a href= "#NFS"   >6.7 - Korzystanie z NFS</a>
<li><a href= "#Bridge">6.9 - Konfiguracja bridge`a w OpenBSD</a>
<li><a href= "#PXE"   >6.10 - Konfiguracja PXE (i386, amd64)</a>
<li><a href= "#CARP"  >6.11 - Common Address Redundancy Protocol (CARP)</a>
<li><a href= "#OpenNTPD">6.12 - Korzystanie z OpenNTPD</a>
<li><a href="#Wireless">6.13 - Jaki wybraæ sprzêt do budowy sieci
      bezprzewodowych?</a>
<li><a href="#Multipath">6.14 - Jak mogê zrobiæ routing oparty na wyborze
jednej z tras o jednakowym koszcie?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Wprowadzenie</h2>

<p>
Dla zrozumienia wiêkszo¶ci z tego dokumentu, zalecane jest zapoznanie siê
i zrozumienie sekcji 5 FAQ <a href="faq5.html">konfiguracja i instalacja
j±dra</a>, dzia³ania narzêdzi
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> oraz
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> na podstawie odpowiadaj±cych im stron manuala.

<p>
Je¶li administrujesz sieci± i zajmujesz siê konfiguracj± protoko³ów routingu
u¿ywaj±c do tego celu maszyny z OpenBSD jako rutera i chcesz zag³êbiæ siê
bardziej w sieci IP, powiniene¶ przeczytaæ poni¿szy znakomity dokument
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">
Understanding IP Addressing</a>.
Dokument ten zawiera fundamentalne informacje na temat sieci IP, jest zw³aszcza
przydatny, gdy opiekujesz siê wieloma sieciami.

<p>
Je¶li zajmujesz siê administrowaniem takimi us³ugami jak serwery www,
ftp czy te¿ poczty, mo¿esz dowiedzieæ siê wielu interesuj±cych rzeczy
o ich dzia³aniu czytaj±c odpowiednie
<a href="http://www.rfc-editor.org/rfc.html">dokumenty RFC</a>
opisuj±ce szczegó³owo protoko³y oraz dzia³anie tych us³ug.
Oczywi¶cie nie przeczytasz ich wszystkich - zajmij siê tymi, którymi
jeste¶ najbardziej zainteresowany lub których u¿ywasz w swojej sieci. Dokumenty
RFC definiuj± tysi±ce standardów opisuj±cych protoko³y sieciowe,
ich dzia³anie oraz sposób w jaki powinny zostaæ realizowane.

<p>
<a name="Setup"></a>
<h2>6.2 - Inicjalizacja Sieci</h2>

<p>
<a name="Setup.1"></a>
<h3>6.2.1 - Identyfikacja i konfiguracja interfejsów sieciowych</h3>

<p>
Aby zacz±æ musisz zidentyfikowaæ swoje interfejsy sieciowe. W OpenBSD nazywane
s± one wed³ug typu sterownika a nie typu po³±czenia (jak ma to miejsce np. w
Linuksie). Mo¿esz zobaczyæ w jaki sposób system wykry³ Twoj± kartê podczas
procesu uruchamiania lub pó¼niej korzystaj±c z polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>.
Aktualn± konfiguracjê interfejsów sieciowych mo¿esz zobaczyæ przy pomocy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Dla przyk³adu, oto co wy¶wietlone zosta³o przez komendê dmesg w przypadku karty sieciowej
Intel Fast Ethernet, u¿ywaj±cej nazwy fxp.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Je¶li nie wiesz, jak nazywa siê Twoje urz±dzenie sieciowe przejrzyj
<a href="../../pl/plat.html">listê urz±dzeñ wspieranych przez OpenBSD</a> dla odpowiedniej platformy.
Znajdziesz tam spis wielu popularnych kart sieciowych oraz odpowiedniki
ich nazw w OpenBSD. Pe³na nazwa urz±dzenia w systemie sk³ada siê z tego
w³a¶nie synonimu (jak fxp) oraz numeru przyznanego urz±dzeniu przez j±dro systemu
(np. fxp0).

<p>
Sprawdzenia jakie interfejsy sieciowe zosta³y zidentyfikowane przez system
mo¿esz dokonaæ korzystaj±c z narzêdzia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Poni¿sza komenda wy¶wietli wszystkie interfejsy w systemie. W tym przyk³adzie
widaæ tylko jeden fizyczny interfejs ethernetowy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.

<blockquote><pre>
$ <strong>ifconfig</strong>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224 
	inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
	inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
	inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
	address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
	address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
Jak widzisz,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
dostarcza nam wielu u¿ytecznych w tym momencie informacji, miêdzy
innymi widaæ tutaj interfejs, który w powy¿szym przyk³adzie jest ju¿ skonfigurowany.
Oczywistym jest, ¿e sieæ IP dostêpna jest poprzez interfejs fxp0, st±d
warto¶ci &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;.
Ponadto flagi <strong>UP</strong> i <strong>RUNNING</strong> s± ustawione.

<p>
Oprócz fxp0 widoczne s± równie¿ domy¶lnie udostêpnione inne interfejsy.
S± to urz±dzenia wirtualne pe³ni±ce w systemie rozmaite funkcje.
Ich szczegó³owy opis znajdziesz na stronach manuala:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - interfejs pêtli zwrotnej (Loopback Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a>
 - interfejs logowania filtra pakietów (Packet Filter Logging Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - interfejs szeregowego ³±cza IP (SLIP)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - interfejs protoko³u PPP (Point to Point Protocol)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - programowy interfejs tunelu (Tunnel Network Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - opakowuj±cy pseudointerfejs pêtli zwrotnej (Encapsulating Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
 - interfejs bridge`a ethernetowego (Ethernet Bridge Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - interfejs sieci wirtualnych budowanych na urz±dzeniach zgodnych z IEEE 802.1Q
 <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - interfejs tunelu IP korzystaj±cy z protoko³ów GRE/MobileIP
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - interfejs tunelu IPv4/IPv6 (Generic IPv4/IPv6 Tunnel Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp</a>
 - interfejs Common Address Redundancy Protocol
</ul>

<p>
Je¶li Twój interfejs sieciowy nie jest skonfigurowany, pierwszym co powiniene¶ zrobiæ,
jest stworzenie pliku <i>/etc/hostname.xxx</i>. W miejsce "xxx" umie¶æ nazwê interfejsu
którego dany plik ma dotyczyæ. Dla powy¿szego przyk³adu, plik ten powinien mieæ
nazwê <i>/etc/hostname.fxp0</i>. Sk³adnia pliku jest prosta:<br>

<blockquote><pre>
address_family address netmask broadcast [other options]
</pre></blockquote>

(Znaczenie oraz wiêcej szczegó³ów odno¶nie formatu tego pliku znajdziesz w manualu pod
has³em
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>.)

<p>
Typowy plik interfejsu sieciowego skonfigurowanego do wspó³pracy z adresami IPv4
mo¿e wygl±daæ nastêpuj±co:

<blockquote><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
Wprowadzaj±c dodatkowe opcje mo¿esz skonfigurowaæ typ Ethernetu i dla przyk³adu:
je¶li chcesz, aby karta pracowa³a w trybie 100baseTX full-duplex, plik konfiguracyjny
bêdzie wygl±da³ nastêpuj±co:

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
Oczywi¶cie nie powiniene¶ nigdy ustawiaæ trybu, z którym nie potrafi wspó³pracowaæ
drugi koniec po³±czenia. Je¶li nie ma ku temu wyra¼nych powodów, nie jest zalecane
stosowanie dodatkowych opcji ustalaj±cych tryb pracy.

<p>
Mo¿esz zauwa¿yæ, ¿e w przypadku konfigurowania ró¿nych typów interfejsów
i przypisywania im specyficznych dla nich opcji format pliku pozostaje niemal identyczny!

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
Nastêpnym krokiem jest ustalenie domy¶lnej bramki (trasy routingu).
Jedyne co musisz zrobiæ, to umie¶ciæ adres IP swojej bramki w pliku
<i>/etc/mygate</i>. Dziêki temu Twój system zostanie poinformowany
o bramie domy¶lnej przy ka¿dorazowym uruchamianiu. Teraz kolej na 
ustalenie serwerów nazw i edycjê pliku <i>/etc/hosts</i> (zobacz
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)</a>).
Do poinformowania systemu z których serwerów nazw powinien korzystaæ,
musisz stworzyæ (o ile jeszcze nie istnieje) plik <i>/etc/resolv.conf</i>.
Wiêcej na temat formatu tego pliku mo¿esz dowiedzieæ siê ze strony manuala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>.
Je¿eli u¿ywasz DHCP mo¿esz chcieæ przeczytaæ <a href="#DHCP">6.4 - DHCP</a> bior±c pod uwagê
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">resolv.conf.tail(5)</a>.
Jednak dla standardowych zastosowañ podajemy przyk³ad.

<p>
Zak³adamy przy tym, ¿e serwery nazw maj± adresy 125.2.3.5 i 125.2.3.5 oraz
nale¿ysz do domeny &quot;example.com&quot;.


<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
W tej chwili, aby zainicjowaæ sieæ na swojej konfiguracji, mo¿esz uruchomiæ
ponownie komputer b±d¼ uruchomiæ skrypt <strong>/etc/netstart</strong>.
Mo¿esz to zrobiæ w prosty sposób (jako u¿ytkownik root):

<blockquote><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Zauwa¿, ¿e uruchomienie skryptu spowodowa³o wyst±pienie kilku b³êdów.
Jest to spowodowane zainicjalizowaniem rekonfiguracji systemu ju¿
skonfigurowanego. Dla przyk³adu, niektóre trasy routingu istnia³y ju¿
w tablicy rutingu j±dra. Od tej chwili obs³uga sieci w Twoim systemie powinna byæ ju¿
skonfigurowana. Aby upewniæ siê, ¿e wszystkie interfejsy zosta³y skonfigurowane
tak jak planowa³e¶ pos³u¿ siê narzêdziem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Trasy routingu mo¿esz obejrzeæ korzystaj±c z
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>
lub <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>.
Je¶li masz problemy z routingiem, mo¿esz skorzystaæ z flagi -n programu
route(8), która drukuje adresy IP, zamiast wykonywaæ wyszukiwania DNS
i wy¶wietlaæ nazwy.
Poni¿ej znajduj± siê przyk³ady u¿ycia obu tych narzêdzi.

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.2"></a>
<h3>6.2.2 - Konfiguracja komputera z OpenBSD jako rutera</h3>

<p>
Poni¿ej zamieszczone s± podstawowe informacje z którymi powiniene¶ zapoznaæ
siê, chc±c skonfigurowaæ maszynê z OpenBSD jako bramkê (router). Je¶li komputer
ma stanowiæ bramkê do Internetu, zalecane jest przeczytanie instrukcji
dotycz±cych konfiguracji filtra pakietów (Packet Filter) aby móc blokowaæ
potencjalnie niebezpieczny ruch. Ponadto, bior±c pod uwagê niewielk±
przestrzeñ adresów
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a>
przydzielan± przez dostawców us³ug internetowych mo¿esz zechcieæ skorzystaæ
z informacji o translacji adresów sieciowych (NAT - Network Address Translation),
aby rozs±dniej wykorzystaæ przyznan± Ci pulê adresów IP.

<p>
Standardowe (GENERIC) j±dro ma mo¿liwo¶æ przekazywania pakietów IP (IP Forwarding),
do dzia³ania, wymaga ono jednak inicjalizacji. Powiniene¶ w tym celu skorzystaæ z
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.
Aby maszyna zawsze startowa³a z w³±czonym przekazywaniem pakietów powiniene¶ wyedytowaæ
plik <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>.
Jedyne co musisz zrobiæ, to dodaæ poni¿sz± linijkê do tego pliku.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Aby uzyskaæ ten efekt bez restartu maszyny, mo¿esz skorzystaæ bezpo¶rednio
z narzêdzia <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.
Pamiêtaj, ¿e po ponownym uruchomieniu komputera, zmiana ta nie bêdzie obowi±zywaæ. Do wykonania poni¿szej
komendy musisz mieæ uprawnienia root'a.

<blockquote><pre>
# <strong>sysctl net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
Teraz jedyne co Ci pozostaje, to ustawienie tras routingu na hostach po obu
stronach Twojego rutera. Istnieje wiele mo¿liwo¶ci wykorzystania OpenBSD
jako rutera korzystaj±c z takich narzêdzi jak stworzony dla OpenBSD
<a href="http://www.openbgpd.org/">OpenBGPD</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.mrtd.net">mrtd</a>,
<a href="http://www.zebra.org">zebra</a>, i
<a href="http://www.quagga.net">quagga</a>.
OpenBSD wspiera oprogramowanie takie jak zebra, gated czy mrtd poprzez 
system portów. OpenBGPD oraz routed s± instalowane jako czê¶ci systemu bazowego.
Potrafi tak¿e wspó³pracowaæ
z rozmaitymi interfejsami takimi jak T1, HSSI, ATM, FDDI, Ethernet oraz po³±czeniami
poprzez linie szeregowe (PPP/SLIP).

<p>
<a name="Setup.3"></a>
<h3>6.2.3 - Ustawianie aliasów na interfejsach sieciowych</h3>

<p>
OpenBSD posiada prosty mechanizm nadawania aliasów IP interfejsom.
Jedyne co musisz zrobiæ, to odpowiednio wyedytowaæ plik
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>.
Plik ten, z informacjami o konfiguracji interfejsu, jest czytany
w momencie uruchamiania siê systemu przez skrypt
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8">/etc/netstart(8)</a>,
który jest elementem procedury startowej (<a href="faq10.html#rc">rc startup
hierarchy</a>). Dla przyk³adu zak³adamy, ¿e u¿ytkownik posiada interfejs
<b>dc0</b> i znajduje siê w sieci 192.168.0.0. Pozosta³e istotne
informacje:

<ul>
<li>adres IP: 192.168.0.2
<li>maska sieciowa (NETMASK): 255.255.255.0
</ul>

<p>
Kilka uwag na temat aliasów. W OpenBSD u¿ywasz tylko jednej nazwy
interfejsu. Nie ma w tym przypadku ¿adnej ró¿nicy pomiêdzy pomiêdzy
pierwszym a drugim aliasem. W przeciwieñstwie do innych systemów operacyjnych
OpenBSD nie odnosi siê do kolejnych aliasów, kolejno je numeruj±c,
jak np.: dc0:0, dc0:1. Je¶li odnosisz siê do konkretnego 'aliasowanego'
adresu IP poprzez ifconfig, lub dodajesz alias, b±d¼ uwa¿ny i pamiêtaj
o sk³adni "<tt>ifconfig int alias</tt>" zamiast "<tt>ifconfig int</tt>".
Dowolny alias mo¿esz usun±æ poleceniem "<tt>ifconfig int delete</tt>".

<p>
Zak³adaj±c, ¿e u¿ywasz wielu adresów IP, które nale¿± do tej samej
podsieci jako aliasy, maska sieciowa dla ka¿dego z nich przyjmuje
warto¶æ 255.255.255.255. Nie musisz powielaæ w ka¿dym przypadku
maski pierwszego adresu IP przypisanego do interfejsu. W poni¿szym
przyk³adzie, plik <i>/etc/hostname.dc0</i>, zawiera definicje dwóch
aliasów do interfejsu dc0 skonfigurowanego pocz±tkowo jako
192.168.0.2 z mask± 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Po wyedytowaniu pliku, jedyne co musisz zrobiæ, aby wprowadziæ powy¿sze
zmiany w konfiguracji, to uruchomiæ ponownie komputer. Naturalnie, mo¿esz
tak¿e nadaæ aliasy rêcznie, bez potrzeby restartowania systemu, u¿ywaj±c
narzêdzia <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Do uaktywnienia pierwszego aliasu z powy¿szego przyk³adu powiniene¶
pos³u¿yæ siê komend±:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
Do wy¶wietlenia aliasów skorzystaj z polecenia:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="NAT"></a>
<a name="PF"></a>
<h2>6.2 - Filtrowanie ruchu i budowa firewalli przy pomocy OpenBSD</h2>
Filtr pakietów (od tej chwili nazywany jako PF) jest systemem OpenBSD
odpowiedzialnym za filtrowanie ruchu TCP/IP oraz translacjê adresów
sieciowych (NAT). PF potrafi tak¿e normalizowaæ pakiety oraz zapewniaæ
kontrolê przepustowo¶ci ³±cza z priorytetowaniem pakietów, oraz s³u¿y
do budowy wydajnych i wysoce konfigurowalnych zapór sieciowych. Opis
PF znajduje siê w <a href="../pf/pl/index.html"><b>PF FAQ</b></a>.

<p>
<a name= "DHCP"></a>
<h2>6.4 - DHCP</h2>

Dynamic Host Configuration Protocol (DHCP) to sposób na "automatyczn±"
konfiguracje interfejsów sieciowych.
OpenBSD mo¿e byæ serwerem DHCP (konfiguruj±c inne maszyny),
klientem DHCP (uzyskuj±c konfiguracjê z innej maszyny), a w niektórych
przypadkach i jednym i drugim.

<p>
<a name="DHCPclient"></a>
<h3>6.4.1 - Klient DHCP</h3>

<p>
Aby skorzystaæ z klienta DHCP
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
do³±czonego standardowo do OpenBSD, wyedytuj plik <tt>/etc/hostname.xl0</tt> (zak³adaj±c
¿e twoim g³ównym interfejsem ethernetowym jest xl0. W rzeczywisto¶ci mo¿e to byæ
ep0 lub fxp0, lub co¶ zupe³nie innego).
Wszystko co musisz zrobiæ to wpisaæ do tego pliku '<tt>dhcp</tt>': 

<blockquote><pre>
# <b> echo dhcp &gt;/etc/hostname.xl0</b>
</pre></blockquote>

<p>
Dziêki temu OpenBSD automatycznie uruchomi klienta DHCP przy starcie dla wskazanego
interfejsu. Pobrany zostanie adres IP, domy¶lna bramka, oraz serwery DNS.

<p>
Je¶li chcesz skonfigurowaæ swój interfejs poprzez DHCP z linii poleceñ, upewnij siê,
¿e masz plik <tt>/etc/dhclient.conf</tt>, a nastêpnie wykonaj:

<blockquote><pre>
# <b>dhclient fxp0</b>
</pre></blockquote>

<p>
Gdzie <tt>fxp0</tt> jest interfejsem na który chcesz otrzymaæ DHCP.

<p>
Niewa¿ne w jaki sposób uruchamiasz klienta DHCP, zawsze mo¿esz wyedytowaæ
<tt>/etc/dhclient.conf</tt> aby np. <b>nie</b> uaktualniaæ swojej
konfiguracji serwerów DNS poprzez odkomentowanie linii 'request'
(poni¿ej znajdziesz przyk³adowe domy¶lne opcje, które musisz odkomentowaæ
i dokonaæ spo¶ród nich wyboru.)

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

<p>
a nastêpnie usun±æ <tt>domain-name-servers</tt>. 
Oczywi¶cie mo¿esz chcieæ chcieæ tak¿e usn±æ <tt>hostname</tt>, lub
pozosta³e ustawienia.

<p>
Poprzez zmianê opcji w twoim pliku
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5">
dhclient.conf(5)</a>,
mo¿esz przekazaæ klientowi DHCP jak stworzyæ twój plik
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>.
Klient DHCP nadpisze wszystkie informacje jakie ju¿ mia³e¶ wpisane do 
resolv.conf(5), informacjami uzyskanymi z serwera DHCP.
Stracisz zatem wszystkie informacje które wprowadzi³e¶ do resolv.conf.

<p>
Dostêpne s± dwa mechanizmy pozwalaj±ce temu zapobiec:

<ul>
<li>
<tt><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS">OPTION
MODIFIERS</a></tt>
(<b>default</b>, <b>supersede</b>, <b>prepend</b>, and <b>append</b>)
pozwol± ci nadpisaæ dowoln± z opcji w dhclient.conf(5).

<li>
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"><tt>resolv.conf.tail(5)</tt></a>
pozwol± ci dodaæ cokolwiek chcesz do, stworzonego przez dhclient(8), pliku resolv.conf(5).
</ul>

<p>
W poni¿szym przyk³adzie chcesz u¿yæ DHCP, ale zamierzasz dodaæ 
<tt>lookup file bind</tt> do swojego pliku resolv.conf(5) tworzonego przez dhclient(8).
Nie ma opcji pozwalaj±cej na to w <tt>dhclient.conf</tt>, musisz zatem u¿yæ
<tt>resolv.conf.tail</tt>:

<blockquote><pre>
# <b>echo "lookup file bind" &gt /etc/resolv.conf.tail</b>
</pre></blockquote>
	     
Teraz twój resolv.conf(5) powinien zawierac "lookup file bind" na koñcu.
<blockquote><pre>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote> 

<p>
<a name="DHCPserver"></a>
<h3>6.4.2 - Serwer DHCP</h3>

<p>
Je¶li chcesz aby Twój OpenBSD pracowa³ w sieci jako serwer DHCP
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>,
wyedytuj <tt>/etc/rc.conf.local</tt> poprzez ustawienie <tt>dhcpd_flags=""</tt>.
Umie¶æ nazwê interfejsu, na którym serwer ma <b>nas³uchiwaæ</b> w pliku
<tt>/etc/dhcpd.interfaces</tt>.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
A nastêpnie zabierz siê za konfiguracjê serwera poprzez plik <tt>/etc/dhcpd.conf</tt>.
Znaczenie poni¿szych opcji jest chyba jasne.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Twój serwer DHCP powie klientowi, ¿e nale¿y do domeny "example.com" oraz ¿e serwery DNS dla tej
domeny to 192.168.1.3 i 192.168.1.5. Hosty znajduj±ce siê w tej samej sieci co adres
interfejsu OpenBSD, na którym nas³uchuje DHCP nale¿±cy do sieci 192.168.1.0/24
otrzymaj± adresy z zakresu 192.168.1.32 - 192.168.1.127. Otrzymaj± te¿ informacjê,
aby jako domy¶ln± bramê wykorzystywa³y host 192.168.1.1.

<p>
Je¶li chcesz uruchomiæ dhcpd(8) z linii komend po edycji
<tt>/etc/dhcpd.conf</tt>, u¿yj:

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd fxp0</b>
</pre>

<p>
Linia zaczynaj±ca siê poleceniem <tt>touch</tt> jest niezbêdna i s³u¿y do
utworzenia pustego pliku <tt>dhcpd.leases</tt> zanim bêdzie mo¿na uruchomiæ
serwer dhcpd(8).
<a href="faq10.html#rc">Skrypty startowe</a> OpenBSD utworz± ten plik je¶li
nie bêdzie on istnia³ podczas startu systemu, jednak uruchamiaj±c dhcpd(8)
rêcznie niezbêdne jest stworzenie tego pliku samodzielnie. <tt>fxp0</tt>
jest interfejsem na którym serwer DHCP bêdzie nas³uchiwaæ.

<p>
Je¶li udostêpniasz us³ugê DHCP klientowi Windows, mo¿esz zechcieæ, aby
dhcpd(8) poda³ temu klientowi adres serwera 'WINS'. Wystarczy dodaæ analogiczn±
do poni¿szej linijkê do <tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(gdzie zamiast <tt>192.168.92.55</tt> powiniene¶ wstawiæ swój adres IP serwera Windows
lub Samba.)
Zobacz <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a>, aby dowiedzieæ siê jakie inne informacje mo¿esz dostarczyæ klientom.

<p>
<a name="PPP"></a>
<h2>6.5 - PPP </h2>

<p>
Protokó³ Punkt-do-Punktu (Point-to-Point Protocol - PPP) najczê¶ciej
wykorzystywany jest w przypadkach, gdy ³±czysz siê ze swoim dostawc±
Internetu poprzez modem. W OpenBSD mo¿esz to zrobiæ na dwa sposoby poprzez:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
 - demon PPP dzia³aj±cy w przestrzeni j±dra.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - demon PPP dzia³aj±cy w przestrzeni u¿ytkownika.
</ul>

<p>
Narzêdzia ppp i pppd oferuj± podobna funkcjonalno¶æ jednak ró¿nymi sposobami.
pppd pracuje ze sterownikiem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp(4)</a>
w j±drze podczas gdy ppp dzia³a w przestrzeni u¿ytkownika z
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun(4)</a>.
Dokument ten opisuje tylko demona PPP pracuj±cego w przestrzeni u¿ytkownika, poniewa¿
jest on prostszy w debagowaniu oraz w konfiguracji.

Zaczniemy od konfiguracji demona PPP, który bêdzie móg³ byæ uruchamiany
przez zwyk³ych u¿ytkowników. Aby rozpocz±æ potrzebujesz trochê informacji od
swojego dostawcy. Oto lista rzeczy, które powiniene¶ wiedzieæ, nim przyst±pimy do pracy:

<ul>
<li>Numer dial-up Twojego dostawcy.
<li>Adres serwera nazw.
<li>Twoja nazwa u¿ytkownika i has³o.
<li>Adres Twojej bramki.
</ul>

<p>
Bez czê¶ci z nich mo¿esz siê obej¶æ, ale wygodniej bêdzie je¶li bêdziesz
dysponowa³ powy¿szymi informacjami. Demon PPP pracuj±cy w przestrzeni u¿ytkownika
korzysta z pliku konfiguracyjnego
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>.
W katalogu <i>/etc/ppp</i> znajdziesz kilka pomocnych plików, które mog±
definiowaæ ró¿ne konfiguracje dla ró¿nych specyficznych sytuacji. Zalecane
jest, aby¶ siê z nimi zapozna³.

<p>
<h3>Podstawowa konfiguracja PPP(8)</h3>

<p>
Podstawowa konfiguracja dzia³aj±cego w przestrzeni u¿ytkownika demona PPP
polega na edycji pliku <i>/etc/ppp/ppp.conf</i>. Domy¶lnie tego pliku nie
ma w Twoim systemie, ale znajduje siê plik <i>/etc/ppp/ppp.conf.sample</i>,
z którego mo¿esz skorzystaæ tworz±c swój plik <i>ppp.conf</i>. Poni¿ej opisana
zostanie najbardziej podstawowa i typowa konfiguracja. Oto przyk³adowy plik
<i>ppp.conf</i>, który definiuje kilka domy¶lnych ustawieñ:

<blockquote>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</blockquote>

<p>
Sekcja poni¿ej <tt>default:</tt> bêdzie przetwarzana przy ka¿dym uruchomieniu
demona. Umieszczamy w niej wszystkie niezbêdne informacje. Korzystaj±c
z &quot;set log&quot; konfigurujemy poziomy logowania. Mo¿esz zmieniæ te
ustawienia, aby dowiedzieæ siê wiêcej na temat ustawienia poziomów logowania
zajrzyj do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>.
Wyboru urz±dzenia, pod którym jest nasz modem dokonujemy w sekcji &quot;set device&quot;,
w tym przypadku modem pod³±czony jest do drugiego portu szeregowego, port
pierwszy to urz±dzenie <i>/dev/cua00</i>. Korzystaj±c z &quot;set speed&quot;
ustalamy prêdko¶æ po³±czenia, a w &quot;set dial&quot; podajemy parametry
naszego po³±czenia. Mo¿na zdefiniowaæ w tym miejscu inny 'timeout' dla naszego
po³±czenia itp. Podana linijka jest do¶æ dobra i raczej nie wymaga zmian.

<p>
Teraz mo¿emy przej¶æ do sekcji w których podamy informacje specyficzne dla
dostawcy Internetu (ISP). Informacje te podajemy w sekcjach umiejscowionych
poni¿ej nag³ówka <tt>default:</tt>. Nag³ówek nowej sekcji mo¿e mieæ dowolny
tytu³, np. nazwê Twojego ISP. Tutaj skorzystamy z nazwy <tt>myisp:</tt>,
poni¿ej tego nag³ówka znajdziesz wszystkie informacje niezbêdne do tego,
aby po³±czenie zosta³o poprawnie zainicjowane:

<blockquote>
<pre>
myisp:
set phone 1234567
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR
enable dns
</pre>
</blockquote>

<p>
Oto podstawowa konfiguracja potrzebna do tego, aby po³±czyæ siê z
konkretnym ISP. Opcja &quot;set phone&quot; ustala numer dial-up naszego ISP.
Kolejna, &quot;set login&quot;, pozwala na wprowadzenie opcji niezbêdnych
do poprawnego zalogowania siê. Umie¶cili¶my tutaj timeout na 5 sekund, co
oznacza, ¿e nasza próba zalogowania siê zostanie przerwana po 5 sekundach
bez sygna³u po³±czenia. W innym przypadku bêdziemy czekaæ na
&quot;login:&quot; oraz wys³ane zostanie Twoja nazwa u¿ytkownika oraz has³o.

<p>
W powy¿szym przypadku
nazwa u¿ytkownika (Username) = ppp oraz has³o (Password) = ppp. Te warto¶ci
bêdziesz musia³ zmieniæ (&quot;od t³umacza: chyba ¿e korzystasz z us³ug TPSA&quot;).
Wiersz &quot;set timeout&quot; ustala "ja³owy" (idle) czas dla ca³ego po³±czenia
na 120 sekund. Opcja &quot;set ifaddr&quot; wymaga d³u¿szego wyja¶nienia.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
W powy¿szej linii korzystamy z ustawienia adresu w formacie &quot;<b>set ifaddr
[myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;.
Czyli pierwszym adresem IP jest ten, jaki chcemy aby zosta³ nam przypisany.
Je¶li dostajesz statyczny adres od swojego ISP powiniene¶ umie¶ciæ go w³a¶nie
tutaj. W tym przyk³adzie dodali¶my /0, aby zaznaczyæ, ¿e ¿aden z bitów tego
adresu nie wymaga dopasowania i mo¿e on zostaæ ca³kowicie zmieniony przez
ISP podczas transakcji rozpoczynaj±cej po³±czenie. Drugi adres IP to adres
IP dostawcy. Je¶li go znasz, umie¶æ go w³a¶nie w tym miejscu, je¶li nie
zrób tak, jak w naszym przypadku - umie¶æ na koñcu /0. Trzecia opcja to nasza
maska sieciowa, w tym przypadku ustawiona na 255.255.255.0. Je¶li triggeraddr
jest ustawiony, u¿ywany jest do zast±pienia myaddr podczas rozpoczêcia
negocjacji IPCP. Jakkolwiek tylko adres z zakresu myaddr zostanie zaakceptowany.
Ta opcja u¿yteczna jest w przypadkach, gdy niektóre implementacje PPP podczas
negocjacji po³±czenia nie przyznaj± adresu IP dopóki nie za¿±dasz ``0.0.0.0.0''.

<p>
Nastêpna opcja &quot;add default HISADDR&quot; ustala domy¶ln± trasê
routingu na adres ISP. Dziêki takiemu wpisowi jeste¶ uniezale¿niony
od adresu IP Twojego dostawcy - za ka¿dym razem bêdzie on automatycznie
uaktualniony w przypadku zmiany. Dziêki opcji &quot;enable dns&quot;
mówimy naszemu ISP aby 'zalegalizowa³' adresy naszych serwerów nazw.
UWAGA: nie rób tego je¶li masz uruchomiony lokalny serwer DNS, poniewa¿
ppp obejdzie to poprzez dopisanie kilku linijek nameserver w pliku
<i>/etc/resolv.conf</i>.

<p>
Zamiast tradycyjnych metod logowania, wielu ISP u¿ywa obecnie autoryzacji
CHAP lub PAP. Je¿eli tak jest w naszym przypadku, nasz plik konfiguracyjny 
bêdzie wyglada³ nieco inaczej:

<blockquote>
<pre>
myisp:
set phone 1234567  
set authname ppp
set authkey ppp
set login
set timeout 120  
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR
enable dns
</pre>
</blockquote>

<p>
W powy¿szym przyk³adzie, podali¶my nazwê u¿ytkownika (ppp) oraz has³o (ppp)
korzystaj±c odpowiednio z authname i authkey. Nie ma potrzeby podawaæ czy
chodzi o autoryzacjê CHAP lub PAP - zostanie to wynegocjowane automatycznie.
Opcja "set login" jedynie okre¶la próbê zalogowania siê, z nazw± u¿ytkownika i
has³em podanym wcze¶niej.

<p>
<h3>U¿ywanie PPP(8)</h3>

<p>
Mamy wreszcie nasz plik <i>ppp.conf</i> z konfiguracj± po³±czenia, teraz
mo¿emy spróbowaæ po³±czyæ siê z naszym ISP. Opisanych zostanie kilka
najczê¶ciej u¿ywanych parametrów ppp:

<ul>
<li><tt>ppp -auto myisp</tt> - Uruchamia ppp, konfiguruje interfejs,
³±czy siê z ISP a nastêpnie przechodzi do pracy w tle.
<li><tt>ppp -ddial myisp</tt> - Podobne do -auto, ale w przypadku, gdy
po³±czenie zostanie utracone, zostan± podjête próby jego przywrócenia.
</ul>

<p>
Je¿eli powy¿sze próby nie powiod± siê, spróbuj uruchomiæ <i>/usr/sbin/ppp</i>
nie podaj±c ¿adnych opcji - uruchomi siê ppp w trybie interaktywnym. Mo¿esz
podawaæ opcje jedna po drugiej sprawdzaj±c gdzie wystêpuj± b³êdy lub inne problemy.
Stosuj±c konfiguracjê opisan± powy¿ej, ppp bêdzie logowa³o do pliku /var/log/ppp.log.
Log ten, podobnie jak strona manuala, zawiera wszystkie pomocne informacje.

<p>
<h3>dodatki do ppp(8)</h3>

<p>
W niektórych sytuacjach mo¿e zaj¶æ potrzeba wykonania jakiej¶ czynno¶ci w momencie,
gdy po³±czenie zostaje utracone lub nawi±zane. Do tego typu zadañ wykorzystuje siê
dwa pliki: <i>/etc/ppp/ppp.linkup</i> i <i>/etc/ppp/ppp.linkdown</i>.
Przyk³adowe konfiguracje znajdziesz poni¿ej:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
<h3>odmiany ppp(8)</h3>

<p>
Bardzo wielu ISP oferuje obecnie us³ugi xDSL, znacznie szybsze ni¿ tradycyjne
metody dial-up. Opiszemy odmiany PPP takie jak ADSL i SDSL.
Chocia¿ nie nastêpuje fizyczne wdzwanianie, po³±czenia wci±¿ oparte s± na 
protokole Point to Point. Za³±czone przyk³ady:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
Point to Point Protocol over Ethernet (PPPoE) pozwala na przesy³anie pakietów
PPP w ramkach ethernetowych.
Point to Point Protocol over ATM (PPPoA) dzia³a w sieciach ATM, takich jak te zbudowane 
w Wielkiej Brytanii i Belgii.

<p>
Oznacza to, ¿e mo¿esz nawi±zaæ po³±cznie z twoim ISP korzystaj±c tylko 
ze standardowej karty sieciowej i ethernetowego modemu DSL (w 
przeciwieñstwie do modemów USB).

<p>
Je¿eli posiadasz modem który rozumie PPPoE/PPPoA, mo¿liwe jest skonfigurowanie
modemu do nawi±zywania po³±czeñ. Alternatywnie, je¿eli modem posiada funkcjê
bridge'a, mo¿liwe jest jego w³±czenie i ustawienie modemu do przepuszczania 
pakietów na maszynê z uruchomionym PPPoE (patrz poni¿ej).

<p>
Podstawowym oprogramowaniem do PPPoE/PPPoA w OpenBSD jest
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8">pppoe(8)</a>,
który jest implementacj± pracuj±c± w przestrzeni u¿ytkownika (w taki sam sposób jak
opisany wcze¶niej
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>).
Implementacja PPPoE pracuj±ca w przestrzeni j±dra,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">pppoe(4)</a>,
zosta³a dodana do OpenBSD.

<p>
<h3>PPTP</h3>

<p>
Point to Point Tunneling Protocol (PPTP) jest prawnie zastrze¿onym
protoko³em Microsoft'u. 
Klient pptp dostêpny jest poprzez interfejsy z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
i mo¿e po³±czyæ siê do opartych o PPTP wirtualnych sieci prywatnych (VPN) u¿ywanych
przez dostawców kablowych i xDSL.
Sam pptp musi byæ instalowany z <a href="faq15.html#PkgMgmt">pakietów</a> lub 
<a href="faq15.html#Ports">partów</a>.
Dodatkowe informacje o konfiguracji i u¿yciu pptp s± dostêpne na stronie manuala,
który instaluje siê razem z pakietem pptp.


<p>
<a name="Tuning"></a>
<h2>6.6 - Tuning parametrów sieciowych</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - Jak zmusiæ j±dro aby stosowa³o wiêksza liczbê ponowieñ
i d³u¿sze czasy timeout dla sesji TCP?</h3>

<p>
Zmiana tych standardowych ustawieñ mo¿e byæ pomocna w przypadku problemów
z po³±czeniem i routingiem. Oczywi¶cie, aby zmiany te dzia³a³y efektywnie
powinny z nich korzystaæ obie strony po³±czenia.

<p>
Do zmiany tych warto¶ci u¿yj <tt>sysctl</tt> i powiêksz warto¶ci:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Korzystaj±c z sysctl -a, mo¿esz obejrzeæ aktualne ustawienia tych
(i wielu innych) parametrów j±dra. Aby zmieniæ jeden z nich, skorzystaj
z <tt>sysctl net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - W jaki sposób uruchomiæ "directed broadcasts"?</h3>

<p>
W normalnej sytuacji nie powiniene¶ tego robiæ. Zezwala to bowiem komu¶ na
wys³anie pakietów pod adres(y) broadcast Twoich sieci w przypadku, gdy u¿ywasz
OpenBSD jako routera. 

<p>
Istnieje kilka przypadków w zamkniêtych sieciach gdy,
mo¿e byæ to u¿yteczne, zw³aszcza korzystaj±c ze starszych implementacji
protoko³u NetBIOS. Wykorzystujemy do tego celu kolejny sysctl:
<tt>sysctl net.inet.ip.directed-broadcast=1</tt>. Je¶li chcesz wiedzieæ
dlaczego domy¶lnie jest ta opcja wy³±czona poczytaj o atakach typu
<a href="http://www.netscan.org">smurf</a>.

<p>
<h3>6.6.3 - Nie chcê aby, j±dro dynamicznie przydziela³o pewne porty.</h3>

<p>
Tak¿e do tej konfiguracji s³u¿y sysctl. Czytaj±c w
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>:

<pre>
Decydowanie o li¶cie zarezerwowanych portów TCP, które nie powinny byæ
alokowane przez j±dro dynamicznie. Mo¿esz wykorzystaæ tê opcjê, aby
nie zezwalaæ demonom na "podkradanie" portów, z których korzystaj±
inne programy. Elementy listy oddzielony mog± byæ przecinkami i/lub
znakami bia³ymi.

 #  <strong>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

Mo¿na tak¿e dodaæ, b±d¼ usun±æ, który¶ z wpisów aktualnej listy.

 #  <strong>sysctl net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl net.inet.tcp.baddynamic=-871</strong>
</pre>

<p>
<h3>6.6.4 - W jaki sposób zwiêkszyæ wydajno¶æ na naprawdê szybkich, silnie obci±¿onych
    interfejsach?</h3>
    
Je¿eli obserwujesz ograniczenia wydajno¶ci korzystaj±c z szybkich po³±czeñ WAN,
przepuszczaj±cych du¿e ilo¶ci danych, mo¿esz zaobserwowaæ zwiêkszenie wydajno¶ci
poprzez modyfikacjê poni¿szych sysctls:
 
<blockquote><pre>
net.inet.tcp.recvspace
net.inet.tcp.sendspace
</pre></blockquote>

Spróbuj u¿yæ warto¶ci takich jak 65536, zamiast domy¶lnych 16384.
Zwracamy uwagê, ¿e wielu nie zauwa¿y ¿adnej zmiany.
Nie zmieniaj tych ustawieñ, chyba ¿e faktycznie obserwujesz wydajno¶æ
poni¿ej twoich oczekiwañ.

<p>
<a name="NFS"></a>
<h2>6.7 - Proste wykorzystanie NFS</h2>

<p>
NFS, sieciowy system plików (Network File System) wykorzystywany jest do
wspó³dzielenia systemów plików w sieci. Przed przyst±pieniem do konfiguracji
NFS powiniene¶ zapoznaæ siê z kilkoma stronami manuala:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
</ul>

<p>
Dziêki temu rozdzia³owi w prosty sposób dowiesz siê jak skonfigurowaæ
NFS. Omawiamy wszystko na przyk³adzie serwera pracuj±cego w sieci LAN
oraz klientów, którzy wykorzystuj± w tej sieci NFS. W sekcji tej nie
bêdziemy poruszaæ zagadnieñ zwi±zanych z bezpieczeñstwem, zak³adamy,
¿e masz ju¿ skonfigurowany swój filtr pakietów lub inn± ochronê typu
firewall, aby uniemo¿liwiæ dostêp osobom z zewn±trz. Je¶li zamierzasz
zezwoliæ na dostêp do NFS z zewn±trz w celu wymiany poufnych
danych, które nie powinny trafiæ w niepowo³ane rêce, rekomendowane jest
wykorzystanie IPsec. W innym przypadku mo¿liwe
jest pods³uchanie ca³ego ruchu, który wymieniany jest przez NFS. Innym
sposobem na niepowo³ane dostanie siê do serwera jest podmienienie
adresu IP na taki, któremu zezwalasz na dostêp. Istnieje jeszcze kilka
metod ataku na NFS, jednak prawid³owo skonfigurowany IPsec stanowi skuteczn±
ochronê.

<p>
Jeszcze jedna uwaga zwi±zana z bezpieczeñstwem. Nie dodawaj samych
systemów plików do <i>/etc/exports</i> bez listy hostów, które mog±
mieæ dostêp do zasobów. Je¶li nie wyszczególnisz, który z nich mo¿e
montowaæ odpowiedni katalog, ka¿dy, kto bêdzie móg³ ustanowiæ z Twoim
serwerem po³±czenie, bêdzie móg³ montowaæ wszystkie eksportowane
przez Ciebie katalogi.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
musi byæ on uruchomiony aby dzia³a³ NFS. Portmap(8) w 
OpenBSD jest domy¶lnie wy³±czony, dlatego
dodaj liniê

<blockquote><pre>
portmap=YES
</pre></blockquote>

do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a>
aby uruchamia³ siê podczas startu. Mo¿esz go tak¿e w³±czyæ poleceniem:

<blockquote><pre>
# <strong>/usr/sbin/portmap</strong>
</pre></blockquote>

<p>
W naszym przyk³adzie serwer ma adres IP <b>10.0.0.1</b>. Bêdzie on udostêpnia³
NFS tylko klientom znajduj±cym siê w swojej sieci. Pierwszym krokiem
w konfiguracji jest edycja pliku <i>/etc/exports</i>. Umie¶cisz w nim
zasoby, które chcia³by¶ udostêpniæ klientom oraz zdefiniujesz kto
powinien mieæ dostêp do poszczególnych zasobów. W pliku <i>/etc/exports</i> mo¿esz
u¿yæ naprawdê wielu opcji, aby zapoznaæ siê ze wszystkimi mo¿liwo¶ciami
przeczytaj <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
W tej chwili mamy <i>/etc/exports</i> wygl±daj±cy w ten sposób:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network=10.0.0 -mask=255.255.255.0
</pre></blockquote>

<p>
Powy¿szy wpis oznacza, ¿e przez NFS dostêpny bêdzie system plików <tt>/work</tt>.
Opcja <tt>-alldirs</tt> ¿e klienci bêd± mogli montowaæ ka¿dy katalog
znajduj±cy siê na systemie plików <tt>/work</tt>. Opcja <tt>-ro</tt>
oznacza, ¿e zezwalamy na montowanie w trybie tylko do odczytu. Ostatnie
dwa argumenty mówi±, ¿e tylko hosty z sieci 10.0.0.0 o masce 255.255.255.0
mog± mieæ dostêp do tego zasobu, co jest istotne w przypadku, gdy serwery
pracuj± w kilku ró¿nych sieciach.

<p>
Gdy Twój plik <i>/etc/exports</i> jest ju¿ odpowiednio skonfigurowany,
mo¿esz przej¶æ do konfiguracji serwera. Upewnij siê, czy Twoje j±dro
zosta³o skompilowane z opcj± NFSSERVER oraz NFSCLIENT
(standardowe j±dra tak maj±).
Nastêpnym krokiem jest dodanie wpisu 

<blockquote><pre>
nfs_server=YES
</pre></blockquote>

do pliku <i>/etc/rc.conf.local</i>. 
Spowoduje to automatyczne uruchomienie
nfsd(8) i mountd(8) za ka¿dym razem, gdy uruchomisz ponownie komputer.
W tej chwili mo¿esz uruchomiæ te demony rêcznie, aby to zrobiæ,
musisz byæ root'em oraz portmap(8) musi byæ ju¿ uruchomiony.
Oto przyk³ad uruchomienia nfsd(8) pracuj±cego na protoko³ach TCP i UDP,
korzystaj±c z 4 demonów. Powiniene¶ ustaliæ tê liczbê wg w³asnych potrzeb,
aby okre¶liæ maksymaln± ilo¶æ jednocze¶nie obs³ugiwanych klientów.

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Wystartowanie nfsd(8) nie jest ostatni± czynno¶ci±, oprócz tego potrzebujesz
uruchomiæ jeszcze mountd(8). Demon ten obs³uguje ¿±dania montowania NFS.
Aby go uruchomiæ, upewnij siê, ¿e istnieje pusty plik mountdtab, a nastêpnie
uruchom demona:

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<p>
Je¶li w trakcie pracy wprowadzisz jakie¶ zmiany w /etc/exports, musisz
poinformowaæ o tym mountd! Wystarczy sygna³ HUP:

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<p>
<h3>Statystyki NFS</h3>

<p>
W tej chwili mo¿esz sprawdziæ czy wystartowanie przez Ciebie demony pracuj±
i s± zarejestrowane w RPC. Skorzystaj z rpcinfo(8).

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Podczas zwyk³ego u¿ytkowania, istnieje jeszcze kilka innych narzêdzi
pozwalaj±cych zobaczyæ co dzieje siê z NFS'em. Jedn± z nich jest:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">showmount(8)</a>,
dziêki któremu mo¿esz dowiedzieæ siê. jakie zasoby s± aktualnie zamontowane
i przez kogo. Jest jeszcze nfsstat(8), który wy¶wietla kilka dodatkowych
informacji. U¿ywaj±c showmount(8), spróbuj <tt>/usr/bin/showmount -a host</tt>
Przyk³adowo:

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>Montowanie systemu plików NFS</h3>

<p>
NFS powinien byæ montowany poleceniem mount(8) lub w bardziej specyficzny
dla niego sposób korzystaj±c z
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
Do zamontowania systemu plików <i>/work</i> znajduj±cego siê na ho¶cie
10.0.0.1 do lokalnego katalogu <i>/mnt</i> skorzystaj z poni¿szej sk³adni
(mo¿esz zamiast adresu IP u¿yæ nazwy hosta):

<blockquote><pre>
# <strong>mount -o ro -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
Je¶li chcesz, aby montowanie przebiega³o w momencie uruchamiania systemu,
dodaj linijkê analogiczn± do poni¿szej w pliku <i>/etc/fstab</i>:

<blockquote><pre>
10.0.0.1:/work /mnt nfs ro 0 0
</pre></blockquote>

<p>
Wa¿ne jest, aby¶ jako dwa ostatnie wpisy w tej linii umie¶ci³ <tt>0 0</tt>,
aby Twój komputer nie próbowa³ sprawdzaæ systemu plików programem fsck
przy starcie! Inne standardowe opcje zwiêkszaj±ce bezpieczeñstwo, takie
jak noexec, nodev i nosuid powinny byæ tak¿e u¿yte zawsze, gdy jest to mo¿liwe:

<blockquote><pre>
10.0.0.1:/work /mnt nfs ro,nodev,nosuid 0 0
</pre></blockquote>

<p>
W ten sposób, mount nie bêdzie interpretowa³ urz±dzeñ specjalnych i uniewa¿ni
bity suid dziêki czemu programy na serwerze nie bêd± mog³y wykonywaæ
niebezpiecznych operacji na kliencie NFS. Je¶li nie montujesz ¿adnych
programów, których chcia³by¶ u¿ywaæ przez NFS, powiniene¶ dodaæ tak¿e opcjê
noexec.


<a name="Bridge"></a>
<h2>6.9 - Konfiguracja sieciowego bridge`a w OpenBSD</h2>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">Bridge</a>
jest pomostem ³±cz±cym dwie lub wiêcej odseparowanych od siebie sieci.
W przeciwieñstwie do rutera, bridge jest logicznie "niewidzialny",
dwa segmenty sieci my¶l±, ¿e tworz± jeden segment z hostami po drugiej
stronie bridge'a. Bridge bêdzie jedynie przekazywa³ pakiety pomiêdzy
segmentami sieci i umo¿liwia³ ³atwy i bezpo¶redni dostêp do zasobów
pomiêdzy hostami znajduj±cymi siê w odrêbnych segmentach sieci.

<p>
Pamiêtaj, ¿e ze wzglêdu na swój "niewidzialny" charakter dzia³ania,
interfejs sieciowy bridge'a mo¿e posiadaæ (lub nie) indywidualny
adres IP. Je¶li tak, interfejs ma dwa typy pracy, jeden jako bridge,
drugi jako zwyk³y, standardowy interfejs sieciowy. Je¶li interfejs nie posiada
adresu IP, bridge bêdzie przekazywa³ pakiety, jednak nie bêdzie
dostêpny z zewn±trz.

<p>
<h3>Przyk³ad bridge'a</h3>

<p>
Posiadam zbiór starych systemów komputerowych, ¿aden z nich nie ma wbudowanego
interfejsu 10BASE-TX. Posiadaj± natomiast ³±cza AUI lub AAUI. Jedn± z maszyn
jest terminal serwerowy z OpenBSD, maj±cy sta³e szybkie po³±czenie z tak±
sam± sieci±. Dodanie kolejnego interfejsu z portem coax pozwoli na wykorzystanie
tej maszyny jako bridge'a pomiêdzy sieciami coax.

<p>
System ten posiada dwa interfejsy, Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
i kartê 3c590-Combo
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
dla portu coax. <tt>fxp0</tt> jest interfejsem pod³±czonym do pozosta³ej
czê¶ci sieci, a zatem bêdzie mieæ przypisany adres IP, <tt>ep0</tt>
bêdzie tworzyæ bridge bez przypisanego adresu IP. Hosty pod³±czone
do segmentu coax bêd± mog³y siê ze sob± komunikowaæ tak, jakby by³y
w drugiej czê¶ci sieci. Jak do tego dojdziemy?

<p>
Plik <tt>hostname.fxp0</tt> zawiera konfiguracjê interfejsu <tt>fxp0</tt>.
Korzysta on z informacji dostarczanych przez DHCP, wiêc plik wygl±da
w poni¿szy sposób:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE
</pre>
</blockquote>

<p>
Bez niespodzianek.

<p>
Karta <tt>ep0</tt> posiada nieco inn± konfiguracjê:

<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

<p>
Instruujemy system, aby aktywowa³ interfejs korzystaj±c z
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
i ustawi³ tryb pracy na 10BASE-2 (coax). Nie przypisujemy do interfejsu
adresu IP, ani ¿adnych podobnych informacji. Opcje kart <tt>ep</tt>
znajdziesz na <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">stronie manuala</a>.

<p>
Teraz musimy uruchomiæ bridge. Inicjujemy go, poprzez plik konfiguracyjny
nazwany w stylu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>.
A oto i jego przyk³adowa zawarto¶æ:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

<p>
Oto ca³a filozofia tworzenia bridge'a sk³adaj±cego siê z dwóch interfejsów
sieciowych fxp0 i ep0 oraz jego aktywacji. Czy jest istotna kolejno¶æ w
jakiej to robimy? Nie, nale¿y bowiem pamiêtaæ, ¿e bridge jest symetryczny -
pakiety wêdruj± w obu kierunkach.

<p>
To ju¿ wszystko! Uruchom ponownie system i ciesz siê funkcjonalno¶ci±
swojego bridge'a.

<p>
<h3>Filtrowanie pakietów w systemie z bridge'm</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

Czêsto, nawet podczas u¿ywania tak prostego bridge'a jak ten, mo¿e zaj¶æ
potrzeba zrobienia CZEGOKOLWIEK z pakietami wêdruj±cymi przez niego.
Jak pewnie siê domy¶lasz, <a href="#PF">Filtr Pakietów</a> potrafi
doskonale sobie z tym radziæ i kontrolowaæ ruch wêdruj±cy poprzez
bridge.

<p>
Uwa¿aj, pamiêtaj o dwukierunkowej naturze bridge'a, o tym, ¿e czê¶æ
danych wêdruje poprzez dwa interfejsy, tak wiêc wystarczy, gdy bêdziesz
je filtrowa³ na jednym z nich. Twoje domy¶lne regu³ki "Pass all" mog±
wygl±daæ w ten sposób:

<blockquote>
<pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre>
</blockquote>

<p>
Teraz, powiedzmy ¿e chcia³bym filtrowaæ ruch wêdruj±cy z/do starych maszyn,
które wymieni³em powy¿ej. Chcê zezwoliæ im na korzystanie jedynie z us³ug www
oraz SSH. W tym przypadku, zezwalamy na przemieszczanie siê pakietów w obu kierunkach
poprzez interfejs <tt>ep0</tt>, natomiast filtrowania dokonujemy na interfejsie <tt>fxp0</tt>,
u¿ywaj±c opcji <tt>keep state</tt> do przechwytywania powracaj±cych danych:

<blockquote>
<pre>
# Przepu¶æ ca³y ruch przez ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Zablokuj ca³y ruch na interfejsie fxp0
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

<p>
Zauwa¿ ¿e ten zestaw regu³ek, zablokuje wszystko za wyj±tkiem ruchu HTTP i SSH
przed dotarciem zarówno do naszego bridge'a jak i ka¿dego hosta "za nim".
Inne rezultaty mo¿esz osi±gn±æ filtruj±c ruch na drugim interfejsie.

<p>
Do monitorowania i kontrolowania utworzonego bridge'a, korzystaj z
komendy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
która mo¿e byæ równie¿ u¿ywana do stworzenia bridge'a.

<p>
<h3>Uwagi na temat bridge'a</h3>

<ul>
<li>Jest BARDZO zalecane, aby¶ filtruj±c pakiety, robi³ to na tylko
jednym interfejsie. Je¶li uwa¿asz, ¿e musisz filtrowaæ dwa interfejsy,
upewnij siê, ¿e naprawdê rozumiesz co robisz.

<li>Poprzez u¿ycie opcji <i>blocknonip</i> komendy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
lub podanie jej w
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">bridgename.bridge0</a>,
mo¿esz zablokowaæ ka¿dy ruch za wyj±tkiem IP (jak nt IPX czy NETBEUI)
przed przedostaniem siê przez Twój filtr. Mo¿e to byæ bardzo pomocne
w kilku przypadkach, pamiêtaj bowiem, ¿e bridge pracuje z ka¿dym protoko³em,
nie tylko IP.

<li>Bridge wymaga aby interfejsy sieciowe pracowa³y w trybie "promiscuous"
-- nas³uchuj± ka¿dy ruch w sieci, nie tylko ten przeznaczony do nich samych.
Powoduje to wiêksze obci±¿enie procesora i magistrali systemowej.
Niektóre karty maj± problemy z prac± w tym trybie, dla przyk³adu
chipy TI ThunderLAN -
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
s± przyk³adem urz±dzenia, które nie mo¿e pracowaæ jako czê¶æ bridge'a.
</ul>

<a name="PXE"></a>
<h2>6.10 - Konfiguracja PXE (i386, amd64)</h2>

<p>
Preboot Execution Environment, czyli PXE, pozwala wystartowaæ komputer
z sieci zamiast z dysku twardego, napêdu CDROM, czy te¿ z dyskietki
startowej. Technologiê t± opracowa³ Intel, jest jednak wspierana
przez znakomit± wiêkszo¶æ kart sieciowych i producentów komputerów.
Warto zwróciæ uwagê, ¿e istnieje kilka standardów startu systemu z sieci,
przy czym PXE opracowano stosunkowo niedawno.
Tradycyjnie, PXE wykorzystuje pamiêci ROM na kartach sieciowych
(b±d¼ te¿ na p³ytach g³ównych). S± jednak dostêpne odpowiednie dyskietki
startowe, pozwalaj±ce na wykorzystanie PXE.
Wiele pamiêci ROM na starszych kartach sieciowych wspiera bootowanie
z sieci, NIE wspiera jednak PXE - obecnie nie mo¿na ich wykorzystaæ do
startu na architekturach: OpenBSD/i386 oraz amd64.

<h3>Jak przebiega proces bootowania w PXE?</h3>
Po pierwsze musimy zrozumieæ pocz±tkowy proces <a
href="faq14.html#Boot386">bootowania OpenBSD</a>
na platformach i386 i amd64.
Podczas startu systemu, kompatybilna z PXE karta sieciowa rozg³asza
¿±danie DHCP.
Serwer DHCP przydziela na podstawie adresu MAC karty sieciowej, adres IP,
oraz przekazuje nazwê pliku do pobrania z serwera
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a>.
Plik ten odpowiada za dalsz± czê¶ci± startu systemu. W OpenBSD plikiem
tym jest  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot(8)</a>, który zastêpuje standardowy plik
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot(8)</a>.
pxeboot(8) umo¿liwia za³adowanie i wykonanie j±dra systemu (dla przyk³adu: <tt>bsd</tt> lub <a href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a>) z serwera 
tftp(1).

<h3>Jak mam to wykonaæ?</h3>
By rozpocz±æ wymagane jest posiadanie karty sieciowej (lub komputera)
kompatybilnej z PXE. Niektóre dokumentacje podaj± listê kart sieciowych i
komputerów zgodnych z PXE. Nie jest to do koñca prawda, poniewa¿ wiele
tanich urz±dzeñ nie zawiera modu³ów PXE ROM lub u¿ywa starego protoko³u.
Co wiêcej, wymagane jest tak¿e poprawne skonfigurowanie serwerów
<a href="#DHCP">DHCP</a> i TFTP.

<p>
Zak³adaj±c, ¿e maszyna z OpenBSD jest ¼ród³em plików startowych
(NIE jest to wymagane). Plik konfiguracyjny serwera DHCP <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5"
>dhcpd.conf</a> powinien zawieraæ liniê:

<pre>
    filename "pxeboot";
</pre>

je¿eli w zamierzeniu OpenBSD udostêpnia ten plik startuj±cym stacjom
roboczym. Na przyk³ad:

<pre>
    shared-network LOCAL-NET {
	option domain-name "example.com";
	option domain-name-servers 192.168.1.3, 192.168.1.5;
    
	subnet 192.168.1.0 netmask 255.255.255.0 {
	    option routers 192.168.1.1;
	    <b>filename "pxeboot";</b>
	    range 192.168.1.32 192.168.1.127;
	    default-lease-time 86400;
	    max-lease-time 90000;
	}
    }
</pre>

<p>
Konieczne jest tak¿e uruchomienie demona <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8"
>tftpd(8)</a>.  Standardowo wykonujemy to poprzez  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a>.
Standardowa instalacja OpenBSD posiada przyk³adow± liniê w <tt>inetd.conf</tt>
która bêdzie dla ciebie pomocna:

<pre>
    #tftp dgram udp wait root /usr/libexec/tftpd tftpd -s /tftpboot
</pre>

(usuwamy # z pocz±tku tej linii) i wys³aniem do procesu inetd(8) 
sygna³u -HUP, aby prze³adowaæ <tt>/etc/inetd.conf</tt>. 
Serwer tftpd(8)  udostêpnia pliki z zaznaczonego katalogu, w naszym
przypadku jest to katalog <tt>/tftpboot</tt>.
Oczywi¶cie, katalog ten musi zostaæ utworzony i udostêpniony.
W typowym rozwi±zaniu potrzebujemy tylko kilku plików dla PXE:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386" 	 
>pxeboot</a>, czyli PXE boot loader (oferuj±cy podobn± funkcjonalno¶æ
jak <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot</a> przy starcie z napêdu lokalnego).
<li><a href="faq4.html#bsd.rd">bsd.rd</a> lub <tt>bsd</tt>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
>/etc/boot.conf</a>, plik konfiguracji bootowania
</ul>

Zwróæ uwagê, ¿e plik <tt>/etc/boot.conf</tt> wykorzystujemy tylko w
sytuacji gdy j±dro które chcemy wykorzystaæ nazwane jest inaczej ni¿
<tt>bsd</tt>, lub w sytuacji gdy inne domy¶lne ustawienia pxeboot
nie s± nam potrzebne (np. gdy chcemy u¿ywaæ konsoli szeregowej).
Mo¿esz przetestowaæ dzia³anie swojego serwera tftpd(8)
przy pomocy klienta <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a>, aby upewniæ siê ¿e mo¿esz pobraæ niezbêdne pliki.

<p>
Zak³adaj±c, ¿e serwery DHCP i TFTP s± ju¿ skonfigurowane, jeste¶my gotowi
do przetestowania konfiguracji.
Pozostaje tylko aktywowaæ PXE na stacji roboczej.
W trakcie uruchamiania systemu powinni¶my zobaczyæ:

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation
    
    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)
    
    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76 MASK: 255.255.255.0 DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe!2.1 mem540k 28m a20=on
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i368 PXEBOOT 1.00
    boot>
</pre>

W tym momencie otrzymujemy standardowy boot prompt. Je¿eli wpiszemy
"<tt>bsd.rd</tt>", zostanie pobrany plik <tt>bsd.rd</tt> z serwera TFTP.

<pre>
    >> OpenBSD/i386 PXEBOOT 1.00
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 58+122112+105468=0x516d04
    entry point at 0x100120
    
    Copyright (c) 1982, 1986, 1989, 1991, 1993
	The Regents of The University of California. All rights reserved.
    
    Copyright (c) 1995-2006 OpenBSD. All rights reserved. http://www.OpenBSD.org
    
    OpenBSD 4.0 (RAMDISK_CD) #39: Sat Sep 16 19:34:26 MDT 2006
     ...
</pre>

Rozpoczyna siê start systemu z <a href="faq4.html#bsd.rd">j±drem
instalacyjnym bsd.rd</a>.

<p>
<h3>Czy mo¿liwe jest u¿ycie innych kerneli ni¿ <tt>bsd.rd</tt>?</h3>

Tak, chocia¿ z narzêdziami dostêpnymi w OpenBSD, PXE zosta³o
zaplanowane raczej do instalacji systemu.

<a name="CARP"></a>
<h2>6.11 - Common Address Redundancy Protocol (CARP)</h2>
<h3>6.11.1 - Czym jest CARP i w jaki sposób dzia³a?</h3>
<!-- This article written by Sunny Raspet, slr@mordac.info, and
released under the BSD license -->

<p>
CARP jest narzêdziem, które pozwala uczyniæ system redundantnym poprzez
utworzenie wirtualnej sieci pomiêdzy komputerami, dziêki czemu w przypadku
awarii jednego z nich, inny przejmuje jego rolê, ewentualnie obci±¿enie
rozk³adane jest na pozosta³e maszyny.
CARP jest udoskonaleniem standardu Virtual Router Redundancy Protocol
(VRRP).
Zosta³ opracowany, gdy uznano ¿e VRRP nie jest wystarczaj±co "wolny",
ze wzglêdu na mo¿liwo¶æ objêcia go patentami CISCO.
Aby uzyskaæ wiêcej informacji o pochodzeniu CARP`a, a tak¿e aspektach
prawnych towarzysz±cych VRRP, odwied¼ t± 
<a href="../../lyrics.html#35">stronê</a>.

<p>
Ze wzglêdu na problemy licencyjne Ryan McBridge (z pomoc± Michael
Shalayeff'a, Marco Pfatschbacher'a i Markusa Friedl'a)
zaprojektowa³ CARP jako narzêdzie fundamentalnie ró¿ne od VRRP.
W³±czenie kryptografii jest najbardziej widoczn± zmian±, wci±¿ jednak
jest to tylko jedna z wielu zmian.

<p>
Jak to dzia³a: CARP jest protoko³em multicastowym.
Grupuje kilka fizycznych maszyn w jednej lub kilku wirtualnych sieciach.
W tej grupie, jeden komputer pe³ni role zarz±dzaj±cego (master`a) i
odpowiada na pakiety kierowane do ca³ej grupy.
Pozosta³e pe³ni± rolê "zapasowych" (ang. "hot spares").
Nie ma znaczenia jaki jest adres IP lub MAC fizycznego interfejsu,
pakiety wys³ane na adres CARP wracaj± z informacj± CARP.

<p>
W konfigurowalnych odstêpach czasu, komputer zarz±dzaj±cy (ang. master)
rozg³asza swoj± aktywno¶æ na protokole 112.
Je¿eli master zostanie od³±czony, systemy z grupy CARP rozpoczynaj±
rozg³aszanie, przy czym host rozg³aszaj±cy najczê¶ciej staje siê nowym
masterem grupy.
Ponowne pojawienie siê g³ównego systemu, domy¶lnie powoduje,
¿e staje siê on zapasowym, o ile nie jest po¿±dane by jedna maszyna
stawa³a siê masterem zawsze kiedy jest dostêpna (dla przyk³adu,
gdy jeden host jest szybkim Sun Fire V120 natomiast pozosta³e to
nieporównywalnie s³absze SPARCstation). Mo¿esz to oczywi¶cie 
skonfigurowaæ.

<p>
O ile wysoko redundantne i odporne na zak³ócenia urz±dzenia minimalizuj±
potrzebê posiadania CARP`a, ca³kowicie nie wykluczaj± jego zasadno¶ci.
Nie istnieje bowiem urz±dzenie mog±ce zachowaæ zdolno¶ci operacyjne
po od³±czeniu go od ¼ród³a zasilania, lub w sytuacji gdy administrator
wpisze <tt>reboot</tt> w niew³a¶ciwym oknie.
CARP pozwala tak¿e u³atwiæ paczowanie i cykliczne restarty w sposób
prze¼roczysty dla u¿ytkowników, a tak¿e testy oprogramowania i modernizacje
sprzêtu - "je¿eli nie dzia³a, mo¿esz wróciæ, zacz±æ od pocz±tku, a¿ do
uzyskania porz±danego efektu".

<p>
Wystêpuj± jednak sytuacje, w których CARP nie pomo¿e.
Architektura protoko³u CARP wymaga by hosty z grupy nale¿a³y do tej samej
fizycznej podsieci ze statycznym adresem IP, chocia¿ wraz z wprowadzeniem
dyrektywy carpdev, nie istnieje potrzeba by fizyczny interfejs sieciowy
posiada³ adres IP.
Podobnie, us³ugi wymagaj±ce sta³ego po³±czenia z serwerem (takie jak SSH
czy IRC), nie mog± byæ prze¼roczy¶cie przenoszone na inny system, w takiej
sytuacji jednak CARP pomaga zminimalizowaæ czas niedostêpno¶ci.
CARP sam w sobie nie synchronizuje danych pomiêdzy aplikacjami, ta czynno¶æ
jest wykonywana przy u¿yciu "alternatywnych kana³ów" takich jak
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4">pfsync(4)</a>
(dla nadmiarowego filtrowania pakietów), manualnego kopiowania danych
pomiêdzy serwerami przy u¿yciu <a href="http://rsync.samba.org/">rsync</a>,
lub dowolnej innej metody specyficznej dla danej aplikacji.

<h3>6.11.2 - Konfiguracja.</h3>

<p>
Konfiguracja CARP`a tworzona jest przy pomocy dwóch narzêdzi: 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> oraz 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Zacznijmy od sysctl.

<p>
Parametr <tt>net.inet.carp.allow</tt> definiuje czy dany host bêdzie
odbiera³ pakiety przeznaczone dla CARP. Oczywi¶cie, jest to niezbêdne,
aby korzystaæ z CARP. Ta opcja jest domy¶lnie w³±czona.

<p>
Parametr <tt>net.inet.carp.arpbalance</tt> u¿ywany jest do rozk³adania
obci±¿enia. W³±czenie jej powoduje, ¿e CARP zapisuje w tablicach
hash`uj±cych ¼ród³owy adres IP rozg³oszenia.
Klucze tablicy hash`uj±cej jest pó¼niej wykorzystywane do wyboru
wirtualnego hosta z dostêpnej grupy zdolnej by odpowiedzieæ na zapytanie.
Ta opcja jest domy¶lnie wy³±czona.

<p>
Trzeci parametr, <tt>net.inet.carp.log</tt>, aktywuje logowanie b³êdów
w CARP. Opcja domy¶lnie wy³±czona.

<p>
Czwarty arametr, <tt>net.inet.carp.preempt</tt>, aktywuje naturalna
selekcjê w¶ród hostów CARP. Host rozg³aszaj±cy najszybciej staje siê
master'em. Opcja domy¶lnie wy³±czona, co oznacza ¿e system nie bêd±cy
masterem nie bêdzie siê o ten status ubiega³.

<p>
Wszystkie te parametry s± szczegó³owo opisane w 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>.

<p>
Pozosta³± czê¶æ konfiguracji CARP`a wykonujemy z poziomu 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Parametry specyficzne dla CARP <tt>advbase</tt> i
<tt>advskew</tt> dotycz± przedzia³u pomiêdzy rozg³oszeniami CARP.
Warto¶æ (w sekundach) to <tt>advskew</tt> dzielone przez 256,
i ustawione w <tt>advbase</tt>.
Aby ograniczyæ ruch sieciowy, lub zwiêkszyæ opó¼nienie zanim system
zapasowy przejmie zadania u¿ywamy <tt>advbase</tt>.
Polecenie <tt>advskew</tt> pozwala na ustalenie który host bêdzie masterem,
minimalizuj±c opó¼nienie zwi±zane z elekcj±.

<p>
Parametry <tt>pass</tt> i <tt>vhid</tt> ustalaj± odpowiednio has³o i numer
identyfikacyjny grupy CARP. Nale¿y ustawiæ unikalne numery ka¿dej
z grup CARP, nawet je¿eli, ze wzglêdu na rozk³adanie obci±¿enia,
dziel± ten sam adres IP. CARP dopuszcza 255 grup.

<p>
Wreszcie, <tt>carpdev</tt> okre¶la który fizyczny interfejs nale¿y do
okre¶lonej grupy CARP.
Domy¶lnie jakikolwiek interfejs posiada adres IP w tej samej podsieci
przypisanej do CARP, bêdzie on u¿ywany.

<p>
Uwzglêdnijmy wszystkie te informacje w testowej konfiguracji.
Zak³adamy ¿e posiadamy dwa identycznie skonfigurowane serwery WWW:
<i>rachael</i> (192.168.0.5) oraz <i>pris</i> (192.168.0.7),
które maj± zast±piæ stary system o adresie 192.168.0.7.
Zaczynamy:

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>
Pierwsze polecenie tworzy interfejs carp0, drugie ustawia dla tego interfejsu
vhid równe 1, has³o <i>tyrell</i> i adres 192.168.0.7 z netmask± 255.255.255.0.
Przypisanie interfejsu fxp0 jako cz³onka.
By mieæ pewno¶æ, ¿e uzyskamy te ustawienia po restarcie systemu, mo¿emy 
utworzyæ plik <tt>/etc/hostname.carp0</tt> z wpisem:

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell carpdev fxp0
</pre></blockquote>

Zauwa¿my, ¿e adres broadcast jest podany w tej linii jako parametr dodatkowy
obok vhid oraz password.
Niepowodzenie takiego postêpowania powoduje czêste wystepowanie b³êdów,
aczkolwiek jest to niezbêdne jako "place holder".

<p>
Identycznie postêpujemy na serwerze <i>pris</i>. System, który jako
pierwszy podniesie interfejs CARP stanie siê masterem (zak³adaj±c, ¿e
preempt jest wy³±czony; odwrotnie jest to prawd± je¿eli preempt jest 
w³±czony).

<p>
Powiedzmy jednak, ¿e nie stawiasz systemu od zera.
<i>Rachael</i> jest dzia³aj±cym systemem z adresem 192.168.0.7.
Jak sobie z tym poradziæ?
Szczê¶liwie, CARP potrafi sobie radziæ z tak± sytuacj±. Mo¿esz po prostu
przypisaæ adres do interfejsu CARP i pozostawiæ fizyczny interfejs wpisany
w 'carpdev' bez przypisanego adresu IP.  

<p>
Zwiêkszmy poziom skomplikowania, aby <i>rachael</i> stawa³ siê masterem
kiedy tylko bêdzie to mo¿liwe. Takie rz±danie mo¿e byæ uzasadnione kilkoma
czynnikami: ró¿nice sprzêtowe, zwyk³e uprzedzenie ("je¿eli ten system nie
jest masterem, to jest problem"), lub znajomo¶æ domy¶lnego mastera bez
konieczno¶ci okresowego sprawdzania.

<p>
Na systemie <i>rachael</i> u¿yjemy sysctl i wyedytujeny
<tt>/etc/sysctl.conf</tt> by utrwaliæ wprowadzone zmiany:

<blockquote><pre>
rachael# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>
W systemie <i>pris</i>:


<blockquote><pre>
pris# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

<p>
znacznie opó¼ni rozg³aszanie <i>pris</i>`a, czyni±c <i>rachael</i>
masterem kiedy tylko bêdzie dostêpny.

<p>
Zauwa¿my, ¿e u¿ywaj±c PF'a na maszynie z CARP`em musimy przepu¶ciæ
"proto carp" na ka¿dym interfejsie obs³uguj±cym protokó³ CARP,
przy pomocy sk³adni podobnej do:

<blockquote><pre>
pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Rozk³adanie obci±¿enia.</h3>

<p>
Rozwa¿my sytuacjê z poprzedniego przyk³adu za kilka miesiêcy. Nasza firma
rozros³a siê w tym czasie i jeden serwer WWW to po prostu za ma³o.
Co mo¿emy zrobiæ? Mo¿emy u¿yæ CARP'a. Czas wypróbowaæ rozk³adanie
obci±¿enia. Stwórzmy nowy interfejs i grupê CARP na <i>rachael</i>:


<blockquote><pre>
rachael# <b>ifconfig create carp1</b>
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>
Na <i>pris</i>`ie utwórzmy now± grupê i nowy interfejs podobnie,
przy czym ustawiamy "preempt" w sysctl:

<blockquote><pre>
pris# <b>ifconfig carp1 create</b>
pris# <b>ifconfig carp1 vhid 2 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
pris# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>
Teraz mamy dwie grupy CARP na tym samym adresie IP.
Ka¿da grupa jest powi±zana z innym hostem, co oznacza,
¿e <i>rachael</i> wci±¿ pozostaje masterem pocz±tkowej grupy,
lecz <i>pris</i> przejmuje now±. 

<p>
Jedyne co musimy jeszcze
zrobiæ to w³±czyæ rozk³adanie obci±¿enia na obu maszynach:

<blockquote><pre>
# <strong>sysctl net.inet.carp.arpbalance=1</strong>
</pre></blockquote>

<p>
Opisane przyk³ady dotycz± wprawdzie klastra z dwoma maszynami,
nic jednak nie stoi na przeszkodzie by zastosowaæ to do wiêkszej
ich ilo¶ci. Zauwa¿my jednak, ¿e nie nale¿y oczekiwaæ roz³o¿enia
50/50 pomiêdzy maszynami - CARP
korzysta z klucza mieszaj±cego by okre¶liæ który system podejmie siê
odpowiedzi, znacznie bardziej ni¿ opieraj±c siê na aktualnym obci±¿eniu.

<h3>6.11.4 - Wiêcej informacji o CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">Firewall Failover with pfsync and CARP</a> 
autor: Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - Korzystanie z OpenNTPD</h2>

Dok³adny czas jest istotny dla wielu aplikacji.
Jednak¿e, wiele osób twierdzi ¿e ich tanie zegarki za 5$ podaj±
dok³adniejszy czas ni¿ komputer za 2000$. Ponadto, poza wiedz± jaki
jest czas, wa¿na jest  synchronizacja komputerów tak by zgadza³y siê
ze sob± co do tego jaki jest czas.
Jaki¶ czas temu <a href="http://www.ntp.org">ntp.org</a> 
wprowadzi³o zgodn± ze specyfikacj± Network Time
Protocol (<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>) aplikacjê,
dostêpn± poprzez system <a href="faq15.html#Ports">portów</a>, i umo¿liwiaj±c±
synchronizacjê zegarów komputerów poprzez Internet.
Jest to jednak zaawansowany program, z trudnym do audytu kodem, i sporymi
zapotrzebowaniami na pamiêæ operacyjn±. Na krótsz± metê odegra³ wa¿n± rolê
dla wielu ludzi, jednak jest daleki od "rozwi±zania dla wszystkich".

<p>
<a href="http://www.openntpd.org">OpenNTPD</a> usi³uje rozwi±zaæ wiêkszo¶æ
tych problemów, daj±c ³atw± w administracji, bezpieczn± i prost± drogê do
posiadania dok³adnego czasu na w³asnym komputerze.
Dostêpny w OpenBSD demon 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8">ntpd(8)</a>,
posiada ³atwy i przejrzysty plik konfiguracyjny 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"><tt>/etc/ntpd.conf</tt></a>.

<p>
Proste uruchomienie ntpd(8), poprzez <a href="faq10.html#rc">rc.conf.local</a>, spowoduje
powolne dostrajanie zegara twojego komputera a nastêpnie utrzymywanie go zsynchronizowanego 
z jednym z publicznie dostêpnych
serwerów czasu <a href="http://www.pool.ntp.org/">pool.ntp.org</a>.
Gdy ju¿ zegar bêdzie ustawiony, ntpd bêdzie go utrzymywa³ na bardzo niskim
poziomie niedok³adno¶ci, jednak¿e, je¿eli twój zegar jest niedok³adny o wiêcej ni¿
kilka minut jest <i>bardzo</i> zalecane by ustawiæ go pocz±tkowo mo¿liwie dok³adnym, poniewa¿
mo¿e potrwaæ dni lub tygodnie by zsynchronizowaæ bardzo niedok³adny zegar.
Mo¿esz to zrobiæ korzystaj±c z opcji "<tt>-s</tt>" dla ntpd(8) lub innego programu
pozwalaj±cego ustawiæ aktualny czas systemowy.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - "Ale OpenNTPD nie jest tak dok³adny jak demon pochodz±cy z ntp.org!"</h3>
To mo¿e byæ prawd±.
Nie jest to (wiêksza ni¿ ntpd dok³adno¶æ) g³ówne
<a href="http://www.openntpd.org/goals.html">za³o¿enie</a> OpenNTPD,
chodzi³o raczej o stworzenie narzêdzia wolnego, bezpiecznego i prostego.
Je¿eli naprawdê potrzebujesz by twój zegar chodzi³ mikrosekundê dok³adniej
ni¿ to oferuje OpenNTPD, swobodnie u¿ywaj demona ntpd pochodz±cego
z ntp.org, poniewa¿ wci±¿ bêdzie on dostêpny poprzez porty i pakiety.
Nie istnieje ¿aden powód czy te¿ pragnienie by kod OpenNTPD "puch³"
pod±¿aj±c za ka¿d± wymy¶l± funkcjonalno¶ci±.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - "Kto¶ twierdzi ¿e OpenNTPD jest 'szkodliwy'!"</h3>
Niektórzy ludzie mog± nie zrozumieæ za³o¿eñ OpenNTPD -- prostej,
bezpiecznej i ³atwej w zarz±dzaniu drogi do utrzymywania dok³adnego czasu.
 

Je¶li dok³adno¶æ czasu jest istotna, wielu u¿ytkowników zg³asza³o lepsze
rezultaty w stosunku do OpenNTPD ni¿ ntpd z ntp.org.
Je¶li bezpieczeñstwo jest istotne: kod OpenNTPD jest bardziej czytelny
(a co za tym idzie ³atwiejszy w audycie) i napisany w oparciu o natywn±
w OpenBSD funkcjê
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3">strlcpy</a>,
a nie bardziej przeno¶ne funkcje 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3">strcpy</a>.
Ponadto OpenNTPD powsta³ jako bezpieczny od pocz±tku, nie jako "bêdzie
bezpieczny pó¼niej".
Je¶li istnieje wiele osób traktuj±cych synchronizacjê czasu jako warto¶ciow±,
OpenNTPD uczyni to znacznie prostszym dla wielu z niego korzystaj±cych.
Je¶li to jest "szkodliwe", jeste¶my wszyscy za tym.

<p>
Istniej± aplikacje dla których narzêdzie ntpd.org
jest bardziej odpowiednie; jednak¿e odczuwamy, ¿e dla du¿ej liczby
pozosta³ych u¿ytkowników, OpenNTPD jest bardziej ni¿ wystarczaj±cy.

<p>
Bardziej kompletna odpowied¼ na to, pochodz±ca od jednego z maintainerów OpenNTPD, jest
dostêpna
<a href="http://www.advogato.org/person/dtucker/diary.html?start=52">tutaj</a>.

<a name="OpenNTPDNoServe"></a>
<h3>6.12.3 - Dlaczego nie mogê synchronizowaæ innego mojego komputera z OpenNTPD?</h3>

Domy¶lnie ntpd(8) nie nas³uchuje na ¿adnym adresie.
Zatem je¿eli chcesz korzystaæ z niego jako serwera, musisz odkomentowaæ liniê 
"<tt>#listen&nbsp;on&nbsp;*</tt>" w
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5">/etc/ntpd.conf</a>
i zresetowaæ demona ntpd(8).
Oczywi¶cie, je¿eli chcesz by serwer nas³uchiwa³ na konkretnym adresie, a nie na 
wszystkich dostêpnych adresach i interfejsach, zamieñ "*" ¿adanym adresem.

<p>
Gdy masz ju¿ nas³uchuj±cego ntpd(8), mo¿e siê zda¿yæ, ¿e inne maszyny
wci±¿ nie mog± siê z niego synchronizowaæ!

¦wierzo uruchomiony demon ntpd(8) (przyk³adowo, gdy w³a¶nie go restartowa³e¶
po zmianach ntpd.conf) odrzuca po³±czenia innym klientom, a¿ do ustawienia
w³asnego czasu na rozs±dnym poziomie stabilno¶ci.
Gdy ntpd(8) uzna, ¿e jego w³asna informacja o czasie jest stabilna, 
zg³asza to komunikatem "clock now synced" w <tt>/var/log/daemon</tt>.
Nawet je¶li zegar systemowy ju¿ na pocz±tku jest ca³kiem dok³adny, 
mo¿e zaj±æ nawet 10 minut uzyskanie synchronizacji, lub godziny a
nawet dni, gdy jest zupe³nie niedok³adny.

<a name="Wireless"></a>
<h2>6.13 - Jaki wybraæ sprzêt do budowy sieci bezprzewodowych?</h2>
OpenBSD zawiera sterowniki dla wielu uk³adów sieci bezprzewodowej:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">awi(4)</a>
AMD 802.11 PCnet Mobile.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">an(4)</a>
Aironet Communications 4500/4800.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">wi(4)</a>
Prism2/2.5/3. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">atw(4)</a>
ADMtek ADM8211.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4">ath(4)</a>
sterownik dla Atheros IEEE 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4">iwi(4)</a>
Intel PRO/Wireless 2200BG/2225BG/2915ABG IEEE 802.11a/b/g. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4">ipw(4)</a>
Intel PRO/Wireless 2100 IEEE 802.11b. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4">atu(4)</a>
Atmel AT76C50x USB IEEE 802.11b. 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4">ral(4)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4">ural(4)</a> [USB]
Ralink Technology RT25x0 IEEE 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4">rtw(4)</a>
Realtek 8180 IEEE 802.11b. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx&amp;sektion=4">acx(4)</a>
TI ACX100/ACX111. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt&amp;sektion=4">pgt(4)</a>
Conexant/Intersil Prism GT Full-MAC. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum&amp;sektion=4">rum(4)</a>
Ralink Technology RT2501USB. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi&amp;sektion=4">wpi(4)</a>
Intel PRO/Wireless 3945ABG. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath&amp;sektion=4">uath(4)</a>
Atheros AR5005UG/AR5005UX USB2.0 (trwaj± prace). <sup>(NFF)</sup>
</ul>

<sup>(AP)</sup> oznacza, ¿e karta mo¿e byæ u¿yta jako access-point.<br>
<sup>(NFF)</sup> oznacza, ¿e chip wymaga nie-wolnego firmware które nie mo¿e byæ w³±czone
do OpenBSD.
 
</ul>

Urz±dzenia bazuj±ce na tych uk³adach mog± byæ wykorzystywane, w sposób
podobny do pozosta³ych urz±dzeñ sieciowych, do pod³±czenia OpenBSD do 
istniej±cej sieci bezprzewodowej i skonfigurowane przy pomocy
standardowego  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
(wiêcej szczegó³ów w podrêczniku systemowym man).
Niektóre z tych kart mog± byæ wykorzystywane do pracy
w trybie bramki dostêpowej ("Host-Based Access Point"), pozwalaj±c na
integracje z twoim firewall`em.

<p>
Zwracamy uwagê ¿e korzystanie z niektórych z tych kart wymaga pobrania
plików firmware poniewa¿ producenci odmawiaj± 
<a href="faq1.html#ReallyFree">wolnej</a> ich dystrybucji, zatem nie
mog± byæ w³±czone do OpenBSD.
Gdy jest to mo¿liwe strony manuala zawieraj± informacjê o kontakcie do
osobny odpowiedzialnej po stronie producenta, tak aby¶ móg³ im napisaæ
jak siê z tym czujesz, lub by przekazaæ im jaki produkt kupi³e¶ zamiast
ich rozwi±zania.

<p>
Inn± mo¿liwo¶ci± jest wykorzystanie twojego firewall-a OpenBSD
do udostêpniania punktu dostêpowego poprzez standardowe po³±czenie
sieciowe do zewnêtrznego mostkuj±cego Access Point-a.
Ma to t± zaletê, ¿e pozwala na ³atwe umiejscowienie anteny w
najdogodniejszym miejscu, które czêsto nie jest bezpo¶rednio przy
firewall-u.

<a name="Multipath">
<h2>6.14 - Jak mogê zrobiæ routing oparty na wyborze jednej z wielu tras o jednakowym koszcie?</h2>

<p>
Routing oparty na wyborze jednej z tras o jednakowym koszcie (ECMP - Equal Cost Multipath Routing)
pozwala na posiadanie wielu wpisów w tablicy routingu dla tej samej podsieci, przyk³adowo
dla trasy domy¶lnej 0.0.0.0/0.
Gdy kernel przegl±da trasy routingu staraj±c siê okre¶liæ gdzie pos³aæ pakiety przeznaczone do
danej podsieci, mo¿e wybraæ jedn± z wielu tras o równym koszcie.
W wiêkszo¶ci przypadków routing "wielo-¶cie¿kowy" (ang. multipath) wykorzystywany jest
w po³±czeniach wychodz±cych zapewniaj±c redundantne po³±czenia z sieci± Internet.

<p>
Polecenie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>
wykorzystywane jest do dodawania/zmian/kasowania tras w tablicy routingu.
Argument <tt>-mpath</tt> jest u¿ywany w przypadku dodawania ¶cie¿ek multipath.

<blockquote>
<tt>
# route add -mpath default 10.130.128.1<br>
# route add -mpath default 10.132.0.1<br>
</tt>
</blockquote>

<p>
Sprawdzanie tras:

<blockquote>
<pre>
# netstat -rnf inet | grep default
default     10.130.128.1      UGS       2      134      -     fxp1
default     10.132.0.1        UGS       0      172      -     fxp2
</pre>
</blockquote>

W powy¿szym przyk³adzie mo¿emy zobaczyæ jak jedna trasa domy¶lna wskazuje
na 10.130.128.1, który jest osi±galny przez interfejs fxp1, natomiast
druga wskazuje na 10.132.0.1, osiagalny przez interfejs fxp2.

<p>
Poniewa¿ plik
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5">mygate(5)</a>
nie obs³uguje jeszcze tego mechanizmu, poni¿sze linie powinny byæ dodane na koñcu plików
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
dla interfejsów fxp1 i fxp2, natomiast sam <tt>/etc/mygate</tt> powinien zostaæ skasowany.
W ten sposób w³a¶ciwe trasy zostan± zainstalowane podczas startu systemu.

<dl>
<dt><b>/etc/hostname.fxp1</b></dt>
<dd><tt>!route add -mpath default 10.130.128.1</tt></dd>
<dt><b>/etc/hostname.fxp2</b></dt>
<dd><tt>!route add -mpath default 10.132.0.1</tt></dd>
</dl>

<p>
Na koniec nie zapomnij w³±czyæ obs³ugê routingu multipath poprzez w³a¶ciw± 
zmienn± sysctl(3).
Upewnij siê, ¿e zmieni³e¶ to tak¿e w pliku
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>
tak by zmana by³a trwa³a.

<blockquote>
<tt>
# sysctl net.inet.ip.multipath=1<br>
# sysctl net.inet6.ip6.multipath=1
</tt>
</blockquote>

<p>
Spróbuj teraz prze¶ledziæ trasy do ró¿nych celów.
Kernel powinien roz³o¿yæ obci±¿enie pomiêdzy ka¿d±
z tras.

<blockquote>
<pre>
# traceroute -n 154.11.0.4
traceroute to 154.11.0.4 (154.11.0.4), 64 hops max, 60 byte packets
 1  10.130.128.1  19.337 ms  18.194 ms  18.849 ms
 2  154.11.95.170  17.642 ms  18.176 ms  17.731 ms
 3  154.11.5.33  110.486 ms  19.478 ms  100.949 ms
 4  154.11.0.4  32.772 ms  33.534 ms  32.835 ms

# traceroute -n 154.11.0.5
traceroute to 154.11.0.5 (154.11.0.5), 64 hops max, 60 byte packets
 1  10.132.0.1  14.175 ms  14.503 ms  14.58 ms
 2  154.11.95.38  13.664 ms  13.962 ms  13.445 ms
 3  208.38.16.151  13.964 ms  13.347 ms  13.788 ms
 4  154.11.0.5  30.177 ms  30.95 ms  30.593 ms
</pre>
</blockquote>

<p>
Wiêcej informacji na temat sposobu w jaki s± wybierane trasy znajdziesz w
dokumencie
<a href="http://www.ietf.org/rfc/rfc2992.txt">RFC2992</a>, "Analysis of an
Equal-Cost Multi-Path Algorithm"</a>.

<p>
Rozwi±zanie to mo¿e okazaæ siê nic nie warte je¿eli interfejs wykorzystywany
w routinigu wieloscie¿kowym zostanie wy³±czony (np. utracone zostanie po³±czenie),
poniewa¿ kernel wci±¿ bêdzie stara³ siê przekazywaæ pakiety korzystaj±c z trasy
wskazuj±cej na ten interfejs.
Taki ruch bêdzie oczywi¶cie gubiony i ostatecznie nigdzie nie trafi.
Zdecydowanie zalecamy korzystanie z
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated&amp;sektion=8">ifstated(8)</a>
w celu sprawdzania wy³±czonych interfejsów i modyfikacji tablicy routingu.

<p>
<font color="#0000e0">
<a href="index.html">[Spis tre¶ci]</a>
<a href="faq5.html">[Sekcja 5 - Tworzenie systemu ze ¼róde³]</a>
<a href="faq7.html">[Sekcja 7 - Ustawienia klawiatury i wy¶wietlania]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[wstecz]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.249 ]<br>
$Translation: faq6.html,v 1.51 2006/11/10 19:09:17 tkniaz Exp $<br>
-->
$OpenBSD: faq6.html,v 1.45 2006/11/12 16:09:22 jufi Exp $
</small>

</body>
</html>
