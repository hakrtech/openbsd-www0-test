<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Sieæ</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color="#0000e0">
<a href="index.html">[Spis Tre¶ci]</a>
<a href="faq5.html">[Sekcja 5 - Konfiguracja j±dra i dysków]</a>
<a href="faq7.html">[Sekcja 7 - Ustawienia klawiatury i wy¶wietlania]</a>
</font>


<h1><font color="#e00000">6 - Sieæ</font></h1>
<hr>

<p>
<h3>Spis Tre¶ci</h3>
<ul>
<li><a href= "#Intro" >6.0.1 - Wprowadzenie</a>
<li><a href= "#Setup" >6.1 - Inicjalizacja sieci</a>
<li><a href= "#PF"    >6.2 - Filtr pakietów (Packet Filter - PF)</a>
<li><a href= "#NAT"   >6.3 - Translacja adresów sieciowych (Network Address Translation)</a>
<li><a href= "#DHCP"  >6.4 - Konfiguracja DHCP</a>
<li><a href= "#PPP"   >6.5 - Protokó³ PPP</a>
<li><a href= "#Tuning">6.6 - Tuning parametrów sieciowych</a>
<li><a href= "#NFS"   >6.7 - Korzystanie z NFS</a>
<li><a href= "#DNS"   >6.8 - Us³ugi rozwi±zywania nazw - DNS, BIND i named</a>
<li><a href= "#PPTP"  >6.9 - Konfiguracja po³±czenia PPTP</a>
<li><a href= "#Bridge">6.10 - Konfiguracja bridge`a w OpenBSD</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<a name="6.0.1"></a>
<h2>6.0.1 - Wprowadzenie</h2>

<p>
Dla zrozumienia wiêkszo¶ci z tego dokumentu, zalecane jest zapoznanie siê
i zrozumienie sekcji 5 FAQ <a href="faq5.html">konfiguracja i instalacja j±dra</a>, 
dzia³ania narzêdzi
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> oraz
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> na podstawie odpowiadaj±cych im stron manuala.

<p>
Je¶li administrujesz sieci± i zajmujesz siê konfiguracj± protoko³ów rutowania
u¿ywaj±c do tego celu maszyny z OpenBSD jako rutera i chcesz zag³êbiæ siê
bardziej w sieci IP, powiniene¶ przeczytaæ poni¿szy znakomity dokument 
<a href="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">Understanding
IP Addressing</a>.
Dokument ten zawiera fundamentalne informacje na temat sieci IP, jest przydatny 
zw³aszcza gdy opiekujesz siê wieloma sieciami.

<p>
Je¶li zajmujesz siê administrowaniem takimi us³ugami jak serwery www,
ftp czy te¿ pocztowymi mo¿esz dowiedzieæ siê wielu interesuj±cych rzeczy
o ich dzia³aniu czytaj±c odpowiednie
<a href="http://the.rfceditor.org/rfc.html">dokumenty RFC</a>
opisuj±ce szczegó³owo protoko³y oraz dzia³anie tych us³ug.
Oczywi¶cie nie przeczytasz ich wszystkich - zajmij siê tymi, którymi
jeste¶ najbardziej zainteresowany lub których u¿ywasz w swojej sieci. Dokumenty
RFC definiuj± tysi±ce standardów opisuj±cych protoko³y sieciowe, 
ich dzia³anie oraz sposób w jaki powinne zostaæ realizowane.

<p>
<a name="Setup"></a>
<a name="6.1"></a>
<h2>6.1 - Inicjalizacja Sieci</h2>

<p>
<a name="Setup.1"></a>
<a name="6.1.1"></a>
<h3>6.1.1 - Identyfikacja i konfiguracja interfejsów sieciowych</h3>

<p>
Aby zacz±æ musisz zidentyfikowaæ swoje interfejsy sieciowe. W OpenBSD nazywane
s± one wed³ug typu sterownika a nie typu po³±czenia (jak ma to miejsce np. w 
Linuksie). Mo¿esz zobaczyæ w jaki sposób system wykry³ Twoj± kartê podczas 
procesu uruchamiania lub pó¼niej korzystaj±c z polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>.
Aktualn± konfiguracjê interfejsów sieciowych mo¿esz zobaczyæ przy pomocy 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Dla przyk³adu, oto co wy¶wietlone zosta³o przez komendê dmesg w przypadku karty sieciowej
Intel Fast Ethernet, u¿ywaj±cej nazwy fxp.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Je¶li nie wiesz jak nazywa siê Twoje urz±dzenie sieciowe przej¿yj 
<a href="../../plat.html">listê urz±dzeñ wspieranych przez OpenBSD</a> dla odpowiedniej platformy.
Znajdziesz tam spis wielu popularnych kart sieciowych oraz odpowiedniki
ich nazw w OpenBSD. Pe³na nazwa urz±dzenia w systemie sk³ada siê z tego
w³a¶nie synonimu (jak fxp) oraz numeru przyznanego urz±dzeniu przez j±dro systemu 
(np. fxp0).

<p>
Sprawdzenia jakie interfejsy sieciowe zosta³y zidentyfikowane przez system
mo¿esz dokonaæ korzystaj±c z narzêdzia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Poni¿sza komenda wy¶wietli wszystkie interfejsy w systemie. W tym przyk³adzie
widaæ tylko jeden fizyczny interfejs ethernetowy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.
</p>

<blockquote><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008<LOOPBACK,MULTICAST> mtu 33224
fxp0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 192.168.1.35 netmask 0xffffff00 broadcast 192.168.1.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0<> mtu 33224
pfsync0: flags=0<> mtu 2020
sl0: flags=c010<POINTOPOINT,LINK2,MULTICAST> mtu 296
sl1: flags=c010<POINTOPOINT,LINK2,MULTICAST> mtu 296
ppp0: flags=8010<POINTOPOINT,MULTICAST> mtu 1500
ppp1: flags=8010<POINTOPOINT,MULTICAST> mtu 1500
tun0: flags=10<POINTOPOINT> mtu 3000
tun1: flags=10<POINTOPOINT> mtu 3000
enc0: flags=0<> mtu 1536
bridge0: flags=0<> mtu 1500
bridge1: flags=0<> mtu 1500
vlan0: flags=0<> mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0<> mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010<POINTOPOINT,LINK0,MULTICAST> mtu 1450
gif0: flags=8010<POINTOPOINT,MULTICAST> mtu 1280
gif1: flags=8010<POINTOPOINT,MULTICAST> mtu 1280
gif2: flags=8010<POINTOPOINT,MULTICAST> mtu 1280
gif3: flags=8010<POINTOPOINT,MULTICAST> mtu 1280

</pre></blockquote>

<p>
Jak widzisz,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
dostarcza nam wielu u¿ytecznych w tym momencie informacji, miêdzy
innymi widaæ tutaj interfejs, który w powy¿szym przyk³adzie jest ju¿ skonfigurowany.
Oczywistym jest ¿e sieæ IP dostêpna jest poprzez interfejs fxp0, st±d
warto¶ci &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;.  
Ponadto flagi <strong>UP</strong> i <strong>RUNNING</strong> s± ustawione.

<p>
Oprócz fxp0 widoczne s± równie¿ domy¶lnie udostêpnione inne interfejsy.
S± to urz±dzenia wirtualne pe³ni±ce w systemie rozmaite funkcje.
Ich szczegó³owy opis znajdziesz na stronach manuala:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - interfejs pêtli zwrotnej (Loopback Interface) 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4&amp;manpath=OpenBSD+3.3">pflog</a>
 - interfejs logowania filtra pakietów (Packet Filter Logging Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - interfejs szeregowego ³±cza IP (SLIP)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - interfejs protoko³u PPP (Point to Point Protocol)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - programowy interfejs tunelu (Tunnel Network Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - opakowuj±cy pseudointerfejs pêtli zwrotnej (Encapsulating Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
 - interfejs bridge`a ethernetowego (Ethernet Bridge Interface)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - interfejs sieci wirtualnych budowanych na urz±dzeniach zgodnych z IEEE 802.1Q 
 <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - interfejs tunelu IP korzystaj±cy z protoko³ów GRE/MobileIP
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - interfejs tunelu IPv4/IPv6 (Generic IPv4/IPv6 Tunnel Interface)
</ul>

<p>
Je¶li Twój interfejs sieciowy nie jest skonfigurowany, pierwszym co powiniene¶ zrobiæ,
jest stworzenie pliku <i>/etc/hostname.xxx</i>. W miejsce xxx umie¶æ nazwê interfejsu
którego dany plik ma dotyczyæ. Dla powy¿szego przyk³adu, plik ten powinien mieæ
nazwê <i>/etc/hostname.fxp0</i>. Sk³adnia pliku jest prosta:<br>

<blockquote><pre>
address_family address netmask broadcast [other options]
</pre></blockquote>

(Znaczenie oraz wiêcej szczegó³ów odno¶nie formatu tego pliku znajdziesz w manualu pod
has³em
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>.)

<p>
Typowy plik interfejsu sieciowego skonfigurowanego do wspó³pracy z adresami IPv4
mo¿e wygl±daæ nastêpuj±co:

<blockquote><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
Wprowadzaj±c dodatkowe opcje mo¿esz skonfigurowaæ typ Ethernetu i dla przyk³adu:
je¶li chcesz aby karta pracowa³a w trybie 100baseTX full-duplex, plik konfiguracyjny
bêdzie wygl±da³ nastêpuj±co:

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
Oczywi¶cie nie powiniene¶ nigdy ustawiaæ trybu z którym nie potrafi wspó³pacowaæ
drugi koniec po³±czenia. Je¶li nie ma ku temu wyra¼nych powodów nie jest zalecane 
stosowanie dodatkowych opcji ustalaj±cych tryb pracy.

<p>
Mo¿esz zauwa¿yæ, ¿e w przypadku konfigurowania ró¿nych typów interfejsów
i przypisywania im specyficznych dla nich opcji format pliku pozostaje niemal identyczny!

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
Nastêpnym krokiem jest ustalenie domy¶lnej bramki (trasy rutowania). 
Jedyne co musisz zrobiæ to umie¶ciæ adres IP swojej bramki w pliku
<i>/etc/mygate</i>. Dziêki temu Twój system bêdzie poinformowany 
o bramie domy¶lnej przy ka¿dorazowym uruchamianiu. Teraz kolej na 
ustalenie serweów nazw i edycjê pliku <i>/etc/hosts</i> (zobacz
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)</a>). 
Do poinformowania systemu z których serwerów nazw powinien korzystaæ,
musisz stworzyæ (o ile jeszcze nie istnieje) plik <i>/etc/resolv.conf</i>. 
Wiêcej na temat formatu tego pliku mo¿esz dowiedzieæ siê ze stony manuala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>. 
Poni¿ej zamieszczony zosta³ przyk³ad dla standardowych przypadków u¿ycia,
zak³adamy w nim, ¿e serwery nazw maj± adresy 125.2.3.4 i 125.2.3.5 
oraz nale¿ysz do domeny &quot;example.com&quot;.

<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
W tej chwili, aby zainicjowaæ sieæ na swojej konfiguracji mo¿esz uruchomiæ
ponownie komputer, b±d¼ uruchomiæ skrypt <strong>/etc/netstart</strong>. 
Mo¿esz to zrobiæ w prosty sposób (jako u¿ytkownik root):

<blockquote><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Zauwa¿ ¿e uruchomienie skryptu spowodowa³o wyst±pienie kilku b³êdów.
Jest to spowodowane zainicjalizowaniem rekonfiguracji systemu ju¿
skonfigurowanego. Dla przyk³adu, niektóre trasy rutowania istnia³y ju¿
w tablicy rutingu j±dra. Od tej chwili obs³uga sieci w Twoim systemie powinna byæ ju¿
skonfigurowana. Aby upewniæ siê ¿e wszystkie interfejsy zosta³y skonfigurowane
tak jak planowa³e¶ pos³u¿ siê narzêdziem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Trasy rutowania mo¿esz obejrzeæ korzystaj±c z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>
lub <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>.
Je¶li masz problemy z routingiem, mo¿esz skorzystaæ z flagi -n programu
route(8), która drukuje adresy IP, zamiast wykonywaæ wyszkukiwania DNS
i wy¶wietlaæ nazwy.
Poni¿ej znajduj± siê przyk³ady u¿ycia obu tych narzêdzi.

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.2"></a>
<a name="6.1.2"></a>
<h3>6.1.2 - Konfiguracja komputera z OpenBSD jako rutera</h3>

<p>
Poni¿ej zamieszczone s± podstawowe informacje z którymi powiniene¶ zapoznaæ
siê, chc±c skonfigurowaæ maszynê z OpenBSD jako bramkê (ruter). Je¶li komputer
ma stanowiæ bramkê do Internetu, zalecane jest przeczytanie instrukcji 
dotycz±cych konfiguracji filtra pakietów (Packet Filter) aby móc blokowaæ
potencjalnie niebezpieczny ruch. Ponadto, bior±c pod uwagê niewielk±
przestrzeñ adresów 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a>
przydzielan± przez dostawców us³ug internetowych mo¿esz zechcieæ skorzystaæ
z informacji o translacji adresów sieciowych (NAT - Network Address Translation)
aby rozs±dniej wykorzystaæ przyznan± Ci pulê adresów IP.

<p>
Standardowe (GENERIC) j±dro ma mo¿liwo¶æ przekazywania pakietów IP (IP Forwarding),
do dzia³ania, wymaga ono jednak inicjalizacji. Powiniene¶ do tego celu skorzystaæ z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.
Aby maszyna zawsze startowa³a z w³±czonym przekazywaniem pakietów powiniene¶ wyedytowaæ
plik <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a>
Jedyne co musisz zrobiæ, to dodaæ poni¿sz± linijkê do tego pliku.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Aby uzyskaæ ten efekt bez restartu maszyny, mo¿esz skorzystaæ bezpo¶rednio
z narzêdzia <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
Pamiêtaj, ¿e po ponownym uruchomieniu komputera, je¶li nie wyedytujesz pliku 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a>
jak zosta³o to pokazane powy¿ej, zmiana ta nie bêdzie obowi±zywaæ. Do wykonania poni¿szej
komendy musisz mieæ uprawnienia root`a.

<blockquote><pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
Teraz jedyne co Ci pozostaje to ustawienie tras rutingu na hostach po obu
stronach Twojego rutera. Istnieje wiele mo¿liwo¶ci wykorzystania OpenBSD
jako rutera korzystaj±c z takich narzêdzi jak
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>,
i <a href="http://www.zebra.org">zebra</a>. OpenBSD wspiera oprogramowanie
takie jak zebra, gated czy mrtd poprzez system portów. Potrafi tak¿e wspó³pracowaæ
z rozmaitymi interfejsami takimi jak T1, HSSI, ATM, FDDI, Ethernet oraz po³±czeniami
poprzez linie szeregowe (PPP/SLIP).

<p>
<a name="Setup.3"></a>
<a name="6.1.3"></a>
<h3>6.1.3 - Ustawianie aliasów na interfejsach sieciowych</h3>

<p>
OpenBSD posiada prosty mechanizm nadawania aliasów IP na interfejsy. 
Jedyne co musisz zrobiæ, to odpowiednio wyedytowaæ plik
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>.
Plik ten, z informacjami o konfiguracji interfejsu, jest czytany
w momencie uruchamiania siê systemu przez skrypt
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a>,
który jest elementem procedury startowej (<a href="../faq10.html#rc">rc startup
hierarchy</a>). Dla przyk³adu zak³adamy, ¿e u¿ytkownik posiada interfejs
<b>dc0</b> i znajduje siê w sieci 192.168.0.0. Pozosta³e istotne 
informacje:

<ul>
<li>adres IP: 192.168.0.2
<li>maska sieciowa (NETMASK): 255.255.255.0
</ul>

<p>
Kilka uwag na temat aliasów. W OpenBSD u¿ywasz tylko jednej nazwy
interfejsu. Nie ma w tym przypadku ¿adnej ró¿nicy pomiêdzy pomiêdzy
pierwszym a drugim aliasem. W przeciwieñstwie do innych systemów operacyjnych
OpenBSD nie odnosi siê do kolejnych aliasów kolejno je numeruj±c,
jak np.: dc0:0, dc0:1. Je¶li odnosisz siê do konkretnego 'aliasowanego'
adresu IP poprzez ifconfig, lub dodajesz alias, b±d¼ uwa¿ny i pamiêtaj
o sk³adni "<tt>ifconfig int alias</tt>" zamiast "<tt>ifconfig int</tt>".
Dowolny alias mo¿esz usun±æ poleceniem "<tt>ifconfig int delete</tt>".

<p>
Zak³adaj±c ¿e u¿ywasz wielu adresów IP które nale¿± do tej samej 
podsieci jako aliasy, maska sieciowa dla ka¿dego z nich przyjmuje
warto¶æ 255.255.255.255. Nie musissz powielaæ w ka¿dym przypadku 
maski pierwszego adresu IP przypisanego do interfejsu. W poni¿szym
przyk³adzie, plik <i>/etc/hostname.dc0</i>, zawiera definicje dwóch 
aliasów do interfejsu dc0 skonfigurowanego pocz±tkowo jako
192.168.0.2 z mask± 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Po wyedytowaniu pliku, jedyne co musisz zrobiæ to uruchomiæ ponownie
komputer, aby wprowadziæ powy¿sze zmiany w konfiguracji. Naturalnie, mo¿esz
tak¿e nadaæ aliasy rêcznie, bez potrzeby restartowania systemu, u¿ywaj±c
narzêdzia <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>. 
Do uaktywnienia pierwszego aliasu z powy¿szego przyk³adu powiniene¶ 
pos³u¿yæ siê komend±:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
Do wy¶wietlenia aliasów skorzystaj z polecenia:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="6.2"></a>
<a name="PF"></a>
<h2>6.2 - Filtr pakietów (Packet Filter - PF)</h2>
<!-- XXXrelease -->

<p>
Filtr pakietów jest podsystemem stworzonym do dwóch g³ównych zadañ,
przekazywania pakietów na podstawie okre¶lonych praw i regu³ oraz mapowania
adresów hostów/podsieci na adresy zewnêtrzne. Plikiem konfiguracyjnym dla 
wszystkich tych us³ug jest
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf(5)</a></i>. 
 
 <p>
(Uwaga: w OpenBSD 3.0 i 3.1 istnia³ dodatkowy plik konfiguracyjny,
<i>/etc/nat.conf</i>.
Jego funkcje s± obecnie przeniesione do <i>/etc/pf.conf</i>.)

<p>
Nowy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><i>/etc/pf.conf</i></a>
sk³ada siê z czterech czê¶ci:

<ul>
<li><b>Opcje:</b> Rozmaite opcje okre¶laj±ce w jaki sposób PF ma dzia³aæ.
<li><b>Normalizacja (Scrub):</b> Przetwarzanie przes³anych pakietów w celu
ich normalizacji i dostosowania do standardów.
<li><b><a href="#NAT">Translacja zdresów (NAT) i regu³y przekierowuj±ce:</a></b> 
NAT pozwala na dostêp do Internetu wielu komputerom, wykorzystuj±c 
do tego jeden adres IP. Dziêki przekierowaniom, mo¿na przekazaæ ruch
do innych maszyn znajduj±cych siê za NAT`em.
<li><b>Regu³y filtruj±ce:</b> Zezwalaj± na selektywne filtrowanie lub
blokowanie pakietów pojawiaj±cych siê na którymkolwiek z interfejsów.
</ul>

Nie jest wymagane istnienie ka¿dej z tych sekcji, jednak te które wystêpuj±,
powinny pojawiæ siê w wymienionej kolejno¶ci.

<p>
Po pierwsze, aby zacz±æ pracowaæ z filtrem pakietów, musisz wyedytowaæ plik
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
dodaj±c w nim wiersz:

<blockquote><pre>
pf=YES
</pre></blockquote>

<p>
Je¶li zamierzasz korzystaæ z NAT, zapewne zechcesz przy pomocy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
warto¶æ <tt>net.inet.ip.forwarding</tt> na 1, aby umo¿liwiæ przekazywanie
pakietów. Mo¿esz zrobiæ to tak¿e poprzez odkomentowanie b±d¼ edytowanie odpowiedniej
linijki w pliku
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a></i>
oraz ponowne uruchomienie maszyny.

<p>
Je¶li masz filtr pakietów wkompilowany w j±dro, ale nie jest on jeszcze
uaktywniony w pliku 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
mo¿esz w³±czyæ go bezpo¶rednio bez konieczno¶ci ponownego uruchamiania systemu
dziêki poleceniu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.3">pfctl(8)</a>.

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

<p>
Pierwszy z powy¿szych wierszy ustala odpowiednie regu³y filtrowania oraz NAT
na podstawie <i>/etc/pf.conf</i> natomiast kolejny aktywuje Twoj filtr pakietów.

<p>
Mo¿na to zrobiæ zgrabniej w jednej komendzie:

<blockquote><pre>
# <strong>pfctl -f /etc/pf.conf -e</strong>
</pre></blockquote>

<p>
Je¶li dokona³e¶ zmian w <i>/etc/pf.conf</i> po wystartowaniu filtra pakietów,
mo¿esz prze³adowaæ aktualn± konfiguracjê na now± w prosty sposób:

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
</pre></blockquote>

<p>
Poni¿szy dokument ods³oni kilka podstawowych mo¿liwo¶ci konfiguracji
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf(5)</a>.
Mo¿esz tak¿e przyj¿eæ siê wynikowemu
<a href="#sample_pf.conf">zestawowi regu³</a> który zawiera wszystkie elementy
konfiguracji poruszane poni¿ej. Dodatkowe informacje na temat filtra pakietów
mo¿esz znale¼æ na jego oficjalnej stronie
<a href="http://www.benzedrine.cx/pf.html">Packet Filter web site</a> 
oraz w nastêpuj±cym HOWTO
<a href="http://www.inebriated.demon.nl/pf-howto/">Packet Filter HOWTO</a>. 

<p>
<h3>Filtr pakietów (Packet Filter - PF)</h3>

<p>
Jak zosta³o to ju¿ powiedziane powy¿ej, aby uaktywniæ PF przy starcie systemu,
musisz ustawiæ w pliku <i>/etc/rc.conf</i> warto¶æ zmiennej <tt>pf=YES</tt>.  
Filtr pakietów kontrolowany jest przez plik konfiguracyjny <i>/etc/pf.conf</i>, 
wczytywany przy starcie systemu. Szczegó³owe wyja¶nienia tego tematu znajdziesz
na stronach manuala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf(5)</a>. 
W poni¿szym przyk³adzie <tt>fxp0</tt> reprezentuje zewnêtrzny interfejs pod³±czony
do internetu. Regu³ki które zaraz zobaczysz zak³adaj± ci±g³e pod³±czenie do
internetu tak jak ma to miejsce w przypadku np. serwera www.

<p>
Regu³y PF przetwarzane s± sekwencyjnie z góry w kierunku do³u, pomaga
to w wizualizacji faktu ¿e ka¿dy pakiet przechodzi przez kolejne regu³ki
zanim osi±gnie swój cel.

<p>
Dla przyk³adu, domy¶lny zestaw regu³ zezwala wszystkim pakietom na zarówno
opuszczanie systemu jak i przybywanie do niego:

<blockquote><pre>
pass out all 
pass in all
</pre></blockquote>

<p>
Jest to skrót dla:

<blockquote><pre>
pass in from any to any
pass out from any to any
</pre></blockquote>

<p>
co mo¿emy odczytaæ jako &quot;przepu¶æ wszystkie przychodz±ce pakiety
pochodz±ce z jakiegokolwiek ¼ród³a i zmierzaj±ce do jakiegokolwiek celu&quot;,
dodatkowo zak³adane jest &quot;przez jakikolwiek interfejs (co zak³adane jest
zawsze gdy nie wyszczególnimy interfejsu jawnie) dla jakiejkolwiek rodziny
adresów
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&amp;sektion=4">inet (v4)</a> lub <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&amp;sektion=4">inet6 (v6)</a>&quot;.

<p>
Naturalnie w takiej konfiguracji nie jest to ¿aden filtr :-). Bardziej u¿yteczne
regu³y bazuj± na rodzinie adresów (IPv4, IPv6), protokole oraz numerze
portu us³ugi któr± zamierzasz filtrowaæ. Do twozenia regu³ wykorzystaæ
mo¿esz ka¿dy z protoko³ów znajduj±cych siê w 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5">/etc/protocols(5)</a></i>
wyra¿aj±c go jako nazwê b±d¼ numer. W tej chwili skoncentrujemy siê na 
najpopularniejszych protoko³ach
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4">tcp(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4">udp(4)</a> oraz
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4">icmp(4)</a>.

<p>
Do dzie³a, powiedzmy ¿e nie chcemy zezwalaæ na ¿adne po³±czenia IPv4 do
portu 3306 warstwy TCP (MySQL), poniewa¿ baza danych powinna byæ 
dostêpna tylko z lokalnego hosta. Nasz zbiór regu³ek powinien wygl±daæ
nastêpuj±co:

<blockquote><pre>
pass out all
pass in all
block in on fxp0 inet proto tcp from any to any port 3306
</pre></blockquote>

<p>
Co oznacza &quot;zablokuj wszystkie przychodz±ce pakiety IPv4 pochodz±ce
z jakiegokolwiek ¼ród³a przeznaczone do jakiegokolwiek celu pod port TCP 3306&quot;.
Zauwa¿ ¿e w przypadku gdy regu³a filtruj±ca opiera siê na porównaniu 
numeru portu, musisz jawnie sprecyzowaæ jakiego protoko³u warstwy transportowej 
ma dotyczyæ a tak¿e zaleca siê podanie rodziny adresów.
Dla us³ug zdefiniowanych w pliku 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5">/etc/services(5)</a>
mo¿esz stosowaæ ich nazwy symboliczne zamiast numerów portów, jak dla przyk³adu
<em>www</em> lub <em>mysql</em>.

Pakiet adresowany do portu 3306 wchodz±cy poprzez interfejs <tt>fxp0</tt>
po przej¶ciu przez pierwsz± regu³kê &quot;pass in&quot; zostanie oznaczony jako
pakiet do przepuszczenia, natomiast regu³ka &quot;block in port 3306&quot; spowoduje
zaznaczenie pakietu jako przeznaczonego do odrzucenia. Je¶li odwrócisz kolejno¶æ
tych regu³:

<blockquote><pre>
pass out all
block in on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
wtedy pakiet przeznaczony do portu 3306 TCP zostanie przepuszczony, poniewa¿ 
ostatnia regu³ka do której pakiet pasuje pozwala mu przej¶æ. Bardzo wa¿ene
jest aby¶ przy tworzeniu swojego filtra pamiêta³ o zasadzie:
<b>Ostatnia pasuj±ca regu³ka decyduje</b>.

<p>
Oczywi¶cie od ka¿dej zasady s± wyj±tki. S³owo kluczowe <em>quick</em> 
pozwala na wykonanie danej akcji na pakiecie natychmiast po napotkaniu
regu³ki do której pasuje. Spójrzmy na zmodyfikowany powy¿szy przyk³ad,
co stanie siê gdy dodamy <em>quick</em> do regu³y $quot;block in&quot;:

<blockquote><pre>
pass out all
block in quick on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
Pakiet przeznaczony do portu 3306 TCP bêdzie pasowa³ do regu³ki 
&quot;block in quick&quot; i dziêki temu s³owu kluczowemu zostanie
natychmiast odrzucony. Wszystkie pakiety przeznaczone do innych 
portów lub protoko³ów bêd± dalej przetwarzane dopóki nie dotr±
regu³ki &quot;pass in&quot; do której bêd± pasowaæ i która zezwoli
im na przej¶cie.

<p>
<b>Domy¶lne odrzucanie pakietów.</b>
<p>
Najbezpieczniejsza polityka filtrowania powinna mówiæ o domy¶lnym
odrzucaniu pakietów, zgodnie z zasad± mówi±c± ¿e ka¿dy ruch który nie jest 
dozwolony jest zabroniony. Taka polityka jest znacznie bezpieczniejsza 
ni¿ polegaj±ca na kolejnym zabranianiu dostêpu do kolejnych strze¿onych us³ug,
powoduje znaczne zmniejszenie liczby regu³ek oraz chroni przed przypadkowo 
opuszczonymi konfiguracjami regu³ek dla us³ug staj±cymi siê w ten sposób
dostêpnymi bez ograniczeñ.

<p>
Spójrzmy na kolejny przyk³adowy zestaw regu³ek oraz spróbujmy go wyja¶niæ
wiersz po wierszu. Mamy tutaj przypadek serwera www z domy¶ln± polityk±
odrzucania pakietów, zezwala siê jedynie na po³±czenia ssh (dla administracji)
oraz po³±czenia http (port 80) i https (port 443).

<blockquote><pre>
block in on fxp0 all
pass  in on fxp0 inet proto tcp from any to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 all
</pre></blockquote>

<p>
Powy¿sze regu³ki przepuszczaj± ruch przychodz±cy z jakiegokolwiek
¼ród³a do portów 22 (ssh), 80 (http) oraz 443 (https) warstwy TCP.
Wszystkie inne próby po³±czeñ przychodz±cych zostan± odrzucone,
natomiast przepuszczamy ca³y ruch wychodz±cy.
To ca³kiem szczelny zestaw regu³ek, ale co w przypadku gdy chcemy
zezwoliæ na po³±czenie ssh tylko z hostów sieci wewnêtrznej o adresie
1.1.1.0, natomiast ruch http i https powinien byæ dostêpny z ka¿dego
miejsca ? Oto rozwi±zanie:

<blockquote><pre>
block in on fxp0 all
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 all
</pre></blockquote>

<p>
Ca³kiem nie¼le, a jak wygl±da³yby regu³ki gdyby¶my chcieli zezwoliæ
tylko jednemu komputerowi (o adresie 1.1.1.1) na zdalne administrowanie 
systemem ? W takim przypadku zmienimy regu³kê:

<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>

<p>
na nastêpuj±c±:

<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
</pre></blockquote>

<p>
<b>Przyk³adowe regu³ki</b>
<p>
Poni¿ej znajdziesz kilka dobrych dla ka¿dego regu³ek (oczywi¶cie zak³adaj±c
¿e interfejs fxp0 jest pod³±czony do sieci zewnêtrznej np. internetu). Po
pierwsze zapewnimy prost± ochronê przed podszywaniem siê pod adresy IP (spoofing).
Poni¿sze adresy niepowinny (normalnie) pojawiaæ siê w Internecie, wiêc je¶li
nasz filtr pakietów je zobaczy naka¿emu mu aby odrzuca³ po³±czenia z tych
adresów.

<blockquote><pre>
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
Teraz nasz zestaw zaczyna wygl±daæ porz±dniej, gdy zbierzemy wszystko w ca³o¶æ
bêdzie to wygl±daæ nastêpuj±co:

<blockquote><pre>
# nie zezwalaj na podszywanie siê pod nieprawid³owe dla Internetu adresy
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# zezwalaj na po³±czenia ssh tylko z komputera administratora
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22

# oraz wszystkim na po³±czenia http i https 
pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443

# domy¶ln± akcj± dla wszystkich innych po³±czeñ przychodz±cych jest ich odrzucenie
block in quick on fxp0 from any to any

# natomiast zezwalamy na wszystkie po³±czenia wychodz±ce
pass out on fxp0 from any to any
</pre></blockquote>

<p>
<b>Logowanie pakietów</b>
<p>
Jest nie¼le, ale mog³oby byæ jeszcze lepiej. Co zrobiæ aby wszystkie nieudane
próby po³±czenia z portem 22 (ssh) zosta³y zalogowane ? S³u¿y do tego s³owo
kluczowe <em>log</em>:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
block in log quick on fxp0 inet proto tcp from any to any port 22
</pre></blockquote>

<p>
Pierwsza regu³ka zezwoli na po³±czenie z komputera administratora pod port 22,
druga  odrzuci i zaloguje wszystkie inne próby po³±czeñ.

<p>
Logowane pakiety przesy³ane s± do interfejsu pflog0, który monitorowany jest
przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">pflogd(8)</a>,
zwykle loguj±cy pakiety do <i>/var/log/pflog</i> w binarnym formacie 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8&amp;manpath=OpenBSD+3.3">tcpdump(8)</a>
pflogd(8) uruchamiany jest domy¶lnie przez
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a></i>
je¶li pf jest w³±czony w
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>.
Pliki z logami mo¿esz przeczytaæ korzystaj±c z poni¿szej komendy:

<blockquote><pre>
# <b>tcpdump -n -e -ttt -r /var/log/pflog</b>
</pre></blockquote>

<p>
Jedna przestroga - u¿ywaj±c tcpdump`a do przegl±dania plików pflog
pamiêtaj ¿e NIE S¡ one wy¶wietlane w czasie rzeczywistym (mechanizm buforowania).
Je¶li oczekujesz pracy w czasie rzeczywistym musisz skorzystaæ z tego
polecenia:

<blockquote><pre>
# <b>tcpdump -i pflog0</b>
</pre></blockquote>

<p>
Mo¿esz tak¿e skorzystaæ ze sk³adni tcpdump`a dla zawê¿enia wy¶wietlanych
wyników aby zwiêkszyæ ich czytelno¶æ:

<blockquote><pre>
# <b>tcpdump -e -i pflog0 port 80</b>
</pre></blockquote>

<p>
Takie dzia³anie NIE wp³ywa na to co zostanie zapisane w pliku
<i>/var/log/pflog</i>.  

<p>
Podczas analizowania logów, uwagê nale¿y zwracaæ na szczegó³owe dekodowanie 
protoko³ów przez tcpdump (tryb verbose aktywowany opcj± -v). Dekoder 
tcpdump`a nie ma zbyt chwalebnej przesz³o¶ci je¶li chodzi o bezpieczeñstwo.
Przynajmniej teoretycznie mo¿liwe jest przeprowadzenie opó¼nionego ataku
poprzez wysy³anie pakietów maj±cych zostaæ zalogowanymi.

<p>
Dodatkowa uwaga powinna byæ zwrócona na dostêp do tych logów. Pflogd przechwytuje
96 bajtów pakietu i loguje je. Dostêp do takich zalogowanych informacji 
mo¿e umo¿liwiæ niepowo³anym osobom dostêp do maszyny poprzez analizê
protoko³ów oraz logowañ poprzez 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&amp;sektion=1">telnet(1)</a> lub
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>).

<p>
<b>Logowanie pakietów przez syslog</b>
<p>
W wielu przypadkach dobrze jest mieæ logi naszej ¶ciany ogniowej
w formacie ASCII i/lub przes³aæ je do serwera loguj±cego. Zadania te mog±
byæ za³atwione przez 2 proste skrypty pow³oki z minimalnymi smianami 
w plikach konfiguracyjnych OpenBSD.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">Syslogd(8)</a>
jest standardowym demonem odpowiedzialnym za logowanie, przechowuje pliki
z logami w formacie ASCII oraz umo¿liwia wysy³anie ich do zdalnego serwera.

<p>
Pierwsze co musimy zrobiæ to utworzenie u¿ytkownika <em>pflogger</em> bez
dostêpu do pow³oki (.nologin. shell). Najpro¶ciej zrobiæ to poleceniem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8&amp;manpath=OpenBSD+3.3">adduser(8)</a>.

<p>
Po dodaniu u¿ytkownika <em>pflogger</em> nale¿y stworzyæ dwa mastêpuj±ce skrypty:

<p>
<i>/etc/pflogrotate</i>

<blockquote><pre>
FILE=/home/pflogger/pflog5min.$(date "+%Y%m%d%H%M")
kill -ALRM $(cat /var/run/pflogd.pid)
if [ $(ls -l /var/log/pflog | cut -d " " -f 8) -gt 24 ]; then
        mv /var/log/pflog $FILE
        chown pflogger $FILE
        kill -HUP $(cat /var/run/pflogd.pid)
fi
</pre></blockquote>


<p>
<i>/home/pflogger/pfl2sysl</i>

<blockquote><pre>
#!/bin/sh
# feed rotated pflog file(s) to syslog
for logfile in /home/pflogger/pflog5min* ; do
        tcpdump -n -e -ttt -r $logfile | logger -t pf -p local0.info
        rm $logfile
done
</pre></blockquote>

<p>
Wyedytowaæ crontab u¿ytkownika <em>root</em>

<blockquote><pre>
# <b>crontab -u root -e</b>
</pre></blockquote>

<p>
poprzez dodanie dwóch poni¿szych linii:

<blockquote><pre>
# rotate pf log file every 5 minutes
0-59/5 *       *       *       *       /bin/sh /etc/pflogrotate
</pre></blockquote>

<p>
Nastêpnym krokiem jest stworzenie crontab`a dla u¿ytkownika <em>pflogger</em>

<blockquote><pre>
# <b>crontab -u pflogger -e</b>
</pre></blockquote>

<p>
oraz dodanie do niego linii:

<blockquote><pre>
# feed rotated pflog file(s) to syslog
0-59/5 *       *       *       *       /bin/sh /home/pflogger/pfl2sysl
</pre></blockquote>

<p>
Teraz dodaj do pliku <i>/etc/syslog.conf</i> wiersz:

<blockquote><pre>
local0.info    /var/log/pflog.txt
</pre></blockquote>

<p>
Je¶li chcesz przechowywaæ logi na zdalnym serwerze, dodaj równie¿ poni¿sz±
linijkê:

<blockquote><pre>
local0.info    @syslogger
</pre></blockquote>

<p>
i upewnij siê ¿e host <i>syslogger</i> jest zdefiniowany w pliku
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5&amp;manpath=OpenBSD+3.3">
/etc/hosts(5)</a>.

<p>
Teraz wszystkie zalogowane pakiety przes³ane zostaj± do <i>/var/log/pflog.txt</i>.
Je¶li doda³e¶ te¿ informacje o zdalnym logowaniu na ho¶cie <i>syslogger</i> to 
syslogd wykona równie¿ i to zadanie.

<p>
<i>/etc/pflogrotate</i> przetwarza i kasuje <i>/var/log/pflog</i>
wiêc rotacja <i>pflog</i> przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newsyslog&amp;sektion=8&amp;manpath=OpenBSD+3.3">
newsyslogd(8)</a> nie jest nam d³u¿ej potrzebne i mo¿e zostaæ wy³±czona.
Jednak¿e <i>/var/log/pflog.txt</i> zastêpuje <i>/var/log/pflog</i> i jego rotacja
powinna byæ aktywna.
Zmieñ <i>/etc/newsyslog.conf</i> jak poni¿ej:

<blockquote><pre>
#/var/log/pflog        600     3       250     *       ZB      /var/run/pflogd.pid
/var/log/pflog.txt     600     7       *       24
</pre></blockquote>

<p>
W tej chwili PF bêdzie zostawiaæ logi w formacie ASCII w pliku /var/log/pflog.txt
oraz na zdalnym serwerze je¶li jest takie zadanie w pliku  <em>/etc/syslog.conf</em>.
Logowanie nie jest natychmiastowe, mo¿e up³yn±æ ok. 5 - 6 minut (interwa³ cron`a)
zanim zalogowane pakiety zaczn± pojawiaæ siê w pliku.

<p>
<b>Ró¿ne protoko³y</b>
<p>
W jaki sposób zezwoliæ na ustanawianie po³±czeñ do us³ug wykorzystuj±cych 
wiele protoko³ów, jak dla przyk³adu bind, który korzysta zarówno z TCP
jak i UDP ? Filtr pakietów zezwala na ³±czenie ze sob± parametrów w zbiory
(wiêcej na ten temat znajdziesz dalej):

<blockquote><pre>
# przepu¶æ zapytania DNS dla BIND`a
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

<p>
Zwróæ uwagê na spacje po obu stronach '{ }'. To elegantszy sposób
zapisu ni¿ alternatywny którego móg³by¶ u¿yæ:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from any to any port 53
pass in quick on fxp0 inet proto udp from any to any port 53
</pre></blockquote>

<p>
<a name="normalization"></a>
<b> Normalizacja Pakietów</b>
<p> 
Normalizacja pakietów oznacza ponowne przetwarzanie nag³ówków pakietów 
pofragmentowanych oraz usuwanie nieprawid³owo¶ci z opcji IP. Niektóre systemy 
operacyjne maj± problemy z niew³a¶ciwie pofragmentowanymi pakietami i 
generalnie jest to dobry pomys³ aby mieæ znormalizowane pakiety przed 
przetwarzaniem ich przez regu³ki filtruj±ce oraz przed przes³aniem
ich do hostów docelowych.
Do normalizacji s³u¿y s³ówko kluczowe <b>scrub</b> u¿ywane tak jak poni¿ej:

<blockquote><pre>
scrub in all
</pre></blockquote>

<p>
Powoduje to niewielkie zwiêkszenie wykorzystania zasobów systemowych oraz
wymaga wiêcej pamiêci aby móc buforowaæ pofragmentowane pakiety. Zaleca
siê stosowanie normalizacji, poniewa¿ zazwyczj jej warto¶æ jest zwykle
wiêksza ni¿ koszty które siê za ni± p³aci.

<p>
<b>Opcje IP</b>
<p>
Domy¶lnie PF blokuje pakiety z ustawionymi opcjami IP. Dziêki temu mo¿na
utrudniæ, przeznaczonym do tego programom takim jak nmap, wykrywanie systemu 
operacyjnego na zdalnym ho¶cie (&quot;OS fingerprinting&quot;).  
Je¶li korzystasz z programów wymagaj±cych takich pakietów do poprawnej pracy,
np. wykorzystuj±cych multicasting lub IGMP, mo¿esz u¿yæ dyrektywy 
<b>allow-opts</b>:

<blockquote><pre>
pass in quick on fxp0 all allow-opts
</pre></blockquote>

<p>
<b>Flagi TCP, po³±czenia nawi±zane oraz utrzymywanie stanu</b>
<p>
Filtr pakietów potrafi tak¿e analizowaæ flagi TCP oraz specjalnie
obs³ugiwaæ po³±czenia nawi±zane oraz stan po³±czeñ. Zalecane jest
aby u¿ytkownicy którzy zamierzaj± filtrowaæ pakiety na podstawie
flag TCP rozumieli jak± odgrywaja one rolê. Dla przyk³adu, je¶li
chcia³by¶ zablokowaæ pakiety z ustawionymi flagami FIN, URG i PSH
(np. aby utrudniæ wykrycie systemu operacyjnego takim narzêdziom 
jak nmap) mo¿esz u¿yæ poni¿szej regu³ki:

<blockquote><pre>
block in quick on fxp0 inet proto tcp from any to any flags FUP/FUP
</pre></blockquote>

<p>
(Dziêki <a href="mailto:halogen@nol.net">Kyle Hargraves</a> za podpowied¼)

<p>
Nastêpn± interesuj±c± mo¿liwo¶ci± udostêpnian± przez PF jest umiejêtno¶æ
utrzymywania stanu po³±czeñ. Dziêki temu, je¶li dane po³±czenie
przejdzie przez fazê inicjalizacyjn± i zostanie ustanowione,
pakiety nale¿±ce do tego po³±czenia nie bêd± ju¿ przechodziæ 
przez regu³y filtruj±ce. To potê¿ny mechanizm znacznie upraszczaj±cy
tworzenie skutecznej i bezpiecznej zapory ogniowej.

<p>
Spójrzmy na przyk³ad który obrazuje jak PF akceptuje nawi±zane
po³±czenia na podstawie rozpoznanego stanu. W przyk³adzie
zezwalamy na dostêp do ssh (port 22) z naszej sieci klasy C
oraz dostêp zarówno z zewn±trz jak i od wewn±trz do portu 80 (http)
oraz 443 (https). Ka¿dy inny ruch zostaje zablokowany. Zastanówmy
siê co nale¿a³oby zrobiæ w przypadku gdybym chcia³ dla przyk³adu
skorzystaæ z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>
i nawi±zaæ po³±czenie na zewn±trz z naszego sewrera www, lub
przegl±darki 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&amp;sektion=1">lynx(1)</a> 
aby poszukaæ czego¶ w FAQ? W powy¿szych przyk³adach by³oby to niemo¿liwe,
poniewa¿ zablokowali¶my wszystkie pakiety przychodz±ce z zewn±trz
za wyj±tkiem tych które przeznaczone s± do wyszczególnionych przez
nas portów naszych serwerów. Skorzystamy z najbezpieczniejszej
metody rozwi±zania naszego problemu. Poprzez dodanie s³ów kluczowych
<em>keep state</em> do regu³ki &quot;pass out&quot;, automatycznie
zezwolimy na wej¶cie pakietom przychodz±cym w odpowiedzi na po³±czenia
które zainicjowali¶my, jak dla przyk³adu gdy korzystamy z przegl±darki
stron www. Pamiêtaj, do utrzymywania stanu musisz wyspecyfikowaæ 
protokó³ którego regu³ka ma dotyczyæ.

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 keep state
pass  out on fxp0 inet proto tcp all keep state
</pre></blockquote>

<p>
Ta ma³a zmiana znacznie zwiêkszy elastyczno¶æ oraz bezpieczeñstwo
naszego zestawu regu³ek: dla wyja¶nienia, w powy¿szych regu³kach
zezwalamy na ruch TCP do portu 80 &amp; 443. Mo¿emy zaostrzyæ 
regu³ki odpowiadaj±ce za to nawet bardziej. Aby po³±czenie TCP
zosta³o poprawnie zainicjowane, musimy zezwoliæ tylko na przej¶cie
pierwszego pakietu rozpoczynaj±cego trójfazowe ustanawianie 
po³±czenia; nastêpnie mo¿emy zablokowaæ inny ruch przeznaczony do tego
portu oraz zezwolic naszej regu³ce utrzymuj±cej stan (&quot;keep state
&quot;) aby opiekowa³a siê pakietami nale¿acymi do tego ustanawiaj±cego
sie po³±czenia. Aby umo¿liwiæ poprawne nawi±zanie po³±czenia TCP
mo¿emy przepuszczaæ jedynie pakiety z ustawion± flag± SYN oraz
wyzerowana flag± ACK. Przez przepuszczanie tylko tych pakietów,
zabezpieczymy siê przed ró¿nymi formami skanowania portów jak np. 
skanowanie pakietami z flag± FIN (FIN ssanning). Flagi S/SA oznaczaj±:
z flag S (SYN) i A (ACK) tylko SYN musi byæ ustawiona. Inne nie s± brane
pod uwagê. Nasze regu³ki wygl±daj± teraz jak poni¿ej:

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 \
	flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 \
	flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 \
	flags S/SA keep state
block out on fxp0 inet proto tcp all
pass  out on fxp0 inet proto tcp all flags S/SA keep state
</pre></blockquote>

<p>
Spróbujmy teraz po³±czyæ wszystkie nasze dotychczasowe regu³ki
w jeden zestaw. Jest on przeznaczony dla protoko³u IPv4, ma domy¶ln±
polityke odrzucania pakietów, zezwala na po³±czenia ssh tylko 
z sieci wewnêtrznej oraz na nawi±zywanie po³±czeñ zarówno
z zewn±trz jak i wewn±trz do portów 80 (http) i 443 (https).
Nasz zestaw zapewnia tak¿e ochronê przed podszywaniem siê pod 
nierutowalne adresy IP oraz odk³ada pakiety które s± zbyt pofragmentowane
aby je przetwarzaæ. Oto jak móg³by wygl±daæ <i>/etc/pf.conf</i>:

<blockquote><pre>
# Wyczy¶æ oraz znormalizuj pofragmentowane i niestandardowe pakiety
scrub in all

# nie zezwalaj na podszywanie siê pod nierutowalne adresy
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }


# domy¶lnie blokujemy wszystkie przychodz±ce pakiety za wyj±tkiem 
# tych na które jawnie zezwalamy w naszych regu³kach
block in on fxp0 all

# zezwalamy wszystkim na ustanawianie po³±czeñ http i https
pass in on fxp0 inet proto tcp from any to any port 80 \
	flags S/SA keep state
pass in on fxp0 inet proto tcp from any to any port 443 \
	flags S/SA keep state

# oraz zezwalamy pakietom na opuszczanie naszej maszyny, jednocze¶nie
# przechowuj±c informacje o stanie po³±czeñ protoko³ów TCP, UDP i ICMP
# tak aby pakiety nale¿±ce do inicjowanego przez nas po³±czenia by³y
# automagicznie akceptowane - np odpowiedzi na nasze zapytania DNS
# przesy³ane protoko³em UDP
block out on fxp0                 all
pass  out on fxp0 inet proto tcp  all flags S/SA keep state
pass  out on fxp0 inet proto udp  all            keep state
pass  out on fxp0 inet proto icmp all            keep state
</pre></blockquote>

<p>
Teraz nasz <i>pf.conf</i> wygl±da ca³kiem przyzwoicie, ale mo¿emy
zrobiæ kilka rzeczy aby ³atwiej by³o wprowadzaæ zmiany i zarz±dzaæ
naszym PF w przysz³o¶ci.

<p>
<b>Zbiory</b>
<p>
Dziêki zbiorom, tworzenie regu³ek jest prostsze i przejrzystsze.
Dla przyk³adu, chcemy zaakceptowaæ ruch przeznaczony do us³ugi
pracuj±cej w kilku protoko³ach, jak BIND korzystaj±cy z TCP i UDP,
oto przyk³ad rozwi±zania:

<blockquote><pre>
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

<p>
Zauwa¿ spacje które znajduj± siê po obu stronach '{ }'.

<p>
Grupy adresów IP mog± byæ ³±czone razem w zestawy, które mog± byæ
u¿yte wszêdzie tam gdzie mog³y byæ u¿yte pojedyncze adresy IP.
Przeanalizuj nastêpuj±cy przyk³ad:

<blockquote><pre>
# zablokuj mo¿liwo¶æ podszywania siê pod nierutowalne adresy
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
<b>Zmienne</b>
<p>
Problemem w powy¿szym pliku <i>pf.conf</i> jest to, ¿e gdyby¶ zechcia³ 
zmieniæ swój interfejs sieciowy lub jeden z adresówm IP musia³by¶
wprowadziæ te zemiany we wszystkich linijkach w których s± wystêpuj±
zmieniane przez Ciebie warto¶ci. W takich przypadkach porêcznie jest
skorzystaæ ze zmiennych:

<blockquote><pre>
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
ExtIF="fxp0"
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
</pre></blockquote>

<p>
<a name="sample_pf.conf"></a>
<b>Sk³adamy wszystko w ca³o¶æ</b>
<p>
Spróbujmy po³±czyæ wszystkie nasze dotychczasowe regu³ki i omawiane
rozwi±zania w jeden plik:

<blockquote><pre>
# definicje u¿ywanych zmiennych
ExtIF="fxp0"              # interfejs zewnêtrzny
IntNet="1.1.1.0/24"       # nasza sieæ wewnêtrzna
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
Services="{ www, https }"

# porz±dkowanie pofragmentowanych i niestandardowych pakietów
scrub in all

# zabezpieczenie przed próbami podszywania siê pod nierutowalne adresy
block in  quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs

# domy¶lnie wszystke wej¶ciowe pakiety s± blokowane za wyj±tkiem
# tych którym pozwolimy na przej¶cie poni¿ej
block in on $ExtIF all

# zezwalamy na korzystanie z http i https
pass  in on $ExtIF inet proto tcp from any to any port $Services \
	flags S/SA keep state

# oraz wypuszczamy na zewn±trz ruch utrzymuj±c stan nawi±zanych po³±czeñ
# wypuszczamy wszystkie protoko³y, TCP, UDP i ICMP, zapamiêtujemy tak¿e
# stan po³±czeñ tak, ¿e zewnêtrzny serwer DNS mo¿e odpowiedzieæ na nasze
# zapytanie (protokó³ UDP)
block out on $ExtIF                 all
pass  out on $ExtIF inet proto tcp  all flags S/SA keep state
pass  out on $ExtIF inet proto udp  all            keep state
pass  out on $ExtIF inet proto icmp all            keep state
</pre></blockquote>

<p>
Je¶li zauwa¿asz jakie¶ problemy, mo¿esz zechcieæ logowaæ pakiety
pasuj±ce do wybranych regu³ek:

<blockquote><pre>
pass in log quick on fxp0 proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">pflogd(8)</a> zaloguje pakiety do <i>/var/log/pflog</i>.
Pamiêtaj ¿e <i>/var/log/pflog</i> jest plikiem binarnym i czytany byæ mo¿e przez<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8&amp;manpath=OpenBSD+3.3">tcpdump(8)</a>.

<p>
Je¶li zmieniasz co¶ w swojej konfiguracji PF nie zapomnij skorzystaæ z
<b>pfctl -R /etc/pf.conf</b> aby PF wiedzia³ o poczynionych przez Ciebie 
modyfikacjach.

<a name="6.3"></a>
<a name="NAT"></a>
<h2>6.3 - NAT</h2>

<p>
<h4>Uwaga: W OpenBSD 3.2 i pó¼niejszych, regu³ki dotycz±ce NAT przechowywane
s± w pliku <i>/etc/pf.conf</i>, a nie oddzielnym <i>/etc/nat.conf</i>
jak OpenBSD 3.0 i 3.1</h4>

<p>
<a name="nat1.0"></a>
<h3><u>6.3.1 Wprowadzenie do NAT</u></h3>

<a name="nat1.1"></a>

<p>
Na podstawie 
<a href="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, 
NAT umo¿liwia ³atwe mapowanie wewnêtrznych sieci do pojedynczego
rutowalnego ("rzeczywistego") adresu internetowego. To bardzo
u¿yteczne w przypadku gdy nie masz oficjalnie przyznanego adresu IP
dla ka¿dego z hostów znajduj±ych siê w Twojej wewnêtrznej sieci.
Gdy konfigurujesz swoj± wewnêtrzn± sieæ mo¿esz skorzystaæ do tego z 
zarezerwowanych bloków adresów (opis w
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), 
jak np.:

<p>
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)

<p>
Zak³adamy ¿e posiadasz zainstalowane i skonfigurowane OpenBSD
na komputerze z dwoma kartami sieciowymi z których jedna pod³±czona
jest do Internetu, a druga do sieci wewnêtrznej.

<p>
<a name="nat1.3"></a>
<b>Konfiguracja</b>

<p>
Je¶li Twój system jest skonfigurowany jak opisane to zosta³o powy¿ej,
mo¿emy zabraæ siê do roboty. Gdy Twoja konfiguracja ró¿ni siê od
powy¿szej b±d¼ ostro¿ny wprowadzaj±c swoje zmiany w taki sposób
aby system zachowywa³ siê tak jak tego oczekujesz.

<blockquote>
<b>Urz±dzenia sieciowe: </b>
<pre>
Intel EtherExpress Pro/100 <b>fxp0</b>
pod³±czona do zewnêtrznej sieci LAN (lub WAN)
<b>Adres IP: </b>24.5.0.5
<b>Maska sieciowa: </b>255.255.255.0

Compaq Netelligent 10/100Mb <b>tl0</b>
pod³±czona do sieci wewnêtrznej
<b>Adres IP: </b>192.168.1.1
<b>Maska sieciowa: </b>255.255.255.0
</pre>
</blockquote>

<blockquote>
<b>Konfiguracja dostêpu do Internetu (dostarczona przez Twojego dostawcê
Internetu, w tym przypadku urz±dzeniem dostêpowym jest  modem kablowy)<br></b>
<pre>
<b>Adres IP: </b>24.5.0.5
<b>Maska sieciowa: </b>255.255.255.0
<b>Bramka: </b>24.5.0.1
</pre>
</blockquote>

<blockquote>
<b>Sieæ lokalna (LAN)</b><br>
W tym przyk³adowym ¶rodowisku, komputery w sieci wewnêtrznej korzystaj±
z adresów IP w postaci 192.168.1.xxx (gdzie xxx to unikatowy numer).
W seci mog± znajdowaæ siê rozmaite systemu operacyjne jak Windows 98,
WIndows NT, OpenBSD, Linux, jednak rodzaj systemu operacyjnego klientów
nie wp³ywa na dzia³anie NAT. Dla przyk³adu, klient w sieci wewnêtrznej 
mo¿e mieæ przypisany adres 192.168.1.40.
</blockquote>

<blockquote>
<b>Diagram of Configuration</b>
<pre>
+-----+              +---------+          +----------+
| Hub |--------- tl0 |   NAT   | fxp0 ----| Internet |
+-----+              +---------+          +----------+
| |
| +-- Klient A
+---- Inni 

		      +--------------------------+
		      |          LEGENDA         |
		      +--------------------------+
		      |  NIC fxp0 - 24.5.0.5     |
		      |  NIC tl0  - 192.168.1.1  |
		      | Klient A  - 192.168.1.40 |
		      +--------------------------+

</pre>
</blockquote>

<p>
<a name="nat2.0"></a>
<h3><u>6.3.2 Translacja adresów sieciowych (Network Address Translation - NAT)</u></h3>

<p>
<a name="nat2.1"></a>
<b>Wprowadzenie do NAT</b>

<p>
Ka¿dy element Internetu wymaga posiadanie unikatowego adresu IP.
W wersji czwartej protoko³u IP (IPv4) liczba adresów jest do¶æ
mocno ograniczona. Wiêkszo¶æ "tanich" dostawców Internetu dostarcza
niewielk± pulê 1 - 30 adresów dla swoich klientów. Wiêksze organizacje
mog³yby zechcieæ korzystaæ zwiêkszej puli adersów, aby móc przypisaæ
je ka¿demu komputerowi z osobna, co prawdê mówi±c daje niewiele korzy¶ci, 
a zmniejsza bezpieczeñstwo i integralno¶æ ca³ej sieci.

<p>
Translacja adresów sieciowych (Network Address Translation - NAT,
znana tak¿e jako maskowanie IP (&quot;IP Masquerading&quot;) 
w Linuksie) zezwala na dostêp do Internetu wielu komputerom 
umieszczonym za jednym (lub kilkoma) adresami IP. Ka¿dy z komputerów
ma przypisany indywidualny, niezarejestrowany  adres IP w sieci 
wewnêtrznej, (<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), 
natomiast wszystkie korzystaj± z tego samego, zewnêtrznego adresu IP
jednocze¶nie.

<p>
Sposób w jaki pracuje NAT jest prosty. Gdy klient z sieci LAN zechce
po³±czyæ siê z komputerem poprzez Internet, wysy³a pakiet TCP z
¿±daniem po³±czenia. Wewn±trz nag³ówka TCP (a w³a¶ciwie IP) znajduje siê
adres IP klienta (np. 192.168.1.40) i adres hosta do którego pakiet ma
dotrzeæ (np. 123.45.67.89). Komputer który wykonuje NAT przechwytuje
pakiet TCP klienta i zmienia jego adres IP z 192.168.1.40 na adres IP
interfejsu pod³±czonego do Internetu (np. 24.5.0.5). Tyle wystarczy
aby zmyliæ komputer docelowy, bêdzie on uwa¿a³ ¿e po³±czenie pochodzi 
od komputera wykonu±cego NAT a nie w³a¶ciwej maszyny wysy³aj±cej
¿±danie. Wysy³a on nastêpnie potwierdzenie do komputera z NAT, który
nastêpnie rozpoznaje odpowied¼, szybko zmienia adres docelowy z 
w³asnego na adres IP swojego klienta i wysy³a pakiet. Klient
nie wie dok³adnie w jaki sposób wygl±da wymiana pakietów, wszystkie
te operacje s± przezroczyste dla ka¿dej aplikacji pracuj±cej na 
komputerze klienta.

<p>
Poni¿szy przyk³ad mo¿e conieco rozja¶niæ:

<blockquote><pre>
Klient ----------------- tl0 [ NAT ] fxp0 ---------- Host w Internecie
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

WYCHODZ¡CY Pakiet TCP                     WYCHODZ¡CY Pakiet TCP
Od: 192.168.1.40  &gt;&gt;=== NAT ===&gt;&gt;  Od: 24.5.0.5
Do: 123.45.67.89                           Do: 123.45.67.89

PRZYCHODZ¡CY Pakiet TCP                  PRZYCHODZ¡CY Pakiet TCP
Od: 123.45.67.89 			Od: 123.45.67.89
Do:   192.168.1.40  &lt;&lt;=== NAT ===&lt;&lt;     Do: 24.5.0.5
</pre></blockquote>

<p>
<a name="nat2.2"></a>
<b>Dlaczego chcia³by¶ u¿ywaæ NAT?</b>

<p>
W przyk³adzie z modemem kablowym pojawi³ siê jeszcze jeden problem.
W jaki sposób udostêpniæ dostêp do Internetu dla moich wspó³lokatorów
gdy modem znajduje siê w moim pokoju? Jest kilka rozwi±zañ które mog³em
zastosowaæ, takie jak uzyskanie wiêkszej ilo¶ci adresów IP, konfiguracja
serwera proxy lub konfiguracja NAT. (Nie my¶l ¿e przyk³ad z modemem
kablowym jest dziecinny, NAT jest na tyle potê¿ny aby maskowaæ ogromne 
sieci z setkami a nawet tysi±cami pracuj±cymi w nich komputerów!)

<p>
Jest naprawdê wiele powodów dla których chcia³em wykorzystaæ do tego
NAT. Pierwszym z nich jest oszczêdno¶æ pieniêdzy. Mieszkam z dwoma
wspó³lokatorami i perspektywa dzielenia kosztów dostêpu do Internetu 
jest do¶æ atrakcyjna.
Id±c dalej, ka¿dy z wspó³lokatorów ma swój PC, ja mam trzy, co daje
piêæ komputerów, natomiast nasz dostawca Internetu dostarczy³
tylko trzy adersy IP. Oznacza to, ¿e nie ma wystarczaj±cej ilo¶ci
adresów aby umo¿liwiæ wszystkim komputerom jednoczesny dostêp
do Internetu.

<p>
Dziêki NAT ka¿da maszyna mo¿e mieæ unikatowy adres IP w sieci 
wewnêtrznej oraz wspó³dzieliæ jeden zewnêtrzny adres IP przyznany
przez naszego dostawcê. 

<p>
<a name="nat2.4"></a>
<b>Inicjalizacja</b>

<p>
Aby udostêpniæ NAT na komputerze z OpenBSD musisz uruchomiæ PF (Packet
Filter). Mo¿esz to zrobiæ w ³atwy sposób edytuj±c pliki wyszczególnione
poni¿ej:

<p>
<b>/etc/rc.conf</b> (ten plik u¿ywany jest do startowania us³ug 
podczas uruchamiania komputera)

<blockquote><pre>
pf=YES<br>
</pre></blockquote>

<p>
<b>/etc/sysctl.conf</b>

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Po tych zmianach komputer jest gotowy do konfiguracji NAT.

<p>
<a name="nat2.5"></a>
<b>Konfiguracja</b>

<p>
Pierwszym krokiem jest edycja pliku konfiguracyjnego PF
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf</a></i>).
Dla potrzeby tego dokumentu zezwolimy na przepuszczanie przez
firewall ca³ego ruchu wychodz±cego oraz przychodz±cego na ka¿dym
z interfejsów. Plik powinien wygl±daæ w ten sposób:

<blockquote><pre>
pass in all
pass out all
</pre></blockquote>

<p>
Wiêcej informacji mo¿esz znale¼æ w podrozdziale <a href="#PF">Filtr pakietów FAQ 6</a>

<p>
Regu³ki odpowiadaj±ce za NAT w pliku konfiguracynym 
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf</a></i>)
maj± bardzo prost± sk³adniê. Dla konfiguracji przedstawionej 
powy¿ej, plik powinien zawieraæ taki wpis:

<blockquote><pre>
nat on fxp0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
</pre></blockquote>

<p>
A oto wyja¶nienie powy¿szej linijki.

<dl>
<dt>"nat"
<dd>To oznacza ¿e dodajesz regu³kê NAT.
</dl>

<dl>
<dt>"fxp0"
<dd>Interfejs sieciowy który pod³±czony jest do Internetu.
</dl>

<dl>
<dt>"192.168.1.0/24"
<dd>Adres IP oraz maska (maska sieciowa w formacie CIDR). Razem
oznacza to ¿e "ka¿dy adres IP o zakresie od 192.168.1.1 do 192.168.1.254
" powinien zostaæ zmapowany (zamaskowany).
</dl>

<dl>
<dt>"24.5.0.5"
<dd>Zewnêtrzny adres IP na który mapowane (zmieniane) bêd± adresy IP
sieci wewnêtrznej.
</dl>

(od t³umacza: pamiêtaj ¿e regu³ki NAT powinny znale¼æ siê w pliku przed regu³kami
filtruj±cymi)

<p>
<a name="nat2.6"></a>
<b>Uruchamianie</b>

<p>
Teraz, gdy konfiguracja jest zakoñczona istniej± dwa sposoby aby 
uruchomiæ NAT. Pierwszym z nich (i najlepszym) jest ponowne uruchomienie
komputera. Mo¿esz to zrobiæ komend± "<i>reboot</i>". 

<p>
Je¶li chcia³by¶ uruchomiæ NAT bez restartu mo¿esz skorzystaæ z 
poni¿szych poleceñ:

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

<p>
Pierwsza linijka ³aduje zestaw regu³ek NAT do filtra pakietów PF (oraz
czy¶ci istniej±ce regu³ki), druga uruchamia PF. Jeszcze raz, restart
systemu jest najlepsz± metod± na to aby przekonaæ siê ¿e po ponownym
uruchomieniu wszystko dzia³a tak jak tego siê spodziewa³e¶.

<p>
<b>Uwaga:</b> aby prze³adowaæ ustawienia NAT (gdy edytujesz plik, ale
nie chcesz ponownego uruchamiania systemu) poprostu skorzystaj
jeszcze raz z pierwszej komendy. Aktualne ustawienia zostan± usuniête
oraz za³adowane ¶wie¿e.

<p>
<a name="nat3.0"></a>
<h3><u>6.3.3 NAT - podstawowe informacje</u></h3>

<p>
<a name="nat3.1"></a>
<b>Sprawdzanie stanu NAT</b>

<p>
Aby dowiedzieæ siê w jaki sposób pracuje teraz NAT lub aby upewniæ
siê ¿e zmiany w konfiguracji zasz³y tak jak zamierza³e¶, skorzystaj
z opcji "-ss". Dziêki niej wy¶wietlone zostan± wszystkie sesje które
obs³uguje w tej chwili NAT:

<blockquote><pre>
# pfctl -ss
TCP  192.168.1.40:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.40:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.40:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
</pre></blockquote>

<p>
Wyja¶nienie (pierwszej linijki, pozosta³e s± podobne):

<dl>
<dt>"192.168.1.40:2132"
<dd>To adres IP komputera w nieci LAN który u¿ywa NAT (192.168.1.40).
Widoczny jest równie¿ numer portu z którego pochodzi po³±czenie (2132).
</dl>

<dl>
<dt>"24.5.0.5:53136"
<dd>Po³±czenie trafia do Internetu poprzez adres 24.5.0.5 i u¿ywa portu
53136.
</dl>

<dl>
<dt>"65.42.33.245:22"
<dd>Adres IP drugiego koñca po³±czenia.
</dl>

<dl>
<dt>"TIME_WAIT:TIME_WAIT"
<dd>Stan po³±czenia TCP rozpoznany przez PF.
</dl>

<p>
<a name="nat3.2"></a>
<b>Wspó³praca NAT i FTP</b>

<p>
Korzystaj±c z NAT nale¿y mieæ na uwadze kilka ograniczeñ, najczê¶ciej
spotykanym jest to zwi±zane z FTP. Mo¿esz korzystaæ z FTP w dwojaki
sposób, u¿ywaj±c trybu pasywnego lub aktywnego. Z tej dwójki, pasywny
uwa¿any jest ogólnie za bezpieczniejszy.

<p>
W trybie aktywnym, gdy u¿ytkowniki pod³±cza siê do zdalnego serwera
FTP i wysy³a ¿±danie informacji lub pliku, klient FTP wysy³a do 
serwera losowy numer portu do którego ma pod³±czyæ siê serwer 
i wykonaæ do niego transfer danych. Jest to problem dla u¿ytkowników
chc±cych korzystaæ ze swojej sieci LAN z zewnêtrznego serwera FTP.
Gdy serwer FTP chce wys³aæ dane, próbuje nawi±zaæ po³±czenie do 
zewnêtrznego interfejsu pod losowy port. Maszyna która wykonuje NAT
odbiera pakiet inicjuj±cy po³±czenie, ale poniewa¿ nic nie wie o tym
po³±czeniu (wie o nim klient z sieci LAN) odrzuca pakiet i niedorêcza
go pod w³a¶ciwy adres.

<p>
W trybie pasywnym FTP (domy¶lnym w kliencie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
w OpenBSD), to klient ¿±da aby serwer wybra³ losowy numer portu i na nim
oczekiwa³ na po³±czenie i transfer danych klienta. Serwer informuje
klienta o numerze portu który wybra³, klient ³±czy siê ze wskazanym 
portem i nastêpuje transfer danych. Niestety nie zawzse jest to mo¿liwe.
ftp(1) u¿ywa tego trybu domy¶lnie; aby wymusiæ aktywny tryb FTP, 
skorzystaj z flagi -A, lub u¿yj komendy 

<blockquote><pre>
passive off
</pre></blockquote>

<p>
po znaku zachêty ftp&gt;

<p>
Filtr pakietów dostarcza pewne rozwi±zanie dla takiej sytuacji, 
przekierowuj±c ruch FTP przez serwer proxy FTP, proces ten "prowadzi"
Twój ruch FTP przez filtr. FTP proxy u¿ywany w OpenBSD i przez PF to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.3">ftp-proxy(8)</a>.
Aby go aktywowaæ, dodaj linijkê analogiczn± do poni¿szej w swoim 
pliku <i>/etc/pf.conf</i>:

<blockquote><pre>
rdr on tl0 proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>

<p>
Krótkie wyja¶nienie tej linijki, "ruch do portu TCP 21 na wewnêtrznym
interfejsie jest przekierowany do serwera proxy uruchomionego na tej
maszynie nas³uchuj±cego na porcie 8021".

<p>
Oczywi¶cie, serwer proxy musi byæ uruchomiony, dokonuje siê zwykle tego
poprzez dodanie poni¿szej linijki w pliku <i>/etc/inetd.conf</i>:

<blockquote><pre>
127.0.0.1:8021 stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
</pre></blockquote>

<p>
oraz ponowne uruchomienie komputera, lub wys³anie sygna³u 'HUP' do 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>.
Jedn± z komend którymi mo¿na wys³aæ sygna³ 'HUP' jest:

<blockquote><pre>
kill -HUP `cat /var/run/inetd.pid`
</pre></blockquote>

<p>
Zauwa¿ysz teraz ¿e ftp-proxy nas³uchuje na porcie 8021, tym samym pod
który wysy³a ruch nasza regu³ka przekierowuj±ca (rdr) ruch wysy³any
do serwerów FTP. Wybór portu 8021 jest dobry, poniewa¿ nie jest on 
przypisany ¿adnej inej aplikacji.

<p>
<a name="nat3.3"></a>
<b>Przekierowywanie ruchu</b>

<p>
Niekiedy mo¿e siê zda¿yæ ¿e bêdziesz potrzebowa³ przekierowaæ 
przychodz±cy lub wychodz±cy ruch dla pewnego protoko³u i/lub portu do
maszyny bêd±cej za filtrem pakietów. Przyk³adem mo¿e byæ komputer
w sieci wewnêtrznej, na którym pracuje serwer www, który powinien byæ
widoczny z zewn±trz (lub przed chwil± dyskutowany ftp-proxy(8)).
Po³±czenia przychodz±ce pod w³a¶ciwy Internetowy adres IP, dopóki
Twoja maszyna wykonuj±ca NAT sama bêdzie pracowa³a jako
serwer www, nie mog± zostaæ ustanowione. Z tego powodu, u¿ywamy
dyrektywy 'rdr' w regu³kach NAT aby poinformowaæ system w jaki 
sposób maj± byæ dokonywane przekierowania.

<p>
Dla przyk³adu, za³ó¿my ¿e serwer www znajduje siê w sieci LAN pod
adresep 192.168.1.80. Regu³ki NAT wymagaj± zastosowania nowej dyrektywy
aby przekierowaæ do neigo ruch. Do Twojego pliku  <i>/etc/pf.conf</i>
powiniene¶ wówczas dodaæ analogiczn± regu³kê:

<blockquote><pre>
rdr on fxp0 proto tcp from any to any port 80 -&gt; 192.168.1.80 port 80
</pre></blockquote>

<p>
Wyt³umaczymy ka¿dy z jej elementów:

<dl>
<dt>"rdr"
<dd>To komenda która wydajesz Twojemu NAT. Mówi mu ona, ¿e ten wpis
dotyczy przekierowywania ruchu.
</dl>

<dl>
<dt>"on fxp0"
<dd>Interfejs sieciowy który jest pod³±czony do Internetu.
</dl>

<dl>
<dt>"from any to any"
<dd>Wyszczególnia adresy IP które powinny ulec przekierowaniu
(po³±czenia pochodz±ce z jakiegokolwiek adresu IP przeznaczone
do jakiegokolwiek adresu docelowego)
</dl>

<dl>
<dt>"port 80"
<dd>Oto port (80) do którego po³±czenia powinny zostaæ przekierowywane.
Jako taki numer "80" nie musi zostaæ u¿yty. Mo¿esz sko¿ystaæ z wpisu
"port www". Je¶li wolisz korzystaæ z nazwy zamiast numeru, upewnij 
siê ¿e podana przez Ciebie nazwa znajduje siê w pliku
<i>/etc/services</i>.
</dl>

<dl>
<dt>"192.168.1.80 port 80"
<dd>Adres IP oraz port maszyny do której ma zostaæ przekierowany ruch.
Zauwa¿ ¿e port docelowy do którego przekierowujemy po³±czenie nie musi 
byæ identyczny z tym do którego pakiet zosta³ pocz±tkowo przeznaczony.

Dla przyk³adu, poni¿sza regu³ka jest poprawna, a nawet w niektórych
przypadkach u¿yteczna:
<pre>
rdr on fxp0 proto tcp from any to any port 8080 -&gt; 192.168.1.35 port 80
</pre>
Przekierowuje ona ca³y ruch przychodz±cy do portu 8080 do serwera
www uruchomionego na komputerze w wewnêtrznej sieci na "standardowym"
porcie 80.
</dl>

<p>
Gdy zakoñczysz wprowadzanie zmian, prze³aduj regu³ki NAT a
przekierowanie ruchu rozpocznie siê automatycznie.

<p>
<b>Negacje</b>
<p>
Czsami, mo¿esz zechcieæ wprowadziæ pewne wyj±tki do przekierowuj±cych 
regu³ek NAT. Oto przyk³ad. Komunikator AOL robi tak nieprzyjemne 
rzeczy jak usi³owanie wyj¶cia przez firewall przez ka¿dy mo¿liwy
port. Mo¿na zauwa¿yæ ¿e czasami dochodzi do konfliktu z naszym ftp-proxy
gdy komunikator AOL stara siê nawi±zaæ po³±czenie do portu 21.
Gdy uznasz ¿e nie podobaj± Ci siê takie praktyki AOL (wielu ludzi
spêdza sporo czasu próbuj±c go zablokowaæ), mo¿esz zechcieæ
wykluczyæ adres IP wykorzystywany przez serwery AOL z naszej 
regu³ki przekierowuj±cej:

<blockquote><pre>
rdr on tl0 proto tcp from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>

<p>
Interpretacja: Przekieruj ruch wchodz±cy na interfejs tl0 i wychodz±cy
do portu 21 za wyj±tkiem adresu docelowego 64.12.163.199 (serwer AOL
z którym u¿ytkownicy maj± problemy) do localhost`a pod port 8021
(gdzie nas³uchuje nasz ftp-proxy). Jakkolwiek istnieje wiele serwerów
AOL, wiêc je¶li ten problem naprawdê nie daje Ci spaæ rozwa¿ zablokowanie
adresów IP podsieci 64.12.0.0/16, uwa¿aj poniewa¿ prawdopodobnie w tym
zakresie znajduj± siê równie¿ zupe³nie przypadkowe serwery.


<p>
<a name="nat3.4"></a>
<b>NAT kontra Proxy</b>

<p>
Ró¿nica pomiêdzy NAT a oprogramowaniem typu proxy jest wyra¼na. Aplikacje
proxy s± wyra¼nym ogniwem ³±cz±cym Internet z komputerami w sieci LAN.
Nie wszystkie aplikacje zdolne s± o wspó³pracy z oprogramowaniem proxy,
szczególnie gry. Po prostu - nie istniej± serwery proxy dla wszystkich
aplikacji korzystaj±cych z sieci Internet.
NAT jest tworem transparentnym, mapuje wewnêtrzne adresy sieciowe tak, 
aby umo¿liwiæ hostom lokalnym dostêp do Internetu. Aplikacje pracuj±ce
po stronie klienta nie zdaj± sobie tak naprawdê spraw z tego ¿e w sieci
pracuje host wykonuj±cy NAT. Jedynym plusem wynikaj±cym z zastosowania 
proxy jest mo¿liwo¶æ zwiêkszenia bezpieczeñstwa, poprzez filtrowanie
ruchu i wychwytywanie wirusów i robaków na które podatne s± Windows, 
ochronê przed przepe³nieniami buforów w oprogramowaniu klienta
i wiele innych. Konfiguracja tego typu filtrów to trudna i powa¿na
praca.

<p>
<a name="nat3.5"></a>
<b>Refleksje na temat przekierowañ</b>

<p>
Czêsto regu³ki przekierowuj±ce u¿ywane s± do przekazywania przychodz±cych
po³±czeñ z Internetu do serwera umieszczonego w sieci LAN i nie posiadaj±cego
publicznego adresu IP:

<pre>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server port 80
</pre>

<p>
Jednak w przypadku gdy testujemy regu³kê z komputera w naszej sieci lookalnej,
zauwa¿amy ¿e nie dzia³a. Przyczyn± jest to ¿e regu³ka przekierowuj±ca
okre¶la interfejs wej¶ciowy dla pakietów ($ext_if - zewnêtrzny interfejs).
Po³±czenie z zewnêtrznym adresem komputera z firewallem z komputera
w sieci lokalnej wcale nie oznacza ¿e pakiety musz± wêdrowaæ przez zewnêtrzny
interfejs.
Stos TCP/IP firewalla porównuje adres przeznaczenia przychodz±cych pakietów
z w³asnymi adresami oraz ich aliasami, wykrywaj±c w ten sposób do siebie samego
w momencie gdy przesz³y tylko przez wewnêtrzny interfejs. Takie pakiety fizycznie 
nie wêdruj± przez zewnêtrzny interfejs a stos TCP/IP nie symuluje w ¿aden
sposób takiej sytuacji. PF nigdy nie widzia³ tych pakietów na zewnêtrznym
interfejsie i dlatego w³a¶nie regu³ka przekierowuj±ca, wy³apuj±ca pakiety
wêdruj±ce do zewnêtrznego interfejsu nie akceptuje po³±czeñ pochodz±cych
z sieci LAN.

<p>
Dodanie drugiej regu³ki przekierowuj±cej nie rozwi±¿e w tym przypadku naszego
problemu. Gdy klient z sieci lokalnej ³±cze siê z zewnêtrznym adresem IP 
firewalla pakiet inicjuj±cy po³±czenie TCP dochodzi do maszyny z firewallem
przez wewnêtrzny interfejs.
Nowa regu³ka przekierowuj±ca akceptuje ten pakiet i adres docelowy zostaje
zast±piony adresem lokalnego serwera.
Pakiet zostaje przekierowany ponownie na wewnêtrzny interfejs i dociera
do serwera. Jednak nie zosta³ przet³umaczony adres ¼ród³owy i zawiera
on adres klienta, wiêc serwer ode¶le odpowied¼ bezpo¶rednio do niego.
Firewall nigdy nie dostanie odpowiedzi od serwera która móg³by poprawnie
przes³aæ z powrotem do klienta, co spowoduje ¿e klient otrzyma pakiet TCP
ze ¼ród³a którego siê nie spodziewa³ i go odrzuci, nawi±zywanie po³±czenia
nie powiedzie siê.

<p>
Czêsto jest po¿±dane, aby hosty w sieci LAN mog³y ³±czeæ siê z tym samym
serwerem lokalnym tak jak hosty z zewn±trz, transparentnie (bez dodatkowej 
wiedzy o faktycznym adresie oraz po³o¿eniu serwera).
Oto kilka rozwi±zañ które mog± pomóc rozwi±zaæ ten problem:

<p>
<b>Konfiguracja serwera DNS</b>
<p>
Mo¿liwe jest skonfigurowanie serwera DNS tak, aby odpowiada³ na zapytania
z sieci lokalnej inaczej ni¿ na zapytania z zewn±trz, tak wiêc klient
w sieci lokalnej mo¿e otrzymaæ od serwera nazw adres lokalny serwera.
Po³±czy siê wtedy z nim bezpo¶rednio, bez zaanga¿owania w tê operacjê
firewalla. Zredukuje to ruch, poniewa¿ pakiety nie bêd± niepotrzebnie
wêdrowa³y przez firewall.

<p>
<b>Przeniesienie serwera do odseparowanej sieci lokalnej</b>
<p>
Do³±czenie dodatkowego interfejsu sieciowego do komputera z firewallem
i przeniesienie serwera do takiej sieci dedykowanej (DMZ) pozwoli na 
przekierowywanie po³±czeñ od lokalnych klientów w taki sam sposób
jak klientom z zewn±trz. Wykorzystanie odseparowanej sieci ma kilka
innych zalet, w³±czaj±c zwiêkszenie bezpieczeñstwa poprzez odseparowanie
serwera tak¿e od klientów lokalnych. Jednak¿e nale¿y pamiêtaæ o tym 
¿e w takim przypadku nasz serwer nie bêdzie mia³ bezpo¶redniego dostêpu
do hostów lokalnych - wszystkie po³±czenia bêd± musia³y przej¶æ przez 
firewall.

<p>
<b>TCP proxy</b>
<p>
TCP proxy mo¿e byæ skonfigurowany na ho¶cie na którym pracuje firewall,
nas³uchuj±c na porcie który ma zostaæ przekierowany oraz przechwytuj±c 
po³±czenia z interfejsu lokalnego i przekierowywaæ je do portu na którym
nas³uchuje. Gdy lokalny klient ³±czy siê z firewallem, proxy akceptuje
po³±czenie otwieraj±c drugie po³±czenie z serwerem i przekierowuj±c
ruch pomiêdzy ustanowionymi po³±czeniami.

<p>
Proste proxy mo¿na stworzyæ korzystaj±c z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
lub
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1">nc(1)</a>.
Poni¿szy wpis w <i>/etc/inetd.conf</i> tworzy gniazdo przypisane do 
interfejsu loopback i portu 5000. Po³±czenia s± przekierowywane do 
portu 80 serwera o adresie 192.168.1.10.

<pre>
127.0.0.1:5000 stream tcp wait nobody /usr/bin/nc nc -w 20 192.168.1.10 80
</pre>

<p>
Poni¿sza regu³ka PF przekierowuje ruch portu 80 na wewnêtrznym interfejsie
do proxy:

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; 127.0.0.1 port 5000
</pre>

<p>
<b>Wspó³praca RDR (przekierowania) i NAT</b>
<p>
Mo¿na równie¿ uzyskaæ translacjê adresu ¼ród³owego poprzez wprowadzenie 
dodatkowej regu³ki NAT dotycz±cej wewnêtrznego interfejsu.

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; $server
no nat on $int_if proto tcp from $int_if to $int_net
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; $int_if
</pre>

<p>
Spowoduje to, ¿e inicjalizuj±cy po³±czenie pakiet pochodz±cy od klienta,
zostanie ponownie poddany NAT w chwili gdy zostanie przekierowany na
zewnêtrzny interfejs, adres ¼ród³owy kleinta zostanie zamieniony na adres 
inetrfejsu wewnêtrznego serwera. Serwer prze¶le swoj± odpowied¼ do firewalla,
który potrafi zamieniæ regu³kê RDR na NAT gdy klientem jest host w sieci
loaklnej. Taka konstrukcja jest do¶æ z³o¿ona dziêki tem ¿e tworzy
dwa oddzielne stany dla ka¿dego po³±czenia.
Trzeba zwróciæ uwagê na odpowiedni± konfiguracjê NAT w taki sposób, aby 
regu³ki nie akceptowa³y innych pakietów ni¿ te które dopuszczasz, dla
przyk³adu, po³±czenia pochodz±ce od hostów z poza naszej sieci lub samego
firewalla. Zauwa¿ ¿e regu³ka rdr powy¿ej, spowoduje ¿e stos TCP/IP bêdzie 
widzia³ pakiety przychodz±ce do wewnêtrznego interfejsu z adresem docelowym
naszej sieci lokalnej. Aby zapobiec generowaniu informacji o przekierowaniach 
ICMP przez stos (mówi±cych klientowi ¿e serwer jest dostêpny lokalnie)
wy³±cz przekierowania na gateway`u:

<pre>
# <strong>sysctl -w net.inet.ip.redirect=0</strong>
</pre>

Dla wiêkszo¶ci przypadków, rozwi±zania omawiane powy¿ej s± w zupe³no¶ci
wystarczaj±ce.

<p>
<a name="nat4.0"></a>
<b>6.3.4 Linki i inna dokumentacja</b>

<p>
Pliki OpenBSD:
<ul>
<li>/etc/pf.conf - plik z regu³kami PF/NAT
<li>/etc/rc.conf - tutaj nale¿y dokonaæ edycji aby uruchomiæ NAT i PF przy starcie systemu
<li>/etc/sysctl.conf - w tym miejscu zezwalamy na przekazywanie pakietów IP
</ul>

<p>
Inne linki o NAT:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">strona man o pf.conf</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.3">strona man o pfctl</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>


<p> 
<a name= "DHCP"></a>
<a name= "6.4"></a> 
<h2>6.4 - DHCP</h2> 

<p>
<h3>6.4.1 Klient DHCP</h3>

<p>
Aby skorzystaæ z klienta DHCP
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
do³±czonego standardowo do OpenBSD, wyedytuj plik /etc/hostname.xl0 (oczywi¶cie
je¶li taki posiadasz, lub analogiczny plik dla Twojej w³asnej konfiguracji 
sprzêtowej). Wszystko czego potrzebujesz to umie¶cicæ w tym pliku wpis 'dhcp'
<pre>
# <strong>echo dhcp &gt;/etc/hostname.xl0</strong>
</pre>

<p>
Dziêki temu OpenBSD automatycznie uruchomi klienta DHCP przy starcie dla wskazanego
interefejsu. Pobrany zostanie adres IP, domy¶lna bramka, oraz serwery DNS.

<p>
Je¶li chcesz skonfigurowaæ swój interfejs poprzez dhcp z linii poleceñ, upewnij siê
¿e masz plik /etc/dhclient.conf, a nastêpnie wykonaj: 

<pre>
# <strong>dhclient fxp0</strong>
</pre>

<p>
Gdzie fxp0 powiniene¶ wstawiæ nazwê w³asnego posiadanego interfejsu.

<p>
Niewa¿ne w jaki sposób uruchamiasz dhclient, zawsze mo¿esz wyedytowaæ 
/etc/dhclient.conf aby np. <b>nie</b> uaktualniaæ swojej konfiguracji serwerów 
DNS poprzez odkomentowanie linii 'request' (poni¿ej znajdziesz przyk³adowe
domy¶lne opcje, które musisz odkomentowaæ i dokonaæ spo¶ród nich wyboru.)

<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>

<p>
a nastêpnie <b>unsun±æ</b> domain-name-servers. Oczywi¶cie mo¿esz usun±æ te¿ ka¿dy
z pozosta³ych wpisów.

<p>
<h3>6.4.2 Serwer DHCP</h3>

<p>
Je¶li chcesz aby Twój OpenBSD pracowa³ w sieci jako serwer DHCP
<A href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>,
wyedytuj /etc/rc.conf poprzez ustawienie dhcpd_flags="-q" zamiast domy¶lnego
dhcpd_flags=NO. Umie¶æ interfejs na którym serwer ma <b>nas³uchiwaæ</b> w pliku
/etc/dhcpd.interfaces.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
A nastêpnie zabierz siê za konfiguracjê serwera poprzez plik  /etc/dhcpd.conf.
Znaczenie poni¿szych opcji jest chyba jasne.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Twój serwer DHCP powie klientowi ¿e nale¿y do domeny "example.com" oraz ¿e serwery DNS dla tej
domeny to 192.168.1.3 i 192.168.1.5. Hosty znajduj±ce siê w tej samej sieci co adres 
interefjsu OpenBSD na którym nas³uchuje DHCP, nale¿±cy do sieci 192.168.1.0/24,
otrzymaj± adresy z zakresu 192.168.1.32 - 192.168.1.127. Otrzymaj± te¿ informacjê
aby jako domy¶ln± bramkê wykorzystywa³y host 192.168.1.1.

<p>
Je¶li chcesz uruchomiæ dhcpd(8) z linii komend po edycji /etc/dhcpd.conf, u¿yj:

<pre>
     # <b>dhcpd -q fxp0</b>
</pre>

<p>
Gdzie <tt>fxp0</tt> jest interfejsem na którym serwer DHCP ma nas³uchiwaæ.
Opcja <tt>-q</tt> mówi dhpcpd(8), aby zachowywa³ siê trochê ciszej ni¿
standardowo.

<p>
Je¶li serwujesz informacje DHCP klientowi Windows, mo¿esz zechcieæ, aby
dhcpd(8) poda³ temu klientowi adres serwera 'WINS'. Wystarczy dodaæ analogiczn±
do poni¿szej linijkê do /etc/dhcpd.conf:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(gdzie zamiast <tt>192.168.92.55</tt> powiniene¶ wstawiæ swój adres IP serwera Windows 
lub Samba.)
Zobacz <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a> aby dowiedzieæ siê jakie inne informacje mo¿esz dostarczyæ klientom.

<p>
<a name="PPP"></a>
<a name="6.5"></a>
<h2>6.5 - PPP </h2>

<p>
Protokó³ Punkt-Punkt (Point-to-Protocol - PPP) najczê¶ciej wykorzystywany jest w przypadkach
gdy ³±czysz siê ze swoim dostawc± Internetu poprzez modem. W OpenBSD mo¿esz to zrobiæ
na dwa sposoby poprzez:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
 - który jest demonem ppp dzia³aj±cym w przestrzeni j±dra.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - dzia³aj±cym w przestrzeni u¿ytkownika. 
</ul>

<p>
Zaczniemy od konfiguracji demona PPP który móg³ bêdzie byæ uruchamiany
przez zwyk³ych u¿ytkowników. Aby rozpocz±æ potrzebujesz trochê informacji od
swojego dostawcy. Oto lista rzeczy które powiniene¶ wiedzieæ nim przyst±pimy do pracy:

<ul>
<li>Numer dialup Twojego dostawcy.
<li>Adres serwera nazw.
<li>Twoja nazwa u¿ytkownika i has³o.
<li>Adres Twojej bramki.
</ul>

<p>
Bez czê¶ci z nich mo¿esz siê obej¶æ, ale wygodniej bêdzie je¶li bêdziesz 
dysponowa³ powy¿szymi informacjami. Demon PPP pracuj±cy w przestrzeni u¿ytkownika
korzysta z pliku konfiguracyjnego 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>.
W katalogu <i>/etc/ppp</i> znajdziesz kilka pomocnych plików, które mog± 
definiowaæ ró¿ne konfiguracje dla ró¿nych specyficznych sytuacji. Zalecane
jest aby¶ siê z nimi zapozna³.

<p>
Ponadto, w przypadku gdy u¿ywasz w³asnorêcznie skompilowanego j±dra (zamiast
domy¶lnego GENERIC), ¿e poni¿szy wiersz znajduje siê w pliku konfiguracji:

<blockquote><pre><strong>
pseudo-device   tun             2
</strong></pre></blockquote>

<p>
<h3>Podstawowa konfiguracja PPP(8)</h3>

<p>
Podstawowej konfiguracji dzia³aj±cego w przestrzeni u¿ytkownika demona PPP
polega na edycji pliku <i>/etc/ppp/ppp.conf</i>. Domy¶lnie tego pliku nie 
ma w Twoim systemie, ale znajduje siê plik <i>/etc/ppp/ppp.conf.sample</i>,
z którego mo¿esz skorzystaæ tworz±c swój plik <i>ppp.conf</i>. Poni¿ej opisana
zostanie najbardziej podstawowa i typowa konfiguracja. Oto przyk³adowy plik
<i>ppp.conf</i> który pozwoli Ci na po³±czenie siê z Twoim dostawc± Internetu,
a tak¿e ustawi domy¶ln± trasê rutowania i serwer nazw (DNS). Wszystko czego 
potrzebujesz aby ten plik dzia³a³ to numer Twojego dostawcy, Twoja nazwa
u¿ytkownika oraz has³o.

<blockquote>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</blockquote>

<p>
Sekcja poni¿ej <tt>default:</tt> bêdzie przetwa¿ana przy ka¿dym uruchomieniu 
demona. Umieszczamy w niej wszystkie niezbêdne informacje. Korzystaj±c 
z &quot;set log&quot; konfigurujemy poziomy logowania. Mo¿esz zmieniæ te 
ustawienia, aby dowiedzieæ siê wiêcej na temat ustawienia poziomów logowania
zajrzyj do 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>.
Wyboru urz±dzenia pod którym jest nasz modem dokonujemy w sekcji &quot;set device&quot;,
w tym przypadku modem pod³±czony jest do drugiego portu szeregowego, port 
pierwszy to urz±dzenie <i>/dev/cua00</i>. Korzystaj±c z &quot;set speed&quot;
ustalamy prêdko¶æ po³±czenia a w &quot;set dial&quot; podajemy parametry 
naszego po³±czenia. Mo¿na zdefiniowaæ w tym miejscu inny 'timeout' dla naszego
po³±czenia itp. Podana linijka jest do¶æ dobra i raczej nie wymaga zmian.

<p>
Teraz mo¿emy przej¶æ do sekcji w których podamy informacje specyficzne dla
dostawcy Internetu (ISP). Informacje te podajemy w sekcjach umiejscowionych 
poni¿ej nag³ówka <b>default:</b>. Nag³ówek nowej sekcji mo¿e mieæ dowolny tytu³,
np. nazwê Twojego ISP. Tutaj skorzysamy z nazwy <b>myisp:</b>, poni¿ej tego nag³ówka
znajdziesz wszystkie informacje niezbêdne do tego aby po³±czenie zosta³o poprawnie
zainicjowane.

<blockquote>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
Oto podstawowa konfiguracja potrzebna do tego aby po³±czyæ siê z konkretnym 
ISP. Opcja &quot;set phone&quot; ustala numer dialup naszego ISP. 
Kolejna, &quot;set login&quot;, pozwala na wprowadzenie opcji niezbêdnych
do poprawnego zalogowania siê. Umie¶cili¶my tutaj timeout na 5 sekund, co
oznacza ¿e nasza próba zalogowania siê zostanie przerwana po 5 sekundach 
bez sygna³u po³±czenia. W innym przypadku bêdziemy czekaæ na &quot;login:&quot;
oraz wys³ane zostanie Twoja nazwa u¿ytkownika oraz has³o. W powy¿szym przypadku
nazwa u¿ytkownika (Username) = ppp oraz has³o (Password) = ppp. Te warto¶ci
bêdziesz musia³ zmieniæ (&quot;od t³umacza: chyba ¿e korzystasz z us³ug TPSA&quot;).
Wiersz &quot;set timeout&quot; ustala "ja³owy" (idle) czas dla ca³ego po³±czenia
na 120 sekund. Opcja &quot;set ifaddr&quot; wymaga d³u¿szego wyja¶nienia.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
W powy¿szej linii korzystamy z ustawienia adresu w formacie &quot;<b>set ifaddr
[myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;. 
Czyli pierwszym adresem IP jest ten jaki chcemy aby zosta³ nam pzypisany.
Je¶li dostajesz statyczny adres od swojego ISP powiniene¶ umie¶ciæ go w³a¶nie
tutaj. W tym przyk³adzie dodali¶my /0 aby zaznaczyæ ¿e ¿aden z bitów tego 
adresu nie wymaga dopasowania i mo¿e on zostaæ ca³kowicie zmieniony przez
ISP podczas transakcji rozpoczynaj±cej po³±czenie. Drugi adres IP to adres 
IP dostawcy. Je¶li go znasz, umie¶æ go w³a¶nie w tym miejscu, je¶li nie
zrób tak jak w naszym przypadku - umie¶æ na koñcu /0. Trzecia opcja to nasza
maska sieciowa, w tym przypadku ustawiona na 255.255.255.0. Je¶li triggeraddr
jest ustawiony, u¿ywany jest do zast±pienia myaddr podczac rozpoczêcia
negocjacji IPCP. Jakkolwiek tylko adres z zakresu myaddr zostanie zaaakceptowany.
Ta opcja u¿yteczna jest w przypadkach gdy niektóre implementacje PPP podczas
negocjacji po³±cznia nie przyznaj± adresu IP dopuki nie zarz±dasz ``0.0.0.0.0''.

<p>
Nastepna opcja &quot;add default HISADDR&quot; ustala domy¶ln± trasê
rutowania na adres ISP. Dziêki takiemu wpisowi jeste¶ uniezale¿niony
od adresu IP Twojego dostawcy - za ka¿dym razem bêdzie on automatycznie
uaktualniony w przypadku zmiany. Dziêki opcji &quot;enable dns&quot;
mówimy naszemu ISP aby 'zalegalizowa³' adresy naszych serwerów nazw.
UWAGA: nie rówb tego je¶li masz uruchomiony lokalny serwer DNS, poniewa¿
ppp obejdzie to poprzez dopisanie kilku linijek nameserver w pliku 
<i>/etc/resolv.conf</i>.

<p>
<h3>U¿ywanie PPP(8)</h3>

<p>
Mamy wreszcie nasz plik <i>ppp.conf</i> z konfiguracj± po³±cznia, teraz
mo¿emy spróbowaæ po³±czyæ siê z naszym ISP. Opisanych zostanie kilka najczê¶ciej
u¿ywanych parametrów ppp.

<ul>
<li><tt>ppp -auto myisp</tt> - Uruchamia ppp, konfiguruje interfejs, ³±czy siê z 
ISP a nastêpnie przechodzi do pracy w tle.
<li><tt>ppp -ddial myisp</tt> - Podobne do -auto, ale w przypadku gdy po³±cznie
zostanie utracone, zostan± podjête próby przywrócenia go.
</ul>

<p>
U¿ywanie <i>/usr/sbin/ppp</i> bez opcji spowoduje pracê w trybie interaktywnym.
Mo¿esz wtedy rêcznie ustanawiaæ po³±cznie rozmawiaj±c ze swoim modemem, ta opcja
(a w zasadzie brak ¿adnych opcji) jest u¿yteczna gdy Twój <i>ppp.conf</i> nie dzia³a
tak jak powinien.

<p>
<h3>dodatki do ppp(8)</h3>

<p>
W niektórych sytuacjach mo¿e zaj¶æ potrzeba wykonania jakiej¶ czynno¶ci w momencie
gdy po³±czenia zostaje utracone lub nawi±zane. Do tego typu zadañ wykorzystuje siê
dwa pliki: <i>/etc/ppp/ppp.linkup</i> i <i>/etc/ppp/ppp.linkdown</i>.
Przyk³adowe konfiguracje znajdziesz poni¿ej:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Dodatkowe informacje mo¿esz znale¼æ pod adresem
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">FreeBSD 
Handbook entry on User PPP</a>. 


<p>
<a name="Tuning"></a>
<a name="6.6"></a>
<h2>6.6 - Tuning parametrów sieciowych</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - Jak zmusiæ j±dro aby stosowa³o wieksz± liczbê ponowieñ
i d³u¿sze czasy timeout dla sesji TCP ?</h3>

<p>
Zmiana tych standardowych ustawieñ mo¿e byc pomocna w przypadku problemów
z po³±czeniem i rutingiem. Oczywi¶cie, aby zmiany te dzia³a³y efektywnie
powinny z nich korzystaæ obie strony po³±czenia.

<p>
Do zmiany tych warto¶ci u¿yj <tt>sysctl</tt> i powiêksz warto¶ci:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Korzystaj±c z sysctl -a, mo¿esz obejrzeæ aktualne ustawienia tych 
(i wielu innych) parametrów j±dra. Aby zmieniæ jeden z nich, skorzystaj
z <tt>sysctl -w</tt>, jak np. <tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - W jaki sposób uruchomiæ directed broadcasts?</h3>

<p>
W normalnej sytuacji nie powiniene¶ tego robiæ. Zezwala to bowiem komu¶ na
wys³anie pakietów pod adres(y) brozdcast Twoich sieci w przypadku gdy u¿ywasz
OpenBSD jako routera. Istnieje kilka przypadków w zamkniêtych sieciach gdy
mo¿e byæ to u¿yteczne, zw³aszcza korzystaj±c ze starszych implementacji 
protoko³u NetBIOS. Wykorzystujemy do tego celu kolejny sysctl: 
<tt>sysctl -w net.inet.ip.directed-broadcast=1</tt>. Je¶li chcesz wiedzieæ
dlaczego domy¶lnie jest ta opcja wy³±czona poczytaj o 
<a href="http://www.netscan.org">smurf attacks</a>.

<p>
<h3>6.6.3 - Nie chcê aby j±dro dynamicznie przydziela³o pewne porty.</h3>

<p>
Tak¿e do tej konfiguracji s³u¿y sysctl. Czytaj±c w
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>:

<pre>
Decydowanie o li¶cie zarezerwowanych portów TCP które nie powinny byæ
alokowane przez j±dro dynamicznie. Mo¿esz wykorzystaæ tê opcjê aby
nie zezwalaæ demonom na "podkradanie" portów z których korzystaj±
inne programy. Elementy listy oddzielony mog± byæ przecinkami i/lub
znakami bia³ymi.

 #  <strong>sysctl -w  net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

Moa¿na tak¿e dodaæ b±d¼ usun±æ który¶ z wpisów aktualnej listy.

 #  <strong>sysctl -w net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl -w net.inet.tcp.baddynamic=-871</strong>
</pre>


<p>
<a name="NFS"></a>
<a name="6.7"></a>
<h2>6.7 - Proste wykorzystanie NFS</h2>

<p>
NFS, sieciowy system plików (Network File System) wykorzystywany jest do
wspó³dzielenia systemów plików w sieci. Przed przyst±pieniem do konfiguraci
NFS powiniene¶ zapoznaæ siê z kilkoma stronami manuala:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
</ul>

<p>
Dziêki temu rozdzia³owi w prosty sposób dowiesz siê jak skonfigurowaæ
NFS. Omawiamy wszystko na przyk³adzie serwera pracuj±cego w sieci LAN
oraz klientów którzy wykorzystuj± w tej sieci NFS. W sekcji tej nie 
bêdziemy poruszaæ zagadnieñ zwi±zanych z bezpieczeñstwem, zak³adamy
¿e masz ju¿ skonfigurowany swój filtr pakietów lub inn± ochronê typu
firewall aby uniemo¿liwiæ dostêp osobom z zewn±trz. Je¶li zamierzasz 
zezwoliæ na dostêp do NFS z zewn±trz w celu wymiany poufnych 
danych które nie powinny trafiæ w niepowo³ane rêce, rekomendowane jest
wykorzystanie <a href="../faq13.html">IPsec</a>. W innym przypadku mo¿liwe
jest pods³uchanie ca³ego ruchu który wymieniany jest przez NFS. Innym 
sposobem na niepowo³ane dostanie siê do serwera jest podmienienie
adresu IP na taki któremu zezwalasz na dostêp. Istnieje jeszcze kilka
metod ataku na NFS, jednak prawid³owo skonfigurowany IPsec stanowi skuteczn±
ochronê.

<p>
Jeszcze jedna uwaga zwi±zana z bezpieczeñstwem. Nie dodawaj samych
systemów plików do <i>/etc/exports</i> bez listy hostów które mog±
mieæ dostêp do zasobów. Je¶li nie wyszczególnisz który z nich mo¿e
montowaæ odpowiedni katalog, ka¿dy kto bêdzie móg³ ustanowiæ z Twoim
serwerem po³±czenie bêdzie móg³ montowaæ wszystkie eksportowane
przez Ciebie katalogi.

<p>
NFS korzysta z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
i musi byæ on uruchomiony jako pierwszy. Portmap(8) w wersjach 
OpenBSD 3.2 i pó¼niejszych jest domy¶lnie wy³±czony, aby to zmieniæ
wyedytuj <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
zmieniaj±c linijkê <tt>portmap</tt> w nastêpuj±cy sposób:

<blockquote><pre>
portmap=YES
</pre></blockquote>
i uruchom ponownie system. 

<p>
W naszym przyk³adzie serwer ma adres ip <b>10.0.0.1</b>. Bêdzie on udostêpnia³
NFS tylko klientom znajduj±cym siê w swojej sieci. Pierwszym krokiem 
w koniguracji jest edycja pliku <i>/etc/exports</i>. Umie¶cisz w nim
zasoby które chcia³by¶ udostêpniæ klientom oraz zdefiniujesz kto 
powinien mieæ dostêp do poszczególnych. W pliku <i>/etc/exports</i> mo¿esz
u¿yæ naprawdê wielu opcji, aby zapoznaæ siê ze wszystkimi mo¿liwo¶ciami 
przeczytaj <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
W tej chwili mamy <i>/etc/exports</i> wygl±daj±cy w ten sposób:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
Powy¿szy wpis oznacza ¿e przez NFS dostêpny bêdzie system plików <tt>/work</tt>.
Opcja <tt>-alldirs</tt> ¿e klienci bêd± mogli montowaæ ka¿dy katalog
znajduj±cy siê na ssytemie plików <tt>/work</tt>. Opcja <tt>-ro</tt>
oznacza ¿e zezwalamy na montowanie w trybie tylko do odczytu. Ostatnie 
dwa argumenty mówi± ¿e tylko hosty z sieci 10.0.0.0 o masce 255.255.255.0
mog± mieæ dostêp do tego zasobu, co jest istotne w przypadku gdy serwery
pracuj± czasami w kilku ró¿nych sieciach.

<p>
Gdy Twój plik <i>/etc/exports</i> jest ju¿ odpowiednio skonfigurowany, mo¿esz
przej¶æ do konfiguracji serwera. Upewnij siê czy Twoje j±dro zosta³o skompilowane
z opcj± NFSSERVER oraz NFSCLIENT (standardowe j±dra tak maj±). Nastêpnym krokiem
jest ustawienie warto¶ci <tt>nfs_server=YES</tt> w pliku <i>/etc/rc.conf</i>.
Spowoduje to automatyczne uruchomienie nfsd(8) i mountd(8) za ka¿dym razem
gdy uruchomisz ponownie komputer. W tej chwili mo¿esz uruchomiæ te demony
rêcznie, aby to zrobiæ musisz byæ rootem oraz portmap(8) musi byæ ju¿ 
uruchomiony. Oto przyk³a uruchomienia nfsd(8) pracuj±cego na protoko³ach
TCP i UDP korzystaj±c z 4 demonów. Powiniene¶ ustaliæ tê liczbê wg w³asnych
potrzeb, aby okre¶liæ maksymaln± ilo¶æ jednocze¶nie obs³ugiwanych klientów.

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Wystartowanie nfsd(8) nie jest ostatni± zcynno¶ci±, oprócz tego potrzebujesz 
uruchomiæ jeszcze mountd(8). Demon ten obs³uguje ¿±dania montowania NFS.
Aby go uruchomiæ, upewnij siê ¿e istnieje pusty plik mountdtab, a nastêpnie
uruchom demona:

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<p>
Je¶li w trakcie pracy wprowadzisz jakie¶ zmiany w /etc/exports, musisz 
poinformowaæ o tym mountd! Wystarczy sygna³ HUP:

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<p>
<h3>Statystyki NFS</h3>

<p>
W tej chwili mo¿esz sprawdziæ czy wystartowane przez Ciebie demony pracuj±
i s± zarejestrowane w RPC. Skorzystaj z rpcinfo(8).

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Podczas zwyk³ago u¿ytkowania, istnieje jeszcze kilka innych narzêdzi 
pozwalaj±cych zobaczyæ co dzieje siê z NFSem. Jedn± z nich jest:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">showmount(8)</a>, 
dziêki któremu mo¿esz dowiedzieæ siê jakie zasoby s± aktualnie zamontowane
i przez kogo. Jest jeszcze nfsstat(8), który wy¶wietla kilka dodatkowych 
informacji. Przyk³adowe wywo³anie showmount(8) wygl±da nastêpuj±co:

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>Montowanie systemu plików NFS</h3>

<p>
NFS powinien byæ montowany poleceniem mount(8), lub w bardziej specyficzny
dla neigo sposób korzystaj±c z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
Do zamontowania systemu plików <i>/work</i> znajduj±cego siê na ho¶cie 
10.0.0.1 do lokalnego katalogu <i>/mnt</i> skorzystaj z poni¿szej sk³adni
(mo¿esz zamiast adresu IP u¿yæ nazwy hosta):

<blockquote><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
Je¶li chcesz aby montowanie przebiega³o w momencie uruchamiania systemu,
dodaj linijkê analogiczn± do poni¿szej w pliku <i>/etc/fstab</i>:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
Wa¿ne jest aby¶ jako dwa ostatnie wpisy w tej linii umie¶ci³ <tt>0 0</tt>
aby Twój komputer nie próbowa³ sprawdzaæ systemu plików programem fsck 
przy starcie! Inne standardowe opcje zwiêkszaj±ce bezpieczeñstwo takie
jak noexec, nodev i nosuid powinny byæ tak¿e u¿yte gdy to mo¿liwe:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
W ten sposób, mount nie bêdzie interpretowa³ urz±dzeñ specjalnych i uniewa¿ni
bity suid dziêki czemu programy na serwerze nie bêd± mog³y wykonywaæ
niebezpiecznych operacji na kliencie NFS. Je¶li nie montujesz ¿adnych 
programów których chcia³by¶ u¿ywaæ przez NFS, powiniene¶ dodaæ tak¿e opcjê 
noexec.

<p>
<a name="DNS"></a>
<a name="6.8"></a>
<h2>6.8 - System nazw domenowych (Domain Name Service)  - DNS, BIND i named</h2>

<i>Uwaga: Sekcja ta zosta³a napisana dla OpenBSD 3.2 i wcze¶niejszych wydañ,
które zawiera³y BIND4. OpenBSD v3.3 zawiera teraz BIND9, który jest
lepiej opisany w literaturze i w Internecie, ni¿ by³o to w przypadku BIND4.

<p>Podobnie jak BIND4 z OpenBSD,
BIND9 na OpenBSD dzia³± w ¶rodowisku chroot(2) i posiada liczne ulepszenia
bezpieczeñstwa w stosunku do standardowego BIND9:
<ul>
<li>wsparcie arc4random() (zintegrowany w 9.3.0-snapshot)
<li>wywo³anie tzset przed chroot
<li>otwarcie /dev/null przed chroot
<li>powrót do domy¶lnego urz±dzenia losuj±cego podczas pracy w chroot
<li>dodanie implementacji LCG (Linear Congruential Generator) do libisc
<li>u¿ywanie LCG zamiast LFSR do generowania ID dopóki LFSR nie bêdzie uznany za godny zaufania
<li>wybór protoko³ów transportuj±cych IPv{4,6} dla zapytañ programu dig(1)
<li>naprwa sha1.c pozwalaj±ca obej¶æ b³±d optymalizacji gcc (sparc64)
<li>domy¶lnie chroot w <tt>/var/named</tt>
<li>domy¶lnie setuid na u¿ytkownika <tt>named</tt>
<li>zapis pid-file przd chroot
</ul>
OpenBSD 3.3 mog± zaj¿eæ na: 
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&amp;sektion=8">named(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.sbin/bind/doc/arm/Bv9ARM.html"
>BIND 9 Administrator Reference Manual</a> (Strony te s± tak¿e dostêpne
w katalogu <tt>/usr/share/doc/html/bind/</tt> w twoim systemie)
</ul>
</blockquote> </i>

<p>
<h3>6.8.1 Co to jest DNS?</h3>

<p>
System nazw domenowych (Domain Name Service) jest w³asno¶ci± zezwalaj±c±
na odwzorowywanie adresów IP na domeny i odwrotnie. Domy¶lna instalacja OpenBSD
skonfigurowana jest jako klient DNS, ale nie jako serwer. Oznacza to, ¿e
Twój system potrafi wys³aæ zapytanie o adres IP przypisany do danej
domeny, ale nie potrafi sam udzieliæ odpowiedzi na takie pytanie wys³ane
z innej maszyny dopóki nie zostanie w tym celu odpowiednio skonfigurowany.

<p>
Mój OpenBSD aktualnie pod³±czony do Internetu poprzez mojego ISP, wiêc mogê
skorzystaæ z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&amp;sektion=8">nslookup(8)</a>
aby wykonaæ zapytanie DNS:

<blockquote><pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre></blockquote>

<p>
<b>165.87.201.244</b> jest adresem serwera który udzieli³ odpowiedzi, poniewa¿
taki w³a¶nie zosta³ mi przydzielony przez mojego ISP i który zosta³ wpisany w 
pliku
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">/etc/resolv.conf</a>.
Uzyskana odpowied¼ nie jest jednak autorytatywna. Do uzyskania takiej
odpowiedzi musimy poszukaæ autorytatywnego serwera DNS dla domeny
<i>openbsd.org</i> i jego spytaæ o adres <i>www.openbsd.org</i>:

<blockquote><pre>
# Identyfikacja serwerów nazw domeny openbsd.org
# uzyskana z pomoc± serwera nazw mojego ISP
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet address = 199.185.137.3
gandalf.sigmasoft.com   internet address = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Wykorzystanie uzyskanych informacji dla uzyskania
# autorytatywnej odpowiedzi z serwera zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Address:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre></blockquote>

<p>
<i>zeus.theos.com</i> jest, jak mo¿na przypuszczaæ, komputerem
z OpenBSD oraz skonfigurowany jest aby móg³ pracowaæ jako serwer
DNS dla domeny <i>openbsd.org</i>.

<p>
<a name="DNS.1.1"></a>
<a name="6.8.1.1"></a>
<h3>6.8.1.1 Sk±d dowiedzieæ siê wiêcej o DNS i jego implementacji
w OpenBSD?</h3>

<ul>
<li>Przeczytaj RFC <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, 
<a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a> oraz 
<a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> dla uzyskania
wiêkszej wiedzy na temat Internetowego systemu domen.
<li>Przeczytaj ksi±¿kê wydawnictwa O'Reilly Associates <i><a href="../../books.html#6">DNS
and BIND</a> </i>.
<li>Odwied¼ tak¿e <a href="http://www.openbsd.org/cgi-bin/man.cgi">Manual OpenBSD</a> a zw³aszcza
strony
  <ul>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&amp;sektion=8">nslookup(8)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&amp;sektion=3">gethostbyname(3)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&amp;sektion=8">named(8)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&amp;sektion=3">resolver(3)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&amp;sektion=5">resolver(5)</a>
  </ul>
</ul>

<p>
Komenda
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
jest bardzo u¿yteczna, poniewa¿ potrafi wykonywaæ zapytania oraz wy¶wietlaæ
wyniki w stylu niemal identycznym z formatem plików konfiguracyjnych BINDa.
Mo¿esz u¿yæ
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
aby sprawdziæ konfiguracjê znanych Ci serwerów nazw.

<p>
<h3>6.8.2 Czy mój komputer musi byæ serwerem nazw?</h3>

<p>
Je¶li nie jeste¶ pewien czy Twój komputer powinien pe³niæ rolê 
serwera DNS, odpowied¼ brzmi najprawdopodobniej - nie. Domy¶lna
instalacja nie konfiguruje Twojego systemu aby pracowa³ w taki 
w³a¶nie sposób, aczkolwiek wszystkie niezbêdne pliki s± ju¿ zainstalowane.
Dla wiêkszo¶ci stacji roboczych wystarczy edycja pliku
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">/etc/hosts</a>
do nadania nazw lokalnym adresom IP oraz
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">/etc/resolv.conf</a>
dla umieszczenia informacji o tym które serwery DNS powinny byæ
u¿ywane do rozwi±zywania nazw intranetu i Internetu.

<p>
Z drugiej strony, mo¿esz potrzebowaæ skonfigurowania Twojego systemu
jako serwera nazw:

<ul>
<li>Je¶li posiadasz sieæ LAN w której nie chcia³by¶ kopiowaæ pliku "hosts"
do ka¿dej maszyny, mo¿esz soknfigurowaæ OpenBSD aby pracowa³ jako 
lokalny serwer DNS i serwowwa³ adresy IP komputerom w Twojej sieci.
  <ul>
  <li><b>Uwaga:</b> Praktycznie nie ma maksymalnej liczby serwerów DNS
  w sieci LAN. Ka¿dy (lub nawet wszystkie) komputery w sieci LAN mog±
  oferowaæ us³ugi DNS je¶li s± tylko do tego odpowiednio skonfigurowane.
  To czy który¶ z tych serwerów jest autorytatywny na zewn±trz sieci LAN
  (lub jest wogóle widziany nazewn±trz) jest czynnikiem który zwykle
  kontrolowany jest przez wy¿szy poziom w hierarchii Twojej domeny.
  </ul>
<li>Je¶li posiadasz sieæ LAN w której znajduj± siê komputery które
powinne byæ dostêpne przez zapytania DNS komputerów z innej
sieci LAN lub WAN.
<li>Je¶li masz problemy z rozwi±zywaniem lokalnej nazwy hosta do adresu IP
lub nazw innych hostów nawet gdy masz poprawnie skonstruowany plik <i>/etc/hosts</i>
i <i>/etc/resolv.conf</i> (Netscape w OpenBSD mo¿e czasami mieæ takie problemy
poniewa¿ ko¿ysta z w³asnej implementacji resolvera zamias korzystaæ 
z funkcji <i>gethostbyname(3)</i>.)
</ul>

<p>
Innym przypadkiem wartym rozwa¿enia jest prêdko¶æ dzia³ania. Poniewa¿
rozwi±zywanie nazwy hosta jest procesem interaktywnym, w którym serwer 
nazw odpytuje inne serwery, operacja zamiany nazwy na adres mo¿e potrwaæ
je¶li masz modemowe po³±æzenie do Internetu i wysy³asz zapytanie do 
w³asnego serwera DNS o adres zewnêtrzny (Twój serwer zacznie odpytywaæ
inne serwery poprzez modem), powiniene¶ korzystaæ z serwera nazw Twojego
ISP (który prawdopodobnie ma szybsze po³±czenie do innych serwerów).

<p>
<h3>6.8.3 Z jakich komponentów sk³ada siê serwer DNS?</h3>

<ul>
<li>named <i>("name daemon")</i>
<li>Pliki konfiguracyjne znajduj± siê w drzewie katalogów <i>/var/named/</i>
</ul>

<p>
<h4>6.8.3.1 Które wersje BIND s± wspierane?</h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
BIND jest nazw± specyfikacji serwera nazw domenowych. Komponenty
serwera nazw wspólnie tworz± system BIND.

<p>
S± trzy wersje specyfikacji BIND:

<ol>
<li>BIND 4
<li>BIND 8
<li>BIND 9
</ol>

<p>
W OpenBSD demon <b>named</b> wspiera BIND w wersji 4.x.

<p>
<h4>6.8.3.2 Jakie s± alternatywy udostêpniania DNS korzystaj±c
z innych wersji implementacji BIND?</h4>
<!-- XXXexpires - goes away when 3.2 becomes unsupported -->

<ul>
<li>BIND w wersji 9.x mo¿esz znale¼æ w <i>/usr/ports/net/bind9</i>.(Zobacz
<a href="../../pl/ports.html">ports</a>)
</ul>

<p>
<h5>6.8.3.2.1 <u>Bezpieczeñstwo</u> - uwagi</h5>

<p>
Je¶li korzystasz z alternatywnych implementacji BIND, pamiêtaj ¿e robisz to
na w³asne ryzyko i ¶wiadomie rezygnujesz z oprogramowania które przesz³o
testy bezpieczeñstwa 
<a href="http://www.openbsd.org/security.html">security-audit</a>
- demona <b>named</b> ze standardowej instalacji.
<p>

<h3>6.8.4 Co muszê zainstalowaæ?</h3>

<p>
W zasadzie nic - je¶li podczas konfiguracji sieci w trakcie instalacji 
systemu nie pope³ni³e¶ ¿adnych b³êdów, wszystkie potrzebne sk³adniki
masz juz zainstalowane w systemie. Jedyne co Ci pozostaje to skonfigurowanie
demona nazw ("<tt>named</tt>").

<p>
<h3>6.8.5 Jak skonfigurowaæ DNS?</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
W OpenBSD konfigurujesz DNS poprzez edycjê i/lub tworzenie plików konfiguracyjnych
demona <tt>named</tt>. Zwykle znajduj± siê one w katalogu <i>/var/named</i> i jego
podkatalogach, w szczególno¶ci plik <i>/var/named/named.boot</i> który jest
plikiem inicjalizacyjnym dla <b>named</b>. Ponadto w katalogu <i>/etc</i> musisz
wykonaæ kilka innych operacji konfiguracyjnych.

<p>
W tym przyk³adzie skonfigurujemy demona nazw na <i>nemo.yewtopia.com</i>
tak aby by³ podstawowym serwerem nazw dla (bardzo ma³ej!) domeny
<i>yewtopia.com</i>. Adres <i>nemo.yewtopia.com</i> to <i>192.168.1.9</i>.
Dwa ine komputery w podsieci to <i>crater.yewtopia.com</i> maj±cy adres
192.168.1.1 i <i>earhart.yewtopia.com</i> z adresem 192.168.1.2.

<p>
<h4>6.8.5.1 Konfiguracja w katalogu <i>/var/named</i></h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<blockquote><pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain   source host/file backup file
cache     .	   root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre></blockquote>

<p>
Powy¿szy fragment mówi procesowi inicjalizuj±cemu w którym podkatalogu
i pod jakimi nazwami ma szukaæ plików konfiguracyjnych dla <i>yewtopia.com</i>.

<p>
<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<blockquote><pre>
; Reverse lookup for localhost interface
@       IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre></blockquote>

<p>
<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<blockquote><pre>
; yewtopia.com domain database
@      IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre></blockquote>

<p>
<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<blockquote><pre>
; yewtopia domain reverse lookup database
@      IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre></blockquote>

<p>
<h4>6.8.5.2 Konfiguracja w katalogu <i>/etc</i></h4>

<p>
<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>

<p>
Upewnij siê ¿e plik <i>/etc/resolv.conf</i> zawiera informacje o domenie
lokalnej komputera (zamiast np. serwera nazw Twojego ISP) czyli nazwy 
domeny któr± aktualnie konfigurujesz aby by³a serwowana przez <b>named</b>.

<blockquote><pre>
domain yewtopia.com
lookup file bind
</pre></blockquote>

<p>
<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>
Je¶li wcze¶niej dodawa³e¶ wpisy o innych komputerach do pliku 
<i>/etc/hosts</i> mo¿esz teraz skróciæ go do domy¶lnej zawarto¶ci:

<blockquote><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></blockquote>

<p>
Teraz <b>named</b> nie bêdzie korzysta³ z (mog±cych byæ ju¿ nieaktualnymi)
adresów w pliku <i>/etc/hosts</i>. <u>Upewnij siê czy posiadasz w <i>/etc/hosts</i>
przynajmniej wpis <i>localhost</i></u>. Jest on niezbêdny do poprawnego 
zainicjowania sieci! Tak¿e nazwa <i>nemo</i> powinna siê pojawiæ w swoim w³asnym
pliku hostów, w przeciwnym razie uj¿ysz seriê b³êdów podczas uruchamiania
systemu gdy <i>/etc/netstart</i> wywo³uje
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>
aby dodaæ wpis <i>nemo</i> (który pojawia siê w <i>/etc/myname</i>).

<p>
<h4>6.8.5.3 Korzystanie z  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
 do wy¶wietlenia wyników konfiguracji.</h4>

<blockquote><pre>
$ <strong>dig @nemo.yewtopia.com yewtopia.com any any</strong>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia.com, type = ANY, class = ANY

;; ANSWERS:
yewtopia.com.   3600    SOA    nemo.yewtopia.com.  your_id.nemo.yewtopia.com. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.com.   3600    NS      nemo.yewtopia.com.

;; ADDITIONAL RECORDS:
nemo.yewtopia.com.  3600    A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.com  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre></blockquote>

<p>
<h3>6.8.6 Jak i kiedy uruchamiaæ i zatrzymywaæ?</h3>

<p>
<h4>6.8.6.1 Uruchamianie DNS</h4>

<p>
Demon <b>named</b> uruchamiany powinien byæ w momencie uruchamiania systemu przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc</a>
je¶li poni¿szy wiersz znajduje siê domy¶lnie w 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf</a>.

<blockquote><pre>
named_flags=NO          # for normal use: ""
</pre></blockquote>

<p>
i jest zmodyfikowany do postaci

<blockquote><pre>
named_flags=""          # for normal use: ""
</pre></blockquote>

<p>
Ponadto zwróæ uwagê na inne linie w /etc/rc.conf:

<blockquote><pre>
named_user=named                # Named nie powinien byæ uruchamiany i pracowaæ z uprawnieniami roota
named_chroot=/var/named         # Gdzie zamkn±æ (chroot) named`a
</pre></blockquote>

<p>
Te domy¶lne opcje bêd± dobre dla wiêkszo¶ci konfiguracji.

<p>
Aby uruchomiæ <b>named</b> "z palca" skorzystaj z komendy 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a>.
Dla przyk³adu:

<blockquote><pre>
# <strong>ndc start</strong>
          lub
# <strong>ndc restart</strong>
</pre></blockquote>

<p>
<h4>6.8.6.2 Zatrzymywanie DNS</h4>

<p>
Najlepsz± metod± na zatrzymanie demona nazw jest u¿ycie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a>. 
Przyk³ad:

<blockquote><pre>
# <strong>ndc stop</strong>
</pre></blockquote>

<p>
Je¶li to nie zadzia³a, znajd¼ id procesu named i u¿yj polecenia
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">kill(1)</a>
aby zakoñczyæ ten proces. Numer PID dla demona <i>named</i> gdy jest on
uruchomiony znajduje siê w pliku
<i>/var/named/named.pid</i>

<blockquote><pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</pre></blockquote>

<p>
<h4>6.8.6.3 Restartowanie DNS z uaktualnion± konfiguracj±</h4>

<p>
Aby zmusiæ uruchomionego named`a do restartu i ponownego przeczytania 
plików konfiguracyjnych wy¶lij do niego sygna³ "hangup":

<blockquote><pre>
# <strong>kill -HUP 4608</strong> 
</pre></blockquote>

<p>
lub u¿yj komendy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a> 
w poni¿szy sposób:

<blockquote><pre>
# <strong>ndc reload</strong>
</pre></blockquote>

<p>
<h3>6.8.7 Jak blokowaæ zapytania AXFR? </h3>

<p>
przyk³ad:

<blockquote><pre>
garden:/home/jeremy$<strong>  host -l openssh.com</strong>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></blockquote>

<p>
Ta informacja u¿yteczna jest w przyadku debugowania swojej konfiguracji
DNS, w kilku przypadkach mo¿esz nie chcieæ publikowania tych informacji 
publicznie. Je¶li u¿ywasz bezklasowej zwrotnej delegacji in-addr (rfc2317),
host -l mo¿e wy¶wietliæ informacje o ka¿dej domenie któr± Twój host utrzymuje!
Mo¿esz zaradziæ temu w bardzo prosty sposób - dodaj±c opcjê 'allow-transfer'
w Twoich pliku stref.

<br><br>

Je¶li u¿ywasz BIND`a 8 musisz wyspecyfikowaæ kosty, którym chcesz zzwoliæ
na transfer stref indywidualnie w plikach stref:

<blockquote><pre>
zone "foo.com" in {
        type master;
        file "directory/zonefile";
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></blockquote>

<p>
Mo¿esz tak¿e zablokowaæ transfer dla wszystkich domen, poprzez edycjê 
/var/named.conf i dodaæ parametr 'allow-transfer' w sekcji 'options'
pliku konfiguracyjnego:

<blockquote><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></blockquote>

<p>
Ta metoda dzia³a równie¿ w implementacji BIND 9.<br>
Je¶li korzystasz z BIND 4 (domy¶lny w OpenBSD), mo¿esz wyedytowaæ 
/var/named/named.boot i skorzystaæ z opcji 'xfrnets'.

<blockquote><pre>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></blockquote>

<p>
BIND 4 zezwala na transfer stref ze wszystkich klas, wiêc nie dzia³a
to dok³adnie tak samo. Zazwyczaj, jedynymi hostami które powinny mieæ
mo¿liwo¶æ transferu s± Twoje zapasowe (slave) serwery DNS oraz hosty
z których zamierzasz debugowaæ konfiguracjê (np. 127.0.0.1). Zablokowanie
zapytañ AXFR dodaje dodatkowy poziom prywatno¶ci, ale mo¿e przeszkadzaæ
w uzyskiwaniu informacji debuguj±cych. (Dziêki
<a href="mailto:ntang@nachtwache.org">Nicholas Tang</a> za tê podpowied¼)

<p>
<h3>6.8.8 Czego jeszcze nie wiem o konfiguracji DNS?</h3>

<p>
Naprawdê ca³ej masy rzeczy, dla przyk³adu, w jaki sposób skonfigurowaæ DNS
tak, aby zapytania o domenê intranetow±, która nie jest widzialna z g³ównej
hierarchii domenowej zosta³y przekierowane do serwerów wewn±trz Twojego
przedsiêbiorstwa. Przeczytaj
<a href="#DNS.1.1">rekomendowane dokumenty</a> aby znale¼æ wiêcej informacji o DNS.


<p>
<a name="PPTP"></a>
<a name="6.9"></a>
<h2>6.9 - Konfigurowanie po³±czenia  PPTP w OpenBSD</h2>

<p>
<strong>UWAGA:</strong> Poni¿sze informacje nie bêd± odpowiednie dla po³±czeñ
do <strong>WSZYSTKICH</strong> providerów ADSL, aczkolwiek wiêkszo¶æ informacji
i ustawieñ jest podobnych. Konfiguracja ta stworzona zosta³a i dzia³a dla 
<a href="http://www.inode.at">Inode</a>, dostawcy ADSL w Austrii.

<p>
Aby rozpocz±æ, musisz zainstalowaæ pptp. Odpowiedni port znajdziesz w
<i>/usr/ports/net/pptp</i>. Przeczytaj <a href="../faq8.html#Ports">FAQ 8, 
Porty</a> dla zdobycia wiêcej informacji o drzewie portów w OpenBSD.

<p>
Poniewa¿ istnieje konflikt pomiêdzy obs³ug±
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre(4)</a>
w j±rze a pptp, bêdziesz musia³ przekompilowaæ swoje j±dro, usuwaj±c
wsparcie dla gre(4).

<blockquote>Patch to remove GRE(4) support.
<pre>
Index: GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.86
diff -u -r1.86 GENERIC
--- GENERIC     14 Mar 2002 00:42:25 -0000      1.86
+++ GENERIC     17 May 2002 01:52:17 -0000
@@ -87,7 +87,7 @@
 pseudo-device  enc     1       # option IPSEC needs the encapsulation interface
 pseudo-device  bridge  2       # network bridging support
 pseudo-device  vlan    2       # IEEE 802.1Q VLAN
-pseudo-device  gre     1       # GRE encapsulation interface
+#pseudo-device gre     1       # GRE encapsulation interface
 #pseudo-device strip   1       # Starmode Radio IP interface

 pseudo-device  pty     64      # pseudo-terminals
</pre></blockquote>

<p>
Aby przekompilowaæ j±dro, zajrzyj do ¼róde³ OpenBSD przez cvs (je¶li
nie czujesz siê pewnie z cvs zajrzyj na stronê
<a href="../../pl/anoncvs.html">AnonCVS</a> po wiêcej informacji), na³ó¿
podany patch i przekompiluj j±dro tak jak zosta³o to opisane w 
<a href="faq5.html#Building">FAQ 5, Budowanie j±dra</a>.

<p>
Gdy masz ju¿ zainstalowene <b>pptp</b> oraz nowe j±dro, mo¿esz przyst±piæ
do edycji plików konfiguracyjnych dla swojego po³±czenia. Pakiet ten jest
podobny do powszechnie u¿ywanego w OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>,
wiêc je¶li nie jeste¶ obeznany z ppp(8), po wiêcej informacji zg³o¶ siê do
<a href="#PPP">FAQ 6, PPP</a>.

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
Je¶li chodzi o plik <i>/etc/ppp/options</i>, poni¿sza konfiguracja bêdzie
odpowiednia dla wiêkszo¶ci przypadków:

<blockquote><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></blockquote>

<p>
W miejsce <tt>LOGINNAME</tt> wpisz swoje dane.

<p>
Plik <i>/etc/ppp/pap-secrets</i> powinien zawieraæ liniê podobn± do tej:

<blockquote><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></blockquote>

<p>
Gdzie LOGINNAME to Twoja nazwa u¿ytkownika przyznana przez dostawcê ADSL,
a PASSWORD to has³o odpowiadaj±ce loginowi. 10.0.0.138 to adres IP
przydzielony Twojemu MODEMOWI. Upewnij siê aby ten plik mia³ prawo odczytu
tylko dla u¿ytkownika root (tryb 600).

<p>
<h3>6.9.1 - Przypisywanie adresu do interfejsu sieciowego</h3>

<p>
W powy¿szym przyk³adzie, nasz modem mia³ prekonfigurowany interfejs
adresem 10.0.0.138. Teraz, musimy przypisaæ adres NASZEMU interfejsowi,
nejlepiej u¿yæ adresu blisiego adresowi modemu, lub skorzystaæ ze statycznego
IP przydzielonego Tobie. Wiêcej o konfiguracji interfejsów dowiesz siê z
<a href="#Setup">FAQ 6, Setup</a>.

<p>
Gdy interfejs jest ju¿ aktywny, powinno udaæ siê utworzyæ po³±czenie pptp
komend±:

<blockquote><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &amp;</strong>
</pre></blockquote>

<p>
Poniewa¿ wykorzystuje ona OpenBSD ppp(8), uruchomione zostaj± dwa procesy,
mo¿esz zakoñczyæ pptp w poni¿szy sposób:

<blockquote><pre>
# <strong>kill -9 [pid of pppd]</strong>
$ <strong>kill -9 [pid of pptp]</strong>
</pre></blockquote>

<p>
Je¶li wyst±pi³y jakie¶ problemy, otwórz <tt>/var/log/messages</tt> i spróbuj
je zlokalizowaæ.

<blockquote>
<pre>
# <strong>tail -f /var/log/messages</strong>
</pre></blockquote>

<p>
Mo¿esz tak¿e umie¶ciæ komendê startuj±ca pptp w pliku <i>/etc/rc.local</i>
aby ³±czyæ siê automatycznie przy starcie.


<a name="Bridge"></a>
<h2>6.10 - Konfiguracja sieciowego bridge`a w OpenBSD</h2>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">Bridge</a>
jest pomostem ³±cz±cym dwie lub wiêcej odseparowanyh od siebie sieci.
W przeciwieñstwie do routera, bridge jest logicznie "niewidzialny", 
dwa segmenty sieci my¶l± ¿e tworz± jeden segment z hostami po drugiej
stronie bridge`a. Bridge bêdzie jedynie przekazywa³ pakiety pomiêdzy 
segmentami sieci i umo¿liwia ³atwy i bezpo¶redni dostêp do zasobów 
pomiêdzy hostami znajduj±cymi siê w odrêbnych segmentach sieci.

<p>
Pamiêtaj, ¿e ze wzglêdy na swój "niewidzialny" charakter dzia³ania,
interfejs sieciowy bridge`a mo¿e posiadaæ (lub nie) indywidualny
adres IP. Je¶li tak, interfejs ma dwa typy pracy, jeden jako bridge, 
drugi jako zwyk³y standardowy interfejs sieciowy. Je¶li interfejs nie posiada
adresu IP, bridge bêdzie przekazywa³ pakiety, jednak nie bêdzie 
dostêpny z zewn±trz.

<p>
<h3>Przyk³ad bridge`a</h3>

<p>
Posiadam zbiór starych systemów komputerowych, ¿aden z nich nie ma wbudowanego
interfejsu 10BASE-TX. Posiadaj± natomiast ³±cza AUI lub AAUI. Jedn± z maszyn
jest terminal serwerowy z OpenBSD, maj±cy sta³e szybkie po³±czenie z tak±
sam± sieci±. Dodanie kolejnego interfejsu z portem coax pozwoli na wykorzystanie
tej maszyny jako bridge`a pomiêdzy sieciami coax.

<p>
System ten, posiada dwa interfejsy, Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
i kartê 3c590-Combo  
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
dla portu coax. <tt>fxp0</tt> jest interfejsem pod³±czonym do pozosta³ej
czê¶ci sieci, a zatem bêdzie mieæ przypisany adres IP, <tt>ep0</tt>
bêdzie tworzyæ bridge bez przypisanego adresu IP. Hosty pod³±czone
do segmentu coax bêd± mog³y siê ze sob± komunikowaæ tak jakby by³y 
w drugiej czê¶ci sieci. Jak do tego dojdziemy?

<p>
Plik <tt>hostname.fxp0</tt> zawiera konfiguracjê interfejsu <tt>fxp0</tt>.
Korzysta on z informacji dostarczanych przez DHCP, wiêc plik wygl±da 
w poni¿szy sposób:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

<p>
Bez niespodzianek.

<p>
Karta <tt>ep0</tt> posiada nieco inn± konfiguracjê:

<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

<p>
Instruujemy system, aby aktywowa³ interfejs korzystaj±c z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
i ustawi³ tryb pracy na 10BASE-2 (coax). Nie przypisujemy do interfejsu
adresu IP, ani ¿adnych podobnych informacji. Opcje kart <tt>ep</tt>
znajdziesz w <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">man page</a>.

<p>
Teraz musimy uruchomiæ bridge. Inicjalizujemy go, poprzez plik konfiguracyjny
nazwany w stylu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
A oto i jego przyk³adowa zawarto¶æ:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

<p>
Oto ca³a filozofia tworzenia bridge`a sk³adaj±cego siê z dwóch interfejsów
sieciowych fxp0 i ep0 oraz jego aktywacji. Czy jest istotna kolejno¶æ w 
jakiej to robimy ? Nie, nale¿y bowiem pamiêtaæ, ¿e bridge jest symetryczny - 
pakiety wêdruj± w obu kierunkach.

<p>
To ju¿ wszystko! Uruchom ponownie system i ciesz siê funkcjonalno¶ci±
swojego bridge`a.

<p>
<h3>Filtrowanie pakietów w systemie z bridge`m</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

Czêsto, nawet podczas u¿ywania tak prostego bridge`a jak ten, mo¿e zaj¶æ
potrzeba zrobienia CZEGOKOLWIEK z pakietami wêdruj±cego przez niego.
Jak pewnie siê domy¶lasz, <a href="#PF">Filtr Pakietów</a> potrafi
doskonale sobie z tym radziæ i kontrolowaæ ruch wêdruj±cy poprzez
bridge.

<p>
Uwa¿aj, pamiêtaj±c o dwukierunkowej naturze bridge`a, o tym ¿e czê¶æ
danych wêdruje poprzez dwa interfejsy, tak wiêc wystarczy, gdy bêdziesz
je filtrowa³ na jednym z nich. Twóje domy¶lne regu³ki "Pass all" mog±
wygl±daæ w ten sposób:

<blockquote>
<pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre>
</blockquote>

<p>
Teraz, powiedzmy ¿e chcia³bym filtrowaæ ruch wêdruj±cy z/do starych maszyn,
które wymieni³em powy¿ej. Chcê zezwoliæ im na korzystanie jedynie z us³ug www
oraz SSH. W tym przypadku, zezwalamy na przemieszczanie siê pakietów w obu kierunkach
poprzez interfejs ep0, natomiast filtrowania dokonujemy na interfejsie fxp0,
u¿ywaj±c opcji keep state do przechwytywania powracaj±cych danych:

<blockquote>
<pre>
# Przepu¶æ ca³y ruch przez ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Zablokuj ca³y ruch na interfejsie fxp0
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

<p>
Zauwa¿ ¿e ten zestaw regu³ek, zablokuje wszystko za wyj±tkiem ruchu HTTP i SSH
przed dotarciem zarówno do naszego bridge`a jak i ka¿dego hosta "za nim".
Inne rezultaty mo¿esz osi±gn±æ filtruj±c ruch na drugim interfejsie.

<p>
Do monitorowania i kontrolowania utworzonego bridge`a, korzystaj z 
komendy
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
która mo¿e byæ równie¿ u¿ywana do stworzenia bridge`a.

<p>
<h3>Uwagi na temat bridge`a</h3>

<ul>
<li>Jest BARDZO zalecane, aby¶ filtruj±c pakiety, robi³ to na tylko
jednym interefjsie. Je¶li uwa¿asz ¿e musisz filtrowaæ dwa interfejsy,
upewnij siê ¿e naprawdê rozumiesz to co robisz.

<li>Poprzez u¿ycie opcji<i>blocknonip</i> komendy 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
lub podanie jej w 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">bridgename.bridge0</a>,
mo¿esz zablokowaæ ka¿dy ruch za wyj±tkiem IP (jak nt IPX czy NETBEUI)
przed przedostanie siê przez Twój filtr. Mo¿e to byæ bardzo pomocne
w kilku przypadkach, pamiêraj bowiem ¿e bridge pracuje z ka¿dym protoko³em
nie tylko IP.

<li>Bridge wymaga aby interefjsy sieciowe pracowa³y w trybie "promiscuous"
-- nas³uchuj± ka¿dy ruch w sieci, nie tylko ten przeznaczony do nich samych.
Powoduje to wiêksze obci±¿enie procesora i magistrali systemowej.
Niektóre karty maj± problemy z prac± w tym trybie, dla przyk³adu
chipy TI ThunderLAN - 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
s± przyk³adem urz±dzenia które nie mo¿e pracowaæ jako czê¶æ bridge`a. 
</ul>


<p>
<font color="#0000e0">
<a href="index.html">[Spis tre¶ci]</a>
<a href="faq5.html">[Sekcja 5 - Konfiguracja j±dra i dysków]</a>
<a href="faq7.html">[Sekcja 7 - Ustawienia klawiatury i wy¶wietlania]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Orginally [OpenBSD: faq6.html,v 1.169 ]<br>
$Translation: faq6.html,v 1.3 2003/05/09 15:15:26 pl-team Exp $<br>
$OpenBSD: faq6.html,v 1.3 2003/05/10 13:39:27 jufi Exp $
</small>

</body>
</html>
