<html>
<head>
<title>OpenBSD FAQ: 10.0 - System Administration</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998,1999 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">
<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq9.html">[To Section 9.0 - Migrating from Linux]</a>
<a href= "faq24.html">[To Section 11.0 - OpenBSD 2.4 Specific Information]</a>
</font>
</p>

<p>
<h1>10.0 - System Administration</h1>
<hr>
</p>

<p>
<a name= "10.1">
<h2>10.1 - Why does it say that I'm in the wrong group when I try to su root?</h2>
</a>
</p>

<p>
Existing users must be added to
the <kbd>&quot;wheel&quot;</kbd> group by hand. This is done for security reasons, and you should be cautious with whom you give
access to. On OpenBSD, users who are in the <kbd>wheel</kbd> group are allowed to use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&apropos=0&sektion=1&format=html">
su(1)</a> userland program to become root. Users who are not in <kbd>&quot;wheel&quot;</kbd> cannot use su(1). Here is
an example of a <kbd>/etc/group</kbd> entry to place the user <strong>ericj</strong> into the
<kbd>&quot;wheel&quot;</kbd> group.
<P>
If you are adding a new user with <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&apropos=0&sektion=8&format=html">adduser(8)</a>,
you can put them in the wheel
group by answering wheel at <tt>Invite <i>user</i> into other groups:</tt>
This will add them to /etc/group, which will look something like this:
</p>

<ul>
<pre>
wheel:*:0:root,ericj
</pre>
</ul>

<p>
If you are looking for a way to allow users limited access to superuser privileges, without putting them in the
<kbd>&quot;wheel&quot;</kbd> group, use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&sektion=8&format=html">sudo(8)</a>.
</p>

<p>
<a name= "10.2">
<h2>10.2 - How do I duplicate a filesystem?</h2>
</a>
</p>

<p>
To duplicate your filesystem use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a> and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a>. For example. To duplicate
everything under directory <kbd>SRC</kbd> to directory <kbd>DST</kbd>, do a:
</p>

<ul>
<pre>
# <strong>cd /SRC; dump 0f - . | (cd /DST; restore -rf - )</strong>
</pre>
</ul>
<p>
dump is designed to give you plenty of backup capabilities, and it may be an overkill
if you just want to duplicate a part of a (or an entire) filesystem.
The command <A 
HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&sektion=1&format=html">tar(1)</a>
may be faster for this operation.  The format looks very similar:
<UL>
<PRE>
# <strong>cd /SRC; tar cf -  . | (cd /DST; tar xpf - )</strong>
</UL>
</PRE>
<BR>

<p>
<a name="10.3">
<h2>10.3 - How do I get httpd, sendmail, etc to startup with the
system?</h2>
</a>
</p>

<p>
OpenBSD uses rc-style startup to control starting applications with the
system. For common daemons you can simply edit 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/rc.conf?rev=1.35">/etc/rc.conf</a>.
<br>
For example: To have ftpd started on boot change the ftpd entry from:
<ul>
<tt>
ftpd_flags=NO<bR>
</tt>
</ul>

to:

<ul>
<tt>
ftpd_flags="-D"
</tt>
</ul>
</p>


<p>
You can add any flags that you wish ftpd to start with.
</p>

<p>
If you have your own daemons that you want to be started, here is a
simple entry that you can put into /etc/rc.local.

<ul>
<pre>
if [ -x /usr/local/sbin/mydaemon ]; then
        echo -n ' mydaemon';       /usr/local/sbin/mydaemon
fi
</pre>
</ul>

Once in there, it will come up with the system each time.
</p>

<p>
<a name="10.4">
<h2>10.4 - Why do users get relaying access denied when they are remotely sending mail through my OpenBSD system?</h2>
</a>
</p>

<p>
Try this:
</p>
<ul>
<pre>
# <strong>cat /etc/sendmail.cf | grep relay-domains</strong>
</pre>
</ul>
<p>
The output may look something like this:
</p>
<ul>
<pre>
FR-o /etc/mail/relay-domains
</pre>
</ul>
<p>
If this file doesn't exist, create it.  You will need to enter the users
who are sending mail remotely with the following syntax:
</p>
<ul>
<pre>
.domain.com    #Allow any <xyz>.domain.com user to send mail through us
sub.domain.com #Allow sub.domain.com to send mail through us
</pre>
</ul>
<p>
Don't forget send a 'HangUP' signal to sendmail, (a signal which
causes most daemons to re-read their configration file):
</p>
<ul>
<pre>
# <Strong>kill -HUP `cat /var/run/sendmail.pid`</strong>
</pre>
</ul>
<br>
<p>
<a name="10.5">
<h2>10.5 - I've set up POP, but users have trouble accessing mail thru POP. What can I do?</h2>
</a>
</p>

<p>
Most issues dealing with POP are problems with temporary files and lock files.
If your pop server sends an error message such as:
</p>
<ul>
<pre>
-ERR Couldn't open temporary file, do you own it?
</pre>
</ul>
<p>
Try setting up your permissions as such:
<ul>
<pre>
permission in  /var
drwxrwxr-x   2 bin     mail     512 May 26 20:08 mail


permissions in  /var/mail
-rw-------   1 username   username        0 May 26 20:08 username
</pre>
</ul>
<p>
Another thing to check is that the user actually owns their own /var/mail file.
Of course this should be the case (as in, /var/mail/joe should be owned by joe)
but if it isn't set correctly it could be the problem!
<P>
Of course, making /var/mail writeable by group mail opens up some vague and
obscure security problems.  It is likely that you will never have problems
with it.  But it could (especially if you are a high profile site, ISP,...)!
Try running cucipop or another POP daemon from the OpenBSD ports collection.
Or, you could just have the wrong options selected for your pop daemon
(like dot locking).  Or, you may just need to change the directory
that it locks in (although then the locking would only be valueable for the
POP daemon.)
</p>

<p>
<a name="10.6">
<h2>10.6 - Setting up a Secure HTTP server with SSL(8)</h2>
</p>

<p>
This will take you through all the steps it takes to set up your own
Secure HTTP server. Since the OpenBSD 2.5 release, OpenBSD has shipped
with SSLeay. Because of patented RSA algorigthms, these cannot be
shipped with OpenBSD. libssl includes support for SSL version 2, SSL
version 3, and TLS version 1. So for now, because of patent
restictions, OpenBSD must ship without a fully-functional libssl. But it
is still completely useable. If you are able to use the RSA patented
libraries, you can easily upgrade your libssl with a command like this.
</p>
<ul>
<kbd># <strong>pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/</strong>${ver}<strong>/packages/</strong>${arch}<strong>/libssl-1.1.tgz</strong> </kbd>
</ul>
Where ${ver} is the OpenBSD version number, and ${arch} is your
architecture.
</p>

<p>
The steps shown here are taken in part from the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&apropos=0&sektion=8&format=html">ssl(8)</a>
man page. Refer to it for further information. This FAQ entry
only outlines how to creating an RSA certificate for web servers, not a DSA
server certificate. To find out how to do so, please refer to the ssl(8)
man page.
</p>

<p>
Here is how you create your server key and certificate. These will go to
<strong>/etc/ssl/private/</strong>. To use the RSA features, you must have
upgraded your libssl. Now you can create your key.  Using ssleay,
</p>

<ul>
<pre># <strong>ssleay genrsa -out /etc/ssl/private/server.key 1024</strong>
</pre>
</ul>

<p>
This will create a key of 1024 bits. Next you need to create a
<strong>Certificate Signing Request</strong> which is used to get a
<strong>CA</strong> or <strong>Certificate Authority</strong> to sign your
key. Here is the command to do so.
</p>

<ul>
<strong># ssleay req -new -key /etc/ssl/private/server.key -out /etc/ssl/private/server.csr</strong>
</ul>

<p>
You would now give /etc/ssl/private/server.csr to the <strong>CA</strong>
to get it signed. Or you could also sign the certificate for yourself.
Here is how you would do this.
</p>

<ul>
<strong># ssleay x509 -req -days 365 -in /etc/ssl/private/server.csr -signkey /etc/ssl/private/server.key -out /etc/ssl/server.crt</strong>
</ul>

<p>
This will sign your key, and it will be valid for up to 365 days. With
this done you can now start the httpd server. To start httpd(8) with ssl
you must start the daemon with the -DSSL flag. You can start this on boot
in <strong>/etc/rc.conf</strong> by changing the httpd line to look like
so:
</p>

<ul>
<pre>
httpd_flags="-DSSL"
</pre>
</ul>

<p>
This server will run on port 443.
</p>

<p>
<a name="10.7">
<h2>10.7 - I edited /etc/passwd, but the changes didn't seem to take place. Why?</h2>
</p>

<p>
If you edit /etc/passwd, your changes will be lost.  OpenBSD
generates /etc/passwd dynamically with <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=pwd_mkdb&sektion=8&apropos=0">pwd_mkdb(8)</a>.  The main password
file in OpenBSD is /etc/master.passwd.  According to pwd_mkdb(8),
<ul>
<pre>
FILES
     /etc/master.passwd  current password file
     /etc/passwd         a Version 7 format password file
     /etc/pwd.db         insecure password database file
     /etc/pwd.db.tmp     temporary file
     /etc/spwd.db        secure password database file
     /etc/spwd.db.tmp    temporary file
</pre>
</ul>
<P>
In a traditional Unix password file, such as /etc/passwd, everything
including the user's encrypted password is available to anyone on the
system (and is a prime target for programs such as Crack.)  4.4BSD
introduces the master.passwd file, which has an extended format (with
additional options beyond what was provided by /etc/passwd) and is only
readable by root.  For faster access to data, the library calls which
access this data normally read /etc/pwd.db and /etc/spwd.db.
<P>
OpenBSD does come with a tool with which you should edit your password file.
It is called vipw(8).  Vipw will use vi (or your favourite editor defined
per $EDITOR) to edit /etc/master.passwd.  After you are done editing, it will
re-create /etc/passwd, /etc/pwd.db, and /etc/spwd.db as per your changes.
Vipw also takes care of locking these files, so that if anyone else attempts
to change them at the same time, they will be denied access.
</p>

<p>
<a name="10.8">
<h2>10.8 - What is the best way to add and delete users?</h2>
</p>

<p>
The best way to add a user in OpenBSD is to use the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&sektion=8&format=html">adduser(8)</a>
script. You can configure this to work however you like by editing
<strong>/etc/adduser.conf</strong>. You can add users by hand, but this is
the recommended way to addusers. adduser(8) allows for consistancy checks
on <strong>/etc/passwd</strong>, <strong>/etc/group</strong>, and shell
databases. It will create then entries for you, and HOME directory, and
even send a message to the user welcoming them. This can be changed to
meet your needs. For further instructions on adding users read the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser_proc&sektion=8&format=html">adduser_proc(8)</a>
man page.
</p>

<p>
To delete users you should use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rmuser&sektion=8&format=html">rmuser(8)</a>
utility. This will remove all existence of a user. It will remove any
crontab(1) entries, their HOME dir (if it is owned by the user), and their mail.
Of course it will also remove their <strong>/etc/passwd</strong> and <strong>/etc/group</strong>
entries.
</p>

<p>
<a name="10.9">
<h2>10.9 - How do I create an ftp-only account?</h2>
</p>
<p>
<p>
There are a few ways to do this, but a very common way to do such is to
add /bin/false into <strong>/etc/shells</strong>. Then when you create
the user set his shell to /bin/false, they will not be able log in
interactively, but will be able to use ftp capabilities. adduser(8)
will give them a home dir by default of /home/<user>. If this is what you
desire it doesn't need to be changed, however you can set this to whatever
directory you wish.
</p>

<p>
<a name="10.10">
<h2>10.10 - Setting up Quotas</h2>
</p>

<p>
Quotas are used to limit users space that they have available to them on
your drives. It can be very helpful in situations where you have limited resources.
Quotas can be set in two different ways. 
</p>

<p>
<ul>
<li>User Quotas</li>
<li>Group Quotas</li>
</ul>
</p>

<p>
The first step to setting up quotas is to make sure that <tt>option
QUOTA</tt> is in your Kernel Configuration. This option is in the
GENERIC kernel. After this you need to mark in /etc/fstab
the filesystems which will have quotas enabled. The keywords
<tt>userquota</tt> and <tt>groupquota</tt> should be used
to mark each fs that you will be using quotas on. By default the files
<tt>quota.user</tt> and <tt>quota.group</tt> will be
created at the root of that filesystem to hold the quota information. This
default can be overwritten by doing, userquota=/var/quotas/quota.user. Or
whatever file you want to use for holding quota information. Here is an
example /etc/fstab that has one filesystem with userquotas enabled.
</p>

<ul>
<pre>
/dev/wd0a / ffs rw,userquota=/var/quotas/quota.user 1 1
</pre>
</ul>

<p>
Now it's time to set the user's quotas. To do so you use the utility
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=edquota&sektion=8&format=html">edquota(8)</a>.
A simple use is just <strong>edquota &lt;user&gt;</strong>. edquota(8)
will use vi(1) to edit the quotas unless the environmental variable
EDITOR is set to a different editor. For example:
</p>

<ul>
</pre>
# <strong>edquota ericj</strong>
</pre>
</ul>

<p>
This will give you output similar to this:
</p>

<ul>
<pre>
Quotas for user ericj:
/: blocks in use: 62, limits (soft = 0, hard = 0)
	inodes in use: 25, limits (soft = 0, hard = 0)
</pre>
</ul>

<p>
To add limits, edit it to give results like this:
</p>

<ul>
<pre>
Quotas for user ericj:
/: blocks in use: 62, limits (soft = 1000, hard = 1050)
	inodes in use: 25, limits (soft = 0, hard = 0)
</pre>
</ul>

<p>
In this the softlimit is set to 1000 blocks and the hardlimit is set to
1050 blocks. A softlimit is a limit where the user is just warned when
they cross it and have until their grace period is up to get their disk
usage below their limit. Grace periods can be set by using the
<strong>-t</strong> option on edquota(8). After the grace period is over
the softlimit is handled as a hardlimit. This usually results in an
allocation failure.
</p>

<p>
Now that the quotas are set, you need to turn the quotas on. To do
this use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quotaon&sektion=8&format=html">quotaon(8)</a>.
For example:
</p>

<ul>
<pre>
# <strong>quotaon -a</strong>
</pre>
</ul>

<p>
This will go thru /etc/fstab to turn on the filesystems with quota
options. Now that quotas are up and running, you can view them by
the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quota&sektion=1&format=html">quota(1)</a>.
Using a command of <strong>quota &lt;user&gt;</strong> will give that users
infoformation. When called with no arguments will give your quota statistics. For
example:
</p>

<ul>
<pre>
# <Strong>quota ericj</strong>
</pre>
</ul>

<p>
Will result in output similar to this:
</p>

<ul>
<pre>
Disk quotas for user ericj (uid 1001): 
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
              /      62    1000    1050              27       0       0        
</pre>
</ul>

<p>
By default quotas set in /etc/fstab will be started on boot. To turn them
off use
<ul><pre># <strong>quotaoff -a</strong></pre></ul>
</p>

<p>
<a name="10.11">
<h2>10.11 - How to Setup Kerberos Clients and Servers under OpenBSD</h2>
</p>

<p>
As a user/administrator of OpenBSD systems, you are fortunate that
KerberosIV is an pre-installed component of the default system. Here is
a guide to setting up both the Kerberos realm server, as well as a
client.
</p>

<p>
An *EXTREMELY* important point to remember is that Kerberos clients
and servers much have their system clocks synchronized. If there is
more than a 5 minute time skew, you will receive wierd errors that
do not immediately reveal themselves to be caused by time skew, such as:
</p>

<ul>
<pre>
kinit: Can't send request (send_to_kdc) 
</pre>
</ul>

Another more accurate error is:

<ul>
<pre>
kauth: Time is out of bounds (krb_rd_req) 
</pre>
</ul>

<p>
An easy way to synchronize system clocks is with xntpd, available in the ports tree at
<strong>/usr/ports/sysutils/xntpd/</strong>.
</p>

This FAQ entry assumes you have prior knowledge of the Kerberos concepts.
For a great, easy to understand, reference, see:

<ul>
<li><a href="http://www.freebsd.org/handbook/kerberos.html">The FreeBSD handbook</a> </li>
<li>Use the command <strong>info kth-krb</strong></li>
<li><a href="http://web.mit.edu/kerberos/www/dialogue.html">Designing an Authentication System: a Dialogue in Four Scenes</a></li>
<li><a href="http://web.mit.edu/kerberos/www/papers.html#krb4">Papers and Documentation Describing KerberosIV</a></li>
</ul>Or the book<ul>
<li><a href="http://www.amazon.com/exec/obidos/ASIN/0130614661/qid%3D930594963/">Network Security Private Communication in a Public World [Kaufman, Perlman, Speciner, 1995]</a></li> 
</ul>
</ul>

<h3>How to setup the Kerberos IV REALM and SERVER</h3>

<p>
We will be setting up the CIARASYSTEMS.COM realm, with avalanche.ciarasystems.com as the main server.
</p>

<p>
To start off, we will need to edit our configuration files. These files are located at <tt>/etc/kerberosIV/</tt>.
The two files we are concerned about are <i>krb.realms</i> and <i>krb.conf</i>. Lets start off with <i>krb.conf</i>.
</p>

<ul>
<pre>
[root@avalanche kerberosIV] <strong>cat krb.conf</strong>
CIARASYSTEMS.COM
CIARASYSTEMS.COM avalanche.ciarasystems.com admin server
</pre>
</ul>

<p>
As you can see, this tells kerberos that the domain is CIARASYSTEMS.COM (or logical realm) and that
within that domain, avalanche is the administration server. Next we will look at <i>krb.realms</i>. For more information
on this refer to <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=krb.conf&sektion=5&format=html">krb.conf</a>.
</p>

<ul>
<pre>
[root@avalanche kerberosIV] <strong>cat krb.realms</strong>
avalanche.ciarasystems.com      CIARASYSTEMS.COM
.ciarasystems.com               CIARASYSTEMS.COM
</pre>
</ul>

<p>
krb.realms provides a translation from a hostname to the Kerberos realm name for the services provided by that host.
Each line of the translation file is in one of the following forms (domain_name should be  of  the  form  .XXX.YYY).
So in this example, avalanche is the hostname of a computer on the CIARASYSTEMS.COM realm. And
.ciarasystems.com is the domain name on the realm CIARASYSTEMS.COM. Again, for further information read
the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=krb.realms&sektion=5&format=html">krb.realms</a>. man page.
</p>

<p>
Next we will run <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kbd_init&sektion=8&format=html">kdb_init(8)</a> 
to create the initial Kerberos database.
</p>

<ul>
<pre>
[root@avalanche kerberosIV] <strong>kdb_init</strong>
Realm name [default  NO.DEFAULT.REALM ]: CIARASYSTEMS.COM
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

Enter Kerberos master password: <strong>not shown</strong>
Verifying password -
Enter Kerberos master password:
</pre>
</ul>

<p>
Next we need to use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kstash&sektion=8&format=html">kstash(8)</a> 
which is used to save the Kerberos key distribution center (KDC) database master key in the master key cache file.
</p>

<ul>
<pre>
[root@avalanche kerberosIV] <strong>kstash</strong>
Enter Kerberos master password:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Wrote master key to /etc/kerberosIV/master_key
</pre>
This saves the encrypted master password in /etc/kerberosIV/master_key.<p>

Next, we need two principals to be added to the database for each
system that will be secured with Kerberos. Their names are
<i>kpasswd</i> and <i>rcmd</i>. These two principals are made for
each system, with the instance being the name of the individual system. 

These daemons, <i>kpasswd</i> and <i>rcmd</i> allow other systems
to change Kerberospasswords and run commands like <i>rcp, rlogin</i> 
and <i>rsh</i>. 


<pre>
# <b>kdb_edit</b>
Opening database...
    
Enter Kerberos master key:
    
Current Kerberos master key version is 1.
    
Master key entered.  BEWARE!

Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

Principal name: <strong>passwd</strong>
Instance: <strong>avalanche</strong>

&lt;Not found&gt;, Create [y] ? <strong>y</strong>

Principal: passwd, Instance: avalanche, kdc_key_ver: 1
New Password:                <strong>&lt;----- Use 'RANDOM' as password</strong>
Verifying password -
New Password:

Random password [y] ? <strong>y</strong>

Principal's new key version = 1
Expiration date (enter yyyy-mm-dd) [ 1999-12-31 ] ? <strong>2001-12-31</strong>
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.


Principal name: <strong>rcmd</strong>
Instance: <strong>avalanche</strong>

<Not found>, Create [y] ? <strong>y</strong>
Principal: rcmd, Instance: avalanche, kdc_key_ver: 1
New Password:                 <strong>&lt;----- Use 'RANDOM' as password</strong>
Verifying password -
New Password:

Random password [y] ? <Strong>y</strong>

Principal's new key version = 1
Expiration date (enter yyyy-mm-dd) [ 1999-12-31 ] ? <strong>2001-12-31</strong>
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:               <strong>&lt;----- Hit &lt;ENTER&gt; to end</strong>

</pre>
</ul>

<p>
A srvtab file is the service key file. These must be extracted from the  Kerberos key  distribution center database in
order for services to authenticate using Kerberos. For  each  hostname  specified  on
the command line, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ext_srvtab&sektion=8&format=html">ext_srvtab(8)</a>
creates the service key file hostname-new-srvtab, containing all the entries in the database with an instance field of
hostname.
</p>

<ul>
<pre>
[root@avalanche kerberosIV] <Strong>ext_srvtab avalanche</strong>

Enter Kerberos master password:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Generating 'avalanche-new-srvtab'....

[root@avalanche kerberosIV] <strong>mv avalanche-new-srvtab srvtab</strong>
[root@avalanche kerberosIV] <strong>chmod 600 srvtab</strong>
</pre>
</ul>

<p>
Now we can add users to our database.
</p>

<ul>
<pre>
[root@avalanche kerberosIV] <strong>kdb_edit</strong>
Opening database...
    
Enter Kerberos master key:
    
Current Kerberos master key version is 1.
    
Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.
    
Principal name: <strong>jeremie</strong>
Instance:
    
<Not found>, Create [y] ? <strong>y</strong>
    
Principal: jeremie, Instance: , kdc_key_ver: 1
New Password:                &lt;---- enter a secure password here
Verifying password
    
New Password:                &lt;---- re-enter the password here
Principal's new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:          &lt;---- null entry here will cause an exit
			       or you can add more entries.
</pre>
</ul>

<p>
So now all the Kerberos particulars are setup. All that is left is to enable
boot-time loading of the Kerberos server and to enable Kerberized-daemons.
</p>

<p>
In /etc/rc.conf, set:
<ul>
<tt>kerberos_server=YES</tt>
</ul>

In /etc/inetd.conf, uncomment:
<UL>
<pre>
telnet       stream  tcp     nowait  root    /usr/libexec/telnetd    telnetd -k
klogin       stream  tcp     nowait  root    /usr/libexec/rlogind    rlogind -k
kshell       stream  tcp     nowait  root    /usr/libexec/rshd       rshd -k
kauth        stream  tcp     nowait  root    /usr/libexec/kauthd     kauthd
</pre>
</ul>

Then, either reboot, or:
<ul>
<pre>
[root@avalanche /] <Strong>kill -HUP `cat /var/run/inetd.pid`</strong>
[root@avalanche /] <Strong>/usr/libexec/kerberos >> /var/log/kerberos.log &</strong>
[root@avalanche /] <strong>/usr/libexec/kadmind -n >> /var/log/kadmind.log &</strong>
</pre>
</ul>
</p>

<p>
Note: this is a rather simple server setup. Usually, redundant servers
are setup (as slave servers) so that if one server goes down, all the
services that depend on Kerberos don't go down. We can also add 'su'
privileges to a specific principal, see <a href="http://www.freebsd.org/handbook/kerberos.html#AEN4957">the FreeBSD Handbook</a>.
</p>

<h3>How to kerberize your client workstation</h3>

<p>
We will be setting the workstation named <i>gatekeeper</i> to be in the
CIARASYSTEMS.COM realm, with avalanche.ciarasystems.com as the main server.
</p>

<p>
To start off, we need to setup our <i>krb.conf</i> and <i>krb.realms</i> like the above machine. This is so
<i>gatekeeper</i> will know what server is the KDC and what domain it is on. Again here are the file contents.
</p>

<ul>
<pre>
[root@gatekeeper kerberosIV] <strong>cat krb.conf</strong>
CIARASYSTEMS.COM
CIARASYSTEMS.COM avalanche.ciarasystems.com admin server

[root@gatekeeper kerberosIV] <strong>cat krb.realms</strong>
avalanche.ciarasystems.com      CIARASYSTEMS.COM
.ciarasystems.com               CIARASYSTEMS.COM
</pre>
</ul>

<p>
Now that is set up, we need to initialize kerberos. To obtain a ticket you use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kinit&sektion=1&format=html">kinit(1)</a>.
</p>

<ul>
<pre>
xyz:jeremie% <Strong>kinit</strong>
The OpenBSD Project (gatekeeper)
Kerberos Initialization
Kerberos name: <strong>jeremie</strong>
Password:
</pre></strong>
</ul>

<p>
Now we have identified we can list our tickets with <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=klist&sektion=1&format=html">klist(1)</a>.
</p>

<ul>
<pre>
xyz:jeremie$ <strong>klist</strong>
Ticket file:    /tmp/tkt1000
Principal:      jeremie@CIARASYSTEMS.COM

  Issued           Expires          Principal
Jun 28 01:03:25  Jun 28 11:03:25  krbtgt.CIARASYSTEMS.COM@CIARASYSTEMS.COM
</pre>
</ul>

<p>
Looks like we are set now. All that's left to do is test it. Here we will test it with rlogin(1) and telnet(1).
</p>

<ul>
<pre>
xyz:jeremie% <Strong>telnet avalanche</strong>
Trying 192.168.0.38...
Connected to avalanche.
Escape character is '^]'.
[ Trying mutual KERBEROS4 ... ]
[ Kerberos V4 accepts you ]
[ Kerberos V4 challenge successful ]
Last login: Sun Jun 27 22:52:25 on ttyp1 from gatekeeper
Warning: no Kerberos tickets issued.
OpenBSD 2.5 (AVALANCHE) #5: Tue Apr  6 01:18:16 EDT 1999
</pre></ul>

and 
<ul><pre>
xyz:jeremie% <Strong>rlogin avalanche</strong>
Last login: Sun Jun 27 22:53:39 on ttyp1 from gatekeeper
Warning: no Kerberos tickets issued.
OpenBSD 2.5 (AVALANCHE) #5: Tue Apr  6 01:18:16 EDT 1999
</pre></strong>
</ul>

<p>
We can tell that it is indeed using Kerberos to authenticate the rlogin
session. To get rid of any tickets issued, you would use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kdestroy&sektion=1&format=html">kdestroy(1)</a>.
For example:
</p>

<ul>
<pre>
xyz:jeremie% <strong>kdestroy</strong>
Tickets destroyed.
xyz:jeremie% <Strong>rlogin avalanche</strong>
krcmd: No ticket file (tf_util)
rlogin: warning, using standard rlogin: can't provide Kerberos auth data.
avalanche: Connection refused
</pre>
</ul>

<p>
Do not worry about 'Warning: no Kerberos tickets issued.' This is because
we're only doing kerberos authentication, not ticket passing. If you want
ticket passing, use Dug Song's <a href="http://www.monkey.org/~dugsong/ssh-afs-kerberos.html">krb4 SSH patches</a>.
Stock KerberosIV  doesn't have support for tgt passing, either - only the AFS kaserver's implementation of krb4,
since the regular KerberosIV kdc checks client IP address listed in the ticket.
</p>

<p>
<a name="10.12">
<h2>10.12 - Setting up Anonymous FTP Services.</h2>
</p>

<p>
Anonymous FTP allows users without accounts to access files on your computer via the File Transfer Protocol. This
will give an overview of setting up the anonymous FTP server, and it's logging, etc. 
</p>

<h3>Adding the FTP account</h3>

<p>
To start off, you need to have an account on your system of ''ftp''. This account shouldn't have a useable
password, and here we will set the login directory to /home/ftp. When using anonymous ftp, the ftp daemon will
chroot itself to /home/ftp. To read up more on that, read the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&sektion=8&format=html">ftp(8)</a> and 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&sektion=2&format=html">chroot(2)</a> man pages. Here
is an example of adding the <i>ftp</i> user. I will do this using <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&sektion=8&format=html">adduser(8)</a>.
We also need to add /bin/false to our <i>/etc/shells</i>, this is the &quot;shell&quot; that we will be giving to
the ftp user. This will allow them not to login, even though we will give them an empty password. To do this you
can simply <i>echo /bin/false &gt;&gt; /etc/shells</i>. Also if you wish for that shell to show up during the adduser
questions, you need to modify <i>/etc/adduser.conf</i>.
</p>


<ul>
<pre>
oshibana# <strong>adduser</strong>
Use option ``-silent'' if you don't want see all warnings & questions.

Reading /etc/shells
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_]: <strong>ftp</strong>
Enter full name []: <strong>anonymous ftp</strong>
Enter shell csh false ksh nologin sh tcsh zsh [sh]: <strong>false</strong>
Uid [1002]:
Login group ftp [ftp]:
Login group is ``ftp''. Invite ftp into other groups: guest no
[no]: <strong>no</strong>
Enter password []:
Use an empty password? (y/n) [y]: <strong>y</strong>

Name:     ftp
Password: ****
Fullname: anonymous ftp
Uid:      1002
Gid:      1002 (ftp)
Groups:   ftp
HOME:     /home/ftp
Shell:    /usr/bin/false
OK? (y/n) [y]: <strong>y</strong>
Added user ``ftp''
Copy files from /usr/share/skel to /home/ftp
Add another user? (y/n) [y]: <strong>n</strong>
Goodbye!
</pre>
</ul>

<h3>Directory Setup</h3>

<p>
Along with the user, this created the directory <i>/home/ftp</i>. This is what we want, but there are some
changes that we will have to make to get it ready for anonymous ftp. Again these changes are explained in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&sektion=8&format=html">ftp(8)</a> man page.
</p>

<ul>
<li><i>/home/ftp</i> - This is the main directory. It should be owned by root and have permissions of 555.</li>
<li><i>/home/ftp/bin</i> - This directory will hold binaries that can be executed from within the chrooted ftpd
environment. This directory should be mode 511. Anonymous FTP only needs ls(1) to operate correctly. So you need
to copy /bin/ls to /home/ftp/bin. <i>~ftp/bin/ls</i> needs to be mode 111, which is executable only.</li>
<li><i>/home/ftp/etc</i> - Directory to hold user information. You should copy /etc/pwd.db and /etc/group to this
directory. This directory should be mode 511, and the two files should be mode 444. These are used to give owner
names as opposed to numbers. The password fields in pwd.db will not be used.</li>
<li><i>/home/ftp/pub</i> - This is the directory to place files in which you wish to share. This directory should
also be mode 555.</li>
</ul>

<p> 
Note that all these directories should be owned by ''root''. Here is a listing of what the directories should
look like after their creation.
</p>

<ul>
<pre>
oshibana# pwd 
/home
oshibana# ls -laR ftp
total 5
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 .
drwxr-xr-x  7 root  wheel  512 Jul  6 10:58 ..
dr-x--x--x  2 root  ftp    512 Jul  6 11:33 bin
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 etc
dr-xr-xr-x  2 root  ftp    512 Jul  6 11:33 pub

ftp/bin:
total 178
dr-x--x--x  2 root  ftp     512 Jul  6 11:33 .
dr-xr-xr-x  5 root  ftp     512 Jul  6 11:33 ..
---x--x--x  1 root  ftp  167936 Jul  6 11:33 ls

ftp/etc:
total 43
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 .
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 ..
-r--r--r--  1 root  ftp    316 Jul  6 11:34 group
-r--r--r--  1 root  ftp  40960 Jul  6 11:34 pwd.db

ftp/pub:
total 2
dr-xr-xr-x  2 root  ftp  512 Jul  6 11:33 .
dr-xr-xr-x  5 root  ftp  512 Jul  6 11:33 ..
</pre>
</ul>

<h3>Starting up the server and logging</h3>

<p>
With ftpd you can choose to either run it from inetd or the rc scripts can kick it off. These examples will show
our daemon being started from <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/inetd.conf">inetd.conf</a>.
First we must become familiar with some of the options to ftpd. The default line from <i>/etc/inetd.conf</i> is:
</p>

<ul><pre>
<strong>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -US</strong>
</pre></ul>

<p>
Here ftpd is invoked with <i>-US</i>. This will log anonymous connections to <i>/var/log/ftpd</i> and concurrent
sessions to <i>/var/run/utmp</i>. That will allow for these sessions to be seen via who(1). For some, you might
want to run only an anonymous server, and disallow ftp for users. To do so you should invoke ftpd with the
<i>-A</i> option. Here is a line that starts ftpd up for anonymous connections only. It also uses <i>-ll</i>
which logs each connection to syslog, along with the get, retrieve, etc, ftp commands.
</p>

<ul><pre>
<strong>ftp             stream  tcp     nowait  root    /usr/libexec/tcpd       ftpd -llUSA</strong>
</pre></ul>

<p>
Note - For people using HIGH traffic ftp servers, you might want to not invoke ftpd from inetd.conf. The best
option is to comment the ftpd line from inetd.conf and start ftpd from rc.conf along with the <i>-D</i> option.
This will start ftpd as a daemon, and has much less overhead as starting it from inetd. Here is an example line
to start it from rc.conf.
</p>

<ul><pre>
ftpd_flags="-DllUSA"           # for non-inetd use: ftpd_flags="-D"
</ul></pre>

<p>
This of course only works if you have ftpd taken out of <i>/etc/inetd.conf</i>.
</p>

<h3>Other relevant files</h3>

<p>
<ul>
<li><i>/etc/ftpwelcome</i> - This holds the Welcome message for people once they have connected to your ftp server.</li>
<li><i>/etc/motd</i> - This holds the message for people once they have successfully logged into your ftp server.</li>  
<li><i>.message</i> - This file can be placed in any directory. It will be shown once a user enters that directory.</li>
</ul>


<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq9.html">[To Section 9.0 - Migrating from Linux]</a>
<a href= "faq24.html">[To Section 11.0 - OpenBSD 2.4 Specific Information]</a>
</font>
</p>
<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq10.html,v 1.26 1999/07/23 14:02:49 ericj Exp $</small>
</p>
</body>
</html>

