<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Le réseau</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../fr/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[Index de la FAQ]</a>
<a href="faq5.html">[Section 5 - Construire le Système à partir des Sources]</a>
<a href="faq7.html">[Section 7 - Contrôles du clavier et de l'affichage]</a></font>

<h1><font color="#e00000">6 - Le réseau</font></h1>
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Remarque Importante :</font></b> Le contenu de
   ce fichier est obsolète. Consultez la version anglaise 
   <a href="../faq6.html">ici</a> pour des informations à jour.

<p>
Si vous souhaitez contribuez à l'effort de traduction,
prière de consulter
<a href="../../fr/translation.html">la page de traduction</a>.

-->
<hr>

<p>
<h3>Table des matières</h3>
<ul>
<li><a href= "#Intro" >6.1 - Avant d'aller plus loin</a>
<li><a href= "#Setup" >6.2 - Configuration initiale du réseau</a>
<li><a href= "#PF"    >6.3 - Comment filtrer et utiliser un pare-feu sous
OpenBSD ?</a>
<li><a href= "#DHCP"  >6.4 - Protocole d'attribution dynamique des adresses
(DHCP)</a>
<li><a href= "#PPP"   >6.5 - Protocole Point à Point (PPP)</a>
<li><a href= "#Tuning">6.6 - Optimisation des paramètres
réseau</a>
<li><a href= "#NFS"   >6.7 - Utilisation de NFS</a>
<li><a href= "#Bridge">6.9 - Mise en place d'un pont ("bridge") avec OpenBSD</a>
<li><a href= "#PXE"   >6.10 - Comment démarrer en utilisant PXE ?</a>
<li><a href= "#CARP">6.11 - Protocole de redondance d'adresse commune (CARP)</a>
<li><a href="#OpenNTPD">6.12 - Utiliser OpenNTPD</a>
<li><a href="#Wireless">6.13 - Quels sont les types de cartes Sans Fil
supportées par OpenBSD ?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Avant d'aller plus loin</h2>

<p>
Afin de mieux comprendre ce document, vous devriez lire et assimiler
au moins partiellement la section <a href="faq5.html">Construire le Système
à partir des Sources</a> de la FAQ ainsi que le manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>.

<p>
Si vous êtes administrateur de réseau et que vous mettez en place
des protocoles de routage, si vous utilisez OpenBSD en tant que routeur, ou si
vous souhaitez en savoir plus sur les réseaux IP, vous devriez lire "<a
href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">
Understanding IP Addressing</a>" (Comprendre l'adressage IP). Il s'agit d'un
excellent document. Vous pouvez vous appuyer sur celui-ci afin de vous aider
à travailler sur les réseaux IP, surtout si vous en avez un ou
plusieurs sous votre responsabilité.

<p>
Si vous travaillez sur des applications telles que des serveurs web, des
serveurs ftp et des serveurs de messagerie, vous pourriez
bénéficier de la <a
href="http://www.rfc-editor.org/rfc.html">lecture des RFCs</a>. A priori, vous
ne pourrez pas toutes les lire. Choisissez les sujets qui vous
intéressent ou les technologies que vous utilisez sur votre
réseau. Lisez-les et voyez comment ces technologies fonctionnent. Les
RFCs standardisent beaucoup (plusieurs milliers) de protocoles Internet et la
façon dont ils sont censés fonctionner.

<p>
<a name="Setup"></a>
<h2>6.2 - Configuration initiale du réseau</h2>

<p>
<a name="Setup.1"></a>
<h3>6.2.1 - Identifier et configurer vos interfaces réseau</h3>

<p>
Pour commencer, vous devez d'abord identifier votre interface réseau.
Sous OpenBSD, les interfaces sont nommées en fonction du type de la carte
réseau, et non en fonction du type de la connexion. Vous pouvez voir
l'initialisation de votre carte pendant la procédure de démarrage, ou après
celle-ci en utilisant la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)
</a>. Vous avez aussi la possibilité de voir votre carte réseau
grâce à l'utilisation de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Voici par exemple la sortie de la commande dmesg pour
une carte Intel Fast Ethernet qui utilise le nom de périphérique fxp.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address
00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Si vous ne connaissez pas le nom du périphérique associé à votre carte,
regardez dans la liste des <a href="../../fr/plat.html">plates-formes
actuellement supportées</a> par votre architecture. Vous pourrez y
trouver le nom des cartes les plus courantes et leur équivalent sous
OpenBSD. Ajoutez au nom alphabétique du périphérique (par exemple fxp)
le numéro assigné par le noyau et vous aurez le nom de votre interface
(par exemple fxp0).

<p>
Vous pouvez connaître quelles interfaces réseaux ont été identifiées à
l'aide de l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. La commande suivante montrera toutes les interfaces
réseau d'un système. Cet exemple montre qu'il n'y a qu'une seule
interface ethernet physique : <a href="http://www.openbsd.org/cgi-
bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a> .

<blockquote><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
Comme vous pouvez le voir, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> nous fourni ici beaucoup plus d'informations que nécessaire.
Mais nous pouvons tout de même voir notre interface. Dans l'exemple
précédent, la carte est déja configurée. Ceci est évident de part la
présence d'une configuration réseau IP pour fxp0, à savoir &quot;inet
10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;. Les indicateurs
<strong>UP</strong> et <strong>RUNNING</strong> sont également présents

<p>
Finalement, vous noterez que d'autres interfaces sont activées par
défaut. Il s'agit d'interfaces virtuelles servant différentes fonctions.
Les manuels suivants les décrivent :

<ul>
<!-- XXXrelease -->
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Interface "Loopback"
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a>
 - Interface d'enregistrement du filtre de paquet (PF)
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - Interface SLIP (protocole Internet sur ligne série)
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Protocole point à point
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Interface de tunnel
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Interface d'encapsulation
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge
</a>
 - Interface de pont Ethernet
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - Interface d'encapsulation EEE 802.1Q
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - Interface d'encapsulation GRE/MobileIP
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Interface générique de tunnel IPv4/IPv6
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp</a>
 - Interface du protocole de redondance d'adresse (CARP)
</ul>

<p>
Si votre interface n'est pas configurée, la première chose à faire est
de créer le fichier <i>/etc/hostname.xxx</i>, où "xxx" représente le nom
de votre interface. En ce basant sur les informations des exemples précédents,
le nom du fichier sera <i>/etc/hostname.fxp0</i>. Le format de ce
fichier est simple :<br>

<blockquote><pre>
address_family address netmask broadcast [autres options]
</pre></blockquote>

(Beaucoup plus d'informations sur la syntaxe de ce fichier sont disponibles dans
le manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
hostname.if(5)</a>.)

<p>
Un fichier de configuration typique pour une interface IPv4 ressemblera
à :

<blockquote><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
Vous pouvez également spécifier le type de media d'une connexion
Ethernet pour, par exemple, forcer le mode 100baseTX full-duplex.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Bien entendu, vous ne devriez jamais forcer le mode full duplex à moins
que les deux extrémités de la connexion ne soient configurées ainsi ! Si
ce n'est pour des besoins spécifiques, la configuration du type de media
n'est pas nécessaire.)

<p>
Vous pouvez aussi vouloir utiliser des indicateurs spécifiques à une
certaine interface. Le format du fichier hostname ne change que très
peu.

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
La prochaine étape consiste à définir votre passerelle par
défaut. Pour ce faire, renseignez simplement le fichier
<i>/etc/mygate</i> avec l'adresse IP de votre passerelle. Ceci permettra de
configurer automatiquement votre route par défaut au démarrage. A
présent, vous pouvez indiquer l'adresse de vos serveurs de noms et
renseigner le fichier <i>/etc/hosts</i> (voir la page de manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)
</a>). Pour configurer vos serveurs de noms, vous devez créer un fichier
nommé <i>/etc/resolv.conf</i>. Vous pouvez en savoir plus sur le format
de ce fichier dans la page de manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">
resolv.conf(5)</a>. Si vous utilisez DHCP, soyez sûr de lire <a href="#DHCP">
6.4 - DHCP</a> ainsi que le manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">
resolv.conf.tail(5)</a>. Mais pour une utilisation standard, voici un exemple.
Dans celui-ci, vos serveurs de noms sont 125.2.3.4 et 125.2.3.5. Vous faites
également partie du domaine &quot;example.com&quot;.

<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
A présent, vous pouvez soit redémarrer, soit lancer le script
<strong>/etc/netstart</strong>. Vous pouvez l'exécuter simplement en
tapant (en tant que root) :

<blockquote><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Notez que plusieurs erreurs sont apparues. En exécutant ce script, vous
reconfigurez certaines choses qui le sont déjà. De fait, certaines
routes sont déja présentes dans la table de routage du noyau. A présent,
votre système devrait être en état de fonctionnement. Une nouvelle fois,
vous pouvez vérifier que votre interface a été correctement configurée
avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Vous pouvez également vérifier vos routes via <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> ou <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)
</a>. Si vous avez des problèmes de routage, vous pouvez utiliser
l'option -n de la commande route(8) qui affichera l'adresse IP plutôt
que d'effectuer une requête DNS et d'afficher le nom d'hôte. Voici un
exemple qui vous permettra de voir vos tables de routage en utilisant
ces deux programmes.

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.2"></a>
<h3>6.2.2 - Mettre en place une passerelle OpenBSD</h3>

<p>
Voici les informations nécessaires à la mise en place d'une passerelle
OpenBSD (appelé aussi routeur). Si vous devez installer OpenBSD pour en
faire un routeur Internet, nous vous suggérons de lire les instructions
sur la mise en place du filtre de paquets (plus loin) afin de bloquer le
trafic non-autorisé. Avec le peu de disponibilité d'adresses <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a> de
la part des fournisseurs d'accès à Internet ainsi que des registres
Internet régionaux, vous pourriez vouloir vous renseigner sur la
translation d'adresses (NAT) afin d'économiser votre adressage IP.

<p>
Le noyau GENERIC est déja configuré pour permettre le routage IP,
mais celui-ci doit être explicitement activé. Vous pouvez l'activer
avec l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a>. Afin d'autoriser le routage de façon permanente,
éditez le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">
/etc/sysctl.conf</a> et ajoutez-y la ligne suivante.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Pour prendre en compte ce changement sans redémarrer, vous utiliserez
directement l'utilitaire <a href="http://www.openbsd.org/cgi-
bin/man.cgi?query=sysctl&amp;sektion=8"> sysctl(8)</a>. Souvenez-vous
que ce changement ne sera pas sauvegardé au redémarrage et que vous
devrez être root pour utiliser cette commande.

<blockquote><pre>
# <strong>sysctl net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
A présent, modifiez les routes sur les hôtes aux deux extrémités. Il
existe beaucoup d'autres usages d'OpenBSD en tant que routeur avec
l'aide de programmes comme <a href="http://www.openbgpd.org/">OpenBGPD</a>
(qui fait partie du projet OpenBSD), <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">
routed(8)</a>, <a href="http://www.mrtd.net">mrtd</a>, <a
href="http://www.zebra.org">zebra </a> et <a
href="http://www.quagga.net">quagga</a>. Sous OpenBSD, zebra et mrtd
sont disponibles en tant que ports. OpenBGPD et routed sont inclus dans
le système de base. OpenBSD supporte différentes interfaces T1, HSSI,
ATM, FDDI, Ethernet, et série (PPP/SLIP).

<p>
<a name="Setup.3"></a>
<h3>6.2.3 - Configurer les alias sur une interface</h3>

<p>
OpenBSD possède un mécanisme simple pour la mise en place d'alias
IP sur une interface. Pour ce faire, il suffit d'éditer le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
<i>/etc/hostname.&lt;if&gt;</i></a>. Ce fichier est lu au boot par le
script <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8">
/etc/netstart(8)</a> faisant partie de la séquence de démarrage <a
href="faq10.html#rc">rc</a>. Admettons par exemple qu'un utilisateur utilise
l'interface <b>dc0</b> et se trouve sur le réseau 192.168.0.0. Autres
informations importantes :

<ul>
<li>l'adresse IP pour dc0 est 192.168.0.2
<li>le masque de sous-réseau est 255.255.255.0
</ul>

<p>
Notes sur les alias. Sous OpenBSD, vous utilisez le nom de l'interface
uniquement. Il n'y a pas de différence entre le premier et le second
alias. A la différence d'autres systèmes d'exploitation, OpenBSD ne s'y
réfère pas en tant que dc0:0, dc0:1. Si vous vous référez à une adresse
IP d'alias avec ifconfig ou si vous ajoutez un alias, soyez sûr
d'utiliser la commande "<tt>ifconfig int alias</tt>" au lieu de
"<tt>ifconfig int</tt>". Vous pouvez supprimer les alias en utilisant
"<tt>ifconfig int delete</tt>".

<p>
En admettant que vous utilisiez plusieurs adresses avec alias sur le
même sous-réseau IP, le masque correspondant à chaque alias devient
255.255.255.255. Il n'est pas nécessaire d'utiliser le masque
correspondant à l'adresse IP primaire de l'interface. Dans cet exemple,
<i>/etc/hostname.dc0</i>, deux alias sont configurés pour le
périphérique dc0, qui lui-même possède l'adresse 192.168.0.2 avec un
masque de 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Après avoir édité ce fichier, il suffit de redémarrer pour que les
changements prennent effet. Mais vous pouvez aussi créer les alias à la
main en utilisant l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Pour créer le premier alias, lancez la commande
suivante :

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
Pour voir les alias, utilisez la commande suivante :

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="NAT"></a>
<a name="PF"></a>
<h2>6.3 - Comment filtrer et utiliser un pare-feu sous OpenBSD ?</h2>
Sous OpenBSD, le filtrage du trafic TCP/IP ainsi que la translation
d'adresses (NAT) est pris en charge par "Packet Filter" (filtre de
paquet ; auquel nous nous réferrerons à présent sous le nom de PF) . PF
est aussi capable de normaliser et de traiter le trafic TCP/IP, d'offrir
une gestion de la bande passante et une prioritarisation des paquets
ainsi que d'être utilisé dans la création de puissants et flexibles
pare-feu. Tout ceci est décrit dans le <a href="../pf/fr/index.html"><b>Guide
de l'Utilisateur PF</b></a>.


<p> 
<a name= "DHCP"></a>
<h2>6.4 - DHCP</h2> 

Le protocole d'attribution dynamique des adresses (DHCP) permet de
configurer les interfaces réseau automatiquement. OpenBSD peut être
serveur DHCP (afin de configurer les autres machines), client DHCP (afin
de recevoir sa configuration à partir d'une autre machine) et, dans
certains cas, les deux.

<p>
<h3>6.4.1 Client DHCP</h3>

<p>
Pour utiliser le client DHCP <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">
dhclient(8)</a> inclus avec OpenBSD, éditez le fichier
<tt>/etc/hostname.xl0</tt> (sous-entendu que l'interface Ethernet soit
xl0. La vôtre pouvant être aussi bien ep0 que fxp0 ou encore autre chose).
Tout ce que vous avez besoin d'écrire dans ce fichier est
'<tt>dhcp</tt>' :

<blockquote><pre>
# <b>echo dhcp &gt; /etc/hostname.xl0</b>
</pre></blockquote>

<p>
Ceci aura pour effet de démarrer automatiquement le client DHCP au
démarrage. OpenBSD se verra attribuer son adresse IP, sa passerelle par
défaut et ses serveurs de noms (DNS) à partir du serveur DHCP.

<p>
Si vous souhaitez démarrer le client DHCP à partir de la ligne de
commande, vérifiez bien que <tt>/etc/dhclient.conf</tt> existe, puis
lancez la commande :

<blockquote><pre>
# <b>dhclient fxp0</b>
</pre></blockquote>

<p>
Où <tt>fxp0</tt> représente l'interface que vous voulez configurer
par DHCP.

<p>
Peu importe la façon dont vous démarrez le client DHCP, vous pouvez
éditer <tt>/etc/dhclient.conf</tt> afin de ne <b>pas</b> mettre à
jour vos DNS à l'aide du serveur dhcp en décommentant les lignes
'request' (il y a des exemples de configurations, mais vous devez les
décommenter afin de changer le comportement par défaut de
dhclient.)

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

<p>
et <b>supprimez</b> domain-name-servers. Bien sûr, vous pouvez
également supprimer hostname ainsi que d'autres options.

<p>
En changeant les options dans le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5">
dhclient.conf(5)</a>, vous indiquez au client DHCP la façon de créer votre
fichier  <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">
resolv.conf(5)</a>.
Le client DHCP écrase toutes les données déja présentes dans resolv.conf(5)
en utilisant les informations envoyées par le serveur DHCP. De fait, tous les
changements que vous aurez apportés manuellement seront perdus.

<p>
Il existe deux mécanismes pour empêcher cela :
<ul>
<li>
<tt><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS">OPTION MODIFIERS</a>
</tt> (<b>default</b>, <b>supersede</b>, <b>prepend</b>, et <b>append</b>)
vous permet de modifier n'importe quelles options du fichier dhclient.conf(5).

<li>
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"><tt>resolv.conf.tail(5)</tt></a>
vous permet d'ajouter ce que vous souhaitez au fichier resolv.conf(5)
créé par dhclient(8).
</ul>

<p>
Imaginions que vous souhaitiez utiliser le client DHCP mais que vous
vouliez ajouter <tt>lookup file bind</tt> au fichier resolv.conf(5) créé
par dhclient(8).
Il n'existe pas de telle option dans le fichier <tt>dhclient.conf</tt> et
vous devrez donc utiliser <tt>resolv.conf.tail</tt> pour préserver ce
changement.

<blockquote><pre>
# <b>echo "lookup file bind" &gt /etc/resolv.conf.tail</b>
</pre></blockquote>

A présent, votre fichier resolv.conf(5) devrait inclure "lookup file bind"
à la fin.

<blockquote><pre>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>




<p>
<h3>6.4.2 Serveur DHCP</h3>

<p>
Pour utiliser OpenBSD en tant que serveur DHCP <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)
</a>, éditez le fichier <tt>/etc/rc.conf.local</tt> afin qu'il contienne la
ligne <tt>dhcpd_flags=""</tt>. Placez le nom des interfaces sur lesquelles vous
souhaitez que le serveur écoute, dans le fichier <tt>/etc/dhcpd.interfaces</tt>.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
Ensuite, éditez <tt>/etc/dhcpd.conf</tt>. Les options sont plutôt
explicites.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Ceci indique à vos clients DHCP que le domaine à ajouter aux
requêtes DNS est example.com (ainsi, si un utilisateur lance la commande
'telnet joe', il sera renvoyé vers joe.example.com). Les clients auront
comme serveurs DNS 192.168.1.3 et 192.168.1.5. Pour les hôtes
présents sur le sous-réseau correspondant à l'interface du
serveur OpenBSD, à savoir dans la plage 192.168.1.0/24, ils se verront
attribuer une adresse IP entre 192.168.1.32 et 192.168.1.127. Leur passerelle
par défaut sera 192.168.1.1.

<p>
Si vous souhaiter démarrez dhcpd(8) à partir de la ligne de
commandes, une fois <tt>/etc/dhcpd.conf</tt> configuré, tapez :

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd fxp0</b>
</pre>

<p>
La ligne invoquant <tt>touch</tt> est nécessaire afin de créer un
fichier <tt>dhcpd.leases</tt> vide avant que dhcpd(8) ne démarre.
Les <a href="faq10.html#rc">scripts de démarrage</a> d'OpenBSD se
chargeront de créer ce fichier au boot, mais si vous lancez dhcpd(8)
manuellement, vous devez au préalable créer ce fichier.
<tt>fxp0</tt> représente l'interface sur laquelle vous voulez
répondre aux requêtes DHCP.

<p>
Si vous prévoyez de servir DHCP à des machines Windows, pour
pourriez souhaiter donner à ces clients une adresse de serveur 'WINS'.
Pour ce faire, ajoutez simplement la ligne suivante dans votre fichier
<tt>/etc/dhcpd.conf</tt> :

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(où <tt>192.168.92.55</tt> est l'adresse IP de votre serveur Windows ou
Samba.) Reportez vous à <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">
dhcp-options(5)</a>. Si vos clients DHCP ont besoin de plus d'options, reportez
vous au manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">
dhcp-options(5)</a>.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP </h2>

<p>
Le protocole point à point est généralement utilisé
afin de créer une connexion modem vers votre FAI (fournisseur
d'accès à Internet). Sous OpenBSD, deux solutions existent.

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">
pppd(8)</a>
 - implémentation noyau du démon ppp.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - implémentation ppp en espace utilisateur ("userland"). 
</ul>

<p>
Chacune des implémentations (ppp et pppd) offrent des fonctionnalités similaires
de différentes façons. pppd utilise le pilote <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp(4)</a>
inclus dans le noyau alors que ppp utilise <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun(4)</a>
dans l'espace utilisateur. Ce document ne couvrira que l'implémentation en
espace utilisateur du démon PPP car il est plus simple à utiliser et
diagnostiquer. Pour commencer, vous aurez besoin de certaines informations
concernant votre FAI. En voici une liste non-exhaustive.

<ul>
<li>Le numéro de téléphone de votre FAI
<li>Votre serveur de noms
<li>Votre nom d'utilisateur et votre mot de passe
<li>Votre passerelle
</ul>

<p>
Certaines de ces options ne sont pas obligatoires mais vous aideront
à la mise en place de ppp. Le fichier de configuration du démon
PPP est <a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">
/etc/ppp/ppp.conf</a>. Selon votre situation, les nombreux fichiers
présents dans <i>/etc/ppp</i> peuvent vous aider à la mise en
place de votre configuration. Vous devriez jeter un oeil à ce
répertoire.

<p>

<h3>Configuration initiale - pour PPP(8)</h3>

<p>
La configuration initiale de PPP nécessite l'édition du fichier
<i>/etc/ppp/ppp.conf</i>. Ce fichier n'existe pas par défaut, mais vous
pouvez vous inspirer du fichier <i>/etc/ppp/ppp.conf.sample</i> afin de
créer votre propre <i>ppp.conf</i>. Je commencerai par une configuration
simple et généralement très employée. Voici
rapidement un petit fichier <i>ppp.conf</i> définissant quelques valeurs
par défaut :

<blockquote>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK
\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</blockquote>

<p>
La section définie par le marqueur <tt>default:</tt> sera
exécutée à chaque fois. Cette section recense des
informations importantes. &quot;set log&quot; défini le niveau de
verbosité des logs. Il peut être changé :
référez-vous au manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
pour plus d'informations concernant les niveaux d'enregistrement des
différents évênements. Le périphérique utilisé est indiqué par &quot;set
device&quot;. Il s'agit du port sur lequel est présent notre modem. Dans
cet exemple, le modem est branché sur le port com 2. Ainsi, le port com
1 sera indiqué par <i>/dev/cua00</i>. La vitesse de la connexion est
précisée par &quot;set speed&quot; et &quot;set dial&quot; renseigne nos
paramètres de numérotation. Avec ceci, nous pouvons changer l'expiration
("timeout") de la connexion, etc. Ceci étant, cette ligne ne devrait pas
tellement varier.

<p>
Nous pouvons maintenant continuer et configurer les informations
spécifiques à notre FAI. Pour ce faire, nous allons rajouter une autre
section en-dessous de <tt>default:</tt>. Le marqueur définissant cette
nouvelle section pourra être ce que vous désirez - le plus simple étant
d'utiliser le nom de votre FAI. Ici, nous utiliserons <b>myisp:</b> pour
indiquer le commencement de la section correspondant à notre FAI. Voici
une configuration simple contenant le nécessaire afin de nous connecter
:

<blockquote>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
Ici nous avons fourni les éléments essentiels concernant ce FAI. La
première option, &quot;set phone&quot;, donne le numéro de téléphone du
FAI. Nos options d'ouverture de session sont renseignées par &quot;set
login&quot;. Notre "timeout" est égal à 5 ; ce qui signifie que notre
tentative de connexion expirera après 5 secondes si aucune porteuse
n'est trouvée. Dans le cas contraire, &quot;login:&quot; sera envoyé
avec notre nom d'utilisateur et notre mot de passe.

<p>
Dans cet exemple, notre nom d'utilisateur est : ppp ; notre mot de passe
est : ppp. Ces valeurs doivent être changées. La ligne &quot;set
timeout&quot; permet de couper la connexion après 120 secondes de
non-utilisation. L'option &quot;set ifaddr&quot; est un peu plus compliquée.
En voici une explication plus complète.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
La ligne précédente se définit avec le format suivant : &quot;<b>set
ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;.
La première IP désigne l'adresse IP que nous souhaitons nous voir
attribuer. Si vous avez une adresse IP statique, vous devez l'indiquer
ici. Dans notre exemple, nous utilisons la notation /0 qui dit qu'aucun
"bit" de cette adresse ne doit forcément correspondre et que celle-ci
peut être changée. La deuxième adresse IP est celle du FAI. La troisième
option est notre masque de sous-réseau, ici défini à 255.255.255.0. Si
triggeraddr est renseigné, il remplacera myaddr comme adresse IP
utilisée pour la négociation IPCP initiale. Cependant, seule une adresse
incluse dans la gamme d'adressage correspondant à myaddr sera acceptée.
Ceci peut être utile dans la négociation avec certaines implémentations
PPP qui n'attribuent pas d'adresse IP à moins que l'initiateur de la
connexion ne demande explicitement l'adresse &quot;0.0.0.0&quot;.

<p>
L'option suivante &quot;add default HISADDR&quot; attribue comme route
par défaut l'adresse IP de votre FAI. Cette entrée permet d'ajuster
automatiquement notre route par défaut en cas de changement d'adresse IP
de celui-ci. &quot;enable dns&quot; est utilisé afin de récupérer la
liste des serveurs DNS du FAI. N'utilisez PAS cette option si vous avez
votre propre serveur DNS local car ppp empêchera les requêtes vers celui-ci
en remplaçant les lignes "nameserver" de votre fichier
<i>/etc/resolv.conf</i>.

<p>
A la place des méthodes traditionnelles de connexion, certains FAI
utilisent à présent l'authentification CHAP ou PAP. Si c'est le cas, notre
configuration sera un peu différente:

<blockquote>
<pre>
myisp:
set phone 1234567   
set authname ppp
set authkey ppp
set login
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
Dans l'exemple précédent, nous spécifions notre nom d'utilisateur (ppp)
et notre mot de passe à l'aide des options authname et authkey,
respectivement. Il n'est pas nécessaire de spécifier le type
d'authentification CHAP ou PAP utilisé, car il sera négocié
automatiquement. "set login" signifie simplement de tenter de se
connecter en utilisant le nom d'utilisateur et le mot de passe précisés
précédemment.

<p>
<h3>Utiliser PPP(8)</h3>

<p>
Maintenant que <i>ppp.conf</i> est configuré, nous pouvons essayer
d'initier une connexion vers notre FAI. Je détaillerais certaines des
options les plus utilisées :

<ul>
<li><tt>ppp -auto myisp</tt> - Cette commande lancera ppp, configurera vos
interfaces, vous connectera à votre FAI et se placera en
arrière-plan.
<li><tt>ppp -ddial myisp</tt> - Cette commande est similaire à -auto mais
si votre connexion est rompue, ppp essayera de se reconnecter automatiquement.
</ul>

<p>
Si les commandes précédentes ne fonctionnent pas, lancez
<i>/usr/sbin/ppp</i> sans options, ce qui vous placera en mode
interactif. Les options peuvent être spécifiées une par une afin de
diagnostiquer les erreurs et autres problèmes. En utilisant la
configuration précédente, ppp enregistrera les évênements dans
/var/log/ppp.log. Ce fichier de log ainsi que la page de manuel
contiennent des informations utiles.

<p>
<h3>Autres options de ppp(8)</h3>

<p>
Dans certaines situations, vous pourriez avoir besoin de lancer
certaines commandes au lancement ou à la coupure de votre connexion. Si
vous vous trouvez dans cette situation, il existe deux fichiers que vous
pouvez créer : <i>/etc/ppp/ppp.linkup</i> et
<i>/etc/ppp/ppp.linkdown</i>. Des exemples de configurations sont
disponibles ici :

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">
ppp.linkup</a>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">
ppp.linkdown</a>
</ul>

<p>
<p>
<h3>variations sur ppp(8)</h3>

<p>
De  nos jours, beaucoup de FAI offrent des services xDSL plus rapides que les
méthodes traditionnelles de connexion. Ceux-ci incluent des variantes de type
ADSL et SDSL. Bien qu'aucun appel à distance n'est lieu, la connexion reste
basée sur le protocol point-à-point. En voici des exemples:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
Le protocole d'encapsulation de PPP dans Ethernet (PPPoE - "Point to Point
Protocol over Ethernet") permet d'envoyer des paquets PPP à l'intérieur de
trames Ethernet. Le protocole d'encapsulation de PPP dans ATM (PPPoA - "Point
to Point Protocol over ATM") est généralement utilisé dans les réseaux ATM tels
qu'au Royaume Uni ou en Belgique.

<p>
En résumé cela signifie que vous pouvez établir une connexion vers votre FAI à
l'aide d'une carte Ethernet standard et d'un modem DSL-Ethernet (à l'inverse des
modems USB).

<p>
Si vous possédez un modem compatible PPPoE/PPPoA, il est possible de le
configurer afin qu'il initie lui-même la connexion. Dans le cas contraire, si le
modem est capable de fonctionner en mode &quot;bridge&quot;, il est possible d'activer ce
mode afin que celui-ci fasse "transiter" les paquets vers une machine exécutant
un logiciel PPPoE (voir plus loin).

<p>
Sous OpenBSD, l'interface logicielle PPPoE/PPPoA principale est <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8">pppoe(8)
</a>, qui est l'implémentation en espace utilisateur (de la même manière que <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)
</a>, précédemment décrit). Une implémentation noyau de PPPoE, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">pppoe(4)
</a>, a été ajoutée dans OpenBSD -current ; cependant, elle ne sera pas
disponible aux utilisateurs non-current avant OpenBSD 3.7.
<!-- XXXrelease -->

<p>
<h3>PPTP</h3>

<p>
Le "Point to Point Tunneling Protocol" (PPTP) est un protocole propriétaire
Microsoft. Un client pptp s'interfaçant avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)
</a> est disponible et est capable de se connecter à un réseau privé virtuel
PPTP (VPN) utilisé par certains fournisseurs d'accès câble ou xDSL. Le logiciel
pptp quant à lui doit être installé en utilisant les <a href="faq8.html#Ports">
ports</a> ou les <a href="faq8.html#Packages">packages</a>. De plus amples
instructions sur la façon de mettre en place et d'utiliser pptp sont disponibles
dans la page de manuel installée avec le paquet pptp.

<p>
<a name="Tuning"></a>
<h2>6.6 - Optimisation des paramètres réseau</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - Comment configurer le noyau pour avoir un plus grand nombre d'essais
et augmenter le délai d'expiration des sessions TCP ?</h3>

<p>
Généralement, vous utiliserez ceci en cas de problèmes de routage ou de
connexion. Bien sûr, pour que cette configuration soit la plus
effective, les deux extrémités de la connexion doivent utiliser des
valeurs similaires.

<p>
Pour optimiser ceci, utilisez <tt>sysctl</tt> et augmentez les valeurs
de :

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Avec sysctl -a, vous pouvez voir les valeurs courantes de ces paramètres
(ainsi que beaucoup d'autres). Pour en changer un, tapez par exemple
<tt>sysctl net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - Comment activer les émissions ("broadcasts") dirigées
?</h3>

<p>
Normalement, vous ne devriez pas utiliser ceci. Cette option permet à
quelqu'un de diriger le trafic vers la ou les adresses "broadcast" des
réseaux sur lesquels vous êtes connecté si vous utilisez OpenBSD en tant
que routeur.

<p>
Dans certaines situations, sur des réseaux fermés, cette option peut-
être utile, surtout lors de l'utilisation de vieilles implémentations du
protocole NetBIOS. Il s'agit d'un autre paramètre sysctl. <tt>sysctl net.inet.ip.directed-
broadcast=1</tt> active cette option. Lisez la section sur les <a
href="http://www.netscan.org">"attaques de type smurf"</a> si vous voulez savoir
pourquoi cette option est désactivée par défaut.

<p>
<h3>6.6.3 - Je ne veux pas que le noyau alloue dynamiquement un port
donné</h3>

<p>
Il existe également un paramètre sysctl pour cela. D'après <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a> :

<pre>
Définie la liste des ports TCP ne devant pas être alloués dynamiquement
par le noyau. Ceci peut être utile afin d'éviter l'appropriation d'un
port spécifique dont un autre programme a besoin pour fonctionner. Les
éléments listés peuvent être séparés par une virgule et/ou un espace.

 #  <strong>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

Il est aussi possible d'ajouter ou de retirer des ports de la liste courante.

 #  <strong>sysctl net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl net.inet.tcp.baddynamic=-871</strong>
</pre>


<p>
<a name="NFS"></a>
<h2>6.7 - Utilisation simple de NFS</h2>

<p>
NFS ("Network File System") est utilisé afin de partager un système de
fichiers à travers un réseau. Voici un certain nombre de manuels à lire
avant la mise en place d'un serveur NFS :

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)
</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">
mountd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">
exports(5)</a>
</ul>

<p>
Cette section détaillera les étapes nécessaires à la mise en oeuvre
d'une configuration NFS simple. Cet exemple détaille un serveur et ses
clients NFS sur un LAN. Il ne s'agit pas d'étudier la sécurisation de
NFS. Nous assumerons que le filtre de paquets (PF) ou qu'un autre type
de pare-feu est configuré afin d'interdire les accès extérieurs. Si vous
autorisez l'accès à votre serveur NFS depuis l'extérieur et que vous
hébergez des données sensibles, nous vous conseillons fortement
d'utiliser IPsec. Autrement certaines personnes pourraient voir ce qui
transite dans votre trafic NFS. Quelqu'un pourrait également usurper
l'adresse IP que vous autorisez à se connecter à votre serveur NFS.
Plusieurs types d'attaques peuvent en découler. Mais lorsqu'IPsec est
correctement configuré, il offre une protection contre ces attaques.

<p>
Autre note concernant la sécurité. Ne vous contentez pas juste d'ajouter
un système de fichiers dans <i>/etc/exports</i> sans mettre en place une
liste recensant les hôtes autorisés à se connecter. Sans une liste
d'hôtes autorisés à monter un répertoire particulier, n'importe qui,
capable de vous atteindre, sera en mesure de monter vos systèmes de
fichiers exportés par NFS.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">
portmap(8)</a> doit être lancé afin que NFS puisse fonctionner. A partir
d'OpenBSD 3.2 Portmap(8) est désactivé par défaut, vous devez donc ajouter la
ligne

<blockquote><pre>
portmap=YES
</pre></blockquote>
dans le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">
rc.conf.local(8)</a> puis redémarrer.


<p>
Cette configuration consiste en un serveur d'adresse IP <b>10.0.0.1</b>. Ce
serveur n'offrira NFS qu'aux clients présents sur ce réseau. La
première étape pour installer un serveur NFS est de renseigner
votre fichier <i>/etc/exports</i>. Ce fichier liste les systèmes de
fichiers que vous souhaitez rendre accessibles par NFS et définit qui
peut y accéder. Beaucoup d'options sont disponibles pour l'édition
de ce fichier et vous devriez lire la page de manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">
exports(5)</a>. Pour cet exemple, notre fichier <i>/etc/exports</i> ressemblera
à :

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
Ceci signifie que le système de fichiers local <tt>/work</tt> sera
accessible par NFS. L'option <tt>-alldirs</tt> permet au client de
monter n'importe quel répertoire sous le point de montage
<tt>/work</tt>. L'option <tt>-ro</tt> exporte le système de fichiers en
lecture seule. Les deux derniers arguments spécifient que seuls les
clients présents dans le réseau 10.0.0.0 et utilisant un masque de
255.255.255.0 seront autorisés à monter ce système de fichiers.
Ceci est important pour certains serveurs accessibles dans différents
réseaux.

<p>
Une fois que votre fichier <i>/etc/exports</i> est configuré, vous
pouvez mettre en place votre serveur NFS. Tout d'abord, vérifiez que les
options NFSSERVER &amp; NFSCLIENT sont bien présentes dans votre fichier
de configuration noyau. (Le noyau GENERIC inclus ces options.) Ensuite,
il vous faut inclure la ligne <tt>nfs_server=YES</tt> dans le fichier
<i>/etc/rc.conf.local</i>. Ceci aura pour effet de démarrer nfsd(8) et
mountd(8) au redémarrage. A présent, vous pouvez lancer les démons
manuellement. Ils doivent être lancés par root et vous devez vérifier
que portmap(8) est bien démarré sur votre système. Voici un exemple de
lancement de nfsd(8) servant les requêtes TCP et UDP et utilisant 4
démons. Vous devriez utiliser un nombre approprié de démons NFS en
fonction du nombre maximum de connexions concurrentes que vous souhaitez
servir.

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Vous devez non seulement démarrer le serveur nfsd(8) mais également
mountd(8). Il s'agit du service qui se charge de passer les requêtes de
montage à NFS. Pour démarrer mountd(8), soyez sûr qu'un fichier
mountdtab vide existe puis lancez le démon :

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<p>
Si vous faites des changements au fichier /etc/exports alors qu'NFS est
déja en fonction, vous devez en informer mountd ! Lancez-lui simplement
un signal HUP :

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<p>
<h3>Statistiques NFS</h3>

<p>
Maintenant, vous pouvez vérifier que tous ces démons sont lancés et
enregistrés avec RPC. Pour ce faire, utilisez rpcinfo(8).

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Dans le cadre d'une utilisation normale, d'autres utilitaires peuvent vous
permettre de voir ce qui se passe au niveau NFS. Un de ces utilitaires est <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">
showmount(8)</a>, qui permet de voir ce qui est monté et par qui. Il
existe aussi nfsstat(8) qui affiche beaucoup plus de statistiques. Pour utiliser
showmount(8), essayez la commande <tt>/usr/bin/showmount -a hôte</tt>. Par
exemple :

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>Monter des systèmes de fichiers NFS</h3>

<p>
Les systèmes de fichiers NFS doivent être montés par
mount(8), ou plus précisément, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">
mount_nfs(8)</a>. Pour monter le système de fichiers <i>/work</i> sur
10.0.0.1 vers le système de fichiers local <i>/mnt</i>, il vous suffit de
lancer la commande suivante (notez qu'il n'est pas nécessaire d'utiliser
une adresse IP ; mount résoudra les noms d'hôtes) :

<blockquote><pre>
# <strong>mount -o ro -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
Pour que ce système de fichiers soit monté au démarrage,
ajoutez la ligne suivante dans votre <i>/etc/fstab</i> :

<blockquote><pre>
10.0.0.1:/work /mnt nfs ro 0 0
</pre></blockquote>

<p>
Il est important que vous utilisiez <tt>0 0</tt> à la fin de la ligne
afin que votre machine ne lance pas un fsck sur ce système de fichiers
NFS au boot !!! Les autres options standards, comme noexec, nodev,
nosuid peuvent être employées lorsqu'elles sont applicables. Par exemple
:

<blockquote><pre>
10.0.0.1:/work /mnt nfs ro,nodev,nosuid 0 0
</pre></blockquote>

<p>
Ainsi, aucun périphérique ni programme setuid présent sur le serveur NFS
ne peut compromettre la sécurité du client. Si vous ne montez pas de
programmes que vous souhaitez utiliser sur le client NFS, ajoutez
l'option noexec à cette ligne.


<a name="Bridge"></a>
<h2>6.9 - Mise en place d'un pont ("bridge") avec OpenBSD</h2>

<p>
Un pont ("<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>")
est un lien entre deux (ou plusieurs) réseaux séparés. A
l'inverse d'un routeur, les paquets sont transférés à travers le pont de
manière "invisible" -- au niveau logique, les deux segments de réseau
semblent n'en faire qu'un de chaque côté du pont. Le pont ne transfèrera
que les paquets passant d'un segment à l'autre, ce qui entre autres,
permet de réduire le trafic sur un réseau complexe tout en permettant à
n'importe quel noeud d'accéder à un autre en cas de besoin.

<p>
Notez qu'à cause de sa nature "invisible", une interface faisant partie
d'un pont peut, ou non, posséder une adresse IP. Si c'est le cas,
l'interface aura deux modes d'opération, l'un faisant parti du pont et
l'autre se comportant comme une interface normale. Si aucune interface
ne possède d'adresse IP, le pont fera transiter le trafic mais ne sera
pas administrable par le réseau (ce qui peut être une fonctionnalité
voulue).

<p>
<h3>Exemple d'application d'un pont</h3>

<p>
Un des mes racks possède un certain nombre d'anciens systèmes, lesquels
ne sont pas équipés de carte réseau 10BASE-TX. Bien qu'ils possèdent des
ports AUI ou AAUI, ma réserve de transmetteurs est limitée à des câbles
coaxiaux. Une des machines de cette rangée est un serveur d'accès
terminal sous OpenBSD, toujours allumée et connectée au réseau à haut
débit. L'ajout d'une seconde carte équipée d'un port coaxial permettra
d'utiliser cette machine comme un pont vers le réseau coaxial.

<p>
Ce système a, pour le moment, deux cartes réseau, une Intel
EtherExpress/100 (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
et une carte 3c590-Combo
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
pour le port coaxial. <tt>fxp0</tt> fait le lien avec le
reste du réseau et possède donc une adresse IP, <tt>ep0</tt>, ne faisant
quant à elle que du "bridging", n'en possède pas. Les machines
connectées sur le segment coaxial communiqueront comme les autres
présentes sur le reste du réseau. A présent, voyons comment arriver à ce
résultat.

<p>
Le fichier <tt>hostname.fxp0</tt> contient les informations concernant
la carte <tt>fxp0</tt>. Cette machine est configurée pour DHCP, donc le
fichier ressemble à celui-ci :

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

<p>
Ici, aucune surprise.

<p>
Comme vous pouvez le deviner, la configuration de la carte <tt>ep0</tt>
est un peu différente :

<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

<p>
Ici, nous demandons au système d'activer cette interface en utilisant <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> et de la configurer pour du 10BASE-2 (coaxial). Aucune adresse
ou information similaire n'est nécessaire pour cette interface. Les
options possibles pour la carte <tt>ep</tt> sont disponibles en détail
dans le <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">manuel</a>.

<p>
A présent, il nous faut paramétrer le pont. Un pont est initialisé par
l'existence d'un fichier du type <a href="http://www.openbsd.org/cgi-
bin/man.cgi?query=bridgename.if&amp;sektion=5">
<tt>bridgename.bridge0</tt></a>. Dans ma situation, voici un exemple
possible :

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

<p>
Cela indique de mettre en place un pont constitué de deux interfaces,
fxp0 et ep0 et de l'activer. Est-ce que l'ordre dans lequel les cartes
sont énoncées est important ? Non, souvenez-vous qu'un pont est très
symétrique -- les paquets entrent et sortent dans les deux directions.

<p>
C'est tout ! Redémarrez et vous aurez un pont fonctionnel.

<p>
<h3>Le filtrage sur un pont ("filtering bridge")</h3>

Bien qu'il existe certainement des usages pour de simples ponts du genre
évoqué, il est probable que vous souhaitiez FAIRE quelquechose avec les
paquets qui le traversent. Comme vous pouvez vous en douter, <a
href="#PF">Packet Filter</a> peut être utilisé pour restreindre le
trafic traversant votre pont (pont filtrant).

<p>
Gardez à l'esprit que de part la nature d'un pont, les mêmes données
traversent les deux interfaces, ce qui signifie que vous n'avez besoin
de filtrer que sur l'une d'entre elles. Vos déclarations par défaut "Pass
all" ressembleront à l'exemple suivant :

<blockquote>
<pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre>
</blockquote>

<p>
Maintenant, admettons que je souhaite filtrer le trafic dirigé vers les
vieux systèmes évoqués précédemment, ne permettant qu'aux protocoles Web
et SSH de les atteindre. Dans ce cas, nous allons autoriser tout le
trafic entrant et sortant sur l'interface <tt>ep0</tt>, mais nous filtrerons sur
l'interface <tt>fxp0</tt> en utilisant <tt>keep state</tt>
pour prendre en charge les données retournées :

<blockquote>
<pre>
# Autoriser le trafic entrant et sortant sur ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Bloquer tout le trafic sur fxp0
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

<p>
Notez que cette règle bloquera tout, à l'exception des requêtes
entrantes HTTP et SSH, vers la machine qui fait le pont ainsi qu'en
direction des autres noeuds "derrière" elle. Il est possible d'obtenir
d'autres résultats en filtrant sur l'autre interface.

<p>
Pour surveiller et contrôler le pont que vous venez de créer,
servez-vous de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">
brconfig(8)</a> qui peut aussi être utilisée pour créer un
pont après le démarrage.

<p>
<h3>Astuces sur les ponts</h3>

<ul>
<li>Il est HAUTEMENT recommandé de ne filtrer que sur une seule
    interface. Bien qu'il soit possible de filtrer sur les deux, vous
    devez vraiment en connaître toutes les implications avant de pouvoir
    le faire de la bonne manière.

<li>En utilisant l'option <i>blocknonip</i> de <a href="http://www.openbsd.org/cgi-
    bin/man.cgi?query=brconfig&amp;sektion=8"> brconfig(8)</a> ou dans
    <a href="http://www.openbsd.org/cgi-
    bin/man.cgi?query=bridgename.if&amp;sektion=5">
    bridgename.bridge0</a>, vous pouvez empêcher le trafic non-IP (comme
    IPX ou NETBEUI) de passer oûtre votre filtre. Dans certaines
    situations, cela peut-être important et vous devez savoir qu'un pont
    fonctionne pour tous les types de trafic, pas seulement IP.

<li>Un pont requiert que les interfaces réseau soient en mode
    "Promiscuous" -- elles écoutent TOUT le trafic réseau, pas seulement
    celui leur étant dirigé. Ceci augmentera la charge du processeur et
    du bus. Certaines cartes ne fonctionnent pas correctement dans ce
    mode, le circuit TI ThunderLAN (<a href="http://www.openbsd.org/cgi-
    bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>) en est un exemple.
    </ul>

<a name="PXE"></a>
<h2>6.10 - Comment démarrer en utilisant PXE ? (i386, amd64)</h2>
PXE ("Preboot Execution Environment", environnement d'exécution avant
démarrage) permet de démarrer un ordinateur à partir du réseau plutôt
que d'un disque dur, une disquette ou un CD-ROM. A l'origine, cette
technologie a été développée par Intel mais est maintenant supportée par
la plupart des contrôleurs réseau et des constructeurs. Sachez qu'il
existe plusieurs protocoles de démarrage par le réseau, PXE étant
relativement récent. Traditionnellement, un démarrage PXE est effectué
en utilisant des ROMs présentes sur la carte réseau ou la carte mère elle-
même, mais plusieurs disquettes permettant de démarrer en PXE sont
disponibles sur différentes sources. Beaucoup de ROMs présentes sur des
anciens contrôleurs supportent le démarrage en réseau mais sont
imcompatibles avec PXE ; s'il est équipé de tels contrôlleurs, un
système OpenBSD/i386 ou amd64 ne pourra pas être démarré à par le
réseau.



<p>
<h3>Comment fonctionne un démarrage PXE ?</h3>
Tout d'abord, il serait sage de savoir <a href="faq14.html#Boot386">comment
se déroule le processus de démarrage d'OpenBSD/i386 ?</a> sur les
platformes i386 et amd64. Au démarrage, chaque interface compatible PXE
émet une requête DHCP en broadcast sur le réseau. Le serveur
DHCP lui attribue alors une adresse IP en lui indiquant l'emplacement du fichier
à exécuter sur le serveur
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1">
tftp(1)</a>. Ce fichier se charge ensuite de gérer le reste du
démarrage. Sous OpenBSD, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arc
h=i386">pxeboot</a>, remplace le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i
386">boot(8)</a> standard. Il est alors capable de charger et d'exécuter
un noyau (comme <tt>bsd</tt> ou <a href="../faq4.html#bsd.rd">
<tt>bsd.rd</tt></a>) à partir du serveur tftp(1).

<h3>Comment le mettre en place ?</h3>
Le point évident est que vous avez besoin d'une machine ou d'un
contrôleur compatible avec un démarrage PXE. Certaines documentations
précisent que toutes les cartes modernes sont compatibles PXE, mais
c'est tout simplement faux -- de nombreux systèmes à bas prix n'incluent
pas de ROMs PXE ou utilisent un ancien protocole de démarrage sur
réseau. Vous avez également besoin d'un serveur <a href="#DHCP">DHCP</a>
configuré ainsi qu'un serveur TFTP.

<p>
En admettant qu'une machine sous OpenBSD serve les fichiers de démarrage
(cela n'étant PAS obligatoire), le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5">
dhcpd.conf</a> de votre serveur DHCP devra contenir la ligne suivante :
<pre>
    filename "pxeboot";
</pre>
afin de pouvoir offrir ce fichier de démarrage à une station de
travail. Par exemple :

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
Vous devrez aussi activer le service <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8">tftpd(8)
</a>. Pour ce faire, il suffit de configurer <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)
</a>. L'installation standard d'OpenBSD fournit une ligne d'exemple dans
<tt>inetd.conf</tt> qui devrait vous satisfaire :
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

Retirez simplement le caractère '#' et envoyez à inetd(8) un signal -HUP
afin que celui-ci relise son fichier <tt>/etc/inetd.conf</tt>. Les
fichiers accessibles par tftpd(8) sont contenus dans un répertoire
particulier, ici <tt>/tftpboot</tt>, que nous utiliserons pour cet
exemple. Bien évidemment, ce répertoire doit être créé et contenir les
fichiers nécessaires. Pour un démarrage PXE, vous n'aurez typiquement
besoin que de quelques fichiers :

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arc
h=i386"
>pxeboot</a>, le chargeur de démarrage (offre la même fonction que
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i
386">boot</a> pour un démarrage sur disque).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, le noyau d'installation ou
<tt>bsd</tt>, un noyau adapté.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;a
rch=i386"
>/etc/boot.conf</a>, le fichier de configuration de boot.
</ul>

Notez que <tt>/etc/boot.conf</tt> n'est nécessaire qu'au cas où vous
souhaiteriez démarrer un noyau ne se nommant pas <tt>bsd</tt>, ou que
les options par défaut de pxeboot ne vous conviennent pas (par exemple
si vous utilisez une console série). Vous pouvez tester votre serveur
tftpd(8) en utilisant un client <a href="http://www.openbsd.org/cgi-
bin/man.cgi?query=tftp&amp;sektion=1"> tftp(1)</a> afin de vérifier que
vous pouvez bien récupérer les fichiers nécessaires.

<p>
Une fois vos serveurs DHCP et TFTP démarrés, vous êtes prêt pour un
essai. Vous devez activer PXE sur votre système ou votre carte réseau ;
consultez la documentation fournie avec votre matériel. Une fois que PXE
est activé, vous devriez voir apparaître des lignes similaires à celles-
ci :

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 1.00
    boot>
</pre>

A présent, vous obtenez l'invite de commandes standard d'OpenBSD. Tapez
simplement "<tt>bsd.rd</tt>" pour récupérer le fichier homonyme à partir
du serveur TFTP.

<pre>
    >> OpenBSD/i386 PXEBOOT 1.00
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2004 OpenBSD.  All rights reserved. 
http://www.OpenBSD.org

    OpenBSD 3.6 (RAMDISK_CD) #378: Fri Sep 17 13:04:04 MDT 2004
      ...
</pre>

Le noyau d'installation <a href="faq4.html#bsd.rd">bsd.rd</a> va
maintenant se lancer.

<p>

<h3>Est-il possible de démarrer d'autres noyaux que <tt>bsd.rd</tt> en
utilisant PXE ?</h3>

Oui, bien qu'avec les outils actuellement présents dans OpenBSD 3.6, le
démarrage PXE ne soit essentiellement prévu que pour installer le
système d'exploitation.

<a name="CARP"></a>
<h2>6.11 - Protocole de redondance d'adresse commune (CARP)</h2>
<h3>6.11.1 - Qu'est-ce que CARP et comment fonctionne-t-il ?</h3>
<!-- This article written by Sunny Raspet, slr@mordac.info, and
released under the BSD license -->

<p>
CARP ("Common Address Redundancy Protocol") est un outil aidant à la
redondance du système en ayant plusieurs ordinateurs créant une
interface réseau unique entre eux, afin que si l'un d'eux ne fonctionne
plus, un autre puisse répondre à sa place ; cet outil permet aussi de
mettre en place un certain partage de charge entre les différents
systèmes. CARP est une avancée par rapport au VRRP ("Virtual Router
Redundancy Protocol" - protocole de redondance de routeur virtuel)
standard. Il a été développé une fois que VRRP fut considéré comme non
suffisamment libre à cause d'un brevet Cisco pouvant le couvrir. Pour
plus d'informations sur les origines de CARP et les problèmes légaux
entourant VRRP, rendez-vous sur <a href="../../lyrics.html#35">cette
page</a>.

<p>
Afin d'éviter tout problème légal, Ryan McBride (avec l'aide de Michael
Shalayeff, Marco Pfatschbacher et Markus Friedl) a conçut CARP de
manière à être fondamentalement différent. Si l'inclusion de la
cryptographie reste le changement le plus visible, il n'en reste pas
moins un seul parmi beaucoup d' autres.

<p>
Comment fonctionne-t-il ? CARP est un protocole multicast. Il regroupe
plusieurs systèmes physiques en une ou plusieurs adresses virtuelles.
L'un d'eux est le maître et répond aux paquets destinés au groupe, alors
que les autres se comportent comme des "hot spares" (remplacement à
chaud et automatique du maître). Peut importe les adresses IP et MAC de
l'interface physique locale, les paquets envoyés vers l'adresse CARP
reviennent avec les informations CARP.

<p>
A intervalles paramétrables, le maître annonce sont état sur le port IP
112. Si le maître est déconnecté, les autres systèmes du groupe CARP
commencent à annoncer leur présence. L'hôte qui parvient à s'annoncer le
plus fréquemment devient le nouveau maître. Lorsque le système principal
est reconnecté, il se transforme par défaut en hôte de secours, bien
qu'il soit possible de configurer un hôte spécifique en tant que maître
par défaut lorsque cela est faisable (ex. un hôte est un Sun Fire
V120 rapide et les autres sont des SPARCstation IPCs, comparativement plus
lentes).

<p>
Bien que les équipements à haute redondance et tolérance de pannes
minimisent le besoin de CARP, ils ne le suppriment pas. Il n'existe pas
de matériel à tolérance de pannes capable de gérer le fait que quelqu'un
débranche le cordon d'alimentation ou que l'administrateur système tape
<tt>reboot</tt> dans la mauvaise fenêtre. L'utilisation de CARP aide à
rendre transparent une mise à jour ou un redémarrage du point de vue des
utilisateurs, ainsi que le test d'un programme ou une mise à jour
matérielle : si cela ne fonctionne pas, vous pouvez basculer sur le
reste du groupe jusqu'à ce que le problème soit résolu.

<p>
Il existe cependant certaines situations où CARP ne pourra pas vous
venir en aide. La conception de CARP est telle que les membres d'un
groupe doivent appartenir au même réseau physique et que chaque
interface doive avoir une véritable adresse IP fixe en plus de l'adresse
IP CARP statique. De même, les services nécessitant une connexion
constante au serveur (tels que SSH ou IRC) ne seront pas transférés de
manière transparente aux autres systèmes, bien que dans ce cas, CARP
puisse aider à minimiser le temps d'arrêt. CARP, lui-même, ne
synchronise pas les données entre applications, ceci doit être fait au
travers de "procédés alternatifs" tels que <a href="http://www.openbsd.org/cgi-
bin/man.cgi?query=pfsync&amp;sektion=4"> pfsync(4)</a> (pour du filtrage
redondant), <a href="http://rsync.samba.org/">rsync</a>, pour dupliquer
manuellement les données entre les machines, ou tout ce qui semble
approprié à votre application.

 

<h3>6.11.2 - Configuration</h3>

<p>
Le contrôle de CARP s'effectue en deux endroits :
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a> et <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Regardons tout d'abord les paramètres sysctls.

<p>
La première variable sysctl, <tt>net.inet.carp.allow</tt>, définit si
l'hôte gère ou non les paquets CARP. Bien évidemment, ceci est
nécessaire à l'utilisation de CARP. Cette variable sysctl est activée
par défaut.

<p>
La seconde, <tt>net.inet.carp.arpbalance</tt>, est utilisée pour la
balance de charge ("load balancing"). Si cette fonctionnalité est
activée, CARP effectue une empreinte (hashage) de l'IP originaire de la
requête. Cette empreinte est ensuite utilisée pour sélectionner à partir
du groupe l'hôte virtuel qui prendra en charge cette requête. Cette
fonctionnalité est désactivée par défaut.

<p>
La troisième, <tt>net.inet.carp.log</tt>, enregistre les erreurs CARP.
Désactivée par défaut.

<p>
La quatrième, <tt>net.inet.carp.preempt</tt> active la sélection
naturelle parmi les hôtes CARP. Le plus à même d'effectuer le travail (à
savoir, celui qui est capable de s'annoncer le plus fréquemment)
deviendra le maître. Celle-ci est désactivée par défaut, ce qui signifie
qu'un système qui n'est pas maître ne tentera pas de (re)gagner ce
status.

<p>
Toutes ces variables sysctl sont documentées dans <a 
href="http://www.openbsd.org/cgi-
bin/man.cgi?query=sysctl&amp;sektion=3"> sysctl(3)</a>.

<p>
Pour ce qui concerne le reste de la configuration de CARP, nous
dépendrons d'<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Deux des quatre commandes spécifiques à CARP,
<tt>advbase</tt> et <tt>advskew</tt>, définissent l'intervalle entre les
annonces CARP. La formule (en secondes) est <tt>advskew</tt> divisée par
255 puis ajoutée à <tt>advbase</tt>. <tt>advbase</tt> peut être utilisée
pour diminuer le trafic réseau ou autoriser une plus grande latence
avant qu'un hôte de sauvegarde ne prenne le relais ; <tt>advskew</tt>
vous permet de contrôler quel hôte sera le maître sans trop de délais de
basculement (si cela est nécessaire).

<p>
Ensuite, <tt>pass</tt> crée un mot de passe et <tt>vhid</tt> définit le
numéro d'identification d'hôte virtuel du groupe CARP. Vous devez
assigner un numéro unique pour chaque groupe CARP, même s'ils partagent
(pour des raisons de balance de charge) la même adresse IP. CARP est
limité à 255 groupes.

<p>
Voyons l'emploi de ces différents paramètres dans une configuration
simple. Admettons que vous déployez deux serveurs Web identiques,
<i>rachael</i>
(192.168.0.5) et <i>pris</i> (192.168.0.6), afin de remplacer un ancien système
à l'adresse 192.168.0.7. Les commandes :

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell 192.168.0.7</b>
</pre></blockquote>

<p>
créent l'interface carp0 et lui donnent un vhid de 1, le mot de passe
<i>tyrell</i>, et l'adresse IP 192.168.0.7. Afin de rendre ces changements
permanents après un redémarrage, vous pouvez créer un fichier
<tt>/etc/hostname.carp0</tt> ressemblant à :

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell 
</pre></blockquote>

<p>
Faites la même chose sur <i>pris</i>. Le système démarrant en premier
son interface CARP deviendra le maître.

<p>
Notez que sur une machine possédant plusieurs interfaces, l'interface
CARP est sur le même sous-réseau que l'interface physique.

<p>
Mais admettons que vous ne déployez pas cette solution à partir de zéro.
<i>Rachael</i> était déja en place à l'adresse 192.168.0.7. Comment allez-
vous gérer cette situation ? Heureusement, CARP ne pose pas de problème
si un système possède la même adresse IP sur son interface physique et
dans un groupe CARP, donc il n'est pas nécessaire de changer les
commandes précédentes. Cependant, il est plus propre d'avoir une adresse
IP différente pour chaque systèm, cela rend les accès et la surveillance
individuels bien plus simples.

<p>
Ajoutons un nouveau niveau de complexité ; nous souhaitons que
<i>rachael</i> reste maître lorsque cela est possible. Plusieurs raisons
peuvent nous pousser à cela : différences matérielles, simple préjudice,
"si ce système n'est pas maître, c'est qu'il y a un problème", ou
simplement connaître le maître par défaut sans avoir à recourir à des
scripts envoyant par courriel l'analyse de la sortie d'ifconfig.

<p>
Sur <i>rachael</i>, nous utiliserons la variable sysctl créée
précédemment puis nous éditerons <tt>/etc/sysctl.conf</tt> afin de
rendre ce paramètre permanent.

<blockquote><pre>
rachael# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Configurons également <i>pris</i> :

<blockquote><pre>
pris# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

<p>
Ceci décale les annonces de <i>pris</i>, ce qui signifie que
<i>rachael</i> sera maître s'il est fonctionnel.

<p>
Notez que si vous utilisez PF sur une machine CARP, vous devez utiliser
"proto carp" sur toutes les interfaces concernées, avec une ligne
similaire à : <blockquote><pre> pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Balance de charge ("load balancing")</h3>

<p>
Effectuons une avance rapide de quelques mois. Notre entreprise de
l'exemple précédent a grossi au point qu'un seul serveur Web interne
arrive tout juste à gérer la charge. Que faire ? CARP à la rescousse. Il
est temps d'essayer la balance de charge. Créons une nouvelle interface
et un nouveau groupe CARP sur <i>rachael</i> :

<blockquote><pre>
rachael# <b>ifconfig carp1 create</b>
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant 192.168.0.7</b>
</pre></blockquote>

<p>
Sur <i>pris</i>, nous allons également créer un nouveau groupe et une
nouvelle interface, puis activer la variable sysctl "preempt" :

<blockquote><pre>
pris# <b>ifconfig create carp1</b>
pris# <b>ifconfig carp1 vhid 2 pass bryant 192.168.0.7</b>
pris# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>
A présent nous avons deux groupes CARP avec la même adresse IP. Chaque
groupe est dirigé vers un hôte différent, ce qui signifie que
<i>rachael</i> restera maître du premier groupe, mais que <i>pris</i>
lui succédera comme maître dans le second.

<p>
Tout ce qu'il nous reste à faire désormais est d'activer la variable
contrôlant la balance de charge sur les deux machines, comme nous
l'avons vu précédemment :

<blockquote><pre>
# <strong>sysctl net.inet.carp.arpbalance=1</strong>
</pre></blockquote>

<p>
Bien que ces exemples ne soient que pour un cluster de deux machines, le
même principe reste valable avec plus de systèmes. Notez en revanche
qu'il n'est pas assuré que vous parveniez à une distribution de 50/50
sur les deux machines : CARP utilise une empreinte de l'IP originatrice
afin de savoir quel système répondra à la requête, indépendamment de la
charge.

<h3>6.11.4 - Plus d'information sur CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">"Firewall
Failover with pfsync and CARP"</a> (Redondance de pare-feu avec pfsync
et CARP) par Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - Utiliser OpenNTPD</h2>
Une horloge précise est importante pour plusieurs applications informatiques.
Cependant, plusieurs personnes ont remarqué que leur montre à 5 euros
est plus précise que leur ordinateur à 2000 euros. Certes, connaître la
date et l'heure est une chose importante. Mais souvent, il est plus
important de synchroniser plusieurs machines afin qu'elles s'accordent
sur la date et l'heure actuelles.
Durant un temps, <a href="http://www.ntp.org">ntp.org</a> a produit une
application "Network Time Protocol"
(<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>),
disponible dans le système des <a href="faq8.html#Ports">ports</a>,
et qui peut être utilisée pour synchroniser les horloges des machines à
travers Internet. Cependant, c'est un programme difficile à configurer,
dont le code est difficile à auditer, et qui nécessite une quantité de
mémoire vive conséquente. En somme, c'est un programme qui rend bien des
services à certaines personnes mais qui est loin d'être une solution
pour tous les utilisateurs.

<p>
<a href="http://www.openntpd.org">OpenNTPD</a> est une tentative pour
résoudre certains de ces problèmes en créant un programme compatible NTP
qui soit facile à administrer, sûr, simple et qui vous permette d'avoir
une horloge exacte sur votre ordinateur.
Le service <a href="http://www.openbsd.org/cgi-
bin/man.cgi?query=ntpd&amp;sektion=8">ntpd(8)</a> d'OpenBSD est contrôlé
à travers le fichier de configuration <a href="http://www.openbsd.org/cgi-
bin/man.cgi?query=ntpd.conf&amp;sektion=5"><tt>/etc/ntpd.conf</tt></a>
facile à comprendre.

<p>
En activant tout simplement ntpd(8) dans <a
href="faq10.html#rc">rc.conf.local</a>, votre ordinateur se
synchronisera avec des serveurs <a
href="http://www.pool.ntp.org/">pool.ntp.org</a>, une collection de
serveurs de temps publiques.
<!-- XXXversion 3.6 only -->
Si l'horloge de votre ordinateur est très décalée, vous devriez d'abord
l'ajuster autant que possible, en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>,
car ntpd(8) n'ajuste l'horloge que TRES lentement en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adjtime&amp;sektion=2">adjtime(2)</a>
; il pourra s'écouler <i>plusieurs heures</i> (ou jours, voire même
plus) avant de synchroniser correctement une horloge retardant de
quelques minutes (<i>-current</i> ajustera immédiatement l'horloge au
démarrage de la machine). Une fois votre horloge réglée de manière
précise, ntpd la gardera à un haut degré d'exactitude.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - "Mais OpenNTPD n'est pas aussi exact que l'application de
ntp.org !"</h3>
C'est probablement vrai.
Ce n'était pas un des <a
href="http://www.openntpd.org/goals.html">objectifs de la conception</a>
d'OpenNTPD. Ce programme a été d'abord conçu pour être libre, simple,
fiable et sécurisé.
Si vous avez réellement besoin d'une précision de l'ordre de la micro-
seconde, alors OpenNTPD n'est pas pour vous. Utilisez plutôt le ntpd de
ntp.org. Ce dernier restera disponible dans les ports et comme package.
Nous n'avons aucun plan ou souhait de rendre OpenNTPD bouffi en y
intégrant toutes les fonctionnalités possibles et imaginables.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - "Quelqu'un a prétendu qu'OpenNTPD était 'nuisible' !"</h3>
Certaines personnes n'ont pas compris le but d'OpenNTPD, à savoir un
moyen de synchroniser l'horloge de votre ordinateur qui soit simple,
sécurisé et facile à maintenir.

Si la maintenance d'un temps aussi exact que possible est une chose
importante, un certain nombre d'utilisateurs ont rapporté de meilleurs
résultats avec OpenNTPD par rapport au programme ntpd de ntp.org. Si la
sécurité est importante, le code d'OpenNTPD est beaucoup plus lisible
(et donc auditable) et a été écrit en utilisant les appels de fonction
natifs d'OpenBSD tels que
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3">strlcpy</a>,
au lieu d'utiliser des fonctions plus portables telles que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3">strcpy</a>.
Il a été écrit avec des principes sécurité dès le début. La sécurité n'a
pas été ajoutée par la suite. Si le fait d'amener autant de personnes
que possible à utiliser la synchronisation du temps est une chose
précieuse, OpenNTPD rend une telle entreprise très facile pour beaucoup
de personnes. Si cela est "nuisible", alors nous souhaitons ce genre de
nuisance.

<p>
Il y a des applications pour lesquelles le programme ntpd de ntp.org est
plus approprié, cependant nous croyons qu'OpenNTPD est plus que
suffisant pour les 95% d'utilisateurs restants.

<p>
Une réponse plus complête donnée par l'un des mainteneurs d'OpenNTPD et
concernant ce fait est disponible <a
href="http://www.advogato.org/person/dtucker/diary.html?start=52">ici</a>.


<a name="Wireless"></a>
<h2>6.13 - Quels sont les types de cartes Sans Fil supportées par OpenBSD ?</h2>
OpenBSD supporte un certain nombre de chipsets sans fil :
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">
awi(4)</a> AMD 802.11 PCnet Mobile
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">
an(4)</a> Aironet Communications 4500/4800
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">
wi(4)</a> Prism2/2.5/3
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">
atw(4)</a> ADMtek ADM8211
</ul>

Les adaptateurs basés sur ces composants peuvent être utilisés de la
même façon que n'importe quel autre adaptateur réseau pour connecter un
système OpenBSD à un réseau sans fil existant (prière de consulter les
pages du manuel pour des détails précis). Cependant, les cartes à base
de Prism2 et Prism3, peuvent aussi être utilisées en mode "Host-Based
Access Point", ce qui leur permet d'être utilisées comme un point
d'accès sans fil pour votre réseau, intégré à votre pare-feu.
Malheureusement, les cartes réseau à base de Prism2/Prism3 ne sont plus
produites par les fabricants du marché de masse. En effet ces derniers
utilisent maintenant des composants plus récents et à moindre coût
souvent <a href="#GenSupport">sans modifier le numéro de série.</a> La
plupart des fabricants des nouveaux composants ont choisi de ne pas
publier la documentation nécessaire pour produire des pilotes libres et
ouverts pour ces périphériques (vous pouvez les contacter et essayer de
les convaincre de changer leur politique).

<p>

D'un autre côté, les adaptateurs Prism2/Prism3 sont encore disponibles
sur les marchés d'occasion et de surplus et quelques usines comprennent
la valeur d'un composant correctement documenté et compatible avec le
logiciel libre et continuent de produire des adaptateurs à base de Prism
de qualité professionnelle. Parmi celles-ci, on peut citer <a
href="http://www.netgate.com">Netgate.com</a>. De manière générale, si
le fabricant n'identifie pas de manière explicite un produit récent
comme étant un produit à base de Prism, vous pouvez estimer qu'il n'est
pas compatible avec le pilote wi(4). Il est à noter que les nouveaux
composants Prism (tels que le Prism-GT) ne sont pas encore supportés.

<p>
Une autre méthode pour permettre à un pare-feu OpenBSD de fournir un
accès sans fil est d'utiliser une carte conventionnelle et un point
d'accès externe en mode pont. Cette méthode a l'avantage de vous
permettre de positionner l'antenne là où elle est la plus efficace.



<p>
<font color="#0000e0">
<a href="index.html">[Index de la FAQ]</a>
<a href="faq5.html">[Section 5 - Construire le Système à partir des Sources]</a>
<a href="faq7.html">[Section 7 - Contrôles du clavier et de l'affichage]</a></font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif"
border="0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.220 ]<br>
$Translation: faq6.html,v 1.60 2005/05/14 09:52:36 ajacoutot Exp $<br>
-->
$OpenBSD: faq6.html,v 1.41 2005/05/15 21:17:52 saad Exp $
</small>

</body>
</html>
