<html>
<head>
<title>11.0 - Optimisation des performances</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2002 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif"> 
<p>
<h2><font color=#e00000>11.0 - Optimisation des performances</font> 
  <hr></h2>
<p></p>

<p>
<ul>
  <h3>Table des mati&egrave;res</h3>
  <li><a href="#Network">11.1 - Mise en r&eacute;seau</a></li>
  <li><a href="#Disk"   >11.2 - E/S disque</a></li>
  <li><a href="#kmem"   >11.3 - Optimisation de kmem</a></li>
  <li><a href="#HW"     >11.4 - Choix mat&eacute;riels</a></li>
  <li><a href="#Async"  >11.5 - Pourquoi nous n'utilisons pas des montages asynchrones 
    (async mounts) ?</a></li>
  <li><a href="#XF86"   >11.6 - Optimisation de la r&eacute;solution de votre 
    &eacute;cran sous XFree86</a></li>
</ul>
<p></p> 
<hr>

<p>
<a name= "Network"></a>
<a name= "11.1"></a>
<h2>11.1 - Mise en r&eacute;seau</h2>
<p></p>

<p>Si la charge de votre serveur, passerelle ou pare-feu, est importante alors 
  vous devez vous assurez que la m&eacute;moire ne manque pas pour les diff&eacute;rentes 
  parties du noyau d&eacute;crites ci-apr&egrave;s.</p>
<P>La page du manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&apropos=0&sektion=4&format=html">options(4)</a> 
  aborde les options pr&eacute;sent&eacute;es.
<p>
<p> 
<p>Une option que vous aurez besoin de modifier pour un serveur, passerelle ou 
  pare-feu charg&eacute; est NMBCLUSTERS. Celle-ci contr&ocirc;le la taille de 
  la table de correspondance des grappes mbuf du noyau. Si recevez des messages 
  tels que &quot;mb_map full" sur votre machine, alors vous devez augmentez la 
  valeur de cette option. Si le trafic sur une interface r&eacute;seau s'arr&ecirc;te 
  sans raison valable, c'est peut-&ecirc;tre aussi un signe que vous devez augmenter 
  la valeur de cette option. Une valeur raisonnable sur architecture i386 pour 
  la plupart des interfaces ethernet 100Mbps (quelque soit le nombre d'interfaces 
  par machine) est 8192.</p>
<ul>
<strong>
option NMBCLUSTERS=8192<BR>
</strong>
</ul>
<p>
<a name= "Disk"></a>
<a name= "11.2"></a>
<h2>11.2 - E/S disque</h2>
<p></p>

<p>La vitesse des E/S sur les disques est un facteur significatif de la vitesse 
  globale de votre machine. Ce facteur devient de plus en plus important quand 
  votre machine h&eacute;berge un environnement multi utilisateur (des utilisateurs 
  de toutes les cat&eacute;gories tels que les utilisateurs qui se connectent 
  de mani&egrave;re interactive et les utilisateurs qui voient votre machine comme 
  un serveur de fichiers ou un serveur Web). Le stockage de donn&eacute;es demande 
  une attention constante et particuli&egrave;rement quand vos partitions ne contiennent 
  plus d'espace libre ou quand vos disques ne fonctionnent plus. OpenBSD poss&egrave;de 
  plusieurs options pour augmenter la vitesse des op&eacute;rations sur disque. 
  De plus il fournit des fonctionnalit&eacute;s de tol&eacute;rance aux pannes.</p>
<ul>
  Table des mati&egrave;res 
  <li><a href="#ccd">CCD</a> - Pilote de disques concat&eacute;n&eacute;s.
  <li><a href="#raid">RAID</a> 
  <li><a href="#buf">Tampon des syst&egrave;mes de fichiers</a>
  <li><a href="#softu">Soft Updates</a> 
  <li><a href="#maxvnodes">Taille du cache </a><a href="#maxvnodes">namei()</a>
</ul>
<p>
<a name="ccd"></a>
<H3>11.2.1 - CCD</H3>
<UL>
  <p>La premi&egrave;re option &agrave; utiliser est <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&apropos=0&sektion=4&format=html">ccd(4)</a>, 
    le pilotes de disques concat&eacute;n&eacute;s (Concatenated Disk Driver). 
    Il vous permet de grouper plusieurs partitions en un seul disque virtuel (ainsi 
    vous pouvez rendre plusieurs disques visibles comme un seul disque). Ce concept 
    est similaire au concept de LVM (gestion de volumes logiques) se trouvant 
    dans plusieurs versions Unix commerciales.</p>
  <p>Si votre machine tourne avec le noyau GENERIC, ccd est d&eacute;j&agrave; 
    activ&eacute;. Si ce n'est pas le cas, vous devriez l'ajouter &agrave; votre 
    configuration du kernel comme ceci : </p>
  <p> 
  <UL>
    <pre>
<strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>
  </UL>
  <p></p>
  <p>La ligne pr&eacute;c&eacute;dente vous permet de configurer jusqu'&agrave; 
    4 p&eacute;riph&eacute;riques ccd (disques virtuels). L'&eacute;tape suivante 
    consiste &agrave; choisir les partitions sur vos disques physiques que vous 
    voulez consacrer &agrave; ccd. Utilisez disklabel pour marquer ces partitions 
    en type 'ccd'. Sous certaines architectures, disklabel ne vous autorisera 
    pas &agrave; effectuer cette op&eacute;ration. Dans ce cas, marquez les en 
    'ffs'. </p>
  <p>Si vous utilisez ccd pour am&eacute;liorer les performances &agrave; travers 
    la technique du striping, il est &agrave; noter que vous n'aurez pas de performance 
    optimale &agrave; moins que vous n'utilisiez le m&ecirc;me mod&egrave;le de 
    disques avec le m&ecirc;me param&eacute;trage disklabel.</p>
  <p> Editez le fichier /etc/ccd.conf afin qu'il ressemble &agrave; ce qui suit 
    : (pour plus d'informations sur la configuration ccd, veuillez consulter <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&apropos=0&sektion=8&format=html">ccdconfig(8)</a>) 
  <UL>
    <PRE>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</PRE>
  </UL>
  <p>Pour que vos modifications prennent effet, ex&eacute;cutez :</p>
  <UL>
    <PRE># ccdconfig -C
</PRE>
  </UL>
  <p>Aussi longtemps que /etc/cdd.conf existera, ccd se configurera automatiquement 
    lors du d&eacute;marrage de la machine. A ce point, vous avez un nouveau disque 
    d&eacute;nomm&eacute; ccd0; combinaison de /dev/sd2e et /dev/sd3e. Pour le 
    partitionner, utilisez disklabel normalement. Nous vous rappelons qu'il ne 
    faut pas utiliser la partition 'c' comme une partition r&eacute;elle sur laquelle 
    vous pouvez stocker des donn&eacute;es. Assurez-vous que vos partitions soient 
    au moins d&eacute;cal&eacute;es d'un cylindre par rapport au d&eacute;but 
    du disque.</p>
  <p></p>
</UL>
<br>

<a name="raid"></a>
<H3>11.2.2 - RAID</H3>
<UL>
  <p>Une autre solution est <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&apropos=0&sektion=4&format=html">raid(4)</a> 
    que vous devez utiliser &agrave; l'aide de <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&apropos=0&sektion=8&format=html">raidctl(8)</a>, 
    commande qui vous permet de contr&ocirc;ler vos p&eacute;riph&eacute;riques 
    raid. le RAID OpenBSD est bas&eacute; sur le <a href="http://www.cs.usask.ca/staff/oster/raid.html">port 
    NetBSD</a> de Greg Oster du logiciel <a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> 
    du CMU. OpenBSD supporte les niveaux RAID 0, 1, 4 et 5.</p>
  <p>Comme pour ccd, le support raid doit &ecirc;tre configur&eacute; dans le 
    NOYAU. Mais contrairement &agrave; ccd, le support RAID n'est pas configur&eacute; 
    par d&eacute;faut dans GENERIC. Il doit compil&eacute; au niveau du noyau 
    (le support RAID ajoute 500k &agrave; la taille d'un noyau i386!) :</p>
  <p> 
  <UL>
    <pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre>
  </UL>
  <p>La configuration du RAID sous certains syst&egrave;mes d'exploitation peut 
    pr&ecirc;ter &agrave; confusion et s'av&eacute;rer difficile. Ce n'est pas 
    le cas de RAIDframe. Lisez les pages du manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&apropos=0&sektion=4&format=html">raid(4)</a> 
    et <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&apropos=0&sektion=8&format=html">raidctl(8)</a> 
    pour les d&eacute;tails complets. Il y a plusieurs options et configurations 
    possibles. Une explication d&eacute;taill&eacute;e est au-del&agrave; du p&eacute;rim&egrave;tre 
    de ce document.</p>
</UL>
<BR>

<a name="buf"></a>
<H3>11.2.3 - Tampon des syst&egrave;mes de fichiers</H3>
<UL>
  <p>Pour les serveurs de fichiers avec de la m&eacute;moire inutilis&eacute;e, 
    vous pouvez augmenter BUFCACHEPERCENT. C'est le pourcentage de la RAM qui 
    sera utilis&eacute;e comme tampon des syst&egrave;mes de fichiers. Cette option 
    sera probablement amen&eacute;e &agrave; changer quand le cache tampon unifi&eacute; 
    UBC (Unified Buffer Cache) sera compl&eacute;t&eacute; et fera partie de OpenBSD. 
    En attendant, pour augmenter BUFCACHEPERCENT, vous devriez ajouter &agrave; 
    la configuration de votre noyau une ligne comme celle-ci :</p>
</UL>
<p></p>

<p>
<UL>
<strong>option	BUFCACHEPERCENT=30</strong><BR>
</UL>
<p></p>
<ul>
  <p>Bien entendu, vous pouvez fixer cette option &agrave; une valeur aussi basse 
    que 5 % (la valeur par d&eacute;faut) ou aussi haut que 50 % (ou plus).</p>
</ul>
<br>

<a name="softu"></a>
<H3>11.2.4 - Soft updates</H3>
<UL>
  <p>Un autre outil qui peut &ecirc;tre utilis&eacute; pour acc&eacute;lerer la 
    vitesse de votre syst&egrave;me est softupdates. La mise &agrave; jour des 
    informations meta ou metainfo (qui a lieu quand vous cr&eacute;ez ou supprimez 
    des fichiers et des r&eacute;pertoires entre autres) est une des op&eacute;rations 
    les plus lentes du syst&egrave;me de fichiers BSD traditionnel. Softupdates 
    tente de mettre &agrave; jour les metainfo dans la RAM au lieu d'&eacute;crire 
    chaque mise &agrave; jour de metainfo sur le disque. Une autre cons&eacute;quence 
    est que les metainfo sur le disque devraient &ecirc;tre toujours compl&egrave;tes, 
    mais pas forc&eacute;ment &agrave; jour. Un crash syst&egrave;me ne devrait 
    donc pas n&eacute;cessiter une op&eacute;ration fsck lors du d&eacute;marrage 
    de la machine, mais seulement une version d'arri&egrave;re-plan de fsck qui 
    effectue des modifications aux metainfo en RAM (comme softupdates). Ce qui 
    veut dire que le red&eacute;marrage d'un serveur est beaucoup plus rapide 
    puisque vous n'avez pas besoin d'attendre que fsck finisse! (OpenBSD ne poss&egrave;de 
    pas cette fonctionnalit&eacute; encore). Pour en savoir plus, consultez <a href="../faq14.html#SoftUpdates">Softupdates 
    FAQ</a>.</p>
</UL>
<p></p>
<BR>

<a name="maxvnodes"></a>
<H3>11.2.5 - Taille du cache namei</H3>
<DL> 
  <DD> 
    <p>Remarque : pr&eacute;c&eacute;demment, la page du manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&sektion=4&format=html">options(4)</a> 
      recommandait de positionner l'option du noyau <tt>NVNODE=integer</tt>. Ce 
      n'est plus recommand&eacute;. Au lieu de cela, vous devriez la commande 
      <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8&format=html">sysctl(8)</a>. 
    </p>
  </DD>
  <DD> 
    <p>Le cache de traduction nom-vers-inode (name-to-inode ou namei()) contr&ocirc;le 
      la vitesse de la traduction chemin vers <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&sektion=5&format=html">inode(5)</a>. 
      Par d&eacute;faut, ce cache peut contenir <tt>NPROC * (80 + NPROC / 8)</tt> 
      entr&eacute;es. <tt>NPROC</tt> vaut <tt>20 + 16 * MAXUSERS</tt>; consultez 
      la page du manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&sektion=8&format=html">config(8)</a> 
      pour plus d&eacute;tails concernant l'option noyau <tt>maxusers</tt>. Une 
      valeur raisonnable de fixer une valeur pour le cache, si on venait &agrave; 
      remarquer &agrave; l'aide d'un outil comme <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&sektion=1&format=html">systat(1)</a> 
      des erreurs d'allocation au niveau du cache, est d'examiner la valeur courante 
      g&eacute;n&eacute;r&eacute;e avec <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8&format=html">sysctl(8)</a>, 
      qui appelle ce param&egrave;tre "<tt>kern.maxvnodes</tt>", et d'augmenter 
      cette valeur soit jusqu'&agrave; ce que les le taux de r&eacute;ponse &agrave; 
      partir du cache namei s'am&eacute;liore soit jusqu'&agrave; ce qu'on d&eacute;termine 
      que le syst&egrave;me ne b&eacute;n&eacute;ficie plus substantiellement 
      de l'augmentation de la taille du cache namei. Une fois que la valeur est 
      d&eacute;termin&eacute;e, vous pouvez la fixer au d&eacute;marrage du syst&egrave;me 
      &agrave; l'aide de <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5&format=html">sysctl.conf(5)</a>.</p>
    </DD>
</DL>
<p></p>
<BR>

<p>
<a name= "kmem"></a>
<a name= "11.3"></a>
<h2>11.3 - Optimisation de kmem</h2>
<p></p>
Cette partie a &eacute;t&eacute; d&eacute;plac&eacute;e vers la <a href="../faq11-2.5.html#11.2">section 
d'informations OpenBSD 2.5</a>. <br>
<p>
<a name= "HW"></a>
<a name= "11.4"></a>
<h2>11.4 - Choix mat&eacute;riels</h2>
<p></p>
<p><i>(Remarque - cette section est tr&egrave;s centr&eacute;e autour de l'architecture 
  i386 ou PC. Quelque part cela signifie que les autres architectures ne vous 
  donnent pas autant de choix!)</i></p>
<p>La performance de vos applications d&eacute;pend beaucoup de votre syst&egrave;me 
  d'exploitation et des fonctionnalit&eacute;s qu'il fournit. C'est peut-&ecirc;tre 
  une des raisons pour laquelle vous utilisez OpenBSD. La performance de vos applications 
  d&eacute;pend beaucoup de votre mat&eacute;riel aussi. Pour beaucoup de gens, 
  le rapport prix/performance d'un nouveau PC dot&eacute; d'un processeur Intel 
  Pentium III ou AMD Athlon est bien meilleur que le rapport prix/performance 
  d'une station Sun UltraSparc 60! Et bien s&ucirc;r, le prix de OpenBSD ne peut 
  &ecirc;tre battu.</p>
<P> Si vous allez acheter un PC, pi&egrave;ce par pi&egrave;ce ou assembl&eacute;, 
  vous devez vous assurer que vous allez acheter des composants fiables. Dans 
  le monde PC, ce n'est pas quelque chose de facile. OpenBSD peut &ecirc;tre lent 
  et souvent planter &agrave; cause de mauvais composants, des composants non 
  fiables ou un mauvais assortiment de composants. Le meilleur conseil que nous 
  pouvons vous donner est d'&ecirc;tre tr&egrave;s attentif, achetez des marques 
  et des composants qui ont &eacute;t&eacute; test&eacute;es par une autorit&eacute; 
  dans laquelle vous avez confiance. Parfois lorsque vous l&eacute;sinez sur le 
  prix d'un PC, vous perdez en qualit&eacute;!
<P> Il y a certaines choses qui vont vous aider &agrave; atteindre la meilleure 
  performance sur votre mat&eacute;riel :
<UL>
  <LI>Utilisez plusieurs disques. 
    <P>Au lieu d'acheter un disque de 20Go, achetez plusieurs disques de 9Go. 
      Bien que &ccedil;a risque de vous co&ucirc;ter plus cher, distribuer la 
      charge sur plusieurs t&ecirc;tes diminuera le temps n&eacute;cessaire pour 
      acc&eacute;der aux donn&eacute;es sur les disques. 
  </ul>
<UL>
  <LI>Utilisez du SCSI si vous avez besoin de tr&egrave;s hautes vitesses en E/S 
    disque. 
    <P>Les disques IDE tournent normalement &agrave; 5400 RPM. Les nouveaux disques 
      IDE tournent g&eacute;n&eacute;ralement &agrave; 7200 RPM. En utilisant 
      des disques IDE haut de gamme, il n'est pas raisonnable de s'attendre &agrave; 
      plus de 15 &agrave; 20 M&eacute;gaoctets de d&eacute;bit par seconde sur 
      un seul disque. En utilisant des disques SCSI haut de gamme (des disques 
      plus chers &agrave; 10000 RPM), vous pouvez atteindre des performances sup&eacute;rieures. 
      Inversement, si vous allez utiliser des disques SCSI milieu ou bas de gamme, 
      c'est une perte d'argent. Et la technologie IDE sera aussi bonne sinon meilleure. 
</ul>
<UL>
  <li>Utilisez de la SDRAM au lieu de la DRAM. 
    <P> Cette option est surtout valable aux PCs. La plupart des autres architectures 
      ne vous laissent pas le choix du type de RAM &agrave; utiliser. Vous aurez 
      de meilleures performances avec de la SDRAM par rapport &agrave; de la DRAM 
      (SIMMs). Si votre syst&egrave;me support la RDRAM ou un autre type nouveau 
      de RAM, alors vous &ecirc;tes d&eacute;j&agrave; en avance...
    <P> 
  <li>Utilisez de la m&eacute;moire ECC ou de la RAM &agrave; parit&eacute;. 
    <P>La parit&eacute; ajoute certaines fonctionnalit&eacute;s pour v&eacute;rifier 
      si les donn&eacute;es en RAM ont &eacute;t&eacute; corrompues. La m&eacute;moire 
      ECC &eacute;tend ces fonctionnalit&eacute;s et tente de corriger certaines 
      erreurs de corruption de bits &agrave; la vol&eacute;e. Cette option s'applique 
      surtout aux PCs. La plupart des autres architectures requi&egrave;rent simplement 
      de la m&eacute;moire ECC ou &agrave; parit&eacute;. Plusieurs machines non-PC 
      ne d&eacute;marreront m&ecirc;me pas avec de la RAM sans parit&eacute;. 
      Si vous n'utilisez pas de la m&eacute;moire ECC ou &agrave; parit&eacute;, 
      vous aurez peut-&ecirc;tre de la corruption de donn&eacute;es et d'autres 
      anomalies. Plusieurs fabricantsde &quot;RAM &agrave; faible co&ucirc;t 
      pour PC&quot; ne font m&ecirc;me pas une vari&eacute;t&eacute; ECC! Ce qui 
      vous aidera &agrave; les &eacute;viter! Les fabricantsde PC vendent souvent 
      plusieurs gammes de produits, organis&eacute;es en &quot;serveurs&quot; 
      et &quot;stations de travail&quot;. Les serveurs vont contenir de la RAM 
      ECC dans leur architecture. Les fabricantsde stations de travail Unix 
      utilisent de la m&eacute;moire &agrave; parit&eacute; (et maintenant ECC) 
      depuis plusieurs ann&eacute;es dans toutes leurs gammes de produits.
</ul>

<UL>
  <LI>Evitez les p&eacute;riph&eacute;riques ISA.
    <P> Alors que la plupart de gens &eacute;vitent les p&eacute;riph&eacute;riques 
      ISA, parce qu'ils sont g&eacute;n&eacute;ralement difficiles &agrave; configurer 
      et obsol&egrave;tes, il en existe encore beaucoup. Si vous utilisez un bus 
      ISA pour votre disque ou vos contr&ocirc;leurs r&eacute;seau (ou, encore 
      plus grave, pour les deux), rappelez vous que le bus ISA en lui-m&ecirc;me 
      peut &ecirc;tre un goulet d'&eacute;tranglement. Si vous avez besoin de 
      vitesse, choisissez le bus PCI. Bien entendu, il y a plusieurs cartes &agrave; 
      bus ISA qui fonctionnement bien. Malheureusement, la plupart de ces cartes 
      sont des cartes son ou des cartes s&eacute;rie.
    <P> 
  <LI> Evitez les cartes r&eacute;seau PCI bas de gamme. 
    <P> OpenBSD supporte une pl&eacute;thore de cartes r&eacute;seau PCI bas de 
      gamme Ces cartes fonctionnement tr&egrave;s bien en environnement domestique, 
      et aussi dans des environnements d'entreprise ou de recherche &agrave; d&eacute;bit 
      faible ou mod&eacute;r&eacute;. Mais si vous avez besoin de haut d&eacute;bit 
      avec un faible impact sur votre serveur, il serait plus judicieux d'opter 
      pour une carte r&eacute;seau PCI de qualit&eacute;. Malheureusement, certaines 
      cartes co&ucirc;teuses (telles que la s&eacute;rie 3com XL) ne sont pas 
      mieux que des cartes bas de gamme. Intel EtherExpress PRO/100 est une des 
      cartes les plus appr&eacute;ci&eacute;es. 
    </ul>
<p>
<a name= "Async"></a>
<a name= "11.5"></a>
<h2>11.5 - Pourquoi nous n'utilisons pas des montages asynchrones (async mounts) 
  ?</h2>
<p>Question : &quot;Je fais simplement &quot;mount -u -o async /&quot; ce qui 
  rend un package dont j'ai besoin (qui touche &agrave; une centaine de chose 
  de temps &agrave; autre) utilisable. Pourquoi le montage asynchrone n'est pas 
  vu d'un bon &#156;il et n'est pas activ&eacute; par d&eacute;faut (comme c'est 
  le cas sur d'autres versions d'Unix) ? C'est un m&eacute;canismes&ucirc;rement 
  plus simple et plus s&ucirc;r d'am&eacute;liorer les performances de certaines 
  applications.&quot;</p>
<p>R&eacute;ponse : &quot; les montages asynchrones sont en effet plus rapides 
  que des montages synchrones, mais ils sont aussi moins s&ucirc;rs. Qu'arrive-t-il 
  dans le cas d'une panne de courant ? Ou un probl&egrave;me mat&eacute;riel ? 
  la qu&ecirc;te de la vitesse ne doit pas sacrifier la fiabilit&eacute; et la 
  stabilit&eacute; du syst&egrave;me. Reportez-vous &agrave; la page du manuel 
  pour <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&apropos=0&sektion=8&format=html">mount(8)</a>."</p>
<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>
<p> D'un autre c&ocirc;t&eacute;, quand vous travaillez avec des donn&eacute;es 
  temporaires que vous pouvez recr&eacute;er apr&egrave;s un plantage, vous pouvez 
  gagnez en vitesse en utilisant une partition &agrave; part mont&eacute;e en 
  asynchrone, utilis&eacute;e uniquement pour ce type de donn&eacute;es. Si vous 
  ne voyez pas d'inconv&eacute;nient &agrave; perdre toutes les donn&eacute;es 
  de cette partition si quelque chose va mal....</p>
<p>
<a name= "XF86"></a>
<a name= "11.6"></a>
<h2>11.6 - Optimisation de la r&eacute;solution de votre &eacute;cran sous XFree86</h2>
<p>Avec plusieurs moniteurs multi-sync, il est possible de configurer un serveur 
  X avec une r&eacute;solution acceptable. Si quelqu'un a d&eacute;j&agrave; essay&eacute; 
  de faire ceci avec les utilitaires standards xf86config ou XF86Setup, il est 
  fort probable qu'il n'aie pas obtenu les meilleurs r&eacute;sultats possibles. 
  Un des aspects les plus difficiles est de simplement configurer votre moniteur 
  avec votre r&eacute;solution pr&eacute;f&eacute;r&eacute;e, puis de param&eacute;trer 
  la vitesse de balayage vertical &agrave; une valeur d'au moins 72-75 Hz, une 
  valeur o&ugrave; le scintillement de l'&eacute;cran est beaucoup moins visible 
  &agrave; l'oeil humain. Inversement, qu'en est t'il quand vous essayez de positionner 
  la vitesse de balayage vertical &agrave; une vitesse tr&egrave;s faible ? Vous 
  pouvez le positionner &agrave; 50 Hz de telle mani&egrave;re &agrave; pouvoir 
  en capturer le contenu sur une vid&eacute;o sans scintillement, mais les m&eacute;thodes 
  pour effectuer cette op&eacute;ration ne sont pas &eacute;videntes avec les 
  outils et la documentation standards de XFree86.</p>
<p>Enfin, il est possible (avec les nouveaux moniteurs du moins) d'utiliser des 
  vitesses de balayage vertical de 85 Hz et plus, afin d'obtenir une image tr&egrave;s 
  propre et agr&eacute;able &agrave; des r&eacute;solutions normalement utilis&eacute;es 
  par beaucoup de gens sur des moniteurs VGA &agrave; faible co&ucirc;t (800x600, 
  1024x768, 1152x900, 1280x1024). Le serveur X XFree86 poss&egrave;de un m&eacute;canismequi vous permet de d&eacute;crire en d&eacute;tail le mode vid&eacute;o que 
  vous voulez utiliser : C'est le ModeLine. Un ModeLine a quatre sections. Un 
  chiffre pour la dotclock (bande passante), quatre chiffres pour les temporisations 
  horizontales, quatre chiffres pour les temporisations verticales, et une section 
  optionnelle contenant une liste de drapeaux sp&eacute;cifiant d'autres caract&eacute;ristiques 
  du mode (telles que l'interla&ccedil;age, DoubleScan, ... Voir la page XF86Config(5) 
  du manuel pour plus de d&eacute;tails concernant ModeLine). 
<P> La g&eacute;n&eacute;ration d'un ModeLine s'apparente &agrave; de la magie 
  noire... Heureusement, il existe plusieurs scripts qui peuvent vous en g&eacute;n&eacute;rer 
  un. Un de ces scripts est <a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">Colas 
  XFree86 ModeLine Generator</a>. Un autre est <a href="http://xtiming.sourceforge.net/">The 
  XFree86 ModeLine Generator</a> h&eacute;b&eacute;rg&eacute; par SourceForge 
  et plusieurs autres sont disponibles sur <a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>. 
  Avant de pouvoir utiliser ces g&eacute;n&eacute;rateurs ModeLine, vous devez 
  trouver les limites de synchronisation verticale et horizontale de votre moniteur. 
  C'est souvent document&eacute; dans le manuel ou sur le site Web du constructeur. 
  Si ne vous trouvez ni l'un ni l'autre, faites une recherche sur le Web avec 
  le mod&egrave;le et la marque du moniteur. Plusieurs personnes sympathiques 
  ont rassembl&eacute; des listes avec ce type d'informations.
<P> Par exemple, supposons que vous avez un moniteur Dell D1226H. Vous avez effectu&eacute; 
  des recherches en agonisant sur le site Web de Dell pour savoir qu'il a une 
  plage de balayage horizontal de 30-95 kHz et 50-160 Hz en balayage vertical. 
  Visitez la page du g&eacute;n&eacute;rateur de ModeLine et saisissez ces informations. 
  La prochaine &eacute;tape consiste &agrave; saisir la vitesse minimale de balayage 
  vertical que vous voulez. N'importe quelle vitesse de 72 Hz et au del&agrave; 
  devrait permettre d'obtenir un scintillement peu visible. Plus vous montez la 
  vitesse, plus votre image est claire et pr&eacute;cise.
<P>Avec toutes ces informations, le script va g&eacute;n&eacute;rer un ModeLine 
  pour toutes les r&eacute;solutions 4x3 possibles que votre moniteur peut supporter, 
  et au-dessus de la vitesse minimale de balayage verticale que vous avez saisi. 
  Si quelqu'un avait saisi les sp&eacute;cifications de ce moniteur Dell avec 
  une vitesse minimale de balayage verticale de 75 Hz, le script donnera quelque 
  chose comme :
<P>
<PRE>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</PRE>
<P>Bien que ce moniteur pr&eacute;tend atteindre 1600x1200 @ 75 Hz, le script 
  ne dit pas que cette r&eacute;solution peut &ecirc;tre atteinte &agrave; 75 
  Hz. Si vous voulez pr&eacute;cis&eacute;ment avoir 1600x1200, abaissez un peu 
  votre vitesse minimale ... (Dans l'exemple qui suit, nous fixons cette vitesse 
  &agrave; 70 Hz) :
<Pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</PRE>
<P>Comme on peut le voir, ce moniteur peut faire 1600x1200 @ 74 Hz quand la vitesse 
  de point (bande passante) est limit&eacute;e &agrave; 200 Mhz. Positionnez la 
  bande passante par rapport aux limites d&eacute;finies par le moniteur.
<P>Une fois que vous avez vos ModeLines, mettez les dans le fichier /etc/XF86Config. 
  Mettez en commentaire les anciens ModeLines de telle fa&ccedil;on &agrave; pouvoir 
  les utiliser par la suite si les nouveaux ne fonctionnent pas. Ensuite choisissez 
  votre r&eacute;solution. D'abord vous devez d&eacute;terminer si X tourne en 
  mode acc&eacute;l&eacute;r&eacute; (ce qui est le cas avec la plupart des cartes 
  graphiques) afin de savoir quelle section <tt>"Screen"</tt> modifier dans le 
  fichier XF86Config. Sinon, modifiez toutes les sections Screen.
<PRE>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</PRE>
<p>La premi&egrave;re fr&eacute;quence que vous voyez apr&egrave;s la ligne &quot;Modes&quot; 
  est la fr&eacute;quence avec laquelle X va d&eacute;marrer. En appuyant sur 
  les touches CTRL-ALT-MOINS DU PAVE NUMERIQUE, ou CTRL-ALT-PLUS DU PAVE NUMERIQUE, 
  vous pouvez commuter entre les fr&eacute;quences que vous avez sp&eacute;cifi&eacute; 
  sur cette ligne. Selon la section ci-dessus, X va essayer de d&eacute;marrer 
  en mode couleur 32 bits (via la directive DefaultColorDepth sans laquelle X 
  va d&eacute;marrer en mode couleur 8 bits). La premi&egrave;re r&eacute;solution 
  qu'il essayera de charger est 1280x1024 (il suit l'ordre pr&eacute;cis&eacute; 
  dans la ligne Modes). Notez que &quot;1280x1024&quot; est simplement un label 
  des valeurs du ModeLine.</p>
<p>Il est &agrave; noter que le script de g&eacute;n&eacute;ration du ModeLine 
  poss&egrave;de des options qui permettent de rendre ces temporisations plus 
  flexibles pour les vieux ou petits moniteurs. De m&ecirc;me, il a la capacit&eacute; 
  de fournir des ModeLines pour des r&eacute;solutions sp&eacute;cifiques. Selon 
  le type de mat&eacute;riel que vous avez, il ne sera peut-&ecirc;tre pas facile 
  de l'utiliser avec les options par d&eacute;faut. Si l'image est trop grande, 
  trop large, ou trop petite, ou elle est d&eacute;cal&eacute;e horizontalement 
  ou verticalement, et les contr&ocirc;les du moniteur ne sont pas suffisants 
  pour corriger son apparence, vous pouvez utiliser xvidtune(1) afin d'ajuster 
  le ModeLine pour mieux respecter les temporisations du moniteur.</p>
<P> Sur la plupart des moniteurs modernes, il n'y a pas de limite fix&eacute;e 
  sur la bande passante. C'est pourquoi elles ne sont plus list&eacute;es dans 
  les sp&eacute;cifications. Mais plus vous augmentez la bande passante, plus 
  l'image devient floue. Ainsi, vous pouvez commencer par la bande passante (appel&eacute;e 
  aussi &quot;dotclock&quot;) de votre carte pour tester (vous ne pouvez pas abimer 
  votre moniteur comme &ccedil;a) et diminuer la bande passante au fur et &agrave; 
  mesure jusqu'&agrave; ce que vous obteniez une image pr&eacute;cise. 
<P>Cette proc&eacute;dure est inutilement complexe. XFree86 4.0 am&eacute;liore 
  nettement ce processus puisque cette version poss&egrave;de des modes internes 
  et est capable de d&eacute;couvrir les capacit&eacute;s des moniteurs &quot;plug 
  and play&quot; &agrave; travers DCC et DCC2.
<P> Vous pouvez t&eacute;l&eacute;charger le script Colas XFree86 ModeLine Generator 
  &agrave; l'adresse <a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>. 
  Vous aurez besoin de t&eacute;l&eacute;charger et de compiler l'interpr&eacute;teur 
  Klone. Cet interpr&eacute;teur se trouve dans la collection de ports sous <tt>lang/klone</tt>. 
  Les scripts sont dans le r&eacute;pertoire scripts de la distribution Klone 
  (la collection de ports les installe dans /usr/local/klone/scripts). 
<P> Deux versions du script sont incluses. La premi&egrave;re est une version 
  CGI identique &agrave; la page Web ci-dessus. La seconde est une version non-CGI 
  qui va lire votre fichier XF86Config dans sa totalit&eacute;, d&eacute;coder 
  les sp&eacute;cifications du moniteur que vous avez saisi dans xf86config/XF86Setup 
  (R&eacute;fl&eacute;chissez, avez-vous r&eacute;ellement renseign&eacute; le 
  fichier avec les sp&eacute;cifications de votre moniteur ou avez-vous gard&eacute; 
  les valeurs g&eacute;n&eacute;riques ?), et corriger les ModeLines existants 
  en cons&eacute;quence.
<p> <font color= "#0000e0"> <a href= "index.html">[Retour &agrave; l'Index G&eacute;n&eacute;ral]</a> 
  <a href= "faq10.html">[Vers la Section 10 - Gestion du syst&egrave;me]</a> <a href= "faq12.html">[Vers 
  la Section 12 - Pour utilisateurs de haut niveau]</a> </font> </p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a> <br>
<small>Originally [OpenBSD: faq11.html,v 1.24 2002/03/20 03:54:33 nick Exp ]<br>
$Translation: faq11.html,v 1.5 2002/05/05 10:06:45 saad Exp $<br>
$OpenBSD: faq11.html,v 1.1 2002/05/14 20:05:06 jufi Exp $</small> 
</body>
</html>
