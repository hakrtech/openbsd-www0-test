
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>11 - Optimisation des Performances</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2003 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de La FAQ]</a>
<a href= "faq10.html">[Section 10 - Gestion du Syst&egrave;me]</a>
<a href= "faq12.html">[Section 12 - Pour Utilisateurs de Haut Niveau]</a>
</font>

<h1><font color="#e00000">11 - Optimisation des Performances</font></h1>
<hr>

<p>
<h3>Table des mati&egrave;res</h3>
<ul>
<li><a href="#Network">11.1 - Mise en R&eacute;seau</a>
<li><a href="#Disk"   >11.2 - E/S Disque</a>
<!-- li><a href="#kmem"   >11.3 - Optimisation de kmem</a></li -->
<li><a href="#HW"     >11.4 - Choix Mat&eacute;riels</a>
<li><a href="#Async"  >11.5 - Pourquoi nous n'utilisons pas de Montage
Asynchrone ?
<li><a href="#XF86"   >11.6 - Optimisation de la R&eacute;solution de
votre &Eacute;cran sous XFree86</a>
</ul>

<hr>

<p>
Si la charge de votre serveur, passerelle ou pare-feu &eacute;tait importante,
vous souhaiteriez ou auriez besoin d'ajuster les param&egrave;tres par d&eacute;faut
pour obtenir les meilleures performances de votre &eacute;quipement.
La page du manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a> 
a pour sujet les options du noyau. Ces options sont utilis&eacute;es dans le
fichier de configuration noyau avant de compiler un noyau personnalis&eacute;,
et quelques unes de ces options sont param&eacute;trables via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>.
Pour plus de d&eacute;tails, consultez la <a href="faq5.html">FAQ 5</a>.

<p>
<a name= "Network"></a>
<a name= "11.1"></a>
<h2>11.1 - Mise en R&eacute;seau</h2>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
Une option que vous aurez besoin de modifier pour un serveur, passerelle
ou pare-feu charg&eacute; est NMBCLUSTERS. Celle-ci contr&ocirc;le la
taille de la table de correspondance des grappes mbuf du noyau. Si vous
recevez des messages tels que &quot;mb_map full" sur votre machine,
alors vous devez augmentez la valeur de cette option. Si le trafic sur
une interface r&eacute;seau s'arr&ecirc;te sans raison valable, c'est
peut-&ecirc;tre aussi un signe que vous devez augmenter la valeur de
NMBCLUSTERS. Une valeur raisonnable sur architecture i386 pour la
plupart des interfaces ethernet 100Mbps (quelque soit le nombre
d'interfaces par machine) est 8192.

<blockquote><strong>
option NMBCLUSTERS=8192
</strong></blockquote>

<p>
La valeur par d&eacute;faut de NMBCLUSTERS d&eacute;pend de la plate-forme. Elle est
comprise dans l'intervalle 256 &agrave; 2048. Elle est param&eacute;tr&eacute;e dans un
fichier en-t&ecirc;te d&eacute;pendant de la plate-forme, sauf si elle est &eacute;cras&eacute;e
par une ligne option dans le fichier de configuration du noyau.

<p>
NMBCLUSTERS peut aussi &ecirc;tre positionn&eacute;e en utilisant 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>,
qui &eacute;limine le besoin de compiler un noyau et de red&eacute;marrer pour le seul
but de changer cette option :

<blockquote><pre>
# <b>config -e -o bsd.new /bsd</b>
OpenBSD 3.3 (GENERIC) #44: Sat Mar 29 13:22:05 MST 2003
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
Enter 'help' for information
ukc> <b>nmbclust</b>
nmbclusters = 2048
ukc> <b>nmbclust 8192</b>
nmbclusters = 8192
ukc> <b>quit</b>
Saving modified kernel.
</pre></blockquote>

Ceci aura pour effet de cr&eacute;er un nouveau noyau nomm&eacute; <tt>bsd.new</tt>
dans le r&eacute;pertoire en cours, <i>et</i> de modifier le param&egrave;tre
NMBCLUSTERS dans le noyau actuel. Si tout va bien, n'oubliez pas de
copier <tt>bsd.new</tt> sous le nom <tt>/bsd</tt> avant de red&eacute;marrer.

<p>
<a name= "Disk"></a>
<a name= "11.2"></a>
<h2>11.2 - E/S Disque</h2>

<p>
La vitesse des E/S sur les disques est un facteur significatif de la
vitesse globale de votre machine. Ce facteur devient de plus en plus
important quand votre machine h&eacute;berge un environnement multi
utilisateur (des utilisateurs de toutes les cat&eacute;gories tels que
les utilisateurs qui se connectent de mani&egrave;re interactive et les
utilisateurs qui voient votre machine comme un serveur de fichiers ou un
serveur Web). Le stockage de donn&eacute;es demande une attention
constante et particuli&egrave;rement quand vos partitions ne contiennent
plus d'espace libre ou quand vos disques ne fonctionnent plus. OpenBSD
poss&egrave;de plusieurs options pour augmenter la vitesse des
op&eacute;rations sur disque. De plus il fournit des
fonctionnalit&eacute;s de tol&eacute;rance aux pannes.

<p>
Table des mati&egrave;res 
<ul>
<li><a href="#ccd">CCD</a> - Pilote de Disques Concat&eacute;n&eacute;s.
<li><a href="#raid">RAID</a>
<li><a href="#buf">Tampon Des Syst&egrave;mes de Fichiers</a>
<li><a href="#softu">Soft Updates</a>
<li><a href="#maxvnodes">Taille du cache namei()</a>
</ul>

<p>
<a name="ccd"></a>
<h3>11.2.1 - CCD</h3>

<blockquote>
La premi&egrave;re option consiste &agrave; utiliser 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>

, le Pilote de Disques Concat&eacute;n&eacute;s. Il vous permet de
grouper plusieurs partitions en un seul disque virtuel (ainsi vous
pouvez rendre plusieurs disques visibles comme un seul disque). Ce
concept est similaire au concept de LVM (gestion de volumes logiques) se
trouvant dans plusieurs versions Unix commerciales.

<p>
Si vous utilisez le noyau GENERIC, ccd est d&eacute;j&agrave; activ&eacute; (dans
<tt>/usr/src/sys/conf/GENERIC</tt>). Si vous avez personnalis&eacute; votre
noyau, vous aurez &eacute;ventuellement besoin de refaire la configuration de
votre noyau. Dans tous les cas, la ligne suivante devra figurer dans
votre fichier de configuration noyau :

<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
La ligne pr&eacute;c&eacute;dente vous permet de configurer
jusqu'&agrave; 4 p&eacute;riph&eacute;riques ccd (disques virtuels).
L'&eacute;tape suivante consiste &agrave; choisir les partitions sur vos
disques physiques que vous voulez consacrer &agrave; ccd. Utilisez
disklabel pour marquer ces partitions en type 'ccd'. Sous certaines
architectures, disklabel ne vous autorisera pas &agrave; effectuer cette
op&eacute;ration. Dans ce cas, marquez les en 'ffs'.

<p>
Si vous utilisez ccd pour am&eacute;liorer les performances &agrave;
travers la technique du striping, il est &agrave; noter que vous n'aurez
pas de performance optimale &agrave; moins que vous n'utilisiez le
m&ecirc;me mod&egrave;le de disques avec le m&ecirc;me
param&eacute;trage disklabel.

<p>
Editez le fichier /etc/ccd.conf afin qu'il ressemble &agrave; ce qui
suit : (pour plus d'informations sur la configuration ccd, veuillez
consulter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
Pour que vos modifications prennent effet, ex&eacute;cutez :

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Aussi longtemps que /etc/cdd.conf existera, ccd se configurera
automatiquement lors du d&eacute;marrage de la machine. A ce point, vous
avez un nouveau disque d&eacute;nomm&eacute; ccd0; combinaison de
/dev/sd2e et /dev/sd3e. Pour le partitionner, utilisez disklabel
normalement. Nous vous rappelons qu'il ne faut pas utiliser la partition
'c' comme une partition r&eacute;elle sur laquelle vous pouvez stocker
des donn&eacute;es. Assurez-vous que vos partitions soient au moins
d&eacute;cal&eacute;es d'un cylindre par rapport au d&eacute;but du
disque. 
</blockquote>

<p>
<a name="raid"></a>
<h3>11.2.2 - RAID</h3>

<blockquote>
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>
est une autre solution. Elle n&eacute;cessitera l'utilisation de la commande 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
pour contr&ocirc;ler vos p&eacute;riph&eacute;riques raid. le RAID
OpenBSD est bas&eacute; sur le
<a href="http://www.cs.usask.ca/staff/oster/raid.html">port NetBSD</a>
du logiciel CMU 
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> par Greg
Oster. OpenBSD supporte les niveaux RAID 0, 1, 4 et 5.
<p>
Comme pour ccd, le support raid doit &ecirc;tre configur&eacute; dans le
NOYAU. Mais contrairement &agrave; ccd, le support RAID n'est pas
configur&eacute; par d&eacute;faut dans GENERIC. Il doit compil&eacute;
au niveau du noyau (le support RAID ajoute 500k &agrave; la taille d'un
noyau i386) :

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
La configuration du RAID sous certains syst&egrave;mes d'exploitation
peut pr&ecirc;ter &agrave; confusion et s'av&eacute;rer difficile. Ce
n'est pas le cas avec RAIDframe. Consultez les pages de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>
et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
Pour des informations compl&egrave;tes. Il y a plusieurs options et
configurations possibles. Une explication d&eacute;taill&eacute;e est
au-del&agrave; du p&eacute;rim&egrave;tre du pr&eacute;sent document.
</blockquote>

<p>
<a name="buf"></a>
<h3>11.2.3 - Tampon des Syst&egrave;mes de Fichiers</h3>

<blockquote>
Pour les serveurs de fichiers avec de la m&eacute;moire
inutilis&eacute;e, vous pouvez augmenter BUFCACHEPERCENT. C'est le
pourcentage de la RAM qui sera utilis&eacute;e comme tampon des
syst&egrave;mes de fichiers. Cette option sera probablement
amen&eacute;e &agrave; changer quand le cache tampon unifi&eacute; UBC
(Unified Buffer Cache) sera compl&eacute;t&eacute; et fera partie de
OpenBSD. En attendant, pour augmenter BUFCACHEPERCENT, vous devriez
ajouter &agrave; la configuration de votre noyau une ligne comme
celle-ci :
</blockquote>

<blockquote>
<strong>option  BUFCACHEPERCENT=30</strong><BR>
</blockquote>

<blockquote>
Bien entendu, vous pouvez fixer cette option &agrave; une valeur aussi
basse que 5 % (la valeur par d&eacute;faut) ou aussi haut que 50 % (ou
plus).
</blockquote>

<blockquote>
BUFCACHEPERCENT peut aussi &ecirc;tre positionn&eacute;e en utilisant la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>
, comme indiqu&eacute; <a href="#Network">pr&eacute;c&eacute;demment</a>, ce qui &eacute;limine le
besoin de compiler un noyau dans le seul but de changer cette option.
</blockquote>

<p>
<a name="softu"></a>
<h3>11.2.4 - Soft Updates</h3>

<blockquote>
Un autre outil qui peut &ecirc;tre utilis&eacute; pour acc&eacute;lerer
la vitesse de votre syst&egrave;me est softupdates. La mise &agrave;
jour des informations meta ou metainfo (qui a lieu quand vous
cr&eacute;ez ou supprimez des fichiers et des r&eacute;pertoires entre
autres) est une des op&eacute;rations les plus lentes du syst&egrave;me
de fichiers BSD traditionnel. Softupdates tente de mettre &agrave; jour
les metainfo dans la RAM au lieu d'&eacute;crire chaque mise &agrave;
jour de metainfo sur le disque. Une autre cons&eacute;quence est que les
metainfo sur le disque devraient &ecirc;tre toujours compl&egrave;tes,
mais pas forc&eacute;ment &agrave; jour. Un crash syst&egrave;me ne
devrait donc pas n&eacute;cessiter une op&eacute;ration fsck lors du
d&eacute;marrage de la machine, mais seulement une version
d'arri&egrave;re-plan de 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
qui effectue des modifications aux metainfo en RAM (comme softupdates).
Ce qui veut dire que le red&eacute;marrage d'un serveur est beaucoup
plus rapide puisque vous n'avez pas besoin d'attendre que fsck finisse !
(OpenBSD ne poss&egrave;de pas cette fonctionnalit&eacute; encore). Pour
en savoir plus, consultez <a href="../faq14.html#SoftUpdates">La FAQ
Softupdates </a>.
</blockquote>

<p>
<a name="maxvnodes"></a>
<h3>11.2.5 - Taille du cache namei()</h3>

<dl>
<dd>
Remarque : pr&eacute;c&eacute;demment, la page du manuel  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>
recommandait de positionner l'option du noyau <tt>NVNODE=integer</tt>.
Ce n'est plus recommand&eacute;. Au lieu de cela, utilisez la
commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<p>
Le cache de traduction nom-vers-inode (name-to-inode ou <!-- need to
write the manual
page first... <a href="">namei(3)</a> -->namei()) contr&ocirc;le 
la vitesse de la traduction chemin vers 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>
Par d&eacute;faut, ce cache peut contenir <tt>NPROC * (80 + NPROC /
8)</tt> entr&eacute;es. <tt>NPROC</tt> vaut <tt>20 + 16 * MAXUSERS</tt>;
consultez la page du manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>
pour plus d&eacute;tails concernant l'option noyau <tt>maxusers</tt>.
Une valeur raisonnable de fixer une valeur pour le cache, si on venait
&agrave; remarquer &agrave; l'aide d'un outil comme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>
, des erreurs d'allocation au niveau du cache, est d'examiner la valeur
courante g&eacute;n&eacute;r&eacute;e avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
, (qui appelle ce param&egrave;tre "<tt>kern.maxvnodes</tt>") et
d'augmenter cette valeur soit jusqu'&agrave; ce que les le taux de
r&eacute;ponse &agrave; partir du cache namei s'am&eacute;liore soit
jusqu'&agrave; ce qu'on d&eacute;termine que le syst&egrave;me ne
b&eacute;n&eacute;ficie plus substantiellement de l'augmentation de la
taille du cache namei. Une fois que la valeur est
d&eacute;termin&eacute;e, vous pouvez la fixer au d&eacute;marrage du
syst&egrave;me &agrave; l'aide de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>.
</dd>
</dl>


<p>
<!-- a name= "kmem"></a>
<a name= "11.3"></a>
<h2>11.3 - Optimisation de kmem</h2>
Cette section a &eacute;t&eacute; d&eacute;plac&eacute;e vers la <a
href="faq11-2.5.html#11.2">section d'information OpenBSD 2.5</a>.
<br>
<p -->
<a name= "HW"></a>
<a name= "11.4"></a>
<h2>11.4 - Choix mat&eacute;riels</h2>
<!-- XXXchanges - check every OpenBSD release -->

<p>
<i>(Remarque - cette section est tr&egrave;s centr&eacute;e autour de
   l'architecture i386 ou PC. Quelque part cela signifie que les autres
   architectures ne vous donnent pas autant de choix! )</i>

<p>
La performance de vos applications d&eacute;pend beaucoup de votre
syst&egrave;me d'exploitation et des fonctionnalit&eacute;s qu'il
fournit. C'est peut-&ecirc;tre une des raisons pour laquelle vous
utilisez OpenBSD. La performance de vos applications d&eacute;pend
beaucoup de votre mat&eacute;riel aussi. Pour beaucoup de gens, le
rapport prix/performance d'un nouveau PC dot&eacute; d'un processeur
Intel Pentium III ou AMD Athlon est bien meilleur que le rapport
prix/performance d'une station Sun UltraSparc 60! Et bien s&ucirc;r, le
prix de OpenBSD ne peut &ecirc;tre battu.

<p>
Si vous allez acheter un PC, pi&egrave;ce par pi&egrave;ce ou
assembl&eacute;, vous devez vous assurer que vous allez acheter des
composants fiables. Dans le monde PC, ce n'est pas quelque chose de
facile. <b>OpenBSD peut &ecirc;tre lent et souvent planter &agrave;
cause de mauvais composants, des composants non fiables ou un mauvais
assortiment de composants</b>. Le meilleur conseil que nous pouvons vous
donner est d'&ecirc;tre tr&egrave;s attentif, achetez des marques et des
composants qui ont &eacute;t&eacute; test&eacute;es par une
autorit&eacute; dans laquelle vous avez confiance. Parfois lorsque vous
l&eacute;sinez sur le prix d'un PC, vous perdez en qualit&eacute;!

<p>
Il y a certaines choses qui vont vous aider &agrave; tirer le meilleur
parti de votre mat&eacute;riel :

<ul>
<li><b>Utiliser plusieurs disques.</b>
Au lieu d'acheter un disque de grande capacit&eacute;, achetez plusieurs
disques de moindre capacit&eacute;. Bien que &ccedil;a risque de vous
co&ucirc;ter plus cher, distribuer la charge sur plusieurs t&ecirc;tes
diminuera le temps n&eacute;cessaire pour acc&eacute;der aux
donn&eacute;es sur les disques. Et avec plus d'axes, vous obtiendrez un
meilleur niveau de fiabilit&eacute; et un acc&egrave;s aux donn&eacute;es plus rapide avec le
syst&egrave;me RAID.
<p>
<li><b>Utilisez du SCSI si vous avez besoin de tr&egrave;s hautes
       vitesses en E/S disque. </b>
Les disques IDE ont des vitesses de rotation comprises entre 5400TPM &agrave;
7200TPM. En utilisant des disques IDE haut de gamme, il n'est pas
raisonnable de s'attendre &agrave; plus de 15 &agrave; 20
M&eacute;gaoctets de d&eacute;bit par seconde sur un seul disque. En
utilisant des disques SCSI haut de gamme (des disques plus chers
&agrave; 10000 RPM), vous pouvez atteindre des performances
sup&eacute;rieures. Inversement, si vous allez utiliser des disques SCSI
milieu ou bas de gamme, c'est une perte d'argent. Et la technologie IDE
sera aussi bonne sinon meilleure.
<p>
Si vous mettez en place un serveur, et que vous avez besoin de plus d'un
disque, consid&eacute;rez la technologie SCSI. IDE vous limitent &agrave; deux disques
par contr&ocirc;leur. Des acc&egrave;s simultan&eacute;s &agrave; ces deux disques peuvent avoir un
impact n&eacute;gatif sur les performances E/S de ces disques. SCSI "Wide" vous
limitent &agrave; 15 par contr&ocirc;leur et g&egrave;re les acc&egrave;s simultan&eacute;s mieux qu'IDE.
Certes, la technologie SCSI est plus co&ucirc;teuse, mais sa flexibilit&eacute; et
ses performances peuvent justifier ces co&ucirc;ts dans certains
environnements.
<p>
<li><b>Utiliser de la SDRAM au lieu de la DRAM.</b>
Cette option est surtout valable pour les PCs. La plupart des autres
architectures ne vous laissent pas le choix du type de RAM &agrave;
utiliser. Vous aurez de meilleures performances avec de la SDRAM par
rapport &agrave; de la DRAM (SIMMs). Si votre syst&egrave;me supporte la
RDRAM ou un autre type nouveau de RAM, alors vous &ecirc;tes
d&eacute;j&agrave; en avance...
<p>
<li><b>Utilisez de la m&eacute;moire ECC ou de la RAM &agrave;
parit&eacute;.</b>
La parit&eacute; ajoute certaines fonctionnalit&eacute;s pour
v&eacute;rifier si les donn&eacute;es en RAM ont &eacute;t&eacute;
corrompues. La m&eacute;moire ECC &eacute;tend ces
fonctionnalit&eacute;s et tente de corriger certaines erreurs de
corruption de bits &agrave; la vol&eacute;e. Cette option s'applique
surtout aux PCs. La plupart des autres architectures requi&egrave;rent
simplement de la m&eacute;moire ECC ou &agrave; parit&eacute;. Plusieurs
machines non-PC ne d&eacute;marreront m&ecirc;me pas avec de la RAM sans
parit&eacute;. Si vous n'utilisez pas de la m&eacute;moire ECC ou
&agrave; parit&eacute;, vous aurez peut-&ecirc;tre de la corruption de
donn&eacute;es et d'autres anomalies. Plusieurs fabricantsde &quot;RAM
&agrave; faible co&ucirc;t pour PC&quot; ne font m&ecirc;me pas une
vari&eacute;t&eacute; ECC! Ce qui vous aidera &agrave; les
&eacute;viter! Les fabricantsde PC vendent souvent plusieurs gammes de
produits, organis&eacute;es en &quot;serveurs&quot; et &quot;stations de
travail&quot;. Les serveurs vont contenir de la RAM ECC dans leur
architecture. Les fabricantsde stations de travail Unix utilisent de la
m&eacute;moire &agrave; parit&eacute; (et maintenant ECC) depuis
plusieurs ann&eacute;es dans toutes leurs gammes de produits.
<p>
<li><b>Evitez les p&eacute;riph&eacute;riques ISA.</b>
Alors que la plupart de gens &eacute;vitent les
p&eacute;riph&eacute;riques ISA, parce qu'ils sont
g&eacute;n&eacute;ralement difficiles &agrave; configurer et
obsol&egrave;tes, il en existe encore beaucoup. Si vous utilisez un bus
ISA pour votre disque ou vos contr&ocirc;leurs r&eacute;seau (ou, encore
plus grave, pour les deux), rappelez vous que le bus ISA en
lui-m&ecirc;me peut &ecirc;tre un goulet d'&eacute;tranglement. Si vous
avez besoin de vitesse, choisissez le bus PCI. Bien entendu, il y a
plusieurs cartes &agrave; bus ISA qui fonctionnement bien.
Malheureusement, la plupart de ces cartes sont des cartes son ou des
cartes s&eacute;rie.
<p>
<li><b>Evitez les cartes r&eacute;seau PCI bas de gamme.</b>
OpenBSD supporte une pl&eacute;thore de cartes r&eacute;seau PCI bas de
gamme Ces cartes fonctionnement tr&egrave;s bien en environnement
domestique, et aussi dans des environnements d'entreprise ou de
recherche &agrave; d&eacute;bit faible ou mod&eacute;r&eacute;. Mais si
vous avez besoin de haut d&eacute;bit avec un faible impact sur votre
serveur, il serait plus judicieux d'opter pour une carte r&eacute;seau
PCI de qualit&eacute;. Malheureusement, certaines cartes co&ucirc;teuses
(telles que la s&eacute;rie 3com XL) ne sont pas mieux que des cartes
bas de gamme. Intel EtherExpress PRO/100 est une des cartes les plus
appr&eacute;ci&eacute;es.
</ul>

<p>
<a name= "Async"></a>
<a name= "11.5"></a>
<h2>11.5 - Pourquoi nous n'utilisons pas de montage asynchrone ("async
       mount") ?</h2>

<p>
Question : &quot;Je fais simplement &quot;mount -u -o async /&quot; ce
qui rend un package dont j'ai besoin (qui touche &agrave; une centaine
de chose de temps &agrave; autre) utilisable. Pourquoi le montage
asynchrone n'est pas vu d'un bon &#156;il et n'est pas activ&eacute; par
d&eacute;faut (comme c'est le cas sur d'autres versions d'Unix) ? C'est
un m&eacute;canismes&ucirc;rement plus simple et plus s&ucirc;r
d'am&eacute;liorer les performances de certaines applications.&quot;

<p>
R&eacute;ponse : &quot; les montages asynchrones sont en effet plus
rapides que des montages synchrones, mais ils sont aussi moins
s&ucirc;rs. Qu'arrive-t-il dans le cas d'une panne de courant ? Ou un
probl&egrave;me mat&eacute;riel ? la qu&ecirc;te de la vitesse ne doit
pas sacrifier la fiabilit&eacute; et la stabilit&eacute; du
syst&egrave;me. Reportez-vous &agrave; la page du manuel de
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>."

<pre>
             async   All I/O to the file system should be done asynchronously.
                     This is a dangerous flag to set since it does not guaran-
                     tee to keep a consistent file system structure on the
                     disk.  You should not use this flag unless you are pre-
                     pared to recreate the file system should your system
                     crash.  The most common use of this flag is to speed up
                     restore(8) where it can give a factor of two speed in-
                     crease.
</pre>

<p>
D'un autre c&ocirc;t&eacute;, quand vous travaillez avec des
donn&eacute;es temporaires que vous pouvez recr&eacute;er apr&egrave;s
un plantage, vous pouvez gagnez en vitesse en utilisant une partition
&agrave; part mont&eacute;e en asynchrone, utilis&eacute;e uniquement
pour ce type de donn&eacute;es. Encore une fois, n'effectuez cette
op&eacute;ration <i>que si</i> vous ne voyez pas d'inconv&eacute;nient
&agrave; perdre toutes les donn&eacute;es de cette partition si quelque
chose va mal. Pour cette raison, les partitions 
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
sont mont&eacute;es en mode asynchrone vu que de toute fa&ccedil;on, elles vont &ecirc;tre
&eacute;cras&eacute;es et recr&eacute;es apr&egrave;s un red&eacute;marrage.

<p>
<a name= "XF86"></a>
<a name= "11.6"></a>
<h2>11.6 - Optimisation de la R&eacute;solution de Votre &eacute;cran
       sous XFree86</h2>

<p>
Avec plusieurs moniteurs multi-sync, il est possible de configurer un
serveur X avec une r&eacute;solution acceptable. Si quelqu'un a
d&eacute;j&agrave; essay&eacute; de faire ceci avec les utilitaires
standards xf86config ou XF86Setup, il est fort probable qu'il n'aie pas
obtenu les meilleurs r&eacute;sultats possibles. Un des aspects les plus
difficiles est de simplement configurer votre moniteur avec votre
r&eacute;solution pr&eacute;f&eacute;r&eacute;e, puis de
param&eacute;trer la vitesse de balayage vertical &agrave; une valeur
d'au moins 72-75 Hz, une valeur o&ugrave; le scintillement de
l'&eacute;cran est beaucoup moins visible &agrave; l'oeil humain.
Inversement, qu'en est t'il quand vous essayez de positionner la vitesse
de balayage vertical &agrave; une vitesse tr&egrave;s faible ? Vous
pouvez le positionner &agrave; 50 Hz de telle mani&egrave;re &agrave;
pouvoir en capturer le contenu sur une vid&eacute;o sans scintillement,
mais les m&eacute;thodes pour effectuer cette op&eacute;ration ne sont
pas &eacute;videntes avec les outils et la documentation standards de
XFree86.

<p>
Enfin, il est possible (avec les nouveaux moniteurs du moins) d'utiliser
des vitesses de balayage vertical de 85 Hz et plus, afin d'obtenir une
image tr&egrave;s propre et agr&eacute;able &agrave; des
r&eacute;solutions normalement utilis&eacute;es par beaucoup de gens sur
des moniteurs VGA &agrave; faible co&ucirc;t (800x600, 1024x768,
1152x900, 1280x1024). Le serveur X XFree86 poss&egrave;de un
m&eacute;canismequi vous permet de d&eacute;crire en d&eacute;tail le
mode vid&eacute;o que vous voulez utiliser : C'est le ModeLine. Un
ModeLine a quatre sections. Un chiffre pour la dotclock (bande
passante), quatre chiffres pour les temporisations horizontales, quatre
chiffres pour les temporisations verticales, et une section optionnelle
contenant une liste de drapeaux sp&eacute;cifiant d'autres
caract&eacute;ristiques du mode (telles que l'interla&ccedil;age,
DoubleScan, ... Voir la page XF86Config(5) du manuel pour plus de
d&eacute;tails concernant ModeLine).

<p>
La g&eacute;n&eacute;ration d'un ModeLine s'apparente &agrave; de la
magie noire... Heureusement, il existe plusieurs scripts qui peuvent
vous en g&eacute;n&eacute;rer un. Un de ces scripts est 
<a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">Colas
XFree86 ModeLine Generator</a>. Un autre est 
<a href="http://xtiming.sourceforge.net/">The XFree86 ModeLine Generator</a> 
h&eacute;b&eacute;rg&eacute; par SourceForge et plusieurs
autres sont disponibles sur <a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>. 
Avant de pouvoir utiliser ces g&eacute;n&eacute;rateurs ModeLine, vous
devez trouver les limites de synchronisation verticale et horizontale de
votre moniteur. C'est souvent document&eacute; dans le manuel ou sur le
site Web du constructeur. Si ne vous trouvez ni l'un ni l'autre, faites
une recherche sur le Web avec le mod&egrave;le et la marque du moniteur.
Plusieurs personnes sympathiques ont rassembl&eacute; des listes avec ce
type d'informations.

<p>
Par exemple, supposons que vous avez un moniteur Dell D1226H. Vous avez
effectu&eacute; des recherches en agonisant sur le site Web de Dell pour
savoir qu'il a une plage de balayage horizontal de 30-95 kHz et 50-160
Hz en balayage vertical. Visitez la page du g&eacute;n&eacute;rateur de
ModeLine et saisissez ces informations. La prochaine &eacute;tape
consiste &agrave; saisir la vitesse minimale de balayage vertical que
vous voulez. N'importe quelle vitesse de 72 Hz et au del&agrave; devrait
permettre d'obtenir un scintillement peu visible. Plus vous montez la
vitesse, plus votre image est claire et pr&eacute;cise.

<p>
Avec toutes ces informations, le script va g&eacute;n&eacute;rer un
ModeLine pour toutes les r&eacute;solutions 4x3 possibles que votre
moniteur peut supporter, et au-dessus de la vitesse minimale de balayage
verticale que vous avez saisi. Si quelqu'un avait saisi les
sp&eacute;cifications de ce moniteur Dell avec une vitesse minimale de
balayage verticale de 75 Hz, le script donnera quelque chose comme :

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
Bien que ce moniteur pr&eacute;tend atteindre 1600x1200 @ 75 Hz, le
script ne dit pas que cette r&eacute;solution peut &ecirc;tre atteinte
&agrave; 75 Hz. Si vous voulez pr&eacute;cis&eacute;ment avoir
1600x1200, abaissez un peu votre vitesse minimale ... (Dans l'exemple
qui suit, nous fixons cette vitesse &agrave; 70 Hz)

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
Comme on peut le voir, ce moniteur peut faire 1600x1200 @ 74 Hz quand la
vitesse de point (bande passante) est limit&eacute;e &agrave; 200 Mhz.
Positionnez la bande passante par rapport aux limites d&eacute;finies
par le moniteur.

<p>
Une fois que vous avez vos ModeLines, mettez les dans le fichier
/etc/X11/XF86Config. Mettez en commentaire les anciens ModeLines de telle
fa&ccedil;on &agrave; pouvoir les utiliser par la suite si les nouveaux
ne fonctionnent pas. Ensuite choisissez votre r&eacute;solution. D'abord
vous devez d&eacute;terminer si X tourne en mode
acc&eacute;l&eacute;r&eacute; (ce qui est le cas avec la plupart des
cartes graphiques) afin de savoir quelle section <tt>"Screen"</tt>
modifier dans le fichier XF86Config. Sinon, modifiez toutes les sections
Screen.

<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
La premi&egrave;re fr&eacute;quence que vous voyez apr&egrave;s la ligne
&quot;Modes&quot; est la fr&eacute;quence avec laquelle X va
d&eacute;marrer. En appuyant sur les touches CTRL-ALT-MOINS DU PAVE
NUMERIQUE, ou CTRL-ALT-PLUS DU PAVE NUMERIQUE, vous pouvez commuter
entre les fr&eacute;quences que vous avez sp&eacute;cifi&eacute; sur
cette ligne. Selon la section ci-dessus, X va essayer de d&eacute;marrer
en mode couleur 32 bits (via la directive DefaultColorDepth sans
laquelle X va d&eacute;marrer en mode couleur 8 bits). La
premi&egrave;re r&eacute;solution qu'il essayera de charger est
1280x1024 (il suit l'ordre pr&eacute;cis&eacute; dans la ligne Modes).
Notez que &quot;1280x1024&quot; est simplement un label des valeurs du
ModeLine.

<p>
Il est &agrave; noter que le script de g&eacute;n&eacute;ration du
ModeLine poss&egrave;de des options qui permettent de rendre ces
temporisations plus flexibles pour les vieux ou petits moniteurs. De
m&ecirc;me, il a la capacit&eacute; de fournir des ModeLines pour des
r&eacute;solutions sp&eacute;cifiques. Selon le type de mat&eacute;riel
que vous avez, il ne sera peut-&ecirc;tre pas facile de l'utiliser avec
les options par d&eacute;faut. Si l'image est trop grande, trop large,
ou trop petite, ou elle est d&eacute;cal&eacute;e horizontalement ou
verticalement, et les contr&ocirc;les du moniteur ne sont pas suffisants
pour corriger son apparence, vous pouvez utiliser xvidtune(1) afin
d'ajuster le ModeLine pour mieux respecter les temporisations du
moniteur.

<p>
Sur la plupart des moniteurs modernes, il n'y a pas de limite
fix&eacute;e sur la bande passante. C'est pourquoi elles ne sont plus
list&eacute;es dans les sp&eacute;cifications. Mais plus vous augmentez
la bande passante, plus l'image devient floue. Ainsi, vous pouvez
commencer par la bande passante (appel&eacute;e aussi
&quot;dotclock&quot;) de votre carte pour tester (vous ne pouvez pas
abimer votre moniteur comme &ccedil;a) et diminuer la bande passante au
fur et &agrave; mesure jusqu'&agrave; ce que vous obteniez une image
pr&eacute;cise.

<p>
Cette proc&eacute;dure est inutilement complexe. XFree86 4.0
am&eacute;liore nettement ce processus puisque cette version
poss&egrave;de des modes internes et est capable de d&eacute;couvrir les
capacit&eacute;s des moniteurs &quot;plug and play&quot; &agrave;
travers DCC et DCC2.

5A
<p>
Vous pouvez t&eacute;l&eacute;charger le script Colas XFree86 ModeLine
Generator &agrave; l'adresse 
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>. 
Vous aurez besoin de t&eacute;l&eacute;charger et de compiler
l'interpr&eacute;teur Klone. Cet interpr&eacute;teur se trouve dans la
collection de ports sous <tt>lang/klone</tt>. Les scripts sont dans le
r&eacute;pertoire scripts de la distribution Klone (la collection de
ports les installe dans /usr/local/klone/scripts).

<p> 
Deux versions du script sont incluses. La premi&egrave;re est une
version CGI identique &agrave; la page Web ci-dessus. La seconde est une
version non-CGI qui va lire votre fichier XF86Config dans sa
totalit&eacute;, d&eacute;coder les sp&eacute;cifications du moniteur
que vous avez saisi dans xf86config/XF86Setup
(R&eacute;fl&eacute;chissez, avez-vous r&eacute;ellement
renseign&eacute; le fichier avec les sp&eacute;cifications de votre
moniteur ou avez-vous gard&eacute; les valeurs g&eacute;n&eacute;riques
?), et corriger les ModeLines existants en cons&eacute;quence.

<p>
<font color= "#0000e0">
<a href= "index.html">[Index de La FAQ]</a>
<a href= "faq10.html">[Section 10 - Gestion du Syst&egrave;me]</a>
<a href= "faq12.html">[Section 12 - Pour Utilisateurs de Haut Niveau]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq11.html,v 1.41 ]<br>
$Translation: faq11.html,v 1.7 2003/06/18 21:15:36 xsa Exp $<br>
$OpenBSD: faq11.html,v 1.3 2003/06/21 12:19:07 jufi Exp $<br>
</small>

</body>
</html>
