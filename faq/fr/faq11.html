<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>11 - Optimisation des Performances</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../fr/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de La FAQ]</a>
<a href= "faq10.html">[Section 10 - Gestion du Système]</a>
<a href= "faq12.html">[Section 12 - Questions Spécifiques Aux
Plates-Formes]</a>
</font>

<h1><font color="#e00000">11 - Optimisation des Performances</font></h1>
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Remarque Importante :</font></b> Le contenu de
   ce fichier est obsolète. Consultez la version anglaise 
   <a href="../faq11.html">ici</a> pour des informations à jour.

<p>
Si vous souhaitez contribuez à l'effort de traduction,
prière de consulter
<a href="../../fr/translation.html">la page de traduction</a>.

-->
<hr>

<p>
<h3>Table des matières</h3>
<ul>
<li><a href="#Disk"   >11.1 - E/S Disque</a>
<li><a href="#HW"     >11.2 - Choix Matériels</a>
<li><a href="#Async"  >11.3 - Pourquoi nous n'utilisons pas de Montage
Asynchrone ?</a>
<li><a href="#XF86"   >11.4 - Optimisation de la Résolution de
votre Écran sous X</a>
</ul>

<hr>

<p>
<a name= "Disk"></a>
<h2>11.1 - E/S Disque</h2>

<p>
La vitesse des E/S sur les disques est un facteur significatif de la
vitesse globale de votre machine. Ce facteur devient de plus en plus
important quand votre machine héberge un environnement multi utilisateur
(des utilisateurs de toutes les catégories tels que les utilisateurs qui
se connectent de manière interactive et les utilisateurs qui voient
votre machine comme un serveur de fichiers ou un serveur Web). Le
stockage de données demande une attention constante et particulièrement
quand vos partitions ne contiennent plus d'espace libre ou quand vos
disques ne fonctionnent plus. OpenBSD possède plusieurs options pour
augmenter la vitesse des opérations sur disque. De plus il fournit des
fonctionnalités de tolérance aux pannes.

<p>
Table des matières 
<ul>
<li><a href="#ccd">CCD</a> - Pilote de Disques Concaténés.
<li><a href="#raid">RAID</a>
<li><a href="#softu">Soft Updates</a>
<li><a href="#maxvnodes">Taille du cache namei()</a>
</ul>

<p>
<a name="ccd"></a>
<h3>11.1.1 - CCD</h3>

<blockquote>
La première option consiste à utiliser 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
, le Pilote de Disques Concaténés. Il vous permet de
grouper plusieurs partitions en un seul disque virtuel (ainsi vous
pouvez rendre plusieurs disques visibles comme un seul disque). Ce
concept est similaire au concept de LVM (gestion de volumes logiques) se
trouvant dans plusieurs versions Unix commerciales.

<p>
Si vous utilisez le noyau GENERIC, ccd est déjà activé (dans
<tt>/usr/src/sys/conf/GENERIC</tt>). Si vous avez personnalisé votre
noyau, vous aurez éventuellement besoin de refaire la configuration de
votre noyau. Dans tous les cas, la ligne suivante devra figurer dans
votre fichier de configuration noyau :

<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
La ligne précédente vous permet de configurer jusqu'à 4 périphériques
ccd (disques virtuels). L'étape suivante consiste à choisir les
partitions sur vos disques physiques que vous voulez consacrer à ccd.
Utilisez disklabel pour marquer ces partitions en type 'ccd'. Sous
certaines architectures, disklabel ne vous autorisera pas à effectuer
cette opération. Dans ce cas, marquez les en 'ffs'.

<p>
Si vous utilisez ccd pour améliorer les performances à travers la
technique du striping, il est à noter que vous n'aurez pas de
performance optimale à moins que vous n'utilisiez le même modèle de
disques avec le même paramétrage disklabel.

<p>
Editez le fichier /etc/ccd.conf afin qu'il ressemble à ce qui suit :
(pour plus d'informations sur la configuration ccd, veuillez consulter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
Pour que vos modifications prennent effet, exécutez :

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Aussi longtemps que /etc/cdd.conf existera, ccd se configurera
automatiquement lors du démarrage de la machine. A ce point, vous avez
un nouveau disque dénommé ccd0; combinaison de /dev/sd2e et /dev/sd3e.
Pour le partitionner, utilisez disklabel normalement. Nous vous
rappelons qu'il ne faut pas utiliser la partition 'c' comme une
partition réelle sur laquelle vous pouvez stocker des données. Assurez-
vous que vos partitions soient au moins décalées d'un cylindre par
rapport au début du disque.
</blockquote>

<p>
<a name="raid"></a>
<h3>11.1.2 - RAID</h3>

<blockquote>
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>
est une autre solution. Elle nécessitera l'utilisation de la commande 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
pour contrôler vos périphériques raid. le RAID OpenBSD est basé sur le
<a href="http://www.cs.usask.ca/staff/oster/raid.html">port NetBSD</a>
du logiciel CMU 
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> par Greg
Oster. OpenBSD supporte les niveaux RAID 0, 1, 4 et 5.
<p>
Comme pour ccd, le support raid doit être configuré dans le NOYAU. Mais
contrairement à ccd, le support RAID n'est pas configuré par défaut dans
GENERIC. Il doit compilé au niveau du noyau (le support RAID ajoute 500k
à la taille d'un noyau i386) :

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
La configuration du RAID sous certains systèmes d'exploitation peut
prêter à confusion et s'avérer difficile. Ce n'est pas le cas avec
RAIDframe. Consultez les pages de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>
et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
Pour des informations complètes. Il y a plusieurs options et
configurations possibles. Une explication détaillée est au-delà du
périmètre du présent document.
</blockquote>

<p>
<a name="softu"></a>
<h3>11.1.3 - Soft Updates</h3>

<blockquote>
Un autre outil qui peut être utilisé pour accélerer la vitesse de votre
système est softupdates. La mise à jour des informations meta ou
metainfo (qui a lieu quand vous créez ou supprimez des fichiers et des
répertoires entre autres) est une des opérations les plus lentes du
système de fichiers BSD traditionnel. Softupdates tente de mettre à jour
les metainfo dans la RAM au lieu d'écrire chaque mise à jour de metainfo
sur le disque. Une autre conséquence est que les metainfo sur le disque
devraient être toujours complètes, mais pas forcément à jour. Un crash
système ne devrait donc pas nécessiter une opération fsck lors du
démarrage de la machine, mais seulement une version d'arrière-plan de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
qui effectue des modifications aux metainfo en RAM (comme softupdates).
Ce qui veut dire que le redémarrage d'un serveur est beaucoup plus
rapide puisque vous n'avez pas besoin d'attendre que fsck finisse !
(OpenBSD ne possède pas cette fonctionnalité encore). Pour en savoir
plus, consultez <a href="faq14.html#SoftUpdates">La FAQ Softupdates
</a>.
</blockquote>

<p>
<a name="maxvnodes"></a>
<h3>11.1.4 - Taille du cache namei()</h3>

<dl>
<dd>
Remarque : précédemment, la page du manuel  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>
recommandait de positionner l'option du noyau <tt>NVNODE=integer</tt>.
Ce n'est plus recommandé. Au lieu de cela, utilisez la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<p>
Le cache de traduction nom-vers-inode (name-to-inode ou <!-- need to
write the manual
page first... <a href="">namei(3)</a> -->namei()) contrôle 
la vitesse de la traduction chemin vers 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>.
Une valeur raisonnable de fixer une valeur pour le cache, si on venait
à remarquer à l'aide d'un outil comme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>
, des erreurs d'allocation au niveau du cache, est d'examiner la valeur
courante générée avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
, (qui appelle ce paramètre "<tt>kern.maxvnodes</tt>") et d'augmenter
cette valeur soit jusqu'à ce que les le taux de réponse à partir du
cache namei s'améliore soit jusqu'à ce qu'on détermine que le système ne
bénéficie plus substantiellement de l'augmentation de la taille du cache
namei. Une fois que la valeur est déterminée, vous pouvez la fixer au
démarrage du système à l'aide de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>.
</dd>
</dl>

<p>
<a name= "HW"></a>
<h2>11.2 - Choix matériels</h2>
<!-- XXXchanges - check every OpenBSD release -->

<p>
<i>(Remarque - cette section est très centrée autour de
l'architecture i386 ou PC. Quelque part cela signifie que les autres
architectures ne vous donnent pas autant de choix! )</i>

<p>
La performance de vos applications dépend beaucoup de votre système
d'exploitation et des fonctionnalités qu'il fournit. C'est peut-être une
des raisons pour laquelle vous utilisez OpenBSD. La performance de vos
applications dépend beaucoup de votre matériel aussi. Pour beaucoup de
gens, le rapport prix/performance d'un nouveau PC doté d'un processeur
Intel Pentium III ou AMD Athlon est bien meilleur que le rapport
prix/performance d'une station Sun UltraSPARC 60! Et bien sûr, le prix
de OpenBSD ne peut être battu.

<p>
Si vous allez acheter un PC, pièce par pièce ou assemblé, vous devez
vous assurer que vous allez acheter des composants fiables. Dans le
monde PC, ce n'est pas quelque chose de facile. <b>OpenBSD peut être
lent et souvent planter à cause de mauvais composants, des composants
non fiables ou un mauvais assortiment de composants</b>. Le meilleur
conseil que nous pouvons vous donner est d'être très attentif, achetez
des marques et des composants qui ont été testées par une autorité dans
laquelle vous avez confiance. Parfois lorsque vous lésinez sur le prix
d'un PC, vous perdez en qualité!

<p>
Il y a certaines choses qui vont vous aider à tirer le meilleur parti de
votre matériel :

<ul>
<li><b>Utiliser plusieurs disques.</b>
Au lieu d'acheter un disque de grande capacité, achetez plusieurs
disques de moindre capacité. Bien que ça risque de vous coûter plus
cher, distribuer la charge sur plusieurs têtes diminuera le temps
nécessaire pour accéder aux données sur les disques. Et avec plus
d'axes, vous obtiendrez un meilleur niveau de fiabilité et un accès aux
données plus rapide avec le système RAID.
<p>
<li><b>Utilisez du SCSI si vous avez besoin de très hautes
       vitesses en E/S disque. </b>
Les disques IDE ont des vitesses de rotation comprises entre 5400TPM à
7200TPM. En utilisant des disques IDE haut de gamme, il n'est pas
raisonnable de s'attendre à plus de 15 à 20 Mégaoctets de débit par
seconde sur un seul disque. En utilisant des disques SCSI haut de gamme
(des disques plus chers à 10000 RPM), vous pouvez atteindre des
performances supérieures. Inversement, si vous allez utiliser des
disques SCSI milieu ou bas de gamme, c'est une perte d'argent. Et la
technologie IDE sera aussi bonne sinon meilleure.
<p>
Si vous mettez en place un serveur, et que vous avez besoin de plus d'un
disque, considérez la technologie SCSI. IDE vous limitent à deux disques
par contrôleur. Des accès simultanés à ces deux disques peuvent avoir un
impact négatif sur les performances E/S de ces disques. SCSI "Wide" vous
limitent à 15 par contrôleur et gère les accès simultanés mieux qu'IDE.
Certes, la technologie SCSI est plus coûteuse, mais sa flexibilité et
ses performances peuvent justifier ces coûts dans certains
environnements.
<p>
<li><b>Utiliser de la SDRAM au lieu de la DRAM.</b>
Cette option est surtout valable pour les PCs. La plupart des autres
architectures ne vous laissent pas le choix du type de RAM à utiliser.
Vous aurez de meilleures performances avec de la SDRAM par rapport à de
la DRAM (SIMMs). Si votre système supporte la RDRAM ou un autre type
nouveau de RAM, alors vous êtes déjà en avance...
<p>
<li><b>Utilisez de la mémoire ECC ou de la RAM à parité.</b>
La parité ajoute certaines fonctionnalités pour vérifier si les données
en RAM ont été corrompues. La mémoire ECC étend ces fonctionnalités et
tente de corriger certaines erreurs de corruption de bits à la volée.
Cette option s'applique surtout aux PCs. La plupart des autres
architectures requièrent simplement de la mémoire ECC ou à parité.
Plusieurs machines non-PC ne démarreront même pas avec de la RAM sans
parité. Si vous n'utilisez pas de la mémoire ECC ou à parité, vous aurez
peut-être de la corruption de données et d'autres anomalies. Plusieurs
fabricantsde &quot;RAM à faible coût pour PC&quot; ne font même pas une
variété ECC! Ce qui vous aidera à les éviter! Les fabricantsde PC
vendent souvent plusieurs gammes de produits, organisées en
&quot;serveurs&quot; et &quot;stations de travail&quot;. Les serveurs
vont contenir de la RAM ECC dans leur architecture. Les fabricantsde
stations de travail Unix utilisent de la mémoire à parité (et maintenant
ECC) depuis plusieurs années dans toutes leurs gammes de produits.
<p>
<li><b>Evitez les périphériques ISA.</b>
Alors que la plupart de gens évitent les périphériques ISA, parce qu'ils
sont généralement difficiles à configurer et obsolètes, il en existe
encore beaucoup. Si vous utilisez un bus ISA pour votre disque ou vos
contrôleurs réseau (ou, encore plus grave, pour les deux), rappelez vous
que le bus ISA en lui-même peut être un goulet d'étranglement. Si vous
avez besoin de vitesse, choisissez le bus PCI. Bien entendu, il y a
plusieurs cartes à bus ISA qui fonctionnement bien. Malheureusement, la
plupart de ces cartes sont des cartes son ou des cartes série.
<p>
<li><b>Evitez les cartes réseau PCI bas de gamme.</b>
OpenBSD supporte une pléthore de cartes réseau PCI bas de gamme Ces
cartes fonctionnement très bien en environnement domestique, et aussi
dans des environnements d'entreprise ou de recherche à débit faible ou
modéré. Mais si vous avez besoin de haut débit avec un faible impact sur
votre serveur, il serait plus judicieux d'opter pour une carte réseau
PCI de qualité. Malheureusement, certaines cartes coûteuses ne sont pas
mieux que des cartes bas de gamme. Les adaptateurs Gigabit ont souvent
de meilleures performances que les adaptateurs 10Mbps/100Mbps même
lorsqu'ils sont utilisés sur des réseaux à vitesse plus lente vu leur
meilleure mise en tampon.
</ul>

<p>
<a name= "Async"></a>
<h2>11.3 - Pourquoi nous n'utilisons pas de montage asynchrone ("async
       mount") ?</h2>

<p>
Question : &quot;Je fais simplement &quot;mount -u -o async /&quot; ce
qui rend un package dont j'ai besoin (qui touche à une centaine
de chose de temps à autre) utilisable. Pourquoi le montage
asynchrone n'est pas vu d'un bon &#156;il et n'est pas activé par
défaut (comme c'est le cas sur d'autres versions d'Unix) ? C'est
un mécanismesûrement plus simple et plus sûr
d'améliorer les performances de certaines applications.&quot;

<p>
Réponse : &quot; les montages asynchrones sont en effet plus rapides que
des montages synchrones, mais ils sont aussi moins sûrs. Qu'arrive-t-il
dans le cas d'une panne de courant ? Ou un problème matériel ? la quête
de la vitesse ne doit pas sacrifier la fiabilité et la stabilité du
système. Reportez-vous à la page du manuel de
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>."

<pre>
             async   All I/O to the file system should be done asynchronously.
                     This is a dangerous flag to set since it does not guaran-
                     tee to keep a consistent file system structure on the
                     disk.  You should not use this flag unless you are pre-
                     pared to recreate the file system should your system
                     crash.  The most common use of this flag is to speed up
                     restore(8) where it can give a factor of two speed in-
                     crease.
</pre>

<p>
D'un autre côté, quand vous travaillez avec des données temporaires que
vous pouvez recréer après un plantage, vous pouvez gagnez en vitesse en
utilisant une partition à part montée en asynchrone, utilisée uniquement
pour ce type de données. Encore une fois, n'effectuez cette opération
<i>que si</i> vous ne voyez pas d'inconvénient à perdre toutes les
données de cette partition si quelque chose va mal. Pour cette raison,
les partitions
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
sont montées en mode asynchrone vu que de toute façon, elles vont être
écrasées et recrées après un redémarrage.

<p>
<a name= "XF86"></a>
<h2>11.4 - Optimisation de la Résolution de Votre écran
       sous X</h2>

<i>Remarque : La plupart des utilisateurs n'ont pas à se soucier
de la création manuelle du ModeLine avec les versions récentes de X.
CEPENDANT, cette opération est parfois nécessaire dans des situations
unusuelles.</i>

<p>
Avec plusieurs moniteurs multi-sync, il est possible de configurer un
serveur X avec une résolution acceptable. Si quelqu'un a déjà essayé de
faire ceci avec les utilitaires standards xorgconfig ou XF86Setup, il
est fort probable qu'il n'aie pas obtenu les meilleurs résultats
possibles. Un des aspects les plus difficiles est de simplement
configurer votre moniteur avec votre résolution préférée, puis de
paramétrer la vitesse de balayage vertical à une valeur d'au moins 72-75
Hz, une valeur où le scintillement de l'écran est beaucoup moins visible
à l'oeil humain. Inversement, qu'en est t'il quand vous essayez de
positionner la vitesse de balayage vertical à une vitesse très faible ?
Vous pouvez le positionner à 50 Hz de telle manière à pouvoir en
capturer le contenu sur une vidéo sans scintillement, mais les méthodes
pour effectuer cette opération ne sont pas évidentes avec les outils et
la documentation standards de X.

<p>
Enfin, il est possible (avec les nouveaux moniteurs du moins) d'utiliser
des vitesses de balayage vertical de 85 Hz et plus, afin d'obtenir une
image très propre et agréable à des résolutions normalement utilisées
par beaucoup de gens sur des moniteurs VGA à faible coût (800x600,
1024x768, 1152x900, 1280x1024). Le serveur X possède un mécanismequi
vous permet de décrire en détail le mode vidéo que vous voulez utiliser
: C'est le ModeLine. Un ModeLine a quatre sections. Un chiffre pour la
dotclock (bande passante), quatre chiffres pour les temporisations
horizontales, quatre chiffres pour les temporisations verticales, et une
section optionnelle contenant une liste de drapeaux spécifiant d'autres
caractéristiques du mode (telles que l'interlaçage, DoubleScan, ... Voir
la page xorg.conf(5) du manuel pour plus de détails concernant
ModeLine).

<p>
La génération d'un ModeLine s'apparente à de la magie noire...
Heureusement, il existe plusieurs scripts qui peuvent vous en générer
un. Un de ces scripts est
<a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">Colas
XFree86 ModeLine Generator</a>. Un autre est 
<a href="http://xtiming.sourceforge.net/">The XFree86 ModeLine Generator</a> 
hébérgé par SourceForge et plusieurs
autres sont disponibles sur
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Avant de pouvoir utiliser ces générateurs ModeLine, vous devez trouver
les limites de synchronisation verticale et horizontale de votre
moniteur. C'est souvent documenté dans le manuel ou sur le site Web du
constructeur. Si ne vous trouvez ni l'un ni l'autre, faites une
recherche sur le Web avec le modèle et la marque du moniteur. Plusieurs
personnes sympathiques ont rassemblé des listes avec ce type
d'informations.

<p>
Par exemple, supposons que vous avez un moniteur Dell D1226H. Vous avez
effectué des recherches en agonisant sur le site Web de Dell pour savoir
qu'il a une plage de balayage horizontal de 30-95 kHz et 50-160 Hz en
balayage vertical. Visitez la page du générateur de ModeLine et
saisissez ces informations. La prochaine étape consiste à saisir la
vitesse minimale de balayage vertical que vous voulez. N'importe quelle
vitesse de 72 Hz et au delà devrait permettre d'obtenir un scintillement
peu visible. Plus vous montez la vitesse, plus votre image est claire et
précise.

<p>
Avec toutes ces informations, le script va générer un ModeLine pour
toutes les résolutions 4x3 possibles que votre moniteur peut supporter,
et au-dessus de la vitesse minimale de balayage verticale que vous avez
saisi. Si quelqu'un avait saisi les spécifications de ce moniteur Dell
avec une vitesse minimale de balayage verticale de 75 Hz, le script
donnera quelque chose comme :

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
Bien que ce moniteur prétend atteindre 1600x1200 @ 75 Hz, le script ne
dit pas que cette résolution peut être atteinte à 75 Hz. Si vous voulez
précisément avoir 1600x1200, abaissez un peu votre vitesse minimale ...
(Dans l'exemple qui suit, nous fixons cette vitesse à 70 Hz)

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
Comme on peut le voir, ce moniteur peut faire 1600x1200 @ 74 Hz quand la
vitesse de point (bande passante) est limitée à 200 Mhz. Positionnez la
bande passante par rapport aux limites définies par le moniteur.

<p>
Une fois que vous avez vos ModeLines, mettez les dans le fichier
/etc/X11/xorg.conf. Mettez en commentaire les anciens ModeLines de
telle façon à pouvoir les utiliser par la suite si les nouveaux ne
fonctionnent pas. Ensuite choisissez votre résolution. D'abord vous
devez déterminer si X tourne en mode accéléré (ce qui est le cas avec la
plupart des cartes graphiques) afin de savoir quelle section
<tt>"Screen"</tt> modifier dans le fichier xorg.conf. Sinon, modifiez
toutes les sections Screen.

<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
La première fréquence que vous voyez après la ligne &quot;Modes&quot;
est la fréquence avec laquelle X va démarrer. En appuyant sur les
touches CTRL-ALT-MOINS DU PAVE NUMERIQUE, ou CTRL-ALT-PLUS DU PAVE
NUMERIQUE, vous pouvez commuter entre les fréquences que vous avez
spécifié sur cette ligne. Selon la section ci-dessus, X va essayer de
démarrer en mode couleur 32 bits (via la directive DefaultColorDepth
sans laquelle X va démarrer en mode couleur 8 bits). La première
résolution qu'il essayera de charger est 1280x1024 (il suit l'ordre
précisé dans la ligne Modes). Notez que &quot;1280x1024&quot; est
simplement un label des valeurs du ModeLine.

<p>
Il est à noter que le script de génération du ModeLine possède des
options qui permettent de rendre ces temporisations plus flexibles pour
les vieux ou petits moniteurs. De même, il a la capacité de fournir des
ModeLines pour des résolutions spécifiques. Selon le type de matériel
que vous avez, il ne sera peut-être pas facile de l'utiliser avec les
options par défaut. Si l'image est trop grande, trop large, ou trop
petite, ou elle est décalée horizontalement ou verticalement, et les
contrôles du moniteur ne sont pas suffisants pour corriger son
apparence, vous pouvez utiliser xvidtune(1) afin d'ajuster le ModeLine
pour mieux respecter les temporisations du moniteur.

<p>
Sur la plupart des moniteurs modernes, il n'y a pas de limite fixée sur
la bande passante. C'est pourquoi elles ne sont plus listées dans les
spécifications. Mais plus vous augmentez la bande passante, plus l'image
devient floue. Ainsi, vous pouvez commencer par la bande passante
(appelée aussi &quot;dotclock&quot;) de votre carte pour tester (vous ne
pouvez pas abimer votre moniteur comme ça) et diminuer la bande passante
au fur et à mesure jusqu'à ce que vous obteniez une image précise.

<p>
Cette procédure est inutilement complexe. X.org améliore nettement ce
processus puisque cette version possède des modes internes et est
capable de découvrir les capacités des moniteurs &quot;plug and
play&quot; à travers DCC et DCC2.

5A
<p>
Vous pouvez télécharger le script Colas XFree86 ModeLine
Generator à l'adresse 
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>. 
Vous aurez besoin de télécharger et de compiler l'interpréteur Klone.
Cet interpréteur se trouve dans la collection de ports sous
<tt>lang/klone</tt>. Les scripts sont dans le répertoire scripts de la
distribution Klone (la collection de ports les installe dans
/usr/local/klone/scripts).

<p> 
Deux versions du script sont incluses. La première est une version CGI
identique à la page Web ci-dessus. La seconde est une version non-CGI
qui va lire votre fichier xorg.conf dans sa totalité, décoder les
spécifications du moniteur que vous avez saisi dans xorgconfig/XF86Setup
(Réfléchissez, avez-vous réellement renseigné le fichier avec les
spécifications de votre moniteur ou avez-vous gardé les valeurs
génériques ?), et corriger les ModeLines existants en conséquence.

<p>
<font color= "#0000e0">
<a href= "index.html">[Index de La FAQ]</a>
<a href= "faq10.html">[Section 10 - Gestion du Système]</a>
<a href= "faq12.html">[Section 12 - Questions Spécifiques Aux
Plates-Formes]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq11.html,v 1.57 ]<br>
$Translation: faq11.html,v 1.28 2006/02/09 09:37:46 ajacoutot Exp $<br>
-->
$OpenBSD: faq11.html,v 1.23 2006/02/09 21:11:55 jufi Exp $
</small>

</body>
</html>
