<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>10 - Gestion du Système</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">
<a href="../../fr/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a>
<a href= "faq9.html">[Section 9 - Migrer vers OpenBSD]</a>
<a href= "faq11.html">[Section 11 - Optimisation des Performances]</a>
</font>

<h1><font color="#e00000">10 - Gestion du Système</font></h1> 
<hr>

<p>
<h3>Table des matières</h3>
<ul>
  <li><a href="#wheel"         >10.1 - Quand j'essaie de passer root à l'aide de su, on me dit que je suis dans le mauvais groupe.</a> 
  <li><a href="#DupFS"         >10.2 - Comment dupliquer un système de fichiers ?</a> 
  <li><a href="#rc"            >10.3 - Comment démarrer des services en même temps que le système ? (Vue d'ensemble de rc(8))</a> 
  <li><a href="#RelayingDenied">10.4 - Pourquoi les utilisateurs sont interdits de relais quand ils envoient des mails à distance à travers mon système OpenBSD ?</a> 
  <li><a href="#POP"           >10.5 - J'ai mis en place POP, mais j'ai des erreurs quand j'accède à ma messagerie via POP. Que puis-je faire ?</a> 
  <li><a href="#SendmailDNS"   >10.6 - Pourquoi Sendmail ignore-t-il /etc/hosts ?</a>
  <li><a href="#HTTPS"         >10.7 - Configurer HTTP en mode sécurisé à l'aide de ssl(8)</a> 
  <li><a href="#vipw"          >10.8 - J'ai effectué des changements dans /etc/passwd avec vi(1), mais les changements ne semblent pas être pris en compte. Pourquoi ?</a> 
  <li><a href="#AddDelUser"    >10.9 - Comment je crée un compte utilisateur ? Ou je supprime un compte utilisateur ?</a> 
  <li><a href="#FTPOnly"       >10.10 - Comment puis-je créer un compte pour ftp uniquement ?</a> 
  <li><a href="#Quotas"        >10.11 - Mise en place des quotas </a>
  <li><a href="#Kerberos"      >10.12 - Mise en place de Clients et Serveurs KerberosV</a>
  <li><a href="#AnonFTP"       >10.13 - Mise en place d'un serveur FTP Anonyme</a>
  <li><a href="#ftpchroot"     >10.14 - Confiner les utilisateurs à leur répertoire HOME avec ftpd(8)</a> 
  <li><a href="#Patches"       >10.15 - Appliquer des correctifs sous OpenBSD</a>
  <li><a href="#httpdchroot"   >10.16 - Parlez moi de chroot() Apache ?</a>
  <li><a href="#rootshell"     >10.17 - Je n'aime pas le shell root standard !</a>
  <li><a href="#ksh"           >10.18 - Que puis-je faire d'autre avec ksh ?</a>
</ul>

<hr>

<p>
<a name= "wheel"></a>
<h2>10.1 - Quand j'essaie de passer root à l'aide de su, on me
    dit que je suis dans le mauvais groupe</h2>

<p> 
Les utilisateurs existant sur le système doivent être rajoutés au groupe
<kbd>"</kbd><kbd>wheel"</kbd> à la main. Ceci est fait pour des raisons
de sécurité, et vous devriez apporter une attention toute particulière
lorsque vous donnez l'accès à ce groupe à des utilisateurs. Sous
OpenBSD, les utilisateurs appartenant au groupe <kbd>wheel</kbd> sont
autorisés à utiliser le programme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su(1)</a>
pour devenir root. Les utilisateurs n'appartenant pas à ce groupe
ne peuvent pas utiliser su(1). Voici un exemple d'une entrée
<kbd>/etc/group</kbd> pour mettre l'utilisateur <strong>ericj</strong>
dans le groupe <kbd>"wheel"</kbd>.
<p>Si vous ajoutez un utilisateur avec 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>, 
vous pouvez le mettre dans le groupe wheel en répondant wheel à la
question "<tt>Invite <i>user</i> into other groups:</tt>". Ceci aura
pour effet de rajouter l'entrée correspondante dans /etc/group qui
ressemble à la ligne suivante :

<blockquote><pre>
wheel:*:0:root,ericj
</pre></blockquote>

<p>
Si vous cherchez un moyen pour limiter l'accès des utilisateurs aux
privilèges du super utilisateur, sans pour autant les mettre dans le
groupe <kbd>"wheel"</kbd>, utilisez

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>. 

<p><a name= "DupFS"></a>
<h2>10.2 - Comment dupliquer un système de fichiers ?</h2>

<p>
Pour dupliquer votre système de fichiers, utilisez 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a> 
et 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>. 
Par exemple, pour dupliquer tout ce qu'il y a sous le répertoire
<kbd>SRC</kbd> vers le répertoire <kbd>DST</kbd>, faites un :
<blockquote><pre>
# <strong>cd /SRC; dump 0f - . | (cd /DST; restore -rf - )</strong>
</pre></blockquote>

<p>
dump est conçu pour vous fournir beaucoup de possibilités de sauvegarde,
et c'est peut-être trop si vous voulez juste dupliquer une partie d'un
système de fichiers (entier). La commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a> 
peut être plus rapide pour ce genre d'opération. Le format est très
similaire à celui de dump :

<blockquote><pre>
# <strong>cd /SRC; tar cf -  . | (cd /DST; tar xpf - )</strong>
</pre></blockquote>

<p>
<a name= "rc"></a>
<h2>10.3 - Comment démarrer des services en même temps que
    le système ? (Vue d'ensemble de rc(8))</h2>

<p>
OpenBSD utilise un démarrage de type 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">rc(8)</a>.
Il utilise seulement quelques fichiers clés pour le démarrage.
<ul>
  <li>/etc/rc - Script principal. Ne doit pas être édité.
  <li>/etc/rc.conf - Fichier de configuration utilisé par
       <i>/etc/rc </i>pour savoir quels services doivent être
       démarrés en même temps que le système
  <li>/etc/rc.conf.local - Fichier de configuration servant à compléter
       /etc/rc.conf, ainsi vous ne devez pas toucher à /etc/rc.conf, ce
       qui est commode pour ceux qui (re)mettent souvent à jour leur
       système.
  <li>/etc/netstart - Script pour initialiser le réseau. Ne devrait pas
       être édité.
  <li>/etc/rc.local - Script utilisé pour l'administration locale. C'est
       là où les informations relatives à de nouveaux services ou des
       informations spécifiques à l'hôte doivent être stockées.
  <li>/etc/rc.securelevel - Script utilisé pour exécuter des commandes
       qui doivent être exécutées avant que le niveau de sécurité ne
       change. Voir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a> 
  <li>/etc/rc.shutdown - Script exécuté lors de l'arrêt de la machine.
       Mettez tout ce que vous voulez exécuter avant l'arrêt de la
       machine dans ce fichier. Voir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.shutdown&amp;sektion=8">rc.shutdown(8)</a> 
</ul>

<h3>Comment fonctionne rc(8) ?</h3>

<p>
<i>/etc/rc.conf</i> (ou <i>/etc/rc.conf.local</i>), <i>/etc/rc.local</i>
    et <i>/etc/rc.shutdown</i> sont les principaux fichiers à connaître
    par l'administrateur système. Pour comprendre le fonctionnement de
    la procédure rc(8), en voici le déroulement :

<p>
<i>/etc/rc </i>est appelé après le démarrage du noyau :
<ul> 
  <li>Les systèmes de fichiers sont vérifiés. Cette vérification n'aura
      pas lieu si le fichier /etc/fastboot existe. Ce n'est certainement
      pas une bonne idée.
  <li>Les variables de configuration sont lues à partir de
      <i>/etc/rc.conf</i> et ensuite <i>/etc/rc.conf.local</i>. Les
      paramètres dans rc.local.conf vont surpasser ceux se
      trouvant dans rc.conf.
  <li>Les systèmes de fichiers sont montés
  <li><i>/tmp </i>est nettoyé et les fichiers d'éditeurs sont préservés
  <li>Le réseau est configuré à l'aide de <i>/etc/netstart</i>
  <ul>
      <li>Les interfaces réseau sont montées.
      <li>Le nom d'hôte et le nom de domaine (ainsi que d'autres
          paramètres) sont positionnés </ul>
  <li>Les services système sont démarrés
  <li>Diverses vérifications sont effectuées (quota, savecore, etc).
  <li>Les services locaux sont démarrés à partir de
      <i>/etc/rc.local</i>
</ul>

<h3>Démarrage des services fournis avec OpenBSD</h3>

<p>
La plupart des services fournis par défaut avec OpenBSD sont lancés au
démarrage simplement en modifiant le fichier de configuration
<i>/etc/rc.conf</i>. Pour commencer, jetez un coup d'oeil au fichier
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/rc.conf">/etc/rc.conf</a> 
par défaut. Vous verrez des lignes similaires à la ligne suivante :
 
<blockquote><pre>
ftpd_flags=NO           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Une ligne telle que celle-ci montre que ftpd n'est pas lancé au
démarrage du système (du moins pas à travers rc(8), lisez la
<a href="faq10.html#AnonFTP">FAQ Serveur FTP Anonyme</a> pour plus
d'informations). Dans tous les cas, chaque ligne est dotée d'un
commentaire qui vous montrent les drapeaux utilisés dans le cadre d'une
utilisation <b>NORMALE </b>du service. Cela ne veut pas dire que vous
devez appeler ce service avec ces mêmes drapeaux. Vous pouvez toujours
utiliser man(1) pour savoir comment démarrer un service donné de la
manière que vous souhaitez. Par exemple, voici la ligne par défaut
concernant httpd(8) :
<blockquote><pre>
httpd_flags=NO          # for normal use: "" (or "-DSSL" after reading ssl(8))
</pre></blockquote>

<p>
D'après cet exemple, vous pouvez voir qu'aucun drapeau n'est nécessaire
pour démarrer httpd normalement. Ainsi, la ligne "<b> httpd_flags=""</b>
suffit. Mais pour démarrer httpd avec le support ssl (Reportez vous à la
<a href="#HTTPS">FAQ SSL</a> ou à
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>
), vous devez démarrer httpd avec une ligne comme celle-ci : "httpd_flags="-
DSSL"".

<p>
Une autre approche serait de ne jamais toucher à <i>/etc/rc.conf</i>. Au
contraire, créez le fichier <i>/etc/rc.conf.local</i> et ne copiez que
les lignes que vous comptez changer dans <i>/etc/rc.conf</i> et
modifiez-les comme vous voulez. Ceci peut rendre vos mises à jour
futures plus faciles -- tous les changements se trouvant dans un
fichier.

<h3>Démarrage et configuration des services locaux</h3>

<p>
Pour les services que vous installez via la collection de ports ou
d'autres méthodes, vous devez utiliser le fichier
<i>/etc/rc.local</i>. Par exemple, j'ai installé un service
fourni par l'applicatif /usr/local/sbin/daemonx. Je souhaite que ce
service soit lancé au démarrage. Pour cela, je rajoute les lignes
suivantes dans <i>/etc/rc.local</i> :

<blockquote><pre>
if [ -x /usr/local/sbin/daemonx ]; then
             echo -n ' daemonx';       /usr/local/sbin/daemonx
fi
</pre></blockquote>

<p>
(Si le service ne se détache pas automatiquement lors de son démarrage,
souvenez-vous de rajouter "&amp;" à la fin de la commande.)

<p>
A partir de là, ce service sera lancé au démarrage. Vous pourrez voir
toutes les erreurs au démarrage. Un démarrage normal sans erreurs
affichera le message suivant :
<blockquote><pre>
Starting local daemons: daemonx.
</pre></blockquote>

<h3>rc.shutdown</h3>

<p>
<i>/etc/rc.shutdown</i> est un script exécuté à l'arrêt de la machine.
Toutes les tâches à effectuer avant l'arrêt du système devront être
ajoutées à ce fichier. Si vous avez apm, vous pouvez aussi positionner
"powerdown=YES". C'est l'équivalent de "shutdown -p".

<p>
<a name= "RelayingDenied"></a>
<h2>10.4 - Pourquoi les utilisateurs sont interdits de relais quand ils
    envoient des mails à distance à travers mon système OpenBSD ?</h2>

<p> 
Essayez ceci : 

<blockquote><pre>
# <strong>cat /etc/mail/sendmail.cf | grep relay-domains</strong>
</pre></blockquote>

<p>
Le résultat ressemblerait à la ligne suivante :

<blockquote><pre>
FR-o /etc/mail/relay-domains
</pre></blockquote>

<p>
Si ce fichier n'existe pas, créez le. Vous devez saisir les hôtes qui
envoient des messages à distance en respectant la syntaxe suivante :

<blockquote><pre>
.domain.com    #Allow relaying for/to any host in domain.com
sub.domain.com #Allow relaying for/to sub.domain.com and any host in that domain
10.2           #Allow relaying from all hosts in the IP net 10.2.*.*
</pre></blockquote>

<p>
N'oubliez pas d'envoyer un signal 'HangUP' à sendmail (signal qui
notifie la plupart des processus de relire leur fichier de
configuration) :

<blockquote><pre>
# <Strong>kill -HUP `head -1 /var/run/sendmail.pid`</strong>
</pre></blockquote>

<p>
<h3>Pour plus d'informations </h3>

<p>
<ul>
<li><a href="http://www.sendmail.org/~ca/email/relayingdenied.html">http://www.sendmail.org/~ca/email/relayingdenied.html</a>
<li><a href="http://www.sendmail.org/tips/relaying.html">http://www.sendmail.org/tips/relaying.html</a>
<li><a href="http://www.sendmail.org/antispam.html">http://www.sendmail.org/antispam.html</a>
</ul>

<p>
<a name= "POP"></a>
<h2>10.5 - J'ai mis en place POP, mais j'ai des erreurs quand
    j'accède à ma messagerie via POP. Que puis-je faire ? </h2>

<p>
La plupart des problèmes rencontrés avec POP sont liés aux fichiers
temporaires et aux fichiers verrous. Si votre serveur POP renvoie une
erreur du type :

<blockquote><pre>
-ERR Couldn't open temporary file, do you own it?
</pre></blockquote>

<p>
Essayez de positionner les permissions comme suit :

<blockquote><pre>
permission in  /var
drwxrwxr-x   2 bin     mail     512 May 26 20:08 mail


permissions in  /var/mail
-rw-------   1 username   username        0 May 26 20:08 username
</pre></blockquote>

<p>
Vérifiez aussi que l'utilisateur possède son propre fichier /var/mail.
Bien évidemment, ceci devrait être le cas (comme par exemple
l'utilisateur joe qui possède /var/mail/joe) mais si ça n'a pas été
configuré proprement, le problème viendrait de là !

<p>
Bien entendu, si vous donner l'accès à /var/mail en écriture au groupe
mail, vous allez probablement vous exposer à des vagues et obscurs
problèmes de sécurité. Il se pourrait que ça ne pose aucun problème mais
on ne sait jamais (et particulièrement si vous êtes un site de haut vol,
un FAI,...) ! Il existe plusieurs services POP de la collection de ports
OpenBSD. Si possible, utilisez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=popa3d&amp;sektion=8">popa3d(8)</a> 
disponible dans le système de base d'OpenBSD. Ou peut-être vous avez
sélectionné les mauvaises options pour votre programme POP serveur
(comme le dot locking). Ou vous avez peut-être simplement besoin de
changer le répertoire dans lequel les verrous sont crées (bien que les
opérations de verrouillage ne devraient être bénéfiques qu'au service
POP).

<p>
<b>PS:</b> Il est à noter que OpenBSD n'a pas de groupe "mail". Vous
   devez en créer un, si nécessaire, dans le fichier <i>/etc/group</i>.
   La ligne suivante devrait suffire :

<blockquote><pre>
mail:*:6:
</pre></blockquote>

<p>
<a name="SendmailDNS"></a>
<h2>10.6 - Pourquoi Sendmail ignore-t-il le fichier <tt>/etc/hosts</tt>
    ?</h2>

<p>
Par défaut, Sendmail utilise le DNS pour la résolution de nom, non le
fichier <tt>/etc/hosts</tt>. Ce comportement peut être changé par
l'usage du fichier <tt>/etc/mail/service.switch</tt>.

<p>
Si vous désirez interroger le fichier d'hôtes avant les serveurs DNS,
créez un fichier <tt>/etc/mail/service.switch</tt> contenant les lignes
suivantes :

<pre>
   hosts      files dns
</pre>

<p>
Si vous désirez interroger QUE le le fichier d'hôtes, utilisez ce qui
suit :

<pre>
   hosts      files
</pre>

<p>
Envoyez un signal HUP à Sendmail :

<pre>
   # <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre>

<p>
et les changements prendront effet.


<p>
<a name= "HTTPS"></a>
<h2>10.7 - Configurer HTTP en mode sécurisé à
    l'aide de SSL(8)</h2>

<p>
OpenBSD est fourni avec des librairies RSA et un service httpd
supportant SSL. Pour utiliser SSL avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>, 
vous devez d'abord créer un certificat. Ce certificat sera stocké dans
<i>/etc/ssl/private/</i>. Les étapes décrites ici sont en partie prises
de la page de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>. 
Lisez la pour plus d'informations. Cette partie de la FAQ s'intéresse
seulement à la génération d'un certificat RSA pour les serveurs Web.
Elle ne décrit pas les certificats serveur DSA. Pour plus d'informations
à ce sujet, lisez la page de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>.

<p>
Pour commencer, vous aurez besoin de créer votre clé serveur et le
certificat en utilisant OpenSSL :

<div style="margin-left: 2em">
<pre>
# <strong>openssl genrsa -out /etc/ssl/private/server.key 1024</strong>
</pre>
</div>

<p>
Ou si vous voulez que la clé soit cryptée avec un mot de passe que vous
devez saisir à chaque démarrage des serveurs

<div style="margin-left: 2em">
<pre>
# <strong>openssl genrsa -des3 -out /etc/ssl/private/server.key 1024</strong>
</pre>
</div>

<p>
La prochaine étape consiste à générer une requête de signature de
certificat qui est utilisée pour permettre à une autorité de
certification (CA) de signer votre certificat. Pour cela, utilisez la
commande suivante :

<div style="margin-left: 2em">
<pre>
# <strong>openssl req -new -key /etc/ssl/private/server.key -out /etc/ssl/private/server.csr</strong>
</pre>
</div>

<p>
Le fichier <i>server.csr</i> pourra alors être communiqué à une autorité
de certification qui signera la clé. Une de ces autorités est <b>Thawte
Certification</b> que vous pourrez joindre à l'adresse
<a href="http://www.thawte.com/">http://www.thawte.com/</a>.

<p>
Si vous ne pouvez pas vous permettre un tel service, ou si vous voulez
auto signer le certificat, vous pouvez utiliser la commande suivante :

<div style="margin-left: 2em">
<pre>
# <strong>openssl x509 -req -days 365 -in /etc/ssl/private/server.csr \
       -signkey /etc/ssl/private/server.key -out /etc/ssl/server.crt</strong>
</pre>
</div>

<p> 
Avec <i>/etc/ssl/server.crt</i> et <i>/etc/ssl/private/server.key</i>,
vous devez être désormais capable de démarrer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a> 
avec le drapeau <b>-DSSL</b> (consultez la
<a href="#rc">section à propos de rc(8) dans cette faq</a>), activant
ainsi les transactions https sur le port 443 de votre machine.

<p>
<a name= "vipw"></a>
<h2>10.7 - J'ai effectué des changements dans /etc/passwd avec
    vi(1), mais les changements ne semblent pas être pris en compte.
    Pourquoi ?</h2>

<p>
Si vous éditez <i>/etc/passwd</i>, vos modifications seront perdues.
OpenBSD génère <i>/etc/passwd</i> dynamiquement avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pwd_mkdb&amp;sektion=8">pwd_mkdb(8)</a>. 
Le fichier principal de mots de passe sous OpenBSD est
<i>/etc/master.passwd</i>. D'après pwd_mkdb(8),

<blockquote><pre>
FILES
     /etc/master.passwd  fichier courant de mots de passe 
     /etc/passwd         fichier de mots de passe au style "6th Edition"
     /etc/pwd.db         fichier non sécurisé de mots de passe au format base de données
     /etc/pwd.db.tmp     fichier temporaire
     /etc/spwd.db        fichier sécurisé de mots de passe au format base de données
     /etc/spwd.db.tmp    fichier temporaire
</pre></blockquote>

<p>
Dans un fichier de mots de passe Unix traditionnel, toutes les
informations y compris le mot de passe crypté de l'utilisateur sont à la
disposition de n'importe quel utilisateur du système (et c'est la cible
principale de programmes tels que Crack). 4.4BSD a introduit le fichier
master.passwd qui a un format étendu (avec les options additionnelles
par rapport à /etc/passwd). Ce fichier n'est accessible que pour root.
Pour un accès plus rapide aux données, les appels à la librairie qui
utilisent ce type d'informations accèdent normalement à /etc/pwd.db et à
/etc/spwd.db.

<p>
OpenBSD met à votre disposition un outil qui vous permet d'éditer le
fichier de mots de passe. Cet outil s'appelle vipw(8). vipw utilisera vi
(ou votre éditeur favori tel que défini par $EDITOR) pour éditer
/etc/master.passwd. Suite à vos modifications, vipw recréera
/etc/passwd, /etc/pwd.db, et /etc/spwd.db qui tiendront compte de vos
modifications. vipw verrouille aussi l'accès à ces fichiers de telle
façon à en interdire l'accès à quiconque essaie d'en changer le contenu
en même temps que vous.

<p>
<a name= "AddDelUser"></a>
<h2>10.8 - Comment je crée un compte utilisateur ? Ou je supprime
    un compte utilisateur ?</h2>

<p>
OpenBSD offre deux commandes pour facilement créer des comptes
utilisateurs sur le système :
<ul>
        <li><a href="#adduser">adduser(8)</a>
        <li><a href="#user">user(8)</a>
</ul>

<a name="adduser"></a> 
<p>
La manière la plus facile pour créer un compte utilisateur sous OpenBSD
est d'utiliser le script
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>.
Ce script est paramétrable à travers le fichier
<i>/etc/adduser.conf</i>. Bien que c'est la méthode
recommandée pour créer des comptes utilisateurs, il est
toujours possible de les créer à la main en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw(8)</a>. 
adduser(8) permet d'effectuer des vérifications sur la cohérence de
<i>/etc/passwd</i>, <i>/etc/group</i>, et les bases de données shell.
adduser(8) crée pour vous les entrées correspondantes et les répertoires
$HOME. Il peut aussi envoyer un message de bienvenue aux utilisateurs.
Le comportement de ce programme peut être adapté à vos besoins. Pour
illustrer notre propos, prenons comme exemple la création du compte
<b>testuser</b>. Le répertoire de cet utilisateur sera
<i>/home/testuser</i>. L'utilisateur fera partie du groupe <b>guest
</b>comme groupe et aura un shell <i>/bin/ksh </i>.

<blockquote><pre>
# <strong>adduser</strong>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Reading /etc/login.conf
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>testuser</b>
Enter full name []: <b>Test FAQ User</b>
Enter shell csh ksh nologin sh [sh]: <b>ksh</b>
Uid [1002]: <b><i>Enter</i></b>
Login group testuser [testuser]: <b>guest</b>
Login group is ``guest''. Invite testuser into other groups: guest no 
[no]: <b>no</b>
Login class auth-defaults auth-ftp-defaults daemon default staff 
[default]: <b><i>Enter</i></b>
Enter password []: <b><i>Type password, then Enter</i></b>
Enter password again []: <b><i>Type password, then Enter</i></b>

Name:        testuser
Password:    ****
Fullname:    Test FAQ User
Uid:         1002
Gid:         31 (guest)
Groups:      guest
Login Class: default
HOME:        /home/testuser
Shell:i      /bin/ksh
OK? (y/n) [y]: <b>y</b>
Added user ``testuser''
Copy files from /etc/skel to /home/testuser
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<p>
Pour supprimer des comptes utilisateurs, utilisez la commande 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rmuser&amp;sektion=8">rmuser(8)</a>. 
Cette commande supprimera toute chose relative à l'utilisateur. Elle
supprimera son entrée
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=1">crontab(1)</a>, 
son répertoire $HOME (s'il lui appartient), et son courrier. Bien
évidemment, cette commande supprimera aussi les entrées correspondantes
dans <i>/etc/passwd</i> et <i>/etc/group</i>. Comme exemple, nous allons
utiliser cette commande pour supprimer le compte utilisateur
précédemment crée. Notez que la commande vous demande l'identifiant du
compte et si oui ou non elle doit supprimer le répertoire home de
l'utilisateur.

<blockquote><pre>
# <strong>rmuser</strong>
Enter login name for user to remove: <strong>testuser</strong>
Matching password entry:

testuser:$2a$07$ZWnBOsbqMJ.ducQBfsTKUe3PL97Ve1AHWJ0A4uLamniLNXLeYrEie:1002
:31::0:0:Test FAQ User:/home/testuser:/bin/ksh

Is this the entry you wish to remove? <strong>y</strong>
Remove user's home directory (/home/testuser)? <strong>y</strong>
Updating password file, updating databases, done.
Updating group file: done.
Removing user's home directory (/home/testuser): done.
</pre></blockquote>

<a name="user"></a>
<h3>Créer des comptes utilisateurs via user(8)</h3>

<p>
Ces outils sont moins interactifs que la commande 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>, 
ce qui en facilite l'usage dans des scripts.

<p>
La liste complète des outils est :
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=8">group(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupadd&amp;sektion=8">groupadd(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupdel&amp;sektion=8">groupdel(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupinfo&amp;sektion=8">groupinfo(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupmod&amp;sektion=8">groupmod(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=user&amp;sektion=8">user(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=useradd&amp;sektion=8">useradd(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userdel&amp;sektion=8">userdel(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userinfo&amp;sektion=8">userinfo(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=usermod&amp;sektion=8">usermod(8)</a> 
</ul>

<h4>Création effective des comptes utilisateurs</h4>

<p>
Etant donné que la commande user(8) n'est pas interactive, la manière la
plus simple et la plus efficace pour créer des comptes utilisateurs est
d'utiliser la commande adduser(8). La commande <i>/usr/sbin/user</i> est
seulement une interface aux autres commandes <i>/usr/sbin/user*</i>.
Ainsi, dans l'exemple qui suit il est possible d'utiliser soit <b>user
add</b> soit <b>useradd</b>. Le choix est votre et ne change rien au
résultat. <p>Dans cet exemple, nous allons créer un compte avec les
mêmes spécificités que le compte crée
<a href="#adduser">précédemment</a>. useradd(8) est bien plus facile à
utiliser si vous connaissez les paramètres par défaut avant de créer un
compte utilisateur. Ces paramètres se trouvent dans le fichier
<i>/etc/usermgmt.conf </i>et peuvent être visualisés comme suit :

<blockquote><pre>
$ <strong>user add -D</strong>
group           users
base_dir        /home
skel_dir        /etc/skel
shell           /bin/csh
inactive        0
expire          Null (unset)
range           1000..60000
</pre></blockquote>

<p>
Ces paramètres vont être appliqués à chaque nouveau compte si vous ne
changez pas leur valeur en utilisant des options en ligne de commande.
Par exemple, dans notre cas nous voulons que l'utilisateur appartienne
au groupe <b>guest </b> et non pas à <b>users</b>. Il est à noter que
lors de la création des comptes utilisateurs, les mots de passe doivent
être spécifiés sous leur forme cryptée en ligne de commande. Vous devez
donc utiliser, au préalable, l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=encrypt&amp;sektion=1">encrypt(1)</a> 
pour créer le mot de passe. Par exemple : Les mots de passe par défaut
sous OpenBSD utilisent l'algorithme Blowfish avec 6 réitérations. Voici
un exemple d'utilisation de la commande encrypt :

<blockquote><pre>
$ <strong>encrypt -p -b 6</strong>
Enter string:
$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq
</pre></blockquote>

<p> 
Maintenant que nous avons le mot de passe crypté, nous sommes prêts à
créer le compte utilisateur :

<blockquote><pre>
# <strong>user add -p '$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq' -u 1002 \
-s /bin/ksh -c "Test FAQ User" -m -g guest testuser</strong>
</pre></blockquote>

<p>
<b>Remarque :</b> Assurez vous d'utiliser " pour englober le mot de
   passe. L'utilisation de "" ne permet pas d'empêcher le shell
   d'interpréter le jeu de caractères correspondant au mot de passe
   avant de les communiquer à user(8). De même, assurez vous d'utiliser
   l'option <b>-m </b>si vous voulez créer le répertoire $HOME de
   l'utilisateur et copier les fichiers à partir de <i>/etc/skel</i>
   vers $HOME.

<p>
Pour voir si le compte utilisateur a été correctement crée, nous pouvons
recourir à plusieurs utilitaires. Voici quelques commandes pour vérifier
rapidement que tout s'est bien passé :

<blockquote><pre>
$ <strong>ls -la /home</strong>
total 14
drwxr-xr-x   5 root      wheel   512 May 12 14:29 .
drwxr-xr-x  15 root      wheel   512 Apr 25 20:52 ..
drwxr-xr-x  24 ericj     wheel  2560 May 12 13:38 ericj
drwxr-xr-x   2 testuser  guest   512 May 12 14:28 testuser
$ <strong>id testuser</strong>
uid=1002(testuser) gid=31(guest) groups=31(guest)
$ <strong>finger testuser</strong>
Login: testuser                         Name: Test FAQ User
Directory: /home/testuser               Shell: /bin/ksh
Last login Sat Apr 22 16:05 (EDT) on ttyC2
No Mail.
No Plan.
</pre></blockquote>

<p>
En plus de ces commandes, user(8) fournit son propre utilitaire, appelé
userinfo(8), qui permet d'afficher les caractéristiques d'un compte
utilisateur :

<blockquote><pre>
$ <strong>userinfo testuser</strong>
login   testuser
passwd  *
uid     1002
groups  guest
change  Wed Dec 31 19:00:00 1969
class
gecos   Test FAQ User
dir     /home/testuser
shell   /bin/ksh
expire  Wed Dec 31 19:00:00 1969
</pre></blockquote>

<h4>Suppression des comptes utilisateurs</h4>

<p>
Pour supprimer des comptes utilisateurs avec la hiérarchie de commandes
user(8), vous devez utiliser userdel(8). Cette commande est simple et
efficace. Pour supprimer le compte précédemment crée, utilisez :

<blockquote><pre>
# <strong>userdel -r testuser</strong>
</pre>
</blockquote>

<p>
Notez bien l'option <b>-r</b> qui doit être spécifiée si vous voulez
supprimer les répertoires $HOME aussi. Si vous voulez juste bloquer
l'accès au compte sans supprimer des informations liées au compte,
utilisez <b>-p</b> au lieu de <b>-r</b>.

<p>
<a name= "FTPOnly"></a>
<h2>10.10 - Comment puis-je créer un compte pour ftp uniquement
    ?</h2>

<p>
Il y a plusieurs méthodes pour effectuer cette opération.
Une des manières les plus communes est d'ajouter
<tt>/usr/bin/false</tt>" à "<tt>/etc/shells</tt>".
A partir de là, lorsque vous affectez "<tt>/usr/bin/false</tt>" à un
utilisateur, il ne sera plus capable d'ouvrir une session interactive
sur le système néamoins il pourra utiliser le service ftp.
Vous souhaiterez peut-être aussi restreindre l'accès en
<a href="#ftpchroot">Confiner les utilisateurs à leur répertoire HOME avec ftpd(8)</a>.

<p>
<a name= "Quotas"></a>
<h2>10.11 - Mise en place des quotas</h2>

<p>
Les quotas sont utilisés pour limiter l'espace disque disponible pour
les utilisateurs. Ce système peut être très utile si vous avez des
ressources limitées. Les quotas peuvent être configurés par utilisateur
et/ou par groupe.


<p>
La première étape pour configurer les quotas est de s'assurer que
<tt>option QUOTA</tt> est présente dans votre
<a href="faq5.html#Options">configuration noyau</a>. Cette option est
incluse dans le noyau GENERIC. Ensuite, vous aurez besoin de marquer les
systèmes de fichiers où les quotas sont utilisés dans le fichier

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"><tt>/etc/fstab</tt></a>. 
Les mots clés <tt>userquota</tt> et <tt>groupquota</tt> doivent être
utilisés pour marquer chaque système de fichiers où les quotas sont
activés. Par défaut, les fichiers <tt>quota.user</tt> et
<tt>quota.group</tt> seront crées à la racine des systèmes de fichiers
où les quotas sont utilisés pour stocker les informations relatives à
ces derniers. Si vous voulez les créer ailleurs, spécifiez un fichier
avec l'option des quotas dans <tt>/etc/fstab</tt>, par exemple
"<tt>userquota=/var/quotas/quota.user</tt>". Voici un exemple de
<tt>/etc/fstab</tt> avec un système de fichiers avec quotas activés et
le fichier de quotas se trouvant dans un endroit non-standard :

<blockquote><pre>
/dev/wd0a / ffs rw,userquota=/var/quotas/quota.user 1 1
</pre></blockquote>

<p>
Maintenant, il faut configurer les quotas par utilisateur. A cette fin,
nous utilisons la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=edquota&amp;sektion=8">edquota(8)</a>. 
Une utilisation simple est <strong>edquota&nbsp;&lt;user&gt;</strong>.
edquota(8) va utiliser vi(1) pour éditer les quotas à moins que la
variable d'environnement EDITOR est positionnée pour charger un autre
éditeur. Par exemple la commande :

<blockquote><pre>
# <strong>edquota ericj</strong>
</pre></blockquote>

<p>
Affichera un résultat similaire à :

<blockquote><pre>
Quotas for user ericj:
/: blocks in use: 62, limits (soft = 0, hard = 0)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Pour ajouter des limites, éditer là pour donner un résultat similaire à
:

<blockquote><pre>
Quotas for user ericj:
/: blocks in use: 62, limits (soft = 1000, hard = 1050)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Notez que l'allocation de quotas est en blocs de 1k. Dans ce cas-ci,
softlimit est fixé à 1000k et hardlimit à 1050k. softlimit est une
limite qui permet au système de prévenir les utilisateurs quand ils
l'ont dépassé. Ils auront alors jusqu'à la fin de leur période de grâce
pour redescendre en dessous de cette limite. Les périodes de grâce
peuvent être configurées à l'aide de l'option <b>-t </b> de edquota(8).
Après la fin de la période de grâce, softlimit est géré comme hardlimit.
Ce qui cause un échec d'allocation.

<p>
Une fois les quotas configurés, il faut les activer. Pour cela, utilisez
la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quotaon&amp;sektion=8">quotaon(8)</a>. 
Par exemple :

<blockquote><pre>
# <strong>quotaon -a</strong>
</pre></blockquote>

<p>
Cette commande analysera le contenu de <tt>/etc/fstab</tt> et activera
les quotas sur les systèmes de fichiers où les options de quota sont
positionnées. Maintenant que les quotas sont activés, vous pouvez les
visualiser à l'aide de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quota&amp;sektion=1">quota(1)</a>. 
Ainsi, la commande <strong>quota &lt;user&gt;</strong> fournit les
informations concernant cet utilisateur. Si aucun argument n'est
utilisé, quota vous fournira des statistiques sur les quotas. Par
exemple :

<blockquote><pre>
# <Strong>quota ericj</strong>
</pre></blockquote>

<p>
Afficherait :

<blockquote><pre>
Disk quotas for user ericj (uid 1001): 
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
              /      62    1000    1050              27       0       0        
</pre></blockquote>

<p>
Par défaut, les quotas positionnés dans <tt>/etc/fstab</tt> seront
activés au démarrage. Pour les désactiver, utilisez :

<blockquote><pre>
# <strong>quotaoff -a</strong>
</pre></blockquote>

<p>
<a name= "Kerberos"></a>
<h2>10.12 - Mise en place de Clients et Serveurs KerberosV</h2>

<p>
OpenBSD inclut KerberosV comme un composant pré-installé sur le système
par défaut.

<p>
Pour plus d'information concernant KerberosV, sur votre système OpenBSD,
utilisez la commande :

<pre>
  # <b>info heimdal</b>
</pre>

<p>
<a name= "AnonFTP"></a>
<h2>10.13 - Mise en place d'un serveur FTP Anonyme</h2>

<p>
Le mode FTP anonyme permet à des utilisateurs sans compte d'accéder aux
fichiers sur votre machine en utilisant le protocole de transfert de
fichiers. Ce chapitre a pour but de fournir une vue d'ensemble de la
configuration d'un serveur FTP anonyme, les logs générés, ...etc.

<h3>Création du compte FTP</h3>

<p>
La première étape consiste à créer un compte "ftp" sur votre système. Ce
compte ne doit pas avoir de mot de passe utilisable. Dans cet exemple,
nous allons considérer que /home/ftp est le répertoire correspondant au
compte "ftp" mais vous n'êtes pas obligé de choisir la même chose. Quand
le mode anonyme est utilisé, le démon ftp va se confiner au répertoire
HOME de l'utilisateur 'ftp' (dans notre cas, ce répertoire est
/home/ftp). Pour en savoir plus, lisez les pages du manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftp(8)</a> 
et 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>. 
Voici un exemple de création du compte <i>ftp</i> en utilisant la
commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>. 
Au préalable, nous avons besoin d'ajouter /usr/bin/false au fichier
<i>/etc/shells</i>. C'est le shell que nous allons attribuer à
l'utilisateur ftp. Il ne permettra pas de connexion en login à ce compte
même si nous configurons un mot de passe vide. Pour effectuer cette
opération, il suffit de faire <i>echo /usr/bin/false &gt;&gt;
/etc/shells</i>. Si en plus vous souhaitez que ce shell apparaisse dans
la liste des choix proposés par adduser, vous devez modifier le fichier
<i>/etc/adduser.conf</i>.

<blockquote><pre>
# <strong>adduser</strong>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Reading /etc/login.conf
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>ftp</b>
Enter full name []: <b>anonymous ftp</b>
Enter shell csh false ksh nologin sh tcsh zsh [sh]: <b>false</b>
Uid [1002]: <b><i>Enter</i></b>
Login group ftp [ftp]: <b><i>Enter</i></b>
Login group is ``ftp''. Invite ftp into other groups: guest no 
[no]: <b>no</b>
Login class auth-defaults auth-ftp-defaults daemon default staff 
[default]: <b><i>Enter</i></b>
Enter password []: <b><i>Enter</i></b>
Set the password so that user cannot logon? (y/n) [n]: <b>y</b>

Name:        ftp
Password:    ****
Fullname:    anonymous ftp
Uid:         1002
Gid:         1002 (ftp)
Groups:      ftp
Login Class: default
HOME:        /home/ftp
Shell:       /usr/bin/false
OK? (y/n) [y]: <b>y</b>
Added user ``ftp''
Copy files from /etc/skel to /home/ftp
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<h3>Configuration du répertoire</h3>

<p>
L'opération a crée, en plus de l'utilisateur, le répertoire
<i>/home/ftp</i>. C'est ce que nous voulons mais nous avons besoin
d'effectuer quelques modifications pour préparer le système à héberger
le service FTP anonyme. Ces modifications sont expliquées dans la page
du manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftp(8)</a>. 

<p>
<b>Vous n'avez pas besoin</b> de créer un répertoire /home/ftp/usr ou
/home/ftp/bin.

<ul>
<li><i>/home/ftp</i> - C'est le répertoire principal. Il doit être
    possédé par root avec les permissions 555.
<li><i>/home/ftp/etc</i> - Ce répertoire est optionnel et non
    recommandé. Son seul but est de fournir des informations sur les
    comptes utilisateurs existant. Si vous voulez que les fichiers de
    votre répertoire de ftp soient associés à de vrais utilisateurs,
    vous devez copier /etc/pwd.db et /etc/group dans ce répertoire. Les
    permissions du répertoire doivent être 511. Les permissions sur les
    deux fichiers doivent être 444. Ils sont utilisés pour fournir une
    correspondance entre des nombres et les noms attribués aux comptes
    utilisateurs et groupes. Il n'y a pas de mots de passe dans pwd.db.
    Tous les mots de passe sont stockés dans spwd.db alors ne copiez pas
    ce fichier.
<li><i>/home/ftp/pub</i> - C'est le répertoire standard pour mettre les
    fichiers que vous voulez partagez. Ce répertoire doit avoir les
    permissions 555.
</ul>

<p>
Il est à noter que tous ces répertoires doivent être la propriété de
"root". Voici à quoi doivent ressembler les répertoires après leur
création :

<blockquote><pre>
# pwd 
/home
# ls -laR ftp
total 5
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 .
drwxr-xr-x  7 root  wheel  512 Jul  6 10:58 ..
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 etc
dr-xr-xr-x  2 root  ftp    512 Jul  6 11:33 pub

ftp/etc:
total 43
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 .
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 ..
-r--r--r--  1 root  ftp    316 Jul  6 11:34 group
-r--r--r--  1 root  ftp  40960 Jul  6 11:34 pwd.db

ftp/pub:
total 2
dr-xr-xr-x  2 root  ftp  512 Jul  6 11:33 .
dr-xr-xr-x  5 root  ftp  512 Jul  6 11:33 ..
</pre></blockquote>

<h3>Démarrage du serveur et logs</h3>

<p>
Vous pouvez choisir d'exécuter ftpd soit à partir de inetd soit
directement de le lancer directement via les scripts rc. L'exemple
ci-après représente le cas où le service est démarré à partir de
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/inetd.conf">inetd.conf</a>. 
Tout d'abord, nous devons nous familiariser avec quelques options de
ftpd. La ligne par défaut dans <i>/etc/inetd.conf</i> est :

<blockquote><pre>
<strong>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -US</strong>
</pre></blockquote>

<p>
Comme vous pouvez le voir, ftpd est invoqué avec <i>-US</i>. Ces options
vont permettre de loguer les connexions anonymes dans
<i>/var/log/ftpd </i>et les sessions courantes dans
<i>/var/run/utmp</i>. Ce qui permet de voir ces sessions via who(1).
Dans certains cas, on souhaitera fournir un accès anonyme et désactiver
ftp pour les utilisateurs du système. Pour cela, il faut utiliser
l'option <i>-A </i>de ftpd. Voici une ligne d'invocation de ftpd en mode
anonyme exclusif. On utilise aussi <i>-ll</i> qui logue chaque connexion
vers syslog en plus des commandes ftp get, retrieve, etc.

<blockquote><pre> 
<strong>
ftp stream tcp nowait root /usr/libexec/tcpd ftpd -llUSA
</strong> 
</pre></blockquote>

<p> 
Remarque - Les personnes gérant des serveurs ftp à HAUT trafic ne
devraient pas invoquer ftpd à partir de inetd.conf. La meilleure option
consiste à commenter la ligne correspondant à ftpd dans /etc/inetd.conf
et à démarrer ftpd à partir de rc.conf avec l'option <i>-D</i>. Ce qui
va démarrer ftpd en tant que démon. Ce mode de fonctionnement est
beaucoup moins coûteux et plus rapide que le démarrage via inetd. La
ligne correspondant à ftpd dans rc.conf ressemblerait à :

<blockquote><pre>
ftpd_flags="-DllUSA"           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Bien évidemment, cette méthode ne fonctionnera que si ftpd est commenté
dans <i>/etc/inetd.conf</i> et en veillant qu'inetd ait bien relu sont
fichier de configuration.

<h3>Autres fichiers importants </h3>

<ul>
<li><i>/etc/ftpwelcome</i> - Ce fichier contient le message de bienvenue
    qui sera affiché aux personnes qui se connectent sur votre serveur
    ftp.
<li><i>/etc/motd</i> - Ce fichier contient le message qui sera affiché
    aux utilisateurs une fois authentifiés sur votre serveur ftp.
<li><i>.message</i> - Ce fichier peut être mis dans n'importe quel
    répertoire. Il contient un message qui sera affiché lorsque
    l'utilisateur entre dans le répertoire où ce fichier se trouve.
</ul>

<p>
<a name= "ftpchroot"></a>
<h2>10.13 - Confiner les utilisateurs à leur répertoire
    HOME avec ftpd(8)</h2>

<p>
Par défaut, lorsque les utilisateurs se connectent en ftp, ils peuvent
aller dans n'importe quel répertoire du système, dans la mesure où les
contrôles d'accès leur permettent.
Dans certains cas, ce comportement peut ne pas être souhaitable.
Il est possible de retreindre les utilisateurs ftp à leur répertoire
HOME en utilisant "chroot".

<p>
Si vous voulez autoriser les connexions ftp en chroot, utilisez l'option
<b>-A</b> de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>.

<p>
Si vous voulez utiliser chroot de manière plus fine, consultez
"<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=login.conf&amp;sektion=5">login capability infrastructure</a>" et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>
<p>

Les utilisateurs appartenant à une classe de connexion où la variable
<tt>ftp-chroot</tt> est positionnée seront automatiquement mis dans un
chroot.
De plus, vous pouvez ajouter un nom d'utilisateur au fichier
<b>/etc/ftpchroot</b> pour mettre ces utilisateurs dans un chroot.
Un utilisateur a uniquement besoin d'être listé dans un de ces endroits.

<p>
<a name= "Patches"></a>
<h2>10.15 - Appliquer des correctifs sous OpenBSD</h2>

<p>
Le code source de OpenBSD est en constante évolution et amélioration. En
même temps, des correctifs aux problèmes les plus communs sont crées et
diffusés au public. Ces correctifs apparaissent sur la
<a href="../../fr/errata.html">page web des errata</a>. Ils sont séparés
en catégories. Ces catégories correspondent à des correctifs qui
concernent différentes architectures ou à des correctifs indépendants de
l'architecture.

<p>
Cependant, il est à noter qu'il n'y a pas de correctifs pour les
nouvelles fonctionnalités ajoutées à OpenBSD. Les correctifs corrigent
uniquement des problémes de stabilité ou de sécurité qui doivent être
réglés très rapidement, bien que le choix final revienne à
l'administrateur.

<p> 
Comme exemple, nous allons appliquer un correctif de sécurité obtenu à
partir de la
<a href="../../fr/errata.html">page web des errata</a> à
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=talkd&amp;sektion=8">talkd(8)</a>.

<h3>Quelle est la différence entre ces correctifs et ce qui se trouve
    dans l'arborescence CVS ? </h3>

<p>
Tous les correctifs postés sur la <a href="../../fr/errata.html">page
web des errata</a> concernent uniquement l'arborescence des sources de
la dernière version diffusée. Les autres correctifs qui concernent
l'arborescence actuelle de CVS peuvent contenir certaines modifications
qui ne sont peut-être pas désirables sur la version de production.

<h3>Préparer le système pour l'application des
    correctifs</h3>

<p>
Les correctifs d'OpenBSD sont distribués sous la forme de fichiers diff.
Ces fichiers sont des fichiers texte qui contiennent les différences par
rapport au code source d'origine. Ils ne sont <b>PAS</b> distribués sous
forme binaire. Cela veut dire que pour appliquer les correctifs, vous
devez avoir à disposition sur votre système le code source de la version
<b>RELEASE </b>d'OpenBSD. Cela ne veut pas dire que vous avez besoin de
tout le code source du système d'exploitation OpenBSD pour appliquer les
correctifs à votre système. Mais vous devez avoir le code source
correspondant au composant à corriger. Par exemple, si vous corrigez le
noyau vous devez avoir tout le code source au noyau.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cvs&amp;sektion=1">cvs(1)</a> 
est un outil très pratique pour télécharger uniquement les sources dont
vous avez besoin en utilisant des serveurs cvs anonymes situés un peu
partout dans le monde. Vous pouvez avoir une liste des serveurs
disponibles dans la
<a href="../../fr/anoncvs.html">page CVS Anonyme</a>.

<p>
Pour télécharger le code source de talkd(8) correspondant
à la version <i>3.6-release</i> via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cvs&amp;sektion=1">cvs(1)</a>, 
vous utiliseriez les lignes de commande suivantes :

<div style="margin-left: 2em">
<pre>
$ <b>export CVSROOT=anoncvs@anoncvs5.usa.openbsd.org:/cvs</b>
$ <b>cvs co -rOPENBSD_3_6_BASE src/libexec/talkd/</b>
cvs server: Updating src/libexec/talkd
U src/libexec/talkd/announce.c
U src/libexec/talkd/talkd.c
U src/libexec/talkd/talkd.h
</pre>
</div>

<p>
Pour connaître le chemin CVS du code dont vous avez besoin,
reportez-vous à la ligne <i>Index:</i>. Dans notre cas, le chemin CVS
est <i>src/libexec/talkd/</i>. Il faut toujours vérifier la révision de
OPENBSD_version_number_BASE. Sans "_BASE", vous obtiendrez le code
correspondant à la branche stable qui contient probablement d'autres
modifications qui peuvent interférer avec la procédure d'application des
correctifs. Si vous synchroniser vos sources par rapport à la branche
stable, les correctifs sont normalement déjà inclus dans le code source.
Cependant, nous vous conseillons de toujours effectuer une vérification.
Vous pouvez voir dans la page consacrée aux

<a href="../../plus.html">changements dans OpenBSD-current</a> les
correctifs qui ont été appliqués à la branche stable. Si les correctifs
n'ont pas encore été appliqués, vous devez télécharger les sources de la
dernière RELEASE en utilisant les commandes précédentes.

<p>
Pour les utilisateurs ayant acheté des CDs OpenBSD officiels, vous
pouvez obtenir le code source directement à partir du CD. Reportez vous
à l'encart livré avec votre CD. Vous n'aurez à ce moment-là besoin
d'obtenir les sources via anoncvs.

<blockquote><pre>
Apply by doing:
        cd /usr/src
        patch -p0 &lt; 026_talkd.patch
        cd libexec/talkd
        make obj &amp;&amp; make depend &amp;&amp; make &amp;&amp; make install

Index: libexec/talkd/announce.c <b>&lt;------ Chemin CVS</b>
===================================================================
RCS file: /cvs/src/libexec/talkd/announce.c,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -r1.8 -r1.9
--- libexec/talkd/announce.c    1998/08/18 03:42:10     1.8
+++ libexec/talkd/announce.c    2000/07/06 00:01:45     1.9
@@ -160,6 +160,6 @@
                *(bptr++) = '\n';
        }
        *bptr = '\0';
-       fprintf(tf, big_buf);
+       fprintf(tf, "%s", big_buf);
        fflush(tf);
 }
</pre>
</blockquote>

<p>
Une fois que vous avez obtenu les sources, vous pouvez télécharger le
correctif que vous mettrez sous <i>src/</i>

<h3>Application des correctifs</h3>

<p>
<div style="margin-left: 2em">
<pre>
$ <b>cd /usr/src</b>
$ <b>patch -p0&lt;/path/to/026_talkd.patch</b>
Hmm...  Looks like a unified diff to me...
The text leading up to this was:
--------------------------
|Apply by doing:
|       cd /usr/src
|       patch -p0 &lt; 026_talkd.patch
|       cd libexec/talkd
|       make obj &amp;&amp; make depend &amp;&amp; make &amp;&amp; make install
|
|Index: libexec/talkd/announce.c
|===================================================================
|RCS file: /cvs/src/libexec/talkd/announce.c,v
|retrieving revision 1.8
|retrieving revision 1.9
|diff -u -r1.8 -r1.9
|--- libexec/talkd/announce.c   1998/08/18 03:42:10     1.8
|+++ libexec/talkd/announce.c   2000/07/06 00:01:45     1.9
--------------------------
Patching file libexec/talkd/announce.c using Plan A...
Hunk #1 succeeded at 160. <b>&lt;------------ Patch Succeeded</b>
done
$ <b>cd /usr/src/libexec/talkd/</b>
$ <b>ls</b>
CVS             announce.c      print.c         table.c         talkd.c
Makefile        announce.c.orig process.c       talkd.8         talkd.h
$ <b>make obj &amp;&amp; make depend &amp;&amp; make</b>
making /home/ericj/lsrc/src/libexec/talkd/obj
mkdep -a /home/ericj/lsrc/src/libexec/talkd/talkd.c /home/ericj/lsrc/sr
c/libexec/talkd/announce.c /home/ericj/lsrc/src/libexec/talkd/process.c
/home/ericj/lsrc/src/libexec/talkd/table.c /home/ericj/lsrc/src/libexec
/talkd/print.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/talkd.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/announce.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/process.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/table.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/print.c
cc   -o ntalkd talkd.o announce.o process.o table.o print.o
nroff -Tascii -mandoc /home/ericj/lsrc/src/libexec/talkd/talkd.8 &gt; talk
d.cat8
$ <b>sudo make install</b>
install -c -s -o root -g bin  -m 555 ntalkd /usr/libexec
install -c -o root -g bin -m 444 talkd.cat8 /usr/share/man/cat8/talkd.0
/usr/share/man/cat8/ntalkd.0 -&gt; /usr/share/man/cat8/talkd.0
</pre>
</div>

<p>
Une fois cette opération effectuée, redémarrez le
service.


<a name="httpdchroot"></a>
<h2>10.16 - Parlez moi de chroot() Apache ?</h2>

Sous OpenBSD, le serveur 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
d'Apache est 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>é
par défaut. Etant un grand pas en avant du point de vue de la sécurité,
cela peut créer des problè si vous n'y êtes pas préparé.

<h3>Qu'est-ce qu'un chroot ?</h3>

Une application 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>ée
est bloquée dans un répertoire spécifique et ne peut errer dans les
autres répertoires de l'arbre du système de fichiers et voit ce
répertoire comme sont répertoire <tt>/</tt> (root). Dans le cas
d'httpd(8), le programme démarre, ouvre ses fichiers log, ouvre ses
ports TCP (bien qu'il n'accepte pas encore de données), et lis sont
fichier de configuration. Ensuite, il se fixe lui-même dans le
répertoire <i>/var/www</i> et baisse ses privilèges. Ce qui veut dire
que tous les fichiers servis et utilisés par Apache, doivent être dans
le répertoire <i>/var/www</i>. Cela aide considérablement la sécurité --
si il devait y avoir un problème de sécurité, les dégats seraient
confinés dans un seul répertoire avec les permissions de "lecture seule"
et aucune ressource pour causer des problèmes.

<h3>Qu'est-ce que cela signifie pour l'utilisateur ?</h3>
En gros, chroot(2)er Apache est quelque chose de nouveau. Ce mode de
configuration n'est pas adopté par la plupart des autres systèmes
d'exploitation. beaucoup d'applications et de configurations système ne
fonctionneront plus comme avant.

<ul>
<li><b>Hiérarchie historique du système de fichiers :</b>
Les serveurs mis à jour depuis d'anciennes versions d'OpenBSD peuvent
avoir les fichiers web situés dans les répertoires HOME des
utilisateurs, ce qui clairement ne fonctionnera pas dans un
environnement chroot(2)é étant donné qu'httpd(8) ne peut atteindre le
répertoire <i>/home</i>. Les administrateurs découvriront peut-être que
leur partition /var/www existente est trop petite pour accueillir tous
les fichiers web. Vos options sont dès lors de restructurer votre
système ou de ne pas utiliser l'option du chroot(2). Vous pouvez, bien
evidemment, utiliser des liens symboliques dans le répertoire HOME de
l'utilisateur pointant vers les sous-répertoires dans
<i>/var/www</i>, mais vous ne pouvez PAS utiliser des liens dans
<i>/var/www</i> pointant vers une autre partie du système de
fichier -- ceci ne peut fonctionner dû au chroot(2). Notez que si
vous voulez que vos utilisateurs aient un
<a href="faq10.html#ftpchroot">accès FTP chroot(2)é</a>,
ceci ne fonctionnera pas plus étant donné que le chroot FTP va (à
nouveau) vous empêcher d'accéder aux destinations de ces liens
symboliques. Une solution est donc, de ne pas utiliser <i>/home</i>
comme répertoire HOME pour ces utilisateurs mais plutot quelque chose
similaire à <i>/var/www/home</i>.


<li><b>Rotation des fichiers log :</b> Normalement, une rotation des
    fichiers log est réalisée en renommant les anciens fichiers, ensuite
    en envoyant à httpd(8) un signal SIGUSR1 qui forcera Apache à fermer
    ses anciens fichiers logs et à en ouvrir de nouveaux. Ceci n'est
    désormais plus possible, étant donné qu'httpd(8) n'a plus la
    possibilité d'ouvrir ses propres fichiers log une fois que ses
    privilèges ont baissés. httpd(8) doit donc être stoppé et relancé :

<pre>
   # <b>apachectl stop && apachectl start</b>
</pre> 

Il existe néanmoins d'autres techniques, notamment logguer vers un
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pipe&amp;sektion=2">pipe(2)</a>, 
et utiliser un programme extérieur afin de réaliser une rotation des
fichiers à la fin du pipe.

<li><b>Modules Apache existants :</b> Pratiquement, ils se lanceront
    tous, cependant, certains pourraient ne pas fonctionner correctement
    dans le chroot(2), et pourraient causer des problèmes lors de
"<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=apachectl&amp;sektion=8">apachectl</a> 
    restart"</tt>, générant une erreur, causant httpd(8) à se stopper.

<li><b>CGIs existants :</b> La plupart ne fonctionneront pas tels quels.
    Ils auront certainement besoin de programmes ou de librairies se
    trouvant hors de <i>/var/www</i>. Certains peuvent être corrigés en
    étant compilés statiquement (n'ayant pas besoin de librairies se
    trouvant dans un autre répertoire), la plupart peuvent être corrigés
    en copiant dans <i>/var/www</i> les fichiers nécessaires à
    l'application, bien que cette manoeuvre soit non triviale et
    requiert certaines notions de programmation -- la plupart des
    utilisateurs trouveront plus facile de ne pas employer le chroot(2)
    en attendant une mise à jour de ces CGIs.
</ul>

Dans certains cas, les applications ou les configurations peuvent être
changées pour fonctionner dans le chroot. Dans d'autres cas, vous devrez
tout simplement retirer cette option en utilisant l'option <tt>-u</tt>
de httpd(8) dans<i>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf</a></i>.

<h3>Exemple de chroot(2) d'une application : wwwcount</h3>

Voyons comment mettre en place chroot(2) pour une application à travers
un exemple. Cet exemple se base sur wwwcount, un compteur tout simple
d'accès aux pages web disponible dans l'arborescence des
<a href="faq8.html#Ports">ports</a>. Bien qu'il soit un programme
très efficace, wwwcount ne sait rien d'Apache chroot(2)é et ne
fonctionnera pas dans un environnement chroot(2)é avec sa configuration
de base.

<p>
Tout d'abord, nous installons un
<a href="faq8.html#Packages">package</a> pour
<a href="http://www.muquit.com/muquit/software/Count/Count.html">wwwcount</a>.
Nous le configurons et le testons et c'est là que nous en déduisons
qu'il ne semble pas fonctionner : Apache nous affiche le message
"Internal Server Error".

La première étape consiste à arrêter Apache et à le redémarrer avec
l'option <tt>-u</tt> pour vérifier que le problème vient bien du
chroot(2) et pas de la configuration système.
<pre>
    # <b>apachectl stop</b>
    /usr/sbin/apachectl stop: httpd stopped
    # <b>httpd -u</b>
</pre>

Après avoir fait cela, nous constatons que le compteur fonctionne
correctement, du moins après avoir changé les droits d'un répertoire
afin qu'Apache (et les CGIs qu'il exécute) puisse écrire à des fichiers.
Ainsi, nous sommes maintenant certains que le problème vient du chroot.
Nous arrêtons alors et redémarrons Apache à nouveau en utilisant le
chroot par défaut :

<pre>
    # <b>apachectl stop</b>
    /usr/sbin/apachectl stop: httpd stopped
    # <b>httpd</b>
</pre>

<p>
Un bon point pour commencer serait de supposer que wwwcount utilise des
librairies et d'autres fichiers qu'il ne peut accéder une fois dans le
chroot. On peut utiliser à cet effet la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldd&amp;sektion=1">ldd(1)</a>
pour trouver les dépendances dynamiques dont le CGI a besoin :
<pre>
# cd /var/www/cgi-bin/
# ldd Count.cgi
Count.cgi:
        Start    End      Type Ref Name
        00000000 00000000 exe   1  Count.cgi
        03791000 237ca000 rlib  1  /usr/lib/libc.so.30.3
        03db4000 03db4000 rtld  1  /usr/libexec/ld.so
</pre>
Ah ! voilà un problème. Deux fichiers ne sont pas disponibles dans
l'environnement chroot(2). Alors, on les copie dans cet environnement :

<pre>
    # mkdir -p /var/www/usr/lib /var/www/usr/libexec
    # cp /usr/lib/libc.so.30.3 /var/www/usr/lib
    # cp /usr/libexec/ld.so /var/www/usr/libexec
</pre>
Puis nous essayons le compteur à nouveau.

<p>
Au moins, le programme s'exécute maintenant et nous affiche des messages
d'erreur directement : "Unable to open config file for reading". Nous
avons bien progressé mais nous n'avons pas encore fini. Le fichier de
configuration se trouve normalement dans le répertoire
<tt>/var/www/wwwcount/conf</tt>, mais au sein de l'environnement chroot,
le programme devrait le voir sous <tt>/wwwcount/conf</tt>.
Nous avons donc deux options. Soit nous recompilons le programme pour
qu'il tienne compte du nouveau fichier de configuration par défaut (où
plutôt du chemin pour l'atteindre) soit nous déplaçons les fichiers de
données. Vu que nous avons installé le programme à partir d'un package,
nous prenons l'option 2, à savoir le déplacement des fichiers de
données. Afin que nous puissons utiliser exactement la même
configuration dans un environnement chroot(2)é ou pas, nous utiliserons
un lien symbolique :

<pre>
    # mkdir -p /var/www/var/www          
    # cd /var/www/var/www
    # ln -s ../../wwwcount wwwcount
</pre>
Remarquez que le lien symbolique a été pensé pour fonctionner au sein du
chroot. Nous testons notre programme à nouveau et nous voilà avec un
autre problème.
Maintenant wwwcount se plaint de ne pas trouver les fichiers "strip
image" qu'il utilise pour afficher des messages. Après quelques
recherches, nous nous rendons compte que ces fichiers sont stockés dans
<tt>/usr/local/lib/wwwcount</tt>, nous devons donc les copier dans le
chroot aussi.
<pre>
    # tar cf - /usr/local/lib/wwwcount | (cd /var/www; tar xpf - )
</pre>
Nous testons à nouveau ... et ça marche !

<p>
Dans cet exemple, le programme était simple et malgré ça, nous avons
constaté plusieurs problèmes. Certaines applications sont relativement
simples et les mettre dans un chroot(2) n'a aucun sens. D'autres sont
très complexes. Elles ne valent pas les efforts nécessaires pour les
mettre en chroot(2) et même si c'était le cas, vous perdriez tous les
avantages du chroot(2) après avoir copié la masse importante de fichiers
dont elles ont besoin pour fonctionner. Même avec une application aussi
simple que celle que nous avons utilisé pour cet exemple, l'accès au
disque est nécessaire (pour mettre à jour les compteurs). Du coup,
certains avantages de chroot(2) ont été perdus. De manière générale, le
minimum de fichiers nécessaires pour faire fonctionner une application
devraient être copiés dans le chroot.
<i>On ne peut ou on ne doit pas chroot(2)er n'importe quelle
   application</i>

<a name="rootshell"></a>
<h2>10.17 - Je n'aime pas le shell root standard !</h2>
Le shell par défaut sur OpenBSD de l'utilisateur <i>root</i> est
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>,
dû principalement à la tradition. Il n'est pas spécialement requis
qu'OpenBSD ait csh(1) comme shell pour l'utilisateur root (lisez
néanmoins avant de le changer).

<p>
Certains utilisateurs venant d'un système d'exploitation "Unix-like"
trouvent csh(1) peu familier et demande dès lors si ils peuvent le
changer et comment. Il y a plusieurs options :

<ul>
<li><b>Ne vous authentifiez pas directement en tant que <i>root</i></b>
    Entre
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su</a> 
    et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo</a>, 
    il ne devrait y avoir que peu de raisons pour que les utilisateurs
    s'authentifient en tant que <i>root</i> pour la plupart des
    applications après l'installation initiale.
<li><b>Invoquez votre shell favori après le login :</b> Si vous aimez
    ksh(1) ou n'importe quel autre shell, invoquez le simplement depuis
    votre shell par défaut.
<li><b>Changez le shell de l'utilisateur root :</b> Ceci peut être fait
    en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chsh&amp;sektion=1">chsh</a>
    ou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw</a>.
</ul>

Une directive Unix traditionelle est d'utiliser pour l'utilisateur root
des shells compilés statiquement, car si votre système démarre en mode
utilisateur unique, les partitions non-root ne seront pas montées et les
shells liés dynamiquement ne seront pas capable d'accéder aux librairies
situées dans la partition <tt>/usr</tt>. Ceci n'étant pas très important
pour OpenBSD, car le système vous demandera de choisir un shell lors
d'un démarrage en mode utilisateur unique, le shell par défaut étant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>.

Les trois shells standards sous OpenBSD 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>)
sont liés statiquement et donc utilisables en mode utilisateur unique.

<p>
Il est parfois dit qu'il ne faut pas changer le shell de l'utilisateur
root, bien qu'il n'y ait aucune raison de ne pas le faire sous OpenBSD.
Mais encore une fois, ceci ne devrait pas être une raison -- ne vous
authentifiez pas directement en tant que root.

<a name="ksh"></a>
<h2>10.18 - Que puis-je faire d'autre avec <i>ksh</i> ?</h2>
Sous OpenBSD,  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
est 
<a href="http://web.cs.mun.ca/~michael/pdksh/">pdksh</a>, 
le Shell Korn du Domaine Public (Public Domain Korn Shell), et est le
même binaire que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>.

<p>
Les utilisateurs qui sont à l'aise avec <i>bash</i>, souvent utilisé sur
les systèmes Linux, trouveront probablement
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
très familier. Ksh(1) offre la plupart des options habituellement
utilisées avec <i>bash</i>, notamment l'achèvement des commandes avec la
touche tab, l'édition de la ligne de commande et l'historique via les
touches flèchées, et CTRL-A/CTRL-E pour aller au début/à la fin de la
ligne de commande. Si vous désirez d'autres options de <i>bash</i>,
<i>bash</i> peut être installé soit via les
<a href="faq8.html#Ports">ports</a> ou soit via les
<a href="faq8.html#Packages">packages</a>.

<p>
Le prompt de <i>ksh</i> peut être facilement changé de manière à fournir
plus d'informations que le simple "$ " par défaut en modifiant la
variable <tt>PS1</tt>. Par exemple, en insérant la ligne suivante :

<pre>
   export PS1='$PWD $ '
</pre>
 
dans votre <tt>/etc/profile</tt>, cela produira le prompt suivant :

<pre>
   /home/nick $
</pre>

Consultez le fichier 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/ksh.kshrc?content-type=text/plain"><tt>/etc/ksh.kshrc</tt></a>,
qui inclut plusieurs options utiles ainsi que des exemples, et qui peut
être invoqué dans les fichiers <tt>.profile</tt> de vos utilisateurs.

<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a> 
<a href= "faq9.html">[Section 9 - Migrer vers OpenBSD]</a>
<a href= "faq11.html">[Section 11 - Optimisation des Performances]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a> <br>
<small>
<!--
Originally [OpenBSD: faq10.html,v 1.109 ]<br>
$Translation: faq10.html,v 1.33 2005/01/17 21:31:58 aanriot Exp $<br>
-->
$OpenBSD: faq10.html,v 1.28 2005/01/18 09:54:29 jufi Exp $
</small>
</body>
</html>
