<html>
<head>
<title>14.0 - Disk Setup</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998,1999 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<h2><font color=#e00000>14.0 - Disk Setup</font><hr></h2>
</p>

<p>
<ul><h3>Table of Contents</h3>
<li><a href="#14.1">14.1 - Benutzung von OpenBSD's Disklabel</a></li>
<li><a href="#14.2">14.2 - Benutzung von OpenBSD's fdisk</a></li>
<li><a href="#14.3">14.3 - Zus&auml;tzliche Festplatten unter OpenBSD installieren</a></li>
<li><a href="#14.4">14.4 - Wie man in eine Datei 'swapt'</a></li>
<li><a href="#14.5">14.5 - Soft-updates</a></li>
<li><a href="#14.6">14.6 - Wenn ich nach der Installation von OpenBSD/i386 boote, stoppt der Rechner bei 
"Using partition 3 id 0".</a></li>
<li><a href="#14.7">14.7 - Wie man ein dmesg von einer Boot Floppy bekommt</a></li>
<li><a href="#14.8">14.8 - Bootblocks installieren- i386 spezifisch</a></li>
<li><a href="#14.9">14.9 - Auf das Disaster vorbereiten: Backups machen und Wiederherstellen mit B&auml;ndern.</a></li>
<li><a href="#14.10">14.10 - Disk images unter OpenBSD mounten</a></li>
</ul>
</p> 
<hr>

<a name="14.1"></a>
<h2>Benutzung von OpenBSD's Disklabel</h2>
   
<p>
<h3>Inhaltsangabe</h3>
<ul>
<li><a href="#14.1.1">Was ist Disklabel(8)?</a>
<li><a href="#14.1.2">Disklabel w&auml;hrend der OpenBSD Installation</a>
<li><a href="#14.1.3">Gebr&auml;uchliche disklabel(8) Varianten</a>
</ul>
</p>
   
<p>
<a name="14.1.1"></a>
<h3>Was ist Disklabel(8)?</h3>
   
<p>
Disklabels werden erzeugt, um ein effizientes Interface zwischen deiner Festplatte
und den Festplattentreibern,die im Kernel enthalten sind, zu erzeugen. 'Labels' enthalten
bestimmte Informationen &uuml;ber dein Dateisystem, wie z.B. die 'drive geometry' und 
Informationen &uuml;ber deine Dateisysteme. Dies wird dann vom 'bootstrap' Programm benutzt,
um die Festplatte zu laden und um zu wissen, wo auf der Platte die Dateisysteme sind.
Labels werden auch zusammen mit den Dateisystemen benutzt, um eine effizientere Umgebung
zu erzeugen. Tiefergehende Informationen &uuml;ber 'disklabel' gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=5&format=html">disklabel(5)</a>
man page.
</p> 

<p>
Zus&auml;tzlich f&uuml;hrt die Benutzung von disklabel zur &Uuml;berwindung
der Architekturgrenzen beim Partitionieren von Festplatten. Auf i386 kann man z.B.
nur 4 prim&auml;re Partitionen haben. (Partitionen, so wie sie andere BS wie
Windows NT oder DOS sehen.) Mit disklabel(8), benutzt du eine dieser
'prim&auml;ren' Partitionen, die dann *alle* deine OpenBSD Partitionen 
enth&auml;lt (z.B. 'swap','/','/usr' und '/var'). Und du hast noch 3
weitere f&uuml;r andere Betriebssystem &uuml;ber!
</p>

<a name="14.1.2"></a>
<h3>disklabel(8) w&auml;hrend der OpenBSD Installation</h3>

<p>
Einer der Hauptteile der OpenBSD Installation ist das erste Erzeugen der 
'labels'. Das kommt (f&uuml;r i386 Benutzer) direkt nach der Benutzung von <a href="#14.2">fdisk(1)</a>.
W&auml;hrend der Installation benutzt du 'disklabel' um deine seperaten 'label' zu erzeugen, die deine
seperaten 'mountpoints' enthalten. W&auml;hrend der Installation kannst du mittels disklabel (8) deine
Mountpoints setzen, aber das ist eigentlich nicht n&ouml;tig, da du deine &Auml;nderungen sp&auml;ter
sowieso best&auml;tigen musst. Aber es macht deine Installation schon etwas geradliniger.
</p>

<p>
Da das w&auml;hrend der Installation geschieht, hast du noch keine funktionierenden 'labels', und
sie m&uuml;ssen erst erzeugt werden. Das erste 'label', das du erzeugt, ist das Label 'a'. Das sollte
das Label sein, auf dem dann '/' gemountet wird. Die empfohlenen Partitionen und ihren Gr&ouml;ssen 
kannst du dir auf <a href="faq4.html#4.3">faq4.3</a> ansehen. F&uuml;r Server wird empfohlen zumindest diese
'label' seperat zu halten. F&uuml;r Desktop User reicht vermutlich ein einzelner Mountpoint '/'. 
Wenn du deine root-Partition ('a' Label) erzeugst, denk dran, dass du in jedem Fall noch etwas Platz f&uuml;r 
deine Swap-Partition ben&ouml;tigst. Jetzt kennst du die Grundlagen, und daher geben wir hier jetzt mal ein
Beispiel f&uuml;r das Benutzen von disklabel. In diesem ersten Beispiel wird angenommen, dass 
OpenBSD das einzige Betriebssystem auf diesem Computer ist, und eine volle/komplette Installation gemacht
wird.
</p>

<ul><pre>

Wenn die Festplatte mit anderen Betriebssystemen geteilt wird, sollten diese BS einen
BIOS Partitionseintrag haben, der den kompletten Platz umfasst, den sie beanspruchen. 
Aus Sicherheitsgr&uuml;nden solltest du auch sicherstellen, dass alle OpenBSD Dateisysteme innerhalb 
des 'offset' und der Gr&ouml;sse sind, die in der 'A6' BIOS Partitionstabelle angegeben sind.
(Standardm&auml;ssig wird der disklabel Editor das versuchen zu erzwingen). Wenn du dir nicht
sicher bist, wie man mehrere Partitionen sauber benutzt (also wie man /, /usr, /tmp, /var, /usr/local
und andere Dinge voneinander trennt), dann belasse es jetzt erstmal bei einer root und einer 
swap Partition.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <strong>d a</strong>
&gt; <strong>a a</strong>
offset: [63] <strong>&lt;Enter&gt;</strong>
size: [16386237] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
&gt; <strong>a b</strong>
offset: [131103] <strong>&lt;Enter&gt;</strong>
size: [16255197] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [swap] <strong>&lt;Enter&gt;</strong>
</pre></ul>

<p>
An diesem Punkt hast du eine 64MB root Partition erzeugt, die mit / gemountet wird, und eine 64MB Swap Partition. 
In diesem Fall startet der Offset bei Sektor 63. So willst du es haben. Wenn es bei der Gr&ouml;sse angekommen
ist, wird dir Disklabel die Gr&ouml;ssen in Sektoren angeben, du musst aber die Gr&ouml;ssen nicht ebenfalls
im gleichen Format eingeben. Wie im Beispiel oben kannst du Gr&ouml;ssen zum Beispiel so eingeben:
<i>64 Megabytes = 64M</i> und <i>2 Gigabytes = 2G</i>. Disklabel wird dann einfach auf den n&auml;chsten
Zylinder runden. Im obigen Beispiel kann man auch sehen, dass Disklabel annimmt, dass Label 'b' eine
Swap-Partition sein wird. Das ist eine korrekte Annahme, da im GENERIC Kernel Swap auf Label 'b' festgelegt
ist, und daher solltest du dieser Richtlinie ebenfalls folgen und 'b' als SwapBereich benutzen. 
</p>

<p>
Das n&auml;chste Beispiel wird dich durch die Erzeugung zweier weiterer Labels f&uuml;hren. Im &uuml;brigen kann
das keine komplette Installation sein, da die Gr&ouml;sse dieser beiden Partitionen nicht ausreicht, um OpenBSD
komplett zu installieren. Das Ganze dient nur zur Wiederholung und Vertiefung. 
</p>

<ul><pre>
&gt; <strong>a d</strong>
offset: [262143] <strong>&lt;Enter&gt;</strong>
size: [16124157] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/tmp</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
&gt; <strong>a e</strong>
offset: [393183] <strong>&lt;Enter&gt;</strong>
size: [15993117] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/var</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
</pre></ul>

<p>
Im obigen Beispiel fallen dir vermutlich zwei Dinge auf. Zum einen, dass der offset automatisch 
f&uuml;r dich errrechnet wird. Wenn du eine solche Installation machst, musst du dich mit dem
&Auml;ndern der Offsets nicht herumschlagen. Ein weiterer Unterschied, der dir vielleicht auff&auml;llt,
ist, dass Label 'c' &uuml;bersprungen wurde. Das ist aber Absicht, und zwar deshalb, weil Label 'c' die ganze
Festplatte repr&auml;sentiert. Aus diesem Grund solltest du Label 'c' vollkommen in Ruhe lassen.
</p>

<p>
Sind deine Label erst einmal alle erzeugt, ist alles, was noch n&ouml;tig ist, die Label auf die Festplatte 
zu schreiben, und einfach mit dem Installationsprozess fortzufahren. Um alles zu schreiben und disklabel zu
beenden (und mit der Installation weiterzumachen) tippe folgendes:
</p>

<ul><pre>
&gt; <strong>w</strong>
&gt; <strong>q</strong>
</ul></pre>

<p>
<strong>*HINWEIS*</strong> - F&uuml;r User mit grossen Festplatten: Wenn dein BIOS nicht in der Lage ist, eine
so grosse Festplatte zu unterst&uuml;tzen, kann OpenBSD das auch nicht. Ansonsten sollte OpenBSD keine 
Schwierigkeiten mit deiner Festplatte haben. Wenn dein BIOS das nicht kann, k&ouml;nntest du es mit
Maxtor EZ-Drive oder einem anderen 'Overlay' Produkt ausprobieren.
</p>


<a name="14.1.3"></a>
<h3>Gebr&auml;chliche Benutzung von disklabel(8)</h3>

<p>
Wenn dein System erst einmal installiert ist, solltest du disklabel nicht mehr allzuoft benutzen m&uuml;ssen.
Aber du kannst es gebrauchen, wenn du z.B. Festplatten hinzuf&uuml;gen willst, welche entfernen willst oder
auch einfach umstrukturieren. Eines der ersten Dinge, die du dann machst, ist, dir den momentanen g&uuml;ltigen
Disklabel anzusehen. Und das geht so:
</p>

<ul><pre>
# <strong>disklabel wd0</strong> &gt;----- Oder was du dir ach immer f&uuml;r eine Platte ansehen willst

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre></ul>

<p>
Der obige Befehl zeigt dir einfach den existierenden Disklabel, und stellt sicher, dass du nichts kaputt machst
oder durcheinanderbringst. (Was wir alle von Zeit zu Zeit mal brauchen.) Um aber Ver&auml;nderungen 
durchzuf&uuml;hren, musst du die -E option mit angeben:
</p>

<ul><pre>
# <strong>disklabel -E wd0</strong>
</pre></ul>

<p>
Das wird dich einfach an einen Prompt bringen, und zwar den selben, den du schon w&auml;hrend der OpenBSD Installation
benutzt hast. Das wahrscheinlich wichtigste Kommando ist '?'. Das erzeugt n&auml;mlich eine Liste mit m&ouml;glichen
Optionen f&uuml;r Disklabel. Mit Hilfe von 'M' kannst du dir sogar die gesamte disklabel(8) man page ansehen. Von
diesem Prompt aus wirst du dein gesamtes Hinzuf&uuml;gen, L&ouml;schen und &Auml;ndern der Partitionen
vornehmen. Zus&auml;tzliche Informationen gibt es in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page.
</p>

<p>
<a name="14.2"></a>
<h2>14.2 - Benutzung von OpenBSD's fdisk</h2>
</p>
<p>
Um sicher zu sein, pr&uuml;fe zuerst die fdisk man page:
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
</p>
<p>
Fdisk ist ein Programm, dass bei der Pflege und Wartung deiner Partitionen helfen soll.
Dieses Programm wird auch bei der Installation benutzt, um deine OpenBSD Partition einzurichten (
diese Partition kann <u>mehrere</u> Labels enthalten, jedes mit Dateisystemen/Swap/etc.).
Es kann den Platz auf deiner Festplatte aufteilen und eine Partition als aktiv setzen.
Dieses Programm wird f&uuml;r gew&ouml;hnlich im 'Single User Mode' benutzt werden (boot -s).
Fdisk setzt auch den MBR auf deinen verschiedenen Festplatten.
</p>

<p>
F&uuml;r Installationszwecke braucht man meistens nur <b>EINE</b> OpenBSD
Partition und benutzt dann disklabel, um Swap und Dateisysteme darauf zu installieren.
</p>

<p>
Um dir nur deine Partitionstabelle mit fdisk anzugucken:<br>
<ul>
<pre># <strong>fdisk fd0</strong><br>
</pre>
</ul>

Was dann eine &auml;hnliche Ausgabe wie diese hier erzeugt:
</p>

<ul>
<pre>
         Disk: fd0       geometry: 80/2/18 [2880 sectors]
         Offset: 0       Signatures: 0xAA55,0x0
                  Starting        Ending
          #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
----------------------------------------------------------------------
         *0: A6    0   0   1 -   79   1  18 [         0 -       2880] OpenBSD
          1: 00    0   0   0 -    0   0   0 [         0 -          0] unused
          2: A7    0   0   2 -   79   1  18 [         1 -       2879] NEXTSTEP
          3: 00    0   0   0 -    0   0   0 [         0 -          0] unused
</pre>
</ul>

<p>
In diesem Beispiel betrachten wir die Ausgabe der Floppy Disk. Wir k&ouml;nnen die
OpenBSD Partition (A6) und ihre Gr&ouml;sse sehen. Der * sagt uns, dass die OpenBSD
Partition bootbar ist.
</p>

<p>
Im vorigen Beispiel haben wir uns die Informationen nur angesehen. Was aber, wenn wir unsere
Partitionstabelle ver&auml;ndern wollen? Nunja, dazu m&uuml;ssen wir zun&auml;chst das <b>-e</b>
flag benutzen. Das bringt uns dann zu einer Kommandozeile, die uns mit fdisk interagieren l&auml;&szlig;t.
</p>

<ul>
<PRE>
# <strong>fdisk -e wd0</strong>
Enter 'help' for information
fdisk: 1&gt; <strong>help</strong>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt;
</PRE>
</ul>

<p> 
Es ist absolut sicher in fdisk ein wenig rumzuwandern und zu probieren, solange man <Strong>N</strong> auf die
Frage antwortet, ob die &Auml;nderungen abgespeichert werden sollen und *NICHT* das <strong>write</strong> 
Kommando benutzt.
</p>

<p>Hier ist eine &Uuml;bersicht &uuml;ber die Kommandos, die man nach der Eingabe des <b>-e</b> flags benutzen kann.<br>
<ul>
<li><strong>help</strong>    Zeige eine Liste der Kommandos an, die fdisk im interaktiven 'edit mode' versteht.</li>
<li><strong>reinit</strong>  Initialisiere die momentane, im Speicher befindliche Kopie des Boot-Blocks.</li>
<li><strong>disk</strong>    Zeige die momentane Platten-Geometrie an, die fdisk herausgefunden hat. Du bekommst eine M&ouml;glichkeit sie zu &auml;ndern, wenn du willst.</li>
<li><strong>edit</strong>     &Auml;ndere eine ausgew&auml;hlte Platten-Geometrie in Kopie des momentanen Bootblocks.  Das geschieht entweder im BIOS geometry mode oder in sector offsets und Gr&ouml;ssen.</li>
<li><strong>flag</strong>    Den jetzigen Partitionstabelleneintrag bootbar machen. Nur ein Eintrag zur Zeit kann bootbar sein. 
Wenn du von einer extended Partition booten willst, musst du auch den entsprechenden Eintrag als bootbar markieren. </li>
<li><strong>update</strong>  Bringe den Maschinencode in der Speicherkopie des momentanen Bootblocks auf aktuellen Stand.</li>
<li><strong>select</strong>  W&auml;hle und lade den Boot block, auf den der Eintrag der erweiterten Partitionstabelle im momentanen Boot-Block zeigt.</li>
<li><strong>print</strong>   Gebe die momentan im RAM befindlichen und gew&auml;hlte Kopie des Boot Blocks und seinen MBR auf dem Bildschirm aus.</li>
<li><strong>write</strong>   Schreibe die RAM-Version des Boot Blocks auf die Platte. Du wirst um eine Best&auml;tigung gebeten.</li>
<li><strong>exit</strong>    Verlasse den momentanen Level von fdisk, kehre entweder zur vorher gew&auml;hlten Kopie eines BootBlocks im RAM zur&uuml;cke oder verlasse das Programm, wenn es keinen gibt.</li>
<li><strong>quit</strong>    Verlasse den momentanen Level von fdisk, kehre entweder zur vorher 
gew&auml;hlten Kopie eines BootBlocks im RAM zur&uuml;cke oder verlasse
das Programm, wenn es keinen gibt. Anders als exit schreibt diese Variante den modifizierten Block auf die Platte.</li>
<li><strong>abort</strong>   Verlasse das Programm ohne &Auml;nderungen zu speichern.</li>
</ul>
</p>
<br>

<p>
<a name="14.3"></a>
<h2>14.3 - Zus&auml;tzliche Festplatten unter OpenBSD installieren</h2>
</p>

<p>
Nun, nachdem du deine Festplatte <strong>SAUBER</strong> eingebaut hast, musst du 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
(<i> nur bei i386 </i
>) und auch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&apropos=0&sektion=8&format=html">
disklabel(8)</a>, um deine Festplatte unter OpenBSD benutzen zu k&ouml;nnen. 
<P>
Die i386 Leute starten mit fdisk.  Andere Architekturen ignorieren das einfach.
<ul><pre>
# <Strong>fdisk -i sd2</strong>
</pre></ul>
Das wird die "echte" Partitionstabelle der Festplatte f&uuml;r eine 
ausschliessliche Benutzung mit OpenBSD initialisieren.
Als n&auml;chstes musst du einen disklabel daf&uuml;r erzeugen.
Das wird wohl etwas verwirrend sein.
<UL><PRE>
# <strong>disklabel -e sd2</strong>

<i>(der Bildschirm wird leer, dein $EDITOR erscheint)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></ul>
Zun&auml;chst einmal ignoriere die 'c' Partition, sie ist immer da und Programme wie disklabel
ben&ouml;tigen sie, um zu funktionieren.
F&uuml;r den normalen Betrieb sollte die fsize immer 1024 sein, bsize immer 8192
und cpg immer 16.  Der Fstype ist 4.2BSD.  Total sectors ist die gesamte Gr&ouml;sse der Festplatte.
Nehmen wir an, es handelt sich um eine 3 Gigabyte Festplatte.  Drei Gigabytes in der Sprache der 
FestplattenHersteller sind 3000 Megabytes.  Rechne also 6185088/3000 (benutze bc(1)).  Du erh&auml;ltst 2061.
um jetzt Partitionsgr&ouml;ssen f&uuml;r a, d, e, f, g, ... zu erhalten, rechne einfach X*2061
um X Megabytes Platz auf dieser Partition zu erhalten.  Der offset f&uuml;r deine erste Partition
sollte derselbe sein, wie von "sectors/track" vorher in disklabel's Ausgabe angegeben.
Bei uns ist es 63.  Der offset f&uuml;r jede Partition ist hinterher eine Kombination aus der
Gr&ouml;sse und dem Offset jeder anderen Partition (mit Ausnahme der C Partition, da sie keine
Rolle in dieser Gleichung spielt.)
<P>
Wenn du aber nur eine Partition auf deiner Festplatte brauchst, zum Beispiel wenn
das ganze Ding nur zum Ablegen von Webpages oder einem Homedirectory oder etwas anderem 
nutzen willst, nimm einfach die gesamte Gr&ouml;sse der Platte und ziehe die Sektoren pro Track
davon ab.
6185088-63 = 6185025.  Deine Partition ist
<UL><PRE>
    d:  6185025       63    4.2BSD     1024  8192    16 
</PRE></UL>
<P>
<b>Wenn dir das alles unn&ouml;tig komplex erscheint, kannst du disklabel -E benutzten, um 
den selben Patitionierungsmodus zu erhalten, den du auf deiner Installationsdisk hattest!</b>
Dort kannst du "96M" benutzen, um "96 megabytes" anzugeben.  (Oder, wenn deine Festplatte gross
genug ist, 96G f&uuml;r 96 Gigabyte!) Ungl&uuml;cklicherweise benutzt der -E Modus die 
BIOS Platten-Geometrie und nicht die reale, und oft sind die beiden nicht deckungsgleich.
Um dieses Problem zu umgehen tippe 'g d' f&uuml;r 'geometry disk'.
(Andere M&ouml;glichkeiten sind 'g b' f&uuml;r Geometry BIOS' und 'g u' f&uuml;r 
geometry user, oder einfach das, was das Label gesagt hat, bevor disklabel irgendwelche
&Auml;nderungen gemacht hat.)
<P>
Das war eine Menge.  Aber du bist noch nicht fertig.  
Zuletzt musst du noch das Dateisystem auf der Festplatte mittels <a href=
"http://www.openbsd.org/cgi-bin/man.cgi?query=newfs
&apropos=0&sektion=8&format=html">newfs(8)</a> erzeugen.
</p>

<p>
<ul><pre>
bsd# <strong>newfs wd1a </strong></pre></ul>
</p>

<p>
Oder wie deine Festplatte auch immer nach dem OpenBSD Plattennummerierungs-Schema heissen mag.  (Guck einfach
in der Ausgabe von dmesg(1) nach, da steht es drin.)
</p>

<p>
Nun &uuml;berleg dir, wohin du deine gerade neu geschaffene Partition mounten willst.
Sagen wir einfach mal /u.  Daher erzeuge zun&auml;chst einmal /u mit 'mkdir'. Dann mounte sie.
</p>

<UL><PRE>
mount /dev/wd1a /u
</PRE></UL>

<P>
Zuletzt musst du sie noch zu /etc/fstab hinzuf&uuml;gen.
</p>
<UL><PRE>/dev/wd1a /u ffs rw 1 1</PRE></UL>

<p>
Was aber, wenn du ein existierendes Verzeichnis, wie zum Beispiel /usr/local auslagern willst? Mounte
die neue Platte unter /mnt und benutze cpio -pdum,um /usr/local in das /mnt Verzeichnis zu kopieren.
Passe  die /etc/fstab so an, dass jetzt die /usr/local Partition auf /dev/wd1a zu finden ist.
(Deine frisch formatierte Partition.) 
Beispiel:
</p>

<ul>
<strong>/dev/wd1a /usr/local ffs rw 1 1</strong>
</ul>

<p>
Reboote in den single user Mode.. <strong>boot -s</strong> Verschiebe das existierende
/usr/local nach /usr/local-backup (oder l&ouml;sche es gleich, wenn du mutig bist) und erzeuge ein
leeres Verzeichnis /usr/local. Dann reboote das System, und voila!! Die Dateien sind da!
</p>

<br>

<p>
<a name="14.4"></a>
<h2>14.4 - Wie man in eine Datei swapt</h2>
</p>

<p>
(Hinweis: wenn du deshalb in eine Datei swappen willst, weil du immer 
&quot;virtual memory exhausted&quot; Fehler bekommst, solltest du lieber
versuchen deine 'per-process limits' zu erh&ouml;hen und zwar mit
csh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&sektion=1&format=html">unlimit(1)</a>,
oder auch mit
sh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&sektion=1&format=html">ulimit(1)</a>.)
</p>

<p>
Nach der Ver&ouml;ffentlichung von OpenBSD 2.5 kam
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a> heraus, 
was den Umgang mit swap devices viel leichter machte. Falls du auf einem OpenBSD 2.5 System arbeitest, tausche swapctl mit swapon, und benutze pstat -s, um 
deine "swap devices" aufzulisten. Das Swappen in eine Datei ben&ouml;tigt keinen
selber gebauten Kernel, obwohl man das nat&uuml;rlich  trotzdem machen kann,
diese FAQ zeigt dir beide Wege den Swap zu erh&ouml;hen.
</p>

<h3>In eine Datei swappen. </h3>

<p>
In eine Datei zu swappen ist der einfachste und schnellste Weg, um 
zus&auml;tzlichen Swap zu bekommen. Das gilt aber nicht f&uuml;r Benutzer von 
Softupdates (was ja standardm&auml;ssig nicht aktiviert ist).
F&uuml;r den Anfang findest du erstmal heraus, wieviel Swap du momentan hast,
und wieviel du davon benutzt, und das geht einfach mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a>
Werkzeug. Zum Beispiel mit diesem Kommando:
</p>

<ul><pre>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></ul>

<p>
Das zeigt alle Ger&auml;te, die momentan f&uuml;r das swappen benutzt werden,
und ihre momentane Statistik. Im obigen Beispiel gibt es nur ein Ger&auml;t namens 
&quot;swap_device&quot;. Das ist der vordefinierte Bereich auf der Platte, der f&uuml;r das Swappen benutzt wird. 
(Wird im &uuml;brigen als Partition 'b' bei 'disklabel' angezeigt). Wie du auch sehen kannst, wird das Ger&auml;t
zur Zeit nicht sonderlich belastet oder vielmehr benutzt. Aber f&uuml;r den Zweck dieses Dokumentes tun wir einfach
so, als wenn noch weitere 32MB ben&ouml;tigt w&uuml;rden.
</p>
<p>
Der erste Schritt um eine Datei als Swap-Bereich zu nutzen, ist, die Datei zu erzeugen. Am besten macht man
das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&sektion=1&format=html">dd(1)</a>
Hier ist ein Beispiel, das eine Datei <i>/var/swap</i> mit der Gr&ouml;sse von 32MB erzeugt.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></ul>

<p>
Nachdem das erledigt ist, k&ouml;nnen wir jetzt das swappen auf diese Datei richten. Benutze einfach das folgende
Kommando, um das Swappen auf diese Datei zu lenken
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo chmod 600 /var/swap</strong>
ericj@oshibana&gt; <strong>sudo swapctl -a /var/swap</strong>
</ul></pre>

<p>
Jetzt m&uuml;ssen wir noch pr&uuml;fen, ob sie auch korrekt zu unserer Liste der Swap-Ger&auml;te hinzugef&uuml;gt wurde.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></ul>

<p>
Jetzt, wo die Datei erzeugt wurde und in sie hinein geswappt wird, musst du noch eine Zeile in deine
<i>/etc/fstab</i> Datei hineinschreiben, so dass die Datei beim n&auml;chsten Booten auch benutzt wird.
Wenn diese Zeile nicht hinzugef&uuml;gt wird, wird dieses Swap-Ger&auml;t eben nicht konfiguriert.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>cat /etc/fstab</strong>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</ul></pre>

<h3>Swappen &uuml;ber ein vnode Ger&auml;t</h3>

<p>
Dies ist eine dauerhaftere L&ouml;sung, um mehr Swap-Speicher zu erhalten. Um in eine Datei zu swappen,
erzeuge zun&auml;chst einen Kernel mit vnd0c als swap. Wenn du wd0a als root Dateisystem hast, und wd0b als bisherigen swap, 
benutze diese Zeile in deiner Kernel Konfigurations-Datei (wenn du dir nicht sicher bist, sieh dir die Sektion "Einen neuen
Kernel kompilieren" in dieser FAQ an): 
</p>

<ul><pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre></ul>

<p>
Nachdem das erledigt ist, muss die Datei, in die geswappt werden soll, erzeugt werden. Du solltest mit dem selben Kommando wie 
im Beispiel oben machen.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></ul>

<p>
Da deine Datei jetzt an ihrem Platz ist, musst du die Datei in die <i>/etc/fstab</i> eintragen. Hier ist eine Beispielzeile,
mit der man dieses Ger&auml;t beim booten als Swap benutzt.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>cat /etc/fstab</strong>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre></ul>

<p>
An diesem Punkt muss dein Computer neu gebootet werden, so dass die &Auml;nderungen am Kernel Effekt haben. Nachdem das 
passiert ist, ist es an der Zeit, das Ger&auml;t als swap zu konfigurieren. Dazu wirst du 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8&format=html">vnconfig(8)</a> benutzen.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo vnconfig -c -v vnd0 /var/swap</strong>
vnd0: 33554432 bytes on /var/swap
</pre></ul>

<p>
Als letzten Schritt, musst du den Swap auf diesem Ger&auml;t noch einschalten. Wir machen das genau wie in dem Beispiel oben mit
swapctl(8). Und zuletzt pr&uuml;fen wir wieder, ob es auch korrekt in unsere Tabelle eingetragen wurde. 
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo swapctl -a /dev/vnd0c</strong>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></ul>



<p><a name="14.5"></a>
<h2>14.5 - Soft-updates</h2>
</p>

<p>
In den letzten paar Jahren hat Kirk McKusick an etwas gearbeitet, was 
"soft updates" genannt wird. Es basiert auf einer Idee von Greg Ganger und Yale
Patt, die besagt, dass ein teilweises Ordnen der "buffer cache" Operationen die
Notwendigkeit des synchronen Schreibens von Verzeichnis Eintr&auml;gen im FFS
Code &uuml;berfl&uuml;ssig machen w&uuml;rde. Ergo ein gro&szlig;er Performance-Gewinn
beim Schreiben auf Festplatten.
</p>

<p>
Um Softupdates aktivieren zu k&ouml;nnen, muss dein Kernel folgende Option haben:<br>
<b>HINWEIS:</b> Diese Option ist seit OpenBSD Version 2.7 standardm&auml;ssig aktiviert. Trotzdem musst du sie
auf Basis der Platten-Partitionen noch aktivieren.
</p>

<p>
<strong>option FFS_SOFTUPDATES</strong>
</p>

<p>
dann musst du in den single-user mode booten:
</p>

<ul>
<strong>
<pre>
        boot> boot -s
        [snip]
        bsd# tunefs -s enable &lt;raw device&gt;
        bsd# reboot -n
</pre>
</strong>
</ul>

<p>
<a name="14.6"></a>
<h2>14.6 -  Wenn ich nach der Installation von OpenBSD/i386 boote, stoppt der Rechner bei "Using partition 3 id 0".</h2>
</p>
<p>
Das bedeutet, dass dein MBR (Master Boot Record) nicht sauber installiert wurde oder dass dein 
BIOS eine andere Idee hat, was die Geometrie deiner Fespltatte angeht, und zwar eine die nicht kompatibel ist
mit deinem jetzigen MBR. Um das Problem zu l&ouml;sen, solltest du zuerst versuchen, den OpenBSD boot block erneut
zu installieren. Dazu lese
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&sektion=8&arch=i386&format=html">installboot(8)</a>.
<P>
Um es zun&auml;chst zum Laufen zu kriegen, musst du deine boot disk als bootstrap benutzen.
Danach tust du deine Install Disk rein, und bevor sie den Kernel und die ramdisk l&auml;dt, bekommst
du einen <tt>boot&gt;</tt> Prompt von der Floppy Disk.  Benutze ihn, um OpenBSD von deiner Festplatte zu booten.
<UL><PRE>
booting...
OpenBSD boot 1.2.3
probing hd0 fd0...
boot&gt; <b>boot hd0a:/bsd</b>
</UL></PRE>
Jetzt, da du gebootet hast, und unter der Vorraussetzung, dass du deine ganze
Festplatte f&uuml;r OpenBSD reserviert hast, kannst du den Master Boot Record  mit fdisk(8) reinitialisieren.
(Falls du auf deiner Festplatte Partitionen f&uuml;r andere Betriebssystem hast, kannst du auf keinen Fall 
<tt>installboot</tt> verwenden, anstattdessen musst du dir eine andere Option wie z.B. OS-BS ansehen,
siehe weiter unten)
<UL><PRE>
# <b>fdisk -i wd0</b>
</PRE></UL>
Jetzt musst du die boot blocks wieder schreiben.
<UL><PRE>
# <strong>cp /usr/mdec/boot /boot</strong>
# <strong>/usr/mdec/installboot -v /boot /usr/mdec/biosboot wd0</strong>
</PRE></UL>
Und zum Schluss musst du rebooten und es testen.
<p>
Wenn das nicht funktioniert hat, hast du imemr noch ein paar Optionen. Deine Gl&uuml;cksstr&auml;hne ist
also noch nicht zu Ende. Die erste ist, einen Bootloader wie OS-BS zu verwenden. Auf der OpenBSD CD-ROM 
ist der os-bs Bootloader im 'tools' Verzeichnis. Wenn du keine CD-ROM gekauft hast, kannst du os-bs von jedem
OpenBSD ftp-Mirror herunterladen. Die ben&ouml;tigte Datei ist 
<tt>pub/OpenBSD/2.8/tools/osbs135.exe</tt>
</p>

<p>
Nimm dir auch die Zeit, dir die OS-BS Webseiten anzusehen: 
<a href= "http://www.prz.tu-berlin.de/~wolf/os-bs.html">
          http://www.prz.tu-berlin.de/~wolf/os-bs.html</a>
</p>

<p>
Es gibt auch einige andere kommerzielle Bootloader oder auch lilo, die du f&uuml;r das 
multi-booting nehmen kannst.
</p>

<p>
Hier ist eine kleine Anweisung, wie du lilo auf dein System bekommst.
</p>

<p>
<ul>
<li>Boote mit einer DOS floppy und gib ein "fdisk /MBR" ein. Stelle sicher, dass du auch auf
der Festplatte bist, von der du booten willst.</li>
<li>Boote von einer Linux Disk, installiere LILO &amp; und verkn&uuml;pfe es mit deinem OpenBSD 
Bootblock.
</li>
</ul>
</p>

<p>
Ausf&uuml;hrlichere Anweisungen gibt es in <a href="ftp://ftp.openbsd.org/pub/OpenBSD/2.8/i386/INSTALL.linux">INSTALL.linux</a>
</p>

<br>

<p>
<a name="14.7"></a>
<h2>14.7 - Wie man ein dmesg von einer Boot-Floppy bekommt</h2>

</p>
<p>
RAMDISK Images (boot floppies) enthalten das <i>dmesg</i> Werkzeug leider nicht.
Sie mounten aber das <code>/kern</code> Dateisystem. Um die dmesg Informationen in eine
Datei zu kopieren kannst du z.B. folgendes eingeben:
</p>

<ul><pre>
# <strong>cat /kern/msgbuf >mydmesg</strong>
</pre></ul>
<P>
Boot disks enthalten aber 'more', um seitenweise durch die Ausgabe zu scrollen :
<pre><ul>
# <strong>more /kern/msgbuf</strong>
</ul></pre>

Pr&uuml;fe auch die <a href= "faq4.html#4.5">Sektion 4.5</a>

<p>
<a name="14.8"></a>
<h2>14.8 - Bootblocks installieren - i386 spezifisch</h2>
</p>

<p>
&Auml;ltere Versionen von MS-DOS k&ouml;nnen nur mit Festplattengeometrien von 1024 Zylindern
oder weniger klarkommen.  Da nahezu alle modernen Betriebssysteme mehr als 1024 Zylinder haben,
haben die meisten SCSI BIOS Chips (die auf den SCSI Controller Karten) und IDE BIOSse
(was Teil des restlichen PC BIOS ist) eine Option, manchmal auch als Grundeinstellung, die 
wirkliche Geometrie in etwas zu &uuml;bersetzen, mit dem MS-DOS umgehen kann.
Wie dem auch sei, nicht alle BIOS Chips "&uuml;bersetzen" die Geometrie in der selben Weise.
Wenn du dein BIOS wechselst (entweder mit einem neuen Motherboard oder einem neuen SCSI
Controller), und das neue benutzt eine andere "&uuml;bersetzte" Geometrie, wirst du nicht
in der Lage sein den 'second stage boot loader' zu laden (und kannst daher den Kernel auch nicht laden)
(Das liegt daran, dass der 'first stage boot loader' eine Liste der Bl&ouml;cke enth&auml;lt, die
/boot in der "&uuml;bersetzten" Geometrie enthalten.)
Falls du IDE Platten benutzt, und du &Auml;nderungen an deinen BIOS Einstellungen machst,
kannst du seine &Uuml;bersetzung ebenfalls (ungewollt) &auml;ndern. (die meisten IDE BIOSse bieten 3 verschiedene
&Uuml;bersetzungen.) Um deinen Bootblock zu reparieren, damit du normal booten kannst,
stecke einfach eine Boot floppy in dein Floppy-Laufwerk und gib am Bootprompt
"b hd0a:/bsd" ein, um ihn zu zwingen, von der ersten Festplatte zu booten (und nicht von der Floppy).
Deine Maschine sollte normal booten. Jetzt musst du die erste Stufe des Bootloaders auf den neuen Stand bringen.
(und dazu passend den Boot block schreiben).
<br>
Unser Beispiel geht davon aus, dass deine boot disk sd0 ist (bei IDE w&auml;re es wd0, etc..) :
</p>
<ul>
<pre>
# <strong>cd /usr/mdec; ./installboot /boot biosboot sd0</strong>
</pre>
</ul>
<p>
Wenn installboot sich dar&uuml;ber beschwert, dass es die BIOS Geometrie nicht lesen kann, kannst du 
am boot&gt; Prompt das &quot;machine diskinfo&quot; (oder k&uuml;rzer
&quot;ma di&quot; ) Kommando eingeben, damit es die Informationen ausgibt, die du brauchst.
F&uuml;ttere die &quot;heads&quot; und &quot;secs&quot; Werte in installboot's -h
und -s Flags, so dass das modifizierte installboot Kommando wie folgt aussieht:
</p>
<ul><pre>
#<strong> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</strong>
</pre></ul>

<p>
Wenn eine neuere Version von bootblocks ben&ouml;tigt wird, wirst du diese selber kompilieren m&uuml;ssen. Und das geht so:
</p>

<ul><pre>
# <strong>cd /sys/arch/i386/stand/</strong>
# <strong>make && make install </strong>
# <strong>cd /usr/mdec; cp ./boot /boot</strong>
# <strong>./installboot /boot biosboot sd0</strong> (oder wie deine Festplatte auch immer heissen mag)
</pre></ul>

<p>
<a name="14.9"></a>
<h2>14.9 - Auf die Katastrophe vorbereiten: Backups machen und Wiederherstellen mit B&auml;ndern (tapes)</h2>
</p>

<h3>Einf&uuml;hrung:</h3>

<p>
Wenn du so etwas wie einen Poduktionsserver laufen lassen willst, ist es ratsam irgendeine Form von Backup zu haben,
f&uuml;r den Fall, dass eine deiner Festplatten versagt oder einen Crash hat.
</p>

<p>
Diese Information wird dir helfen die Standard-Werkzeuge <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a> und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> zu benutzen, die als Teil von OpenBSD ausgeliefert werden. 
Ein fortgeschritteneres Werkzeug ist "Amanda", das auch multiple Server auf ein Tape-Drive sichern kann. In den meisten Umgebungen sind 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a>/<a href=http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> aber ausreichend. 
Wenn du aber multiple Maschinen auf ein Band sichern willst, ist Amanda auf jeden Fall einen Blick wert.
</p>

<p>
Die Beispiele in diesem Dokument benutzen sowohl SCSI Festplatten, als auch Tapes. In einer Produktionsumgebung empfehlen wir SCSI und kein
IDE wegen der Art und Weise, wie IDE mit 'bad blocks' umgeht. Das heisst aber nicht, dass diese Informationen nutzlos sind, wenn 
du IDE benutzt,  sondern einzig deine Ger&auml;tenamen werden sich leicht unterscheiden.  Zum Beispiel w&auml;re sd0a in einem
IDE-basierten System wd0a.
</p>

<h3>Backup auf's Tape bringen:</h3>

<p>
Um sein Backup auf ein Band zu bringen, muss man wissen, wo seine Dateisysteme gemountet sind. Das findet man mit dem 
"mount"-Kommando am Shell-Prompt heraus. Dabei sollte eine Ausgabe wie diese herauskommen:
</p>

<ul><pre>
shell# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</ul></pre>

<p>
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a, also auf der SCSI-Festplatte 0, Partition a. Das /usr 
Dateisystem befindet sich auf sd0h, also SCSI Festplatte 0, Partition h.
</p>

<p>
Ein weiteres Beispiel einer etwas gr&ouml;sseren mount-Tabelle k&ouml;nnte so aussehen:
</p>

<ul><pre>
shell# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</ul></pre>

<p>
In diesem fortgeschritteneren Beispiel befindet sich das root (/) Dateisystem auf sd0a. Das /var Dateisystem befindet sich auf sd0d, das /home 
Dateisystem auf sd0e und /usr auf sd0h.
</p>

<p>
Um ein Backup deiner Maschine zu machen, musst du 'dump' mit jeder festgelegten Partition f&uuml;ttern. Hier ist ein
Beispiel der Kommandos, um die einfachere mount-Tabelle weiter oben zu sichern:
</p>

<ul><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</ul></pre>

<p>
F&uuml;r die etwas fortgeschrittenere mount-Tabelle w&uuml;rde man etwas wie das hier benutzen:
</p>

<ul><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</ul></pre>

<p>
Sieh dier einfach die dump-man-page f&uuml;r genauere Angaben &uuml;ber jedes Befehlsargument an.
</p>

<ul>
<li><b>0</b> - F&uuml;hre einen Level 0 Dump durch, hole alles
<li><b>a</b> - Versuche automatisch die Bandl&auml;nge herauszufinden
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand, um zu reflektieren, wann die letzte Sicherung gemacht wurde
<li><b>f</b> - Welches Bandlaufwerk benutzt werden soll (/dev/nrst0 in diesem Fall)
</ul>

<p>
Zuletzt welche Partition gesichert werden soll (/dev/rsd0a, usw.)
</p>

<p>
Das mt Kommando wird am Ende benutzt, um das Band zur&uuml;ckzuspulen. Sieh dir die mt man page an, wenn du mehr Informationen
haben willst (wie etwa eject).
</p>

<p>
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heisst, benutze einfach dmesg, um das herauzufinden. Ein Beispiel-Eintrag von
dmesg f&uuml;r ein Bandlaufwerk k&ouml;nnte so aussehen:
</p>

<ul><pre>
st0 at scsibus0 targ 5 lun 0: <ARCHIVE, Python 28388-XXX, 5.28>
</ul></pre>

<p>
Du hast vielleicht bemerkt, dass bei der Sicherung das Bandlaufwerk als "nrst0" anstatt von "sto" bezeichnet wird, wie man es in dmesg sieht.
Wenn du auf st0 als nrst0 zugreifst, benutzt du das selbe physikalische Ger&auml;t, aber sagst dem Ger&auml;t, es solle nicht 
zur&uuml;ckspulen, nachdem der Job im raw mode beendet wurde. Um multiple Dateien auf ein einziges Band zu sichern, stelle sicher, dass du 
nicht zur&uuml;ckspulst, sprich das richtige Ger&auml;t benutzt, ansonsten wirst du mit der zweiten Sicherung die erste &uuml;berschreiben,
usw. Du findest in der dump man page eine ausf&uuml;hrlichere Beschreibung.
</p>

<p>
Wenn du ein kleines Skript namens "backup" schreiben w&uuml;rdest, k&ouml;nnte es z.B. so aussehen:
</p>

<ul><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo                      
</ul></pre>

<p>
Wenn regelm&auml;ssige n&auml;chtliche Backups gefordert sind, k&ouml;nnte man <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&sektion=8&format=html">cron(8)</a> benutzen, um das Backup jede Nacht automatisch zu starten.
</p>

<p>
Es ist ausserdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie gro&szlig; jedes Dateisystem sein muss. Du kannst df -h benutzen,
um herauszufinden, wieviel Platz jede Partition momentan verbraucht. Das ist dann n&uuml;tzlich ,wenn eine Platte versagt, und
du die Partitionstabelle auf der neuen Platte wieder erstellen musst.
</p>

<p>
Deine Daten wiederherzustellen hilft ausserdem noch gegen Fragmentierung. Der beste Weg, um sicherzustellen, dass du alle Dateien erwischst, 
ist es, im Single-User-Mode zu booten. Dateisysteme m&uuml;ssen nicht gemountet werden, um gesichert zu werden. Vergiss aber nicht root (/)
zu mounten, denn sonst wird dein dump versagen, wenn er versucht Dumpdaten zu schreiben. Gib einfach bsd -s am Boot-Prompt ein, um in
den Single-User-Modus zu kommen.
</p>

<h3>Den Inhalt eines dump Bandes ansehen:</h3>


<p>
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es sicher eine gute Idee dein Band zu testen und sicherzustellen,
dass es auch die Daten enth&auml;lt, die darauf sein sollen.
</p>

<p>
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien auf einem 'dump' Band zu bekommen:
</p>

<ul><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</ul></pre>

<p>
Das listet die Dateien auf der 1. Partition auf dem dump Band (dem Sicherungsband) auf. Wie in den Beispielen weiter oben, ist 1 
dein root (/) Dateisystem.
</p>

<p>
Um den Inhalt der zweiten Partition zu sehen und die Ausgabe in eine Datei umzulenken, w&uuml;rde man z.B. solch ein Kommando 
benutzen:
</p>

<ul><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</ul></pre>

<p>
Wenn du eine mount-Tabelle wie die oben aufgef&uuml;hrte hast, w&auml;re 2 /usr, wenn deine aber etwas gr&ouml;sser w&auml;re, k&ouml;nnte
2 auch /var sein oder irgendwas anderes. Die Sequenznummer ist auf jeden Fall die gleiche Reihenfolge, in der das Dateisystem auf Band 
gesichert wird.
</p>


<h3>Wiederherstellen vom Band:</h3>

<p>
Das Beispielszenario w&auml;re sinnvoll, wenn deine eigentliche Festplatte komplett ausgefallen w&auml;re. Falls du aber nur eine einzige 
Datei wieder herstellen willst, sieh dir die restore man page genau an, und achte besonders auf die Anweisungen zum interaktiven Modus.
</p>

<p>
Wenn du gut vorbereitet bist, kann der Prozess des Ersetzens einer Festplatte sehr schnell von statten gehen. Die Standard OpenBSD 
install/boot floppy enth&auml;lt bereits das ben&ouml;tigte restore Werkzeug, genauso wie die ausf&uuml;hrbaren Dateien, um neue Partitionen
zu erstellen, und deine Festplatte bootbar zu machen. In den meisten F&auml;llen sind diese Floppy und dein Sicherungsband alles, was
du brauchst, um wieder alles betriebsbereit zu bekommen.
</p>

<p>
Nachdem du das kaputte Laufwerk physikalisch ersetzt hast, sind die grundlegenden Schritte zur Wiederherstellung folgende:
</p>

<ul>
<li>
<p>
Boote von der OpenBSD install/boot floppy. An der Men&uuml;auswahl w&auml;hle Shell. Nimm dein neuestes und schreibgesch&uuml;tztes
Band und packe es in dein Laufwerk.
<br>
</p>

<li>
<p>
Benutze das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> Kommando, um eine prim&auml;re
OpenBSD Partition auf dieser neu installierten Festplatte zu erzeugen. Z.B.:
</p>

<ul><pre>
shell# <b>fdisk -e sd0</b>
</ul></pre>

<p>
Sieh einfach in die <a href="#14.2">fdisk FAQ</a> um genaueres zu erfahren.
</p>

<li>
<p>  
Mit dem disklabel Kommando stellst du dann deine OpenBSD Partitionstabelle in der prim&auml;ren OpenBSD Partition wieder her, die du gerade 
mit fdisk erzeugt hast. Z.B.:
</p>

<ul><pre>
shell# <b>disklabel -E sd0</b>
</ul></pre>

<p>
(Vergiss den swap nicht, siehe dazu die <a href="#14.1">disklabel FAQ</a>)
</p>

<li>
<p>
Benutze das newfs Kommando, um ein neues sauberes Dateisystem auf jeder Partition zu erstellen, die du mit dem oben aufgef&uuml;hrten 
Schritt erstellt hast. Z.B.:
</p>

<ul><pre>
shell# <b>newfs /dev/rsd0a</b>
shell# <b>newfs /dev/rsd0h</b>
</ul></pre>

<li>
<p>
Mounte dein neu vorbereitetes root (/) Dateisystem auf /mnt. Beispiel:
</p>

<ul><pre>
shell# <b>mount /dev/sd0a /mnt</b>
</ul></pre>

<li>
<p>
Gehe in das gemountete root Dateisystem und beginne mit dem restore Prozess. Beispiel: 
</p>

<ul><pre>
shell# <b>cd /mnt</b>
shell# <b>restore -rs 1 -f /dev/rst0</b>
</ul></pre>

<li>
<p>
Wenn die Platte bootbar sein soll, schreibe mit dem folgenden Befehl einen neuen MBR auf deine Festplatte:
</p>

<ul><pre>
shell# <b>fdisk -i sd0</b>
</ul></pre>

<li>
<p>
Zus&auml;tzlich zum Schreiben eines neuen MBR musst du boot blocks installieren, um davon booten zu k&ouml;nnen.
Das folgende ist ein kurzes Beispiel:
</p>

<ul><pre>
shell# <b>cp /usr/mdec/boot /mnt/boot</b>
shell# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</ul></pre>

<li>
<p>
Dein neues root Dateisystem auf der eingebauten Festplatte sollte jetzt fertig sein, so dass du davon booten kannst und damit beginnen
kannst, den Rest der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht komplett ist, solltest du alles im single-User Modus
wiederherstellen. Am shell prompt benutze die folgende Kommandos, um deine Festplatten "abzumelden" (umount) und das
System anzuhalten:
</p>

<ul><pre>
shell# <b>umount /mnt</b>
shell# <b>halt</b>
</ul></pre>

<li>
<p>
Entferne die Install/boot floppy aus dem Laufwerk und reboote dein System. Am OpenBSD boot&gt; prompt benutze das folgende Kommando:
</p>

<ul><pre>
boot&gt; <b>bsd -s</b>
</ul></pre>

<p>
Das bsd -s f&uuml;hrt dazu, dass der Kernel im Single-User-Modus gestartet wird, der nur ein root (/) Dateisystem braucht.
</p>

<li>
<p>
Unter der Annahme, das du die obigen Schritte  richtig ausgf&uuml;hrt hast und nichts schief gegangen ist, solltest du von einem Prompt begr&uuml;sst
werden, der dich nach einem Pfad zu einer Shell fragt, oder du sollst Return dr&uuml;cken. Dr&uuml;cke return, um die sh zu benutzen.
Als n&auml;chstes willst du sicher root im r/w Modus (Schreib/Lese) remounten, und nicht mehr im Nur-Lese-Modus benutzen (ro)
Dazu benutze folgendes: 
</p>

<ul><pre>
shell# <b>mount -u -w /</b>
</ul></pre>

<li>
<p>
Sobald du im r/w Modus remountet hast, kannst du fortfahren deine restlichen Dateisysteme wiederherzustellen. Beispiel:
</p>

<ul><pre>
(einfache mount Tabelle)
shell# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(etwas umfassendere mount Tabelle)
shell#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</ul></pre>

<p>
Benutze "<b>restore rvsf</b>" anstatt eines einfachen rsf um die Namen von Objekten zu sehen, w&auml;hrend sie vom dump set
ausgepackt werden.
</p>

<li>
<p>
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme wiederhergestellt hast, f&uuml;hre einen reboot in den Multi-User-Modus durch.
Wenn alles geklappt hat, sollte dein Sytem wieder genauso sein, wie zum Zeitpunkt deiner letzten Sicherung und wieder normal zu benutzen.
</p>
</ul>

<p>

<a name=14.10></a>
<h2>14.10 - Disk mages in OpenBSD mounten</h2>
</p>

<p>
Um ein Disk Image (ISO images, Disk images, die mit  dd erstellt wurden, etc) in OpenBSD
zu moutnen, musst du ein <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&sektion=4">vnd(4)</a> Device/Ger&auml;t konfigurieren. 
Zum Beispiel, wenn du ein ISO Image unter <i>/tmp/ISO.image</i> hast, w&uuml;rdest du die folgenden Schritte machen, um es zu mounten:
</p>

<ul>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <strong>vnconfig svnd0 /tmp/ISO.image</strong>
# <strong>mount -t cd9660 /dev/svnd0c /mnt</strong>
</pre>
                </td>
        </tr>
</table>
</ul>

<p>
Bedenke bitte, da&szlig; du den Typ <i>cd9660</i> angeben musst, wenn es eine CD ist. Das gilt aber auch f&uuml;r Das gilt aber auch f&uuml;r die 
anderen Typen, also musst du z.B. ffs beim mounten eines disk images angeben. 
</p>

<p>
Um das Image wieder 'unzumounten' benutze die folgenden Kommandos:
</p>

<ul>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <strong>umount /mnt</strong>
# <strong>vnconfig -u svnd0</strong>
</pre>
                </td>
        </tr>
</table>
</ul>

<p>
Mehr Informationen gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8">vnconfig(8)</a> man page.
</p>

<p>
<font color= "#0000e0">
<a href= "index.html">[Zur&uuml;ck zu Haupt-Index]</a>
<a href= "../faq13.html">[Zu Sektion 13.0 - IPsec]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small> 
Originally [OpenBSD: faq14.html,v 1.35 ]
<br>
$Translation: faq14.html,v 1.4 2001/03/07 21:28:28 jufi Exp $
<br></small>
<small>$OpenBSD: faq14.html,v 1.3 2001/03/07 21:31:05 jufi Exp $</small>
</p>
</body>
</html>
