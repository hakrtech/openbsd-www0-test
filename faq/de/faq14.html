<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Platteneinrichtung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2005.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="de">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq13.html">[Zum Kapitel 13 - Multimedia]</a>
<a href= "faq15.html">[Zum Kapitel 15 - Packages und Ports]</a>
</font>

<h1><font color="#e00000">14 - Platteneinrichtung</font></h1><hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Benutzung von OpenBSDs disklabel(8)</a>
<li><a href="#fdisk"      >14.2 - Benutzung von OpenBSDs fdisk(8)</a>
<li><a href="#NewDisk"    >14.3 - Hinzufügen von weiteren Festplatten unter
    OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - Wie man in eine Datei swappt</a>
<li><a href="#SoftUpdates">14.5 - Softupdates</a>
<li><a href="#Boot386"    >14.6 - Wie bootet OpenBSD/i386?</a>
<li><a href="#LargeDrive" >14.7 - Welche Probleme treten bei großen
    Festplatten mit OpenBSD auf?</a>
<li><a href="#InstBoot"   >14.8 - Installieren von Bootblocks -
    i386-spezifisch</a>
<li><a href="#Backup"     >14.9 - Sich auf das Schlimmste vorbereiten:
    Backups und Wiederherstellen von Band.</a>
<li><a href="#MountImage" >14.10 - Diskimages unter OpenBSD mounten</a>
<li><a href="#pciideErr"  >14.11 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</a>
<li><a href="#RAID"       >14.13 - RAID-Optionen unter OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich
    mehr als 100&nbsp;% von meiner Platte belegt habe?</a>
<li><a href="#OhBugger"   >14.15 - Partitionen wiederherstellen, nachdem
    das Disklabel gelöscht wurde</a>
<li><a href="#foreignfs"  >14.16 - Kann ich auf Daten zugreifen, die auf
    anderen Dateisystemen als FFS liegen?</a>
<ul>
  <li><a href="#foreignfsafter">14.16.1 - Die Partitionen befinden sich
      nicht in meinem Disklabel! Was kann ich tun?</a>
</ul>
<li><a href="#flashmem"   >14.17 - Kann ich ein Gerät mit Flashspeicher
    unter OpenBSD benutzen?</a>

</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Benutzung von OpenBSDs disklabel(8)</h2>
<h3>Inhaltsverzeichnis</h3>

<ul>
<li><a href="#disklabel.1">Was ist disklabel(8)?</a>
<li><a href="#disklabel.2">disklabel(8) während der OpenBSD-Installation</a>
<li><a href="#disklabel.3">Gebräuchliche Verwendungen von disklabel(8).</a>
</ul>

   
<a name="disklabel.1"></a>
<h3>Was ist disklabel(8)?</h3>
  
<p>
Lies zunächst die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>-Manualseite.

<p>
Disklabels werden erzeugt, um ein effizientes Interface zwischen deiner
Festplatte und den Festplattentreibern zu erzeugen, die im Kernel
enthalten sind. Labels enthalten bestimmte Informationen über deine
Festplatte, wie z.&nbsp;B. die Plattengeometrie und Informationen über
deine Dateisysteme. Dies wird dann vom Bootstrapprogramm benutzt, um die
Festplatte zu laden und zu wissen, wo auf der Platte die Dateisysteme
sind. Labels werden auch zusammen mit den Dateisystemen benutzt, um eine
effizientere Umgebung zu erzeugen. Tiefergehende Informationen über
disklabel gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>-Manualseite.

<p>
Zusätzlich führt die Benutzung von disklabel zur Überwindung
der Architekturgrenzen beim Partitionieren von Festplatten. Auf i386
kann man z.&nbsp;B. nur 4 primäre Partitionen haben (Partitionen, so
wie sie andere Betriebssysteme wie Windows NT oder DOS sehen). Mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
benutzt du eine dieser primären Partitionen, die dann *alle* deine
OpenBSD-Partitionen enthält (z.&nbsp;B. »swap«, »/«, »/usr« und »/var«).
Und du hast noch 3 weitere für andere Betriebssysteme übrig!

<a name="disklabel.2"></a>
<h3>disklabel(8) während der OpenBSD-Installation</h3>

<p>
Einer der Hauptteile der OpenBSD-Installation ist das erstmalige Erzeugen
der Labels. Das kommt (für i386-Benutzer) direkt nach der Benutzung von
<a href="#fdisk">fdisk(8)</a>.
Während der Installation benutzt du disklabel, um deine separaten Labels
zu erzeugen, die deine separaten Mountpoints enthalten. Während der
Installation kannst du mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a> 
deine Mountpoints setzen. Das ist aber eigentlich nicht nötig, da du
deine Änderungen später sowieso bestätigen musst. Aber es macht deine
Installation schon etwas geradliniger.

<p>
Da das während der Installation geschieht, hast du noch keine
funktionierenden Labels und sie müssen erst erzeugt werden. Das erste
Label, das du erzeugst, ist das Label a. Das SOLLTE das Label sein, auf
dem dann / gemountet wird. Die empfohlenen Partitionen und ihren Größen
kannst du dir unter <a href="faq4.html#SpaceNeeded">FAQ4, Wieviel Platz
brauche ich für eine OpenBSD-Installation?</a> ansehen. Für Server wird
empfohlen, zumindest diese Labels separat zu halten. Für Desktopanwender
reicht vermutlich ein einzelner Mountpoint /. Wenn du deine
root-Partition (,a' Label)
erzeugst, denk dran, dass du in jedem Fall noch ETWAS Platz für dein
Swap Label benötigst. Jetzt kennst du die Grundlagen und daher geben wir
hier jetzt mal ein Beispiel für das Benutzen von disklabel. In diesem
ersten Beispiel wird angenommen, dass OpenBSD das einzige Betriebssystem
auf diesem Computer ist und eine vollständige Installation gemacht
wird.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
An diesem Punkt angekommen hast du eine 64 MB große root-Partition, die
mit / gemountet wird, und eine 64 Meg Swappartition erzeugt. In diesem
Fall beginnt der Offset bei Sektor 63. So willst du es haben. Wenn es
bei der Größe angekommen ist, wird dir Disklabel die Größen in Sektoren
angeben; du musst aber die Größen nicht ebenfalls im gleichen Format
eingeben. Wie im Beispiel oben kannst du Größen zum Beispiel so
eingeben: <i>64 Megabytes = 64M</i> und <i>2 Gigabytes = 2G</i>.
Disklabel wird dann einfach auf den naheliegendsten Zylinder runden. Im
obigen Beispiel kann man auch sehen, dass disklabel annimmt, dass Label
b Swapbereich sein wird. Das ist eine korrekte Annahme, da im
GENERIC-Kernel Swap auf Label b festgelegt ist. Du solltest daher
dieser Richtlinie ebenfalls folgen und b als Swapbereich benutzen. 

<p>
Das nächste Beispiel wird dich durch die Erzeugung zweier weiterer
Labels führen. Im Übrigen kann das keine komplette Installation sein, da
die Größe dieser beiden Partitionen nicht ausreicht, um OpenBSD komplett
zu installieren. Das Erzeugen dieser ganzen Partitionen dient nur zur
Wiederholung und Vertiefung. 

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
Im obigen Beispiel fallen dir vermutlich zwei Dinge auf. Zum einen, dass
der Offset, der als nächstes an der Reihe ist, automatisch für dich
errechnet wird; wenn du eine solche Installation machst, musst du dich
mit dem Ändern der Offsets nicht herumschlagen. Zum anderen, dass das
Label c übersprungen wurde. Das ist aber Absicht, und zwar deshalb, weil
Label c die ganze Festplatte repräsentiert. Aus diesem Grund solltest du
Label c vollkommen in Ruhe lassen.

<p>
Sind deine Label erst einmal alle erzeugt, ist alles, was noch nötig ist,
die Label auf die Festplatte zu schreiben und einfach mit dem
Installationsprozess fortzufahren. Um alles zu schreiben und disklabel zu
beenden (und mit der Installation weiterzumachen), tippe Folgendes:

<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>

<a name="disklabel.3"></a>
<h3>Gebräuchliche Verwendungen von disklabel(8)</h3>

<p>
Wenn dein System erst einmal installiert ist, solltest du disklabel
nicht mehr allzuoft benutzen müssen. Aber du kannst es gebrauchen, wenn
du z.&nbsp;B. Festplatten hinzufügen, welche entfernen oder auch einfach
umstrukturieren möchtest. Eines der ersten Dinge, die du dann machst,
ist dir den momentanen gültigen Disklabel anzusehen. Und das geht so:

<pre>
# <b>disklabel wd0</b> &gt;----- Oder was du dir auch immer für eine Platte ansehen willst

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
Der obige Befehl zeigt dir einfach den existierenden Disklabel und stellt
sicher, dass du nichts kaputt machst oder durcheinanderbringst (was wir
alle von Zeit zu Zeit mal brauchen). Um aber Veränderungen durchzuführen,
musst du die Option -E wie folgt mit angeben:

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
Das wird dich an den gleichen Prompt bringen, den du schon während der
OpenBSD-Installation benutzt hast. Das wahrscheinlich wichtigste
Kommando an diesem Prompt ist ?. Das erzeugt nämlich eine Liste mit
möglichen Optionen für Disklabel. Mit Hilfe von M kannst du dir sogar
die gesamte 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>-Manualseite
ansehen. Von diesem Prompt aus wirst du dein gesamtes Hinzufügen,
Löschen und Ändern der Partitionen vornehmen. Zusätzliche Informationen
gibt es in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>-Manualseite.

<a name="fdisk"></a>
<h2>14.2 - Benutzung von OpenBSDs fdisk(8)</h2>
Um sicher zu sein, lies zuerst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Manualseite.

<p>
Das Programm fdisk dient dazu, bei der Wartung deiner Partitionen
zu helfen. Dieses Programm wird auch bei der Installation benutzt, um
deine OpenBSD-Partition einzurichten (diese Partition kann
<u>mehrere</u> Labels enthalten, jedes mit Dateisystemen/Swap/etc.). Es
kann den Platz auf deiner Festplatte aufteilen und eine Partition als
aktiv markieren. Dieses Programm wird für gewöhnlich im Singleuser-Modus
benutzt (boot -s). Der MBR wird auf deinen verschiedenen Festplatten von
fdisk gesetzt.

<p>
Für Installationszwecke braucht man meistens nur <b>EINE</b>
OpenBSD-Partition und benutzt dann disklabel, um Swap und Dateisysteme
darauf zu installieren.

<p>
Um dir nur deine Partitionstabelle mit fdisk anzugucken, verwende:

<pre># <b>fdisk fd0</b><br>
</pre>

<p>
Was dann eine ähnliche Ausgabe wie diese hier erzeugt:

<pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre>

<p>
In diesem Beispiel betrachten wir die Ausgabe des ersten
SCSI-Laufwerks. Wir können die OpenBSD-Partition (A6) und ihre Größe
sehen. Der * sagt uns, dass die OpenBSD-Partition eine bootfähige
Partition ist.

<p>
Im vorherigen Beispiel haben wir uns die Informationen nur angesehen.
Was aber, wenn wir unsere Partitionstabelle verändern wollen? Nun, dazu
müssen wir zunächst die Option <b>-e</b> benutzen. Diese bringt uns dann
zu einer Kommandozeile, die uns mit fdisk interagieren lässt.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt;
</pre>

<p> 
Es ist absolut sicher, in fdisk ein wenig rumzuwandern und zu probieren,
solange man auf die Frage, ob die Änderungen abgespeichert werden
sollen, mit <b>N</b> antwortet und das Kommando <b>write</b> *NICHT*
benutzt.

<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe
der Option <b>-e</b> benutzen kann.

<ul>
<li><b>help</b>  Zeigt eine Liste der Kommandos an, die fdisk im
interaktiven Editmodus versteht.
<li><b>reinit</b>  Initialisiert die momentane im Speicher befindliche
Kopie des Bootblocks.
<li><b>disk</b>  Zeigt die momentane Plattengeometrie an, die fdisk
ermittelt hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du
willst.
<li><b>setpid</b>  Ändert eine Partitionsidentifizierung des angegebenen
Partitionstabelleneintrages. Dieses Kommando ist insbesondere nützlich,
um eine existierende Partition OpenBSD wieder zugänglich zu machen.
<li><b>edit</b>  Ändere eine ausgewählte Plattengeometrie in der Kopie
des momentanen Bootblocks.  Das geschieht entweder im
BIOS-Geometriemodus oder in Sektoroffsets und -größen.
<li><b>flag</b>  Macht den jetzigen Partitionstabelleneintrag bootfähig.
Nur ein Eintrag kann gleichzeitig bootfähig sein. Wenn du von einer
erweiterten Partition booten willst, musst du auch den entsprechenden
Eintrag als bootfähig markieren.
<li><b>update</b>  Bringt den Maschinencode in der Speicherkopie des
momentanen Bootblocks auf den aktuellen Stand.
<li><b>select</b>  Wählt und lädt den Bootblock, auf den der Eintrag der
erweiterten Partitionstabelle im momentanen Bootblock zeigt.
<li><b>print</b>  Gibt die momentan im RAM befindliche und gewählte
Kopie des Bootblocks und seinen MBR auf dem Bildschirm aus.
<li><b>write</b>  Schreibt die RAM-Version des Bootblocks auf
die Platte. Du wirst um eine Bestätigung gebeten.
<li><b>exit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt.
<li><b>quit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt. Im Gegensatz zu exit schreibt diese
Variante den modifizierten Block auf die Platte.
<li><b>abort</b>  Verlässt das Programm ohne Änderungen zu speichern.
</ul>

<a name="NewDisk"></a>
<h2>14.3 - Hinzufügen von weiteren Festplatten unter OpenBSD</h2>

<p>
Nun, nachdem du deine Festplatte <b>ORDNUNGSGEMÄSS</b> eingebaut hast,
musst du 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>nur i386 </i>) und auch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
verwenden, um deine Festplatte unter OpenBSD benutzen zu können. 

<p>
Besitzer eines i386-Systems starten mit fdisk. Besitzer anderer
Architekturen können diesen Schritt einfach ignorieren. In dem Beispiel
weiter unten werden wir dem System ein drittes SCSI-Laufwerk hinzufügen.
<pre>
# <b>fdisk -i sd2</b>
</pre>
Das wird die »echte« Partitionstabelle der Festplatte für eine 
ausschließliche Benutzung von OpenBSD initialisieren. Als nächstes musst
du ein Disklabel dafür erzeugen. Das wird wohl etwas verwirrend wirken.
<pre>
# <b>disklabel -e sd2</b>

<i>(der Bildschirm wird leer, dein $EDITOR erscheint)</i>
type: SCSI
<i>... Bla ...</i>
sectors/track: 63
total sectors: 6185088
<i>... Bla ...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

Zunächst einmal ignoriere die Partition c - sie ist immer da und
Programme wie disklabel benötigen sie, um zu funktionieren!
Für OpenBSD ist fstype 4.2BSD. Die gesamte Größe der Festplatte ist
wird unter total sectors angegeben. Nehmen wir an, es handelt sich um
eine 3 Gigabyte große Festplatte. Drei Gigabytes in der Sprache der
Festplattenhersteller sind 3000 Megabytes.  Dividiere also
6185088 mit 3000 (benutze
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1))</a>.
Du erhältst 2061. Um jetzt Partitionsgrößen für a, d, e, f, g, ... zu
erstellen, rechne einfach X * 2061, um X Megabytes Platz auf dieser
Partition zu erhalten. Der Offset für deine erste Partition sollte
derselbe sein, wie unter sectors/track vorher in disklabels Ausgabe
angegeben. Bei uns ist es 63. Der Offset für jede Partition ist
hinterher eine Kombination aus der Größe und dem Offset jeder anderen
Partition (mit Ausnahme der Partition c, da sie keine Rolle in dieser
Gleichung spielt).

<p>
Wenn du aber nur eine Partition auf deiner Festplatte brauchst, zum
Beispiel, wenn du das ganze Ding nur zum Ablegen von Webseiten oder
einem Heimatverzeichnis oder etwas anderem nutzen willst, nimm einfach
die gesamte Größe der Platte und ziehe die Sektoren pro Spur davon ab:
6185088 - 63 = 6185025.  Deine Partition ist:

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>Wenn dir das alles unnötig komplex erscheint, kannst du disklabel -E
benutzten, um den selben Patitionierungsmodus zu erhalten, den du auf
deiner Installationsdisk hattest!</b>
Dort kannst du 96M benutzen, um 96 Megabytes anzugeben.  (Oder, wenn
deine Festplatte groß genug ist, 96G für 96 Gigabytes!)
Unglücklicherweise benutzt der Modus -E die BIOS-Plattengeometrie und
nicht die reale - oft sind die beiden nicht deckungsgleich. Um dieses
Problem zu umgehen, tippe »g d« für »geometry disk«. (Andere
Möglichkeiten sind »g b« für »Geometry BIOS« und »g u« für »geometry
user« oder einfach das, was das Label gesagt hat, bevor disklabel
irgendwelche Änderungen gemacht hat.)

<p>
Das war eine Menge. Aber du bist noch nicht fertig. Zuletzt musst du
noch das Dateisystem auf der Festplatte mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
anlegen.

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
Oder wie auch immer deine Festplatte nach dem
OpenBSD-Plattennummerierungsschema heißen mag. (Siehe einfach in der
Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
nach, um zu sehen, wie die Platte von OpenBSD benannt wurde.)

<p>
Nun überleg dir, wohin du deine gerade neu geschaffene Partition mounten
willst. Sagen wir einfach mal /u. Erzeuge zunächst erstmal /u. Dann
mounte sie.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Zuletzt musst du sie noch zur
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
hinzufügen.

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
Was aber, wenn du ein existierendes Verzeichnis wie zum Beispiel
/usr/local auslagern willst? Mounte die neue Platte unter /mnt und
benutze <tt>cpio -pdum</tt>, um /usr/local in das Verzeichnis /mnt zu
kopieren. Passe die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
so an, dass die /usr/local-Partition nun /dev/wd1a ist (deine frisch
formatierte Partition). Beispiel:

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Starte in den Singleuser-Modus mit <b>boot -s</b> neu, verschiebe
das existierende /usr/local nach /usr/local-backup (oder lösche es
gleich, wenn du mutig bist) und lege ein leeres Verzeichnis namens
/usr/local an. Starte dann das System neu und voila: die Dateien sind
da!


<a name="SwapFile"></a>
<h2>14.4 - Wie man in eine Datei swappt</h2>

<p>
(Hinweis: wenn du in eine Datei swappen willst, weil du immer 
»virtual memory exhausted«-Fehler bekommst, solltest du lieber
versuchen, deine Begrenzungen auf Prozessebene mittels
cshs <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>
oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>
zu erhöhen.)

<p>
In eine Datei zu swappen benötigt keinen angepassten Kernel, obwohl das
weiterhin gemacht werden könnte, zeigt dir diese FAQ, wie man den
Swapbereich auf beide Arten hinzufügen kann.

<h3>In eine Datei swappen.</h3>

<p>
In eine Datei zu swappen ist der einfachste und schnellste Weg, um 
zusätzlichen Swap zu bekommen. Die Datei darf aber nicht auf einem
Dateisystem mit Softupdates liegen (was ja standardmäßig deaktiviert
ist). Finde zunächst einmal heraus, wieviel Swap du momentan hast
und wieviel du davon benutzt. Das geht mit dem Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
recht einfach. Zum Beispiel mit diesem Aufruf:

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
Das zeigt sowohl alle Geräte, die momentan für das Swappen benutzt
werden, als auch ihre momentane Statistik an. Im obigen Beispiel gibt es
nur ein Gerät namens swap_device. Das ist der vordefinierte Bereich auf
der Platte, der für das Swappen benutzt wird (wird im Übrigen als
Partition b bei Disklabels angezeigt). Wie du auch sehen kannst, wird
das Gerät zur Zeit nicht sonderlich belastet oder vielmehr benutzt.
Aber für den Zweck dieses Dokumentes tun wir einfach so, als wenn noch
weitere 32 MB benötigt werden würden.

<p>
Der erste Schritt, um eine Datei als Swapbereich zu nutzen, ist die
Datei zu erzeugen. Am besten macht man das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Hier ist ein Beispiel, das die 32 M große Datei <i>/var/swap</i>
erzeugt.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Nachdem das erledigt ist, können wir jetzt das Swappen auf dieses Device
richten. Benutze einfach das folgende Kommando, um das Swappen auf
dieses Device zu lenken:

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
Jetzt müssen wir noch prüfen, ob sie auch korrekt zu unserer Liste der
Swapdevices hinzugefügt wurde.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Jetzt, da die Datei erzeugt wurde und in sie hinein geswappt wird, musst
du noch eine Zeile in deine <i>/etc/fstab</i> hineinschreiben, so
dass die Datei beim nächsten Booten auch benutzt wird. Wenn diese Zeile
nicht hinzugefügt wird, wird dieses Swapdevice nicht konfiguriert.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>Swappen über ein vnode-device</h3>

<p>
Dies ist eine dauerhaftere Lösung, um mehr Swapbereich zu erhalten.
Um in eine Datei zu swappen, erzeuge zunächst einen Kernel mit vnd0c als
Swap. Wenn du wd0a als root-Dateisystem hast und wd0b als bisherigen
Swap, benutze diese Zeile in deiner Kernelkonfigurationsdatei (wenn du
dir nicht sicher bist, siehe dir das Kapitel »Einen neuen Kernel
kompilieren« in dieser FAQ an): 

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
Nachdem das erledigt ist, muss die Datei erzeugt werden, in die geswappt
werden soll. Du solltest dies mit dem selben Kommando wie in den
vorherigen Beispielen machen.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Da deine Datei jetzt an ihrem Platz ist, musst du die Datei in deine
<i>/etc/fstab</i> eintragen. Hier ist eine Beispielzeile, mit der man
dieses Device beim Booten als Swap benutzt.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
An diesem Punkt angekommen musst du deinen Computer neustarten, so dass
die Änderungen am Kernel Effekt haben. Nachdem das passiert ist, ist es
an der Zeit, das Device als Swap zu konfigurieren. Dazu wirst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
benutzen.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
Als letzten Schritt musst du den Swap auf diesem Gerät noch einschalten.
Wir machen das genau wie in dem Beispiel oben mit swapctl(8). Und zuletzt
prüfen wir wieder, ob es auch korrekt in unsere Liste der Swapdevices
eingetragen wurde. 

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name="SoftUpdates"></a>
<h2>14.5 - Softupdates</h2>


<p>
Softupdates basieren auf einer Idee, die von
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg&nbsp;Ganger
und Yale&nbsp;Patt</a> vorgeschlagen wurde, und wurden für FreeBSD von
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a> entwickelt.
Softupdates erzwingen eine gewisse Reihenfolge der
Buffercacheoperationen, was die Anforderungen für das Entfernen des
FFS-Codes ermöglicht, der für das synchrone Schreiben von
Verzeichniseinträgen zuständig ist. Daher konnte ein großer
Geschwindigkeitsanwachs in der Leistung der Schreibzugriffe auf Platten
festgestellt werden.

<p>
Um Softupdates aktivieren zu können, muss in deinen Kernel

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
einkompiliert sein. In GENERIC ist dies bereits der Fall.

<p>
Die Aktivierung von Softupdates muss mit einer Option während dem
Mounten ausgeführt werden. Wenn eine Partition mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
gemountet wird, kannst du angeben, dass du Softupdates auf dieser
Partition aktivieren möchtest. Dies ist ein Beispieleintrag für
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i>,
der eine Partition <i>sd0a</i> auflistet, die wir mit Softupdates
gemountet haben möchten.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Hinweis für Sparc-Anwender: Aktiviere Softupdates nicht auf sun4- oder
sun4c-Maschinen. Diese Architekturen unterstützen nur eine sehr
begrenzte Menge an Kernelspeicher und können diese Funktion nicht
verwenden. Trotzdem sind sun4m-Maschinen in Ordnung.

<a name="Boot386"></a>
<h2>14.6 - Wie bootet OpenBSD/i386?</h2>
Der Bootprozess für OpenBSD/i386 ist nicht einfach und verstehen, wie es
funktioniert, kann nützlich sein, um ein Problem zu lösen, wenn Dinge
nicht laufen. Während dem Bootprozess gibt es vier Schlüsselereignisse:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> Der Master Boot Record ist
der erste physikalische Sektor (512 Bytes) auf der Platte. Er beinhaltet
die primäre Partitionstabelle und ein kleines Programm, um den Partition
Boot Record (PBR) zu laden. Bedenke, dass in einigen Umgebungen der
Begriff MBR verwendet wird, um nur auf den Codeteil dieses ersten Blocks
auf der Platte zu verweisen, statt auf den gesamten ersten Block
(einschließlich der Partitionstabelle). Es ist äußerst wichtig, die
Bedeutung von »initialize the MBR« zu verstehen - in der Terminologie
von OpenBSD würde es den gesamten MBR-Sektor neu schreiben, nicht nur
den Code, so wie es auf anderen Systemen der Fall sein könnte. Du wirst
das nur selten machen wollen. Verwende stattdessen fdisk(8)s
Kommandozeilenoption -u (»<tt>fdisk -u wd0</tt>«).

<p>
Obwohl OpenBSD einen MBR beinhaltet, wirst du nicht gezwungen, ihn zu
verwenden, da so gut wie jeder MBR OpenBSD booten kann. Der MBR wird von
dem Programm fdisk(8) verändert, welches verwendet wird, um die
Partitionstabelle zu editieren und um ebenfalls den MBR-Code auf die
Platte zu schreiben.

<p>
OpenBSDs MBR kündigt sich selbst mit der Meldung an:
<pre>
    Using drive 0, partition 3.
</pre>
die die Platte und Partition anzeigt, von der er den PBR laden wird.
Zusätzlich zu dem Offensichtlichen, zeigt er ebenfalls einen angehängten
Punkt ("."), welcher darauf deutet, dass diese Maschine in der Lage ist,
LBA-Übersetzung zum Booten zu verwenden. Wenn die Maschine nicht in der
Lage ist, LBA-Übersetzung zu verwenden, wäre der obige Punkt mit einem
Semikolon (»;«) ausgewechselt worden, das auf CHS-Übersetzung deutet:
<pre>
    Using Drive 0, Partition 3;
</pre>
Bedenke, dass der angehängte Punkt oder das angehängte Semikolon als ein
Indikator für den neuen OpenBSD-MBR angesehen werden kann, der mit
OpenBSD 3.5 eingeführt wurde.

<li><b><i>Partition Boot Record (PBR):</i></b>
Der Partition Boot Record, auch der PBR oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
genannt wird (benannt nach dem Namen der Datei, der den Code
beinhaltet), ist der erste physikalische Sektor der OpenBSD-Partition
auf der Platte. Der PBR ist der Firststage-Bootloader für OpenBSD.
Er wird vom MBR-Code geladen und hat die Aufgabe, OpenBSDs
Secondstage-Bootloader
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
zu laden.
Wie der MBR ist auch der PBR eine sehr kleine Sektion von Code und Daten
- insgesamt nur 512 Bytes. Das ist nicht genug, um eine vollständig
dateisystembewusste Applikation zu laden, so dass, statt den PBR
<tt>/boot</tt> auf der Platte ausfindig machen zu lassen, die
BIOS-verfügbare Stelle von <tt>/boot</tt> physikalisch in den PBR
während der Installation eingetragen wird.

<p>
Der PBR wird von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>
installiert, das
<a href="faq14.html#InstBoot">später in diesem Dokument</a> genauer
beschrieben wird.
Der PBR kündigt sich selbst mit der Meldung an:
<pre>
    Loading...
</pre>
die einen Punkt für jeden Dateisystemblock anzeigt, den er versucht
auszulesen. Ebenfalls zeigt der PBR an, ob er LBA oder CHS zum Laden
verwendet - wenn er CHS-Übersetzung verwendet, zeigt er eine Nachricht
mit einem Semikolon an:
<pre>
    Loading;...
</pre>
Das ältere (vor v3.5) biosboot(8) zeigte die Nachricht »<tt>reading
boot...</tt>« an.

<li><b><i>Secondstage-Bootloader, <tt>/boot</tt>:</i></b> <tt>/boot</tt>
wird vom PBR geladen und hat die Aufgabe, auf das OpenBSD-Dateisystem
durch das BIOS der Maschine zuzugreifen und den aktuellen Kernel
ausfindig zu machen und zu laden. boot(8) übergibt ebenfalls
verschiedene Optionen und Informationen an den Kernel.
<p>
boot(8) ist ein interaktives Programm. Nachdem es geladen ist versucht
es, <tt>/etc/boot.conf</tt> ausfindig zu machen und zu laden, wenn sie
existiert (was auf einer standardmäßigen Installation nicht der Fall
sein muss) und verarbeitet sämtliche Kommandos in ihr. Wenn es durch
<tt>/etc/boot.conf</tt> nicht anders angeordnet wurde, gibt es dem
Benutzer einen Prompt aus:

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.10
     boot>
</pre>
Es gibt dem Benutzer (standardmäßig) fünf Sekunden lang die Möglichkeit,
andere Aufgaben auszuführen, aber wenn keine vor dem Ablauf der Zeit
eingegeben wurde, startet es sein normales Verhalten: den Kernel
<tt>bsd</tt> von der root-Partition der ersten Festplatte laden.
Der Secondstage-Bootloader untersucht deine Systemhardware durch das
BIOS (da der OpenBSD-Kernel noch nicht geladen ist). Oben kannst du ein
paar Dinge sehen, die er gesucht und gefunden hat:
<ul>
<li><b>pc0</b> - Die Standardtastatur und -bildschirmausgabe eines
i386-Systems.
<li><b>com0, com1</b> - Zwei serielle Schnittstellen
<li><b>apm</b> - »Advanced Power Management«-BIOS-Funktionen
<li><b>636k 190M</b> - Die Menge vom herkömmlichen (unterhalb von 1 M)
und erweiterten (überhalb von 1 M) Speicher, den er gefunden hat
<li><b>fd0 hd0+</b> - Die BIOS-Laufwerke, die er gefunden hat: in diesem
Fall ein Disketten- und ein Festplattenlaufwerk.
</ul>

Das »+«-Zeichen nach hd0 zeigt an, dass das BIOS <tt>/boot</tt>
mitgeteilt hat, dass diese Festplatte über LBA angesprochen werden kann.
Wenn eine erstmalige Installation ausgeführt wird, siehst du ab und zu
einen * nach einer Festplatte - dies deutet auf eine Platte hin, die so
scheint, als wenn sie kein OpenBSD-Disklabel beinhaltet.

<li><b><i>Kernel: <tt>/bsd</tt></i>:</b> Dies ist das Ziel des
Bootprozesses: den OpenBSD Kernel in den RAM laden und sauber
auszuführen.  Wenn der Kernel einmal geladen wurde, kann OpenBSD direkt
auf die Hardware zugreifen, nicht mehr durch das BIOS.

</ol>

So, der Anfang vom Start des Bootprozesses könnte wie folgt aussehen:
<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.10
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2005 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.8 (GENERIC) #138: Sat Sep 10 15:41:37 MDT 2005
   ...
</pre></blockquote>


<h3>Was fehlschlagen kann</h3>
<ul>
<li><b>Beschädigter/ungültiger/inkompatibler MBR:</b>
Normalerweise hat eine gebrauchte Festplatte irgendeinen MBR-Code
installiert, aber wenn die Platte neu ist oder von einer anderen
Plattform übernommen wurde UND du nicht mit Yes auf die Frage »Use
entire disk« Frage vom
<a href="faq4.html#Disks">Installationsprozess</a> geantwortet hast,
kann es sein, dass du mit einer Platte ohne gültigem MBR da stehst und
daher nicht in der Lage sein wirst zu booten, obwohl sie eine gültige
Partitionstabelle hat.

<p>
Du kannst den OpenBSD-MBR auf deine Festplatte unter Verwendung vom
Programm fdisk installieren. Boote dein Installationsmedium und wähle
Shell aus, um auf den Kommandoprompt zu gelangen:

<pre>
    # <b>fdisk -u wd0</b>
</pre>

Du kannst auch einen bestimmten MBR auf deine Platte mit fdisk
schreiben:
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre>

Hiermit wird die Datei <tt>/usr/mdec/mbr</tt> als dein System-MBR
installiert. Diese bestimmte Datei einer standardmäßigen
OpenBSD-Installation ist ebenfalls der standardmäßige MBR, der in
fdisk integriert wurde. Es könnte aber jeder andere MBR hier angegeben
werden.

<li><b>Ungültige <tt>/boot</tt>-Ortsangabe im PBR installiert:</b>
Wenn installboot(8) den Partition Boot Record installiert, schreibt er
die Blocknummer und den Offset von <tt>/boot</tt>s Inode in den PBR.
Daher wird das Löschen oder Ersetzen von <tt>/boot</tt> ohne
erneutes Ausführen von <a href="faq14.html#InstBoot">installboot(8)</a>
dein System in einen Zustand versetzen, in dem es nicht mehr booten
kann, da der PBR laden wird, auf was auch immer die Inode zeigt, die
angegeben wurde. Das wird vermutlich nicht mehr der erhoffte
Secondstage-Bootloader sein!

Seit <tt>/boot</tt> unter Verwendung von BIOS-Aufrufen ausgelesen wird,
waren ältere Versionen vom PBR sehr sensibel auf
BIOS-Plattenübersetzungen. Wenn du die Plattengeometrie (z.&nbsp;B.
wenn du die Platte aus einem Computer genommen hast, der
CHS-Übersetzung verwendet hat, und es in einen steckst, der
LBA-Übersetzung verwendet oder sogar die Übersetzungsoption im BIOS
geändert hast) geändert hast, wird es <i>für das BIOS so wirken</i>, als
wenn sie an einem anderen Ort liegen würde (es muss auf einen anderen
nummerischen Block zugegriffen werden, um die gleichen Daten von der
Platte zu erhalten), so dass du installboot(8) erneut ausführen musst,
bevor das System neugestartet werden kann. Der neue (von OpenBSD 3.5 und
später) PBR ist sehr viel tolleranter im Bezug auf Übersetzungsänderungen.
</ul>

Da der PBR sehr klein ist, ist die Anzahl von Fehlermeldungen sehr
begrenzt und recht kryptisch. Typische Nachrichten sind:

<ul>
<li><b>ERR R</b> - Das BIOS gab einen Fehler zurück als es versucht hat,
einen Block von der Platte zu lesen.
Es bedeutet meistens genau das, was es aussagt: von deiner Platte konnte
nicht gelesen werden.
<li><b>ERR M</b> - Eine ungültige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>-Nummer
wurde aus dem Header des Secondstage-Bootloaders gelesen. Dies bedeutet
normalerweise, dass, was auch immer eingelesen wurde, NICHT
<tt>/boot</tt> war, was darauf hinweist, dass installboot(8) nicht
korrekt ausgeführt wurde, die /boot-Datei geändert wurde oder du die
Fähigkeit deines BIOS erschöpft hast, um von einer
<a href="#LargeDrive">großen Platte</a> zu lesen.

</ul>
Andere Fehlermeldungen werden in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">biosboot(8)-Manualseite</a>
ausführlich besprochen.

Für weitere Informationen über den i386-Bootprozess, siehe
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
  Hale Landis' »How it Works«-Dokumente.
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - Welche Probleme treten bei großen Festplatten mit OpenBSD
auf?</h2>

<p>
OpenBSD unterstützt ein individuelles Dateisystem von bis zu
2<sup>31</sup>-1, oder 2,147,483,647 Sektoren und da jeder Sektor 512
Bytes groß ist, ist das etwas unterhalb von 1 T.

<p>
Selbstverständlich sind die Fähigkeit eines Dateisystems und die
Fähigkeit einer bestimmten Hardware zwei unterschiedliche Dinge.
Eine neue 250 G große IDE-Festplatte wird nicht mit älteren (vor
>137G-Standard) Interfaces funktionieren und einige sehr alte
SCSI-Adapter sind bekannt dafür, dass sie Probleme mit moderneren
Laufwerken haben und einige alte BIOSe werden hängen, wenn sie einer
modern bestückten Festplatte begegnen. Du musst die Fähigkeiten deiner
Hardware respektieren.

<h3>Partitionsgröße und Lokalitätsbegrenzungen</h3>
Leider ist die volle Funktionalität des OS nicht verfügbar, bis
NACHDEM das OS in den Speicher geladen wurde. Der Bootprozess verwendet
(und ist daher auch darauf beschränkt) die Boot-ROM des Systems.

<p>
Aus diesem Grund muss die /bsd-Datei (der Kernel) innerhalb des vom
Boot-ROM adressierbarem Bereich liegen. Das bedeutet für einige ältere
i386-Systeme, dass die root-Partition vollständig innerhalb der ersten
504 M liegen muss, aber neuere Computer können diese Grenze bei 2 G,
8 G, 32 G, 128 G oder mehr haben. Es ist ebenfalls sinnvoll zu erwähnen,
dass viele relativ neue Computer, die Laufwerke mit mehr als 128 G
Speicher unterstützen tatsächlich eine BIOS-Begrenzung für die ersten
128 G für das Booten haben. Du kannst diese Systeme mit großen
Laufwerken betreiben, aber deine root-Partition muss innerhalb der
ersten 128 G liegen.

<p>
Bedenke, dass es möglich ist, ein 40 G großes Laufwerk in einen alten
486er einzubauen und auf diesem OpenBSD mit einer großen Partition zu
installieren und zu denken, dass du erfolgreich die vorherige Regel
gebrochen hast. Trotzdem kann es dich auf einem höchst unangenehmen Weg
verfolgen:

<ul>
 <li>Du installiert eine 40 G /-Partition. Es funktioniert, da das
 Basis-OS und alle seine Dateien (einschließlich /bsd) innerhalb der
 ersten 504 M liegen.
 <li>Du benutzt das System und endest mit mehr als 504 M Dateien auf
 ihm.
 <li>Du aktualisiert und erstellst deinen eigenen Kernel, was auch
 immer, und kopierst deinen neuen /bsd über den alten.
 <li>Du startest neu.
 <li>Du bekommst eine Meldung wie »ERR M« oder andere Probleme während
 dem Booten.
</ul>
<p>
Warum? Weil, wenn du eine neue /bsd-Datei »über« die alte kopierst,
überschreibt sie nicht die alte: ihr wird einem neuen Ort auf der Platte
zugewiesen, möglicherweise außerhalb der 504-M-Grenze, die das
BIOS hat. Der Bootloader wird nun nicht mehr in der Lage sein, die
/bsd-Datei zu erhalten und das System hängt.

<p>
Um OpenBSD zum Booten zu bringen, müssen die Bootloader (biosboot(8) und
<tt>/boot</tt> im Falle von i386) und der Kernel (<tt>/bsd</tt>)
innerhalb des Bereiches sein, den die Boot-ROM unterstützt und
innerhalb ihrer eigenen Fähigkeiten. Um sicher zu gehen, ist die Regel
einfach:

<p>
<b>Die gesamte root-Partition muss innerhalb des BIOS (oder Boot-ROM)
vom Computer adressierbaren Speicher liegen.</b>

<p>
Einige Nicht-i386-Anwender denken, dass sie dies nicht betrifft, jedoch
haben die meisten Plattformen eine Art Begrenzung des ROMs bezüglich der
Plattengröße. Herauszufinden, wie groß diese Begrenzung denn nun
tatsächlich ist, kann schwer sein.

<p>
Dies ist ein weiterer guter Grund <a href="faq4.html#SpaceNeeded">deine
Festplatte zu partitionieren</a>, statt nur eine große Partition zu
verwenden.

<h3>Zeit- und Speicheranforderungen von fsck(8)</h3>
Eine weitere Überlegung mit großen Dateisystemen ist die Zeit und der
Speicher, die benötigt werden, um as Dateisystem nach einem Crash oder
einer Stromunterbrechung einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
zu unterziehen.
Man sollte nicht ein 120 G großes Dateisystem auf ein System mit 32 M
RAM setzen und erwarten, dass es fsck(1) erfolgreich nach einem Crash
ausführt. Eine grobe Richtlinie ist, dass das System zumindest 1 M
Arbeitsspeicher für jedes 1 G des Plattenspeichers haben sollte, um
erfolgreich fsck gegen die Platte auszuführen. Die benötigte Zeit, um
fsck gegen ein Laufwerk auszuführen kann ein Problem werden, sobald das
Dateisystem an Größe gewinnt.

<a name="InstBoot"></a>
<h2>14.8 - Installieren von Bootblocks - i386-spezifisch</h2>

<p>
Ältere Versionen von MS-DOS können nur mit Festplattengeometrien von
1024 Zylindern oder weniger umgehen. Da nahezu alle modernen
Betriebssysteme mehr als 1024 Zylinder haben, haben die meisten
SCSI-BIOS-Chips (die auf den SCSI-Controllerkarten) und IDE-BIOSe (was
Teil des restlichen PC-BIOS ist) eine Option (manchmal auch als
Grundeinstellung), die wirkliche Geometrie in etwas zu übersetzen, mit
dem MS-DOS umgehen kann. Wie dem auch sei, nicht alle BIOS-Chips
übersetzen die Geometrie in der selben Weise. Wenn du dein BIOS
wechselst (entweder mit einem neuen Motherboard oder einem neuen
SCSI-Controller) und das neue benutzt eine andere übersetzte Geometrie,
wirst du nicht in der Lage sein, den Secondstage-Bootloader zu laden
- und kannst daher den Kernel auch nicht laden (das liegt daran, dass
der Firststage-Bootloader eine Liste der Blöcke enthält, die /boot in
der übersetzten Geometrie enthalten). Falls du IDE-Platten benutzt und
du Änderungen an deinen BIOS-Einstellungen machst, kannst du seine
Übersetzung ebenfalls (ungewollt) ändern (die meisten IDE-BIOSe bieten
3 verschiedene Übersetzungen). Um deinen Bootblock zu reparieren, damit
du normal booten kannst, lege einfach eine Bootdiskette in dein
Diskettenlaufwerk ein und gib am Bootprompt »b hd0a:/bsd« ein, um ihn
zu zwingen, von der ersten Festplatte zu booten (und nicht von der
Diskette). Deine Maschine sollte normal booten. Jetzt musst du die erste
Stufe des Bootloaders auf den neuen Stand bringen. (Und dazu passend
den Bootblock schreiben.) <br>
Unser Beispiel geht davon aus, dass deine Bootdisk sd0
ist (bei IDE wäre es wd0, etc.):

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
Wenn eine neuere Version des Bootblocks benötigt wird, wirst du diese
selber kompilieren müssen. Und das geht so:

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (oder wie deine Festplatte auch immer heißen mag)
</pre>

<a name="Backup"></a>
<h2>14.9 - Sich auf das Schlimmste vorbereiten: Backups und
Wiederherstellen von Band.</h2>

<h3>Einführung:</h3>

<p>
Wenn du so etwas wie einen Produktionsserver laufen lassen willst, ist
es ratsam, irgendeine Form des Backups für den Fall zu haben, dass eine
deiner Festplatten versagt oder einen Crash hat.

<p>
Diese Information wird dir helfen, die Standardwerkzeuge
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
zu benutzen, die als Teil von OpenBSD ausgeliefert werden. Ein
fortgeschritteneres Werkzeug ist
<a href="http://www.amanda.org">Amanda</a>, das über
<a href="faq8.html#Ports">Ports</a> verfügbar ist und auch mehrere
Server auf ein Bandlaufwerk sichern kann. In den meisten Umgebungen sind
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
aber ausreichend. Wenn du aber mehrere Maschinen sichern willst,
ist Amanda auf jeden Fall einen Blick wert.

<p>
Die Beispiele in diesem Dokument benutzen sowohl SCSI-Festplatten als
auch Bänder. In einer Produktionsumgebung empfehlen wir SCSI und kein
IDE wegen der Art und Weise, wie IDE mit Badblocks umgeht. Das heißt
aber nicht, dass diese Informationen nutzlos sind, wenn du IDE benutzt,
sondern einzig deine Gerätenamen werden sich leicht unterscheiden. Zum
Beispiel wäre sd0a in einem IDE-basierten System wd0a.

<h3>Backup aufs Band bringen:</h3>

<p>
Um sein Backup auf ein Band zu bringen, muss man wissen, wo die
Dateisysteme gemountet sind. Das findet man mit dem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)"></a>-Kommando
am Shellprompt heraus. Dabei sollte eine Ausgabe wie diese
herauskommen:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>

<p>
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a -
also auf der SCSI-Festplatte 0, Partition a. Das /usr-Dateisystem
befindet sich auf sd0h - also SCSI-Festplatte 0, Partition h.

<p>
Ein weiteres Beispiel einer etwas größeren Mounttabelle könnte so
aussehen:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>

<p>
In diesem fortgeschritteneren Beispiel befindet sich das root- (/)
Dateisystem auf sd0a. Das /var-Dateisystem befindet sich auf sd0d, das
/home-Dateisystem auf sd0e und schlussendlich /usr auf sd0h.

<p>
Um ein Backup deiner Maschine zu machen, musst du dump mit jeder
festgelegten Partition füttern. Hier ist ein Beispiel der Kommandos, um
die einfachere Mounttabelle weiter oben zu sichern:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Für die etwas fortgeschrittenere Mounttabelle würde man etwas wie das
hier benutzen:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Du kannst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>-Manualseite
ansehen, um genau zu erfahren, was jede Kommandozeilenoption macht. Hier
ist eine kurze Übersicht der Parameter, die oben verwendet wurden:

<ul>
<li><b>0</b> - Führe einen Level-0-Dump durch - hole alles
<li><b>a</b> - Versuche automatisch die Bandlänge herauszufinden
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand,
um zu reflektieren, wann die letzte Sicherung gemacht wurde
<li><b>f</b> - Welches Bandlaufwerk benutzt werden soll (/dev/nrst0 in
diesem Fall)
</ul>

<p>
Zuletzt welche Partition gesichert werden soll (/dev/rsd0a, usw.)

<p>
Das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
wird am Ende benutzt, um das Band zurückzuspulen. Sieh dir die
mt-Manualseite an, wenn du mehr Informationen haben willst (wie etwa
eject).

<p>
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heißt, benutze
einfach dmesg, um das herauzufinden. Ein Beispieleintrag von dmesg für
ein Bandlaufwerk könnte so aussehen:

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
Du hast vielleicht bemerkt, dass bei der Sicherung das Bandlaufwerk als
<tt>nrst0</tt> anstatt von <tt>st0</tt> bezeichnet wird, wie man es
in dmesg sieht. Wenn du auf <tt>st0</tt> statt <tt>nrst0</tt> zugreifst,
benutzt du das selbe physikalische Gerät, sagst ihm aber, dass es nicht
zurückspulen soll, nachdem der Job im raw-Modus beendet wurde. Um
mehrere Dateien auf ein einziges Band zu sichern, stelle sicher, dass du
nicht zurückspulst - sprich das richtige Gerät (<tt>rst0</tt>) benutzt -
ansonsten wirst du mit der zweiten Sicherung die erste überschreiben,
usw. Du findest in der Manualseite zu dump eine ausführlichere
Beschreibung.

<p>
Wenn du ein kleines Skript namens backup schreiben würdest, könnte es
z.&nbsp;B. so aussehen:

<pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo                      
</pre>

<p>
Wenn regelmäßige nächtliche Backups gefordert sind, könnte man
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
benutzen, um das Backup jede Nacht automatisch zu starten.

<p>
Es ist außerdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie
groß jedes Dateisystem sein muss. Du kannst »<tt>df -h</tt>« benutzen,
um herauszufinden, wieviel Platz jede Partition momentan verbraucht. Das
ist dann nützlich, wenn eine Platte versagt und du die Partitionstabelle
auf der neuen Platte wieder erstellen musst.

<p>
Deine Daten wiederherzustellen hilft außerdem noch gegen Fragmentierung.
Der beste Weg, um sicherzustellen, dass du alle Dateien erwischst, ist
es, im Singleuser-Modus zu booten. Dateisysteme müssen nicht gemountet
werden, um gesichert zu werden. Vergiss aber nicht, root (/) zu mounten,
denn sonst wird dein dump versagen, wenn er versucht, Dumpdaten zu
schreiben. Gib einfach »<tt>bsd -s</tt>« am boot&gt;-Prompt ein, um in
den Singleuser-Modus zu gelangen.

<h3>Den Inhalt eines dump-Bandes ansehen:</h3>


<p>
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es
sicher eine gute Idee, dein Band zu testen und sicherzustellen, dass es
auch die Daten enthält, die darauf sein sollen.

<p>
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien
auf einem dump-Band zu erhalten:

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
Das listet die Dateien auf der 1. Partition des dump-Bandes (des
Sicherungsbands) auf. Wie in den Beispielen weiter oben ist 1 dein root-
(/) Dateisystem.

<p>
Um den Inhalt der 2. Partition zu sehen und die Ausgabe in eine Datei
umzulenken, würde man z.&nbsp;B. solch ein Kommando benutzen:

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
Wenn du eine Mounttabelle wie die oben aufgeführte hättest, wäre 2 /usr
- wenn deine aber etwas größer wäre, könnte 2 auch /var sein oder
irgendwas anderes. Die Sequenznummer unterliegt auf jeden Fall der
gleichen Reihenfolge, mit der das Dateisystem auf das Band gesichert
wurde.


<h3>Wiederherstellen vom Band:</h3>

<p>
Das Beispielszenario wäre sinnvoll, wenn deine eigentliche Festplatte
komplett ausgefallen wäre. Falls du aber nur eine einzige Datei
wiederherstellen willst, sieh dir die restore-Manualseite genau an und
achte besonders auf die Anweisungen für den interaktiven Modus.

<p>
Wenn du gut vorbereitet bist, kann der Prozess des Ersetzens einer
Festplatte sehr schnell von statten gehen. Die normale
OpenBSD-Installations-/Bootdiskette enthält bereits das benötigte
restore-Werkzeug genauso wie die ausführbaren Dateien, um neue
Partitionen zu erstellen und deine Festplatte bootfähig zu machen. In
den meisten Fällen sind diese Disketten und dein Sicherungsband alles,
was du brauchst, um wieder alles betriebsbereit zu bekommen.

<p>
Nachdem du das kaputte Laufwerk physikalisch ersetzt hast, sind die
grundlegenden Schritte zur Wiederherstellung folgende:

<ul>
<li>
<p>
Boote von der OpenBSD-Installations-/Bootdiskette. Wähle Shell aus dem
Menü aus. Nimm dein neuestes und schreibgeschütztes Band und lege es in
dein Laufwerk ein.
<br>
<li>
<p>
Benutze das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Kommando,
um eine primäre OpenBSD-Partition auf dieser neu installierten
Festplatte zu erzeugen. Beispiel:

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
Sieh einfach in die <a href="#fdisk">fdisk-FAQ</a>, um genaueres zu
erfahren.

<li>
<p>  
Mit dem disklabel-Kommando stellst du dann deine
OpenBSD-Partitionstabelle in der primären OpenBSD-Partition wieder her,
die du gerade mit fdisk erzeugt hast. Beispiel:

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(Vergiss den Swap nicht; siehe dazu die
<a href="#disklabel">disklabel-FAQ</a> für weitere Informationen)

<li>
<p>
Benutze das newfs-Kommando, um ein neues sauberes Dateisystem auf jeder
Partition zu erstellen, die du mit den oben aufgeführten Schritten
erstellt hast. Beispiel:

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
Mounte dein neu vorbereitetes root- (/) Dateisystem auf /mnt. Beispiel:

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
Wechsel in das gemountete root-Dateisystem und beginne mit dem
Wiederherstellungsprozess. Beispiel: 

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
Wenn die Platte bootfähig sein soll, schreibe mit dem folgenden Befehl
einen neuen MBR auf deine Festplatte. Beispiel:

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
<p>
Zusätzlich zum Schreiben eines neuen MBR musst du Bootblöcke
installieren, um von ihr booten zu können. Das Folgende ist ein
kurzes Beispiel:

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
Dein neues root-Dateisystem auf der eingebauten Festplatte sollte jetzt
fertig sein, so dass du davon booten und damit beginnen kannst, den Rest
der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht
komplett ist, solltest du alles im Singleuser-Modus wiederherstellen.
Benutze die folgenden Kommandos am Shellprompt, um deine Festplatten
zu unmounten und das System anzuhalten:

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
Entferne die Installations-/Bootdiskette aus dem Laufwerk und starte
dein System neu. Benutze das folgende Kommando am
OpenBSD-boot&gt;-Prompt:

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
Das bsd -s führt dazu, dass der Kernel im Singleuser-Modus gestartet
wird, der nur ein root- (/) Dateisystem braucht.

<li>
<p>
Unter der Annahme, dass du die obigen Schritte richtig ausgeführt hast
und nichts schief gegangen ist, solltest du von einem Prompt begrüßt
werden, der dich nach einem Pfad zu einer Shell fragt, oder du Return
drücken sollst. Drücke Return, um die sh zu benutzen. Als nächstes
willst du sicherlich root im Lese-/Schreibmodus (rw) remounten und nicht
mehr im schreibgeschützten Modus benutzen (ro). Dazu benutze
Folgendes:

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
Sobald du im Lese-/Schreibmodus remountet hast kannst du fortfahren,
deine restlichen Dateisysteme wiederherzustellen. Beispiel:

<pre>
(einfache Mounttabelle)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(umfassendere Mounttabelle)
#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
Benutze »<b>restore rvsf</b>« statt eines einfachen rsf, um die Namen
von Objekten zu sehen, während sie vom dump-Set ausgepackt werden.

<li>
<p>
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme
wiederhergestellt hast, führe einen Neustart in den Multiuser-Modus
durch. Wenn alles geklappt hat, sollte dein System wieder genau so
sein, wie zum Zeitpunkt deiner letzten Sicherung, und bereit, wieder
eingesetzt zu werden.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Diskimages unter OpenBSD mounten</h2>

<p>
Um ein Diskimage (ISO-Images, Diskimages, die mit dd erstellt wurden,
etc.) unter OpenBSD zu mounten, musst du ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>-Device
konfigurieren. Zum Beispiel, wenn du ein ISO-Image unter
<i>/tmp/ISO.image</i> hast, würdest du die folgenden Schritte machen,
um es zu mounten:

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
Bedenke bitte, dass du den Typ <i>cd9660</i> angeben musst, wenn es
eine CD ist. Das gilt aber auch für die anderen Typen. Du musst also
z.&nbsp;B. <i>ext2fs</i> beim Mounten eines Linux-Diskimages angeben.

<p>
Um das Image wieder zu unmounten, benutze die folgenden Kommandos.

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
Mehr Informationen gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>-Manualseite.

<a name="pciideErr"></a>
<h2>14.11 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</h2>

<p>
DMA-IDE-Übertragungen, die durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>
unterstützt werden, sind unzuverlässig. Bis vor kurzem wurden die
meisten Mainstreambetriebssysteme, die behaupteten, dass sie
DMA-Übertragungen mit IDE-Laufwerken unterstützen, nicht mit
standardmäßig aktivierter Unterstützung wegen unzuverlässiger Hardware
ausgeliefert. Nun werden viele dieser gleichen Maschinen mit OpenBSD
verwendet.

<p>
OpenBSD ist aggressiv und versucht, den höchsten DMA-Modus zu benutzen,
den es konfigurieren kann. Dies führt in einigen Konfigurationen zu
Datenkorruptionen aufgrund von defekten Motherboardchipsets,
fehlerhaften Treibern, die Probleme verursachen und/oder Lärm auf den
Kabeln. Glücklicherweise schützt Ultra-DMA die Datenübertragungen mit
einem CRC, um Korruptionen zu entdecken. Falls ein Fehler bei einem
solchen Ultra-DMA CRC geschieht, wird OpenBSD eine Fehlermeldung
ausgeben und erneut versuchen, die Daten zu übertragen.

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
Nach ein paar Fehlversuchen wird OpenBSD zu einem langsameren (und damit
hoffentlich zuverlässigeren) DMA-Modus herunterschalten. Nach den
Ultra-DMA-Modi wird dann zu einem PIO-Modus heruntergeschaltet.

<p>
UDMA-Fehler werden meistens durch minderwertige oder beschädigte Kabel
verursacht. Kabelprobleme sollten normalerweise zuerst in Betracht
gezogen werden, wenn du viele DMA-Fehler oder unerwartet niedrige
DMA-Leistung erhälst. Es ist ebenfals eine schlechte Idee, das CD-ROM an
den gleichen Kanal wie die Festplatte zu stecken.

<p>
Wenn das Ersetzen der Kabel nicht zur Lösung des Problems führt und
OpenBSD nicht erfolgreich herunterschaltet oder der Prozess zu einem
Einfrieren deiner Maschine führt, möchtest du vielleicht dein System
auf einen niedrigereren DMA- oder UDMA-Level standardmäßig begrenzen.
Dies kann unter Verwendung von <a href="faq5.html#BootConfig">UKC</a>
oder <a href="faq5.html#config">config(8)</a> realisiert werden, indem
man die Optionen des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>-Devices
ändert.


<a name="RAID"></a>
<h2>14.13 - RAID-Optionen unter OpenBSD</h2>
RAID (Redundant Array of Inexpensive Disks) gibt die Möglichkeit,
mehrere Laufwerke zu verwenden, um bessere Leistung, Kapazität und/oder
Redundanz zu erhalten, als man aus einem einzelnen Laufwerk herausholen
kann. Während eine vollständige Diskussion über die Vorteile und Risiken
von RAID außerhalb des Rahmens dieses Artikels liegt, existieren einige
Punkte, die so wichtig sind, dass sie nun besprochen werden sollten:

<ul>
<li>RAID hat nichts mit Backup zu tun.
<li>RAID allein wird die Ausfallzeit nicht eliminieren.
</ul>

Wenn diese Information neu für dich ist, ist das kein guter
Ausgangspunkt, um RAID zu erforschen.

<h3>Software Möglichkeiten</h3>
OpenBSD beinhaltet RAIDframe - eine software-basierte RAID-Lösung.
Dokumentation hierfür kann an folgenden Stellen gefunden werden:

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe-Homepage</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">Manualseite
     für raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">Manualseite
     für raid(4)</a>
</ul>

<p>
Die root-Partition kann direkt von OpenBSD unter Verwendung der
Option Autoconfiguration von RAIDframe gespiegelt werden.

<p>
OpenBSD 3.7-stable und neuer beinhaltet ebenfalls Mirroring als
Funktionalität des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>-Treibers.
Dieses System wurde in den GENERIC-Kernel integriert und befindet sich
im Kernel bsd.rd, so dass es viel einfacher genutzt werden kann, obwohl
es einige Begrenzungen im Bezug auf das Neuerzeugen des Arrays hat.
Siehe:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">Manualseite
zu ccd(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">Manualseite
zu ccdconfig(8)</a>
</ul>

<h3>Hardwaremöglichkeiten</h3>
<p>
Viele OpenBSD-<a href="../../de/plat.html">Plattformen</a> beinhalten
Unterstützung für etliche Hardware-RAID-Produkte. Die Möglichkeiten
variieren von Plattform zu Plattform: siehe die passende
Hardwareunterstützungsseite (<a href="../../de/plat.html">hier</a>
aufgelistet).

<p>
Eine andere Möglichkeit, die für viele Plattformen bereit steht, ist
eine der vielen Produkte, die mehrere Laufwerke dazu bringt, wie ein
großes IDE- oder SCSI-Laufwerk zu agieren und die dann in einen
standardmäßigen IDE- oder SCSI-Adapter gesteckt werden. Diese Geräte
können nahezu auf jeder Hardwareplattform funktionieren, die entweder
SCSI oder IDE verwenden.

<p>
Einige Hersteller dieser Produkte:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Hinweis: dies sind nur Produkte, die von OpenBSD-Anwendern verwendet
und gemeldet wurden - dies ist weder eine Art Werbung noch ist es eine
ausführliche Liste.)

<h3>Keine Möglichkeit</h3>
<p>
Eine häufig gestellte Frage in den
<a href="../../de/mail.html">Mailinglisten</a> ist »Werden die
kostengünstigen IDE- oder SATA-RAID-Controller (wie zum Beispiel jene,
die die Highpoint-, Promise- oder Adaptec-HostRAID-Chips benutzen)
unterstützt?« Die Antwort ist »Nein«. Diese Karten und Chips sind nicht
echte Hardware-RAID-Controller sondern eher BIOS-assistierte Bots für
ein Software-RAID. Da OpenBSD bereits Software-RAID auf eine
hardwareunabhängige Art und Weise unterstützt, besteht kein großes
Verlangen bei den OpenBSD-Entwicklern, diese spezielle Unterstützung
für diese Karten zu implementieren.

<p>
Fast alle Onboard-SATA- oder -IDE-»RAID«-Controller sind von diesem
softwarebasierendem Stil und funktionieren normalerweise einwandfrei als
SATA- oder IDE-Controller unter Verwendung des standardmäßigen
IDE-Treibers
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>).
Sie werden aber nicht als Hardware-RAID-System unter OpenBSD
funktionieren.

<a name="NegSpace"></a>
<h2>14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich mehr als 100&nbsp;%
von meiner Platte belegt habe?</h2>
Leute sind manchmal erstaunt darüber, herausfinden zu müssen, dass sie
<i>negativen</i> verfügbaren Plattenspeicher haben oder mehr als
100&nbsp;% einer Partition in Verwendung ist, wie es von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>
angezeigt wird.

<p>
Wenn eine Partition mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
erstellt wird, wird ein Teil des verfügbaren Speichers vor den normalen
Benutzern in Reserve gehalten. Dies stellt einen Spielraum für Fehler
bereit, wenn du versehentlich die Platte füllst und hilft, die
Plattenfragmentierung auf einem Minimum zu halten. Standardwert hierfür
ist 5&nbsp;% der Plattenkapazität, so dass, falls der
Systemadministrator sorglos die Platte auffüllt, du bis zu 105&nbsp;%
Speicher sehen kannst, der verwendet wird.

<p>
Wenn der 5-%-Wert für dich nicht angemessen erscheint, kannst du ihn mit
dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>
ändern.

<a name="OhBugger"></a>
<h2>14.15 - Partitionen wiederherstellen, nachdem das Disklabel gelöscht
wurde</h2>

<p>
Wenn du eine Partitionstabelle beschädigt hast, gibt es einige Dinge,
die du versuchen kannst, um sie wiederherzustellen.

<p>
Zu aller erst Panik. Das würde sowieso passieren - aber dann hast du
es jedenfalls hinter dir. Mach einfach nichts Unvernünftiges. Halte
deine Panik von der Maschine fern. Dann entspanne dich und guck, ob dir
die unten stehenden Schritte vielleicht weiterhelfen.

<p>
Eine Kopie des Disklabels wird für jede Platte als Teil der täglichen
Systemverwaltung unter <tt>/var/backups</tt> gespeichert. Angenommen,
dass du die var-Partition weiterhin hast, kannst du einfach die Ausgabe
lesen und sie zurück in das Disklabel schreiben.

<p>
Falls du die Partition nicht mehr sehen kannst, gibt es zwei
Möglichkeiten. Behebe genug Fehler der Platte, bis du sie sehen kannst
oder behebe genug Fehler der Platte, um deine Daten von ihr zu bekommen.

Abhängig davon, was passiert ist, könnte der eine oder ein anderer
Weg bevorzugt sein (mit sterbenden Platten, von denen du zuerst
die Daten haben willst, könntest du mit schlampigen Fingern nur das
Label bekommen).

<p>

Das erste Werkzeug, das du brauchst, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(achte auf den Unterstrich, es wird nicht »scanffs« genannt).
Das Werkzeug scan_ffs(8) durchsucht die Platte und versucht,
Partitionen zu finden, und teilt dir die Informationen mit, die es über
sie herausgefunden hat. Du kannst diese Informationen nutzen, um das
Disklabel neu zu erstellen. Wenn du einfach nur <tt>/var</tt>
zurückhaben willst, kannst du die Partition für <tt>/var</tt> wieder
erstellen und dann das gesicherte Label nutzen, um den Rest von diesem
aus zu erstellen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
wird sowohl die Erkenntnis des Kernels über das Disklabel erneuern
als auch versuchen, das Label auf die Platte zu schreiben.
Selbst wenn der Bereich der Platte, in dem das Disklabel liegt, nicht
lesbar ist, wirst du trotzdem in der Lage sein, bis zum nächsten
Neustart
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
aufzurufen.


<a name="foreignfs"></a>
<h2>14.16 - Kann ich auf Daten zugreifen, die auf anderen Dateisystemen
als FFS liegen?</h2>
<!-- This article written by Steven Mestdagh,
steven.mestdagh@esat.kuleuven.be, and released under the BSD license -->

Ja. Andere unterstützte Dateisysteme sind unter anderem: ext2 (Linux),
ISO9660 und UDF (CD-ROM-, DVD-Medien), FAT (MS-DOS und Windows), NFS,
NTFS (Windows) und AmigaDOS. Einige von ihnen haben eingeschränkte - zum
Beispiel nur schreibgeschützte - Unterstützung.

<p>
Wir werden hier einen allgemeinen Überblick darüber geben, wie man eines
dieser Dateisysteme unter OpenBSD verwendet. Um in der Lage zu sein, ein
Dateisystem zu benutzen, muss es gemountet sein. Für Details und
Optionen für mount, konsultiere bitte die Manualseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
und die Manualseite zum mount-Kommando für das Dateisystem, das du
mounten möchtest, z.&nbsp;B. mount_msdos, mount_ext2fs,&nbsp;...

<p>
Zu aller erst musst du wissen, auf welchem Device sich dein Dateisystem
befindet. Vielleicht einfach deine erste Festplatte (<tt>wd0</tt> oder
<tt>sd0</tt>), es könnte aber auch weniger offensichtlich sein.
Alle erkannten und konfigurierten Devices deines Systems werden in der
Ausgabe vom Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
aufgeführt: ein Devicename, gefolgt von einer einzeiligen Beschreibung
des Devices. Mein erstes CD-ROM-Laufwerk wird beispielsweise wie folgt
erkannt:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Du kannst
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
verwenden, um eine viel kürzere Liste der verfügbaren Platten zu
erhalten. Das Kommando

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

wird alle Platten anzeigen, die deinem System momentan bekannt sind,
z.&nbsp;B.:

<blockquote><pre>
hw.disknames=cd0,cd1,wd0,fd0,cd2
</pre></blockquote>

<p>
An diesem Punkt angekommen ist es Zeit dafür, herauszufinden, welche
Partitionen sich auf dem Device befinden, und auf welcher Partition das
gewünschte Dateisystem liegt. Daher untersuchen wir das Device mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Das Disklabel beinhaltet eine Liste, die aus maximal 16 Partitionen
besteht. Partition c steht immer für das gesamte Device. Partitionen
a - b und d - p werden von OpenBSD genutzt. Partitionen i - p können
automatisch für Dateisysteme anderer Betriebssysteme allokiert werden.
In diesem Fall werde ich mir das Disklabel meiner Festplatte betrachten,
welches eine Anzahl verschiedener Dateisysteme beinhaltet.

<p>
<b>HINWEIS: OpenBSD wurde nach allen anderen Betriebssystemen
installiert</b> und während der Installation wurde ein Disklabel
erstellt, das alle Partitionen der nativen als auch der anderen
Dateisysteme enthält, die sich auf der Platte befanden. Wenn du jedoch
andere Dateisysteme installiert nachdem das OpenBSD-Disklabel bereits
auf der Platte installiert wurde, musst du sie nachträglich manuell
hinzufügen oder ändern. Dies wird in <a href="#foreignfsafter">diesem
Unterkapitel</a> behandelt.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A       
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581 
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206 
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544 
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367 
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773 
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176 
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>

<p>
Wie du in dieser Ausgabe erkennen kannst, werden die OpenBSD-Partitionen
zuerst aufgelistet. Nach diesen ist eine Anzahl von ext2-Partitionen und
eine MSDOS-Partition aufgelistet, sowie ein paar unbekannte (unknown)
Partitionen. Auf i386- und amd64-Systemen kannst du mehr über diese
unter Verwendung des Werkzeugs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
in Erfahrung bringen.
Für den neugierigen Leser: Partition i ist eine Wartungspartition, die
vom Hersteller erzeugt wurde, Partition j ist eine NTFS-Partition und
Partition l ist eine Swappartition für Linux.

<p>
Sobald du herausgefunden hast, welche dieser Partitionen die ist, die du
benutzen möchtest, kannst du den letzten Schritt durchführen: das
Dateisystem, das sich auf dieser befindet, mounten. Die meisten
Dateisysteme werden vom GENERIC-Kernel unterstützt: wirf einfach einen
Blick in die Kernelkonfigurationsdatei, die sich im Verzeichnis
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt> befindet.
Einige werden jedoch nicht unterstützt, z.&nbsp;B. ist die
NTFS-Unterstützung experimentell und daher nicht im GENERIC.
Wenn du eines der Dateisysteme nutzen möchtest, die nicht in GENERIC
unterstützt werden, musst du <a href="faq5.html#Options">einen
angepassten Kernel erzeugen</a>.

<p>
Wenn du die Informationen auf zuvor beschriebene Weise gesammelt hast,
ist es nun an der Zeit, das Dateisystem zu mounten.
Lass uns annehmen, dass ein Verzeichnis namens <tt>/mnt/otherfs</tt>
existiert, welches wir als Mountpunkt nutzen werden, unter dem wir das
gewünschte Dateisystem mounten werden.
In diesem Beispiel werden wir das ext2-Dateisystem von Partition m
mounten:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

<p>
Wenn du vorhast, dieses Dateisystem regulär zu nutzen, kannst du etwas
Zeit sparen, indem du eine Zeile in <tt>/etc/fstab</tt> schreibst; zum
Beispiel etwas wie:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Beachte den Wert 0 im fünften und sechsten Feld. Diese bedeuten, dass
wir nicht möchten, dass die Dateisysteme mit dump gesichert oder unter
Verwendung von fsck überprüft werden. Generell gilt, dass du solche
Aufgaben eher mit dem dazugehörigem Betriebssystem machen möchtest.

<a name="foreignfsafter"></a>
<h3>14.16.1 - Die Partitionen sind nicht in meinem Disklabel! Was kann
ich tun?</h3>

Wenn du andere Dateisysteme auf deinem System angelegt hast (resultiert
meist aus der Installation eines anderen Betriebssystems) nachdem du
OpenBSD bereits installiert hast, wird ein Disklabel bereits vorliegen
und nicht automatisch aktualisiert, so dass es die neuen fremden
Dateissystempartionen enthielte. Wenn du diese verwenden möchtest,
dann musst du diese Partionen manuell unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
hinzufügen oder editieren.

<p>
Beispielsweise habe ich eine meiner bestehenden ext2fs-Partitionen
geändert: unter Verwendung von Linux' fdisk-Programm habe ich die
Größe der o-Partition (siehe die Disklabelausgabe weiter oben) auf 1 G
reduziert. Wir können dies leicht sehen, indem wir einen Blick auf die
Startposition (Offset: 64372518) und die Größe (13783707) werfen.
Beachte, dass diese Werte Sektornummern und dass die Verwendung von
Sektornummern (nicht Megabytes oder ein anderes Maß) die exakteste
Angabe ist und der sicherste Weg, um diese Informationen zu lesen.

<p>
Vor dem Ändern sah die Partition wie diese aus (Ausgabe von OpenBSDs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Werkzeug
[nur die wichtigen Informationen werden hier angegeben]):

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Wie du sehen kannst sind die Startposition und die Größe genau so, wie
sie zuvor von disklabel(8) angegeben wurden. (Sei jetzt nicht wegen dem
Wert verwirrt, der als Offset angegeben wird: der Wert bezieht sich auf
die Startposition der erweiterten Partition, in der sich die
ext2-Partition befindet.)

<p>
Nachdem die Partitionsgröße unter Linux geändert wurde, sieht sie wie
folgt aus:

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Dies muss nun unter Verwendung von disklabel(8) geändert werden.
Zum Beispiel kannst du <tt>disklabel -e wd0</tt> aufrufen, womit du
einen Editor startest, der mit der Umgebungsvariable EDITOR (Standard
ist vi) angegeben wird. Ändere mit diesem Editor die Zeile des
Disklabels, um diese auf die neue Größe anzupassen:

<blockquote><pre>
  o:       2104452      64372518  ext2fs
</pre></blockquote>

Schreibe das Disklabel auf die Platte, wenn du fertig bist. Nun, da das
Disklabel wieder aktuell ist, solltest du in der Lage sein, die
Partitionen wie oben beschrieben wieder mounten zu können.

<p>
Du kannst einen sehr ähnlichen Prozess ausführen, um neue Partitionen
hinzuzufügen.


<a name="flashmem"></a>
<h2>14.17 - Kann ich ein Gerät mit Flashspeicher unter OpenBSD
benutzen?</h2>
<!-- This article written by Steven Mestdagh,
steven.mestdagh@esat.kuleuven.be, and released under the BSD license -->

Normalerweise sollte ein Speichergerät erkannt werden, wenn es an eine
Schnittstelle deiner Maschine angeschlossen wird. Kurz nach dem
Anschließen werden einige Nachrichten auf der Konsole des Kernels
angezeigt. Wenn ich zum Beispiel meinen USB-Flashspeicher anschließe,
sehe ich folgendes auf meiner Konsole:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Diese Zeilen deuten darauf, dass der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>-
(USB-Massenspeicher-) Treiber an das Speichergerät angehängt wurde und
dass es das SCSI-System nutzt. Die beiden letzten Zeilen sind die
wichtigsten: sie sagen, an welche Gerätedatei das Speichergerät
angehängt wurde, und wie groß der gesamte Speicherplatz ist.
Wenn du diese Zeilen - warum auch immer - verpasst haben solltest,
kannst du sie nachträglich mit dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
betrachten. Die angegebene CHS-Geometrie ist eine fiktive, da der
Flashspeicher wie eine normale SCSI-Platte verarbeitet wird.

<p>
Wir werden nun zwei Szenarien besprechen.

<h3>Das Gerät ist neu/leer und du möchtest es nur mit OpenBSD
nutzen</h3>

Du musst ein Disklabel und mindestens eine Partition auf diesem Gerät
erstellen. Bitte lies <a href="#disklabel">OpenBSDs disklabel
verwenden</a> und die Manualseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
für Details hierüber.

<p>
In diesem Beispiel habe ich nur die Partition <i>a</i> erstellt, auf
der ich ein FFS-Dateisystem erstellen werde:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Lass uns das Dateisystem, das wir auf der Partition <i>a</i> erstellt
haben, unter <tt>/mnt/flashmem</tt> mounten.
Erstelle zuerst einen Mountpunkt, wenn er noch nicht existiert.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h3>Du hast das Speichergerät von jemandem erhalten, mit dem du Daten
austauschen möchtest</h3>

<p>
Möglicherweise wird diese andere Person nicht OpenBSD nutzen, so dass
sich ein fremdes Dateisystem auf diesem Speichergerät befinden kann.
Daher müssen wir zuerst alle Partitionen auf diesem Gerät finden, so
wie es in <a href="#foreignfs">FAQ 14 - Fremde Dateisysteme</a>
beschrieben steht.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122 
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Wie man in der Ausgabe von disklabel sehen kann, gibt es nur eine
Partition names <i>i</i>, das ein FAT-Dateisystem beinhaltet, das von
einer Windows-Maschine erstellt wurde. Wie gewöhnlich stellt die
Partition <i>c</i> das gesamte Gerät dar.

<p>
Lass uns nun das Dateisystem auf der Partition <i>i</i> unter
<tt>/mnt/flashmem</tt> mounten.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Nun können wir damit beginnen, es wie jede andere Platte anzusprechen.

<p>
<b>WARNUNG:</b>
Du solltest das Dateisystem <b>vor dem Herausziehen</b> des Geräts
<b>immer erst unmounten</b>.
Wenn du das nichts tust, könnte das Dateisystem in einem nicht
konsistenten Zustand zurückgelassen werden, was im schlimmsten Fall
Datenverlust bedeutet.

<p>
Nach dem Entfernen des Speichergeräts von deiner Maschine wirst du
wieder sehen, dass der Kernel Meldungen hierüber auf der Konsole
ausgibt:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq13.html">[Zum Kapitel 13 - Multimedia]</a>
<a href= "faq15.html">[Zum Kapitel 15 - Packages und Ports]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small> 
<!--
Originally [OpenBSD: faq14.html,v 1.138 ]
$Translation: faq14.html,v 1.46 2005/11/04 14:03:54 paldium Exp $
-->
$OpenBSD: faq14.html,v 1.41 2005/11/04 20:24:23 jufi Exp $
</small>

</body>
</html>
