<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Festplattenkonfiguration</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 14 - Disk Setup">
<meta name= "keywords"      content= "openbsd,faq14">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2013 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq13.html">[Zum Kapitel 13 - Multimedia]</a>
<a href= "faq15.html">[Zum Kapitel 15 - Pakete und Portierungen]</a>
</font>

<h1><font color="#e00000">14 - Festplattenkonfiguration</font></h1><hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#intro"      >14.1 - Festplatten und Partitionen</a>
<li><a href="#fdisk"      >14.2 - Benutzung von OpenBSDs fdisk(8)</a>
<li><a href="#disklabel"  >14.3 - Benutzung von OpenBSDs disklabel(8)</a>
<li><a href="#NewDisk"    >14.4 -
    Hinzufügen weiterer Festplatten unter OpenBSD</a>
<li><a href="#Swap"       >14.5 - Wie wird Auslagerung gehandhabt?</a>
<li><a href="#SoftUpdates">14.6 - »Soft Updates«</a>
<li><a href="#Boot386"    >14.7 - Wie booten OpenBSD/i386 und OpenBSD/amd64?</a>
<li><a href="#LargeDrive" >14.8 -
    Welche Probleme treten bei großen Festplatten mit OpenBSD auf?</a>
<li><a href="#InstBoot"   >14.9 -
    Installieren von Bootblocks - i386/amd64-spezifisch</a>
<li><a href="#Backup"     >14.10 -
    Vorbereitung auf Katastrophen -
    Erzeugen von Backups und Wiederherstellung vom Band.</a>
<li><a href="#MountImage" >14.11 - Laufwerksabbilder in OpenBSD einhängen</a>
<li><a href="#pciideErr"  >14.12 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</a>
<li><a href="#NegSpace"   >14.14 -
    Warum sagt mir <tt>df(1)</tt>,
    dass ich mehr als 100&nbsp;% von meinem Laufwerk belegt habe?</a>
<li><a href="#OhBugger"   >14.15 -
    Partitionen wiederherstellen,
    nachdem das Disklabel gelöscht wurde</a>
<li><a href="#foreignfs"  >14.16 -
    Kann ich auf Daten zugreifen,
    die auf anderen Dateisystemen als FFS liegen?</a>
<ul>
  <li><a href="#foreignfsafter">14.16.1 -
        Die Partitionen sind nicht in meinem Disklabel verzeichnet!
        Was kann ich tun?</a>
</ul>
<li><a href="#flashmem"   >14.17 -
    Kann ich ein Flash-Speicher-Gerät mit OpenBSD benutzen?</a>
  <ul>
  <li><a href="#flashmemPortable">14.17.1 -
        Flash-Speicher als portables Speichergerät</a>
  <li><a href="#flashmemBoot"    >14.17.2 -
        Flash-Speicher als startbarer Speicherplatz</a>
  <li><a href="#flashmemLive"    >14.17.3 -
        Wie kann ich ein startbares »Live« USB-Gerät erzeugen?</a>
  </ul>
<li><a href="#DiskOpt"    >14.18 - Optimierung der Laufwerksleistung</a>
<li><a href="#Async"      >14.19 -
    Warum verwenden wir keine »async«hrone Einhängemodi?</a>
</ul>
<hr>

<a name="intro"></a>
<h2>14.1 - Festplatten und Partitionen</h2>

<p>
Die Details der Einrichtung von Festplatten unter OpenBSD variieren zwischen
den Plattformen, sodass die spezifischen Installationsanweisungen der Datei
<tt>INSTALL.&lt;arch&gt;</tt> für die <a href="../../de/plat.html">Plattform</a>
gelesen werden sollten, um die Besonderheiten des Systems festzustellen.

<p>
<h3>Identifikation der Festplatte</h3>
OpenBSD handhabt Massenspeicher auf den meisten Plattformen mit zwei Treibern,
und zwar in Abhängigkeit des von dem Gerät unterstützten normalen
Befehlssatzes:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4"
>wd(4):</a> IDE-Festplatten (und Geräte die wie IDE-Platten aussehen, zum
Beispiel SATA-, MFM- oder ESFI-Festplatten, oder ein Flash-Speichergerät mit
einem entsprechendem Adapter), die an
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wdc&amp;sektion=4"
>wdc(4)</a>- oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4"
>pciide(4)</a>-Schnittstellen angeschlossen sind.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4"
>sd(4):</a> Geräte die SCSI-Kommandos nutzen, wie zum Beispiel
SCSI-Festplatten, die an SCSI-Adapter angeschlossen sind, USB-Festplatten,
SATA-Festplatten, die an eine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4"
>ahci(4)</a>-Schnittstelle angeschlossen sind, sowie Festplattenverbünde, die
durch einen RAID-Kontroller angesteuert werden.
</ul>

Die erste von OpenBSD identifizierte Platte eines bestimmten Types wird Platte
»0«, die zweite wird »1« etc.
Also wird die erste IDE-ähnliche Festplatte zu wd0, und die dritte
SCSI-ähnliche Festplatte zu sd2.
Wenn auf einem System zwei SCSI-ähnliche Platten und drei IDE-ähnliche Platten
vorhanden wären, so gäbe es auf dieser Maschine sd0, sd1, wd0, wd1 und wd2.
Die Anordnung hängt von der Reihenfolge ab, in der sie die Hardwareerfassung
während des Systemstarts gefunden hat.
Es gibt ein paar wichtige Punkte zu beachten:
<ul>
<li>Festplatten sind möglicherweise nicht in derselben Anordnung nummeriert, in
der das Boot-ROM versucht hat, sie zu booten (d.&nbsp;h. das System kann
etwas zu booten versuchen, dass OpenBSD als wd2 oder sd1 identifiziert).
Manchmal mag es dir möglich sein dies zu ändern, manchmal auch nicht.
<li>Das Entfernen oder Hinzufügen von Festplatten kann die Identität anderer
Laufwerke auf dem System verändern.
</ul>

<h3>Partitionierung</h3>

Aus historischen Gründen wird der Begriff »Partition« in OpenBSD für zwei
verschiedene Dinge benutzt, und dies führt zu einiger Verwirrung.

<p>
Die zwei als »Partition« bezeichneten Typen sind:
<ul>
<li>»disklabel-Partitionen«, die mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a> erzeugt werden (oft auch »Dateisystem-Partitionen« genannt).
<li>»fdisk-Partitionen«, erzeugt mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386"
>fdisk(8)</a> (oft »Partitionstabellen-Partitionen« oder »Master Boot Record
(MBR)-Partitionen« genannt).
</ul>

<p>
Alle von OpenBSD unterstützten Plattformen benutzen disklabel(8) als Königsweg,
um OpenBSD-Dateisystem-Partitionen zu verwalten, aber einige Plattformen
benötigen zusätzlich fdisk(8), um Partitionstabellen-Partitionen zu verwalten.
Auf den fdisk-Partitionen nutzenden Plattformen nimmt eine fdisk-Partition
alle OpenBSD-Dateisysteme auf, da diese eine Partition in disklabel-Partitionen
aufgeteilt wird.
Die disklabel-Partitionen sind mit den Buchstaben »a« bis »p« etikettiert.
Einige von ihnen sind speziell:
<ul>
<li><b>a</b> -- Auf dem Bootlaufwerk ist Partition »a« die root-Partition.
<li><b>b</b> -- Auf dem Bootlaufwerk wird Partition »b« automatisch als
Auslagerungs-Partition genutzt.
<li><b>c</b> -- Auf allen Laufwerken bezeichnet Partition »c« das gesamte
Laufwerk, vom ersten bis zum letzten Sektor.
(Hinweis: wenn du ein Laufwerk komplett löschen möchtest, brauchst du nur die
Partition »c« mit Nullen zu beschreiben.
Häufiger jedoch wird Partition »c« von Dienstprogrammen wie »fdisk« benutzt, um
»Bootloader«, Partitionstabellen usw. zu installieren.)
</ul>

<h3>Partitionsidentifizierung</h3>
Ein OpenBSD-Dateisystem wird durch die Festplatte identifiziert, auf der es
sich befindet, und zusätzlich durch die Dateisystem-Partition auf dieser
Festplatte.
Also können Dateisysteme durch Bezeichner wie »sd0a« (die Partition »a« des
ersten »sd«-Geräts), »wd2h« (Partition »h« des dritten »wd«-Geräts) oder »sd1c«
(das gesamte zweite »sd«-Gerät) gekennzeichnet sein.
Die Gerätedateien wären <tt>/dev/sd0a</tt> für das »block«-Gerät, und
<tt>/dev/rsd0a</tt> wäre die Gerätedatei für das »unverarbeitete« Gerät
(»Character-Device«).

<p>
Einige Dienstprogramme erlauben die Benutzung der verkürzten Namensform einer
Partition (d.&nbsp;h. »sd0d«) oder eines Geräts (d.&nbsp;. »wd1«), anstatt des
tatsächlichen, ausgeschriebenen Gerätenamens
(»<tt>/dev/sd0d</tt>« oder »<tt>/dev/wd1c</tt>«, respektive).

<p>
Erneut: es ist zu beachten, dass, wenn du Daten auf <tt>wd2d</tt> platzierst,
und dann später <tt>wd1</tt> aus dem System entfernst und neu startest, sich
deine Daten nun auf <tt>wd1d</tt> befinden, da dein vorheriges <tt>wd2</tt> nun
<tt>wd1</tt> ist.
Dagegen ändern sich die Kennungen eines Geräts nach dem Systemstart nicht
mehr, sodass für den Fall, dass ein USB-Gerät entfernt wird oder ausfällt, sich
die Kennungen für die anderen Geräte bis zum Neustart des Systems nicht ändern.

<a name="DUID"></a>
<h3>Eindeutige Disklabel-Kennungen</h3>
Laufwerke können ebenso durch eindeutige Disklabel-Kennungen
(»Disklabel Unique Identifiers«, DUIDs) identifiziert werden;
dies sind 16-stellige hexadezimale Zahlen, die von dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskmap&amp;sektion=4"
>diskmap(4)</a>-Gerät verwaltet werden.
Diese Zahl wird automatisch als Zufallszahl erzeugt, wenn ein Disklabel zum
ersten Mal geschrieben wird, der Standardwert auf existierenden (vor-OpenBSD
4.8) Labels ist jedoch (eine Reihe von 16) Null(en).
disklabel(8) kann benutzt werden, um die UID zu ändern, wenn gewünscht.
Diese UIDs sind »persistent« - identifizierst du deine Laufwerke auf diese
Weise, wird Laufwerk »<tt>f18e359c8fa2522b</tt>« immer Laufwerk
<tt>f18e359c8fa2522b</tt> bleiben, egal in welcher Reihenfolge oder auf welche
Weise es angeschlossen wird.
Du kannst auf dem Laufwerk Partitionen durch das Anhängen eines Punkts und dem
Partitions-Buchstaben spezifizieren; so bezeichnet zum Beispiel
<tt>f18e359c8fa2522b.d</tt> die Partition »d« des Laufwerks
<tt>f18e359c8fa2522b</tt> und wird IMMER auf denselben Speicherplatz verweisen,
ganz egal in welcher Reihenfolge das Gerät an das System angeschlossen wird,
oder an welche Schnittstellenart es angeschlossen wird.

<p>
Diese UIDs können fast überall dort zur Identifikation benutzt werden, wo eine
Partition oder ein Gerät spezifiziert werden muss, zum Beispiel in
<tt>/etc/fstab</tt> oder auf den Kommandozeilen.
Natürlich können Festplatten und Partitionen auch auf traditionelle Weise
identifiziert werden, also nach Gerät, Nummer der Einheit und Partition
(z.&nbsp;B. /dev/sd1f), und dies kann völlig transparent, also austauschbar
geschehen.

<p>
Es ist anzumerken, dass die DUID eine Eigenschaft des Disklabel ist, obwohl, da
OpenBSD nur ein Disklabel pro Laufwerk unterstützt, dies eher eine akademische
Feststellung ist.

<p>
<a name="fdisk"></a>
<h2>14.2 - Benutzung von OpenBSDs fdisk(8)</h2>

Lies zuerst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386"
>fdisk(8)</a>-Handbuchseite.

<p>
Auf einigen Plattformen (i386, amd64, macppc, zaurus und armish) wird
fdisk(8) verwendet, um eine Partition zu erstellen, die vom
Boot-ROM des Systems erkannt werden kann und die Disklabelpartitionen
von OpenBSD aufnehmen wird. Andere Plattformen benötigen oder verwenden
fdisk(8) nicht. Mit fdisk(8) kann auch der Masterbootrecord (MBR)
editiert werden, wodurch alle Betriebssysteme auf einem Computer
betroffen sind. Im Gegensatz zu anderen fdisk-ähnlichen Programmen
einiger anderen Betriebssysteme nimmt OpenBSDs fdisk an, dass du weißt
was du tust, und wird dich die meiste Zeit machen lassen was du willst
- somit steht dir ein sehr mächtiges Werkzeug zur Verfügung.
Andererseits lässt es dich eben auch Dinge machen, die du entweder
nicht machen solltest oder die du auch nicht gar nicht vorhattest.
Bei der Verwendung ist also Vorsicht geboten.

<p>
Normalerweise wird nur eine fdisk-Partition für OpenBSD auf einer Platte
angelegt. Diese Partition wird dann mit
<a href="#disklabel">disklabel</a> in weitere
OpenBSD-Dateisystempartitionen aufgeteilt.

<p>


<p>
Um dir nur deine Partitionstabelle mit fdisk anzugucken, verwende:

<blockquote><pre>
# <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Was dann eine ähnliche Ausgabe wie diese hier erzeugt:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre></blockquote>

<p>
In diesem Beispiel betrachten wir die Ausgabe des ersten
SCSI-Laufwerks. Wir können die OpenBSD-Partition (A6) und ihre Größe
sehen. Der * sagt uns, dass die OpenBSD-Partition eine bootbare
Partition ist.

<p>
Im vorherigen Beispiel haben wir uns die Informationen nur angesehen.
Was aber, wenn wir unsere Partitionstabelle verändern wollen? Nun, dazu
müssen wir zunächst die Option <b>-e</b> benutzen. Diese bringt uns dann
zu einer Kommandozeile, die uns mit fdisk interagieren lässt.

<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        swap            Swap two partition entries
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt;
</pre></blockquote>

<p>

<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe
der Option <b>-e</b> benutzen kann.

<ul>
<li><b>help</b>  Zeigt eine Liste der Kommandos an, die fdisk im
interaktiven Editmodus versteht.
<li><b>reinit</b>  Initialisiert die momentane im Speicher befindliche
Kopie des Bootblocks. Hiermit kannst du auf elegante und schnelle Weise
eine - die gesamte Platte in Anspruch nehmende - OpenBSD-Partition
erstellen, den Bootcode aktualisieren und - im Allgemeinen gesagt -
das System für OpenBSD vorbereiten (und nichts weiter außer OpenBSD).
<li><b>disk</b>  Zeigt die momentane Plattengeometrie an, die fdisk
ermittelt hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du
willst.
<li><b>setpid</b>  Ändert eine Partitionsidentifizierung des angegebenen
Partitionstabelleneintrages. Dieses Kommando ist insbesondere nützlich,
um eine existierende Partition OpenBSD wieder zugänglich zu machen.
<li><b>edit</b>  Ändere eine ausgewählte Plattengeometrie in der Kopie
des momentanen Bootblocks.  Das geschieht entweder im
BIOS-Geometriemodus oder in Sektoroffsets und -größen.
<li><b>flag</b>  Macht den jetzigen Partitionstabelleneintrag bootbar.
Nur ein Eintrag kann gleichzeitig bootbar sein. Wenn du von einer
erweiterten Partition booten willst, musst du auch den entsprechenden
Eintrag als bootbar markieren
(OpenBSD selbst kann nur von einer primären Partition gebootet werden,
auch wenn andere Partitionen als aktiv markiert werden können).
<li><b>update</b>  Bringt den Maschinencode in der Speicherkopie des
momentanen Bootblocks auf den aktuellen Stand.
<li><b>select</b>  Wählt und lädt den Bootblock, auf den der Eintrag der
erweiterten Partitionstabelle im momentanen Bootblock zeigt.
<li><b>swap</b>  Tauscht zwei MBR-Einträge miteinander aus, sodass du
den MBR neu ordnen kannst.
<li><b>print</b>  Gibt die momentan im RAM befindliche und gewählte
Kopie des Bootblocks und seinen MBR auf dem Bildschirm aus.
<li><b>write</b>  Schreibt die RAM-Version des Bootblocks auf
die Platte. Du wirst um eine Bestätigung gebeten.
<li><b>exit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt.
<li><b>quit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt. Im Gegensatz zu exit schreibt diese
Variante den modifizierten Block auf die Platte.
<li><b>abort</b>  Verlässt das Programm ohne Änderungen zu speichern.
</ul>

<h3>Tipps und Tricks für fdisk</h3>
<ul>
<!-- <li>Auf OpenBSD-Plattformen, die fdisk verwenden, solltest du die
erste Spur ungenutzt lassen. Hiermit lässt du Platz für den
Masterbootrecord, in dem sich die fdisk-Partitionstabelle befindet
(bin mir nicht sicher, ob das wahr ist). -->
<li>fdisk(8) bietet die Möglichkeit an, die Partitionen sowohl direkt
in Sektoren als auch im Zylinder/Kopf/Sektor-Format anzugeben. Für beide
Optionen gibt es gute Gründe - einige Aufgaben werden auf die eine Weise
leichter gelöst, andere auf die andere. Beschränke dich nicht darauf,
nur eine von beiden einzusetzen.
<li>Eine völlig geleerte Platte setzt voraus, dass der Bootcode des
Masterbootrecords geschrieben werden muss, bevor von ihr gebootet werden
kann. Du möchtest den vorhandenen Bootcode eventuell sowieso erneuern
falls dir seine Herkunft unbekannt ist.
<li>Wenn dein System eine Verwaltungs- oder Diagnosepartition besitzt,
dann wird dazu geraten, diese bestehen zu lassen oder sie VOR der
Installation von OpenBSD zu installieren.
<li>Aus historischen Gründen speichert »q« Änderungen ab und verlässt
das Programme - »x« hingegen verlässt das Programme ohne zu speichern.
Dies ist genau das Gegenteil von dem, was Leute von anderen Umgebungen
her gewohnt sind. Vor dem Speichern von Änderungen fragt fdisk(8) nicht
nach - sei bei der Verwendung also sorgfältig.

</ul>

<a name="disklabel"></a>
<h2>14.2 - Benutzung von OpenBSDs disklabel(8)</h2>
<a name="disklabel.1"></a>
<h3>Was ist disklabel(8)?</h3>

<p>
Lies zunächst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a>-Handbuchseite.

<p>
Die Details wie Platten unter OpenBSD eingerichtet werden
unterscheiden sich auf den einzelnen Plattformen. Auf den Plattformen
<a href="../../de/i386.html">i386</a>,
<a href="../../de/amd64.html">amd64</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/zaurus.html">zaurus</a>
und <a href="../../de/armish.html">armish</a> findet die Platteneinrichtung in
zwei Phasen statt. Zuerst wird das OpenBSD-Slice unter Verwendung von
fdisk(8) auf der Festplatte definiert und dann mit disklabel(8) in
OpenBSD-Partitionen unterteilt.

<p>
Alle OpenBSD-Plattformen verwenden jedoch primär disklabel(8) für die
Verwaltung von OpenBSD-Partitionen. Plattformen, die ebenfalls fdisk(8)
einsetzen, legen alle disklabel(8)-Partitionen in einer einzelnen
fdisk-Partition an.

<p>
Labels beinhalten bestimmte Informationen über deine Festplatte; unter
anderem deine Plattengeometrie und Informationen über die Dateisysteme
auf deiner Platte. Sie beinhalten auch Informationen über deine Platte
selbst wie zum Beispiel Umdrehungsgeschwindigkeit, Interleave etc.
Diese Einträge existieren auf Grund früherer Notwendigkeiten und sind
meist nicht einmal korrekt: Mach dir also keine Gedanken darüber. Das
Disklabel wird dann vom Bootstrapprogramm genutzt, um das Laufwerk
anzusprechen und zu wissen, welche Dateisysteme sich auf dem Laufwerk
befinden. Weitere Informationen über Disklabel kannst du in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>-Handbuchseite
nachlesen.

<p>
Auf einigen Plattformen hilft disklabel, Architekturbegrenzungen bei
der Plattenpartitionierung zu überwinden. Zum Beispiel kann man auf
i386 nur vier primäre Partitionen anlegen;
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
benutzt eine dieser primären Partitionen, die dann *alle* deine
OpenBSD-Partitionen enthält (z.&nbsp;B. »swap«, »/«, »/usr«, »/var«
etc.) - und du hast noch drei weitere für andere Betriebssysteme übrig.

<a name="disklabel.2"></a>
<h3>disklabel(8) während der OpenBSD-Installation</h3>

<p>
Einer der Hauptteile der OpenBSD-Installation ist das erstmalige
Erzeugen der Labels. Während der Installation kannst du disklabel(8)
verwenden, um separate Partitionen zu erstellen. Als Teil des
Installationsprozesses kannst du deine Mountpunkte in disklabel(8)
definieren - im weiteren Verlauf oder auch nach der Installation kannst
du sie aber weiterhin ändern.

<p>
Obwohl es keinen »richtigen« Weg gibt, wie man ein Disklabel anlegt,
gibt es viele falsche. Bevor du versuchst, ein Label für deine Platte
anzulegen, wirf einen Blick auf <a href="faq4.html#Partitioning">diese
Diskussion</a> über das Partitionieren und Partitionsgrößen.

<p>
Um ein Beispiel für die Verwendung von disklabel(8) während der
Installation zu sehen, wirf einen Blick auf das Kapitel
<a href="faq4.html#Moredisklabel">Festplatte(n) einrichten</a>, das Teil der
<a href="faq4.html">Installationsanleitung</a> ist.


<p>

<a name="disklabel.3"></a>
<h3>disklabel(8) nach der Installation verwenden</h3>

<p>
Wenn dein System erst einmal installiert ist, solltest du disklabel
nicht mehr allzu oft benutzen müssen. Aber du kannst es gebrauchen, wenn
du z.&nbsp;B. Festplatten hinzufügen, welche entfernen oder auch einfach
umstrukturieren möchtest. Eines der ersten Dinge, die du dann machst,
ist dir den momentanen gültigen Disklabel anzusehen. Und das geht so:

<blockquote><pre>
# <b>disklabel wd0</b> &lt;-- <i>Or whatever disk device you'd like to view</i>
type: ESDI
disk: ESDI/IDE disk
label: SAMSUNG HD154UI 
duid: d920a43a5a56ad5f
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2907021
total sectors: 2930277168
boundstart: 64
boundend: 2930272065
drivedata: 0 

16 partitions:
#                size           offset  fstype [fsize bsize  cpg]
  a:          1024064               64  4.2BSD   2048 16384    1 # /
  b:          4195296          1024128    swap                   
  c:       2930277168                0  unused                   
  d:          4195296          5219424  4.2BSD   2048 16384    1 # /usr
  e:          4195296          9414720  4.2BSD   2048 16384    1 # /tmp
  f:         20972448         13610016  4.2BSD   2048 16384    1 # /var
  h:          2097632         34582464  4.2BSD   2048 16384    1 # /home
</pre></blockquote>

<p>
Beachte, dass bisher nur ein Teil des zur Verfügung stehenden
Plattenspeichers zugewiesen wurde.

Mit disklabel gibt es zwei verschiedene Modi für die Editierung des
Disklabels: ein eingebauter kommandozeilenbasierter Editor (mit diesem
hast du OpenBSD ursprünglich installiert) und ein vollständiger Editor
wie beispielsweise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">vi(1)</a>.
Den eingebauten kommandozeilenbasierten Editor wirst du vermutlich als
einfacher zu bedienen empfinden, da er dich durch alle Schritte führt
und nach Bedarf weitere Hilfe ausgibt - der Vollbildeditor hat
selbstverständlich auch seine Daseinsberechtigung.

<p>
Lass uns eine Partition zum gerade gezeigten System hinzufügen.

<p>
<blockquote>
<i>Warnung: Jedes Mal wenn du dein Disklabel editierst setzt du die
gesamten Daten auf deiner Platte einer großen Gefahr aus. Stell sicher,
dass du deine Daten gesichert hast, bevor du ein bestehendes Disklabel
modifizierst!</i>
</blockquote>

<p>
Wir werden hierfür den eingebauten kommandozeilenbasierten Editor
verwenden, der mit der Option -E von disklabel(8) aufgerufen wird.

<blockquote><pre>
# <b>disklabel -E wd0</b>
...
> a k
offset: [36680096] 
size: [2893591969] 1T
Rounding to cylinder: 2147483536
FS type: [4.2BSD] 
> p m
OpenBSD area: 64-2930272065; size: 1430796.9M; free: 364310.8M
#                size           offset  fstype [fsize bsize  cpg]
  a:           500.0M               64  4.2BSD   2048 16384    1 # /
  b:          2048.5M          1024128    swap                   
  c:       1430799.4M                0  unused                   
  d:          2048.5M          5219424  4.2BSD   2048 16384    1 # /usr
  e:          2048.5M          9414720  4.2BSD   2048 16384    1 # /tmp
  f:         10240.5M         13610016  4.2BSD   2048 16384    1 # /var
  h:          1024.2M         34582464  4.2BSD   2048 16384    1 # /home
  k:       1048575.9M         36680192  4.2BSD   8192 65536    1 
> q
Write new label?: [y] 
</pre></blockquote>

In diesem Fall war disklabel(8) nett und hat einen guten Startoffset
für die Partition berechnet. In den meisten Fällen wird das auch
funktionieren - falls du aber »Löcher« im Disklabel hast (d.&nbsp;h.
falls du eine Partition gelöscht hast oder dir das Leben unnötig schwer
machen willst) musst du eventuell zu Papier und Bleistift greifen und
den passenden Offset selbst ausrechnen.
Beachte, dass es gut möglich ist, dass Dinge hier fehlschlagen, obwohl
disklabel(8) einige Gültigkeitsüberprüfungen durchführt. Sei sicher,
dass du genau weißt, was die Bedeutung dieser Zahlen ist, die du gerade
eingibst.

<p>
Auf den meisten OpenBSD-Plattformen stehen sechzehn Disklabelpartitionen
zur Verfügung: von a bis p (einige »besondere« Systeme haben nur acht).
Jedes Disklabel sollte eine Partition namens c mit dem Dateisystemtyp
(fstype) »unused« aufweisen. Versuche niemals, ein Dateisystem auf c
zu erstellen. Auf dem Bootdevice ist a für die Rootpartition reserviert
und b für die Swappartition. Diese Einschränkung gilt nur für das
Bootdevice. Andere Devices können alle fünfzehn Partitionen außer c für
Dateisysteme nutzen.

<p>
<h3>Tipps und Tricks für disklabel</h3>
<ul>
<li><b>Hilfe erhalten:</b> Im kommandozeilenbasierten Modus kann man
mit Drücken von »?« eine Liste aller verfügbaren Kommandos anzeigen
lassen. »M« gibt die Handbuchseite von disklabel(8) aus.

<li><b>Auf Standardwerte zurücksetzen:</b> In einigen Fällen möchtest
du vielleicht komplett von vorne beginnen und alle bestehenden
Disklabelinformationen löschen. Das Kommando »D« wird das Label zurück
auf die Standardwerte setzen - als wenn noch nie ein Disklabel auf dem
Laufwerk gewesen wäre.

<li><b>Ein Disklabel duplizieren:</b> In einigen Fällen möchtest du
vielleicht die Partitionierung von einer Platte auf eine andere kopieren
- allerdings nicht 100%ig (zum Beispiel möchtest du zwar die gleichen
Partitionen haben, diese aber auf unterschiedlich großen Laufwerken).
Verwende den Modus -e (Vollbildeditor) von disklabel(8), kopiere die
Partitionen des Ausgangslaufwerks und füge die Zeilen in das neue
Laufwerk ein. Entferne dann die Partition c vom Ausgangslaufwerk und
speicher ab. Somit hast du nun das Plattenlayout auf das andere
Laufwerk kopiert, ohne die Basisparameter geändert zu haben.

<li>(sparc/sparc64) <b>Lege die Swappartition nicht am Anfang deiner
Platte an.</b>

<li>(i386, amd64) <b>Belasse die erste Spur ungenutzt:</b>
Auf einigen Plattformen muss die erste logische Spur ungenutzt
bleiben - sowohl von disklabel(8) als auch von fdisk(8). Dieser
Leitfaden wird manchmal umformuliert in »beginne mit deinen Partitionen
beim Sektor 63«, doch ist das NUR wahr, wenn es sich dabei auch um die
Größe einer Spur auf deiner Hardware handelt. Nimm niemals an, dass
das immer der Fall ist - disklabel wird dir mitteilen, wie viele Sektoren
vermutlich pro Spur vorliegen. Viele andere Plattformen gehen davon
aus, dass OpenBSD-Partitionen beim Sektor 0 beginnen.

<li><b>Devices ohne Disklabel:</b>
Falls ein Device momentan kein OpenBSD-Disklabel hat, dafür aber andere
Dateisysteme (zum Beispiel eine Platte mit zuvor angelegtem
FAT32-Dateisystem) wird der OpenBSD-Kernel ein Disklabel im Speicher
»anlegen«. Hiermit ist eine Grundlage für ein OpenBSD-Disklabel gegeben,
das dann auf die Platte geschrieben werden kann. Fall ein Disklabel
jedoch erstellt und auf die Platte geschrieben wurde und danach ein
Dateisystem angelegt wird, das nicht zu OpenBSD gehört, wird das
Disklabel nicht automatisch aktualisiert. Du musst dies manuell machen,
wenn du möchtest, dass OpenBSD auf dieses Dateisystem zugreifen kann.
Weitere Informationen hierüber befinden sich
<a href="faq14.html#foreignfsafter">weiter unten</a>.

<li><b>»q« gegen »x«:</b>
Aus historischen Gründen speichert »q« im kommandobasierten Editormodus
alle Änderungen ab und verlässt das Programm - »x« hingegen verlässt
das Programm, ohne zu speichern. Dies ist genau das Gegenteil von dem,
was viele Leute aus anderen Umgebungen gewohnt sind. Vor dem Speichern
von Änderungen warnt disklabel(8) jedoch, sodass »x« schnell und
ohne jeglichen Kommentar ausgeführt wird.

<li><b>Automatische Partitionierung:</b>
Neue Benutzer werden ermutigt, das Kommando »A« zur automatischen Erzeugung
eines empfohlenen disklabels zu nutzen.
Du kannst danach das automatisch erzeugte Label editieren oder verändern, wenn
die Notwendigkeit dafür besteht.

</ul>


<a name="NewDisk"></a>
<h2>14.4 - Hinzufügen weiterer Festplatten unter OpenBSD</h2>
<!-- XXX whoa. this section needs rework -->
<p>
Nun, nachdem du deine Festplatte <b>ORDNUNGSGEMÄSS</b> eingebaut hast,
musst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>nur i386 </i>) und auch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
verwenden, um deine Festplatte unter OpenBSD benutzen zu können.

<p>
Besitzer eines i386-Systems starten mit fdisk. Besitzer anderer
Architekturen können diesen Schritt einfach ignorieren. In dem Beispiel
weiter unten werden wir dem System ein drittes SCSI-ähnliches Laufwerk
hinzufügen.

<blockquote><pre>
# <b>fdisk -i sd2</b>
</pre></blockquote>

Das wird die »echte« Partitionstabelle der Festplatte für eine
ausschließliche Benutzung von OpenBSD initialisieren. Als nächstes musst
du ein Disklabel dafür erzeugen. Das wird wohl etwas verwirrend wirken.

<blockquote><pre>
# <b>disklabel -e sd2</b>

<i>(der Bildschirm wird leer, dein $EDITOR erscheint)</i>
type: SCSI
<i>... Bla ...</i>
sectors/track: 63
total sectors: 6185088
<i>... Bla ...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></blockquote>

Zunächst einmal ignoriere die Partition c - sie ist immer da und
Programme wie disklabel benötigen sie, um zu funktionieren!
Für OpenBSD ist fstype 4.2BSD. Die gesamte Größe der Festplatte ist
wird unter total sectors angegeben. Nehmen wir an, es handelt sich um
eine 3 Gigabyte große Festplatte. Drei Gigabytes in der Sprache der
Festplattenhersteller sind 3000 Megabytes. Dividiere also
6185088 mit 3000 (benutze
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1"
>bc(1)</a>).
Du erhältst 2061. Um jetzt Partitionsgrößen für a, d, e, f, g, ... zu
erstellen, rechne einfach X * 2061, um X Megabyte Platz auf dieser
Partition zu erhalten. Der Offset für deine erste Partition sollte
derselbe sein, wie unter sectors/track vorher in disklabels Ausgabe
angegeben. Bei uns ist es 63. Der Offset für jede Partition ist
hinterher eine Kombination aus der Größe und dem Offset jeder anderen
Partition (mit Ausnahme der Partition c, da sie keine Rolle in dieser
Gleichung spielt).

<p>
Wenn du aber nur eine Partition auf deiner Festplatte brauchst, zum
Beispiel, wenn du das ganze Ding nur zum Ablegen von Webseiten oder
einem Heimatverzeichnis oder etwas anderem nutzen willst, nimm einfach
die gesamte Größe der Platte und ziehe die Sektoren pro Spur davon ab:
6185088 - 63 = 6185025.  Deine Partition ist:

<blockquote><pre>
    d:  6185025       63    4.2BSD     1024  8192    16
</pre></blockquote>

<b>Wenn dir das alles unnötig komplex erscheint, kannst du disklabel -E
benutzten, um den selben Partitionierungsmodus zu erhalten, den du auf
deiner Installationsdisk hattest!</b>
Dort kannst du 96M benutzen, um 96 Megabytes anzugeben (oder 96G für 96
Gigabytes).

<p>
Das war eine Menge. Aber du bist noch nicht fertig. Zuletzt musst du
noch das Dateisystem auf der Festplatte mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
anlegen.

<blockquote><pre>
# <b>newfs sd2d </b>
</pre></blockquote>

<p>
Oder wie auch immer deine Festplatte nach dem
OpenBSD-Plattennummerierungsschema heißen mag. (Siehe einfach in der
Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
nach, um zu sehen, wie die Platte von OpenBSD benannt wurde.)

<p>
Nun überleg dir, wohin du deine gerade neu geschaffene Partition mounten
willst. Sagen wir einfach mal /u. Erzeuge zunächst erstmal /u. Dann
mounte sie.

<blockquote><pre>
# <b>mount /dev/sd2d /u</b>
</pre></blockquote>

<p>
Zuletzt musst du sie noch zur
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
hinzufügen.

<blockquote><pre>
/dev/sd2d /u ffs rw 1 1
</pre></blockquote>

<p>
Was aber, wenn du ein existierendes Verzeichnis wie zum Beispiel
/usr/local auslagern willst?
In diesem Falle solltest du die neue Platte als /mnt einhängen und /usr/local
nach /mnt kopieren.
Beispiel:

<blockquote><pre>
# <b>cd /usr/local && pax -rw -p e . /mnt</b>
</pre></blockquote>

Mounte die neue Platte unter /mnt und
benutze <tt>cpio -pdum</tt>, um /usr/local in das Verzeichnis /mnt zu
kopieren. Passe die Datei

Editiere
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"
>/etc/fstab(5)</a> dergestalt, dass die Partition /usr/local nun auf /dev/sd2d
(deine frisch formatierte Partition) zeigt.
Beispiel:

<blockquote><pre>
<b>/dev/sd2d /usr/local ffs rw 1 1</b>
</pre></blockquote>

<p>
Starte in den Singleuser-Modus mit <b>boot -s</b> neu, verschiebe
das existierende /usr/local nach /usr/local-backup (oder lösche es
gleich, wenn du mutig bist) und lege ein leeres Verzeichnis namens
/usr/local an. Starte dann das System neu und voila: Die Dateien sind
da!

<p>
<a name="SwapFile"></a>
<a name="Swap"></a>
<h2>14.5 - Wie wird Auslagerung gehandhabt?</h2>

<h3>14.5.1 - Über Auslagerung</h3>
Historisch betrachtet wurden alle Arten von Regeln aufgestellt, um
Administratoren eine Richtschnur darüber zur Hand zu geben, wieviel
Auslagerungsspeicher sie auf ihren Maschinen zu konfigurieren hätten.
Das Problem dabei ist, natürlich, dass es wenige »normale« Anwendungen gibt.

<p>
Eine nicht-offensichtliche Nutzung von Auslagerung ist, dass es ein Platz ist,
an den der Kernel eine Kopie darüber, was sich im Moment einer Systempanik im
Speicher befindet, für die spätere Analyse abladen kann.
Damit dies funktionieren kann, muss eine Auslagerungs-Partition (keine
Auslagerungs-Datei) vorhanden sein, die mindestens so groß ist wie der
Hauptspeicher.
Im Normalfall wird das System eine Kopie dieses Dumps während des
Systemneustarts nach <tt>/var/crash</tt> kopieren, sodass, wenn du möchtest,
dass all dies automatisch geschieht, du ausreichenden <i>freien</i>
Speicherplatz auf <tt>/var</tt> benötigst.
Allerdings kannst du das System auch in den Ein-Benutzer-Modus booten und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8"
>savecore(8)</a> benutzen, um den Dump an eine andere Stelle zu verfrachten.

<p>
Viele Arten von Systemen können auch ohne Auslagerung passend konfiguriert
sein.
So sollten zum Beispiel Firewalls im normalen Betrieb nicht auslagern.
Basiert deine Firewall auf Flash-Speicher, so magst du einen (kleinen) Nutzen
davon haben, keine Auslagerungs-Partition zu allozieren, obwohl, in den meisten
Fällen, eine Auslagerungs-Partition auch nicht wirklich schmerzt;
die meisten Laufwerke haben mehr als genug Platz, um ein kleines bisschen davon
für Auslagerung zu allozieren.

<p>
Es gibt alle Arten von Tipps für die Optimierung von Auslagerung (wo auf der
Platte, separate Platte, etc.), aber wenn du dich in einer Situation befindest,
in der die Optimierung von Auslagerung ein Thema ist, so benötigst du
vielleicht mehr Hauptspeicher.
Generell gesagt ist die beste Optimierung von Auslagerung, keine solche zu
benötigen.

<p>
Unter OpenBSD wird Auslagerung von dem Programm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8"
>swapctl(8)</a> verwaltet, das Auslagerungs-Geräte und -Dateien hinzufügt,
entfernt, auflistet und priorisiert.

<h3>14.5.2 - Auf eine Partition auslagern</h3>

<p>
Unter OpenBSD wird die Partition »b« des Bootlaufwerks standardmäßig und
automatisch für Auslagerung genutzt.
Hierfür wird keinerlei Konfiguration benötigt.
Wünschst du keine Auslagerung auf dem Boolaufwerk zu nutzen, definiere keine
Partition »b«.
Wünschst du die Nutzung von Auslagerung auf einer anderen Partition oder auf
anderen Laufwerken, so musst du diese Partitionen in <tt>/etc/fstab</tt> mit
Zeilen wie den Folgenden definieren:

<blockquote><pre>
/dev/sd3b none swap sw 0 0
/dev/sd3d none swap sw 0 0
</pre></blockquote>

<h3>14.5.3 - In eine Datei auslagern</h3>

(Hinweis: Wenn du in eine Datei swappen willst, weil du immer
»virtual memory exhausted«-Fehler bekommst, solltest du lieber
versuchen, deine Begrenzungen auf Prozessebene mittels

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1"
>csh(1)</a>'s unlimit,
oderr
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1"
>sh(1)</a>'s ulimit zu erhöhen.)

<p>
Manchmal erweist sich deine erste Vermutung darüber, wieviel Auslagerung du
brauchst, als falsch, und du musst zusätzlichen Auslagerungs-Speicherplatz
hinzufügen, zuweilen in Eile (wie in »Jungs, wenn es in dieser Geschwindigkeit
Auslagerung verbrennt, sind wir in fünf Minuten eingekeilt«).
Findest du dich in dieser Situation, mag das Hinzufügen von zusätzlichem
Auslagerungs-Speicherplatz in Form einer Datei auf einem existierenden
Dateisystem eine schnelle Hilfe sein.

<p>
Die Datei darf nicht auf einem
Dateisystem mit Softupdates liegen (was ja standardmäßig deaktiviert
ist). Finde zunächst einmal heraus, wie viel Swap du momentan hast
und wie viel du davon benutzt. Das geht mit dem Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
recht einfach. Zum Beispiel mit diesem Aufruf:

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></blockquote>

<p>
Das zeigt sowohl alle Geräte, die momentan für das Swappen benutzt
werden, als auch ihre momentane Statistik an. Im obigen Beispiel gibt es
nur ein Gerät namens swap_device. Das ist der vordefinierte Bereich auf
der Platte, der für das Swappen benutzt wird (wird im Übrigen als
Partition b bei Disklabels angezeigt). Wie du auch sehen kannst, wird
das Gerät zurzeit nicht sonderlich belastet oder vielmehr benutzt.
Aber für den Zweck dieses Dokumentes tun wir einfach so, als wenn noch
weitere 32 MB benötigt werden würden.

<p>
Der erste Schritt, um eine Datei als Swapbereich zu nutzen, ist die
Datei zu erzeugen. Am besten macht man das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Hier ist ein Beispiel, das die 32 M große Datei <i>/var/swap</i>
erzeugt.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Nachdem das erledigt ist, können wir jetzt das Swappen auf dieses Device
richten. Benutze einfach das folgende Kommando, um das Swappen auf
dieses Device zu lenken:

<blockquote><pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre></blockquote>

<p>
Jetzt müssen wir noch prüfen, ob sie auch korrekt zu unserer Liste der
Swapdevices hinzugefügt wurde.

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>

<p>
Jetzt, da die Datei erzeugt wurde und in sie hinein geswappt wird, musst
du noch eine Zeile in deine <i>/etc/fstab</i> hineinschreiben, so
dass die Datei beim nächsten Booten auch benutzt wird. Wenn diese Zeile
nicht hinzugefügt wird, wird dieses Swapdevice nicht konfiguriert.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></blockquote>

<a name="SoftUpdates"></a>
<h2>14.6 - Softupdates</h2>

<p>
Softupdates basieren auf einer Idee, die von
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg&nbsp;Ganger
und Yale&nbsp;Patt</a> vorgeschlagen wurde, und wurden für FreeBSD von
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a> entwickelt.
Softupdates erzwingen eine gewisse Reihenfolge der
Buffercacheoperationen, was die Anforderungen für das Entfernen des
FFS-Codes ermöglicht, der für das synchrone Schreiben von
Verzeichniseinträgen zuständig ist. Daher konnte ein großer
Geschwindigkeitsanwachs in der Leistung der Schreibzugriffe auf Platten
festgestellt werden.

<p>
Die Aktivierung von Softupdates muss mit einer Option während dem
Mounten ausgeführt werden. Wenn eine Partition mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
gemountet wird, kannst du angeben, dass du Softupdates auf dieser
Partition aktivieren möchtest. Dies ist ein Beispieleintrag für
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i>,
der eine Partition <i>sd0a</i> auflistet, die wir mit Softupdates
gemountet haben möchten.

<blockquote><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></blockquote>

<p>
Hinweis für Sparc-Anwender: Aktiviere Softupdates nicht auf sun4- oder
sun4c-Maschinen. Diese Architekturen unterstützen nur eine sehr
begrenzte Menge Kernelspeicher und können diese Funktion nicht
verwenden. Trotzdem sind sun4m-Maschinen in Ordnung.

<p>
<a name="Boot386"></a>
<a name="BootAmd64"></a>
<h2>14.7 - Wie booten OpenBSD/i386 und OpenBSD/amd64?</h2>
Der Bootprozess für OpenBSD/i386 und OpenBSD/amd64 ist nicht einfach und verstehen, wie es funktioniert, kann nützlich sein, um ein Problem zu lösen, wenn Dinge
nicht laufen.
Während des Bootprozesses gibt es vier Schlüsselereignisse:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> Der »Master Boot Record« ist,
was sich in den ersten 512 Bytes des Laufwerks findet.
Er beinhaltet
die primäre Partitionstabelle und ein kleines Programm, um den Partition
Boot Record (PBR) zu laden. Bedenke, dass in einigen Umgebungen der
Begriff MBR verwendet wird, um nur auf den Codeteil dieses ersten Blocks
auf der Platte zu verweisen, statt auf den gesamten ersten Block
(einschließlich der Partitionstabelle).
Es ist äußerst wichtig, die Bedeutung von »initialize the MBR« zu verstehen -
in der Terminologie von OpenBSD bedeutet es, den kompletten MBR neu zu
schreiben und die existierende Partitionstabelle zu löschen, und nicht nur den
Code, wie es eventuell einige andere Systeme machen.
Oft wirst du dies nicht tun wollen.
Darum benutze stattdessen fdisk(8)s Kommandozeilenoption »-u«
(»<tt>fdisk -u wd0</tt>«), um den MBR-Boot-Code (erneut) zu installieren.

<p>
Obwohl OpenBSD seinen eigenen MBR-Code besitzt, wirst du nicht gezwungen, ihn
zu verwenden, da so gut wie jeder MBR OpenBSD booten kann.
Der MBR wird von
dem Programm fdisk(8) verändert, welches verwendet wird, um die
Partitionstabelle zu editieren und um ebenfalls den MBR-Code auf die
Platte zu schreiben.

<p>
OpenBSDs MBR kündigt sich selbst mit der Meldung an:

<blockquote><pre>
Using drive 0, partition 3.
</pre></blockquote>

die die Platte und Partition anzeigt, von der er den PBR laden wird.
Zusätzlich zu dem Offensichtlichen, zeigt er ebenfalls einen angehängten
Punkt ("."), welcher darauf deutet, dass diese Maschine in der Lage ist,
LBA-Übersetzung zum Booten zu verwenden. Wenn die Maschine nicht in der
Lage ist, LBA-Übersetzung zu verwenden, wäre der obige Punkt mit einem
Semikolon (»;«) ausgewechselt worden, das auf CHS-Übersetzung deutet:

<blockquote><pre>
Using Drive 0, Partition 3;
</pre></blockquote>

Bedenke, dass der angehängte Punkt oder das angehängte Semikolon als ein
Indikator für den neuen OpenBSD-MBR angesehen werden kann, der mit
OpenBSD 3.5 eingeführt wurde.

<p>
<li><b><i>Partition Boot Record (PBR):</i></b>
Der »Partition Boot Record«, auch der PBR oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a> genannt wird (nach dem Namen der Datei, der den Code
beinhaltet), ist, was sich in den ersten 512 Byte einer OpenBSD-Partition
findet.
Der PBR ist der »First-Stage Boot-Lader« für OpenBSD.
Er wird vom MBR-Code geladen und hat die Aufgabe, OpenBSDs
Secondstage-Bootloader
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
zu laden.
Wie der MBR ist auch der PBR eine sehr kleine Sektion von Code und Daten
- insgesamt nur 512 Byte. Das ist nicht genug, um eine vollständig
dateisystembewusste Applikation zu laden, sodass, statt den PBR
<tt>/boot</tt> auf der Platte ausfindig machen zu lassen, die
BIOS-verfügbare Stelle von <tt>/boot</tt> physikalisch in den PBR
während der Installation eingetragen wird.

<p>
Der PBR wird von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>
installiert, das
<a href="faq14.html#InstBoot">später in diesem Dokument</a> genauer
beschrieben wird.
Der PBR kündigt sich selbst mit der Meldung an:
<blockquote><pre>
Loading...
</pre></blockquote>
die einen Punkt für jeden Dateisystemblock anzeigt, den er versucht
auszulesen. Ebenfalls zeigt der PBR an, ob er LBA oder CHS zum Laden
verwendet - wenn er CHS-Übersetzung verwendet, zeigt er eine Nachricht
mit einem Semikolon an:
<blockquote><pre>
Loading;...
</pre></blockquote>

<p>
<li><b><i>Secondstage-Bootloader, <tt>/boot</tt>:</i></b> <tt>/boot</tt>
wird vom PBR geladen und hat die Aufgabe, auf das OpenBSD-Dateisystem
durch das BIOS der Maschine zuzugreifen und den aktuellen Kernel
ausfindig zu machen und zu laden. boot(8) übergibt ebenfalls
verschiedene Optionen und Informationen an den Kernel.
<p>
boot(8) ist ein interaktives Programm. Nachdem es geladen ist versucht
es, <tt>/etc/boot.conf</tt> ausfindig zu machen und zu laden, wenn sie
existiert (was auf einer standardmäßigen Installation nicht der Fall
sein muss) und verarbeitet sämtliche Kommandos in ihr. Wenn es durch
<tt>/etc/boot.conf</tt> nicht anders angeordnet wurde, gibt es dem
Benutzer einen Prompt aus:

<blockquote><pre>
probing: pc0 com0 com1 apm mem[636k 190M a20=on]
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.21
boot>
</pre></blockquote>

Es gibt dem Benutzer (standardmäßig) fünf Sekunden lang die Möglichkeit,
andere Aufgaben auszuführen, aber wenn keine vor dem Ablauf der Zeit
eingegeben wurde, startet es sein normales Verhalten: Den Kernel
<tt>bsd</tt> von der root-Partition der ersten Festplatte laden.
Der Secondstage-Bootloader untersucht deine Systemhardware durch das
BIOS (da der OpenBSD-Kernel noch nicht geladen ist). Oben kannst du ein
paar Dinge sehen, die er gesucht und gefunden hat:
<ul>
<li><b>pc0</b> - Die Standardtastatur und -bildschirmausgabe eines
i386-Systems.
<li><b>com0, com1</b> - Zwei serielle Schnittstellen
<li><b>apm</b> - »Advanced Power Management«-BIOS-Funktionen
<li><b>636k 190M</b> - Die Menge des herkömmlichen (unterhalb von 1 M)
und erweiterten (oberhalb von 1 M) Speichers, den er gefunden hat
<li><b>fd0 hd0+</b> - Die BIOS-Laufwerke, die er gefunden hat: in diesem
Fall ein Disketten- und ein Festplattenlaufwerk.
</ul>

Das »+«-Zeichen nach hd0 zeigt an, dass das BIOS <tt>/boot</tt>
mitgeteilt hat, dass diese Festplatte über LBA angesprochen werden kann.
Wenn eine erstmalige Installation ausgeführt wird, siehst du ab und zu
einen * nach einer Festplatte - dies deutet auf eine Platte hin, die so
scheint, als wenn sie kein OpenBSD-Disklabel beinhaltet.

<p>
<li><b><i>Kernel: <tt>/bsd</tt></i>:</b> Dies ist das Ziel des
Bootprozesses: Den OpenBSD Kernel in den RAM laden und sauber
auszuführen.  Wenn der Kernel einmal geladen wurde, kann OpenBSD direkt
auf die Hardware zugreifen, nicht mehr durch das BIOS.

</ol>

So, der Anfang vom Start des Bootprozesses könnte wie folgt aussehen:

<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.21
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2013 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 5.3 (GENERIC) #50: Tue Mar 12 18:35:23 MDT 2013
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
   ...
</pre></blockquote>


<h3>Was fehlschlagen kann</h3>
<ul>
<li><b>Beschädigter/ungültiger/inkompatibler MBR:</b>
Normalerweise hat eine gebrauchte Festplatte irgendeinen MBR-Code
installiert, aber wenn die Platte neu ist oder von einer anderen
Plattform übernommen wurde,
UND du nicht mit »w« auf die Frage »Use (W)hole disk or (E)dit the MBR?«
des <a href="faq4.html#InstDisks">Installations-Prozesses</a> geantwortet hast,
so kann es sein, dass am Ende das Laufwerk keinen gültigen MBR besitzt, und
daher nicht startbar ist, obwohl es eine gültige Partitionstabelle besitzt.

<p>
Du kannst den OpenBSD-MBR auf deine Festplatte unter Verwendung vom
Programm fdisk installieren. Boote dein Installationsmedium und wähle
Shell aus, um auf den Kommandoprompt zu gelangen:

<blockquote><pre>
# <b>fdisk -u wd0</b>
</pre></blockquote>

Du kannst auch einen bestimmten MBR auf deine Platte mit fdisk
schreiben:
<blockquote><pre>
# <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre></blockquote>

Hiermit wird die Datei <tt>/usr/mdec/mbr</tt> als dein System-MBR
installiert. Diese bestimmte Datei einer standardmäßigen
OpenBSD-Installation ist ebenfalls der standardmäßige MBR, der in
fdisk integriert wurde. Es könnte aber jeder andere MBR hier angegeben
werden.

<li><b>Ungültige <tt>/boot</tt>-Ortsangabe im PBR installiert:</b>
Wenn installboot(8) den Partition Boot Record installiert, schreibt er
die Blocknummer und den Offset von <tt>/boot</tt>s Inode in den PBR.
Daher wird das Löschen oder Ersetzen von <tt>/boot</tt> ohne
erneutes Ausführen von <a href="faq14.html#InstBoot">installboot(8)</a>
dein System in einen Zustand versetzen, in dem es nicht mehr booten
kann, da der PBR laden wird, auf was auch immer die Inode zeigt, die
angegeben wurde. Das wird vermutlich nicht mehr der erhoffte
Secondstage-Bootloader sein!

Seit <tt>/boot</tt> unter Verwendung von BIOS-Aufrufen ausgelesen wird,
waren ältere Versionen vom PBR sehr sensibel auf
BIOS-Plattenübersetzungen. Wenn du die Plattengeometrie (z.&nbsp;B.
wenn du die Platte aus einem Computer genommen hast, der
CHS-Übersetzung verwendet hat, und es in einen steckst, der
LBA-Übersetzung verwendet oder sogar die Übersetzungsoption im BIOS
geändert hast) geändert hast, wird es <i>für das BIOS so wirken</i>, als
wenn sie an einem anderen Ort liegen würde (es muss auf einen anderen
nummerischen Block zugegriffen werden, um die gleichen Daten von der
Platte zu erhalten), sodass du installboot(8) erneut ausführen musst,
bevor das System neugestartet werden kann. Der neue (von OpenBSD 3.5 und
später) PBR ist sehr viel toleranter im Bezug auf Übersetzungsänderungen.
</ul>

Da der PBR sehr klein ist, ist die Anzahl der Fehlermeldungen sehr
begrenzt und recht kryptisch. Typische Nachrichten sind:

<ul>
<li><b>ERR R</b> - Das BIOS gab einen Fehler zurück als es versucht hat,
einen Block von der Platte zu lesen.
Es bedeutet meistens genau das, was es aussagt: Von deiner Platte konnte
nicht gelesen werden.
<li><b>ERR M</b> - Eine ungültige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>-Nummer
wurde aus dem Header des Secondstage-Bootloaders gelesen. Dies bedeutet
normalerweise, dass, was auch immer eingelesen wurde, NICHT
<tt>/boot</tt> war, was darauf hinweist, dass installboot(8) nicht
korrekt ausgeführt wurde, die /boot-Datei geändert wurde oder du die
Fähigkeit deines BIOS erschöpft hast, um von einer
<a href="#LargeDrive">großen Platte</a> zu lesen.

</ul>
Andere Fehlermeldungen werden in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>-Handbuchseite ausführlich besprochen.

<p>
Für weitere Informationen über den i386-Bootprozess, siehe:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.html"
>http://www.ata-atapi.com/hiw.htm</a> Hale Landis' »How it Works«-Dokumente.
</ul>

<a name="LargeDrive"></a>
<h2>14.8 - Welche Probleme treten bei großen Festplatten mit OpenBSD
auf?</h2>

<p>
OpenBSD unterstützt sowohl FFS- als auch FFS2- (ebenfalls bekannt als
UFS und UFS2) Dateisysteme. FFS ist das historische OpenBSD-Dateisystem,
FFS2 seit Version 4.3 verfügbar. Bevor die speziellen Grenzen der
jeweiligen Systeme betrachtet werden, müssen wir zuerst auf ein paar
generelle Systemeinschränkungen eingehen.

<p>
Selbstverständlich sind die Fähigkeit eines Dateisystems und die
Fähigkeit einer bestimmten Hardware zwei unterschiedliche Dinge.
Eine neuere 250 G große IDE-Festplatte kann unter Umständen nicht mit
älteren (vor >137G-Standard) Interfaces funktionieren (obwohl sie
meistens einwandfrei arbeiten) und einige sehr alte SCSI-Adapter sind
bekannt dafür, dass sie Probleme mit moderneren Laufwerken haben und
einige alte BIOSe werden hängen, wenn sie einer modern bestückten
Festplatte begegnen.
Du musst natürlich die Fähigkeiten deiner Hardware und deines Starter-Codes
respektieren.

<h3>Partitionsgröße und Lokalitätsbegrenzungen</h3>
Leider ist die volle Funktionalität des OS nicht verfügbar, bis
NACHDEM das OS in den Speicher geladen wurde. Der Bootprozess verwendet
(und ist daher auch darauf beschränkt) die Boot-ROM des Systems.

<p>
Aus diesem Grund muss die /bsd-Datei (der Kernel) innerhalb des vom
Boot-ROM adressierbarem Bereich liegen. Das bedeutet für einige ältere
i386-Systeme, dass die root-Partition vollständig innerhalb der ersten
504 M liegen muss, aber neuere Computer können diese Grenze bei 2 G,
8 G, 32 G, 128 G oder mehr haben. Es ist ebenfalls sinnvoll zu erwähnen,
dass viele relativ neue Computer, die Laufwerke mit mehr als 128 G
Speicher unterstützen tatsächlich eine BIOS-Begrenzung für die ersten
128 G für das Booten haben. Du kannst diese Systeme mit großen
Laufwerken betreiben, aber deine root-Partition muss in dem Bereich
liegen, der vom Boot-ROM unterstützt wird.

<p>
Bedenke, dass es möglich ist, ein 40 G großes Laufwerk in einen alten
486er einzubauen und auf diesem OpenBSD mit einer großen Partition zu
installieren und zu denken, dass du erfolgreich die vorherige Regel
gebrochen hast. Trotzdem kann es dich auf einem höchst unangenehmen Weg
verfolgen:

<ul>
 <li>Du installiert eine 40 G /-Partition. Es funktioniert, da das
 Basis-OS und alle seine Dateien (einschließlich /bsd) innerhalb der
 ersten 504 M liegen.
 <li>Du benutzt das System und endest mit mehr als 504 M Dateien auf
 ihm.
 <li>Du aktualisiert und kopierst deinen neuen /bsd über den alten.
 <li>Du startest neu.
 <li>Du bekommst eine Meldung wie »ERR M« oder andere Probleme während
 dem Booten.
</ul>
<p>
Warum? Weil, wenn du eine neue /bsd-Datei »über« die alte kopierst,
überschreibt sie nicht die alte - ihr wird einem neuen Ort auf der Platte
zugewiesen, möglicherweise außerhalb der 504-M-Grenze, die das
BIOS hat. Der Bootloader wird nun nicht mehr in der Lage sein, die
/bsd-Datei zu erhalten und das System hängt.

<p>
Um OpenBSD zum Booten zu bringen, müssen die Bootloader (biosboot(8) und
<tt>/boot</tt> im Falle von i386/amd64) und der Kernel (<tt>/bsd</tt>)
innerhalb des Bereiches sein, den die Boot-ROM unterstützt und
innerhalb ihrer eigenen Fähigkeiten. Um sicher zu gehen, ist die Regel
einfach:

<blockquote>
<b>Die gesamte root-Partition muss innerhalb des vom Computer-BIOS
(oder Boot-ROM) adressierbaren Speichers liegen.</b>
</blockquote>

<p>
Einige Nicht-i386-Anwender denken, dass sie dies nicht betrifft, jedoch
haben die meisten Plattformen eine Art Begrenzung des ROMs bezüglich der
Plattengröße. Herauszufinden, wie groß diese Begrenzung denn nun
tatsächlich ist, kann schwer sein.

<p>
Dies ist ein weiterer guter Grund <a href="faq4.html#Partitioning">deine
Festplatte zu partitionieren</a>, statt nur eine große Partition zu
verwenden.

<h3>Zeit- und Speicheranforderungen von fsck(8)</h3>
Eine weitere Überlegung mit großen Dateisystemen ist die Zeit und der
Speicher, die benötigt werden, um as Dateisystem nach einem Crash oder
einer Stromunterbrechung einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
zu unterziehen.
Man sollte nicht ein 120 G großes Dateisystem auf ein System mit 32 M
RAM setzen und erwarten, dass es fsck(1) erfolgreich nach einem Crash
ausführt. Eine grobe Richtlinie ist, dass das System zumindest 1 M
Arbeitsspeicher für jedes 1 G des Plattenspeichers haben sollte, um
erfolgreich fsck gegen die Platte auszuführen. Zu diesem Zeitpunkt
kann zwar geswappt werden, doch wird dies mit einem großen
Geschwindigkeitseinbruch geschehen. In den meisten Fällen ist daher
davon abzuraten - es sei denn es gibt spezielle Gründe dafür.

<p>
Die benötigte Zeit, um fsck gegen ein Laufwerk auszuführen kann ein
Problem werden, sobald das Dateisystem an Größe gewinnt. Du musst fsck
aber nur auf den Plattenspeicher anwenden, der tatsächlich zu
gemounteten Dateisystemen gehört. Dies ist ein weiterer Grund, NICHT
sofort deinen gesamten Plattenbereich zu allokieren, nur weil er
vorhanden ist.
Dateisysteme nur lesend oder gar nicht gemountet zu
haben hilft dabei, sie beim nächsten Stolpern über das Stromkabel
keinem erneuten fsck(8) zu unterziehen.
Die Anzahl an »inodes« (durch Nutzung der newfs-Option -i) zu reduzieren kann
ebenfalls den Zeitbedarf von fsck verbessern -- vorausgesetzt, dass du sie
wirklich nicht benötigst.

<p>
Falls du mehrere Platten in deinem System hast denke bitte daran, dass
nach einem Absturz alle Platten gleichzeitig mit fsck(8) überprüft
werden, sodass deutlich mehr RAM pro Platte benötigt wird.

<h3>FFS gegen FFS2</h3>
Mit FFS unterstützt OpenBSD ein individuelles Dateisysteme von bis zu
2<sup>31</sup>-1 oder 2.147.483.647 Blocks, und da jeder Block 512 Byte groß
ist, ist dies ein bisschen weniger als 1&nbsp;TB.
FFS2 ist in der Lage, deutlich größere Dateisysteme zu unterstützen,
obwohl andere Grenzen längst erreicht sind, bevor das Dateisystem voll
ausgereizt ist.

<p>
Der Boot-/Installationskernel <i>unterstützt nur FFS</i> (kein FFS2),
sodass wichtige Systempartitionen (<tt>/, /usr, /var, /tmp</tt>) nicht
mit FFS2 formatiert werden sollten, da ansonsten Wartungsprobleme
auftreten könnten (es sollte ohnehin keinen Grund geben, warum diese
Partitionen so riesig sein sollten). Deshalb sollten sehr große
Partitionen nur für Partitionen wie <tt>/home, /var/www, /bigarray</tt>
etc. genutzt werden, die nicht entscheidend für das System sind.

<p>
Beachte, dass nicht alle Controller und Laufwerke große Platten
unterstützten. <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ami&amp;sektion=4"
>ami(4)</a> zum Beispiel unterstützt maximal 2&nbsp;TB pro logischem
Volumen.
Sei dir immer bewußt, was verfügbar war, wenn ein Kontroller oder eine
Schnittstelle produziert wurde, und verlasse dich nicht auf »die Stecker
passen«.

<p>
<h3>Laufwerke größer als 2&nbsp;TB</h3>
Das MBR-System, das auf PCs genutzt wird, versteht sich nur im Umgang mit
Laufwerken von bis zu 2&nbsp;TB Größe.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8"
>fdisk(8)</a> zeigt die Größe von Laufwerken größer 2&nbsp;TB als 2&nbsp;TB an.
Dies behindert in keinster Weise OpenBSD's Fähigkeit, größere Laufwerke nutzen
zu können, da der MBR nur benutzt wird, um das Betriebssystem urzuladen; ist
jedoch das Betriebssystem einmal in Betrieb, so werden die Dateisysteme durch
das »disklabel« definiert, welches kein 2&nbsp;TB Limit besitzt.

<p>
Um ein Laufwerk zu nutzen, das größer als 2&nbsp;TB ist, erzeuge auf dem
Laufwerk eine OpenBSD-Partition mit Hilfe von fdisk, und zwar in der Größe, die
dir fdisk ermöglicht.
Kennzeichnest du dann das Laufwerk mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a>, so nutze die Option "b", um die OpenBSD-Grenzen
(die standardmäßig auf die Größe der OpenBSD-fdisk-Partition eingestellt sind)
so zu definieren, dass sie das gesamte Laufwerk einschließen.
Nun kannst du deine Partitionen genauso erzeugen, wie du es wünschst.
Allerdings musst du natürlich die Möglichkeiten deines BIOS respektieren, dass
die Einschränkung haben wird, einzig die fdisk-Partitionen zu verstehen, sodass
deine Partition "a" komplett innerhalb der von fdisk verwalteten Bereiche des
Laufwerks liegen sollte, zusätzlich zu anderen Einschränkungen des BIOS.

<p>
<a name="InstBoot"></a>
<h2>14.9 - Installieren von Bootblocks - i386/amd64-spezifisch</h2>

<p>
OpenBSD besitzt ein sehr robustes Systemladeprogramm (»Bootloader«), das
recht gleichgültig gegenüber verschiedenen Laufwerksgeometrien ist,
allerdings ist es hochsensibel gegenüber der Position von
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>/boot</a></tt> auf der Festplatte. Falls du Änderungen durchführst,
die boot(8) auf der Platte verschieben (tatsächlich oder nur eine neue
I-Node), so wirst du dein System »beschädigen« - es wird nicht mehr
hochfahren.
Um den »Bootblock« zu reparieren, sodass du einen normalen Systemstart
durchführen kannst, lege einfach eine startbare CD-ROM in dein Laufwerk (oder
nutze eine startbare Diskette), und gib am Bootprompt »<tt>boot hd0a:/bsd</tt>«
ein, um den Systemstart von der ersten Festplatte (nicht der CD-ROM oder der
Diskette) zu erzwingen.
Deine Maschine sollte normal starten.
Nun musst du den Firststage-Bootloader
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>) basierend auf der neuen Position von <tt>/boot</tt>
erneut installieren, indem du das Programm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386"
>installboot(8)</a> aufrufst.

<p>
In unserem Beispiel gehen wird davon aus, dass du von sd0
bootest (für IDE wäre es wd0 etc.).

<blockquote><pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre></blockquote>

Beachte, da dass Dateisystem im Moment eingehängt ist, dass »/boot« die
physische Position der Datei »boot« ist, die du benutzen möchtest, wenn das
System normal startet.
Wäre deine Situation ein wenig anders, und hättest du von CD-ROM gestartet und
deine Partition »a« unter /mnt eingehängt, so würde dies stattdessen
wahrscheinlich »/mnt/boot« sein.
installboot(8) macht hier zwei Dinge - es installiert die Datei »biosboot«
dahin, wo es im »Partition Boot Record« stehen muss, und modifiziert es für die
tatsächlichen physischen Position der Datei «/boot«.

<a name="Backup"></a>
<h2>14.10 - Vorbereitung auf Katastrophen -
Erzeugen von Backups und Wiederherstellung vom Band.</h2>

<h3>Einführung:</h3>

<p>
Wenn du so etwas wie einen Produktionsserver laufen lassen willst, ist
es ratsam, irgendeine Form des Backups für den Fall zu haben, dass eine
deiner Festplatten ausfällt, oder die Daten aus einem anderen Grund verloren
sind.

<p>
Diese Information wird dir helfen, die Standardwerkzeuge
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
zu benutzen, die als Teil von OpenBSD ausgeliefert werden.
Fortgeschrittenere Backup-Dienstprogramme, wie
»<a href="http://www.amanda.org">Amanda</a>« und
»<a href="http://www.bacula.org">Bacula</a>« sind als
<a href="faq15.html#PkgMgmt">Pakete</a> verfügbar, um mehrere Sever auf
Festplatte und Bandlaufwerk zu sichern.

<h3>Backup aufs Band bringen:</h3>

<p>
Um sein Backup auf ein Band zu bringen, muss man wissen, wo die
Dateisysteme gemountet sind. Das findet man mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)"</a>-Kommando
am Shellprompt heraus. Dabei sollte eine Ausgabe wie diese
herauskommen:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a,
was ein SCSI-ähnliches, wahrscheinlich fest installiertes Laufwerk 0, Partition
a indiziert.
Das Dateisystem /usr befindet sich auf sd0h, was ein SCSI-ähnliches,
wahrscheinlich fest installiertes Laufwerk 0, Partition h indiziert.

<p>
Ein weiteres Beispiel einer etwas größeren Mounttabelle könnte so
aussehen:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
In diesem fortgeschritteneren Beispiel befindet sich das root- (/)
Dateisystem auf sd0a. Das /var-Dateisystem befindet sich auf sd0d, das
/home-Dateisystem auf sd0e und schlussendlich /usr auf sd0h.

<p>
Um ein Backup deiner Maschine zu machen, musst du dump mit jeder
festgelegten Partition füttern. Hier ist ein Beispiel der Kommandos, um
die einfachere Mounttabelle weiter oben zu sichern:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Für die etwas fortgeschrittenere Mounttabelle würde man etwas wie das
hier benutzen:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Du kannst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>-Handbuchseite
ansehen, um genau zu erfahren, was jede Kommandozeilenoption macht. Hier
ist eine kurze Übersicht der Parameter, die oben verwendet wurden:

<ul>
<li><b>0</b> - Führe einen Level-0-Dump durch - hole alles
<li><b>a</b> - Versuche automatisch die Bandlänge herauszufinden
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand,
um zu reflektieren, wann die letzte Sicherung gemacht wurde
<li><b>f</b> - Welches Bandlaufwerk benutzt werden soll (/dev/nrst0 in
diesem Fall)
</ul>

<p>
Zuletzt welche Partition gesichert werden soll (/dev/rsd0a usw.)

<p>
Das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
wird am Ende benutzt, um das Band zurückzuspulen. Sieh dir die
mt-Handbuchseite an, wenn du mehr Informationen haben willst (wie etwa
eject).

<p>
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heißt, benutze
einfach dmesg, um das herauszufinden. Ein Beispieleintrag von dmesg für
ein Bandlaufwerk könnte so aussehen:

<blockquote><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></blockquote>

<p>
Du hast vielleicht bemerkt, dass bei der Sicherung das Bandlaufwerk als
<tt>nrst0</tt> anstatt von <tt>st0</tt> bezeichnet wird, wie man es
in dmesg sieht. Wenn du auf <tt>st0</tt> statt <tt>nrst0</tt> zugreifst,
benutzt du das selbe physikalische Gerät, sagst ihm aber, dass es nicht
zurückspulen soll, nachdem der Job im raw-Modus beendet wurde. Um
mehrere Dateien auf ein einziges Band zu sichern, stelle sicher, dass du
nicht zurückspulst - sprich das richtige Gerät (<tt>rst0</tt>) benutzt -
ansonsten wirst du mit der zweiten Sicherung die erste überschreiben
usw. Du findest in der Handbuchseite zu dump eine ausführlichere
Beschreibung.

<p>
Wenn du ein kleines Skript namens backup schreiben würdest, könnte es
z.&nbsp;B. so aussehen:

<blockquote><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre></blockquote>

<p>
Wenn regelmäßige nächtliche Backups gefordert sind, könnte man
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
benutzen, um das Backup jede Nacht automatisch zu starten.

<p>
Es ist außerdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie
groß jedes Dateisystem sein muss. Du kannst »<tt>df -h</tt>« benutzen,
um herauszufinden, wie viel Platz jede Partition momentan verbraucht. Das
ist dann nützlich, wenn eine Platte versagt und du die Partitionstabelle
auf der neuen Platte wieder erstellen musst.

<p>
Deine Daten wiederherzustellen hilft außerdem noch gegen Fragmentierung.
Der beste Weg, um sicherzustellen, dass du alle Dateien erwischst, ist
es, im Singleuser-Modus zu booten. Dateisysteme müssen nicht gemountet
werden, um gesichert zu werden. Vergiss aber nicht, root (/) zu mounten,
denn sonst wird dein dump versagen, wenn er versucht, Dumpdaten zu
schreiben. Gib einfach »<tt>bsd -s</tt>« am boot&gt;-Prompt ein, um in
den Singleuser-Modus zu gelangen.

<h3>Den Inhalt eines dump-Bandes ansehen:</h3>


<p>
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es
sicher eine gute Idee, dein Band zu testen und sicherzustellen, dass es
auch die Daten enthält, die darauf sein sollen.

<p>
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien
auf einem dump-Band zu erhalten:

<blockquote><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></blockquote>

<p>
Das listet die Dateien auf der 1. Partition des dump-Bandes (des
Sicherungsbands) auf. Wie in den Beispielen weiter oben ist 1 dein root-
(/) Dateisystem.

<p>
Um den Inhalt der 2. Partition zu sehen und die Ausgabe in eine Datei
umzulenken, würde man z.&nbsp;B. solch ein Kommando benutzen:

<blockquote><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></blockquote>

<p>
Wenn du eine Mounttabelle wie die oben aufgeführte hättest, wäre 2 /usr
- wenn deine aber etwas größer wäre, könnte 2 auch /var sein oder
irgendwas anderes. Die Sequenznummer unterliegt auf jeden Fall der
gleichen Reihenfolge, mit der das Dateisystem auf das Band gesichert
wurde.


<h3>Wiederherstellen vom Band:</h3>

<p>
Das Beispielszenario wäre sinnvoll, wenn deine eigentliche Festplatte
komplett ausgefallen wäre. Falls du aber nur eine einzige Datei
wiederherstellen willst, sieh dir die restore-Handbuchseite genau an und
achte besonders auf die Anweisungen für den interaktiven Modus.

<p>
Wenn du gut vorbereitet bist, kann der Prozess des Ersetzens einer
Festplatte sehr schnell von statten gehen. Die normale
OpenBSD-Installations/Bootdiskette enthält bereits das benötigte
restore-Werkzeug genauso wie die ausführbaren Dateien, um neue
Partitionen zu erstellen und deine Festplatte bootbar zu machen. In
den meisten Fällen sind diese Disketten und dein Sicherungsband alles,
was du brauchst, um wieder alles betriebsbereit zu bekommen.

<p>
Nachdem du das kaputte Laufwerk physikalisch ersetzt hast, sind die
grundlegenden Schritte zur Wiederherstellung folgende:

<ul>
<li>
<p>
Boote von der OpenBSD-Installations/Bootdiskette. Wähle Shell aus dem
Menü aus. Nimm dein neuestes und schreibgeschütztes Band und lege es in
dein Laufwerk ein.
<br>
<li>
<p>
Benutze das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Kommando,
um eine primäre OpenBSD-Partition auf dieser neu installierten
Festplatte zu erzeugen. Beispiel:

<blockquote><pre>
# <b>fdisk -e sd0</b>
</pre></blockquote>

<p>
Sieh einfach in die <a href="#fdisk">fdisk-FAQ</a>, um genaueres zu
erfahren.

<li>
<p>
Mit dem disklabel-Kommando stellst du dann deine
OpenBSD-Partitionstabelle in der primären OpenBSD-Partition wieder her,
die du gerade mit fdisk erzeugt hast. Beispiel:

<blockquote><pre>
# <b>disklabel -E sd0</b>
</pre></blockquote>

<p>
(Vergiss den Swap nicht; siehe dazu die
<a href="#disklabel">disklabel-FAQ</a> für weitere Informationen)

<li>
<p>
Benutze das newfs-Kommando, um ein neues sauberes Dateisystem auf jeder
Partition zu erstellen, die du mit den oben aufgeführten Schritten
erstellt hast. Beispiel:

<blockquote><pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre></blockquote>

<li>
<p>
Mounte dein neu vorbereitetes root- (/) Dateisystem auf /mnt. Beispiel:

<blockquote><pre>
# <b>mount /dev/sd0a /mnt</b>
</pre></blockquote>

<li>
<p>
Wechsel in das gemountete root-Dateisystem und beginne mit dem
Wiederherstellungsprozess. Beispiel:

<blockquote><pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre></blockquote>

<li>
<p>
Wenn die Platte bootbar sein soll, schreibe mit dem folgenden Befehl
einen neuen MBR auf deine Festplatte. Beispiel:

<blockquote><pre>
# <b>fdisk -i sd0</b>
</pre></blockquote>

<li>
<p>
Zusätzlich zum Schreiben eines neuen MBR musst du Bootblöcke
installieren, um von ihr booten zu können. Das Folgende ist ein
kurzes Beispiel:

<blockquote><pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></blockquote>

<li>
<p>
Dein neues root-Dateisystem auf der eingebauten Festplatte sollte jetzt
fertig sein, sodass du davon booten und damit beginnen kannst, den Rest
der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht
komplett ist, solltest du alles im Singleuser-Modus wiederherstellen.
Benutze die folgenden Kommandos am Shellprompt, um deine Festplatten
zu unmounten und das System anzuhalten:

<blockquote><pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre></blockquote>

<li>
<p>
Entferne die Installations/Bootdiskette aus dem Laufwerk und starte
dein System neu. Benutze das folgende Kommando am
OpenBSD-boot&gt;-Prompt:

<blockquote><pre>
boot&gt; <b>bsd -s</b>
</pre></blockquote>

<p>
Das bsd -s führt dazu, dass der Kernel im Singleuser-Modus gestartet
wird, der nur ein root- (/) Dateisystem braucht.

<li>
<p>
Unter der Annahme, dass du die obigen Schritte richtig ausgeführt hast
und nichts schief gegangen ist, solltest du von einem Prompt begrüßt
werden, der dich nach einem Pfad zu einer Shell fragt, oder du Return
drücken sollst. Drücke Return, um die sh zu benutzen. Als nächstes
willst du sicherlich root im Lese/Schreibmodus (rw) remounten und nicht
mehr im schreibgeschützten Modus benutzen (ro). Dazu benutze
Folgendes:

<blockquote><pre>
# <b>mount -u -w /</b>
</pre></blockquote>

<li>
<p>
Sobald du im Lese/Schreibmodus remountet hast kannst du fortfahren,
deine restlichen Dateisysteme wiederherzustellen. Beispiel:

<blockquote><pre>
<i>(einfache Mounttabelle)</i>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

<i>(umfassendere Mounttabelle)</i>
#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></blockquote>

<p>
Benutze »<b>restore rvsf</b>« statt eines einfachen rsf, um die Namen
von Objekten zu sehen, während sie vom dump-Set ausgepackt werden.

<li>
<p>
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme
wiederhergestellt hast, führe einen Neustart in den Multiuser-Modus
durch. Wenn alles geklappt hat, sollte dein System wieder genau so
sein, wie zum Zeitpunkt deiner letzten Sicherung, und bereit, wieder
eingesetzt zu werden.
</ul>

<a name="MountImage"></a>
<h2>14.11 - Laufwerksabbilder in OpenBSD einhängen</h2>

<p>
Um ein Laufwerks-Abbild (ISO-Abbild, Abbilder, die mit dd erstellt wurden
etc.) unter OpenBSD einzuhängen (zu »mounten«), musst du ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4"
>vnd(4)</a>-Gerät konfigurieren.
Zum Beispiel, wenn du ein ISO-Abbild unter <i>/tmp/ISO.image</i> hast, würdest
du die folgenden Schritte gehen, um es einzuhängen:

<blockquote><pre>
# <b>vnconfig vnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/vnd0c /mnt</b>
</pre></blockquote>

<p>
Bedenke bitte, dass du den Typ <i>cd9660</i> angeben musst, wenn es
eine CD ist. Das gilt aber auch für die anderen Typen. Du musst also
z.&nbsp;B. <i>ext2fs</i> beim Mounten eines Linux-Diskimages angeben.

<p>
Um das Abbild wieder auszuhängen, benutze die folgenden Kommandos.

<blockquote><pre>
# <b>umount /mnt</b>
# <b>vnconfig -u vnd0</b>
</pre></blockquote>

<p>
Mehr Informationen gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>-Handbuchseite.

<p>
<a name="pciideErr"></a>
<h2>14.12 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</h2>

<p>
DMA-IDE-Übertragungen, die durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4"
>pciide(4)</a> unterstützt werden, sind in vielen Konfigurationen alter
Hardware unzuverlässig.

<p>
OpenBSD ist aggressiv und versucht, den höchsten DMA-Modus zu benutzen,
den es konfigurieren kann. Dies führt in einigen Konfigurationen zu
Datenkorruptionen aufgrund von defekten Motherboardchipsets,
fehlerhaften Treibern, die Probleme verursachen und/oder Lärm auf den
Kabeln. Glücklicherweise schützt Ultra-DMA die Datenübertragungen mit
einem CRC, um Korruptionen zu entdecken. Falls ein Fehler bei einem
solchen Ultra-DMA CRC geschieht, wird OpenBSD eine Fehlermeldung
ausgeben und erneut versuchen, die Daten zu übertragen.

<blockquote><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></blockquote>

<p>
Nach ein paar Fehlversuchen wird OpenBSD zu einem langsameren (und damit
hoffentlich zuverlässigeren) DMA-Modus herunterschalten. Nach den
Ultra-DMA-Modi wird dann zu einem PIO-Modus heruntergeschaltet.

<p>
UDMA-Fehler werden meistens durch minderwertige oder beschädigte Kabel
verursacht. Kabelprobleme sollten normalerweise zuerst in Betracht
gezogen werden, wenn du viele DMA-Fehler oder unerwartet niedrige
DMA-Leistung erhältst. Es ist ebenfalls eine schlechte Idee, das CD-ROM
an den gleichen Kanal wie die Festplatte zu stecken.

<p>
Wenn das Ersetzen der Kabel nicht zur Lösung des Problems führt und
OpenBSD nicht erfolgreich herunterschaltet oder der Prozess zu einem
Einfrieren deiner Maschine führt, möchtest du vielleicht dein System
auf einen niedrigeren DMA- oder UDMA-Level standardmäßig begrenzen.
Dies kann unter Verwendung von <a href="faq5.html#BootConfig">UKC</a>
oder <a href="faq5.html#config">config(8)</a> realisiert werden, indem
man die Optionen des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>-Devices
ändert.

<p>
<a name="NegSpace"></a>
<h2>14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich mehr als 100&nbsp;%
von meinem Laufwerk belegt habe?</h2>
Leute sind manchmal erstaunt darüber, herausfinden zu müssen, dass sie
<i>negativen</i> verfügbaren Plattenspeicher haben oder mehr als
100&nbsp;% eines Dateisystems in Verwendung ist, wie es von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>
angezeigt wird.

<p>
Wenn ein Dateisystem mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
erstellt wird, wird ein Teil des verfügbaren Speichers vor den normalen
Benutzern in Reserve gehalten. Dies stellt einen Spielraum für Fehler
bereit, wenn du versehentlich die Platte füllst und hilft, die
Plattenfragmentierung auf einem Minimum zu halten. Standardwert hierfür
ist 5&nbsp;% der Plattenkapazität, sodass, falls der
Systemadministrator sorglos die Platte auffüllt, du bis zu 105&nbsp;%
Speicher sehen kannst, der verwendet wird.

<p>
Wenn der 5-%-Wert für dich nicht angemessen erscheint, kannst du ihn mit
dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>
ändern.

<p>
<a name="OhBugger"></a>
<h2>14.15 - Partitionen wiederherstellen, nachdem das Disklabel gelöscht
wurde</h2>

<p>
Wenn du eine Partitionstabelle beschädigt hast, gibt es einige Dinge,
die du versuchen kannst, um sie wiederherzustellen.

<p>
Zu aller erst Panik. Das würde sowieso passieren - aber dann hast du
es jedenfalls hinter dir. Mach einfach nichts Unvernünftiges. Halte
deine Panik von der Maschine fern. Dann entspanne dich und guck, ob dir
die unten stehenden Schritte vielleicht weiterhelfen.

<p>
Eine Kopie des Disklabels wird für jede Platte als Teil der täglichen
Systemverwaltung unter <tt>/var/backups</tt> gespeichert. Angenommen,
dass du die var-Partition weiterhin hast, kannst du einfach die Ausgabe
lesen und sie zurück in das Disklabel schreiben.

<p>
Falls du die Partition nicht mehr sehen kannst, gibt es zwei
Möglichkeiten. Behebe genug Fehler der Platte, bis du sie sehen kannst
oder behebe genug Fehler der Platte, um deine Daten von ihr zu bekommen.

Abhängig davon, was passiert ist, könnte der eine oder ein anderer
Weg bevorzugt sein (mit sterbenden Platten, von denen du zuerst
die Daten haben willst, könntest du mit schlampigen Fingern nur das
Label bekommen).

<p>

Das erste Werkzeug, das du brauchst, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(achte auf den Unterstrich, es wird nicht »scanffs« genannt).
Das Werkzeug scan_ffs(8) durchsucht die Platte und versucht,
Partitionen zu finden, und teilt dir die Informationen mit, die es über
sie herausgefunden hat. Du kannst diese Informationen nutzen, um das
Disklabel neu zu erstellen. Wenn du einfach nur <tt>/var</tt>
zurückhaben willst, kannst du die Partition für <tt>/var</tt> wieder
erstellen und dann das gesicherte Label nutzen, um den Rest von diesem
aus zu erstellen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
wird sowohl die Erkenntnis des Kernels über das Disklabel erneuern
als auch versuchen, das Label auf die Platte zu schreiben.
Selbst wenn der Bereich der Platte, in dem das Disklabel liegt, nicht
lesbar ist, wirst du trotzdem in der Lage sein, bis zum nächsten
Neustart
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
aufzurufen.

<p>
<a name="foreignfs"></a>
<h2>14.16 - Kann ich auf Daten zugreifen, die auf anderen Dateisystemen
als FFS liegen?</h2>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Ja. Andere unterstützte Dateisysteme sind unter anderem: ext2 (Linux),
ISO9660 und UDF (CD-ROM-, DVD-Medien), FAT (MS-DOS und Windows), NFS,
NTFS (Windows).
Einige von ihnen haben eingeschränkte - zum
Beispiel nur schreibgeschützte - Unterstützung.

<p>
Wir werden hier einen allgemeinen Überblick darüber geben, wie man eines
dieser Dateisysteme unter OpenBSD verwendet. Um in der Lage zu sein, ein
Dateisystem zu benutzen, muss es gemountet sein. Für Details und
Optionen für mount, konsultiere bitte die Handbuchseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
und die Handbuchseite zum mount-Kommando für das Dateisystem, das du
mounten möchtest, z.&nbsp;B. mount_msdos, mount_ext2fs,&nbsp;...

<p>
Zu aller erst musst du wissen, auf welchem Device sich dein Dateisystem
befindet. Vielleicht einfach deine erste Festplatte (<tt>wd0</tt> oder
<tt>sd0</tt>), es könnte aber auch weniger offensichtlich sein.
Alle erkannten und konfigurierten Devices deines Systems werden in der
Ausgabe vom Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
aufgeführt: ein Devicename, gefolgt von einer einzeiligen Beschreibung
des Devices. Mein erstes CD-ROM-Laufwerk wird beispielsweise wie folgt
erkannt:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Du kannst
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
verwenden, um eine viel kürzere Liste der verfügbaren Platten zu
erhalten. Das Kommando

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

wird alle Platten anzeigen, die deinem System momentan bekannt sind,
z.&nbsp;B.:

<blockquote><pre>
hw.disknames=cd0:,cd1:,wd0:,fd0:,cd2:
</pre></blockquote>

<p>
An diesem Punkt angekommen ist es Zeit dafür, herauszufinden, welche
Partitionen sich auf dem Device befinden, und auf welcher Partition das
gewünschte Dateisystem liegt. Daher untersuchen wir das Device mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Das Disklabel beinhaltet eine Liste, die aus maximal 16 Partitionen
besteht. Partition c steht immer für das gesamte Device. Partitionen
a - b und d - p werden von OpenBSD genutzt. Partitionen i - p können
automatisch für Dateisysteme anderer Betriebssysteme allokiert werden.
In diesem Fall werde ich mir das Disklabel meiner Festplatte betrachten,
welches eine Anzahl verschiedener Dateisysteme beinhaltet.

<p>
<b>HINWEIS: OpenBSD wurde nach allen anderen Betriebssystemen
installiert</b> und während der Installation wurde ein Disklabel
erstellt, das alle Partitionen der nativen als auch der anderen
Dateisysteme enthält, die sich auf der Platte befanden. Wenn du jedoch
andere Dateisysteme installiert nachdem das OpenBSD-Disklabel bereits
auf der Platte installiert wurde, musst du sie nachträglich manuell
hinzufügen oder ändern. Dies wird in <a href="#foreignfsafter">diesem
Unterkapitel</a> behandelt.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A       
duid: d920a43a5a56ad5f
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
boundstart: 20338290
boundend: 49656915
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # /
  b:       1638000      20746656    swap
  c:      78165360             0  unused
  d:       4194288      22384656  4.2BSD   2048 16384   16 # /usr
  e:        409248      26578944  4.2BSD   2048 16384   16 # /tmp
  f:      10486224      26988192  4.2BSD   2048 16384   16 # /var
  g:      12182499      37474416  4.2BSD   2048 16384   16 # /home
  i:         64197            63 unknown
  j:      20274030         64260 unknown
  k:       1975932      49656978   MSDOS
  l:       3919797      51632973 unknown
  m:       2939832      55552833  ext2fs
  n:       5879727      58492728  ext2fs
  o:      13783707      64372518  ext2fs 

</pre></blockquote>

<p>
Wie du in dieser Ausgabe erkennen kannst, werden die OpenBSD-Partitionen
zuerst aufgelistet. Nach diesen werden einige ext2-Partitionen und
eine MSDOS-Partition aufgelistet, sowie ein paar unbekannte (unknown)
Partitionen. Auf i386- und amd64-Systemen kannst du mehr über diese
unter Verwendung des Werkzeugs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
in Erfahrung bringen.
Für den neugierigen Leser: Partition i ist eine Wartungspartition, die
vom Hersteller erzeugt wurde, Partition j ist eine NTFS-Partition und
Partition l ist eine Swappartition für Linux.

<p>
Sobald du herausgefunden hast, welche dieser Partitionen die ist, die du
benutzen möchtest, kannst du den letzten Schritt durchführen: das
Dateisystem, das sich auf dieser befindet, mounten. Die meisten
Dateisysteme werden vom GENERIC-Kernel unterstützt: Wirf einfach einen
Blick in die Kernelkonfigurationsdatei, die sich im Verzeichnis
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt> befindet.
Wenn du eines der Dateisysteme nutzen möchtest, die nicht in GENERIC
unterstützt werden, musst du <a href="faq5.html#Options">einen
angepassten Kernel erzeugen</a>.

<p>
Wenn du die Informationen auf zuvor beschriebene Weise gesammelt hast,
ist es nun an der Zeit, das Dateisystem zu mounten.
Lass uns annehmen, dass ein Verzeichnis namens <tt>/mnt/otherfs</tt>
existiert, welches wir als Mountpunkt nutzen werden, unter dem wir das
gewünschte Dateisystem mounten werden.
In diesem Beispiel werden wir das ext2-Dateisystem von Partition m
mounten:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

<p>
Wenn du vorhast, dieses Dateisystem regulär zu nutzen, kannst du etwas
Zeit sparen, indem du eine Zeile in <tt>/etc/fstab</tt> schreibst; zum
Beispiel etwas wie:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Beachte den Wert 0 im fünften und sechsten Feld. Diese bedeuten, dass
wir nicht möchten, dass die Dateisysteme mit dump gesichert oder unter
Verwendung von fsck überprüft werden. Generell gilt, dass du solche
Aufgaben eher mit dem dazugehörigem Betriebssystem machen möchtest.

<p>
<a name="foreignfsafter"></a>
<h3>14.16.1 - Die Partitionen sind nicht in meinem Disklabel verzeichnet!
Was kann ich tun?</h3>

Wenn du andere Dateisysteme auf deinem System angelegt hast (resultiert
meist aus der Installation eines anderen Betriebssystems) nachdem du
OpenBSD bereits installiert hast, wird ein Disklabel bereits vorliegen
und nicht automatisch aktualisiert, sodass es die neuen fremden
Dateisystempartionen enthielte. Wenn du diese verwenden möchtest,
dann musst du diese Partitionen manuell unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
hinzufügen oder editieren.

<p>
Beispielsweise habe ich eine meiner bestehenden ext2fs-Partitionen
geändert: Unter Verwendung von Linux' fdisk-Programm habe ich die
Größe der o-Partition (siehe die Disklabelausgabe weiter oben) auf 1 G
reduziert. Wir können dies leicht sehen, indem wir einen Blick auf die
Startposition (Offset: 64372518) und die Größe (13783707) werfen.
Beachte, dass diese Werte Sektornummern und dass die Verwendung von
Sektornummern (nicht Megabyte oder ein anderes Maß) die genaueste
Angabe ist und der sicherste Weg, um diese Informationen zu lesen.

<p>
Vor dem Ändern sah die Partition wie diese aus (Ausgabe von OpenBSDs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Werkzeug
[nur die wichtigen Informationen werden hier angegeben]):

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Wie du sehen kannst sind die Startposition und die Größe genau so, wie
sie zuvor von disklabel(8) angegeben wurden. (Sei jetzt nicht wegen dem
Wert verwirrt, der als Offset angegeben wird: der Wert bezieht sich auf
die Startposition der erweiterten Partition, in der sich die
ext2-Partition befindet.)

<p>
Nachdem die Partitionsgröße unter Linux geändert wurde, sieht sie wie
folgt aus:

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Dies muss nun unter Verwendung von disklabel(8) geändert werden.
Zum Beispiel kannst du <tt>disklabel -e wd0</tt> aufrufen, womit du
einen Editor startest, der mit der Umgebungsvariable EDITOR (Standard
ist vi) angegeben wird. Ändere mit diesem Editor die Zeile des
Disklabels, um diese auf die neue Größe anzupassen:

<blockquote><pre>
  o:       2104452      64372518  ext2fs
</pre></blockquote>

Schreibe das Disklabel auf die Platte, wenn du fertig bist. Nun, da das
Disklabel wieder aktuell ist, solltest du in der Lage sein, die
Partitionen wie oben beschrieben wieder mounten zu können.

<p>
Du kannst einen sehr ähnlichen Prozess ausführen, um neue Partitionen
hinzuzufügen.

<p>
<a name="flashmem"></a>
<h2>14.17 - Kann ich ein Flash-Speicher-Gerät mit OpenBSD benutzen?</h2>
<a name="flashmemPortable"></a>
<h3>14.17.1 - Flash-Speicher als portables Speichergerät</h3>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Normalerweise sollte ein Speichergerät erkannt werden, wenn es an eine
Schnittstelle deiner Maschine angeschlossen wird. Kurz nach dem
Anschließen werden einige Nachrichten auf der Konsole des Kernels
angezeigt. Wenn ich zum Beispiel meinen USB-Flashspeicher anschließe,
sehe ich Folgendes auf meiner Konsole:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Diese Zeilen deuten darauf, dass der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>-
(USB-Massenspeicher-) Treiber an das Speichergerät angehängt wurde und
dass es das SCSI-System nutzt. Die beiden letzten Zeilen sind die
wichtigsten: Sie sagen, an welche Gerätedatei das Speichergerät
angehängt wurde, und wie groß der gesamte Speicherplatz ist.
Wenn du diese Zeilen - warum auch immer - verpasst haben solltest,
kannst du sie nachträglich mit dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
betrachten. Die angegebene CHS-Geometrie ist eine fiktive, da der
Flashspeicher wie eine normale SCSI-Platte verarbeitet wird.

<p>
Wir werden nun zwei Szenarien besprechen.

<h4>Das Gerät ist neu/leer und du möchtest es nur mit OpenBSD nutzen</h4>

Du musst ein Disklabel und mindestens eine Partition auf diesem Gerät
erstellen. Bitte lies <a href="#disklabel">OpenBSDs disklabel
verwenden</a> und die Handbuchseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
für Details hierüber.

<p>
In diesem Beispiel habe ich nur die Partition <i>a</i> erstellt, auf
der ich ein FFS-Dateisystem erstellen werde:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Lass uns das Dateisystem, das wir auf der Partition <i>a</i> erstellt
haben, unter <tt>/mnt/flashmem</tt> mounten.
Erstelle zuerst einen Mountpunkt, wenn er noch nicht existiert.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h4>Du hast das Speichergerät von jemandem erhalten, mit dem du Daten
austauschen möchtest</h4>

<p>
Möglicherweise wird diese andere Person nicht OpenBSD nutzen, sodass
sich ein fremdes Dateisystem auf diesem Speichergerät befinden kann.
Daher müssen wir zuerst alle Partitionen auf diesem Gerät finden, so
wie es in <a href="#foreignfs">FAQ 14 - Fremde Dateisysteme</a>
beschrieben steht.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Wie man in der Ausgabe von disklabel sehen kann, gibt es nur eine
Partition names <i>i</i>, das ein FAT-Dateisystem beinhaltet, das von
einer Windows-Maschine erstellt wurde. Wie gewöhnlich stellt die
Partition <i>c</i> das gesamte Gerät dar.

<p>
Lass uns nun das Dateisystem auf der Partition <i>i</i> unter
<tt>/mnt/flashmem</tt> mounten.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Nun können wir damit beginnen, es wie jede andere Platte anzusprechen.

<p>
<b>WARNUNG:</b>
Du solltest das Dateisystem <b>vor dem Herausziehen</b> des Geräts
<b>immer erst unmounten</b>.
Wenn du das nichts tust, könnte das Dateisystem in einem nicht
konsistenten Zustand zurückgelassen werden, was im schlimmsten Fall
Datenverlust bedeutet.

<p>
Nach dem Entfernen des Speichergeräts von deiner Maschine wirst du
wieder sehen, dass der Kernel Meldungen hierüber auf der Konsole
ausgibt:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<a name="flashmemBoot"></a>
<h3>14.17.2 - Flash-Speicher als startbarer Speicherplatz</h3>
<!-- This article written by Nick Holland
nick@openbsd.org, and released under the BSD license -->
Man kann ebenfalls Flash-Speicher in vielfacher Form als startbares Laufwerk
mit OpenBSD benutzen.
Dies kann sowohl mit USB-Geräten (vorausgesetzt dein Computer kann von einem
USB-Flash-Speicher-Gerät starten, was nicht für alle gilt), als auch mit
nicht-USB-Geräten (z.&nbsp;B. »CompactFlash«) mit einem IDE- oder SATA-Adapter
geschehen.
(Nicht-USB-Geräte, die an einen USB-Adapter angeschlossen sind, werden als
USB-Geräte behandelt.)
In einigen Fällen kann man das Gerät auf beide Arten nutzen (laden des Mediums
mit einem USB-Adapter, laufenlassen mit einem IDE-Adapter).

<p>
Ein Flash-Gerät, das an einen USB-Anschluss angeschlossen wird, taucht als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4"
>sd(4)</a> SCSI-ähnliches Gerät auf.
Wird es an einen IDE-Adapter angeschlossen, so tauch es als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4"
>wd(4)</a>-Gerät auf.

<p>
In dem Fall, dass das Flash-Medium über einen IDE-Adapter angeschlossen wird,
kann man von ihm jedes System starten, dass von einer IDE-Festplatte über
denselben Adapter starten könnte.
Das System betrachtet dieses Flash-Medium in jeder Hinsicht als IDE-Laufwerk.
Konfiguriere einfach deine Hardware entsprechend, und OpenBSD wird sich ganz
normal auf das Flash-Laufwerk installieren.

<p>
In dem Fall des Startens von einem USB-Gerät muss das System in der Lage sein,
von einem USB-Gerät starten zu können, ohne von anderen Geräten des Systems
abgelenkt zu werden.
Beachte das, sollte deine Intention sein, eine portable Systemstart-Umgebung
auf einem USB-Gerät zu kreieren, du wirklich <a href="#DUID">DUIDs</a> anstatt
der traditionellen »<tt>/dev/sd0X</tt>«-Notation benutzen solltest.
Das USB-Gerät wird als SCSI-Laufwerk auftauchen, manchmal sd0.
Ohne DUIDs wird es, wenn du es an ein Gerät anschließt, das bereits einige
SCSI-ähnliche Laufwerke (d.&nbsp;h. Geräte, die an eine ahci(4)-Schnittstelle
angeschlossen sind) aufweist, wahrscheinlich mit einer anderen Kennzeichnung
registriert werden, was das Übertragen des Flash-Geräts von System zu System
verkompliziert, da <tt>/etc/fstab</tt> entsprechend angepaßt werden muss.
Die Benutzung von DUIDs beseitigt diesen Problembereich.

<p>
Einige Anmerkungen:
<ul>
<li><b>Geschwindigkeit:</b> Generell sind Flash-Geräte viel langsamer als
Festplatten, besonders hinsichtlich des Schreibens von Daten.
Das Benutzen von »<a href="#SoftUpdates">Soft-Updates</a>« hilft hier
beachtlich, ebenso wie die mount-Option »noatime«.

<li><b>»Schreibmüdigkeit«:</b>
Viel wurde über die endliche Anzahl Schreiboperationen auf eine Flash-Zelle
bis zu ihrem Ausfall geschrieben.
Jedoch gibt es, praktisch gesprochen, viele Möglichkeiten, wie ein Flash-Gerät
ausfallen kann, und Schreibmüdigkeit ist nur eine davon.
Moderne Flash-Geräte verifizieren Schreiboperationen und ersetzen im Falle
eines Fehlers automatisch den ausgefallenen Sektor mit einem der vielen
Reservesektoren.
Die meisten Benutzer moderner Flash-Geräte werden sich über »Schreibmüdigkeit«
keinerlei Gedanken machen müssen.
Du wirst möglicherweise mehr Ausfallzeiten durch Probleme haben, die sich aus
»cleveren« Tricks zur Minimierung von Schreiboperationen auf Flash-Geräte
ergeben, als wenn du diese Laufwerke einfach als les- und schreibbares Medium
benutzt.

<li><b>Zuverlässigkeit:</b>
Der Umstand das Flash-Medien keinerlei bewegliche Teile haben, hat viele Leute
glauben lassen, dass Flash-Medien inhärent sicherer sind als Festplatten.
Es ist nicht klug anzunehmen, dass der Wechsel auf Flash bedeutet, dass man
sich keinerlei Gedanken mehr über Datenverlust oder Laufwerksausfälle machen
muss.
Personen berichteten von bemerkenswert schwankender Qualität von Flash-Medien,
und es ist wahrscheinlich am besten, Flash-Speicher als leise und stromsparende
Alternative zu Festplatten anzusehen, als als fehlerfreies Speichermedium.

<li><b>Erzeugung eines startbaren USB-Flash-Laufwerks:</b>
Obwohl ein USB-Gerät nur von einer Maschine gestartet werden kann, die von
USB-Geräten starten kann, so kann es doch auf jeder Maschine erzeugt werden,
welche USB-Hardware unterstützt.
Du kannst natürlich deine Arbeit solange nicht testen, bis du ein von USB
startbares System bekommst.

<li><b>Wechsel von IDE- zu USB-Schnittstellen:</b>
Da Flash-Medien von USB-, IDE- und anderen Adaptern gelesen und geschrieben
werden können, kannst du ein startbares Medium mit dem einen Adaptertyp
erzeugen, es aber mit einem anderen Typ verwalten und benutzen.

<li><b>Das Mischen von OpenBSD- und anderen Partitionen auf einem Gerät:</b>
OpenBSD behandelt das Flash-Laufwerk wie jedes Andere, sodass du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8"
>fdisk(8)</a> benutzen kannst, um ein Flash-Gerät zu partitionieren, genauso
wie du es für eine Festplatte machen würdest.
Du kannst dann OpenBSD-Dateisysteme auf einer Partition haben, und eine andere
Partition für ein anderes Dateisystem benutzen, zum Beispiel FAT32.
Jedoch behandeln nicht alle Betriebssysteme USB-Geräte »gleich«.
Windows, zumindest, versucht erst gar nicht eine Partition zu nutzen oder zu
erzeugen, die nicht am Anfang des Geräts startet, noch wird es das
Partitionierungs-Werkzeug von Windows erlauben, das Laufwerk zu partitionieren,
obwohl es existierende Partitionen respektiert.
Also, wenn du ein USB-Flash-Laufwerk erzeugen willst, dass mit OpenBSD startbar
ist, aber ebenfalls als FAT32-taugliches Gerät unter anderen Betriebssystemen
nutzbar ist, so musst du so etwas machen wie dies:

  <ol>
  <li>Partitioniere das Medium mit OpenBSD's fdisk, und erzeuge eine Partition
    des mit und für Windows gewünschten Typs am Anfang des Laufwerks, und
    eine OpenBSD-Partition am Ende des Laufwerks.
  <li>Installiere OpenBSD wie normal in die OpenBSD-fdisk-Partition, und
    vergesse nicht, diese Partition als »Active«, d.&nbsp;h. startbar zu
    markieren.
  <li>Formatiere die andere Partition.
    Dies kann (und vielleicht sollte es auch) auf dem »Ziel«-Betriebssystem (in
    diesem Fall Windows) geschehen.
  </ol>

Beachte das es, wenn der andere Partitionstyp passend gewählt ist, für OpenBSD
möglich ist, beide Partitionen auf dem Gerät anzusprechen.
Also könnte ein Windows-Benutzer die FAT32-Partition mit MP3-Dateien füllen,
welche dann abgespielt werden, wenn sie von der OpenBSD-Partition aus geladen
werden.

</ul>

<a name="flashmemLive"></a>
<h3>14.17.3 - Wie kann ich ein startbares »Live«-USB-Gerät erzeugen?</h3>
Es ist sehr einfach ein startbares USB-Flash-Laufwerk (oder ein anderes!) zu
erzeugen, das als sogenanntes »Live«-OpenBSD-System benutzt werden kann, ohne
das OpenBSD auf der lokalen Festplatte der Maschine installiert werden muss.
Augenscheinlich muss die Zielmaschine von einem USB-Gerät startbar sein, aber
die Vorarbeit kann auf jeder Maschine mit einer USB-Schnittstelle geleistet
werden.

<p>
Einige Gründe, warum du dies machen können wolltest:
<ul>
<li>Eine portable, sichere »Maschine«, die du in deiner Tasche mit dir tragen
kannst.

<li>Lösen von Problemen in OpenBSD und anderen Installationen mit Werkzeugen,
die in einem <a href="faq4.html#bsd.rd">bsd.rd</a> nicht vorhanden sind.

<li>Bewertung von Hardware auf OpenBSD-Kompatibilität zum Zeitpunkt des Kaufs.

<li>Installation auf Maschinen die eine andere Form von Startmedium missen
lassen.

<li>Sammeln von <a href="faq4.html#SendDmesg">dmesg</a>-Ausgaben von den
Computern deiner Freunde!
(Da OpenBSD's »dmesg«-Ausgaben nützlich zur Identifikation von Hardware sind,
kann dies eine guter Weg der Vorbereitung zur Installation ANDERER
Betriebssysteme auf der Maschine sein - stelle sicher, dass du alle benötigten
Treiber hast, bevor du startest).

</ul>

Das Erzeugen eines solchen »Live-OpenBSD-Laufwerks« ist einfach.
<ul>
<li>Hänge dein USB-Laufwerk in die Maschine ein, von der du installieren willst.
<li>Starte dein favorisiertes OpenBSD-Installationsmedium.
<li><a href="faq4.html">Installiere</a> wie normal, versichere dich, dass du
das Flash-Laufwerk als Installationsziel auswählst.
<li>Starte von deinem neu erzeugten USB-Gerät.
</ul>

Das ist alles!

<p>
Es gibt einige Dinge, die du eventuell nach der Installation machen möchtest,
um deine Ergebnisse zu verbessern:

<ul>
<li>Installiere alle Pakete und Dienstprogramme, die du wahrscheinlich
verfügbar haben möchtest.
<li>Unterschiedliche Zielmaschinen werden wahrscheinlich unterschiedliche NICs
haben.
Du könntest eine Reihe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a>-Dateien in <tt>/etc</tt> erzeugen, jede einzig mit dem
Inhalt <tt>dhcp</tt>, und zwar für alle jene NICs, die dir wahrscheinlich
auf von USB startbaren Maschinen begegnen werden (fxp0, re0, rl0, bge0, bnx0,
em0, etc.), und zusätzlich einige Beispiel-Konfigurationsdateien für drahtlose
Netzwerke.
OpenBSD ignoriert alle hostname.if(5)-Dateien für Geräte, die während des
Systemstarts nicht vorhanden sind.

<li>Du könntest den Wunsch verspüren, eine Kopie aller Installationsdateien und
vielleicht aller gewünschte Paket-.tgz-Dateien zu haben, so dass du das
Laufwerk als Installationsmedium nutzen kannst (starte dafür bsd.rd, anstatt
den normalen Startprozess ablaufen zu lassen).

<li>Auf vielen Maschinen wird X »einfach funktionieren«, selbst ohne
Konfigurationsdatei, aber du möchtest vielleicht X-Konfigurationsdateien für
jene Systeme sammeln, die sie benötigen.

<li><a href="#SoftUpdates">Soft-Updates</a> könnte etwas sein, dass du nutzen
möchtest.

<li>Für die maximale Flexibilität möchtest du eventuell
<a href="../../de/i386.html">i386</a> anstatt
<a href="../../de/amd64.html">amd64</a> benutzen.
Wenn du es als Installationsmedium benutzen möchtest, so kannst du natürlich
einen amd64 bsd.rd und amd64 Installationsdateien zusätzlich zu jenen für i386
haben.

<li>Benutze <a href="#DUID">DUIDs</a> zur Identifikation von Parititionen.
<li>Du könntest es für wünschenswert erachten, eine FAT-Partition auf dem
USB-Laufwerk zu haben, erzeuge es wie <a href="#flashmemBoot">oben</a>
detailliert beschrieben.

<li>Du könntest
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4"
>softraid(4)</a> zur Verschlüsselung einer Datenpartition nutzen wollen.

</ul>

<p>
<a name= "DiskOpt"></a>
<h2>14.18 - Optimierung der Laufwerksleistung</h2>

<p>
Die Festplattenleistung ist ein wichtiger Faktor in der
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multiuserumgebung beheimatet
(Benutzer aller Arten - von solchen, die sich einloggen, bis zu denen,
die Serverdienste nutzen). Datenspeicher brauchen ständige
Aufmerksamkeit; insbesondere, wenn deine Partition überläuft
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erhöhen
und Fehlertoleranz zu bieten.

<p>
<ul>
<li><a href="#Optsoftu">Softupdates</a>
<li><a href="#Optmaxvnodes">Größe des namei()-Caches</a>
</ul>

<p>
<a name="Optsoftu"></a>
<h3>14.18.1 - Softupdates</h3>

Ein wichtiges Werkzeug zum Erhöhen der Systemgeschwindigkeit sind
Softupdates. Eine der langsamsten Operationen im traditionellen
BSD-Dateisystem ist das Aktualisieren der Metainfos (was unter anderem
immer dann geschieht, wenn du Dateien oder Verzeichnisse erzeugst oder
löschst). Softupdates versucht die Metainfo im RAM zu aktualisieren,
statt jedes einzelne Metainfoupdate auf die Platte zu schreiben. Ein
weiterer Nebeneffekt ist, dass die Metainfos auf der Festplatte immer
komplett, wenn auch nicht immer auf dem aktuellen Stand sind.
Du kannst mehr über Softupdates in dem
<a href="#SoftUpdates">Softupdates-FAQ</a>-Eintrag finden.

<p>
<a name="Optmaxvnodes"></a>
<h3>14.18. - Größe des namei()-Caches</h3>

Die name-to-inode-Übersetzung (a.&nbsp;k.&nbsp;a. <!-- need to write
the manual page first... <a href="">namei(3)</a> --> namei()-Cache)
kontrolliert die Geschwindigkeit der
pathname-to-<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>-Übersetzung.
Ein sinnvoller Weg zum Herausfinden der passenden Größe des Caches
wäre eine große Anzahl namei()-Cachemisses, die man mit einem
Werkzeug wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>
messen könnte (was eine Untersuchung des momentanen berechneten Wertes
mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> voraussetzt, das diesen Parameter <tt>kern.maxvnodes</tt>
nennt) und diesen Wert zu vergrößern, bis sich entweder die Hitrate des
namei()-Caches verbessert oder es bewiesen ist, dass das System nicht
wesentlich von einer Erhöhung der Größe des namei()-Caches profitiert.
Nachdem der Wert festgestellt wurde, kannst du ihn für die nächsten
Systemstarts mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>
setzen.

<p>
<a name= "Async"></a>
<h2>14.19 - Warum verwenden wir keine »async«hronen Einhängemodi?</h2>

<p>
Frage: »Ich gebe einfach ein ,mount -u -o async /' ein, was ein Paket,
welches ich brauche, benutzbar macht (das darauf besteht alle paar
Momente ein paar hundert Dateien zu ändern).

Wieso wird asynchrones Mounting abgelehnt und ist nicht standardmäßig
aktiviert (wie in manchen anderen Unixen)? Wäre das nicht ein
einfacherer und daher auch ein sichererer Weg, die Leistung mancher
Applikation zu erhöhen?«

<p>
Antwort: »Asynchrone Mounts sind tatsächlich schneller als synchrone
Mounts - aber auch unsicherer. Was passiert im Falle eines
Stromausfalls - oder bei einem Hardwareproblem? Die Suche nach
Geschwindigkeit darf nicht auf Kosten der Stabilität und Zuverlässigkeit
des Systems gehen. Siehe auch die Handbuchseite von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>.«

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
Auf der anderen Seite kannst du mehr Geschwindigkeit erhalten, wenn du
sowieso nur mit temporären Daten umgehst, die du nach einem Crash wieder
rekonstruieren kannst, indem du eine separate Partition nur für
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur,
wenn</i> dir der Verlust aller Daten in der Partition nach irgendeinem
Problem nichts ausmacht. Daher sind
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>-Partitionen
asynchron gemountet, weil sie ja nach jedem Neustart sowieso gelöscht
und neu erzeugt werden.


<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq13.html">[Zum Kapitel 13 - Multimedia]</a>
<a href= "faq15.html">[Zum Kapitel 15 - Pakete und Portierungen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.230 ]<br>
$Translation: faq14.html,v 1.109 2013/05/01 16:30:37 steffen Exp $<br>
-->
$OpenBSD: faq14.html,v 1.91 2013/05/01 17:39:06 ajacoutot Exp $
</small>

</body>
</html>
