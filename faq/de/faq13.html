<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>13 - Multimedia</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 13 - Multimedia">
<meta name= "keywords"      content= "openbsd,faq13">
<meta name= "distribution"  content= "global">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<!--
Copyright (c) 2005-2007 Steven Mestdagh <steven@openbsd.org>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq12.html">[Zum Kapitel 12 -
Hardware- und Plattformspezifische Fragen]</a>
<a href= "faq14.html">[Zum Kapitel 14 - Einrichtung von Laufwerken]</a>
</font>

<h1><font color="#e00000">13 - Multimedia</font></h1><hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#confaudio"  >13.1 - Wie konfiguriere ich mein Audiodevice?</a>
<li><a href="#playaudio"  >13.2 - Unterschiedliche Audiotypen abspielen</a>
<li><a href="#playCD"     >13.3 - Wie kann ich Audio-CDs unter OpenBSD
    abspielen?</a>
<li><a href="#recordaudio">13.4 - Kann ich OpenBSD benutzen, um
  Audiosamples aufzuzeichnen?</a>
<li><a href="#audioserver">13.5 - Wie richte ich einen Audioserver ein?</a>
<li><a href="#audioprob"  >13.6 - Was kann ich machen, wenn ich Probleme mit
    Audio habe?</a>
<li><a href="#midi"       >13.7 - Wie verwende ich meine MIDI-Instrumente?</a>
<li><a href="#lossyaudio" >13.8 - Was gibt es über Ogg-Vorbis- und
  MP3-Encoding zu sagen?</a>
<li><a href="#playDVD"    >13.9 - Wie kann ich Video-DVDs unter OpenBSD
  abspielen?</a>
<li><a href="#burnCD"     >13.10 - Wie brenne ich CDs und DVDs?</a>
<ul>
<li><a href="#burnIntro"  >13.10.1 - Einführung und grundlegende Einrichtung</a>
  <li><a href="#writeCD"  >13.10.2 - CDs brennen</a>
  <li><a href="#writeDVD" >13.10.3 - DVDs brennen</a>
</ul>
<li><a href="#convert"    >13.11 - Ich möchte meine Mediendateien aber im
    Format XYZ haben.</a>
<li><a href="#streaming"  >13.12 - Ist es möglich, Medienstreams unter
    OpenBSD abzuspielen?</a>
<li><a href="#javaplugin" >13.13 - Kann ich mit meinem Webbrowser Java
    verwenden? (nur i386 und amd64)</a>
<li><a href="#flashplugin">13.14 - Kann ich mit meinem Webbrowser Flash
    verwenden? (nur i386)</a>
<!--
<li><a href="#camera"     >13.xx - Kann ich meine Digitalkamera unter
  OpenBSD verwenden?</a>
<li><a href="#scanner"    >13.yy - Wie richte ich meinen Scanner ein und
  wie verwende ihn?</a>
-->
</ul>
<hr>

<a name="confaudio"></a>
<h2>13.1 - Wie konfiguriere ich mein Audiodevice?</h2>

Die Gerätedateien unter OpenBSD, die mit Audio zu tun haben, sind
<tt>/dev/audio</tt>, <tt>/dev/sound</tt>, <tt>/dev/audioctl</tt> und
<tt>/dev/mixer</tt>. Bitte lies die Manualseite für
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audio&amp;sektion=4">audio(4)</a>,
um einen guten Überblick über die Audiotreiberschicht zu erhalten.

<p>
Alle unterstützten Audiotreiber befinden sich bereits im GENERIC-Kernel,
sodass keine weitere Konfiguration oder Installation der Treiber
notwendig ist. Um die Optionen für deinen Soundchip zu erfahren, musst
du herausfinden, welchen Soundchip du hast. Unterstützte Chips können
auf der Hardwarekompatibilitätsseite für deine
<a href="../../de/plat.html">Plattform</a> gefunden werden.
Wenn OpenBSD bei dir bereits läuft, siehe nach, ob in der Ausgabe vom
Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
ein Soundtreiber aufgelistet wird und lies die Manualseite für diesen,
um weitere spezifische Informationen wie zum Beispiel Optionen und
andere Details über diesen Treiber zu erfahren.
Ein Beispiel für einen Audiochip in einer Ausgabe von dmesg ist:

<blockquote><pre>
auich0 at pci0 dev 31 function 5 "Intel 82801BA AC97" rev 0x04: irq 10, ICH2 AC97
ac97: codec id 0x41445360 (Analog Devices AD1885)
ac97: codec features headphone, Analog Devices Phat Stereo
audio0 at auich0
</pre></blockquote>

<p>
Das Basissystem von OpenBSD bietet zwei Werkzeuge für die Überwachung und die
Konfiguration von Audiogeräten.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1"
>audioctl(1)</a> wird für die Parameter der Audio-Verarbeitung, wie Kodierung,
Sample-Rate und die Kanalzahl benutzt, wohingegen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mixerctl&amp;sektion=1"
>mixerctl(1)</a> für die Mixer-Parameter, wie Kanalquelle, Gain-Niveau und
Stummschaltung.

<p>
Die folgenden Kommandos nutzen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1"
>audioctl(1)</a>, um die standardmäßigen Verarbeitungsparameter eines
Audiogerätes anzuzeigen.

<blockquote><pre>
$ <strong>audioctl -f /dev/audio</strong>
...
</pre></blockquote>

Beachte das <tt>-f /dev/audio</tt> explizit angegeben wurde.
Das Öffnen von <tt>/dev/audio</tt> setzt das Audiogerät auf seine
Standard-Parameter zurück, und diese wollten wir sehen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1"
>audioctl(1)</a> ist ebenfalls sehr nützlich, um die Möglichkeiten eines
Audiogerätes herauszufinden.
Zum Beispiel, um zu sehen, ob ein Gerät einige übliche Sample-Raten
unterstützt, könntest du einfach versuchen, die Wiedergabegeschwindigkeit zu
setzen:

<blockquote><pre>
$ <strong>audioctl play.rate=48000</strong>
play.rate: -> 48000
$ <strong>audioctl play.rate=44100</strong>
play.rate: -> 44100
$ <strong>audioctl play.rate=22050</strong>
audioctl: set failed: Invalid argument
$ <strong>audioctl play.rate=8000</strong>
audioctl: set failed: Invalid argument
$
</pre></blockquote>

Dieses Gerät unterstützt eine Wiedergabegeschwindigkeit von 48000 und 44100 Hz,
nicht jedoch 22050 oder 8000.
Anzumerken ist, dass nicht für alle nicht-unterstützten Sample-Raten eine
Fehlermeldung gezeigt wird, sondern manchmal nur die zurückgegebene Sample-Rate
nicht die gewünschte ist.

<blockquote><pre>
$ <strong>audioctl play.rate=48000</strong>
play.rate: -> 48000
$ <strong>audioctl play.rate=44100</strong>
play.rate: -> 48000
$ <strong>audioctl play.rate=22050</strong>
play.rate: -> 48000
$ <strong>audioctl play.rate=8000</strong>
play.rate: -> 48000
$
</pre></blockquote>

Dieses Gerät unterstützt nur die Wiedergabe mit 48000 Hz.

<p>
Audio-Hardware besitzt normalerweise zumindest minimale Mixerfähigkeiten.
Der Aufruf von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mixerctl&amp;sektion=1"
>mixerctl(1)</a> ohne jegliche Kommandozeilenargumente listet alle
Mixerregler des Geräts, sowie ihre aktuellen Einstellungen auf.

<blockquote><pre>
$ <strong>mixerctl</strong>
...
</pre></blockquote>

Einige Geräte besitzen nur eine Handvoll Regler, andere hundert und mehr.
Es muss gesagt werden, dass nicht alle Optionen aller Audio-Chips
notwendigerweise die Außenwelt erreichen.
So kann es z.&nbsp;B. passieren, dass mehr Ausgänge aufgelistet werden als
physisch auf der Soundkarte oder der Hauptplatine vorhanden sind.

<p>
Es gibt einige Regler, die vielen Geräten gemein sind:

<ul>
<li><tt>outputs.master</tt> kontrolliert den Ausgangspegel der Wiedergabe
<li><tt>inputs.dac</tt> kontrolliert den Pegel des D/A-Wandlers
(»DAC«: »digital to analog converter«), der benutzt wird, wenn eine Audiodatei
abgespielt wird.
<li><tt>record.source</tt> kontrolliert welche Eingänge in den A/D-Wandler
(»ADC«: »analog to digital converter«) während einer Aufnahme eingemixt werden
<li><tt>record.volume</tt> oder <tt>record.record</tt> kontrollieren den
Eingangspegel für den A/D-Wandler (»ADC«)
</ul>

Die Regler eines Audiogeräts können unterschiedlich etikettiert sein.
Zum Beispiel ist es möglich, dass kein <tt>outputs.master</tt> so wie oben
existiert, sondern stattdessen ein diesselbe Funktionalität bereitstellender
<tt>outputs.outputs</tt>.

Normalerweise besitzen die Regler aussagekräftige Etikette, aber manchmal muss
man einfach einige unterschiedliche Einstellungen ausprobieren, um zu sehen,
welche Wirkung ein Regler hat.

<p>
Einige Geräte nutzen etwas, das unter dem Namen »EAPD« bekannt ist, was für
»external amplifier power down« steht.
Allerdings ist auch dies nur ein weiterer An/Aus-Schalter.
Es wird vielleicht deshalb »power down« genannt, weil es oft für
Energiesparmodi genutzt wird, was bedeutet, dass dieser Reglertyp häufiger in
Laptops zu finden ist.
Manchmal ist es notwendig Regler, die <tt>eapd</tt> oder <tt>extamp</tt>
Bestandteile in ihrem Namen aufweisen, of <tt>on</tt> zu setzen, um ein
Ausgangssignal zu bekommen.

<p>
Als ein einfaches Beispiel einer typischen Benutzung von mixerctl, muss man
Folgendes tun, um die Lautstärke des linken und rechten Kanals auf 200
einzustellen:

<blockquote><pre>
$ <strong>mixerctl outputs.master=200,200</strong>
outputs.master: 255,255 -&gt; 207,207
</pre></blockquote>

Beachte, dass der Wert 207 wird.
Der Grund hierfür ist, dass dieses Audiogerät einen AC'97-Codec nutzt, der nur
5 Bits für die Lautstärkekontrolle verwendet.
Dies führt zu gerade einmal 32 möglichen Werten.
Andere Hardware könnte eine andere Auflösung nutzen.

<p>
Um den Masterkanal zu aktivieren, würdest du Folgendes aufrufen:

<blockquote><pre>
$ <strong>mixerctl outputs.master.mute=off</strong>
outputs.master.mute: on -&gt; off
</pre></blockquote>

<p>
Damit diese Änderung bei jedem Systemstart vorgenommen wird, bearbeite
<i>/etc/mixerctl.conf</i>, zum Beispiel:

<blockquote><pre>
$ <strong>cat /etc/mixerctl.conf</strong>
outputs.master=200,200
outputs.master.mute=off
outputs.headphones=160,160
outputs.headphones.mute=off
</pre></blockquote>


<a name="playaudio"></a>
<h2>13.2 - Unterschiedliche Audiotypen abspielen</h2>

<h3>Digitalisiertes Audio</h3>

<h4>Verlustfreie Audioformate (AU, PCM, WAV, FLAC, TTA)</h4>

Einige der verlustfreien Audioformate können ohne Software von
Drittanbietern abgespielt werden - vorausgesetzt die Software kennt
die Kodierung des Formats.
Diese Formate sind unter anderem Sun audio (AU), reinen PCM-Dateien
(ohne Header) und RIFF-WAV-Dateien.

<p>
OpenBSD beinhaltet
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1"
>aucat(1)</a>, einem Programm zum Aufnehmen und Abspielen von unkomprimierten
Audio.
Das folgende Beispiel spielt eine WAV-Datei ab:

<blockquote><pre>
$ <strong>aucat -i filename.wav</strong>
</pre></blockquote>

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1"
>aucat(1)</a> unterstützt mit Hilfe der Kommandozeilenoption -i sowohl
Audiodateien ohne »Header« als auch WAV-Dateien.
aucat spielt ebenfalls Sun-Audiodateien ab, deren Daten im Format 8 KHz Mono
mu-law vorliegen, was die übliche Kodierung dieses Dateityps darstellt.

<p>
Es ist ebenfalls möglich, unkomprimierte Audiodaten abzuspielen, indem diese
Daten direkt an das Audiogerät übergeben werden.
Um dies zu ermöglichen müssen die Hauptparameter dieser Daten bekannt sein:
Kodierungstyp, Kanalzahl, Sample-Rate, Anzahl der Bits pro Sample.
Sind diese Parameter nicht bekannt, ist es eventuell möglich, sie mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=file&amp;sektion=1"
>file(1)</a> herauszufinden:

<blockquote><pre>
$ <strong>file music.au</strong>
music.au:  Sun/NeXT audio data: 16-bit linear PCM, stereo, 44100 Hz
</pre></blockquote>

<blockquote><pre>
$ <strong>file music.wav</strong>
music.wav: Microsoft RIFF, WAVE audio data, 16 bit, stereo 44100 Hz
</pre></blockquote>

Die verbleibenden Dinge, die man noch über dieses Beispiel wissen
sollte, ist dass die Datei die »Little-Endian«-Byteanordnung und
»signed linear quantization« nutzt. Das kannst du heraus finden,
indem du den Header mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hexdump&amp;sektion=1">hexdump(1)</a>
ansiehst. Wenn du headerlose (Raw-)Dateien hast, gibt es keine
Möglichkeit, diese Parameter im  Vorfeld zu bestimmen.
Setze die folgenden Parameter mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1">audioctl(1)</a>.

<blockquote><pre>
play.encoding=slinear_le
play.rate=44100
play.channels=2
play.precision=16
</pre></blockquote>

Leite als nächstes die Audiodatei durch ein Soundlaufwerk:

<blockquote><pre>
$ <strong>cat music.au > /dev/sound</strong>
</pre></blockquote>

Wenn du die korrekten Werte gesetzt hast, solltest du das hören, was du
erwartet hattest.

<p>
Merke: Benutze immer <tt>/dev/sound</tt> (nicht <tt>/dev/audio</tt>),
wenn du willst, dass die mit audioctl eingerichteten Werte auch
gesichert bleiben.

<p>
Selbstverständlich gibt es noch andere Programme, mit denen man diese Dateien
abspielen kann.
Wie zum Beispiel XMMS, das als Paket und Portierung verfügbar ist, und
zahlreiche Audioformate abzuspielen in der Lage ist.

<p>
Abgesehen von dem zuvor Beschriebenen gibt es Audioformate, die
verlustfreie Kompression verwenden. Beispiele für solche Formate sind:
»Free Lossless Audio Codec« (FLAC) und TTA. Die FLAC-Implementation
wurde auf OpenBSD portiert und kann unter <tt>audio/flac</tt> in den
Ports oder Packages gefunden werden.

<h4>Audioformate mit verlustbehafteter Komprimierung (Ogg Vorbis, MP3,
WMA, AAC)</h4>

Verlustfreie Kompressionsverfahren werden oft in Audio- oder anderen
Mediadateien verwendet.
Die Idee dahinter ist, eine Menge Daten während der Komprimierung
zu verwerfen. Diese Verfahren reduzieren den Platzbedarf und die
Anforderungen an die Bandbreite. Das Ergebnis ist sowohl eine geringere
Datenmenge als auch eine noch akzeptable Abspielqualität.

<p>
Ein gutes Beispiel hierfür ist das freie, offene und unpatentierte
<a href="http://www.vorbis.com/">Ogg-Vorbis</a>-Format.
Um Ogg-Vorbis-Dateien abzuspielen, kannst du das Programm ogg123
benutzen, welches im Package <tt>audio/vorbis-tools</tt> enthalten ist.
Zum Beispiel:

<blockquote><pre>
$ <strong>ogg123 music.ogg</strong>

Audio Device:   Sun audio driver output

Playing: music.ogg
Ogg Vorbis stream: 2 channel, 44100 Hz
Time: 00:02.95 [02:21.45] of 02:24.40  (133.1 kbps)  Output Buffer  87.5%
</pre></blockquote>

Selbstverständlich existieren Ogg-Vorbis-Plugins auch für andere
Software.

<p>
Ein weiteres sehr populäres Beispiel ist die »MPEG-1 Audio Layer 3«-
(MP3-) Komprimierung, welche - warum auch immer - einige Lizenzen und
Patente hat. MP3-Dateien können von vielen Programmen wiedergegeben
werden. Schau einfach mal durch die <tt>audio</tt>-Sektion der
Portliste oder der Packages.

<p>
Was ist mit dem proprietären »Windows Media Audio«- (WMA-) Format?
Dateien solchen Formates können mittels <tt>x11/mplayer</tt>
abgespielt werden, welches das
<a href="http://ffmpeg.sourceforge.net">FFmpeg</a>-Framework nutzt.

<p>
Ein guter Startpunkt, um mehr über Audiodateiformate zu lernen, ist
dieser Wikipedia-Artikel:
<a href="http://en.wikipedia.org/wiki/Audio_file_format">Audio file formats</a>.

<h3>Künstlich erzeugter Klang</h3>

<h4>MIDI</h4>

Das »Musical Instrument Digital Interface«-Protokoll (MIDI),
wird über <a href="#midi">MIDI-Devices</a> verarbeitet.
Wenn du keinen MIDI-Synthesizer hast, aber dennoch eine
Standard-MIDI-Datei (»standard MIDI file«, SMF) abspielen möchtest,
kannst du Software einsetzen, die MIDI-Daten rendert und aus ihnen
Audiodateien erstellt.
Standardmäßig rendert der <tt>audio/timidity</tt>-Port MIDI-Dateien
und spielt sie auf einem Audiodevice ab:

<blockquote><pre>
$ <strong>timidity file.mid</strong>
</pre></blockquote>

<h4>MOD</h4>

Ein Soundtrackermodul ist ein binäres Format, welches Audiosamples
in einer geordneten Befehlsreihenfolge mischt. Dies macht es möglich,
eher lange Stücke digitalisierter Musik in einer vernünftigen Qualität
abzuspielen.

<p>
Der einfachste Weg, deine favorisierten MOD-Dateien unter OpenBSD
abzuspielen, ist wahrscheinlich, die XMMS-Software zu benutzen. Diese
ist in den Ports und Packages verfügbar.
Du solltest das Subpackage <tt>-mikmod</tt> installieren, damit XMMS
die MikMod-Bibliothek nutzen kann, welche das MOD-, S3M-, IT- und
XM-Modul-Format unterstützt.

<p>
Du kannst darüber hinaus noch andere sogenannte Tracker in der
<tt>audio</tt>-Ports- und Packagesektion finden. Beispiele hierfür
sind tracker und soundtracker. Mit diesen Trackern kannst du
nicht nur Dateien abspielen, sondern auch eigene Module erstellen.
Beachte jedoch, dass nicht jedes Trackerformat von den Programmen
in den Ports unterstützt wird.
Du bist aber stets willkommen, deinen favorisierten Tracker als
<a href="../ports/index.html">Portierung hinzuzufügen</a>.

<p>
<a name="playCD"></a>
<h2>13.3 - Wie kann ich Audio-CDs unter OpenBSD abspielen?</h2>

Es ist sowohl möglich, Audio-CDs von dem CD-ROM-Laufwerk abspielen zu lassen,
indem man dieses die analogen Audiodaten direkt an die Soundkarte senden
lässt, als auch durch das Auslesen der Audiodaten und dem Senden der digitalen
Samples an die Soundkarte über den PCI-Bus.

<p>
Um eine Audio-CD über den analogen Ausgang deines CD-ROM-Laufwerks
abzuspielen, kannst du:
<ul>
<li>Den Kopfhörerausgang benutzen. Dieser ist i.&nbsp;d.&nbsp;R. an der
Vorderseite des Laufwerks zu finden.
<li>Verbinde den Audioausgang an der Rückseite des Laufwerks mit der der
Soundkarte.
Ja, dies ist ein zusätzliches Kabel neben den Daten- (SATA/IDE/SCSI) und
Stromkabeln.
</ul>

<p>
Ein nettes Kommandozeilenprogramm mit dem Namen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>
wurde mit in das Standardsystem übernommen. Wird es ohne Parameter
aufgerufen, arbeitet es im interaktiven Modus. Willst du die CD gleich
abspielen lassen, dann benutze:

<blockquote><pre>
$ <strong>cdio play</strong>
</pre></blockquote>

<p>
Dieses Kommando nutzt standardmäßig das erste CD-ROM-Laufwerk, <tt>cd0</tt>.
Es ist zu beachten, dass der Benutzer, der cdio ausführt, die nötigen Rechte
für das Lesen des CD-ROM-Geräts (z.&nbsp;B. <tt>/dev/rcd0c</tt>) benötigt.
Da dieses Gerät standardmäßig nur von root und der Gruppe operator gelesen
werden kann, solltest du der Einfachheit halber
den Benutzer zur Gruppe operator hinzufügen, indem du die Zeile der
Gruppe in <tt>/etc/group</tt> anpasst.
Alternativ können auch die Zugriffsrechte auf das Geät selbst angepasst werden.

<p>
Beachte, dass du eventuell den CD-Input des Mixers einschalten musst.
Der tatsächliche Name des Inputs variiert von System zu System genau so,
wie es bei der Ausgabe der Fall ist. Das Kommando wird aber diesem
ähneln:

<blockquote><pre>
$ <strong>mixerctl inputs.cd.mute=off</strong>
</pre></blockquote>

Es ist ebenfalls möglich, dass keine analoge Verbindung zwischen dem
CD-ROM-Laufwerk und dem Audiogerät vorliegt.
In diesem Fall kann man <tt>cdio</tt>s <tt>cdplay</tt>-Kommando benutzen, um
die Audiodaten der CD-ROM direkt über den PCI-Bus an die Soundkarte zu
schicken.

<blockquote><pre>
$ <strong>cdio cdplay</strong>
</pre></blockquote>

<p>
Es sei erwähnt, dass es eine Vielzahl X11-basierter Spieler in der
Ports- und Packagekollektion gibt, falls du lieber eine schöne GUI
magst. Sieh einfach mal in der entsprechenden <tt>audio</tt>-Sektion
nach.

<p>
<a name="recordaudio"></a>
<h2>13.4 - Kann ich OpenBSD benutzen, um Audiosamples aufzuzeichnen?</h2>

Ja.
Die meisten Geräte unterstützen Aufnahmen.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1"
>aucat(1)</a> ist in OpenBSD enthalten und kann für Aufnahmen verwendet werden.

<blockquote><pre>
$ <strong>aucat -o file.wav</strong>
</pre></blockquote>

Das obige Kommando beginnt mit der Aufnahme einer Datei im WAV-Format.
Benutze [CTRL]-C ([Steuerungstaste]-C), um die Aufnahme zu beenden.
Die Datei wird aus vorzeichenbehafteten 16 Bit Stereosamples bestehen, die mit
einer Sample-Rate von 44,1 KHz aufgezeichnet wurden.
Andere Sample-Formate, Sample-Raten und eine andere Anzahl an Kanälen können
für die Aufnahme verwendet werden.
Siehe in das Handbuch für weitere Details.

<p>
Benutze aucat, um die Datei wiederzugeben:

<blockquote><pre>
$ <strong>aucat -i file.wav</strong>
</pre></blockquote>

<p>
Wenn die Aufnahme zu funktionieren schien, aber die Wiedergabe der Aufgabe
still oder nicht wie erwartet war, so benötigt der Mixer eventuell ein wenig
Konfigurationsarbeit.
Stelle sicher, dass du das richtige Gerät auswählst, von dem aufgenommen werden
soll, und das die Quelle nicht ausgedämpft (mute) ist.
Du kannst die nötigen Parameter mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mixerctl&amp;sektion=1"
>mixerctl(1)</a> setzen.
Zum Beispiel:

<blockquote><pre>
inputs.mic.mute=off
inputs.mic.preamp=on
inputs.mic.source=mic0
record.source=mic
record.volume=255,255
record.volume.mute=off
record.mic=255
record.mic.mute=off
</pre></blockquote>

Dies sind die Einstellungen für die Aufnahme von einem Mikrofon.
Vorverstärkung (»preamp«) ist angeschaltet, da ansonsten die aufgenommenen
Geräusche auf einigen Systemen ziemlich leise sein können.
Andererseits kann Vorverstärkung auf anderen Systemen auch sehr laut sein.

<p>
<a name="audioserver"></a>
<h2>13.5 - Wie richte ich einen Audioserver ein?</h2>

<!-- This section Copyright (c) 2009 Alexandre Ratchov -->

<h3>Brauche ich einen Audioserver?</h3>

Das Dienstprogramm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1"
>aucat(1)</a> kann als Audioserver benutzt werden,
um als Verbindungsschicht zwischen dem audio(4) Gerätetreiber und
Audioanwendungen zu dienen.
Es zielt auf Folgendes ab:

<ul>

<li>
Der Überwindung von Inkompatibilitäten zwischen Hardware und Anwendungen.
Zum Beispiel kann es sein, dass die Anwendung eine Kodierung oder Sample-Rate
der Hardware nicht unterstützt; wenn dem so ist, kann der Server die
notwendigen Konvertierungen während der Datenvermittlung durchführen.

<li>
Dem gleichzeitigen Zugriff mehrerer Anwendungen auf die Hardware.
Zum Beispiel um einen im Hintergrund laufenden Musikplayer benutzen zu können,
während eine Anwendung Sound abspielt, oder um simultan über die
Front-Lautsprecher Musik auszugeben und den Kopfhörerstecker für Telefonie zu
benutzen, um ein weiteres Beispiel zu geben.

</ul>

Wenn die Anwendungen, die du nutzt, kompatibel mit deiner Hardware sind, und du
nicht vorhast, mehrere Anwendungen gleichzeitig zu nutzen, dann benötigst du
keinen Audioserver.

<h3>How do I setup aucat(1)?</h3>

Es gibt keine Konfigurationsdatei und in den meisten Fällen sind keine
Anpassungen nötig.
Die Eingabe von:

<pre>
$ <strong>aucat -l</strong>
</pre>

startet den Server auf dem Standard-Audiogerät (das Ziel des symbolischen Links
<tt>/dev/audio</tt>), eingestellt auf eine Sample-Rate von 44,1 KHz und den
Zweikanal-Modus (Stereo).
Das bedeutet, dass Anwendungen, die Stereo bei 44,1 KHz benutzen, optimal
laufen, d.&nbsp;.h. ohne die Ausführung von Umwandlungs-Code anzustoßen.
Unterstützt das Gerät diese Parameter nicht, so wird
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1"
>aucat(1)</a> automatisch ein anderes Parameter-Set auswählen.

<p>
Wenn du aucat als root startest, so wird es automatisch seine Priorität
erhöhen, um die Wahrscheinlichkeit von Pufferunterläufen oder -überläufen zu
vermindern.

Es kann beim Systemstart automatisch gestartet werden, indem:

<pre>
<strong>aucat_flags=""</strong>
</pre>

zu <tt>/etc/rc.conf.local</tt> hinzugefügt wird.

<h3>Welche Latenz benötige ich?</h3>

Latenz bezeichnet die Zeit die zwischen der Entscheidung des Programms ein
Sample abzuspielen, und dem Moment vergeht, indem der Benutzer den Sample hört.
Da Audiodaten immer gepuffert sind, ist diese Verzögerung proportional zu der
Größe des Audiopuffers.
Die folgenden Werte werden empfohlen:

<ul>

<li>
Echtzeit-Synthesizer: 5 ms.
Dies ist die Zeit, die zwischen dem Anschlag einer Taste auf deinem
MIDI-Keyboard und dem Hören der Note vergeht.
5 ms entsprechen ungefähr der Zeit, die ein Ton benötigt, um 1,75 m
zurückzulegen.

<li>
Spiele: 50 ms.
Dies ist die Zeit, die zwischen dem Sehen eines Ereignisses und dem Hören des
entsprechenden Sounds vergeht.

<li>
Filmwiedergabe und Ähnliches: 500 ms und mehr.
Derartige Anwendungen »wissen« im Voraus, welcher Sound abzuspielen ist, und
senden deshalb Audiodaten dergestalt, dass sie gleichzeitig mit dem
entsprechenden Bild abgespielt werden.

</ul>

Je kleiner Audio-Puffer sind (um eine niedrige Latenz zu erzielen), desto
größer ist die Wahrscheinlichkeit von Pufferüberläufen und -unterläufen.
Pufferüberläufe/-unterläufe führen zu einem »stottern« des Sounds.

<p>
Im Server-Modus erzwingt aucat(1) eine minimale Latenz für alle
Audio-Anwendungen, und die standardmäßige Latenz liegt um 250 ms.

Wenn du planst, Anwendungen zu verwenden, die eine niedrigere Latenz benötigen,
benutze die Option »-b« um die gewünschte Latenz (ausgedrückt in der Anzahl an
Frames) auszuwählen.

Zum Beispiel entsprechen bei 44100 Samples pro Sekunde 50 ms Latenz:

<blockquote>
44100 samples/second x 0.050 seconds = 2205 samples
</blockquote>

also führe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1"
>aucat(1)</a> folgendermaßen aus:

<pre>
$ <strong>aucat -b 2205 -l</strong>
</pre>

<h3>Verbessert eine niedrige Latenz die Audio/Video-Synchronisation</h3>

Die Synchronisation von Audio zu Video benötigt keine niedrige Latenz.
Synchronisationsprobleme werden oft von der Software selbst verursacht
(schlechte Implementierung, Fehler,&nbsp;...).
Die Anwendung dazu zu zwingen kleinere Puffer zu verwenden (durch das Starten
von aucat(1) in einem Modus mit niedriger Latenz) mag in einigen Fällen das
tatsächliche Problem verdecken, und das Gefühl vermitteln, dass die Software
besser läuft, aber offensichtlich ist es besser, nach dem eigentlichen Fehler
zu suchen.

<p>
<a name="audioprob"></a>
<h2>13.6 - Was kann ich tun, wenn ich Audio-Probleme habe?</h2>

<p>
Wenn du beim Abspielen von Audio nichts hörst, ist es wahrscheinlich, dass ein
Mixerregler niedrig eingestellt oder einfach ausgeschaltet ist.
Lies den Abschnitt
<a href="#confaudio">13.1 Wie konfiguriere ich mein Audiodevice</a>,
um den Mixer zu konfigurieren.
Bitte schalte <b>alle</b> Eingänge und Ausgänge an, bevor du ein Problem
meldest.

<p>
Ist der Sound verzerrt, so kann es sein das deine Soundkarte nur eine einzige,
oder nur ein beschränktes Set an Sample-Raten oder Kodierungen unterstützt.
Lies den Abschnitt
<a href="#confaudio">13.1 Wie konfiguriere ich mein Audiodevice</a>
für Beispiele dafür wie man herausfindet, welche Parameter ein Audiogerät
unterstützt.

<p>
Wenn dein Gerät nur unübliche Kodierungen oder nur eine oder nur einige wenige
Sample-Raten unterstützt, und von dir benutzte Anwendungen die notwendigen
Format-Konvertierungen nicht durchführen, so erwäge den Einsatz von aucat(1)
als Audio-Server.
Siehe den Abschnitt
<a href="#audioserver">13.5 - Wie richte ich einen Audioserver ein?</a>

<p>
Treten immer noch Probleme auf, so sind hier einige prüfenswerte Dinge:
<ul>
<li>
Einige alte ISA-Karten haben besondere Macken:
  <ul>
  <li>Einige müssen mit anderen I/O-Adressen und IRQ-Werten konfiguriert
  werden, um Konflikte mit anderer Hardware zu vermeiden.
  Du kannst andere Kombinationen sehr einfach mit Hilfe von
  <a href="faq5.html#BootConfig">User Kernel Configuration (UKC)</a>
  ausprobieren.
  <li>Es ist möglich, dass sich ein nicht-optimaler Treiber sich an das
  Sound-Gerät anhängt, und dass du mit einem anderen Treiber bessere Resultate
  erzielen kannst.
  Dies ist nicht die am einfachsten herauszufindende Sache, aber wirf einen
  genauen Blick auf die Ausgabe deiner
  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8"
  >dmesg(8)</a>, und suche die Zeilen, wo sich der Audiotreiber anhängt.
  Wenn sich mehr als ein Soundtreiber anhängt (oder es versucht), teste sie
  dadurch einzeln, indem du mit Hilfe der
  <a href="faq5.html#BootConfig">User Kernel Configuration (UKC)</a>
  einige deaktivierst und nur einen aktiviert lässt.
  </ul>
<li>
Finde Informationen über dein Sound-Gerät.
Benutze die Dokumentation, oder nutze eine Internet-Suchmaschine um seine
Spezifikationen herauszufinden.
Für
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ac97&amp;sektion=4"
>ac97(4)</a>- und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=azalia&amp;sektion=4"
>azalia(4)</a>-Geräte, schaue sowohl nach Dokumentation für den Kontroller und
den Codex.
Sie könnten dir helfen, die tatsächle Ursache des Problems zu finden.
</ul>

<p>
Wenn du glaubst, dass dein Gerät funktionieren sollte, es dies aber aus was
auch immer für Gründen nicht tut, dann wird es Zeit für ein bißchen Debugging.
Die folgenden Schritte können feststellen, ob Daten vom D/A-Wandler (»DAC«)
verarbeitet werden.

<blockquote><pre>
$ <strong>cat > /dev/audio < /dev/zero &</strong>
[1] 9926
$ <strong>audioctl play.{seek,samples,errors}</strong>
play.seek=48000
play.samples=3312000
play.errors=0
$ <strong>audioctl play.{seek,samples,errors}</strong>
play.seek=57600
play.samples=7065600
play.errors=0
$ <strong>audioctl play.{seek,samples,errors}</strong>
play.seek=48000
play.samples=9379200
play.errors=0
$ <strong>kill %1</strong>
$ <strong>fg %1</strong>
cat > /dev/audio < /dev/zero
Terminated
</pre></blockquote>

Hier sehen wir, das sich der Zähler für die verarbeiteten Daten
<tt>play.samples</tt> jedesmal erhöht, wenn wir ihn prüfen, also fließen Daten.
Wir sehen ebenfalls, dass das Gerät genug Daten puffert <tt>play.seek</tt>,
und dass das Gerät keinen Pufferunterlauf zu verzeichnen hat
<tt>play.errors</tt>.
Das ist auch gut.

<p>
Beachte, dass du, selbst für den Fall des Vorhandenseins angeschlossener
Lautsprecher, während des obigen Tests nichts gehört haben solltest.
Dieser Test sendet Nulls and das Gerät, was in allen aktuell unterstützten
Standard-Kodierungen als Stille interpretiert wird.

<p>
Da wir wissen, dass das Gerät Daten verarbeiten kann, ist es eine gute Idee,
erneut die Mixereinstellungen zu überprüfen.
Stelle sicher das alle Ausgänge und alle Eingänge aktiviert und auf einen
angemessenen Pegel eingestellt sind.

<p>
Solltest du an diesem Punkt immer noch Probleme, ist es wahrscheinlich Zeit,
<a href="http://www.openbsd.org/report.html"
>einen Fehlerbericht einzusenden</a>.
Bitte füge, zusätzlich zu den normalen Informationen eines Fehlerberichts, wie
einer vollständigen »dmesg« und einer Beschreibung des Problems, auch die
standardmäßige Ausgabe von <tt>mixerctl -v</tt> und die Ausgabe des obigen
D/A-Wandler (»DAC«)-Signalverarbeitungstests hinzu.

<p>
<a name="midi"></a>
<h2>13.7 - Wie verwende ich meine MIDI-Instrumente?</h2>

Das »Musical Instrument Digital Interface«- (MIDI) Protokoll bietet
standardisierte und effiziente Hilfsmittel, um musikalische
Aufführungsinformationen als elektronische Daten zu repräsentieren.
MIDI-Daten enthalten lediglich Anweisungen für einen Synthesizer,
um Klänge abzuspielen, statt die Musik an sich.
Weitere Informationen:
<a href="http://www.harmony-central.com/MIDI/Doc/tutorial.html">Tutorial
on MIDI and Music Synthesis</a>.

<!-- <h3>Devices setup</h3> -->

<p>
Um MIDI-Daten abspielen zu können, muss ein Synthesizer über einen
MIDI-Port an der Maschine angeschlossen sein. Dementsprechend wird
auch ein MIDI-Instrument benötigt, um MIDI-Daten aufzuzeichnen
(z.&nbsp;B. ein MIDI-Keyboard). Auf einigen Soundkarten befinden sich
eingebettete MIDI-Synthesizer, die als MIDI-Ports erkannt werden.
Fortgeschrittene MIDI-Instrumente können mehrere Unterkomponenten
enthalten (Synthesizer, Keyboards, Mischpulte etc.), diese werden
unter OpenBSD als weitere MIDI-Ports aufgelistet.

<p>
Wenn du OpenBSD bereits in Betrieb genommen hast, schau in der Ausgabe
des dmesg(8)-Kommandos nach, welche MIDI-Ports gefunden wurden. Eine
Beispielauflistung der MIDI-Ports in einer Ausgabe von dmesg ist:

<blockquote><pre>
umidi0 at uhub2 port 2 configuration 1 interface 0 "Roland Roland XV-2020" rev 1.10/1.00 addr 2
midi0 at umidi0: &lt;USB MIDI I/F&gt;
umidi1 at uhub1 port 2 configuration 1 interface 1 "Evolution Electronics Ltd. USB Keystation 61es" rev 1.00/1.25 addr 3
midi1 at umidi1: &lt;USB MIDI I/F&gt;
</pre></blockquote>

Es werden drei MIDI-Ports aufgelistet, dabei handelt es sich um:

<ul>
<li> <tt>/dev/rmidi0</tt> - einen über USB angeschlossenen Synthesizer
<li> <tt>/dev/rmidi1</tt> - ein MIDI-Keyboard
</ul>

Diese Geräte sind
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sndio">sndio(7)</a>
unter den Namen <tt>rmidi:0</tt> und <tt>rmidi:1</tt> bekannt.

Um dein MIDI-Keyboard zu testen, kannst du das Werkzeug <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hexdump&amp;sektion=1"
>hexdump(1)</a> verwenden. Die gespielten MIDI-Daten können wie folgt
angezeigt werden:

<blockquote><pre>
$ <strong>midicat -q rmidi:1 -o - | hexdump -e '1/1 "%02x\n"'</strong>
90
3c
71
...
</pre></blockquote>

Die Ausgabe des Keyboards kann wie folgt direkt zur Eingabe des
Synthesizers weitergeleitet werden:

<blockquote><pre>
$ <strong>midicat -q rmidi:0 -q rmidi:1</strong>
</pre></blockquote>

Nun kannst du über den Synthesizer hören, was du auf dem MIDI-Keyboard
spielst.
Die Handbuchseite von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=midicat&amp;sektion=1"
>midicat(1)</a> bietet weitere Informationen.

<!-- <h3>Playing, recording MIDI sequences</h3> -->

<p>
Das Hauptwerkzeug zum Abspielen von Standard-MIDI-Dateien ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=midiplay&amp;sektion=1"
>midiplay(1)</a>. Standard-MIDI-Dateien abspielen ist ganz einfach
möglich (in diesem Beispiel über den Synthesizer):

<blockquote><pre>
$ <strong>midiplay -f rmidi:0 file.mid</strong>
</pre></blockquote>

<p>
Um MIDI-Dateien aufzunehmen, kannst du das <tt>smfrec</tt>-Werkzeug
verwenden, das sich im <tt>audio/midish</tt>-Port befinden, zum
Beispiel:

<blockquote><pre>
$ <strong>smfrec -d rmidi:0 -i rmidi:1 file.mid</strong>
</pre></blockquote>

Hiermit wird aufgezeichnet, was auf dem Keyboard (<tt>rmidi:1</tt>)
gespielt wird , während es in Echtzeit an den Synthesizer
(<tt>rmidi:0</tt>) gesendet wird, so dass du hören kannst, was
du gerade spielst. Komplizierte Anwendungen wie Editieren, Routing
und Mixen sowie Transformieren von MIDI-Daten können mit dem
<tt>rmidish</tt>-Werkzeug im <tt>audio/midish</tt>-Port realisiert
werden.

<p>
<a name="lossyaudio"></a>
<h2>13.8 - Was gibt es über Ogg-Vorbis- und MP3-Encoding zu sagen?</h2>

Diese Formate wurden bereits in der Sektion
<a href="#playaudio">Unterschiedliche Audiotypen abspielen</a>
aufgeführt. In dieser Sektion werden wir eine kurze Einführung in die
Kodierung solcher Dateien geben. Wenn du interessiert bist, etwas über
die Kompressionscodecs zu lernen, kannst die Wikipedia-Artikel über
<a href="http://en.wikipedia.org/wiki/Vorbis">Vorbis</a> und
<a href="http://en.wikipedia.org/wiki/MP3">MP3</a> lesen.

<h3>Ogg Vorbis</h3>

Die Kodierung von einem rohen, WAV- oder AIFF-Audioformat in
<a href="http://www.vorbis.com/">Ogg Vorbis</a> kann mit dem
Programm <b>oggenc</b> durchgeführt werden, welches in dem
Package <tt>audio/vorbis-tools</tt> enthalten ist. Dies kann aus den
OpenBSD-Ports oder -Packages bezogen werden.

<p>
Nehmen wir an, du hättest eine Anzahl WAV-Dateien, die bereit sind,
kodiert zu werden - beispielsweise dein Lieblingsalbum, welches du von
der CD extrahiert hast.
Um alle diese Dateien mit einer ungefähren Bitrate von 192 kbps zu
kodieren, könntest du das folgende Kommando verwenden:
<blockquote><pre>
$ <strong>oggenc *.wav -b 192</strong>
</pre></blockquote>

Wenn der Vorgang beendet ist, wirst du einen Satz .ogg-Dateien im
aktuellen Verzeichnis finden.
Weitere ausführliche Beispiele sowie Optionen für die Kodierung sind
im oggenc-Manual zu finden.

<h3>MPEG-1 Audio Layer 3 (MP3)</h3>

Solltest du das MP3-Format nutzen wollen, so kannst du den
<a href="http://lame.sourceforge.net/">»Lame ain't an MP3 encoder« (LAME)</a>
benutzen, ein erklärendes Programm um mehr über MP3-Kodierung zu
lernen. Lame ist im OpenBSD-Ports-Tree enthalten.
Wegen der MP3-Patente ist das Package nicht auf den
<a href="../../de/orders.html">offiziellen CD-Sets</a> zu finden.

<p>
Nachfolgend ein kleines Beispiel einer Kodierung einer WAV-Datei mit
einer Bitrate von 192 kbps:
<blockquote><pre>
$ <strong>lame -b 192 track01.wav track01.mp3</strong>
</pre></blockquote>

Für alle Optionen und Details, schaue bitte in das mitgelieferte
Manual zu Lame.

<p>
<a name="playDVD"></a>
<h2>13.9 - Wie kann ich Video-DVDs unter OpenBSD abspielen?</h2>

OpenBSD unterstützt DVD-Medien über das ISO-9660-Dateisystem, das
ebenfalls auf CD-ROMs genutzt wird, und - seit OpenBSD 3.8 - ebenfalls
über das neuere
<a href="http://www.osta.org/specs/">Universal-Disk-Format- (UDF-)</a>
Dateisystem, das man auf einigen DVDs vorfinden kann.
Die meisten DVD-Videos und DVD-ROMs verwenden jedoch das
UDF-Bridgeformat, welches eine Kombination von DVD-MicroUDF (ein Teil
von UDF 1.0) und dem ISO-9660-Dateisystem ist. Es wird als
Abwärtskompatibilität genutzt.

<p>
Da die meisten Computer mit DVD-ROM-Laufwerken softwareseitige
Dekodierung verwenden ist es empfehlenswert, mindestens einen Pentium
II mit 350 MHz zu verwenden, um eine gute Wiedergabequalität zu
erhalten.

<p>
Einige populäre Mediaprogramme, die DVDs abspielen können, wurden auf
OpenBSD portiert. Beispiele sind
<a href="http://www.dtek.chalmers.se/groups/dvd/">ogle</a>,
<a href="http://www.mplayerhq.hu/">mplayer</a>,
<a href="http://www.xine-project.org/">xine</a> und
<a href="http://kaffeine.sourceforge.net/">kaffeine</a>.
Bitte lies die Installationsanweisungen, die im entsprechenden Package
mitgeliefert werden, denn die Programme könnten vorher noch
konfiguriert werden müssen.
Mit diesen Programmen ist es möglich, die DVD durch direkten Zugriff
auf die Rohdaten abzuspielen.
Selbstverständlich kann man die DVD auch zuerst mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_cd9660&amp;sektion=8">mount_cd9660(8)</a>
mounten und sie dann von diesem oder von einem anderen gemounteten
Dateisystem abspielen.

<p>
<b>Anmerkung:</b>
<ul>
<li>Fast alle DVDs, die du kaufst, sind mit dem »Content Scrambling
System« (CSS) verschlüsselt.
Um in der Lage zu sein, auch diese abspielen zu können, kannst du die
<b>libdvdcss</b>-Bibliothek benutzen. Sie kann ebenfalls als Port oder
Package installiert werden.

<li>Bedenke, dass ein Ländercode auf der DVD sein könnte. Dies sollte
allerdings kein Problem beim Abspielen mit dem Computer darstellen.
</ul>


<a name="burnCD"></a>
<h2>13.10 - Wie brenne ich CDs und DVDs?</h2>

<a name="burnIntro"></a>
<h3>13.10.1 - Einführung und grundlegende Einrichtung</h3>

Stelle zunächst sicher, dass dein CD/DVD-Brenner von deinem Kernel
erkannt und konfiguriert worden ist.
Die meisten SCSI-Laufwerke werden unterstützt.
SATA-, IDE/ATAPI- und USB-Laufwerke werden durch SCSI-Emulation unterstützt.
Dein Laufwerk kannst du schnell in der Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
finden.
Suche einfach Zeilen, die mit cd beginnen. Als Beispiel:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;TOSHIBA, CD-ROM XM-5702B, 2826&gt; SCSI0 5/cdrom removable
cd1 at scsibus1 targ 4 lun 0: &lt;PLEXTOR, CD-R PX-R412C, 1.04&gt; SCSI2 5/cdrom removable
</pre></blockquote>

<h4>Aber <tt>cdrecord -scanbus</tt> funktioniert nicht!</h4>

Das stimmt. OpenBSD nutzt unterschiedliche Namensplatzhalter für
Laufwerke als das Betriebssystem, worauf das cdrecord-Programm
geschrieben worden ist. Alle konfigurierten Laufwerke sollten in der
Ausgabe von dmesg - wie soeben gezeigt - erscheinen. Die Information,
die du brauchst, ist hier zu finden.

<h4>Error: <tt>mount_cd9660: /dev/cd2c on /mnt/cdrom: No such file or directory</tt></h4>

Standardmäßig erstellt der OpenBSD-Installer nur 2 Laufwerkseinträge:
für <tt>cd0</tt> und <tt>cd1</tt>.
Um ein <tt>cd2</tt>-Laufwerk zu benutzen, musst du den entsprechenden
Laufwerkseintrag selbst erstellen.
Der empfohlene Weg, dies zu tun, ist das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=MAKEDEV&amp;sektion=8">MAKEDEV(8)</a>-Skript
(wähle die entsprechende Plattform aus):

<blockquote><pre>
# <strong>cd /dev</strong>
# <strong>./MAKEDEV cd2</strong>^
</pre></blockquote>

In den folgenden Teilen werden wir auf den CD/DVD-Brenner meistens
durch die »<i>rohe</i> Charaktergerätedatei« und <b>nicht</b> das
<i>block</i>-Laufwerk zugreifen.

<h4>CD/DVD-Brenneroperationen überprüfen</h4>

Es ist empfohlen, stets zu prüfen, ob der CD/DVD-Brenner korrekt
arbeitet.  In diesem Beispiel benutzen wir diesen USB-2.0-DVD-Brenner:

<blockquote><pre>
cd2 at scsibus2 targ 1 lun 0: &lt;LITE-ON, DVDRW LDW-851S, GS0C&gt; SCSI0 5/cdrom removable
</pre></blockquote>

Benutze ihn, indem du eine CD/DVD darin mountest.
Wenn erwünscht, kannst du auch die Übertragungsrate messen, wenn du
Dateien von dem CD/DVD-Laufwerk auf die Festplatte kopierst.
Das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=time&amp;sektion=1">time(1)</a>-Kommando
wird ein williger Helfer sein.

<p>
Wenn hier irgendwelche Fehler auftreten, ist es weise, diese Fehler
zunächst zu beheben, bevor du probierst, CDs/DVDs zu beschreiben.

<h4>Ich möchte jetzt meine CD beschreiben. Können wir anfangen?</h4>

Bevor wir weitermachen, ein paar Worte darüber, was man berücksichtigen
sollte:

<ul>
<li>Lasse keine Jobs laufen, die intensiv auf die Festplatte zugreifen,
während du eine CD/DVD beschreibst. Dies reduziert die Ausgabe auf
deinen CD/DVD-Brenner. Wenn der Brenner dann zu lange auf die
Ausgabe warten muss, wird ein leerer Puffer verarbeitet. Dieses
Phänomen wird als Pufferunterlauf bezeichnet.
<li>Verhindere während des Schreibvorgangs jegliche Erschütterungen
deines Brenners. Erschütterungen können den Laser von seiner Bahn
abdriften lassen. Die Daten werden so u.&nbsp;U. nicht korrekt
geschrieben.
<li>Nicht jeder DVD-Brenner unterstützt jedes Format; siehe weiter
unten.
</ul>

<a name="writeCD"></a>
<h3>13.10.2 - CDs brennen</h3>

<h4>Daten-CD-ROMs erstellen</h4>

Zunächst wirst du ein ISO-9660-Dateisystem auf der CD-ROM erstellen
wollen. Um das zu tun, kannst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mkhybrid&amp;sektion=8">mkhybrid(8)</a>
aus dem Basissystem oder das mkisofs-Werkzeug verwenden, das sich im
cdrtools-<a href="faq15.html#PkgMgmt">Package</a> befindet und mit
größeren Dateistrukturen besser umgehen kann. Im folgenden Beispiel
verwenden wir mkhybrid - der Aufruf von mkisofs ist sehr ähnlich.

<p>
Als Beispiel sagen wir, dass wir die OpenBSD-Kernelquellen in einem
ISO-9660-Image speichern wollen.

<blockquote><pre>
$ <strong>mkhybrid -R -o sys.iso /usr/src/sys</strong>

Using ALTQ_RMC.000;1 for  /usr/src/sys/altq/altq_rmclass_debug.h (altq_rmclass.h)
...
Using IEEE8021.00H;1 for  /usr/src/sys/net80211/ieee80211_amrr.c (ieee80211.c)
 10.89% done, estimate finish Sat Nov  3 08:01:23 2007
 21.78% done, estimate finish Sat Nov  3 08:01:28 2007
...
 87.12% done, estimate finish Sat Nov  3 08:01:31 2007
 98.01% done, estimate finish Sat Nov  3 08:01:32 2007
Total translation table size: 0
Total rockridge attributes bytes: 896209
Total directory bytes: 2586624
Path table size(bytes): 11886
Max brk space used 0
45919 extents written (89 Mb)
</pre></blockquote>

<p>
Die Option <tt>-R</tt> sagt <tt>mkhybrid</tt>, dass die
Rock-Ridge-Erweiterungen in dem ISO-9660-Image zu erstellen sein werden.
Das »Rock Ridge Interchange«-Protokoll wurde entwickelt, um die
POSIX-Dateisystemsemantik in ISO-9660-Dateisystemen zu unterstützen
(z.&nbsp;B. lange Dateinamen, Benutzerrechte, Datei- und Softlinks,
Laufwerksknoten, tiefe Dateihierachien [mehr als 8 Unterverzeichnisse]
etc.)

<p>
Wenn du willst, dass lange Dateinamen auf deiner CD-ROM unter DOS und
Windows gelesen werden können, dann solltest du die Option <tt>-J</tt>
benutzen, um die Joliet-Erweiterung dem ISO-9660-Image hinzuzufügen.

<p>
Nachdem das Dateisystem erstellt worden ist, kannst du es überprüfen,
indem du das
<a href="faq14.html#MountImage">ISO-9660-Image mountest</a>.
Wenn das in Ordnung ist, ist alles bereit, um die CD-R(W) zu brennen.
Am einfachsten ist es, hierfür das <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1"
>cdio(1)</a>-Werkzeug zu verwenden.

<p>
Wenn du wiederbeschreibbare CDs verwendest (wie zum Beispiel CD-RW),
dann musst du das Medium erst löschen, bevor du es brennen kannst.

<blockquote><pre>
# <strong>cdio -f cd1c blank</strong>
</pre></blockquote>

Du kannst das zuvor erstellte ISO-Image nun auf eine unbeschriebene
CD-R(W) brennen. Dazu kannst du folgendes Kommando verwenden:

<blockquote><pre>
# <strong>cdio -f cd1c tao sys.iso</strong>
</pre></blockquote>

Mit den gerade verwendeten Optionen sagen wir cdio, dass das zweite
CD-ROM-Laufwerk als Brenner genutzt werden soll.

<p>
Um zu überprüfen, ob die CD korrekt gebrannt worden ist, kannst du sie
mounten und prüfen, ob die Daten entsprechend vorhanden sind.
Um das Dateisystem zu mounten, solltest du das <i>block</i>-Laufwerk
für das CD-ROM-Laufwerk benutzen, welches in diesem Fall auch der
CD-Brenner ist.

<blockquote><pre>
# <strong>mount /dev/cd1c /mnt/cdrom</strong>
</pre></blockquote>


<h4>Audio-CDs erstellen</h4>

Um Audio-CDs zu brennen, kannst du ebenfalls <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1"
>cdio(1)</a> mit der Option <tt>tao -a</tt> verwenden.

<p>
Als Beispiel werde ich eine Sicherungskopie von einer meiner Musik-CDs
erstellen. Dazu sind zwei Schritte nötig:

<ol>
<li>Ziehe die Audiotracks von der originalen CD. Als Beispiel:
<blockquote><pre>
# <strong>cdio -f cd1c cdrip</strong>
</pre></blockquote>

Dieses Kommando extrahiert eine Reihe WAV-Dateien von deinem zweiten
CD-ROM-Laufwerk auf deine Festplatte.
<li>Schreibe die Audiotracks auf eine leere CD. Zum Beispiel:
<blockquote><pre>
# <strong>cdio -f cd1c tao -a *.wav</strong>
</pre></blockquote>
</ol>


<a name="writeDVD"></a>
<h3>13.10.3 - DVDs brennen</h3>

Es gibt einige wichtige Dinge, die du über DVDs wissen solltest, bevor
du anfängst, deine eigenen DVDs zu brennen.

<p>
<b>Wichtige Anmerkungen:</b>
<ul>
<li>Wenn du wirklich alles über DVDs wissen möchtest, empfehle ich dir
das wirklich ausführliche
<a href="http://www.dvddemystified.com/dvdfaq.html">DVD-FAQ</a> zu
studieren.
<li>In dieser Sektion konnten wir nur begrenzt testen. Außerdem haben wir
sicherlich nicht alle möglichen Kombinationen von Rohlingen und Brennern
probieren können. Bisher hatten wir keine positiven Erfahrungen mit
irgendeinem der weiter unten aufgeführten DVD-Formaten gemacht -
wir haben auch noch von keinen Erfolgserlebnissen gehört.
Wir würden uns aber freuen, wenn du uns
<a href="mailto:faq@openbsd.org">deine Erfahrungen zu dieser Sektion
mitteilen würdest</a>.
</ul>

<h4>Unterschiedliche DVD-Formate</h4>

Es gibt eine Menge unterschiedliche DVD-Formate. Üblicherweise
werden die Formate DVD-R, DVD-RW, DVD+R und DVD+RW verwendet (R
bedeutet, dass die DVDs einmal beschreibbar sind. RW bedeutet, dass
sie einige tausendmal beschrieben werden können).
Dies sind stark konkurrierende Standards.

<p>
Einen großen Unterschied stellt das DVD-RAM-Format dar, welches
hauptsächlich als Datenlaufwerk entwickelt worden ist und erweiterte
Paketschreibfunktionen bietet, was es möglich macht, es als eine Art
optische Festplatte zu nutzen. Für die Benutzung im Zusammenhang mit
Video wird DVD-RAM nicht empfohlen - das Format ist nicht kompatibel zu
einem normalen DVD-Player.

<p>
Der sinnvollste Weg ist es, Medien zu verwenden, die zu deinem
DVD-Brenner passen. Wenn du zu anderen DVD-Spielern kompatibel sein
möchtest, dann gehe sorgfältig vor und lies
<a href="http://www.dvddemystified.com/dvdfaq.html#4.3.1">diese
Sektion</a> der DVD-FAQ.

<h4>DVD-Brenngeschwindigkeit</h4>

Es könnte hilfreich sein, festzuhalten, dass die Angabe der
DVD-Geschwindigkeit anders ist als die einer CD-ROM.
Die folgende Tabelle gibt einen Überblick:
<p>
<table border="1" style="empty-cells: show;">
<tr align="center">
<td>DVD-Lese/Schreibgeschwindigkeit</td>
<td>Übertragungsrate (MB/s)</td>
<td>Äquivalente CD-R(W)-Lese/Schreibgeschwindigkeit</td>
</tr>
<tr align="center">
<td>1x</td>
<td>1,32</td>
<td>9x</td>
</tr>
<tr align="center">
<td>2x</td>
<td>2,64</td>
<td>18x</td>
</tr>
<tr align="center">
<td>4x</td>
<td>5,28</td>
<td>36x</td>
</tr>
<tr align="center">
<td>8x</td>
<td>10,57</td>
<td>72x</td>
</tr>
</table>

<p>
Wie der Tabelle zu entnehmen ist, ist die Transferrate relativ hoch und
du solltest prüfen, ob dein Bus (SCSI, IDE/ATAPI, SATA, USB) genug
Leistung bietet, um den Durchsatz zu gewährleisten. Besonders die
älteren USB-1.0- und -1.1-Schnittstellen arbeiten mit langsameren
Übertragungsraten wie 1,5 MBit/s und 12 MBit/s.
Das bedeutet, dass USB 1.0 einen maximalen Durchsatz von 178,8 kByte/s
und USB 1.1 einen maximalen Durchsatz von 1,43 MB/s hat.
USB 2.0 ist mit 480 MBit/s bzw. 1,43 MB/s um einiges schneller.
Allgemein kann man sagen, dass die Geschwindigkeit von SCSI-, SATA- und
IDE/ATAPI-Bussen völlig ausreichend ist.

<h4>Brennen der DVD</h4>

Grundsätzlich kann man sagen, dass das Brennen von DVDs ähnlich dem
Brennen von CD-ROMs ist. Die verwendete Software ist jedoch
unterschiedlich. Derzeit ist die beste Möglichkeit <b>growisofs</b> aus
dem <tt>sysutils/dvd+rw-tools</tt>-Package. Dieses Programm schreibt ein
ISO-9660-Image auf die DVD. Es werden alle wiederbeschreibbaren
DVD-Formate von den dvd+rw-tools unterstützt.

<p>
Für den Fall, dass du mehr über das Medium in deinem DVD-Brenner
(z.&nbsp;B. wenn du die Informationsbeilagen verloren hast oder einfach
nur - wie ich - schlecht organisiert bist) erfahren möchtest, kannst du
das Programm <b>dvd+rw-mediainfo</b> benutzen.

<!--blockquote><pre>
$ <strong>dvd+rw-mediainfo /dev/rcd2c</strong>
INQUIRY:                [LITE-ON ][DVDRW LDW-851S  ][GS0C]
GET [CURRENT] CONFIGURATION:
 Mounted Media:         1Ah, DVD+RW
 Current Write Speed:   4.0x1385=5540KB/s
 Write Speed #0:        4.0x1385=5540KB/s
 Write Speed #1:        2.4x1385=3324KB/s
GET [CURRENT] PERFORMANCE:
 Write Performance:     4.0x1385=5540KB/s@[0 -> 0]
 Speed Descriptor#0:    00/0 R@2.4x1385=3324KB/s W@4.0x1385=5540KB/s
 Speed Descriptor#1:    00/0 R@2.4x1385=3324KB/s W@2.4x1385=3324KB/s
READ DVD STRUCTURE[#0h]:
 Media Book Type:       92h, DVD+RW book [revision 2]
 Media ID:              SONY/S11
 Legacy lead-out at:    2295104*2KB=4700372992
READ DISC INFORMATION:
 Disc status:           blank
 Number of Sessions:    1
 State of Last Session: empty
 Number of Tracks:      1
READ TRACK INFORMATION[#1]:
 Track State:           blank
 Track Start Address:   0*2KB
 Free Blocks:           2295104*2KB
 Track Size:            2295104*2KB
READ CAPACITY:          1*2048=2048
</pre></blockquote-->

Es gibt zwei Möglichkeiten, eine DVD zu brennen:
<ul>
<li>Erstelle ein ISO-9660-Image deiner DVD und speichere es auf deiner
Festplatte. Danach brenne dieses Image auf eine DVD.
<li>Schreibe gleich ein ISO-9660-Image von deinen Daten auf die DVD.
</ul>

<p>
Ich habe vorab ein ISO-9660-Image von den OpenBSD-CVS-Modulen (src,
xenocara, ports und www) in meinem /cvs-Verzeichnis auf meiner Festplatte
erstellt. Ich habe das folgende Kommando verwendet, welches dem zum
Erstellen von CD-ROM-Images sehr ähnlich ist.

<blockquote><pre>
$ <strong>mkhybrid -r -o cvs.iso /cvs</strong>
</pre></blockquote>

Wenn erwünscht, teste das ISO-9660-Dateisystem, indem du das
<a href="faq14.html#MountImage">Image mountest</a>.
Um dieses Image (über 2 GB) auf eine leere DVD zu brennen, kann man
Folgendes benutzen:

<blockquote><pre>
# <strong>growisofs -dvd-compat -Z /dev/rcd2c=cvs.iso</strong>
Executing 'builtin_dd if=cvs.iso of=/dev/rcd2c obs=32k seek=0'
/dev/rcd2c: pre-formatting blank DVD+RW...
/dev/rcd2c: "Current Write Speed" is 4.1x1385KBps.
  23822336/1545832448 ( 1.5%) @3.9x, remaining 5:19
  42172416/1545832448 ( 2.7%) @3.9x, remaining 5:20
  60522496/1545832448 ( 3.9%) @3.9x, remaining 4:54
...
1504706560/1545832448 (97.3%) @3.9x, remaining 0:07
1523318784/1545832448 (98.5%) @3.9x, remaining 0:04
1541898240/1545832448 (99.7%) @3.9x, remaining 0:00
/dev/rcd2c: flushing cache
/dev/rcd2c: writing lead-out
/dev/rcd2c: reloading tray
</pre></blockquote>

Die Option <tt>-Z</tt> sagt growisofs, dass es eine Initialsession
auf mein DVD-Laufwerk brennen soll, welches an cd2 gebunden ist.
Die Option <tt>-dvd-compat</tt> sagt, dass die DVD geschlossen werden
soll, d.&nbsp;h. keine weiteren Brennvorgänge sind mehr möglich.
Dies sollte eine bessere Kompatibilität zu Video-DVD-Spielern und
älteren DVD-ROM-Einheiten bieten.

<p>Beachte auch, wie growisofs die Geschwindigkeit anzeigt. In diesem
Fall 3,9-fache DVD Geschwindigkeit. Das ist entsprechend der Kombination
des Rohlings und des Brenners, wie auch dvd+rw-mediainfo anzeigt.

<p>
Wenn du zu wenig Platz hast, um vorab das ISO-9660-Image auf deiner
Festplatte zu erstellen, dann kannst du es auch direkt auf die DVD
brennen. Aber zuvor machen wir einen Testlauf, welcher das Erstellen
eines ISO-9660-Images simuliert.

<blockquote><pre>
# <strong>growisofs -dry-run -Z /dev/rcd2c -R /cvs</strong>
</pre></blockquote>

Wenn dieses Kommando erfolgreich ist, dann starte es nochmal ohne
-dry-run.

<blockquote><pre>
# <strong>growisofs -Z /dev/rcd2c -R /cvs</strong>
</pre></blockquote>

<p>
Es ist außerdem möglich, Daten zu einer bereits beschriebenen DVD
hinzuzufügen, indem man die Option -M verwendet. Dann wird eine neue
Session geschrieben.

<blockquote><pre>
# <strong>growisofs -M /dev/rcd2c -R /mydata</strong>
</pre></blockquote>

Für mehr Informationen über growisofs, lies bitte das Manual.

<p>
Wenn du den Brennvorgang abgeschlossen hast, so mounte die DVD und
prüfe, ob alle Daten, die gebrannt werden sollten, auch tatsächlich
vorhanden sind.

<h4>Warum erhalte ich nicht die zu erwartende Brenngeschwindigkeit?</h4>

Anstelle der zuvor beschriebenen Ausgabe könntest du Folgendes sehen:

<blockquote><pre>
   4784128/1545832448 ( 0.3%) @0.7x, remaining 26:50
   7929856/1545832448 ( 0.5%) @0.7x, remaining 29:05
  14123008/1545832448 ( 0.9%) @0.7x, remaining 27:06
...
</pre></blockquote>

was um einiges langsamer ist.
Das bedeutet, dass du aus irgendwelchen Gründen nicht genug
Datendurchsatz auf dem Bus hast, den dein DVD-Brenner verwendet.
In dem vorigen Beispiel war der USB-DVD-Brenner an einer Maschine
angeschlossen, auf der das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ehci&amp;sektion=4">ehci(4)</a>-Laufwerk,
das vom USB-2.0-Controller benutzt wird, nicht korrekt initialisiert
werden konnte. Wie immer bist du herzlich eingeladen, Patches und
Testergebnisse zu erstellen. Der DVD-Brenner fällt also zurück in seinen
USB-1.1-Modus, welcher langsamer ist, und erhält somit einen
reduzierten Datendurchsatz. Allerdings ist USB 1.1 auf 12 MBit/s
begrenzt, was 1,43 MB/s oder 1,08-fache Brenngeschwindigkeit der DVD
bedeutet. Der DVD-Brenner verwendet eine geringere Brenngeschwindigkeit,
um das Risiko von Pufferunterläufen zu reduzieren.

<p>
<a name="convert"></a>
<h2>13.11 - Ich möchte meine Mediendateien aber im Format XYZ haben.</h2>

<h3>Zwischen verschiedenen Audioformaten konvertieren</h3>

Lass uns davon ausgehen, dass du die Soundaufnahme aus
<a href="#recordaudio">FAQ 13 - Audioaufnahme</a> weiter verarbeiten
willst. Diese Aufzeichnung wurde im rohen Format abgespeichert. Es
wäre sinnvoll, sie zu konvertieren, da das rohe Format keinen Header
einfügt und die Aufnahmeparameter daher bei jeder Verwendung der Datei
angegeben werden müssten.

<p>
Ein Soundkonvertierungswerkzeug ist <tt>audio/sox</tt>, das über
Packages und Ports zur Verfügung steht.
<b>sox</b> unterstützt AIFF-, AU-, MP3-, Ogg-Vorbis-, RIFF-WAV- und
rohe Formate neben weiteren exotischen Formaten, auf die man treffen
könnte. Es folgt ein Beispiel für die Konvertierung der Aufzeichnung
zum RIFF-WAV-Format.

<blockquote><pre>
$ <strong>sox -U -c 1 -r 8000 -b myvoice.raw myvoice.wav</strong>
</pre></blockquote>

Beachte, dass die angegeben Parameter mit den Parametern übereinstimmen,
die bei der Aufnahme angegeben wurden.
Dies war nur ein Beispiel. Weitere audiobezogene Bibliotheken und
andere Softwareprodukte können für die Audiokonvertierung genutzt
werden.

<p>
<b>Hinweis:</b>
Es ist nicht empfehlenswert, zwischen verschiedenen verlustbehafteten
Kompressionsformaten zu konvertieren. Beispielsweise lassen MP3- und
Vorbis-Formate unterschiedliche Stellen der originalen Audiowaveform
fallen. Solltest du also eine MP3-Datei ins Ogg-Vorbis-Format
konvertieren, dann wird das Resultat sich eventuell schlechter anhören
als die Original-MP3.

<h3>Zwischen verschiedenen Audioformaten konvertieren</h3>

Es ist wichtig, eine klare Grenze zwischen folgenden Eigenschaften
zu ziehen:
<ul>
<li>Das Containerdateiformat - weit verbreitete Beispiele sind
MP4, OGG, MPEG, MOV, AVI, ASF.
<li>Der Videocodec - zum Beispiel MPEG-1, MPEG-2, MPEG-4-kompatible
Codecs (wie z.&nbsp;B. Xvid und DivX), FFmpeg, WMV,&nbsp;... -
lies diesen
<a href="http://en.wikipedia.org/wiki/Video_codec">Wikipedia-Artikel
über Videocodecs</a>, um mehr über sie zu erfahren.
</ul>

Unter OpenBSD ist momentan die Unterstützung für MPEG- und AVI-Container
am ausgereiftesten.

<p>
Zwei oft eingesetzte Werkzeuge sind <tt>multimedia/transcode</tt> und
<b>mencoder</b> (Teil von <tt>x11/mplayer</tt>). Sie verwenden - oder
könnten es - die <b>libavcodec</b>-Bibliothek als Teil des Ports
<tt>graphics/ffmpeg</tt>, dessen Ausgabe gute Qualität hat. Du kannst
selbstverständlich <b>ffmpeg</b> auch gleich direkt verwenden.
Es sollte auch möglich sein, den XviD-Encoder aus
<tt>multimedia/xvidcore</tt> zu nutzen.

<p>
Die Dokumentation, die in Form von Manualseiten und HTML-Dokumenten
in <tt>/usr/local/share/doc</tt> vorliegt, beinhaltet viele Beispiele -
daher wird DRINGEND dazu geraten, diese Dokumentation zu lesen.

<p>
<a name="streaming"></a>
<h2>13.12 - Ist es möglich, Streams unter OpenBSD abzuspielen?</h2>

Ja, ist es. Viele Audio- und Videostreams werden auf einer begrenzten
Anzahl Plattformen problemlos funktionieren. Ein paar von ihnen nicht.

<p>
Diese Sektion soll keine ausführliche Liste aller funktionierenden
Streamingformate sein, die auf irgendeiner Hardwarearchitektur
funktionieren. Um mehr darüber zu erfahren, solltest du dich ausgiebig
mit Streamingmedien auseinandersetzen. Eine etwas alte aber dennoch
gute Einführung bietet dieses
<a href="http://www.oreilly.com/catalog/sound/chapter/ch05.html">Kapitel
über Streamingmedien</a> des O'Reilly-Buchs mit dem Titel Designing Web
Audio.

<p>
Das erste, was man einsehen sollte, ist dass es viele verschiedene
Streamingprotokolle gibt. Das Streaming<b>protokoll</b> definiert, wie
die Streams über das Netzwerk gesendet werden. Sie wurden entwickelt,
um eine effiziente Übertragung von Audio/Video über das Internet in
Echtzeit bereitzustellen. Größtenteils ist das Streamingprotokoll
ein Applikationsprotokoll (Schicht 7), welches entweder UDP oder TCP
(Schicht 4) als Transportprotokolle nutzt. Das »User Datagram«-Protokoll
UDP ist für diese Aufgaben sehr gut geeignet, da es keine Rückantworten
auf die Pakete erfordert oder jegliche andere Netzwerklasten hervorruft.
Viele spezialisierte aber proprietäre Protokolle wurden entwickelt,
z.&nbsp;B. Microsoft Media Services (MMS) oder das »Real Time
Streaming«-Protokoll (RTSP). Wie wir sehen werden wird auch HTTP (das
wiederum TCP nutzt) ebenfalls verwendet, obwohl es keine Möglichkeit
bietet, Streams bei einer konstanten Bitrate anzubieten, wie es etwa
UDP, RTSP und MMS machen.

<p>
Ebenso gibt es ein Streaming<b>format</b>, das definiert, wie die
Audio/Videodaten organisiert und abgespielt werden können. Die
am weitesten verbreiten Formate sind MP3, Real Audio (RA, RM) und
Windows Media (ASF) - alles proprietäre Technologien. Ab und zu könntest
du auch auf einen Stream treffen, der das offene Ogg-Vorbis-Format
nutzt.

<p>
Um ein Beispiel zu liefern, werde ich ein paar Schritt erklären, wie man
<a href="http://www.radio1.be">Radio 1</a> hören kann - einen der
belgischen Nationalradiosender. Browsereingebettete Plugins stehen unter
OpenBSD nicht zur Verfügung, daher muss man etwas mehr tun als nur ein
einfaches »click and play«.

<ul>
<li>Stelle fest, welches Streamingprotokoll und -format genutzt
wird.<br>
Dies wird normalerweise auf der Website angegeben, von der aus du auf
den Stream zugreifst. In diesem Fall folgte ich dem Link »Listen live«
von der Hauptseite. Dort erfuhr ich, dass mein Betriebssystem nicht
unterstützt wird. Sie waren freundlich indem sie mir mitteilen, dass ich
auch auf ihre MP3-Streams zugreifen kann, ohne ihren eingebetteten
Flashplayer benutzen zu müssen. Abgesehen davon erschien eine Liste von
Links zu den nationalen Radiosendern, wodurch ich mit dem nächsten
Schritt weitermachen konnte. Achte darauf, dass ich einen
Browser verwendet habe, der JavaScript konnte, um so weit kommen zu
können.
<li>Ermittle die genaue URL.<br>
Viele Websites verweisen auf eine Containermetadatei oder Playlist
(z.&nbsp;B. M3U, ASX, RAM), welche die tatsächliche URL des Streams
beinhalten. Speichere die Datei einfach ab und lies die URL aus ihr. In
meinem Beispiel wäre sie:

<blockquote><pre>
$ <strong>ftp http://internetradio.vrt.be/dab/hoeluisteren/pc/help/gebruiksvoorwaarden/stream_11.m3U</strong>
$ <strong>cat stream_11.m3U</strong>
http://mp3.streampower.be/radio1-mid.mp3
http://mp3.streampower.be/radio1-low.mp3
http://mp3.streampower.be/radio1-high.mp3
</pre></blockquote>

Es sieht so als, als könnte ich sogar zwischen schlechter, normaler und
guter Qualität des Streams aussuchen. Andere Websites beinhalten einen
JavaScript-Code, um die URL zu generieren. In diesem Fall ist der beste
Ratschlag: Lies den HTML-Quelltext und die Skripte, auf die er verlinkt.
Es ist gut möglich, dass du so die URL rekonstruieren kannst.

<li>Um Streams abzuspielen, solltest du am besten <tt>x11/mplayer</tt>
verwenden, der über Packages und Ports verfügbar ist.
Er unterstützt die meisten Streamingprotokolle und -formate. Außerdem
ist bekannt, dass er auf den Plattformen amd64, i386, powerpc und
sparc64 läuft. Es gibt aber auch Alternativen:
<b>ogg123</b> aus <tt>audio/vorbis-tools</tt> (für Ogg-Vorbis-Streams),
<tt>audio/mpg123</tt> und <tt>audio/mpg321</tt> (für MP3-Streams),
XMMS aus <tt>audio/xmms</tt> und Videolan Client aus <tt>x11/vlc</tt>.
Das Beispiel weiterführend:

<blockquote><pre>
$ <strong>mplayer http://mp3.streampower.be/radio1-mid.mp3</strong>
</pre></blockquote>

<li>Wenn du möchtest, kannst du es dir auch etwas einfacher machen,
indem du ein Alias in deine <tt>.profile</tt> mit aufnimmst:

<blockquote><pre>
alias radio1='mplayer http://mp3.streampower.be/radio1-mid.mp3'
</pre></blockquote>

</ul>

<!--
check out http://www.cbc.ca/listen/index.html
it has DivX streams over MMS as well as Ogg Vorbis streams over HTTP.
maybe a good example but also nearly an ideal case...
-->

Windows-Media (AFS)-Streams funktionieren meistens auch, obwohl
sie Daten beinhalten könnten, die nur durch den
<tt>graphics/win32-codecs</tt>-Port verarbeiten werden können, welcher
auch nur auf i386 läuft (»pkg_info win32-codecs« wird dir sagen, welche
Codecs unterstützt werden).
Einige Real-Audio-Streams können mit Hilfe von <b>mplayer</b> auf i386
angesehen werden, wenn er in Verbindung mit den Ports
<tt>graphics/win32-codecs</tt> und <tt>emulators/fedora/base</tt>
genutzt wird (lies
<a href="http://marc.info/?t=107060510300001&amp;r=1&amp;w=2">diesen
Thread</a> der Ports-Mailingliste).

<p>
<a name="javaflash"></a>
<a name="javaplugin"></a>
<h2>13.13 - Kann ich mit meinem Webbrowser Java verwenden?
(nur i386 und amd64)</h2>

Das Java-Plugin ist Teil des Java Development Toolkits (JDK).
Lizenzprobleme machen es OpenBSD unmöglich, Binärpackages des JDKs
auszuliefern. Das bedeutet, dass du es aus den Ports installieren
musst. Weitere Informationen über das Erzeugen des JDKs kannst du
in <a href="faq8.html#Programming">FAQ 8 - Programmiersprachen</a>
erhalten. Sobald du mit dem Übersetzen vom JDK fertig bist kannst du
entscheiden, ob du das gesamte JDK-Package oder nur die
Java-Laufzeitumgebung (JRE) installieren möchtest, welches sich in
einem Subpackage befindet und das Browserplugin beinhaltet.

<p>
Nach der Installation werden Instruktionen angezeigt, wie man das
Java-Plugin mit den Webbrowsern Firefox oder Seamonkey verwendet.
Erstelle die symbolischen Verknüpfungen wie es beschrieben wird. Du
solltest dann das Java-Plugin nach dem Eingeben von »about:plugins« in
der Adresszeile sehen können.

<p>
Für KDEs Webbrowser Konqueror muss sich die java-Binary entweder im
PATH befinden oder der absolute Pfadname über das Menü
Settings -&gt; Configure Konqueror -&gt; Java &amp; JavaScript
angegeben werden. Standardmäßig befindet sich die java-Binary in
<tt>/usr/local/jre-<i>version</i>/bin/</tt> oder
<tt>/usr/local/jdk-<i>version</i>/bin/</tt>; je nachdem, ob du das
JRE oder das JDK installiert hast.

<p>
<b>Hinweis:</b> Java-Unterstützung wurde nur mit den Webbrowsern
Firefox, Seamonkey und Konqueror getestet. Wenn es auch mit anderen
Browsern gut funktioniert, lass es uns bitte wissen.

<p>
<a name="flashplugin"></a>
<h2>13.14 - Kann ich mit meinem Webbrowser Flash verwenden? (nur i386)</h2>

Das Flash-Plugin wird von Adobe nur in Binärform ausgeliefert.
Adobe bietet kein natives Plugin für OpenBSD an.
In Anbetracht ihres Sicherheits-Vorgeschichte danken wir ihnen für diese
Vernachlässigung.

<p>
Wenn du nur Videos im Flash-Format von den üblichen Webseiten anschauen
möchtest, so gibt es eine Reihe geeigneter Paket-Optionen, einschließlich:
<a href="http://code.google.com/p/get-flash-videos/">get_flash_videos</a>,
<a href="http://flavio.tordini.org/minitube">minitube</a>,
<a href="http://rg3.github.com/youtube-dl/">youtube-dl</a>,
get_iplayer und yt.
Außerdem hat das <a href="http://gnashdev.org/">Gnash</a>-Project in letzter
Zeit große Fortschritte gemacht, und könnte deine Bedürfnisse erfüllen.

<p>

<!--
Das könnte interessant sein aber derzeit ist keine Hardware zum Testen
verfügbar

<a name="camera"></a>
<h2>13.xx - Kann ich meine Digitalkamera unter OpenBSD benutzen?</h2>

<a name="scanner"></a>
<h2>13.yy - Wie kann ich meinen Scanner einrichten und benutzen?</h2>
-->

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Hardware- und Plattformspezifische Fragen]</a>
<a href= "faq14.html">[Zum Kapitel 14 - Einrichtung von Laufwerken]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq13.html,v 1.141 ]<br>
$Translation: faq13.html,v 1.44 2012/01/05 18:02:37 steffen Exp $<br>
-->
</small>

</body>
</html>
