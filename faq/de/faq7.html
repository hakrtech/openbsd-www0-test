<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>7 - Tastatur- und Display-Kontrollen</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta name="resource-type" content="document">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="de">
<meta name="description"   content="Die OpenBSD FAQ Seite">
<meta name="keywords"      content="openbsd,faq">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 1998-2004 by OpenBSD.">
</head>

<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->


<body bgcolor="#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq6.html">[Zu Sektion 6 - Netzwerk]</a>
<a href="../faq8.html">[Zu Sektion 8 - Allgemeine Fragen]</a>
</font>

<h1><font color="#e00000">7 - Tastatur- und Display-Kontrollen</font></h1>
<hr>
<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href= "#Keyboard"     >7.1 - Wie verändere ich die Belegung der Tastatur? (wscons)</a>
<li><a href= "#ConsoleMouse" >7.2 - Gibt es so etwas wie gpm für OpenBSD?</a>
<li><a href= "#ConsoleClear" >7.3 - Wie lösche ich die Konsole, sobald sich ein User ausloggt?</a>
<li><a href= "#Scrollback"   >7.4 - Auf den Konsolen 'Scrollback Puffer' zugreifen. (amd64, i386 und einige Alphas)</a>
<li><a href= "#SwitchConsole">7.5 - Wie wechsel ich zwischen den Konsolen? (amd64, i386 und einige Alphas)</a>
<li><a href= "#80x50"        >7.6 - Wie kann ich auf meiner Konsole eine Auflösung von
    80x50 bekommen ? (amd64, i386)</a>
<li><a href= "#SerCon"       >7.7 - Wie kann ich eine serielle Konsole benutzen?</a>
<li><a href= "#Blanker"      >7.8 - Gibt es einen "Blank" für die Konsole? (wscons)</a>
<li><a href= "#ALLCAPS"      >7.9 - ALLES WAS ICH TIPPE IST IN GROSSBUCHSTABEN!</a>
</ul>
<hr>

<br>
<p>
<a name= "Keyboard"></a>
<h2>7.1 - Wie verändere ich die Belegung der Tastatur? <i>(wscons)</i></h2>

<p>
Die Ports, die den <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a> 
Konsole Treiber benutzen: <a href="../../de/alpha.html">alpha</a>, 
<a href="../../de/amd64.html">amd64</a>,
<a href="../../de/cats.html">cats</a>,
<a href="../../de/hppa.html">hppa</a>,
<a href="../../de/i386.html">i386</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/sparc.html">sparc</a>,
<a href="../../de/sparc64.html">sparc64</a>
und <a href="../../de/vax.html">vax</a>.
<p>

Bei wscons(4) Konsolen werden die meisten Optionen mit dem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a> 
Utility kontrolliert. Beispielsweise würde man die Tastaturbelegung 
mit Hilfe von <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a> 
wie folgt ändern:

<blockquote><pre>
# <strong>wsconsctl -w keyboard.encoding=de</strong>
</pre></blockquote>

<p>
Im nächsten Beispiel werden wir die &quot;Caps Lock&quot; Taste neu 
belegen, und zwar so, dass sie nun &quot;Steuerung L&quot; ist:

<blockquote><pre>
# <strong>wsconsctl -w keyboard.map+="keysym Caps_Lock = Control_L"</strong>
</pre></blockquote>

<a name= "ConsoleMouse"></a>
<h2>7.2 -  Gibt es so etwas wie gpm für OpenBSD?</h2>

<p>
Für die <a href="../../de/alpha.html">alpha</a>,
<a href="../../de/amd64.html">amd64</a>
und <a href="../../de/i386.html">i386</a> Plattformen
bietet OpenBSD den 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsmoused&amp;sektion=8&amp;arch=i386">wsmoused(8)</a>
an, einen Port des moused(8) von FreeBSD. Er kann bei jedem Booten
automatisch aktiviert werden, indem du die passende Zeile in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
editierst.

<p>
<a name= "ConsoleClear"></a>
<h2>7.3 - Wie lösche ich die Konsole, sobald sich ein User ausloggt?</h2>

<p>
Dazu musst du eine Zeile in 
<kbd><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gettytab&amp;sektion=5">/etc/gettytab(5)</a></kbd>
einfügen. Ändere die Sektion, die so aussieht:

<blockquote><pre>
P|Pc|Pc console:\
        :np:sp#9600:
</pre></blockquote>

<p>
Füge die Zeile &quot;<tt>:cl=\E[H\E[2J:</tt>&quot; am Ende hinzu, so dass
das ganze schlussendlich so aussieht:

<blockquote><pre>
P|Pc|Pc console:\
        :np:sp#9600:\
	:cl=\E[H\E[2J:
</pre></blockquote>

<p>
<a name= "Scrollback"></a>
<h2>7.4 - Auf den Konsolen 'Scrollback Puffer' zugreifen <i>(amd64, i386 und einige Alphas)</i></h2>

<p>
OpenBSD bietet auf einigen Plattformen einen sogenannten "console scrollback
buffer".  Das macht es möglich, Informationen zu sehen, die bereits wieder 
oben aus dem Bildschirm gescrollt sind. Um sich auf- und abwärst 
zu bewegen, benutze einfach die Tastenkombinationen
<tt>[SHIFT]+[BILD AUF]</tt> und <tt>[SHIFT]+[BILD AB]</tt>
<p>
Der Standard-Scrollback-Puffer und somit auch die Anzahl der Seiten, die
du so betrachten kannst, beträgt 8. 
Das ist ein Feature des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>
Treibers, daher funktioniert das alles natürlich nicht ohne VGA Karte auf
jeglichen Plattformen (viele Alpha Systeme haben TGA video).


<p>
<a name= "SwitchConsole"></a>
<h2>7.5 - Wie wechsel ich zwischen den Konsolen?<i>(amd64, i386 und einige Alphas)</i></h2>

Auf amd64, i386 und einigen Alphas mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>
Karte bietet OpenBSD sechs virtuelle Terminal an,
/dev/ttyC0 bis /dev/ttyC5.
ttyC4 ist fü die Benutzung durch das X Window System reserviert, 
was noch fünf Text-Konsolen übrig lässt.
Du kannst zwischen ihnen hin- und herspringen, indem du 
Tastaturkombinationen
<tt>[STRG]+[ALT]+[F1]</tt>, <tt>[STRG]+[ALT]+[F2]</tt>,
<tt>[STRG]+[ALT]+[F3]</tt>, <tt>[STRG]+[ALT]+[F4]</tt> und
<tt>[STRG]+[ALT]+[F6]</tt> benutzt.

<p>
Die X Umgebung benutzt ttyC4, <tt>[STRG]+[ALT]+[F5]</tt>.
Wenn du X benutzt,
bringen dich die <tt>[STRG]+[ALT]+[F</tt><i>n</i><tt>]</tt> Tasten auf 
die Text-Konsolen,
<tt>[STRG]+[ALT]+[F5]</tt>
bringt dich wieder auf die grafische Oberfläche.

Wenn du mehr als die standardmäßige Anzahl von Text-Konsolen haben
willst, kannst du den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg(8)</a>
Befehl benutzen, um Bildschirme für ttyC6, ttyC7 und weitere zu erzeugen.
Zum Beispiel:

<blockquote>
<pre>
wsconscfg -t 80x25 6
</pre>
</blockquote>

erzeugt ein virtuelles Terminal für ttyC6,
was man mit <tt>[STRG]+[ALT]+[F7]</tt> erreicht.
Vergiss nicht, diesen Befehl deiner
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local(8)</tt></a>
Datei hinzuzufügen, wenn der zusätzliche Bildschirm auch nach dem nächsten
Reboot noch vorhanden sein soll.

<p>
Denk daran, dass du keinen "<tt>login:</tt>" Prompt
auf der neu erzeugten virtuellen Konsole erhälst, bis du sie in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><tt>/etc/ttys(5)</tt></a>,
auf "on" setzt und entweder mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
rebootest oder ein HUP Signal mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">kill(1)</a>
sendest.

<a name="80x50"></a>
<h2>7.6 - Wie bekomme ich eine Konsolen-Auflösung von 80x50? <i>(amd64, i386)</i></h2>

amd64 und i386 User haben normalerweise eine Konsole mit 25 Zeilen und
jede hat 80 Buchstaben. Viele VGA Grafikkarten sind aber in der Lage,
eine höhere  Textauflösung von 50 Zeilen mit 80 Buchstaben darzustellen.

<p>
Zunächst einmal kann man einen Font, der die gewünschte Auflösung
unterstützt, mittels des 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsfontload&amp;sektion=8">wsfontload</a>
Befehls laden. Der Standard-80x25-Text-Bildschirm benutzt 8x16 pixel
Fonts, um die vertikale Auflösung zu verdoppeln, müssen wir 8x8 pixel
Fonts benutzen.

<p>
Danach müssen wir die
<a href="#SwitchConsole">virtuelle Konsole</a> löschen und in der
gewünschten Auflösung neu erzeugen, und zwar mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg</a>
Befehl.

<p>
Das kann während des Bootens automatisch am Ende deiner
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local</tt></a>
Datei geschehen:
<blockquote>
<pre>
wsfontload -h 8 -e ibm /usr/share/misc/pcvtfonts/vt220l.808
wsconscfg -dF 5
wsconscfg -t 80x50 5
</pre>
</blockquote>

Wie bei jeder Änderung deiner Systemkonfiguration solltest du 
etwas Zeit mit den passenden Manual Seiten verbringen, um zu verstehen,
was diese Befehle eigentlich tun.

<p>
Die erste Zeile dort oben lädt den 8x8 Font. Die zweite Zeile
löscht den virtuellen Bildschirm Nummer 5 
(den man mit <tt>[STRG]-[ALT]-[F6]</tt> erreichen würde). Die dritte
Zeile erzeugt einen neuen Bildschirm 5 mit der Auflösung 50 Zeilen
mit je 80 Buchstaben. Wenn du alles so gemacht hast, werden deine anderen
virtuellen Bildschirme ganz normal im 80x25 Modus erscheinen, und der neue
Bildschirm 5 mit 80x50 ist mit <tt>[STRG]-[ALT]-[F6]</tt> erreichbar.

<p>
Denke daran, dass <tt>[STRG]-[ALT]-[F1]</tt> hier Bildschirm 0 ist. Wenn du 
die anderen Schirme auch ändern willst, wiederhole einfach die
Schritte "delete" und "add screen" für jeden Bildschirm, den du mit
80x50 betreiben willst.

<p>
Du solltest aber Bildschirm 4 (ttyC4, <tt>[STRG]-[ALT]-[F5]</tt>) 
unverändert lassen, da dieser von X als grafischer Schirm genutzt wird.
Außerdem ist es nicht möglich, die Auflösung des 
ersten Konsolen-Device zu ändern (also ttyC0).

<p>
Natürlich können all diese Befehle auch als root an
der Konsole eingegeben werden, oder besser mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>.

<p>
<b>Hinweis: Das funktioniert nicht mit allen Grafikkarten.</b> Dummerweise
unterstützen nicht alle Grafikkarten die von 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons</a>
benötigten Fonts für den 80x50 Text-Modus. In diesen Fällen
solltest du über den Einsatz von X nachdenken.


<a name="SerCon"></a>
<h2>7.7 - Wie kann ich eine serielle Konsole benutzen ?</h2>

Es gibt viele Gründe, warum du auf deinem OpenBSD System eine serielle
Konsole benutzen willst:
<ul>
<li>Aufnehmen der Ausgabe der Konsole (zur Dokumentation). 
<li>Remote Management.
<li>Einfachere Wartung einer großen Anzahl von Maschinen
<li>Ein sauberes dmesg von Maschinen bekommen, von denen das sonst nicht
    so einfach ist.
<li>Eine saubere "trace" und "ps" Ausgabe bieten, wenn dein System gecrasht
    ist, so dass die Entwickler eine Chance haben, das Problem zu beheben.
</ul>
OpenBSD unterstützt auf den meisten Plattformen eine serielle Konsole,
die Details weichen aber stark ab.

<p>
Bedenke, dass serielles Arbeiten/Interfacing KEINE einfache
Sache ist -- du wirst oft ungewöhnliche Kabel benötigen
und Ports sind oft nicht zwischen den Maschinen standardisiert und
manchmal noch nicht mal auf einer einzelnen Maschine konsistent. 
Ein komplettes Tutorial über serielles Arbeiten/Interfacing
geht zwar weit über die Möglichkeiten dieses Artikels hinaus, aber
wir geben dir trotzdem einen guten Rat: Nur weil der Stecker hineinpasst,
heisst das noch lange nicht, dass es auch funktioniert.

<a name="SerContty"></a>
<h3><i>/etc/ttys</i> Änderung</h3>
Es gibt zwei Punkte, um eine funktionierende serielle Konsole 
unter OpenBSD zu erhalten. Erstens musst du OpenBSD haben, um deinen
seriellen Port als Konsole für Status-Ausgaben und ,single user' Modus
benutzen zu können. Zweitens muss dein serieller Port eingeschaltet
sein, um als interaktives Terminal benutzbar zu sein, so dass ein Benutzer
sich einloggen kann, wenn die Maschine im ,multi user' Betrieb läuft. 
Dieser Teil ist zwischen den verschiedenen Plattformen relativ gleich 
und wird hier besprochen.
 
<p>
Terminal Sitzungen werden von der Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><i>/etc/ttys</i></a>
kontrolliert. Bevor OpenBSD dir auf der seriellen Konsole einen 
"<tt>login:</tt>" Prompt serviert, musst du das ganze in <i>/etc/ttys</i>
einschalten, normalerweise gibt es ja andere Verwendungen für die
serielle Schnittstelle. Bei Plattformen, die normalerweise eine 
angeschlossene Tastatur und Bildschirm haben, ist die serielle
Konsole standardmäßig abgeschaltet. Wir benutzen hier die 
i386-Plattform als Beispiel. In diesem Fall musst du die Zeile
editieren, die wie folgt aussieht:

<pre>
     tty00   "/usr/libexec/getty std.9600"   unknown off
</pre>
Ist zu ändern in:
<pre>
     tty00   "/usr/libexec/getty std.9600"   vt100   on secure
</pre>

<tt>tty00</tt> ist hier der serielle Port, den wir als Konsole nutzen wollen.
Das "<tt>on</tt>" aktiviert das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8"><i>getty</i></a>
für den seriellen Port, so dass ein "<tt>login:</tt>" Prompt präsentiert
wird, das "<tt>secure</tt>" erlaubt ein root (uid 0) Login auf dieser Konsole
(das kann man wollen, oder auch nicht) und das 
"<tt>9600</tt>" ist die Baud-Rate des Terminals.  Denke daran, dass du 
die serielle Konsole auch ohne diese Schritte für Installationen benutzen
kannst, da das System im ,singel user' Modus läuft, und <i>getty</i>
gar nicht erst für den Login benutzt wird.

<p>
Auf einigen Plattformen und einigen Konfigurationen ist es notwendig, das
System im ,single user' Modus zu booten, damit die Änderungen durchgeführt
werden können.

<h3>amd64 und i386</h3>
Um den Boot-Prozess dazu zu bewegen, den seriellen Port als
Konsole zu verwenden, erzeuge oder editiere deine 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386">/etc/boot.conf</a></i>
Datei, damit sie folgende Zeile enthält:
<pre>
     set tty com0
</pre>

damit du den ersten seriellen Port als Konsole verwendest.
Die Standard-Baud-Rate ist 9600bps, das kann mittels der stty Option in
<i>/etc/boot.conf</i> angepasst werden. Diese Datei wird auf deinem 
Boot-Laufwerk abgelegt, was auch deine Installations-Floppy sein kann,
oder das Kommando kann ebenso gut am <tt>boot></tt> Prompt vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">OpenBSD
,second stage' Bootloader</a> eingegeben werden, wenn es nur ein
einziges Mal (oder zum ersten Mal) genutzt werden soll.


<p>
<h4>amd64 und i386 Hinweise:</h4>
<ul>
<li>OpenBSD zählt die seriellen Ports beginnend mit <i>tty00</i>,
DOS/Windows mit <i>COM1</i>. Denke also daran, dass
<i>tty02</i> <i>COM3</i> ist und nicht <i>COM2</i>

<li>Einige Systeme können sogar ohne eingesteckte Grafikkarte
funktionieren, aber sicher nicht alle -- viele Systeme sehen das
als Fehler an. Manche Systeme verweigern sogar ohne eingesteckte Tastatur
den Dienst.

<li>Einige Systeme sind in der Lage alle BIOS Tastatur- und 
Bildschirm-Aktivitäten dank einer Konfigurationsoption auf einen
seriellen Port zu lenken, so dass die Maschine vollständig über
den seriellen Port verwaltet werden kann. 
Möglicherweise ist das bei dir anders -- wenn man dieses
Feature benutzt, verhindert manchmal das BIOS, dass der Bootloader
den seriellen Port sieht und somit kann der Kernel ihn auch nicht
benutzen.
Manches BIOS hat eine Option namens "Continue Console Redirection after POST"
(Power On Self Test), dies sollte auf "OFF" gestellt sein, so dass der
Bootloader und der Kernel ihre eigene Konsole benutzen können.
Dummerweise ist dieses Feature nicht universell.

<li>PC kompatible Computer sind nicht entworfen worden, um von einer seriellen
Konsole aus bedient zu werden, im Gegensatz zu einigen anderen Plattformen.
Sogar die Systeme, die eine serielle Konsole unterstützen, haben
dafür im Normalfall eine Option im BIOS - und sollte diese Information
verloren gehen, wird das System wieder nach normal angeschlossener Tastatur
und Monitor suchen. Du solltest immer einen Monitor und eine Tastatur
für deinen amd64 und i386 griffbereit haben, um im Notfall darauf
zurückgreifen zu können.

<li>Du wirst <i>/etc/ttys</i> wie 
<a href="#SerContty">oben</a> anpassen müssen.

<li>Nur der erste serielle Port (com0) wird als serielle Konsole 
auf amd64 und i386 unterstützt.

</ul>


<h3>SPARC und UltraSPARC</h3>
Diese Maschinen sind so entworfen worden, dass sie vollständig
über eine serielle Konsole gewartet werden können. 
Entferne einfach die Tastatur von der Maschine und das System
läuft über die serielle Konsole.

<h4>SPARC und UltraSPARC Hinweise</h4>
<ul>
<li>Die zwei seriellen Ports auf SPARC heißen <i>ttya</i>, 
<i>ttyb</i>, etc.

<li>Anders als auf anderen Plattformen ist es nicht notwendig, irgendwelche
Änderungen an <i>/etc/ttys</i> zu machen, um die serielle Konsole
benutzen zu können.

<li>Die SPARC/UltraSPARC Systeme interpretieren ein BREAK Signal auf dem 
Konsolen-Port als das selbe wie ein STOP-A Kommando, und bringt das System
zurück zum Forth Prompt, und hält jede Anwendung und das Betriebssystem
an diesem Punkt an. Das ist recht nützlich, wenn man es braucht, aber
unglücklicherweise senden einige serielle Terminals beim Power-Down und
einige RS-232 Switche etwas, was der Computer als Break-Signal interpretiert
und halten damit die Maschine an. Überprüfe das, bevor du damit
in einer Produktionsumgebung arbeitest.

<li>Wenn du Tastatur und Monitor angeschlossen hast, kannst du trotzdem die
serielle Konsole benutzen, indem du die folgenden Befehle am
<tt>ok</tt> Prompt eingibst:
 <pre>
     ok <b>setenv input-device ttya</b>
     ok <b>setenv output-device ttya</b>
     ok <b>reset</b>
 </pre>
Wenn Tastatur und Monitor (ttyC0) in <i>/etc/ttys</i>
(<a href="#SerContty">siehe oben</a>) aktiv sind, kannst du sie
zusätzlich benutzen.
</ul>

<h3>MacPPC</h3>
Die MacPPC Maschinen sind durch OpenFirmware für die
Benutzung mittels serieller Konsole vorbereitet. Benutze
die folgenden Befehle:
 <pre>
     ok <b>setenv output-device scca</b>
     ok <b>setenv input-device scca</b>
     ok <b>reset-all</b>
 </pre>
Setze deine serielle Konsole auf 57600bps, 8N1.

<h4>MacPPC Hinweise</h4>
<ul>
<li>Unglücklicherweise ist die serielle Konsole auf den meisten
MacPPCs nicht direkt verfügbar. Während die meisten dieser 
Maschinen zwar serielle Hardware haben, ist sie nicht von außen zugänglich.
Einige Firmen bieten jedoch Zusatz-Hardware für verschiedene 
Macintosh-Modelle, so dass dann der Port als serielle Konsole (oder
anderweitig) nutzbar ist. Verwende die Suchmaschine deines Vertrauens
und suche nach etwas wie "Macintosh internal serial port".

<li>Du wirst <tt>tty00</tt> in <i>/etc/ttys</i> auf
<tt>on</tt> ändern müssen und die Geschwindigkeit auf 57600 anstelle 
der standardmäßigen 9600 setzen müssen, wie <a href="#SerContty">oben</a> 
beschrieben, und zwar im ,single user' Modus, bevor du eine funktionierende 
serielle Konsole hast.</ul>


<h3>Mac68k</h3>
Die serielle Konsole wird im <i>Booter</i> Programm ausgewählt, 
unter dem "<tt>Options</tt>" Pull-Down Menü, dann 
"<tt>Serial Ports</tt>". Prüfe den "Serial Console" Knopf, 
dann wähle den Modem- oder Drucker-Port. Du wirst ein Macintosh Modem 
oder Drucker-Kabel an den seriellen Port des Macs anschließen müssen.
Wenn das in Zukunft deine Standardeinstellung sein soll, musst du dem
Booter-Programm sagen, dass es deine Optionen speichern soll.


<h4>Mac68k Hinweise</h4>
<ul>
<li>Der Modem Port ist <i>tty00</i>, der Drucker Port ist <i>tty01</i>.

<li>Der Mac68k schaltet seinen seriellen Port nicht ein, bis man ihn danach
fragt, also wird deine breakout Box keinerlei Signale anzeigen, bis der
OpenBSD Boot Prozess gestartet ist.

<li>Du wirst den Port in (<i>tty00</i> oder <i>tty01</i>) wie
<a href="#SerContty">oben</a> beschrieben einschalten müssen.</ul>

<a name="Blanker"></a>
<h2>7.8 - Wie schalte ich meinen Konsolen-Bildschirmschoner ein ? (wscons)</h2>
Wenn du möchtest, dass sich deine Konsole nach einer gewissen Zeit der 
Inaktivität von X abschaltet, kannst du die folgenden 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a>
Variablen ändern:

<ul>
<li><b><tt>display.vblank</tt></b> auf <tt>on</tt> gesetzt, schaltet
das vertical sync Signal ein, was einige Monitore dazu veranlasst,
in den "energy saver" Modus zu gehen.  Es wird hinterher mehr Zeit 
beanspruchen, den Monitor wieder in den Normalmodus zu bringen,
aber es reduziert den Energieverbrauch und die Hitzeentwicklung 
neuerer Monitore. Im Modus <tt>off</tt> wird zwar der Bildschirm 
schwarz, aber der Monitor empfängt weiter das horizontale und 
vertikale sync Signal und die Rückkehr zum Normalbetrieb 
geschieht augenblicklich.

<li><b><tt>display.screen_off</tt></b> gibt die Verzögerungszeit
in tausendstel Sekunden an, also wäre 60000 eine Verzögerung
von einer Minute.

<li><b><tt>display.kbdact</tt></b> gibt an, ob Aktivitäten auf
der Tastatur wieder zur Rückkehr in den Normalmodus führen.
Normalerweise will man das.

<li><b><tt>display.outact</tt></b> gibt an, ob Ausgaben auf dem Bildschirm
wieder zur Rückkehr in den Normalmodus führen.
</ul>

Du kannst diese Variablen auf der Kommandozeile mittels des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a> 
Befehls setzen:
<pre>
     # <b>wsconsctl -w display.screen_off=60000</b>
     display.screen_off -> 60000
</pre>

oder sie dauerhaft setzen, indem du sie in der Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl.conf&amp;sektion=5"><i>/etc/wsconsctl.conf</i></a>
einträgst, so dass sie beim nächsten Bootvorgang aktiviert werden:

<pre>
     display.vblank=on               # enable vertical sync blank
     display.screen_off=600000       # set screen blank timeout to 10 minutes
     display.kbdact=on               # Restore screen on keyboard input
     display.outact=off              # Restore screen on display output
</pre>

Der Bildschirmschoner wird entweder aktiv, wenn <tt>display.kbdact</tt> oder
<tt>display.outact</tt> auf "<tt>on</tt>" gesetzt sind.  

<a name="ALLCAPS"></a>
<h2>7.9 -  ALLES WAS ICH TIPPE IST IN GROSSBUCHSTABEN!</H2>
Tatsächlich ist das ein Feature, kein Fehler.

<p>
Nahezu alle Unix Befehle und Benutzernamen werden in Kleinbuchstaben
eingegeben. Trotzdem waren einige alte Terminals nur in der Lage,
Großbuchstaben zu benutzen, was es für sie unmöglich machte,
für Unix benutzt werden zu werden. 
Als Workaround hat 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8">getty(8)</a>,
wenn du deinen Usernamen komplett in Großbuchstaben eingegeben hast, angenommen,
dein Terminal sei "lowercase challenged", und hat einfach alles,
was du getippt hast, als Kleinbuchstaben interpretiert, es allerdings
alles in Großbuchstaben ausgegeben.
Wenn du ein gemischtes oder nur-Großbuchstaben-Passwort hast,
kannst du dich nicht einloggen.

<p>
Wenn du STRG-D am Login Prompt drückst, wird getty(8) beendet und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
wird einen neuen starten, der dann Groß- und Kleinbuchstaben sauber akzeptiert.


<p>
<font color= "#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq6.html">[Zum Kapitel 6 - Netzwerken]</a>
<a href="../faq8.html">[Zum Kapitel 8 - Allgemeine Fragen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a> 
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq7.html,v 1.65 ]
<br>
$Translation: faq7.html,v 1.45 2004/11/12 18:20:14 paldium Exp $
<br></small>
<small>$OpenBSD: faq7.html,v 1.42 2004/11/12 19:21:37 jufi Exp $</small>
</body>
</html>
