<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>7 - Tastatur- und Bildschirm-Kontrollen</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
</head>

<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->


<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq6.html">[Zum Kapitel 6 - Vernetzung]</a>
<a href= "faq8.html">[Zum Kapitel 8 - Allgemeine Fragen]</a>
</font>

<h1><font color="#e00000">7 - Tastatur- und Bildschirmkontrollen</font></h1>
<hr>
<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#Keyboard"     >7.1 -
    Wie kann ich die Tastatur neu belegen? (wscons)</a>
<li><a href="#ConsoleMouse" >7.2 -
    Wird die Maus auch unter der Konsole unterstützt?</a>
<li><a href="#Scrollback"   >7.3 -
    Auf den Scrollbackpuffer zugreifen (amd64, i386 und einige Alphas)</a>
<li><a href="#SwitchConsole">7.4 -
    Wie wechsle ich zwischen den Konsolen?
    (amd64, i386, Zaurus und einige Alphas)</a>
<li><a href="#80x50"        >7.5 -
    Wie kann ich eine Konsolenauflösung von 80 x 50 bekommen?
    (amd64, i386, paar Alphas)</a>
<li><a href="#SerCon"       >7.6 -
    Wie kann ich eine serielle Konsole benutzen?</a>
<li><a href="#Blanker"      >7.7 -
    Wie schalte ich meine Konsole aus (Bildschirmschoner, wscons)</a>
<li><a href="#ALLCAPS"      >7.8 -
    ALLES, WAS ICH AM LOGINPROMPT SCHREIBE, IST IN GROSSBUCHSTABEN!</a>
<li><a href="#tmux"         >7.9 - Was ist tmux(1)?</a>
</ul>
<hr>

<br>
<p>
<a name= "Keyboard"></a>
<h2>7.1 - Wie kann ich die Tastatur neu belegen? <i>(wscons)</i></h2>

<p>
Die meisten OpenBSD-Plattformen nutzen den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4"
>wscons(4)</a>-Konsolentreiber.

<p>
Bei wscons(4)-Konsolen werden die meisten Optionen mit dem Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>
kontrolliert. Beispielsweise würde man die Tastaturbelegung
mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>
wie folgt ändern:

<blockquote><pre>
# <strong>wsconsctl keyboard.encoding=de</strong>
</pre></blockquote>

<p>
Im nächsten Beispiel werden wir die [CAPS LOCK]-Taste neu
belegen; und zwar so, dass sie nun [STRG L] (die linke Steuerungstaste) ist:

<blockquote><pre>
# <strong>wsconsctl -w keyboard.map+="keysym Caps_Lock = Control_L"</strong>
</pre></blockquote>

<a name= "ConsoleMouse"></a>
<h2>7.2 - Wird die Maus auch unter der Konsole unterstützt?</h2>

<p>
Für die <a href="../../de/alpha.html">alpha</a>-,
<a href="../../de/amd64.html">amd64</a>-
und <a href="../../de/i386.html">i386</a>-Plattformen
bietet OpenBSD den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsmoused&amp;sektion=8&amp;arch=i386">wsmoused(8)</a>
an - einen Port des moused(8) von FreeBSD. Er kann bei jedem Booten
automatisch aktiviert werden, indem du die passende Zeile in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"
>rc.conf.local(8)</a> editierst.

<p>
<a name= "Scrollback"></a>
<h2>7.3 - Auf den Scrollbackpuffer zugreifen <i>(amd64, i386 und einige
Alphas)</i></h2>

<p>
OpenBSD bietet auf einigen wenigen Plattformen einen sogenannten
Konsolenscrollbackpuffer. Damit ist es möglich, Informationen zu sehen,
die bereits wieder oben aus dem Bildschirm gescrollt sind. Um sich auf-
und abwärts zu bewegen, benutze einfach die Tastenkombinationen
<tt>[SHIFT]+[BILD AUF]</tt> und <tt>[SHIFT]+[BILD AB]</tt>
<p>
Der Standardscrollbackpuffer und somit auch die Anzahl der Seiten, die
du so betrachten kannst, beträgt 8. Das ist eine Funktionalität des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>-Treibers
- daher funktioniert das alles natürlich nicht ohne VGA-Karte auf
jeglichen Plattformen (viele Alpha-Systeme haben TGA-Video).

<p>
Wegen der Speicherbegrenzung unterstützen die Installationskernel
keine Scrollbackfunktion. Ein <a
href="#SwitchConsole">Konsolenwechsel</a> wird den Scrollbackpuffer
löschen.

<p>
<a name= "SwitchConsole"></a>
<h2>7.4 - Wie wechsle ich zwischen den Konsolen?<i>(amd64, i386, Zaurus
und einige Alphas)</i></h2>

Auf amd64, i386 und einigen Alphas mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>-Karte
bietet OpenBSD sechs virtuelle Terminal an: /dev/ttyC0 bis /dev/ttyC5.
Das Terminal ttyC4 ist für die Benutzung des X-Window-Systems
reserviert, was noch fünf Textkonsolen übrig lässt. Du kannst zwischen
ihnen hin- und herspringen, indem du die Tastaturkombinationen
<tt>[STRG]+[ALT]+[F1]</tt>, <tt>[STRG]+[ALT]+[F2]</tt>,
<tt>[STRG]+[ALT]+[F3]</tt>, <tt>[STRG]+[ALT]+[F4]</tt> und
<tt>[STRG]+[ALT]+[F6]</tt> benutzt.

<p>
Die X-Umgebung benutzt ttyC4: <tt>[STRG]+[ALT]+[F5]</tt>.
Wenn du X benutzt, bringen dich die
<tt>[STRG]+[ALT]+[F</tt><i>n</i><tt>]</tt>-Tasten auf
die Textkonsolen und <tt>[STRG]+[ALT]+[F5]</tt> bringt dich wieder auf
die grafische Oberfläche.

<p>
Wenn du mehr als die standardmäßige Anzahl der Textkonsolen haben
willst, kannst du den Befehl
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg(8)</a>
benutzen, um Bildschirme für ttyC6, ttyC7 und weitere zu erzeugen.
Zum Beispiel:

<blockquote>
<pre>
wsconscfg -t 80x25 6
</pre>
</blockquote>

Dieser Eintrag erzeugt ein virtuelles Terminal für ttyC6, welches man
mit <tt>[STRG]+[ALT]+[F7]</tt> erreicht. Vergiss nicht, diesen Befehl
deiner
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local(8)</tt></a>-Datei
hinzuzufügen, wenn der zusätzliche Bildschirm auch nach dem nächsten
Neustart noch vorhanden sein soll.

<p>
Denk daran, dass du keinen <tt>login:</tt>-Prompt
auf der neu erzeugten virtuellen Konsole erhältst, bis du sie in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><tt>/etc/ttys(5)</tt></a>
auf on setzt und entweder mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
neustartest oder ein HUP-Signal mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">kill(1)</a>
sendest.

<p>
Auf dem Zaurus stehen standardmäßig zwei virtuelle Terminals (/dev/ttyC0
und /dev/ttyC1) zur Verfügung, die mit den Tastenkombinationen
<tt>[ALT]+[CALENDAR]</tt> und <tt>[ALT]+[ADDRESS]</tt> erreicht werden
können (Die <tt>[ALT]</tt>-Taste befindet sich rechts neben der linken
<tt>[CTRL]</tt>-Taste).

<a name="80x50"></a>
<h2>7.5 - Wie kann ich eine Konsolenauflösung von 80 x 50 bekommen?
<i>(amd64, i386, paar Alphas)</i></h2>

Anwender der Architekturen amd64, i386 oder VGA-Alpha haben
normalerweise eine Konsole mit 25 Zeilen und je 80 Buchstaben. Viele
VGA-Grafikkarten sind aber in der Lage, eine höhere Textauflösung von
50 Zeilen mit 80 Buchstaben darzustellen.

<p>
Zunächst einmal kann man einen Font, der die gewünschte Auflösung
unterstützt, mittels des Befehls
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsfontload&amp;sektion=8">wsfontload</a>
laden. Der standardmäßige Textbildschirm mit der Auflösung 80x25 benutzt
8x16-Pixelfonts; um die vertikale Auflösung zu verdoppeln, müssen wir
8x8-Pixelfonts benutzen.

<p>
Danach müssen wir die
<a href="#SwitchConsole">virtuelle Konsole</a> löschen und in der
gewünschten Auflösung neu erzeugen. Das machen wir mit dem Befehl
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg</a>.

<p>
Das kann während des Bootens automatisch am Ende deiner
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local</tt></a>-Datei
geschehen:
<blockquote>
<pre>
wsfontload -h 8 -e ibm /usr/share/misc/pcvtfonts/vt220l.808
wsconscfg -dF 5
wsconscfg -t 80x50 5
</pre>
</blockquote>

Wie bei jeder Änderung deiner Systemkonfiguration solltest du
etwas Zeit mit den passenden Handbuchseiten verbringen, um zu verstehen,
was diese Befehle eigentlich tun.

<p>
Die erste Zeile dort oben lädt den 8x8-Schriftsatz. Die zweite Zeile
löscht den virtuellen Bildschirm Nummer 5 (den man mit
<tt>[STRG]-[ALT]-[F6]</tt> erreichen würde). Die dritte Zeile erzeugt
einen neuen Bildschirm 5 mit der Auflösung 50 Zeilen mit je 80
Buchstaben. Wenn du alles so gemacht hast, werden deine anderen
virtuellen Bildschirme ganz normal im 80x25-Modus erscheinen; der
neue Bildschirm 5 mit 80x50 ist mit <tt>[STRG]-[ALT]-[F6]</tt>
erreichbar.

<p>
Denke daran, dass <tt>[STRG]-[ALT]-[F1]</tt> hier Bildschirm 0 ist. Wenn
du die anderen Schirme auch ändern willst, wiederhole einfach die
Schritte delete und add screen für jeden Bildschirm, den du mit
80x50 betreiben willst.

<p>
Du solltest aber Bildschirm 4 (ttyC4, <tt>[STRG]-[ALT]-[F5]</tt>)
unverändert lassen, da dieser von X als grafischer Schirm genutzt wird.
Außerdem ist es nicht möglich, die Auflösung des ersten
Konsolendevices zu ändern (also ttyC0).

<p>
Selbstverständlich können all diese Befehle auch als root an der Konsole
eingegeben werden - oder besser mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>.

<p>
<b>Hinweis: Das funktioniert nicht mit allen Grafikkarten.</b>
Dummerweise unterstützen nicht alle Grafikkarten die von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons</a>
benötigten Schriftsätze für den 80x50-Textmodus. In diesen Fällen
solltest du über den Einsatz von X nachdenken.


<a name="SerCon"></a>
<h2>7.6 - Wie kann ich eine serielle Konsole benutzen?</h2>

Es gibt viele Gründe, warum du auf deinem OpenBSD-System eine serielle
Konsole benutzen willst:
<ul>
<li>Aufnehmen der Ausgabe der Konsole (zur Dokumentation).
<li>Remotemanagement.
<li>Einfachere Wartung einer großen Anzahl Maschinen.
<li>Ein sauberes dmesg der Maschinen bekommen, von denen das sonst nicht
    so einfach ist.
<li>Eine saubere Ausgabe von trace und ps bieten, wenn dein System
    abgestürzt ist, sodass die Entwickler eine Chance haben, das
    Problem zu beheben.
</ul>
OpenBSD unterstützt auf den meisten Plattformen eine serielle Konsole -
die Details weichen aber stark ab.

<p>
Bedenke, dass serielles Arbeiten/Interfacing KEINE einfache
Sache ist - du wirst oft ungewöhnliche Kabel benötigen
und Schnittstellen sind oft nicht zwischen den Maschinen standardisiert
und manchmal noch nicht mal auf einer einzelnen Maschine konsistent.
Ein komplettes Tutorial über serielles Arbeiten/Interfacing
geht zwar weit über die Möglichkeiten dieses Artikels hinaus, aber
wir geben dir trotzdem einen guten Rat: Nur weil der Stecker
hineinpasst, heißt das noch lange nicht, dass es auch funktioniert.

<a name="SerContty"></a>
<h3><i>/etc/ttys</i>-Änderung</h3>
Es gibt zwei Punkte, um eine funktionierende serielle Konsole
unter OpenBSD zu erhalten. Erstens musst du OpenBSD haben, um deinen
seriellen Port als Konsole für Statusausgaben und Singleuser-Modus
benutzen zu können. Zweitens muss deine serielle Schnittstelle
eingeschaltet sein, um als interaktives Terminal benutzbar zu sein, so
dass ein Benutzer sich einloggen kann, wenn die Maschine im
Multiuser-Betrieb läuft. Dieser Teil ist zwischen den verschiedenen
Plattformen relativ gleich und wird hier besprochen.

<p>
Terminalsitzungen werden von der Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><i>/etc/ttys</i></a>
kontrolliert. Bevor OpenBSD dir auf der seriellen Konsole einen
<tt>login:</tt>-Prompt serviert, musst du das ganze in <i>/etc/ttys</i>
einschalten - normalerweise gibt es ja andere Verwendungen für die
serielle Schnittstelle. Bei Plattformen, die normalerweise eine
angeschlossene Tastatur und einen angeschlossenen Bildschirm haben, ist
die serielle Konsole standardmäßig ausgeschaltet. Wir benutzen hier die
i386-Plattform als Beispiel. In diesem Fall musst du die Zeile
editieren, die wie folgt aussieht:

<pre>
     tty00   "/usr/libexec/getty std.9600"   unknown off
</pre>
Ist so zu ändern in, dass sie so ähnlich wie folgt aussieht:
<pre>
     tty00   "/usr/libexec/getty std.9600"   vt220   on secure
</pre>

Die serielle Schnittstelle ist in diesem Fall die Gerätedatei
<tt>tty00</tt>, die wir als Konsole nutzen wollen. <tt>vt220</tt>
ist dabei der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=termcap&amp;sektion=5">termcap(5)</a>-Eintrag,
der DEIN Terminal beschreibt (weitere häufig genutzte Optionen
sind <tt>vt100</tt>, <tt>xterm</tt> etc.). Das <tt>on</tt>
aktiviert das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8"><i>getty</i></a>
für die serielle Schnittstelle, sodass ein <tt>login:</tt>-Prompt
präsentiert wird, die Option <tt>secure</tt> erlaubt ein root- (UID 0)
Login auf dieser Konsole (das kann man wollen - oder auch nicht) und
<tt>9600</tt> ist die Baudrate des Terminals. Du solltest dabei die
Baudrate aber nicht auf den maximalen Wert stellen, der von deiner
Hardware unterstützt wird, da eine solche Einstellung weitaus mehr
Probleme als Nutzen verursachen wird. Die meisten System haben eine
Standardgeschwindigkeit (liegt bei Boot-ROMs und/oder dem Bootloader
meist bei 9600). Verwende diesen Wert, wenn du keinen guten Grund hast,
einen anderen nutzen zu müssen.

<p>
Denke daran, dass du die serielle Konsole auch ohne diese Schritte für
Installationen benutzen kannst, da das System im Singleuser-Modus läuft
und <i>getty</i> gar nicht erst für den Login benutzt wird.

<p>
Auf einigen Plattformen und einigen Konfigurationen ist es notwendig,
das System im Singleuser-Modus zu booten, damit die Änderungen
durchgeführt werden können.

<h3>amd64 und i386</h3>
Um den Bootprozess dazu zu bewegen, die serielle Schnittstelle als
Konsole zu verwenden, erzeuge oder editiere deine
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386">/etc/boot.conf</a></i>-Datei,
damit sie folgende Zeile enthält:
<pre>
     set tty com0
</pre>

Damit kannst du die erste serielle Schnittstelle als Konsole verwendest.
Die Standardbaudrate ist 9600 bps, das kann mittels der stty-Option in
<i>/etc/boot.conf</i> angepasst werden. Diese Datei wird auf deinem
Bootlaufwerk abgelegt (kann auch deine Installationsdiskette sein);
das Kommando kann aber ebenso gut am <tt>boot></tt>-Prompt vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">OpenBSD-Secondstage-Bootloader</a>
eingegeben werden, wenn es nur ein einziges Mal (oder zum ersten Mal)
genutzt werden soll.


<p>
<h4>Hinweise für amd64 und i386:</h4>
<ul>
<li>OpenBSD zählt die seriellen Schnittstellen beginnend mit
<i>tty00</i>, DOS/Windows mit <i>COM1</i>. Denke also daran, dass
<i>tty02</i> <i>COM3</i> ist und nicht <i>COM2</i>.

<li>Einige Systeme können sogar ohne eingesteckte Grafikkarte
funktionieren, aber sicher nicht alle - viele Systeme sehen das
als Fehler an. Manche Systeme verweigern sogar ohne eingesteckte
Tastatur den Dienst.

<li>Einige Systeme sind in der Lage, alle BIOS-Tastatur- und
Bildschirmaktivitäten dank einer Konfigurationsoption auf eine serielle
Schnittstelle zu lenken, sodass die Maschine vollständig über die
serielle Schnittstelle verwaltet werden kann. Möglicherweise ist das
bei dir anders - wenn man diese Funktionalität benutzt, verhindert
manchmal das BIOS, dass der Bootloader die serielle Schnittstelle sieht
und somit kann der Kernel ihn auch nicht benutzen.
Manches BIOS hat eine Option namens »Continue Console Redirection after
POST« (POST: Power On Self Test), dies sollte auf OFF gestellt sein, so
dass der Bootloader und der Kernel ihre eigene Konsole benutzen können.
Dummerweise ist diese Funktionalität nicht universell.

<li>PC-kompatible Computer sind nicht entworfen worden, um von einer
seriellen Konsole aus bedient zu werden - im Gegensatz zu einigen
anderen Plattformen. Sogar die Systeme, die eine serielle Konsole
unterstützen, haben dafür im Normalfall eine Option im BIOS - und sollte
diese Information verloren gehen, wird das System wieder nach normal
angeschlossener Tastatur und Monitor suchen. Du solltest immer einen
Monitor und eine Tastatur für deinen amd64 oder i386 griffbereit haben,
um im Notfall darauf zurückgreifen zu können.

<li>Du wirst <i>/etc/ttys</i> wie
<a href="#SerContty">oben</a> anpassen müssen.

</ul>


<h3>SPARC und UltraSPARC</h3>
Diese Maschinen sind so entworfen worden, dass sie vollständig
über eine serielle Konsole gewartet werden können.
Entferne einfach die Tastatur von der Maschine und das System
läuft über die serielle Konsole.

<h4>SPARC- und UltraSPARC-Hinweise</h4>
<ul>
<li>Die zwei seriellen Schnittstellen der SPARC heißen <i>ttya</i>,
<i>ttyb</i> etc.

<li>Anders als auf anderen Plattformen ist es nicht notwendig,
irgendwelche Änderungen an <i>/etc/ttys</i> zu machen, um die serielle
Konsole benutzen zu können.

<li>Die SPARC/UltraSPARC-Systeme interpretieren ein BREAK-Signal auf
dem Konsolenport als das selbe wie ein STOP-A-Kommando, bringt das
System zurück zum Forthprompt und hält jede Anwendung und das
Betriebssystem an diesem Punkt an. Das ist recht nützlich, wenn man es
braucht, aber unglücklicherweise senden einige serielle Terminals beim
Powerdown und einige RS-232-Switche etwas, was der Computer als
BREAK-Signal interpretiert und halten damit die Maschine an. Überprüfe
das, bevor du damit in einer Produktionsumgebung arbeitest.

<li>Wenn du Tastatur und Monitor angeschlossen hast, kannst du trotzdem
die serielle Konsole benutzen, indem du die folgenden Befehle am
<tt>ok</tt>-Prompt eingibst:
 <pre>
     ok <b>setenv input-device ttya</b>
     ok <b>setenv output-device ttya</b>
     ok <b>reset</b>
 </pre>
Wenn Tastatur und Monitor (ttyC0) in <i>/etc/ttys</i>
(<a href="#SerContty">siehe oben</a>) aktiv sind, kannst du sie
zusätzlich benutzen.
</ul>

<h3>MacPPC</h3>
Die MacPPC-Maschinen sind durch OpenFirmware für die
Benutzung mittels serieller Konsole vorbereitet. Benutze
die folgenden Befehle:
 <pre>
     ok <b>setenv output-device scca</b>
     ok <b>setenv input-device scca</b>
     ok <b>reset-all</b>
 </pre>
Setze deine serielle Konsole auf 57600 bps, 8N1.

<h4>MacPPC-Hinweise</h4>
<ul>
<li>Unglücklicherweise ist die serielle Konsole auf den meisten MacPPCs
nicht direkt verfügbar. Während die meisten dieser Maschinen zwar
serielle Hardware haben, ist sie nicht von außen zugänglich. Einige
Firmen bieten jedoch Zusatzhardware für verschiedene Macintosh-Modelle,
sodass dann der Port als serielle Konsole (oder anderweitig) nutzbar
ist. Verwende die Suchmaschine deines Vertrauens und suche nach etwas
wie »Macintosh internal serial port«.

<li>Du wirst <tt>tty00</tt> in <i>/etc/ttys</i> auf <tt>on</tt> ändern
müssen und die Geschwindigkeit auf 57600 anstelle der standardmäßigen
9600 setzen müssen, wie <a href="#SerContty">oben</a> beschrieben - und
zwar im Singleuser-Modus, bevor du eine funktionierende serielle Konsole
hast.</ul>


<h3>Mac68k</h3>
Die serielle Konsole wird im <i>Booter</i>-Programm ausgewählt
(im "<tt>Options</tt>"-Pulldownmenü, dann "<tt>Serial Ports</tt>". Prüfe
den "Serial Console"-Knopf, dann wähle die Modem- oder
Druckerschnittstelle). Du wirst ein Macintosh-Modem oder -Druckerkabel
an die serielle Schnittstelle des Macs anschließen müssen. Wenn das in
Zukunft deine Standardeinstellung sein soll, musst du dem
Booterprogramm sagen, dass es deine Optionen speichern soll.


<h4>Mac68k-Hinweise</h4>
<ul>
<li>Die Modemschnittstelle ist <i>tty00</i>, die Druckerschnittstelle
ist <i>tty01</i>.

<li>Der Mac68k schaltet seine serielle Schnittstelle nicht ein, bis man
ihn danach fragt; also wird dein hochfahrender Rechner keinerlei Signale
anzeigen, bis der OpenBSD-Bootprozess gestartet ist.

<li>Du wirst die Schnittstelle (<i>tty00</i> oder <i>tty01</i>) wie
<a href="#SerContty">oben</a> beschrieben einschalten müssen.</ul>

<a name="Blanker"></a>
<h2>7.7 - Wie schalte ich meine Konsole aus
(Bildschirmschoner, wscons)?</h2>
Wenn du - auch ohne Benutzung von X - möchtest, dass sich deine Konsole nach
einer gewissen Zeitspanne der Inaktivität ausschaltet, so kannst du die
folgenden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4"
>wscons(4)</a>-Variablen ändern:

<ul>
<li><b><tt>display.vblank</tt></b> auf <tt>on</tt> gesetzt, deaktiviert das
vertikale Synchronisationssignal, was viele Monitore dazu veranlasst,
in den Energiesparmodus zu gehen. Es wird hinterher mehr Zeit
beanspruchen, den Monitor wieder in den Normalmodus zu bringen,
reduziert aber den Energieverbrauch und die Hitzeentwicklung
neuerer Monitore. Im Modus <tt>off</tt> wird zwar der Bildschirm
schwarz, aber der Monitor empfängt weiter das horizontale und
vertikale Syncsignal und die Rückkehr zum Normalbetrieb
geschieht augenblicklich.

<li><b><tt>display.screen_off</tt></b> gibt die Verzögerungszeit
in tausendstel Sekunden an: 60000 wäre also eine Verzögerung
von einer Minute.

<li><b><tt>display.kbdact</tt></b> gibt an, ob Aktivitäten auf
der Tastatur wieder zur Rückkehr in den Normalmodus führen.
Normalerweise will man das.

<li><b><tt>display.outact</tt></b> gibt an, ob Ausgaben auf dem
Bildschirm wieder zur Rückkehr in den Normalmodus führen.
</ul>

Du kannst diese Variablen auf der Kommandozeile mittels des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>-Befehls
setzen:
<pre>
     # <b>wsconsctl display.screen_off=60000</b>
     display.screen_off -> 60000
</pre>

oder sie dauerhaft setzen, indem du sie in der Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl.conf&amp;sektion=5"><i>/etc/wsconsctl.conf</i></a>
einträgst, sodass sie beim nächsten Bootvorgang aktiviert werden:

<pre>
     display.vblank=on               # enable vertical sync blank
     display.screen_off=600000       # set screen blank timeout to 10 minutes
     display.kbdact=on               # Restore screen on keyboard input
     display.outact=off              # Restore screen on display output
</pre>

Der Bildschirmschoner wird entweder aktiv, wenn <tt>display.kbdact</tt>
oder <tt>display.outact</tt> auf <tt>on</tt> gesetzt sind.

<a name="ALLCAPS"></a>
<h2>7.8 -  ALLES, WAS ICH AM LOGINPROMPT SCHREIBE, IST IN
GROSSBUCHSTABEN!</H2>
Tatsächlich ist das eine Funktionalität, kein Fehler.

<p>
Nahezu alle Unix-Befehle und -Benutzernamen werden in Kleinbuchstaben
eingegeben. Trotzdem waren einige alte Terminals nur in der Lage
Großbuchstaben zu benutzen, was es für sie unmöglich machte, für Unix
benutzt zu werden. Als Umgehung des Problems hat
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8">getty(8)</a>,
wenn du deinen Benutzernamen komplett in Großbuchstaben eingegeben hast,
angenommen dass dein Terminal »lowercase challenged« sei und hat einfach
alles, was du getippt hast, als Kleinbuchstaben interpretiert, es
allerdings alles in Großbuchstaben ausgegeben. Wenn du ein gemischtes
oder Nur-Großbuchstaben-Passwort hast, kannst du dich nicht einloggen.

<p>
Wenn du [STRG]-D am Loginprompt drückst, wird getty(8) beendet und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
wird einen neuen starten, der dann Groß- und Kleinbuchstaben sauber
akzeptiert.


<a name="tmux"></a>
<h2>7.9 - Was ist tmux?</h2>

Für diejenigen, die mit dem Programm »screen«, das als »Package« angeboten
wird, vertraut sind, oder mit window(1), das sich im Basissystem befindet,
mag jene Antwort am einfachsten sein, die besagt, dass
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>tmux(1)</a>
viele Funktionen von screen und window, und darüber hinaus viele weitere
besitzt.

<p>
Für jene, die mit den genannten Programmen nicht vertraut sind,
ist tmux ein <i>Terminal-Multiplexer</i>.
Dies ist ein Programm, dass es einer Anzahl von Programmen erlaubt, denselben
Bildschirm für Eingabe und Ausgabe zu benutzen.
In tmux wird eine solche Kollektion von Programmen »<i>session</i>« (Sitzung)
genannt, wobei jedes Programm in einem tmux »<i>window</i>« (Fenster) läuft.

<p>
Zusätzlich zum Teilen des Terminals erlaubt es tmux, eine Sitzung und ihre
Fenster von der Bildschirmausgabe zu trennen, sie damit einfach im Hintergrund
weiterlaufen zu lassen, und sie später wieder an dieselbe, oder aber eine
andere Konsole »anzuhängen«.
Eine Sitzung kann manuell oder durch ein unerwartetes Ereignis, wie zum
Beispiel einer Unterbrechung des Netzwerks, getrennt werden, in jedem Falle
aber bestehen die Programme fort und laufen weiter wie normal.

<p>
tmux besitzt ebenfalls viele andere Eigenschaften wie zum Beispiel die
Aufteilung des Fensters in verschiedene Sektionen (»<i>panes</i>« genannt;
auf Deutsch: Feld), einer Historie der Bildschirmausgabe jedes Fensters,
konfigurierbaren Tastenkombinationen und der Sperrung des Terminals.
Weitere Informationen offenbart ein Blick in die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>tmux(1)</a>-Handbuchseite.

<h3>Wie benutze ich tmux?</h3>

<p>
Der erste Schritt ist, tmux zu starten:

<blockquote><pre>
$ tmux
</pre></blockquote>

<p>
Dies startet eine neue tmux-Instanz mit einer einzigen neuen Sitzung (»0«
genannt), und erzeugt einen Klienten, der auf dem Bildschirm dargestellt wird.
Der größte Teil des Bildschirms wird ein Fenster mit einem Shell-Prompt zeigen,
und es ist zu sehen, dass die letzte Zeile durch eine Statuszeile eingenommen
wird.
Letztere zeigt linkerhand den Namen der Sitzung in eckigen Klammern, den
Fenstertitel (für Shells normalerweise leer) und die Uhrzeit auf der rechten
Seite, und in der Mitte eine Übersicht der aktuell geöffneten Fenster.
In dieser neuen Sitzung wird die Liste der aktuell geöffneten Fenster nur einen
Eintrag aufweisen, zum Beispiel:

<blockquote><pre>
0:ksh*
</pre></blockquote>

<p>
Ein kurzer Einschub hinsichtlich Terminals: unter OpenBSD werden Anwendungen
auf die Möglichkeiten des Terminals mit Hilfe der Umgebungsvariable TERM
aufmerksam gemacht.
Diese ist auf den Namen eines Eintrags der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=terminfo&amp;sektion=5"
>terminfo(5)</a>-Datenbank gesetzt und erzählt dem Programm das das Terminal,
zum Beispiel, Farbe unterstützt, oder die Möglichkeit des Einschubs von Zeilen
besitzt, oder viele andere Dinge.
Ein wichtige Anmerkung ist, dass der »xterm«-Eintrag der Datenbank keinerlei
Farbunterstützung hat, sodass tmux in xterm standardmäßig keine Farbe benutzt.
TERM sollte auf »xterm-xfree86« gesetzt werden, wenn Farbunterstützung
gewünscht wird (die »XTerm*termName« X-Ressource kann als Eintrag in der
Datei .Xdfaults dazu benutzt werden, dies für alle xterms zu setzen).
Es ist außerdem wesentlich, dass TERM in den Shells, die innerhalb von tmux
gestartet werden, auf »screen« gesetzt ist, da sonst von diesen gestartete
Programme eventuell keine korrekte Bildschirmausgabe produzieren -
tmux setzt diesen Wert selbst, aber es sollte darauf geachtet werden, dass er
in den Shell-Startdateien nicht überschrieben wird.

<p>
Um zu der Statuszeile zurückzukommen - die Nummer »0« ist die Indexzahl des
Fensters, »ksh« sein Name und das »*« indiziert, dass dies das aktuell
dargestellte Fenster oberhalb der Statuszeile ist.
Jedwede Eingabe wird zu der Shell durchgereicht, und jedwede Ausgabe
dargestellt.
Zum Beispiel, startet man
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=top&amp;sektion=1"
>top</a>«:

<blockquote><pre>
$ top
</pre></blockquote>

<p>
Es wird laufen wie normal, und den Bereich des Bildschirms oberhalb der
Statuszeile okkupieren.
Dir wird auch auffallen, dass sich der in der Statuszeile dargestellte
Fenstername von »ksh« zu »top« geändert hat - tmux benennt Fenster so um, dass
ihr Name den des gerade laufenden Programms reflektiert.

<p>
Stellen wir uns vor, dass du tmux vom Bildschirm loslösen, und zu der
ursprünglichen Shell zurückkehren willst, von der es gestartet wurde.
Eine tmux-Sitzung kann durch das gemeinsame Drücken der Tasten <i>Ctrl</i>
(Steuerungstaste) und <i>b</i>, gefolgt von der <i>d</i>-Taste vom Bildschirm
losgelöst werden.
Die <i>Ctrl-b</i> Tastenkombination (in tmux und seiner Handbuchseite zu einem
einfachen »C-b« verkürzt) ist unter dem Namen »<i>prefix key</i>«
(Präfixtaste) bekannt und wird benutzt, um tmux zu zeigen, das die nächste
Taste, die gedrückt wird, als Instruktion interpretiert werden soll, anstatt
sie zu dem im Fenster laufenden Programm durchzureichen.

<p>
Nach dem Drücken von <i>Ctrl-b d</i> und der Rückkehr an den Shell-Prompt kann
die tmux-Sitzung mit Hilfe des »attach«-Kommandos wieder verbunden werden:

<blockquote><pre>
$ tmux attach
</pre></blockquote>

<p>
Die tmux-Sitzung wird wieder erscheinen, und die Statuszeile und »top« werden
immer noch vergnügt laufen.
(Startest du stattdessen tmux ohne Argumente, so wird eine zweite Sitzung
erzeugt, die den Namen »1« tragen wird.)

<p>
Als Nächstes lass uns ein zweites Fenster erzeugen.
Dies wird mit Hilfe der »c«-Taste gemacht: drücke die Präfixtaste
<i>Ctrl-b</i>, gefolgt von der »c«-Taste.
Ein neues Fenster wird erzeugt und wieder wird ein Shell-Prompt auf dem
Bildschirm dargestellt.
Die Statuszeile wird dahingehend aufgefrischt, um das neue Fenster zu zeigen:

<blockquote><pre>
0:top- 1:ksh*
</pre></blockquote>

<p>
Der »-« nach dem »top« zeigt »das vorherige aktuelle Fenster« (das letzte
Fenster) an.
Ein erneutes <i>Ctrl-b c</i> erzeugt eine andere neue Shell:

<blockquote><pre>
0:top  1:ksh- 2:ksh*
</pre></blockquote>

<p>
Es gibt verschiedene Kommandos um zwischen Fenstern hin- und herzuschalten.
Von Fenster 2 aus kann man zum vorherigen Fenster, Nummer 1, wechseln, indem
man <i>Ctrl-b p</i> (»previous«, vorheriges) eingibt.
<i>Ctrl-b n</i> (»next«, nächstes) schaltet zum nächsten Fenster;  In diesem
Falle gibt es kein Fenster 3, sodass die Zählung von vorne beginnt und somit
Fenster 0 das aktuelle Fenster wird.
Man kann auch <i>Ctrl-b w</i> (»windows«, Fenster) drücken um ein interaktives
Menü der offenen Fenster zu erhalten, <i>Ctrl-b l</i> (»last«, letztes) um zum
letzten (das mit »-« markierte) Fenster, oder <i>Ctrl-b 0</i> um Fenster
0 direkt anzuspringen, <i>Ctrl-b 1</i> für Fenster 1 und so weiter bis
einschließlich <i>Ctrl-b 9</i> für Fenster 9.
Also, um zurück zu »top« in Fenster 0 zu gelangen, kann man es entweder mit
<i>Ctrl-b 0</i> direkt anspringen, oder mit zweimal <i>Ctrl-b p</i> in zwei
Schritten über Fenster 1 hinweg erreichen, oder von Fenster 2 aus durch
<i>Ctrl-b n</i> eine neue Zählung erzwingen und dadurch bei 0 landen,
oder aber man drückt <i>Ctrl-b w</i> und wählt Fenster 0 aus der Liste aus.

<p>
Manchmal möchte man auch ein Fenster erzeugen in dem ein Programm direkt läuft,
ohne das zuerst eine Shell gestartet wird.
Dies kann vom tmux <i>Kommandoprompt</i> aus erreicht werden.
Das Drücken der Tastenkombination <i>Ctrl-b :</i> verwandelt die Statuszeile in
einen »:«-Prompt, an dem Kommandos eingegeben werden können.
Alle von tmux unterstützten Kommandos werden auf der Handbuchseite
dokumentiert.
In diesem Fall wird das Kommando »new-window« benötigt.
Jedes Kommando besitzt ein Kürzel, das an seiner statt benutzt werden kann,
für »new-window« ist dies »neww«.
Also, um ein Fenster zu erzeugen in dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tetris&amp;sektion=6"
>tetris(6)</a> läuft, tippe:

<blockquote><pre>
neww tetris
</pre></blockquote>

<p>
Dieses neue Fenster wird geschlossen, wenn sich tetris beendet, oder kann
zwingend mit der Tastenkombination <i>Ctrl-b &</i> vernichtet werden.
Letzteres wird zuerst eine Bestätigung verlangen, und, wenn gegeben, das
Fenster schließen und das darin laufende Programm beenden.

<p>
Ein weiterer häufiger Wunsch ist die Umbenennung eines Fensters.
Die kann mit der Tastenkombination <i>Ctrl-b ,</i> geschehen.
Die Statuszeile wird sich in einen »(rename-window)«-Prompt ändern, an dem der
neue Name eingegeben werden kann.
Das umbenennen eines Fensters schaltet das automatische Umbenennen für dieses
Fenster aus; um diese Eigenschaft wiederzuerlangen, muss mit der
Tastenkombination <i>Ctrl-b :</i> der Kommandoprompt aktiviert-
und Folgendes eingegeben werden (mehr über die Bedeutung im nächsten
Abschnitt):

<blockquote><pre>
setw -u automatic-rename
</pre></blockquote>

<p>
Ein weitere wichtige Tastenkombination ist es wert, erinnert zu werden:
<i>Ctrl-b ?</i>.
Diese zeigt eine Liste aller tmux Tastenkombinationen und der Kommandos, die
sie ausführen.  Zum Beispiel zeigt <i>Ctrl-b ?</i>, dass die Taste <i>c</i> an
das Kommando »new-window« gebunden ist, und die Taste <i>n</i> an das
Kommando »next-window«.

<h3>tmux konfigurieren</h3>

<p>
Viele Benutzer wollen die Art, wie tmux aussieht oder sich verhält, an ihre
Bedürfnisse anpassen.
Dies geschieht mit Hilfe der Konfigurationsdatei <i>~/.tmux.conf</i>.
Diese Datei enthält eine Liste von tmux-Kommandos, die ausgeführt werden, wenn
tmux ursprünglich gestartet, also bevor die erste Sitzung erzeugt wird.
Alle tmux-Kommandos werden auf der Handbuchseite dokumentiert, aber einige
geläufige Beispiele, die du vielleicht in deiner Konfigurationsdatei haben
möchtest, werden weiter unten diskutiert.

<p>
Der geläufigste Bedarf besteht im Setzen von Optionen.
Es gibt zwei Optionstypen in tmux: <i>Sitzungsoptionen</i> und
<i>Fensteroptionen</i>.
Sitzungsoptionen kontrollieren das Verhalten einer Sitzung, und Fensteroptionen
das einzelner Fenster.
Für beide gibt es eine Anzahl globaler Optionen.
Wenn sich tmux für einen Optionswert zwischen dem einer Sitzung und dem eines
Fensters entscheiden muss, so wird es den lokalen Wert für dieses Fenster
vorziehen, und nur dann den globalen Wert benutzen, wenn kein lokaler gefunden
wurde.

<p>
Sitzungsoptionen werden mit dem Kommando »set-option« (Alias: »set«), und
Fensteroptionen mit dem Kommando »set-window-option« (Alias: »setw«) gesetzt.
Um eine globale Option zu setzen, benutze die »-g« Kommandooption; fehlt diese,
so wird die Option für das aktuelle Fenster oder die aktuelle Sitzung gesetzt.
Diese Kommandos akzeptieren auch wenige andere Optionen, wie z.&nbsp;B. »-u«,
dass eine lokale Option löscht und es damit einem Fenster oder einer Sitzung
erlaubt, wieder die globale Option zu erben.

<p>
In der Konfigurationsdatei ist es üblich, globale Optionen zu setzen.
Lass uns einen Blick auf einige Beispiele werfen, die die Statuszeile anpassen:

<blockquote><pre>
set -g status-bg blue
set -g status-right '#(sysctl vm.loadavg)'
setw -g window-status-current-attr underscore
</pre></blockquote>

<p>
Schreibt man diese drei Kommandos in .tmux.conf und startet tmux danach neu,
so ändert sich der Hintergrund der Statuszeile auf blau, wird der
Systemauslastungsdurchschnitt auf der rechten Seite dargestellt, und außerdem
wird das aktuelle Fenster unterstrichen.
Die Statuszeile kann auch komplett ausgeschaltet werden:

<blockquote><pre>
set -g status off
</pre></blockquote>

<p>
Es existiert eine große Anzahl anderer Optionen; eine weitere Praktische ist
der Wechsel hin zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1"
>vi(1)</a>-ähnlichen Tastenkombinationen am Kommandoprompt und in der
Fensterliste und anderen interaktiven tmux-Modi:

<blockquote><pre>
set -g status-keys vi
setw -g mode-keys vi
</pre></blockquote>

<p>
Die aktuell gesetzten Optionen und ihre Werte kann man mit den Kommandos
»show-options« und »show-window-options« auflisten.
Wie die »set«-Kommandos auch akzeptieren diese die Option »-g« zum Zugriff auf
die globalen Optionen.

<p>
Ein weitere geläufige Aufgabe für die Konfigurationsdatei ist das Hinzufügen
von, oder das Modifizieren bestehender Tastenkombinationen für tmux, dass heißt
der Kommandos, die nach dem Drücken von <i>Ctrl-b</i> zusammen mit einer
weiteren Taste ausgeführt werden.
Diese werden mit dem Kommando »bind-key« (Alias: »bind«) hinzugefügt oder
geändert, und mit dem Kommando »unbind-key« (Alias: »unbind«) entfernt.
Zwei Beispiele für »bind-key« sind:

<blockquote><pre>
bind C-d detach
bind / neww 'exec top'
</pre></blockquote>

<p>
Die erste Zeile erzeugt eine Bindung zwischen <i>Ctrl-b Ctrl-d</i> und der
Loslösung von tmux von dem Bildschirm, identisch der standardmäßigen
<i>Ctrl-b d</i>, und die zweite verknüpft <i>Ctrl-b /</i> mit dem Erzeugen
eines neues Fensters, in welchem »top« ausgeführt wird.

<p>
Viele Leute möchten einen anderen Präfix anstelle von <i>Ctrl-b</i> haben.
Dies kann dadurch erzielt werden, dass sowohl die »set-option« als auch die
Tastenkombinationskommandos benutzt werden, um die Präfixtastenoption
dergestalt zu ändern, dass das zweimalige Drücken auch weiterhin den
Originalwert an das Fenster durchreicht.
Um den Präfix auf <i>Ctrl-a</i> zu ändern:

<blockquote><pre>
set -g prefix C-a
unbind C-b
bind C-a send-prefix
</pre></blockquote>

<p>
Die letzte nützliche Sache, die man in der Konfigurationsdatei machen kann, ist
das Erzeugen einer anfänglichen Reihe von Fenstern, wenn tmux startet.
Dies ist ein wenig komplizierter als die vorangegangenen Beispiele.
In tmux müssen Sitzungen Fenster haben, und ohne Sitzung können keine Fenster
erzeugt werden.
Das heißt, um in der Konfigurationsdatei Fenster zu erzeugen, muss es zuerst
eine Sitzung geben, der sie zugeordnet werden können.
Zum Beispiel (beachte, dass »new« der Alias für das Kommando »new-session« ist):

<blockquote><pre>
new -d 'exec top'
neww -d
neww -d
</pre></blockquote>

<p>
Diese Kommandos erzeugen zuerst eine neue Session, in deren erstem Fenster
»top« läuft, und danach zwei weitere Fenster.
Die »-d«-Optionen weisen tmux an, weder zu versuchen, die neue Session an den
Bildschirm anzuhängen, noch die neuen Fenster zu aktuellen Fenstern zu machen.
Bevor man diese Zeilen in die .tmux.conf schreibt, sollte ein weiteres
Problem bedacht werden.
Wenn man tmux ohne Argumente startet, so führt es das Kommando »new-session«
aus, sodass ein per »tmux« von der Shell gestartetes tmux aus der
Konfigurationsdatei die Anweisung erhält, eine Sitzung zu starten, wonach das
gestartete tmux ebenfalls eine andere Sitzung erzeugt, sodass in diesem
Fall am Ende <i>zwei</i> Sitzungen existieren.
Um dies zu vermeiden, sollte tmux mit »tmux attach« gestartet werden, wenn eine
Sitzung aus der Konfigurationsdatei heraus erzeugt werden soll - dies bedeutet,
dass es die Sitzung aus der .tmux.conf erzeugt und sich danach sofort an sie
anhängt, ohne eine zweite Sitzung zu starten.

<h3>Fortgeschrittene Benutzung von tmux</h3>

<p>
Dieser Abschnitt behandelt kurz einige der eher fortgeschrittenen
Möglichkeiten, die tmux bietet.
Lies die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1"
>Handbuchseite</a> für weitere Informationen.

<p>
In tmux kann man zwischen Fenstern das Kopieren und Einfügen von Text
durchführen.  Dazu muss der Text im <i>Kopiermodus</i> kopiert, und dann mit
dem Einfügekommando eingefügt werden.
Um in den Kopiermodus zu gelangen, benutze <i>Ctrl-b [</i>.
Im Kopiermodus (mit der Fensteroption »mode-keys« gesetzt auf »emacs«, siehe
Handbuchseite für »vi«-Tastenkombinationen) ermöglichen die Pfeiltasten eine
Positionierung des Cursors, <i>Ctrl-Space</i> (Leertaste) beginnt die Selektion
und <i>Ctrl-w</i> kopiert.
Man kann den Cursor ebenfalls mit <i>Page up</i> (Seite hoch), <i>Page down</i>
(Seite runter), <i>Ctrl-a</i> und <i>Ctrl-e</i> bewegen.
Drücke <i>g</i> oder <i>Escape</i>, um den Kopiermodus zu verlassen.
Danach wird <i>Ctrl-b ]</i> den kopierten Text in das aktuelle Fenster
einfügen, als ob man ihn direkt getippt hätte.

<p>
tmux läßt sich ganz gut mit Skripten steuern, und die meisten Kommandos, die am
Kommandoprompt eingegeben, oder über eine Tastaturkombination abgerufen werden
können, können ebenfalls von einer Shell aus benutzt werden.
Beinahe alle tmux-Kommandos akzeptieren ein optionales Argument »-t« zur
Spezifizierung einer Sitzung oder eines Fensters als Kommandoziel.
Zum Beispiel wird dieses Kommando:

<blockquote><pre>
$ tmux kill-window -t0:1
</pre></blockquote>

das Fenster 1 der Sitzung 0 vernichten.
Und:

<blockquote><pre>
$ tmux new-window -tmysession
</pre></blockquote>

<p>
erzeugt ein neues Fenster in der Sitzung mit Namen »mysession«.
Viele Kommandos akzeptieren andere Argumente, zum Beispiel akzeptiert das
Kommando »new-window« eine Option »-n« zur Benennung des neuen Fensters, und
»new-session« akzeptiert verschiedene Argumente zur Spezifizierung von
Attributen für das Fenster, das mit der Sitzung erzeugt wird.
Diese Argumente können ebenfalls benutzt werden, wenn ein Kommando an eine
Tastenkombination gebunden-, oder vom Kommandoprompt aus benutzt wird.

<p>
Ein weiteres nützliches Merkmal ist die Möglichkeit, ein einfaches Fenster in
mehrere Sektionen aufzusplitten, die »<i>pane</i>« (Feld) genannt werden.
Mit der Tastenkombination <i>Ctrl-b "</i> kann man Fenster vertikal (von oben
nach unten) aufteilen.
Ein Feld kann nach oben oder unten mit den Tastenkombinationen
<i>Ctrl-b Alt-Up</i> (Meta und Pfeil-hoch) und <i>Ctrl-b Alt-Down</i> (Meta und
Pfeil-runter) in der Größe verändert, und das aktive Feld mit <i>Ctrl-b o</i>
gewechselt werden.
Zusätzlich kann ein Fenster, das derart aufgeteilt wurde, in eine Reihe fester
Layouts überführt werden, durch welche man mit der Tastenkombination
<i>Ctrl-b Space</i> (Leertaste) durchwechseln kann; jedoch können Felder in
einem solchen Layout nicht in der Größe verändert werden.
In -current wurde das Aufteilen erweitert, und unterstützt nun auch die
horizontale Aufteilung (<i>Ctrl-b %</i>); ebenfalls wurden die festen Layouts
geändert, sodass sie nun einmal (mit denselben <i>Ctrl-b Space</i>
Tasteneingaben) angewendet  aber danach frei sowohl in der Größe, als auch
horizontal und vertikal verändert werden können.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq6.html">[Zum Kapitel 6 - Vernetzung]</a>
<a href= "faq8.html">[Zum Kapitel 8 - Allgemeine Fragen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq7.html,v 1.90 ]<br>
$Translation: faq7.html,v 1.76 2012/01/31 21:20:32 tobias Exp $<br>
-->
$OpenBSD: faq7.html,v 1.69 2012/01/31 23:04:08 ajacoutot Exp $
</small>
</body>
</html>
