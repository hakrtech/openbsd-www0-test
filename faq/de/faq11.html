<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>11 - Leistungstuning</title>
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2005.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Plattformspezifische Fragen]</a>
</font>

<h1><font color="#e00000">11 - Leistungstuning</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#Disk"   >11.1 - Festplatten-E/A</a>
<li><a href="#HW"     >11.2 - Hardwareauswahl</a>
<li><a href="#Async"  >11.3 - Wieso benutzen wir keine »async
      mounts«?</a>
<li><a href="#XF86"   >11.4 - Deine Monitorauflösung unter X
      tunen</a>
</ul>

<hr>


<p>
<a name= "Disk"></a>
<h2>11.1 - Festplatten-E/A</h2>

<p>
Festplatten-E/A-Geschwindigkeit ist ein wichtiger Faktor in der 
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multiuserumgebung beheimatet
(Benutzer aller Arten - von solchen, die sich einloggen, bis zu denen,
die Serverdienste nutzen). Datenspeicher brauchen ständige
Aufmerksamkeit; insbesondere, wenn deine Partition überläuft
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erhöhen
und Fehlertoleranz zu bieten.

<p>
Inhaltsverzeichnis
<ul>
<li><a href="#ccd">CCD</a> - Concatenated Disk Driver.
<li><a href="#raid">RAID</a>
<li><a href="#softu">Softupdates</a>
<li><a href="#maxvnodes">Größe des namei()-Caches</a>
</ul>

<p>
<a name="ccd"></a>
<h3>11.1.1 - CCD</h3>

<blockquote>
Die erste Option ist die Benutzung des 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
- des Concatenated Disk Driver.
Dieser erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu
verwandeln (und damit kannst dafür sorgen, dass mehrere Festplatten wie
eine einzige aussehen). Dieses Konzept ist ähnlich wie das von LVM
(logical volume management), das in mehreren kommerziellen Unix-Arten
zu finden ist. 

<p>
Wenn du GENERIC benutzt, ist ccd bereits eingeschaltet (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  Wenn du einen veränderten
Kernel benutzt, musst du ihn vielleicht wieder in deine
Kernelkonfiguration einfügen. Wie auch immer, auf jeden Fall muss sich
eine Zeile wie die folgende in deiner Konfigurationsdatei befinden:

<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
Das obige Beispiel gibt dir bis zu 4 ccd-Devices (virtuelle Platten).
Jetzt musst du festlegen, welche Partitionen auf deinen realen
Festplatten du in den ccd einbinden willst. Benutze disklabel, um diese
Partitionen als ccd-Typ zu markieren. Auf einigen Architekturen
erlaubt dir disklabel das vielleicht nicht. In diesem Fall markiere sie
einfach als ffs. 

<p>
Wenn du ccd dazu benutzt, um mittels striping Leistung zu gewinnen,
solltest du wissen, dass du keine optimale Leistung bekommst, bis du das
gleiche Festplattenmodell mit den gleichen Disklabeleinstellungen benutzt.

<p>
Editiere /etc/ccd.conf, bis sie etwa so aussieht:
(Mehr Informationen über das Konfigurieren von ccd findest du unter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
Um die Änderungen wirksam zu machen, führe das hier aus:

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Solange /etc/ccd.conf existiert, wird sich ccd automatisch beim Booten 
konfigurieren.
Jetzt hast du eine neue Festplatte (ccd0): eine Kombination von
/dev/sd2e und /dev/sd3e. Benutze disklabel einfach wie gewöhnlich, um
die Partition oder Partitionen zu erzeugen, die du benutzen willst.
Nutze erneut die Partition c nicht, um darauf irgendetwas zu speichern.
Stelle sicher, dass deine benutzten Partitionen mindestens einen
Zylinder vom Anfang der Disk weg ist.
</blockquote>

<p>
<a name="raid"></a>
<h3>11.1.2 - RAID</h3>

<blockquote>
Eine weitere Lösung ist
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
wofür du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
nutzen musst, um deine RAID-Geräte zu kontrollieren. OpenBSDs RAID
basiert auf Greg Osters
<a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD-Port</a>
der
CMU-<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a>-Software.
OpenBSD hat Unterstützung für die RAID-Level
0, 1, 4 und 5.<p> Für raid muss - wie auch bei ccd - Unterstützung
im KERNEL sein.
Diese Treiberunterstützung für RAID ist im Gegensatz zu ccd allerdings
nicht im GENERIC-Kernel enthalten; sie muss also extra in deinen Kernel
einkompiliert werden (RAID-Unterstützung vergrößert deinen
i386-Kernel um gute 500k).

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
Ein RAID aufzusetzen ist mit einigen Betriebssystemen verwirrend und 
schmerzhaft, um es sanft auszudrücken. Nicht jedoch mit RAIDframe.
Lies die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>- und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>-Manualseiten
für die kompletten Details. Es gibt dafür viele Optionen und mögliche
Konfigurationen, und ein detaillierter Überblick sprengt den Rahmen
dieses Dokumentes.
</blockquote>

<p>
<a name="softu"></a>
<h3>11.1.3 - Softupdates</h3>

<blockquote>
Ein weiteres Werkzeug zum Erhöhen der Systemgeschwindigkeit sind
Softupdates. Eine der langsamsten Operationen im traditionellen
BSD-Dateisystem ist das Aktualisieren der Metainfos (was unter anderem
immer dann geschieht, wenn du Dateien oder Verzeichnisse erzeugst oder
löschst). Softupdates versucht die Metainfo im RAM zu aktualisieren,
statt jedes einzelne Metainfoupdate auf die Platte zu schreiben. Ein
weiterer Nebeneffekt ist, dass die Metainfos auf der Festplatte immer
auf dem aktuellen Stand sind. Das heißt, ein Systemabsturz sollte kein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
beim folgende Booten benötigen, sondern eine einfache Hintergrundversion
von fsck, die Änderungen an den Metainfos im RAM macht (a la
Softupdates). Das heißt, dass Reboots viel schneller sind, da 
nicht mehr auf fsck gewartet werden muss! (OpenBSD hat diese
Funktionalität leider noch nicht.) Mehr über Softupdates findest du im 
<a href="faq14.html#SoftUpdates">Softupdates-FAQ</a>-Eintrag.
</blockquote>

<p>
<a name="maxvnodes"></a>
<h3>11.1.4 - Größe des namei()-Caches</h3>

<dl>
<dd>
Hinweis: Bisher hat die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>-Manualseite
empfohlen, die Kerneloption <tt>NVNODE=integer</tt> zu setzen. Das wird
nicht mehr empfohlen; du solltest stattdessen das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
benutzen. 
<p>
Die name-to-inode-Übersetzung (a.&nbps;k.&nbsp;a. <!-- need to write
the manual page first... <a href="">namei(3)</a> --> namei()-Cache)
kontrolliert die Geschwindigkeit der
pathname-to-<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>-Übersetzung.
Ein sinnvoller Weg zum Herausfinden der passenden Größe des Caches
wäre eine große Anzahl namei()-Cachemisses, die man mit einem 
Werkzeug wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a> 
messen könnte (was eine Untersuchung des momentanen berechneten Wertes
mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> voraussetzt, das diesen Parameter <tt>kern.maxvnodes</tt>
nennt) und diesen Wert zu vergrößern, bis sich entweder die Hitrate des
namei()-Caches verbessert oder es bewiesen ist, dass das System nicht
wesentlich von einer Erhöhung der Größe des namei()-Caches profitiert.
Nachdem der Wert festgestellt wurde, kannst du ihn für die nächsten 
Systemstarts mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>
setzen.
</dd>
</dl>


<p>
<a name= "HW"></a>
<h2>11.2 - Hardwareauswahl</h2>
<!-- XXXchanges - check every OpenBSD release -->

<p>
<i>(Hinweis - diese Sektion dreht sich fast ausschließlich um die i386-
oder PC-Architektur. Andere Architekturen geben dir sozusagen keine so
große Auswahl!)</i>

<p>
Die Leistung deiner Anwendungen hängt stark von deinem Betriebssystem
und den Fähigkeiten ab, die es bereitstellt. Das mag ein Grund dafür
sein, dass du OpenBSD benutzt. Die Leistung deiner Anwendungen hängt
aber auch stark von deiner Hardware ab. Für viele Leute ist das
Preisleistungsverhältnis eines brandneuen PCs mit einem
Intel-Pentium-IV oder AMD-Athlon-Prozessors viel besser als das
Preisleistungsverhältnis einer Sun UltraSPARC 60!  Der Preis von OpenBSD
ist natürlich unschlagbar.

<p>
Wenn du einen neuen PC kaufen willst (ob nun in einem Komplettangebot,
oder Einzelteil für Einzelteil), solltest du sicherstellen, dass du 
unbedingt nur zuverlässige Teile bekommst. In der Welt der PCs ist 
das leichter gesagt als getan. 
<b>Schlechte oder sonstig unzuverlässige oder unpassende Teile
können dazu führen, dass OpenBSD schlecht läuft und oft
abstürzt</b>.  Der beste Rat, den wir geben können, ist, vorsichtig 
zu sein und Marken und Teile zu kaufen, die von jemandem empfohlen
werden, dem du trauen kannst. Wenn du nur auf den Preis eines PCs
achtest, wirst du wahrscheinlich auch an Qualität verlieren!

<p>
Es gibt ein paar Dinge, die dir helfen können, die maximale 
Leistung aus deiner Hardware zu holen:

<ul>
<li><b>Benutze mehrere Festplatten.</b>
Statt nur eine große Platte zu kaufen, kaufe mehrere kleine Platten.
Wenn das auch mehr kostet, wird es doch die Last auf mehrere Spindeln
verteilen und somit die Zeitspanne verringern, die ein Datenzugriff
benötigt.  Außerdem kannst du mit mehreren Platten auch mehr
Zuverlässigkeit und schnelleren Datenzugriff mit RAID bekommen.
<p>
<li><b>Benutze SCSI, wenn du hohe Festplatten-E/A-Geschwindigkeit
brauchst.</b> IDE-Festplatten laufen normalerweise mit 5400 RPM bis 7200
RPM. Selbst bei hochwertigen IDE-Platten ist es manchmal zu viel
verlangt, wenn man mehr als 15 bis 20 MB pro Sekunde an Datendurchsatz
von einer einzelnen Platte verlangt. Mit hochwertigen SCSI-Platten (10k
RPM oder 15k RPM) kannst du mehr Durchsatz bekommen. Im Gegensatz dazu
ist es eine Verschwendung von Geld, wenn du mittlere oder langsame
SCSI-Platten benutzt, da dann IDE die gleiche oder bessere Leistung
bringt.
<p>Wenn du einen Server und mehr als ein Laufwerk brauchst, solltest du
über SCSI nachdenken. IDE beschränkt dich auf zwei Platten pro
Controller. Gleichzeitige Zugriffe auf diese Platten haben vermutlich
einen negativen Effekt auf die E/A-Leistung dieser Platten. Mit Wide
SCSI kannst du 15 Platten pro Controller anschließen und es hat bessere
Unterstützung für gleichzeitigen Zugriff als IDE.
<p>
<li><b>Benutze SDRAM statt DRAM.</b>
Diese Option trifft fast nur auf PCs zu. Bei den meisten anderen
Architekturen hast du keinerlei Auswahl, welche Art von RAM du benutzen
kannst. Bei den meisten PCs schon. Mit SDRAM bekommst du eine bessere
Leistung als mit DRAMs (SIMMs). Wenn dein System RDRAM unterstützt oder
vielleicht DDR oder eine andere neue Art von RAM bist du sogar noch
besser dran.
<p>
<li><b>Benutze ECC- oder Parity-RAM.</b>
Parity fügt einen Mechanismus hinzu, der prüft, ob die Daten im RAM noch
in Ordnung sind. ECC baut das noch dahingehend aus, dass es versucht,
Fehler bei einzelnen Bits automatisch zu korrigieren. Diese Option gibt
es wieder fast nur bei PCs. Die meisten anderen Architekturen brauchen
einfach ECC- oder Parity-RAM. Einige Nicht-PC-Computer booten nicht
einmal mit Nicht-Parity-RAM. Wenn du kein ECC-/Parity-RAM benutzt, kann
es zu Datenkorrumpierung und anderen Abnormitäten kommen. Einige
Herstelle von billigem PC-RAM stellen nicht einmal eine ECC-Variante
her! Das hilft dir, sie zu vermeiden! PC-Hersteller verkaufen oftmals
mehrere Produktlinien - in Server und Workstations aufgeteilt. Die
Server haben Parity (und jetzt ECC) seit vielen Jahren beinhaltet.
Unixworkstationhersteller benutzen Parity (und nun ECC) seit vielen
Jahren in all ihren Produktlinien.
<p>
<li><b>Vermeide ISA-Karten.</b>
Während die meisten Leute ISA-Karten schon deshalb meiden, weil
sie veraltet und zudem noch schwer zu konfigurieren sind, gibt es aber
trotzdem noch eine ganze Menge davon. Wenn du den ISA-Bus für deine
Festplatte oder Netzwerkkarte benutzt (oder noch schlimmer, für beides)
denke daran, dass der ISA-Bus vermutlich ein Flaschenhals ist. Wenn du
Geschwindigkeit brauchst, benutze PCI. Natürlich gibt es noch 
zahllose ISA-Karten, die einfach gut funktionieren. Unglücklicherweise 
sind das meist Soundkarten oder solche für serielle Ports.
<p>
<li><b>Vermeide billige PCI-Netzwerkkarten.</b>
OpenBSD unterstützt eine ganze Menge billige PCI-Netzwerkkarten.
Diese Karten funktionieren prima in einfachen Heimsystemen, oder 
solchen mit wenig oder moderater Netzwerklast im Geschäfts-
oder Forschungsbereich. Wenn du aber hohen Durchsatz und
wenig Belastung deines Servers benötigst, bist du mit einer
Qualitätsnetzwerkkarte besser dran. Unglücklicherweise sind einige
Serien teurer Markenhersteller nicht besser als die billigen Karten.
Gigabitkarten sind wegen dem besseren Buffering meist leistungsfähiger
als 10-Mbps-/100-Mbps-Adapter, selbst wenn sie mit langsameren
Netzwerkgeschwindigkeiten genutzt werden.
</ul>


<p>
<a name= "Async"></a>
<h2>11.3 - Wieso benutzen wir keine »async mounts«?</h2>

<p>
Frage: »Ich gebe einfach ein ,mount -u -o async /' ein, was ein Paket,
welches ich brauche, benutzbar macht (das darauf besteht alle paar
Momente ein paar hundert Dateien zu ändern).

Wieso wird ,async mounting' abgelehnt und ist nicht standardmäßig
aktiviert (wie in manchen anderen Unixen)? Wäre das nicht ein
einfacherer und daher auch ein sichererer Weg, die Leistung mancher
Applikation zu erhöhen?«

<p>
Antwort: »Asynchrone Mounts sind tatsächlich schneller als synchrone 
Mounts - aber auch unsicherer. Was passiert im Falle eines
Stromausfalls - oder bei einem Hardwareproblem? Die Suche nach
Geschwindigkeit darf nicht auf Kosten der Stabilität und Zuverlässigkeit
des Systems gehen. Siehe auch die Manualseite von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>.«

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
Auf der anderen Seite kannst du mehr Geschwindigkeit erhalten, wenn du
sowieso nur mit temporären Daten umgehst, die du nach einem Crash wieder
rekonstruieren kannst, indem du eine separate Partition nur für 
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur,
wenn</i> dir der Verlust aller Daten in der Partition nach irgendeinem
Problem nichts ausmacht. Daher sind
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>-Partitionen
asynchron gemountet, weil sie ja nach jedem Neustart sowieso gelöscht
und neu erzeugt werden.


<p>
<a name= "XF86"></a>
<h2>11.4 - Deine Monitorauflösung unter X tunen</h2>

<i>Hinweis: Die meisten Benutzer müssen sich NICHT um die Erstellung einer
ModeLine in modernen Versionen von X sorgen.
TROTZDEM: manchmal ist es in ungewöhnlichen Situationen notwendig.</i>

<p>
Es ist durchaus mit vielen Multisyncmonitoren möglich, einen X-Server
in einer akzeptablen Auflösung zum Laufen zu kriegen. Mit den
Standardkonfigurationswerkzeugen xorgconfig oder XF86Setup ist es aber
recht schwierig, ein gutes Ergebnis zu erhalten. Einer der
schmerzvolleren Punkte ist es, deinen Monitor zur gewünschten Auflösung
zu bewegen und dann eine vertikale Scanrate von mindestens 72 - 75 Hz zu
bekommen; eine Rate, bei der das Bildschirmgeflacker wesentlich geringer
sichtbar für das menschliche Auge ist. Was passiert aber, wenn du die
vertikale Scanfate sehr niedrig einstellst? So könntest du den
Bildschirm zum Beispiel ohne Flackern auf Video filmen - aber auch dazu
sind die Methoden mit den Standardwerkzeugen von X eher nicht intuitiv.

<p>
Schlussendlich ist es bei den Auflösungen
(800x600, 1024x768, 1152x900,1280x1024), die die meisten Leute heute 
mit preiswerten VGA-Monitoren benutzen (zumindest mit neueren Modellen)
bestens möglich, vertikale Wiederholungsraten von 85 Hz und mehr 
zu bekommen, um ein wirklich klares und ansehnliches Bild zu erhalten.
Der X-Server hat einen Mechanismus, der dir erlaubt, im Detail
den Grafikmodus zu beschreiben, den du benutzen willst: dies nennt
sich ModeLine. Eine ModeLine hat vier Sektionen: eine einzelne Nummer 
für die Pixelclock, vier Nummern für horizontales Timing, vier Nummern
für vertikales Timing und eine optionale Sektion mit einer Liste der
Flags für weitere Charakteristika wie etwa den Modus (z.&nbsp;B.
Interlace, DoubleScan und weitere&nbsp;... mehr Details gibt es in der
xorg.conf(5)-Manualseite)

<p>
Das Erzeugen einer ModeLine ist eine schwarze Kunst. Glücklicherweise
gibt es mehrere Skripte, die das für dich erledigen können.
Eines davon ist
<a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">
Colas XFree86 ModeLine Generator</a>.  Ein weiteres ist
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline
Generator</a>, der bei SourceForge gehostet wird. Es gibt weitere bei
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Bevor du diese ModeLinegeneratoren benutzen kannst, musst du die 
vertikalen und horizontalen Syncgrenzen für deinen Monitor herausfinden.
Diese Angaben finden sich oftmals im Handbuch oder auf der Webseite des
Monitorherstellers. Wenn du sie dort nicht finden kannst, suche einfach
im Web nach deinem Modell und Hersteller. Viele Leute waren so
freundlich, Listen mit den entsprechenden Angaben zu erstellen.

<p>
Sagen wir zum Beispiel, du hättest einen Dell-D1226H-Monitor. Du hast
auf Dells Website herausgefunden, dass er einen Bereich von 30 - 95 kHz
horizontal und 50 - 160 Hz vertikal hat. Besuche die
ModeLinegeneratorseite und gib diese Informationen ein. Als nächstes
musst du die minimale vertikale Scanrate eingeben, die du haben
willst. Jede Rate ab 72 Hz und größer sollte im Allgemeinen wenig
flackern. Je mehr, desto besser wird das Bild.

<p>
Mit all diesen Informationen wird das Skript eine ModeLine für jede
mögliche 4x3-Auflösung generieren, die dein Monitor unterstützen
kann. Wenn jemand die Dell-Spezifikationen von oben und eine minimale
vertikale Rate von 75 Hz eingibt, gibt das Skript etwas ähnliches wie
das Folgende aus:

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
Dieser Monitor gibt nun vor, 1600x1200 @ 75 Hz machen zu können.
Das Skript sagt aber nicht, dass das innerhalb der 75 Hz sei.
Wenn du also exakt 1600x1200 haben willst, geh ein wenig mit deiner
minimalen vertikalen Rate herunter. (Hier z.&nbsp;B. kannst du bis
70 Hz heruntergehen)

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
Hier sehen wir, dass der Monitor tatsächlich 1600x1200 @ 74 Hz macht,
wenn die Bandbreite (dot clock) auf 200 MHz begrenzt ist. Setze die
Bandbreite gemäß der Grenzen, die vom Monitor definiert werden.

<p>
Nachdem du einmal die ModeLines hast, schreibe sie in deine
/etc/X11/xorg.conf-Datei. Kommentiere die alten ModeLines aus, so dass
du sie noch benutzen kannst, falls die neuen nicht funktionieren.
Als nächstes wähle aus, mit welcher Auflösung du nun arbeiten willst.
Als erstes musst du nun herausfinden, ob X im beschleunigten Modus
läuft oder nicht (das tut es mit den meisten Grafikkarten), so dass 
du auch weißt, welche <tt>"Screen"</tt>-Sektion der xorg.conf-Datei du 
modifizieren musst. Alternativ kannst du natürlich einfach alle
Screensektionen modifizieren.

<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
Die erste Auflösung nach dem "Modes"-Stichwort ist die Auflösung,
in der X startet. Mit dem Drücken von STRG-ALT-NUMMERN_BLOCK_MINUS oder
STRG-ALT-NUMMERN_BLOCK_PLUS kannst du zwischen den hier aufgeführten
Auflösungen hin- und herschalten. Gemäß der Angaben oben wird X
versuchen, im 32-Bit-Modus zu starten (wegen der
DefaultColorDepth-Direktive - ohne sie würde X im 8-Bit-Modus
starten). Die erste Auflösung, die versucht wird, ist 1280x1024 (es
wird einfach der Reihenfolge in der 'Modes'-Zeile gefolgt). Denke daran,
dass »1280x1024« einfach ein Label für die Werte in der ModeLine ist.

<p>
Du solltest wissen, dass das ModeLinegeneratorskript Optionen hat, um
seine Timings für ältere oder kleinere Monitore etwas zu lockern, und
dass es die Möglichkeit hat, ModeLines für spezielle Monitore
anzubieten. Abhängig davon, was für eine Hardware du hast, ist sie
vielleicht nur schwer mit den Standardoptionen zu betreiben. Wenn das 
Bild zu groß, zu breit oder zu klein ist oder nicht genügend 
horizontal oder vertikal gekippt ist und die Monitorkontrollen zur
Kompensierung nicht ausreichen, kann man mittels xvidtune(1) die
ModeLine besser dem Monitor anpassen.

<p>
In den meisten modernen Monitoren gibt es kein festes Limit der
Bandbreite, daher ist sie auch oftmals nicht in den Spezifikationen
aufgeführt. Aber je mehr du in der Bandbreite nach oben gehst, desto
verschwommener wird das Bild. Du könntest also zum Testen die
Bandbreite deiner Grafikkarte (auch dotclock genannt) eingeben (so
kannst du deinen Monitor nicht beschädigen) und Schritt für Schritt in
Bandbreite heruntergehen, bis du ein schönes, klares Bild hast.

<p>
Wenn dir das unnötig kompliziert erscheint, liegt das daran,
dass es genau das ist. X.org kümmert sich darum und macht diesen
Prozess bedeutend einfacher, da es viele eingebaute Modi hat und außerdem
in der Lage ist, Angaben aus vielen Plug-and-play-DDC- und
-DDC2-Monitoren auszulesen.

<p>
Du kannst das »Colas XFree86 ModeLine Generator script« hier
herunterladen:
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>.
Du brauchst den Kloneinterpreter und musst ihn kompilieren. Er ist als
<tt>lang/klone</tt> in den Ports. Die Skripte existieren im Verzeichnis
scripts der Klonedistribution. (Der Port installiert sie nach
/usr/local/lib/klone/scripts.)

<p>
Es sind zwei Versionen des Skriptes dabei: die erste ist eine
CGI-Version, die identisch zu der obigen Webseite ist, die zweite ist
eine Nicht-CGI-Version, die deine komplette X.org-Datei nimmt, die
Monitorspezifikationen dekodiert, die du in xorgconfig/XF86Setup
eingegeben hast (Hast du eigentlich die echten Spezifikationen für
deinen Monitor eingegeben, oder die generischen benutzt?) und passt die
existierenden ModeLines an.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Plattformspezifische Fragen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq11.html,v 1.57 ]
$Translation: faq11.html,v 1.17 2006/01/13 21:58:46 paldium Exp $
-->
$OpenBSD: faq11.html,v 1.17 2006/01/14 11:35:59 jufi Exp $
</small>
</body>
</html>
