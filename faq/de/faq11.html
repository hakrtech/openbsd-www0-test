<html>
<head>
<title>11.0 - Performance Tuning</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2002 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<h2><font color=#e00000>11.0 - Performance Tuning</font><hr></h2>
</p>

<p>
<ul><h3>Inhaltsverzeichnis</h3>
<li><a href="#Network">11.1 - Netzwerk</a></li>
<li><a href="#Disk"   >11.2 - Festplatten I/O</a></li>
<!-- li><a href="#kmem"   >11.3 - Tuning kmem</a></li -->
<li><a href="#HW"     >11.4 - Hardware Auswahl</a></li>
<li><a href="#Async"  >11.5 - Wieso benutzen wir keine async mounts?</a></li>
<li><a href="#XF86"   >11.6 - Tunen deiner Monitoraufl&ouml;sung unter XFree86</a></li>
</ul>
</p> 
<hr>

<p>
Wenn du einen vielbesuchten Server, ein Gateway oder eine Firewall administrierst, 
m&ouml;chtest oder musst du vielleicht einige der standardm&auml;ssigen 
Parameter anpassen, um eine optimale Performance zu erhalten.
Die <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&sektion=4">options(4)</a> 
man page berichtet &uuml;ber die angebotenen Kerneloptionen. Diese Optionen werden in der 
Kernel-Konfigurationsdatei plaziert, bevor du einen eigenen Kernel kompilierst. 
Mehr Details dazu erh&auml;lst du in der <a href="faq5.html">FAQ 5</a>.
<p>
<a name= "Network"></a>
<a name= "11.1"></a>
<h2>11.1 - Netzwerk</h2>
</p>

<p>
Ein Parameter, der bei einem besonders belasteten Server, Gateway oder 
Firewall vielleicht angepasst werden muss, ist NMBCLUSTERS.  Er 
kontrolliert die Gr&ouml;sse der kernel mbuf cluster map. Wenn du Meldungen
wie "mb_map full" auf deinem Computer bekommst, musst du die Werte f&uuml;r
diesen Parameter vergr&ouml;ssern. Wenn ohne ersichtlichen Grund der 
Traffic auf einem Netzwerk aufh&ouml;rt, kann das ebenfalls ein Zeichen
f&uuml;r zu kleine NMBCLUSTERS sein.  Ein sinnvoller Wert beim i386 port 
mit mindestens 100Mbps ethernet Interfaces (egal wieviele davon
die Maschine hat) ist 8192.  
</p>

<ul>
<strong>
option NMBCLUSTERS=8192<BR>
</strong>
</ul>
Die Standard-Anzahl von NMBCLUSTERS variiert von Plattform zu Plattform, 
und reicht von 256 bis 2048.  Sie werden in einer plattform-abh&auml;ngigen 
Header-Datei gesetzt, es sei denn, sie werden von einer "option"-Zeile 
in einer Kernel-Konfigurations-Datei &uuml;berschrieben.
<br>

<p>
<a name= "Disk"></a>
<a name= "11.2"></a>
<h2>11.2 - Festplatten I/O</h2>
</p>

<p>
Festplatten I/O Geschwindigkeit ist ein wichtiger Faktor in der 
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multi-User-Umgebung beheimatet
(User aller Arten, von solchen, die sich einloggen, bis zu denen
die Serverdienste nutzen). Datenspeicher brauchen st&auml;ndige 
Aufmerksamkeit. Insbesondere, wenn deine Partition &uuml;berl&auml;uft,
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erh&ouml;hen
und Fehlertoleranz zu bieten.
</p>

<ul>Inhaltsverzeichnis
	<li><a href="#ccd">CCD</a> - Concatenated Disk Driver.
	<li><a href="#raid">RAID</a>
	<li><a href="#buf">Filesystem Buffer</a>
	<li><a href="#softu">Soft Updates</a>
	<li><a href="#maxvnodes">Gr&ouml;sse des namei() cache</a>
</ul>
<p>
<a name="ccd"></a>
<H3>11.2.1 - CCD</H3><UL>
<p>
Die erste Option ist die Benutzung des 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&apropos=0&sektion=4&format=html">ccd(4)</a>, 
des Concatenated Disk Driver.
Das erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu verwandeln 
(und damit kannst daf&uuml;r sorgen, dass mehrere Festplatten wie eine 
einzige aussehen). Dieses Konzept ist &auml;hnlich wie das von LVM
(logical volume management), das in mehreren kommerziellen Unix-Arten
zu finden ist. 
<P>
Wenn du GENERIC benutzt, ist ccd bereits eingeschaltet (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  Wenn du einen ver&auml;nderten
Kernel benutzt, musst du es vielleicht wieder in deine Kernel-Konfiguration
einf&uuml;gen. Wie auch immer, auf jeden Fall muss sich eine
Zeile wie die folgende in deiner Konfigurationsdatei befinden:
</p>

<p>
<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>
</p>

<p>
Das obige Beispiel gibt die bis zu 4 ccd Devices (virtuelle Platten).
Jetzt musst du festlegen, welche Partitionen auf deinen realen Festplatten
du in den ccd einbinden willst. Benutze disklabel, um diese
Partitionen als 'ccd'-Typ zu markieren. Auf einigen Architekturen
erlaubt dir disklabel das vielleicht nicht. In diesem Fall markiere sie
einfach als 'ffs'. 
<p>
Wenn du ccd dazu benutzt, um mittels striping Performance zu gewinnen, solltest du wissen,
dass du keine optimale Performance bekommst, bis du das gleiche Festplatten-Modell mit den 
gleichen disklabel Einstellungen benutzt.
<P>
Editiere /etc/ccd.conf, bis sie etwa so aussieht :
(Mehr Informationen &uuml;ber das Konfigurieren von ccd findest du unter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&apropos=0&sektion=8&format=html">ccdconfig(8)</a>)
<UL>
<PRE>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</PRE></UL>
Um die &Auml;nderungen wirksam zu machen, f&uuml;hre das hier aus:
<UL><PRE># ccdconfig -C
</PRE></UL>
Solange /etc/ccd.conf existiert, wird sich ccd automatisch beim Booten 
konfigurieren.
Jetzt hast du eine neue Festplatte, ccd0, eine Kombination von /dev/sd2e und /dev/sd3e.
Benutze disklabel einfach wie gew&ouml;hnlich, um die Partition oder 
Partitionen zu erzeugen, die du benutzen willst. Nutze erneut die 'c' 
Partition nicht, um darauf irgendetwas zu speichern. Stelle sicher, dass 
deine benutzten Partitionen mindestens einen Zylinder vom Anfang
der Disc weg ist.
</p>
</UL>
<br>

<a name="raid"></a>
<H3>11.2.2 - RAID</H3>
<UL>
<p>
Eine weitere L&ouml;sung ist <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&apropos=0&sektion=4&format=html">raid(4)</a>,
wof&uuml;r du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&apropos=0&sektion=8&format=html">raidctl(8)</a>
nutzen musst, um deine RAID Ger&auml;te zu kontrollieren. OpenBSD's RAID basiert auf 
Greg Oster's <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD port</a>
der CMU
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> Software.
OpenBSD hat Unterst&uuml;tzung f&uuml;r die RAID-Level
0, 1, 4, und 5.
<p> 
F&uuml;r RAID muss, wie auch bei ccd, Unterst&uuml;tzung
im KERNEL sein.
Diese Treiber-Unterst&uuml;tzung f&uuml;r RAID ist im Gegensatz zu ccd allerdings nicht 
im GENERIC-Kernel enthalten, also muss sie extra in deinen Kernel
einkompiliert werden (RAID-Unterst&uuml;tzung vergr&ouml;ssert deinen
i386 Kernel um gute 500k!)
</p>

<p>
<UL>
<pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre>
</UL>
<P>
Ein RAID aufzusetzen ist mit einigen Betriebssystemen verwirrend und 
schmerzhaft, um es sanft auszudr&uuml;cken. Nicht jedoch mit RAIDframe.
Lies die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&apropos=0&sektion=4&format=html">raid(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&apropos=0&sektion=8&format=html">raidctl(8)</a>
man pages f&uuml;r die kompletten Details. Es gibt daf&uuml;r viele 
Optionen und m&ouml;gliche Konfiguationen, und ein detaillierter &Uuml;berblick 
sprengt den Rahmen dieses Dokumentes.
</UL>
<BR>

<a name="buf"></a>
<H3>11.2.3 - Filesystem Buffer</H3>
<UL>
Fileserver, die noch Speicher &uuml;berhaben, k&ouml;nnen die BUFCACHEPERCENT 
erh&ouml;hen. Das heisst, welcher Prozentsatz deines RAM als 
"file system buffer" (Dateisystem-Puffer) genutzt werden soll.
Diese Option wird vielleicht ge&auml;ndert, wenn der Unified Buffer Cache 
komplett und ein Teil von OpenBSD ist. In der Zwischenzeit solltest du 
eine Zeile wie diese zu deiner Kernel-Konfiguration hinzuf&uuml;gen, 
um BUFCACHEPERCENT zu erh&ouml;hen:
</UL>
</p>

<p>
<UL>
<strong>option	BUFCACHEPERCENT=30</strong><BR>
</UL>
</p>
<ul>
<p>
Nat&uuml;rlich kannst du ihn auch auf 5 Prozent setzen (dem Standard) oder auch so hoch
wie 50 Prozent (oder auch mehr.)
</p>
</ul>
<br>

<a name="softu"></a>
<H3>11.2.4 - Soft Updates</H3><UL>
Ein weiteres Tool zum Erh&ouml;hen der Systemgeschwindigkeit sind Soft Updates.
Eine der langsamsten Operationen im traditionellen BSD Dateisysteme ist 
das Updaten der Metainfos (was unter anderem immer dann geschieht, wenn 
du Dateien oder Verzeichnisse erzeugst oder l&ouml;schst.) Soft Updates
versucht die Metainfo im RAM upzudaten, statt jedes einzelne Metainfo-Update 
auf die Platte zu schreiben. Ein weiterer Nebeneffekt ist, dass die 
Metainfos auf der Festplatte immer auf dem aktuellen Stand sind. Das heisst, 
ein Systemcrash sollte kein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
beim folgende Booten ben&ouml;tigen, sondern eine einfache 
Hintergrund-Version von fsck, die &Auml;nderungen an den Metainfos im RAM macht
(a la softupdates). Das heisst, dass Reboots viel schneller sind, da 
nicht mehr auf fsck gewartet werden muss! (OpenBSD hat dieses Feature 
leider noch nicht.) Mehr &uuml;ber Soft Updates findest du im 
<a href="../faq14.html#SoftUpdates">Soft Updates FAQ</a> Eintrag.
</UL>
</p>
<BR>

<a name="maxvnodes"></a>
<H3>11.2.5 - Gr&ouml;sse des namei() cache</H3>
<DL>
<DD>
<p>
Hinweis: Vorher hat die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&sektion=4&format=html">options(4)</a>
manual page empfohlen, die <TT>NVNODE=integer</TT> Kernel Option zu setzen. Das wird nicht mehr
empfohlen; du solltest stattdessen das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8&format=html">sysctl(8)</a>
Kommando benutzen. 
</p>
<p>
Die name-to-inode &Uuml;bersetzung (a.k.a., <!-- need to write the manual
page first... <a href="">namei(3)</a> --> namei()) cache kontrolliert die Geschwindigkeit
der pathname zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&sektion=5&format=html">inode(5)</a>
&Uuml;bersetzung. Standardm&auml;ssig hat dieser Cache <TT>NPROC * (80 + NPROC / 8)</TT> 
Eintr&auml;ge. <TT>NPROC</TT> ist auf <TT>20 + 16 * MAXUSERS</TT> gesetzt; in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&sektion=8&format=html">config(8)</a>
manual page steht eine Erkl&auml;rugn der <TT>maxusers</TT> Kernel-Konfigurations-Parameter.
Ein sinnvoller Weg zum Herausfinden der passenden Gr&ouml;sse des Cache 
w&auml;re, eine gro&szlig;e Anzahl von namei() cache misses vorrausgesetzt, die man mit einem 
Tool wie   
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&sektion=1&format=html">systat(1)</a> 
messen k&ouml;nnte, w&auml;re eine Untersuchung des momentanen 
berechneten Wertes mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8&format=html">sysctl(8)</a>,
(das diesen Parameter "<TT>kern.maxvnodes</TT>" nennt) und diesen Wert zu 
verg&ouml;ssern, bis sich entweder die namei() cache hit rate verbessert,
oder es bewiesen ist, dass das System nicht wesentlich von einer
Erh&ouml;hung der Gr&ouml;sse des namei() cache profitiert. Nachdem der 
Wert gestgestellt wurde, kannst du ihn f&uuml;r die n&auml;chsten 
Systemstarts mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5&format=html">sysctl.conf(5)</a>
setzen.
</DD>
</DL>
</p>
<BR>

<p>
<!-- a name= "kmem"></a>
<a name= "11.3"></a>
<h2>11.3 - Tuning kmem</h2>
</p>
This was moved to the <a href="faq11-2.5.html#11.2">OpenBSD 2.5 information section</a>.
<br>
<p -->
<a name= "HW"></a>
<a name= "11.4"></a>
<h2>11.4 - Hardware Auswahl</h2>
</p>
<i>(Hinweis - diese Sektion dreht sich fast ausschliesslich um die i386 oder PC Architektur.
Andere Architekturen geben dir sozusagen keine so grosse Auswahl!)</i>
<P>
Die Performance deiner Anwendungen h&auml;ngt stark von deinem 
Betriebssystem und den F&auml;higkeiten ab, die es bereitstellt. Das mag
ein Grund daf&uuml;r sein, dass du OpenBSD benutzt.
Die Performance deiner Anwendungen h&auml;ngt aber auch stark von deiner 
Hardware ab.
F&uuml;r viele Leute ist das Preis-Leistungs-Verh&auml;ltnis eines 
brandneuen PC mit einem Intel Pentium IV oder AMD Athlon Prozessors viel
besser als das Preis-Leistungs-Verh&auml;ltnis einer Sun UltraSparc 60!
Der Preis von OpenBSD ist nat&uuml;rlich unschlagbar.
<P>
Wenn du einen neuen PC kaufen willst, ob nun in einem Komplettangebot,
oder Einzelteil f&uuml;r Einzelteil, solltest du sicherstellen, dass du 
unbedingt nur zuverl&auml;ssige Teile bekommst. In der Welt der PCs ist 
das leichter gesagt als getan. 
<b>Schlechte oder sonstige unzuverl&auml;ssige oder unpassende Teile
k&ouml;nnen dazu f&uuml;hren, dass OpenBSD schlecht l&auml;uft und oft
abst&uuml;rzt</b>.  Der beste Rat, den wir geben k&ouml;nnen, ist, vorsichtig 
zu sein, und Marken und Teile zu kaufen, die von jemandem empfohlen werden,
dem du trauen kannst. Wenn du nur auf den Preis eines PCs achtest, wirst 
du wahrscheinlich auch an Qualit&auml;lt verlieren!
<P>
Es gibt ein paar Dinge, die dir helfen k&ouml;nnen, die maximale 
Performance aus deiner Hardware zu holen:
<UL>
<LI>Benutze mehrere Festplatten.
<P>Statt nur eine 20GB Platte zu kaufen, kaufe mehrere 9GB Platten. Wenn 
das auch mehr kostet, wird es doch die Last auf mehrere Spindeln verteilen,
und somit die Zeitspanne verringern, die ein Datenzugriff ben&ouml;tigt.
Ausserdem kannst du mit mehreren Platten auch mehr Zuverl&auml;ssigkeit
und schnelleren Datenzugriff mit RAID bekommen.
<p>
<LI>Benutze SCSI, wenn du hohe Festplatten-IO-Geschwindigkeit brauchst.
<P>IDE Festplatten laufen normalerweise mit 5400 RPM bis 7200 RPM.  
Selbst bei hochwertigen IDE Platten ist es manchmal zu viel verlangt, wenn
man mehr als 15 bis 20 MB pro Sekunde an Datendurchsatz von einer einzelnen
Platte verlangt. Mit hochwertigen SCSI-Platten (10k RPM oder 15k RPM)
kannst du mehr Durchsatz bekommen. 
Im Gegensatz dazu ist es eine Verschwendung von Geld, wenn du mittlere oder
langsame SCSI-Platten benutzt, da dann IDE die gleiche oder bessere Leistung
bringt.
<P>Wenn du einen Server baust, und mehr als 20 GB Plattenplatz brauchst, 
solltest du &uuml;ber SCSI nachdenken. IDE beschr&auml;nkt dich auf zwei
Platten pro Controller. Gleichzeitige Zugriffe auf diese Platten haben
vermutlich einen negativen Effekt auf die I/O Performance dieser 
Platten. Mit Wide SCSI kannst du 15 Platten pro Controller anschliessen,
und es hat bessere Unterst&uuml;tzung f&uuml;r gleichzeitigen Zugriff 
als IDE.
<P>
<li>Benutze SDRAM statt DRAM.
<P>
Diese Option trift fast nur auf PCs zu. Bei den meisten anderen Architekturen
hast du keinerlei Auswahl welche Art von RAM du benutzen kannst. Bei den
meisten PCs schon. Mit SDRAM bekommst du eine bessere Performance als mit
DRAMs (SIMMs). Wenn dein System RDRAM unterst&uuml;tzt, oder vielleicht
DDR oder eine andere neue Art von RAM bist du sogar noch besser dran..  
<P>
<li>Benutze ECC oder parity RAM.
<P>
Parity f&uuml;gt einen Mechanismus hinzu, der pr&uuml;ft, ob die Daten im 
RAM noch in Ordnung sind. ECC baut das noch dahingehend aus, dass es 
versucht, Fehler bei einzelnen Bits automatisch zu korrigieren. 
Diese Option gibt es wieder fast nur bei PCs. Die meisten anderen 
Architekturen brauchen einfach ECC oder parity RAM. Einige nicht-PC-Computer
booten nicht einmal mit nicht-parity-RAM. 
Wenn du kein ECC/parity RAM benutzt, kann es zu Daten-Korrumpierung und
anderen Abnormit&auml;ten kommen. Einige Herstelle von "billigem  PC RAM"
stellen nicht einmal eine ECC-Variante her! Das hilft dir, sie zu vermeiden!
PC Hersteller verkaufen oftmals mehrere Produktlinien, in "Server" und
"Workstations" aufgeteilt. Die Server haben parity (und jetzt ECC) seit 
vielen Jahren beinhaltet. Unix-Workstation-Hersteller benutzen parity 
(und nun ECC) seit vielen Jahren in all ihren Produktlinien.
<P>
<LI>Vermeide ISA-Karten.
<P>
W&auml;hrend die meisten Leute ISA-Karten schon deshalb meiden, weil
sie veraltet und zudem noch schwer zu konfigurieren sind, gibt es aber
trotzdem noch eine ganze Menge davon. Wenn du den ISA Bus f&uuml;r deine
Festplatte oder Netzwerk-Karte benutzt (oder noch schlimmer, f&uuml;r beides)
denke daran, dass der ISA Bus vermutlich ein Flaschenhals ist. Wenn du
Geschwindigkeit brauchst, benutze PCI. Nat&uuml;rlich gibt es noch 
zahllose ISA-Karten, die einfach gut funktionieren. Ungl&uuml;cklicherweise 
sind das meist Sound-Karten oder solche f&uuml;r serielle Ports.
<P>
<LI> Vermeide billige PCI Netzwerk-Karten.
<P>
OpenBSD unterst&uuml;tzt eine ganze Menge von billigen PCI Netzwerk-Karten.  
Diese Karten funktionieren prima in einfachen Heim-Systemen, oder 
solchen mit wenig oder moderater Netzwerk-Last im Gesch&auml;fts-
oder Forschungs-Bereich. Aber, wenn du hohen Durchsatz brauchst, und
wenig Belastung deines Servers, bist du mit einer 
Qualit&auml;ts-Netzwerk-Karte besser dran. Ungl&uuml;cklicherweise
sind einige Serien von teuren Marken-Herstellern (wie die 3com XL Serie) 
nicht besser als die billigen Karten.
Ein echter Favorit unter den 10/100Mbps Netzwerk-Karten ist dagegen die 
Intel EtherExpress PRO/100.
<P>
</ul>
<br>
<p>
<a name= "Async"></a>
<a name= "11.5"></a>
<h2>11.5 - Wieso benutzen wir keine async mounts?</h2>
<p>
Frage: "Ich gebe einfach ein "mount -u -o async /"ein, was ein Paket, was ich 
brauche, benutzbar macht. 
(das darauf besteht alle paar Momente ein paar hundert Dateien zu &auml;ndern.)

Wieso wird asynchrones mounting abgelehnt und ist nicht standardm&auml;ssig 
aktiviert (wie in manchen anderen Unixen) ? W&auml;re das nicht ein 
einfacherer, und daher auch sichererer Weg, die Performance mancher 
Applikation zu erh&ouml;hen ?"
</p>
<p>
Antwort: "Asynchrone mounts sind tats&auml;chlich schneller als synchrone 
mounts, aber sie sind unsicherer. Was passiert im Falle eine Stromausfalls?
Oder bei einem Hardwareproblem ? Die Suche nach Geschwindigkeit darf nicht
auf Kosten von Stabilit&auml;t und Zuverl&auml;ssigkeit des Systems gehen.
Siehe auch die man page von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&apropos=0&sektion=8&format=html">mount(8)</a>."
</p>
<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>
<p>
Auf der anderen Seite, wenn du sowieso nur mit tempor&auml;ren Daten 
umgehst, die du nach einem Crash wieder rekonstruieren kannst, kannst du
mehr Geschwindigkeit erhalten, indem du eine separate Partition nur f&uuml;r 
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur</i>,
wenn dir der Verlust aller Daten in der Partition nach irgendeinem
Problem nichts ausmacht. Daher sind
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&sektion=8">mfs(8)</a>
Partitionen asynchron gemountet, weil sie ja nach jedem Reboot sowieso
gel&ouml;scht und neu erzeugt werden.
</p>
<br>
<p>
<a name= "XF86"></a>
<a name= "11.6"></a>
<h2>11.6 - Tunen deiner Monitoraufl&ouml;sung unter XFree86</h2>
<p>
Es ist durchaus mit vielen multi-Sync-Monitoren m&ouml;glich, einen X 
Server in einer azeptablen Aufl&ouml;sung zum Laufen zu kriegen.
Mit den Standard-Konfigurations-Werkzeugen xf86config oder XF86Setup ist
es aber recht schwierig, ein gutes Ergebnis zu erhalten. Einer der 
schmerzvolleren Punkte ist es, deinen Monitor zur gew&uuml;nschten
Aufl&ouml;sung zu bewegen, und dann eine vertikale Scan-Rate von
mindestens 72-75 Hz zu bekommen, eine Rate, bei der das Bildschirmgeflacker
wesentlich geringer sichtbar f&uuml;r menschliche Augen ist.
Was passiert aber, wenn du die vertikale Scan-Rate sehr niedrig einstellst?
So k&ouml;nntest du den Bildschirm zum Beispiel ohne Flackern auf Video
filmen, aber auch dazu sind die Methoden mit den Standard-Werkzeugen von
XFree86 eher nicht-intuitiv.
<P>
Schlussendlich ist es bei den Aufl&ouml;sungen, 
(800x600, 1024x768, 1152x900,1280x1024), die die meisten Leute heute 
mit preiswerten VGA-Monitoren benutzen (zumindest mit neueren Modellen)
bestens m&ouml;glich, vertikale Wiederholungsraten von 85 Hz und mehr 
zu bekommen, um ein wirklich klares und ansehnliches Bild zu erhalten.
Der XFree86 X Server hat einen Mechanismus, der dir erlaubt, im Detail
den Grafik-Modus zu beschreiben, den du benutzen willst, dies nennt
sich ModeLine. Eine ModeLine hat vier Sektionen, eine einzelne Nummer 
f&uuml;r die Pixel Clock, vier Nummern f&uuml;r horizontales Timing,
vier Nummern f&uuml;r vertikales Timing, und eine optionale Sektion
mit einer Liste von Flags f&uuml;r weitere Charakteristika wie etwa 
den Modus (z.B. Interlace, DoubleScan, und weitere.. mehr Details
gibt es in der XF86Config(5) manual page)
<P>
Das Erzeugen einer ModeLine ist eine schwarze Kunst.. Gl&uuml;cklicherweise
gibt es mehrere Skripte, die das f&uuml;r dich erledigen k&ouml;nnen.
Eines davon ist der <a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">
Colas XFree86 ModeLine Generator</a>.  Ein weiteres ist der 
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline Generator</a>
, der bei SourceForge gehostet wird, und es gibt weitere bei
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Bevor du diese ModeLine-Generatoren benutzen kannst, musst du die 
vertikalen und horizontalen sync Limits f&uuml;r deinen Monitor herausfinden.
Diese Angaben finden sich oftmals im Handbuch, oder auf der Webseite des
Monitor-Herstellers. Wenn du sie dort nicht finden kannst, suche einfach im Web nach
deinem Modell und Hersteller, viele Leute waren so freundlich, Listen
mit den entsprechenden Angaben zu erstellen.
<P>
Sagen wir zum Beispiel, du h&auml;ttest einen Dell D1226H Monitor.  Du hast auf
Dell's Website herausgefunden, das er einen Bereich  von 30-95 kHz horizontal 
und 50-160 Hz vertikal hat. Besuche die ModeLine Generator Page,
und gib diese Informationen ein. Als n&auml;chstes musst du die minimale
vertical scan rate eingeben, die du haben willst. Jede Rate ab 72 Hz und 
gr&ouml;sser sollte im allgemeinen wenig flackern. Je mehr, desto besser 
wird das Bild.
<P>
Mit all diesen Informationen wird das Skript eine ModeLine f&uuml;r jede
m&ouml;gliche 4x3 Aufl&ouml;sung generieren, die dein Monitor unterst&uuml;tzen
kann. Wenn jemand die Dell Spezifikationen von oben und eine minimale vertikale
Rate von 75 Hz eingibt, gibt das Skript etwas &auml;hnliches wie das folgende
aus:
<P>
<PRE>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</PRE>
<P>
Dieser Monitor gibt nun vor, 1600x1200 @ 75 Hz machen zu k&ouml;nnen, 
aber das Skript sagt nicht, dass das innerhalb der  75 Hz sei.
Wenn du also exakt 1600x1200 haben willst, geh ein wenig mit deiner
minimalen vertikalen Rate herunter.. (Hier z.B. kannst du bis
70 Hz heruntergehen)
<Pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</PRE>
<P>
Hier sehen wir, dass der Monitor tats&auml;chlich 1600x1200 @ 74 Hz macht,
wenn die dot clock (Bandbreite) auf 200MHz begrenzt ist. Setze die Bandbreite
gem&auml;ss der Grenzen, die vom Monitor definiert werden.
<P>
Nachdem du einmal die ModeLines hast, schreibe sie in deine /etc/XF86Config Datei. 
Kommentiere die alten ModeLines aus, so dass du sie noch benutzen kannst, 
falls die neuen nicht funktionieren.
Als n&auml;chstes w&auml;hle aus, mit welcher Aufl&ouml;sung du nun 
arbeiten willst. Als erstes musst du nun herausfinden, ob X im "accelerated mode"
l&auml;uft, oder nicht (das tut es mit den meisten Grafik-Karten), so dass 
du auch weisst, welche <TT>"Screen"</tt> Sektion der XF86Config-Datei du 
modifizieren musst. Alternativ kannst du nat&uuml;rlich einfach alle Screen-Sektionen
modifizieren.
<PRE>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</PRE>
Die erste Aufl&ouml;sung nach dem "Modes" Stichwort ist die Aufl&ouml;sung,
in der X startet. Mit dem Dr&uuml;cken von CTRL-ALT-KEYPAD MINUS oder CTRL-ALT-KEYPAD
PLUS kannst du zwischen den hier aufgef&uuml;hrten Aufl&ouml;sungen hin-
und herschalten. Gem&auml;ss der Angaben oben wird X versuchen im 32-Bit-Modus 
(wegen der DefaultColorDepth Direktive, ohne sie w&uuml;rde X im 8-Bit-Modus 
starten.) Die erste Aufl&ouml;sung, die versucht wird, ist 1280x1024 (es
wird einfach der Reihenfolge in der 'Modes'-Zeile gefolgt.)  Denke daran, dass
"1280x1024" einfach ein Label f&uuml;r die Werte in der ModeLine ist.
<P>
Du solltest wissen, dass das ModeLine Generator-Skript Optionen hat, um seine
Timings f&uuml;r &auml;ltere oder kleinere Monitore etwas zu lockern, und
dass es die M&ouml;glichkeit hat, ModeLines f&uuml;r spezielle Monitore
anzubieten. Abh&auml;ngig davon, was f&uuml;r eine Hardware du hast, ist sie
vielleicht nur schwer mit den Standard-Optionen zu betreiben. Wenn das 
Bild zu gross ist, zu breit oder zu klein, oder nicht gen&uuml;gend 
horizontal oder vertikal gekippt ist, und die Monitor-Kontrollen zur
Kompensierung nicht ausreichen, kann man mittels xvidtune(1) die ModeLine 
besser dem Monitor anpassen.
<P>
In den meisten modernen Monitoren gibt es kein fixes Limit der Bandbreite,
daher ist sie auch oftmals nicht in den Spezifikationen aufgef&uuml;hrt.
Aber je mehr du in der Bandbreite nach oben gehst, desto  verschwommener
wird das Bild. Du k&ouml;nntest also zum Testen die Bandbreite deiner Grafikkarte
(auch "dotclock" genannt) eingeben (so kannst du deinen Monitor nicht
besch&auml;digen) und Schritt-f&uuml;r-Schritt in BW heruntergehen, bis du
ein sch&ouml;nes, klares Bild hast.
<P>
Wenn dir das unn&ouml;tig kompliziert erscheint, liegt das daran,
dass es genau das ist. XFree86 4.0 k&uuml;mmert sich darum, und macht diesen
Prozess bedeutend einfacher, da es viele eingebaute Modi hat, und ausserdem
in der Lage ist, Angaben aus vielen "plug and play" DDC und DDC2 
Monitoren auszulesen.
<P>
Du kannst das "Colas XFree86 ModeLine Generator script" hier herunterladen:
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>.
Du brauchst den Klone Interpreter, und musst ihn kompilieren. Er ist in als
<tt>lang/klone</tt> in den ports. Die Skripte existieren im "scripts" 
Verzeichnis der Klone Distribution.  (Der port installiert sie nach
/usr/local/lib/klone/scripts.)
<P>
Es sind zwei Versionen des Skriptes dabei, die erste ist eine CGI Version 
die identisch zu der obigen Webseite ist. Die zweite ist eine nicht-CGI-Version
die deine komplette XF86Config-Datei nimmt, dekodiere die Monitor-Spezifikationen,
die du in xf86config/XF86Setup eingegeben hast (Hast du eigentlich die echten
Spezifikationen f&uuml;r deinen Monitor eingegeben, oder die generischen
benutzt?) und passe die existierenden ModeLines an.
<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "../faq10.html">[To Section 10.0 - System Administration]</a>
<a href= "faq12.html">[To Section 12.0 - F&uuml;r fortgeschrittene Users]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq11.html,v 1.28 ]
<br>
$Translation: faq11.html,v 1.1 2002/08/05 16:35:54 jufi Exp $
<br></small>
<small>$OpenBSD: faq11.html,v 1.1 2002/08/05 16:39:17 jufi Exp $</small>
</p>
</body>
</html>
