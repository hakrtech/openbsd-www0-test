<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>11 - Leistungs Tuning</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "../faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href= "../faq12.html">[Zum Kapitel 12 - Plattform-spezifische Fragen]</a>
</font>

<h1><font color="#e00000">11 - Leistungs Tuning</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#Disk"   >11.1 - Festplatten E/A</a>
<li><a href="#HW"     >11.2 - Hardware Auswahl</a>
<li><a href="#Async"  >11.3 - Wieso benutzen wir keine ,async mounts'?</a>
<li><a href="#XF86"   >11.4 - Deine Monitor-Auflösung unter X
tunen</a>
</ul>

<hr>


<p>
<a name= "Disk"></a>
<h2>11.1 - Festplatten E/A</h2>

<p>
Festplatten E/A Geschwindigkeit ist ein wichtiger Faktor in der 
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multi-User-Umgebung beheimatet
(User aller Arten, von solchen, die sich einloggen, bis zu denen
die Serverdienste nutzen). Datenspeicher brauchen ständige 
Aufmerksamkeit. Insbesondere, wenn deine Partition überläuft
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erhöhen
und Fehlertoleranz zu bieten.

<p>
Inhaltsverzeichnis
<ul>
<li><a href="#ccd">CCD</a> - Concatenated Disk Driver.
<li><a href="#raid">RAID</a>
<li><a href="#softu">Soft Updates</a>
<li><a href="#maxvnodes">Größe des namei() Cache</a>
</ul>

<p>
<a name="ccd"></a>
<H3>11.1.1 - CCD</H3>

<blockquote>
Die erste Option ist die Benutzung des 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>, 
des Concatenated Disk Driver.
Dieser erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu verwandeln 
(und damit kannst dafür sorgen, dass mehrere Festplatten wie eine 
einzige aussehen). Dieses Konzept ist ähnlich wie das von LVM
(logical volume management), das in mehreren kommerziellen Unix-Arten
zu finden ist. 

<p>
Wenn du GENERIC benutzt, ist ccd bereits eingeschaltet (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  Wenn du einen veränderten
Kernel benutzt, musst du ihn vielleicht wieder in deine Kernel-Konfiguration
einfügen. Wie auch immer, auf jeden Fall muss sich eine
Zeile wie die folgende in deiner Konfigurationsdatei befinden:

<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
Das obige Beispiel gibt dir bis zu 4 ccd Devices (virtuelle Platten).
Jetzt musst du festlegen, welche Partitionen auf deinen realen Festplatten
du in den ccd einbinden willst. Benutze disklabel, um diese
Partitionen als ,ccd'-Typ zu markieren. Auf einigen Architekturen
erlaubt dir disklabel das vielleicht nicht. In diesem Fall markiere sie
einfach als ,ffs'. 

<p>
Wenn du ccd dazu benutzt, um mittels striping Performance zu gewinnen,
solltest du wissen, dass du keine optimale Leistung bekommst, bis du das
gleiche Festplatten-Modell mit den gleichen disklabel Einstellungen benutzt.

<p>
Editiere /etc/ccd.conf, bis sie etwa so aussieht:
(Mehr Informationen über das Konfigurieren von ccd findest du unter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
Um die Änderungen wirksam zu machen, führe das hier aus:

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Solange /etc/ccd.conf existiert, wird sich ccd automatisch beim Booten 
konfigurieren.
Jetzt hast du eine neue Festplatte, ccd0, eine Kombination von /dev/sd2e
und /dev/sd3e.
Benutze disklabel einfach wie gewöhnlich, um die Partition oder 
Partitionen zu erzeugen, die du benutzen willst. Nutze erneut die ,c'
Partition nicht, um darauf irgendetwas zu speichern. Stelle sicher, dass 
deine benutzten Partitionen mindestens einen Zylinder vom Anfang
der Disk weg ist.
</blockquote>

<p>
<a name="raid"></a>
<h3>11.1.2 - RAID</h3>

<blockquote>
Eine weitere Lösung ist <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
wofür du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
nutzen musst, um deine RAID Geräte zu kontrollieren. OpenBSDs RAID basiert auf 
Greg Osters <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD Port</a>
der CMU
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> Software.
OpenBSD hat Unterstützung für die RAID-Level
0, 1, 4 und 5. Für raid muss, wie auch bei ccd, Unterstützung
im KERNEL sein.
Diese Treiber-Unterstützung für RAID ist im Gegensatz zu ccd allerdings nicht 
im GENERIC-Kernel enthalten, also muss sie extra in deinen Kernel
einkompiliert werden (RAID-Unterstützung vergrößert deinen
i386 Kernel um gute 500k).

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
Ein RAID aufzusetzen ist mit einigen Betriebssystemen verwirrend und 
schmerzhaft, um es sanft auszudrücken. Nicht jedoch mit RAIDframe.
Lies die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
Manual Seiten für die kompletten Details. Es gibt dafür viele 
Optionen und mögliche Konfigurationen, und ein detaillierter
Überblick sprengt den Rahmen dieses Dokumentes.
</blockquote>

<p>
<a name="softu"></a>
<h3>11.1.3 - Soft Updates</h3>

<blockquote>
Ein weiteres Tool zum Erhöhen der Systemgeschwindigkeit sind Soft Updates.
Eine der langsamsten Operationen im traditionellen BSD Dateisystem ist 
das Updaten der Metainfos (was unter anderem immer dann geschieht, wenn 
du Dateien oder Verzeichnisse erzeugst oder löschst). Soft Updates
versucht die Metainfo im RAM upzudaten, statt jedes einzelne Metainfo-Update 
auf die Platte zu schreiben. Ein weiterer Nebeneffekt ist, dass die 
Metainfos auf der Festplatte immer auf dem aktuellen Stand sind. Das
heißt,  ein Systemcrash sollte kein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
beim folgende Booten benötigen, sondern eine einfache 
Hintergrund-Version von fsck, die Änderungen an den Metainfos im RAM macht
(a la softupdates). Das heißt, dass Reboots viel schneller sind, da 
nicht mehr auf fsck gewartet werden muss! (OpenBSD hat dieses Feature 
leider noch nicht.) Mehr über Soft Updates findest du im 
<a href="faq14.html#SoftUpdates">Soft Updates FAQ</a> Eintrag.
</blockquote>

<p>
<a name="maxvnodes"></a>
<h3>11.1.4 - Größe des namei() Cache</h3>

<dl>
<dd>
Hinweis: Vorher hat die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>
Manual Seite empfohlen, die <tt>NVNODE=integer</tt> Kernel Option zu setzen.
Das wird nicht mehr empfohlen; du solltest stattdessen das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
Kommando benutzen. 
<p>
Die name-to-inode Übersetzung (a.k.a., <!-- need to write the manual
page first... <a href="">namei(3)</a> --> namei() Cache) kontrolliert die
Geschwindigkeit der pathname zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>
Übersetzung.
Ein sinnvoller Weg zum Herausfinden der passenden Größe des Cache 
wäre, eine große Anzahl von namei() ,cache misses', die man mit einem 
Tool wie   
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a> 
messen könnte, vorausgesetzt, eine Untersuchung des momentanen 
berechneten Wertes mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>,
(das diesen Parameter "<tt>kern.maxvnodes</tt>" nennt) und diesen Wert zu 
vergrößern, bis sich entweder die namei() Cache ,hit rate'
verbessert, oder es bewiesen ist, dass das System nicht wesentlich von einer
Erhöhung der Größe des namei() Cache profitiert. Nachdem der 
Wert festgestellt wurde, kannst du ihn für die nächsten 
Systemstarts mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>
setzen.
</dd>
</dl>


<p>
<a name= "HW"></a>
<h2>11.2 - Hardware Auswahl</h2>
<!-- XXXchanges - check every OpenBSD release -->

<p>
<i>(Hinweis - diese Sektion dreht sich fast ausschließlich um die i386
oder PC Architektur. Andere Architekturen geben dir sozusagen keine so
große Auswahl!)</i>

<p>
Die Leistung deiner Anwendungen hängt stark von deinem 
Betriebssystem und den Fähigkeiten ab, die es bereitstellt. Das mag
ein Grund dafür sein, dass du OpenBSD benutzt.
Die Leistung deiner Anwendungen hängt aber auch stark von deiner 
Hardware ab.
Für viele Leute ist das Preis-Leistungs-Verhältnis eines 
brandneuen PCs mit einem Intel Pentium IV oder AMD Athlon Prozessors viel
besser als das Preis-Leistungs-Verhältnis einer Sun UltraSPARC 60!
Der Preis von OpenBSD ist natürlich unschlagbar.

<p>
Wenn du einen neuen PC kaufen willst, ob nun in einem Komplettangebot,
oder Einzelteil für Einzelteil, solltest du sicherstellen, dass du 
unbedingt nur zuverlässige Teile bekommst. In der Welt der PCs ist 
das leichter gesagt als getan. 
<b>Schlechte oder sonstige unzuverlässige oder unpassende Teile
können dazu führen, dass OpenBSD schlecht läuft und oft
abstürzt</b>.  Der beste Rat, den wir geben können, ist, vorsichtig 
zu sein und Marken und Teile zu kaufen, die von jemandem empfohlen werden,
dem du trauen kannst. Wenn du nur auf den Preis eines PCs achtest, wirst 
du wahrscheinlich auch an Qualität verlieren!

<p>
Es gibt ein paar Dinge, die dir helfen können, die maximale 
Leistung aus deiner Hardware zu holen:

<ul>
<li><b>Benutze mehrere Festplatten.</b>
Statt nur eine große Platte zu kaufen, kaufe mehrere kleine Platten. Wenn 
das auch mehr kostet, wird es doch die Last auf mehrere Spindeln verteilen
und somit die Zeitspanne verringern, die ein Datenzugriff benötigt.
Außerdem kannst du mit mehreren Platten auch mehr Zuverlässigkeit
und schnelleren Datenzugriff mit RAID bekommen.
<p>
<li><b>Benutze SCSI, wenn du hohe Festplatten-EA-Geschwindigkeit brauchst.</b>
IDE Festplatten laufen normalerweise mit 5400 RPM bis 7200 RPM.  
Selbst bei hochwertigen IDE Platten ist es manchmal zu viel verlangt, wenn
man mehr als 15 bis 20 MB pro Sekunde an Datendurchsatz von einer einzelnen
Platte verlangt. Mit hochwertigen SCSI-Platten (10k RPM oder 15k RPM)
kannst du mehr Durchsatz bekommen. 
Im Gegensatz dazu ist es eine Verschwendung von Geld, wenn du mittlere oder
langsame SCSI-Platten benutzt, da dann IDE die gleiche oder bessere Leistung
bringt.
<p>Wenn du einen Server und mehr als ein Laufwerk brauchst, 
solltest du über SCSI nachdenken. IDE beschränkt dich auf zwei
Platten pro Controller. Gleichzeitige Zugriffe auf diese Platten haben
vermutlich einen negativen Effekt auf die E/A Leistung dieser 
Platten. Mit Wide SCSI kannst du 15 Platten pro Controller anschließen
und es hat bessere Unterstützung für gleichzeitigen Zugriff 
als IDE.
<p>
<li><b>Benutze SDRAM statt DRAM.</b>
Diese Option trifft fast nur auf PCs zu. Bei den meisten anderen Architekturen
hast du keinerlei Auswahl welche Art von RAM du benutzen kannst. Bei den
meisten PCs schon. Mit SDRAM bekommst du eine bessere Leistung als mit
DRAMs (SIMMs). Wenn dein System RDRAM unterstützt oder vielleicht
DDR oder eine andere neue Art von RAM bist du sogar noch besser dran.
<p>
<li><b>Benutze ECC oder Parity RAM.</b>
Parity fügt einen Mechanismus hinzu, der prüft, ob die Daten im 
RAM noch in Ordnung sind. ECC baut das noch dahingehend aus, dass es 
versucht, Fehler bei einzelnen Bits automatisch zu korrigieren. 
Diese Option gibt es wieder fast nur bei PCs. Die meisten anderen 
Architekturen brauchen einfach ECC oder Parity RAM. Einige nicht-PC-Computer
booten nicht einmal mit nicht-Parity-RAM. 
Wenn du kein ECC/Parity RAM benutzt, kann es zu Daten-Korrumpierung und
anderen Abnormitäten kommen. Einige Herstelle von "billigem  PC RAM"
stellen nicht einmal eine ECC-Variante her! Das hilft dir, sie zu vermeiden!
PC Hersteller verkaufen oftmals mehrere Produktlinien, in "Server" und
"Workstations" aufgeteilt. Die Server haben Parity (und jetzt ECC) seit 
vielen Jahren beinhaltet. Unix-Workstation-Hersteller benutzen Parity 
(und nun ECC) seit vielen Jahren in all ihren Produktlinien.
<p>
<li><b>Vermeide ISA-Karten.</b>
Während die meisten Leute ISA-Karten schon deshalb meiden, weil
sie veraltet und zudem noch schwer zu konfigurieren sind, gibt es aber
trotzdem noch eine ganze Menge davon. Wenn du den ISA Bus für deine
Festplatte oder Netzwerkkarte benutzt (oder noch schlimmer, für beides)
denke daran, dass der ISA Bus vermutlich ein Flaschenhals ist. Wenn du
Geschwindigkeit brauchst, benutze PCI. Natürlich gibt es noch 
zahllose ISA-Karten, die einfach gut funktionieren. Unglücklicherweise 
sind das meist Soundkarten oder solche für serielle Ports.
<p>
<li><b>Vermeide billige PCI Netzwerkkarten.</b>
OpenBSD unterstützt eine ganze Menge von billigen PCI Netzwerkkarten.
Diese Karten funktionieren prima in einfachen Heim-Systemen, oder 
solchen mit wenig oder moderater Netzwerk-Last im Geschäfts-
oder Forschungs-Bereich. Aber, wenn du hohen Durchsatz brauchst, und
wenig Belastung deines Servers, bist du mit einer 
Qualitäts-Netzwerkkarte besser dran. Unglücklicherweise
sind einige Serien von teuren Marken-Herstellern nicht besser als die billigen
Karten. Gigabit Karten sind wegen dem besseren Buffering meist
leistungsfähiger als 10Mbps/100Mbps Adapter, selbst wenn sie mit
langsameren Netzwerkgeschwindigkeiten genutzt werden.
</ul>


<p>
<a name= "Async"></a>
<h2>11.3 - Wieso benutzen wir keine ,async mounts'?</h2>

<p>
Frage: "Ich gebe einfach ein "mount -u -o async /" ein, was ein Paket, was ich 
brauche, benutzbar macht. 
(das darauf besteht alle paar Momente ein paar hundert Dateien zu ändern.)

Wieso wird ,async mounting' abgelehnt und ist nicht
standardmäßig aktiviert (wie in manchen anderen Unixen)?
Wäre das nicht ein einfacherer, und daher auch ein sichererer Weg,
die Leistung mancher Applikation zu erhöhen?"

<p>
Antwort: "Asynchrone mounts sind tatsächlich schneller als synchrone 
mounts, aber sie sind unsicherer. Was passiert im Falle eine Stromausfalls?
Oder bei einem Hardwareproblem? Die Suche nach Geschwindigkeit darf nicht
auf Kosten von Stabilität und Zuverlässigkeit des Systems gehen.
Siehe auch die Manual Seite von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;apropos=0&amp;sektion=8">mount(8)</a>."

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
Auf der anderen Seite, wenn du sowieso nur mit temporären Daten 
umgehst, die du nach einem Crash wieder rekonstruieren kannst, kannst du
mehr Geschwindigkeit erhalten, indem du eine separate Partition nur für 
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur,
wenn</i> dir der Verlust aller Daten in der Partition nach irgendeinem
Problem nichts ausmacht. Daher sind
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
Partitionen asynchron gemountet, weil sie ja nach jedem Reboot sowieso
gelöscht und neu erzeugt werden.


<p>
<a name= "XF86"></a>
<h2>11.4 - Deine Monitor-Auflösung unter X tunen</h2>

<i>Hinweis: Die meisten Benutzer müssen sich NICHT um die Erstellung einer
ModeLine in modernen Versionen von X sorgen.
TROTZDEM, manchmal ist es in ungewöhnlichen Situationen notwendig.</i>

<p>
Es ist durchaus mit vielen multi-Sync-Monitoren möglich, einen
X-Server in einer akzeptablen Auflösung zum Laufen zu kriegen.
Mit den Standard-Konfigurations-Werkzeugen xorgconfig oder XF86Setup ist
es aber recht schwierig, ein gutes Ergebnis zu erhalten. Einer der 
schmerzvolleren Punkte ist es, deinen Monitor zur gewünschten
Auflösung zu bewegen, und dann eine vertikale Scan-Rate von
mindestens 72-75 Hz zu bekommen, eine Rate, bei der das Bildschirmgeflacker
wesentlich geringer sichtbar für menschliche Augen ist.
Was passiert aber, wenn du die vertikale Scan-Rate sehr niedrig einstellst?
So könntest du den Bildschirm zum Beispiel ohne Flackern auf Video
filmen, aber auch dazu sind die Methoden mit den Standard-Werkzeugen von
X eher nicht intuitiv.

<p>
Schlussendlich ist es bei den Auflösungen, 
(800x600, 1024x768, 1152x900,1280x1024), die die meisten Leute heute 
mit preiswerten VGA-Monitoren benutzen (zumindest mit neueren Modellen)
bestens möglich, vertikale Wiederholungsraten von 85 Hz und mehr 
zu bekommen, um ein wirklich klares und ansehnliches Bild zu erhalten.
Der X-Server hat einen Mechanismus, der dir erlaubt, im Detail
den Grafik-Modus zu beschreiben, den du benutzen willst, dies nennt
sich ModeLine. Eine ModeLine hat vier Sektionen, eine einzelne Nummer 
für die Pixel Clock, vier Nummern für horizontales Timing,
vier Nummern für vertikales Timing und eine optionale Sektion
mit einer Liste von Flags für weitere Charakteristika wie etwa 
den Modus (z.B. Interlace, DoubleScan und weitere... mehr Details
gibt es in der XF86Config(5) Manual Seite)

<p>
Das Erzeugen einer ModeLine ist eine schwarze Kunst. Glücklicherweise
gibt es mehrere Skripte, die das für dich erledigen können.
Eines davon ist der <a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">
Colas XFree86 ModeLine Generator</a>.  Ein weiteres ist
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline Generator</a>,
der bei SourceForge gehostet wird, und es gibt weitere bei
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Bevor du diese ModeLine-Generatoren benutzen kannst, musst du die 
vertikalen und horizontalen sync Grenzen für deinen Monitor herausfinden.
Diese Angaben finden sich oftmals im Handbuch oder auf der Webseite des
Monitor-Herstellers. Wenn du sie dort nicht finden kannst, suche einfach im
Web nach deinem Modell und Hersteller, viele Leute waren so freundlich, Listen
mit den entsprechenden Angaben zu erstellen.

<p>
Sagen wir zum Beispiel, du hättest einen Dell D1226H Monitor.  Du hast auf
Dells Website herausgefunden, dass er einen Bereich von 30-95 kHz horizontal 
und 50-160 Hz vertikal hat. Besuche die ModeLine Generator Page,
und gib diese Informationen ein. Als nächstes musst du die minimale
vertical scan rate eingeben, die du haben willst. Jede Rate ab 72 Hz und 
größer sollte im Allgemeinen wenig flackern. Je mehr, desto besser 
wird das Bild.

<p>
Mit all diesen Informationen wird das Skript eine ModeLine für jede
mögliche 4x3 Auflösung generieren, die dein Monitor unterstützen
kann. Wenn jemand die Dell Spezifikationen von oben und eine minimale vertikale
Rate von 75 Hz eingibt, gibt das Skript etwas ähnliches wie das folgende
aus:

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
Dieser Monitor gibt nun vor, 1600x1200 @ 75 Hz machen zu können, 
aber das Skript sagt nicht, dass das innerhalb der  75 Hz sei.
Wenn du also exakt 1600x1200 haben willst, geh ein wenig mit deiner
minimalen vertikalen Rate herunter. (Hier z.B. kannst du bis
70 Hz heruntergehen)

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
Hier sehen wir, dass der Monitor tatsächlich 1600x1200 @ 74 Hz macht,
wenn die Bandbreite (dot clock) auf 200MHz begrenzt ist. Setze die Bandbreite
gemäß der Grenzen, die vom Monitor definiert werden.

<p>
Nachdem du einmal die ModeLines hast, schreibe sie in deine /etc/X11/XF86Config Datei. 
Kommentiere die alten ModeLines aus, so dass du sie noch benutzen kannst, 
falls die neuen nicht funktionieren.
Als nächstes wähle aus, mit welcher Auflösung du nun 
arbeiten willst. Als erstes musst du nun herausfinden, ob X im "accelerated
mode" läuft, oder nicht (das tut es mit den meisten Grafik-Karten), so dass 
du auch weißt, welche <tt>"Screen"</tt> Sektion der XF86Config-Datei du 
modifizieren musst. Alternativ kannst du natürlich einfach alle Screen-Sektionen
modifizieren.

<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
Die erste Auflösung nach dem "Modes" Stichwort ist die Auflösung,
in der X startet. Mit dem Drücken von STRG-ALT-NUMMERN_BLOCK MINUS oder
STRG-ALT-NUMMERN_BLOCK PLUS kannst du zwischen den hier aufgeführten
Auflösungen hin- und herschalten. Gemäß der Angaben oben wird X versuchen im
32-Bit-Modus zu starten (wegen der DefaultColorDepth Direktive, ohne sie
würde X im 8-Bit-Modus starten). Die erste Auflösung, die versucht wird, ist
1280x1024 (es wird einfach der Reihenfolge in der 'Modes'-Zeile gefolgt).
Denke daran, dass "1280x1024" einfach ein Label für die Werte in der
ModeLine ist.

<p>
Du solltest wissen, dass das ModeLine Generator-Skript Optionen hat, um seine
Timings für ältere oder kleinere Monitore etwas zu lockern, und
dass es die Möglichkeit hat, ModeLines für spezielle Monitore
anzubieten. Abhängig davon, was für eine Hardware du hast, ist sie
vielleicht nur schwer mit den Standard-Optionen zu betreiben. Wenn das 
Bild zu groß, zu breit oder zu klein ist oder nicht genügend 
horizontal oder vertikal gekippt ist und die Monitor-Kontrollen zur
Kompensierung nicht ausreichen, kann man mittels xvidtune(1) die ModeLine 
besser dem Monitor anpassen.

<p>
In den meisten modernen Monitoren gibt es kein festes Limit der Bandbreite,
daher ist sie auch oftmals nicht in den Spezifikationen aufgeführt.
Aber je mehr du in der Bandbreite nach oben gehst, desto  verschwommener
wird das Bild. Du könntest also zum Testen die Bandbreite deiner Grafikkarte
(auch "dotclock" genannt) eingeben (so kannst du deinen Monitor nicht
beschädigen) und Schritt-für-Schritt in Bandbreite heruntergehen, bis du
ein schönes, klares Bild hast.

<p>
Wenn dir das unnötig kompliziert erscheint, liegt das daran,
dass es genau das ist. X.org kümmert sich darum und macht diesen
Prozess bedeutend einfacher, da es viele eingebaute Modi hat und außerdem
in der Lage ist, Angaben aus vielen "plug and play" DDC und DDC2 
Monitoren auszulesen.

<p>
Du kannst das "Colas XFree86 ModeLine Generator script" hier herunterladen:
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>.
Du brauchst den Klone Interpreter und musst ihn kompilieren. Er ist als
<tt>lang/klone</tt> in den Ports. Die Skripte existieren im "scripts" 
Verzeichnis der Klone Distribution. (Der Port installiert sie nach
/usr/local/lib/klone/scripts.)

<p>
Es sind zwei Versionen des Skriptes dabei, die erste ist eine CGI Version,
die identisch zu der obigen Webseite ist. Die zweite ist eine nicht-CGI Version,
die deine komplette X.org-Datei nimmt, die Monitor-Spezifikationen
dekodiert, die du in xorgconfig/XF86Setup eingegeben hast (Hast du eigentlich
die echten Spezifikationen für deinen Monitor eingegeben, oder die
generischen benutzt?) und passt die existierenden ModeLines an.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "../faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Plattformspezifische Fragen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq11.html,v 1.56 ]
$Translation: faq11.html,v 1.11 2005/05/20 10:58:57 paldium Exp $
-->
$OpenBSD: faq11.html,v 1.11 2005/05/20 14:55:33 jufi Exp $
</small>
</body>
</html>
