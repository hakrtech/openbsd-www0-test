<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>4 - Installationsanleitung für OpenBSD 5.0</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 4 - Installationsanleitung">
<meta name= "keywords"      content= "openbsd,faq4">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2011 by OpenBSD.">
</head>

<!-- Passes validator.w3.org.  Please keep it this way -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Starten mit OpenBSD]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<h1><font color="#e00000">4 - Installationsanleitung für OpenBSD 5.0</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href= "#Overview"    >4.1 - Eine Übersicht über die
                                OpenBSD-Installationsprozedur</a>
<li><a href= "#Checklist"   >4.2 - Vor der Installation: Checkliste</a>
<li><a href="#MkInsMedia"   >4.3 - Startbare OpenBSD-Installationsmedien
                                erzeugen</a>
    <ul>
    <li><a href="#MkCD-ROM" >4.3.1 - Eine »Boot«-CD erzeugen</a>
    <li><a href="#UnixFlop" >4.3.2 - Disketten unter Unix erzeugen</a>
    <li><a href="#DosFlop"  >4.3.3 - Disketten unter Windows erzeugen</a>
    </ul>
<li><a href="#Boot"         >4.4 - Starten eines
                                OpenBSD-Installationsmediums</a>
<li><a href="#Install"      >4.5 - Eine einfache Installation durchführen</a>
  <ul>
  <li><a href="#InstStart"    >4.5.1 - Mit der Installation beginnen</a>
  <li><a href="#InstQuestions">4.5.2 - Die Fragen der Installation</a>
  <li><a href="#InstDisks"    >4.5.3 - Laufwerke einrichten</a>
  <li><a href="#InstMedia"    >4.5.4 - Auswahl des Installationsmediums
                                und der Dateisets</a>
  <li><a href="#Inst1stBoot"  >4.5.5 - Der erste Start!</a>
  <li><a href="#InstFinish"   >4.5.6 - Eine letzte Sache...</a>
  </ul>
<li><a href="#More"         >4.6 - Details für eine komplexere Installation</a>
  <ul>
  <li><a href="#MoreNetwork"  >4.6.1 - Einrichtung des Netzwerks</a>
  <li><a href="#MoreTimeZone" >4.6.2 - Festlegung der Zeitzone</a>
  <li><a href="#Morefdisk"    >4.6.3 - Anpassung der fdisk(8)-Konfiguration</a>
  <li><a href="#Moredisklabel">4.6.4 - Anpassung der disklabel-Konfiguration</a>
  </ul>
<li><a href= "#FilesNeeded" >4.7 - Welche Dateien werden für die Installation
                                benötigt?</a>
<li><a href= "#Partitioning">4.8 - Wie sollte ich mein Laufwerk
                                partitionieren?</a>
<li><a href= "#Multibooting">4.9 - »Multibooting« OpenBSD/i386</a>
<li><a href= "#SendDmesg"   >4.10 - Das Senden deiner »dmesg« an
                                dmesg@openbsd.org nach der Installation</a>
<li><a href= "#AddFileSet"  >4.11 - Ein Dateiset nach der Installation
                                hinzufügen</a>
<li><a href= "#bsd.rd"      >4.12 - Was ist »bsd.rd«?</a>
<li><a href= "#InstProb"    >4.13 - Geläufige Installationsprobleme</a>
  <ul>
  <li><a href="#cpq16m"     >4.13.1 - Mein Compaq erkennt nur 16&nbsp;MB RAM</a>
  <li><a href="#noboot"     >4.13.2 - Mein i386 startet nach der Installation
                                nicht</a>
  <li><a href="#sshhang"    >4.13.3 - Mein System startete, hing aber bei der
                                ssh-Schlüsselgenerierung</a>
  <li><a href="#noftplist"  >4.13.4 - Ich bekam die Meldung
                                »Failed to change directory«,
                                als ich die Installation durchführte</a>
  <li><a href="#blankfdisk" >4.13.5 - Meine fdisk-Partitionstabelle ist kaputt
                                oder leer!</a>
  <li><a href="#noflopcd"   >4.13.6 - Mein System besitzt weder Disketten-
                                noch CD-ROM-Laufwerk</a>
  <li><a href="#shamismatch">4.13.7 - Ich bekam einen SHA256-Prüfsummenfehler
                                während der Installation!</a>
  </ul>
<li><a href= "#site"        >4.14 - Anpassung des Installationsprozesses</a>
<li><a href= "#Multiple"    >4.15 - Wie kann ich eine Anzahl gleichartiger
                                Systeme installieren?</a>
<li><a href="#getdmesg"     >4.16 - Woher bekomme ich eine dmesg(8), damit ich
                              ein Problem mit der Installation melden kann?</a>
</ul>
<hr>

<p>
<a name= "Overview"></a>
<h2>4.1 - Eine Übersicht über die OpenBSD-Installationsprozedur</h2>

<p>
OpenBSD wird seit langem für seinen einfachen und geradlinigen
Installationsprozess anerkannt, der auf allen Plattformen gleich aufgebaut ist.

<p>
Alle Plattformen besitzen eine sehr ähnliche Installationsprozedur, jedoch
gibt es auf ein paar Plattformen einige kleine Unterschiede im Detail.
In jedem Fall wird dringend dazu geraten, das plattformspezifische
INSTALL-Dokument im <i>Plattform</i>-Verzeichnis auf der CD-ROM oder den
FTP-Seiten (z.&nbsp;B. <tt>i386/INSTALL.i386</tt>,
<tt>macppc/INSTALL.macppc</tt> oder <tt>sparc/INSTALL.sparc</tt>) durchzulesen.

<p>
Das OpenBSD Installationsprogramm ist ein <a href="#bsd.rd">spezieller</a>
Kernel mit einigen Werkzeugen und Installationsskripten, die sich auf einem
vorgeladenen RAM-Laufwerk befinden.  Nachdem dieser Kernel gestartet wurde,
wird das Betriebssystem aus einigen komprimierten
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>
(<tt>.tgz</tt>) Dateien extrahiert, die sich nicht auf dem vorgeladenen
RAM-Laufwerk befinden, und daher aus einer anderen Quelle bezogen werden müssen.
Es existieren mehrere Wege, diesen Installationskernel zu starten:

<ul>
<li><b>Diskette:</b>
OpenBSD kann auf vielen Plattformen installiert werden, indem ein
Installationsprogramm von einer einzigen Diskette gestartet wird.
Einschränkungen des verfügbaren Speicherplatzes jedoch zwingt einige »größere«
Plattformen (sparc64, amd64, alpha) dazu, einige Werkzeuge auszulassen, die
vielleicht gerade für dich wichtig sind, z.&nbsp;B. ein DHCP Programm, welches
das Netzwerk konfigurieren könnte.
Auf diesen Plattformen wirst du wahrscheinlich mit einer CD-basierten
Installation besser fahren.  Auf Plattformen wie i386 und sparc jedoch wird dir
der Inhalt der Startdiskette sehr komplett erscheinen.
<p>
Die bereitgestellten Diskettenabbilder können dazu benutzt werden,
um Installationsdisketten auf einem anderen
<a href="#UnixFlop">Unix-ähnlichen</a>- oder einem
<a href="#DosFlop">Windows</a>-System zu erstellen.
Ein typischer Dateiname ist <tt>floppy50.fs</tt>, obwohl für einige
Plattformen mehrere Diskettenabbilder vorhanden sind.

<li><b>CD-ROM:</b> Für einige Plattformen wird ein CD-ROM-Abbild
(<tt>cd50.iso</tt> zum reinen Starten oder <tt>install50.iso</tt> für
eine gesamte Installation) bereitgestellt, mit dem eine startbare CD-ROM
erzeugt werden kann.

<li><b>Bestehende Partition:</b> Der <a href="#bsd.rd">RAM-Laufwerk</a>s-Kernel
kann für ein »Upgrade« oder eine Neuinstallation von einer bereits
existierenden OpenBSD-Partition geladen werden.

<li><b>Netzwerk:</b> Manche Systeme können über das Netzwerk starten (zum
Beispiel unter Verwendung von <a href="faq6.html#PXE">PXE</a> oder einem
anderen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8">Netzwerk-»Boot«-Prozess</a>).

<li><b>Ein Dateisystemabbild auf Platte schreiben (»miniroot«):</b> Ein
Dateisystemabbild (»Image«), das auf eine existierende Partition geschrieben
und daraufhin gestartet werden kann.

<li><b>Startfähiges Band:</b> Einige Systeme können von Band starten.
Diese Bänder können anhand der INSTALL.<i>Plattform</i>-Anleitung erstellt
werden.
</ul>

Nicht jede <a href="../../de/plat.html">Plattform</a> unterstützt alle
Startmöglichkeiten:

<ul>
<li><a href="../../de/alpha.html"><b>alpha:</b></a> Diskette, CD-ROM,
Netzwerk, Diskettenabbild auf Festplatte schreiben.

<li><a href="../../de/amd64.html"><b>amd64:</b></a> Diskette, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../de/armish.html"><b>armish:</b></a>
Je nach Maschine unterschiedlich.

<li><a href="../../de/hp300.html"><b>hp300:</b></a> CD-ROM, Netzwerk.

<li><a href="../../de/hppa.html"><b>hppa:</b></a> Netzwerk.

<li><a href="../../de/i386.html"><b>i386:</b></a> Diskette, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../de/landisk.html"><b>landisk:</b></a> »miniroot«, das mit
Hilfe eines anderen Rechners installiert wurde.

<li><a href="../../de/macppc.html"><b>macppc:</b></a> CD-ROM, Netzwerk.

<li><a href="../../de/mvme68k.html"><b>mvme68k:</b></a> Netzwerk, startbares
Band.

<li><a href="../../de/mvme88k.html"><b>mvme88k:</b></a> Netzwerk, startbares
Band.

<li><a href="../../de/sparc.html"><b>sparc:</b></a> Diskette, CD-ROM, Netzwerk,
schreiben eines Abbilds auf eine existierende Partition, startbares Band.

<li><a href="../../de/sparc64.html"><b>sparc64:</b></a> Diskette (nur U1/U2),
CD-ROM, Netzwerk, schreiben eines Abbilds auf eine existierende Partition.

<li><a href="../../de/vax.html"><b>vax:</b></a> Diskette, Netzwerk.

<li><a href="../../de/zaurus.html"><b>zaurus:</b></a> Starte bsd.rd von einer
Linux-Partition. Lies
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/5.0/zaurus/INSTALL.zaurus">INSTALL.zaurus</a>
für weitere Details.
</ul>

Alle Plattformen können ebenfalls einen <a href="#bsd.rd">bsd.rd</a> für eine
Neuinstallation oder ein »Upgrade« verwenden.

<p>
Wenn der Installationskernel erst einmal gestartet ist, gibt es mehrere
Möglichkeiten, um die <a href="#FilesNeeded">Installations-Dateisets</a> zu
beziehen.  Wie üblich unterstützt nicht jede Plattform dieselben Optionen.

<ul>
<li><b>CD-ROM:</b> Selbstverständlich bevorzugen wir, dass du das
<a href="../../de/orders.html">offizielle CD-ROM-Set</a> verwendest, aber du
kannst auch <tt>install50.iso</tt> benutzen, oder dein Eigenes erstellen.

<li><b>FTP:</b>
Entweder über einen der
OpenBSD-<a href="../../de/ftp.html">FTP-Spiegelserver</a>,
oder aber dein eigener lokaler FTP-Server, der die Dateisets vorhält.

<li><b>HTTP:</b>
Entweder über einen der
OpenBSD-<a href="../../de/ftp.html#http">HTTP-Spiegelserver</a>,
oder aber dein eigener lokaler Web-Server, der die Dateisets vorhält.

<li><b>Lokale Festplattenpartition:</b>
In vielen Fällen kannst du die Dateisets von einer anderen Partition einer
lokalen Festplatte aus installieren.
Um ein Beispiel zu nennen, kannst du auf <a href="../../de/i386.html">i386</a>
von einer FAT-Partition, oder einer CD-ROM mit ISO9660-, Rock-Ridge- oder
Joliet-Format aus installieren.
In einigen Fällen musst du das Dateisystem manuell einhängen, bevor du es
verwenden kannst.

<li><b>NFS:</b>
Manche Plattformen unterstützen eingehängte NFS (»Network File System«) für die
Dateisets.

<li><b>Band:</b>
Dateisets können ebenfalls von einem unterstützten Band gelesen werden.
Details darüber, wie ein solches Band erstellt werden kann, finden sich im
<tt>INSTALL.</tt><i>Plattform</i>-Dokument.
</ul>

<a name="Checklist"></a>
<h2>4.2 - Vor der Installation: Checkliste</h2>

<p>
Bevor du mit der eigentlichen Installation beginnst, solltest du dir darüber im
Klaren sein, was du eigentlich am Ende haben willst.

Zumindest die folgenden Punkte sollten daher vorab geklärt werden:
<ul>
<li>Der Name der Maschine
<li>Die eingebaute Hardware
  <ul>
  <li>Prüfe die Kompatibilität anhand der
      Kompatibilitätsseite für deine Hardware.
  <li>Wenn du ISA-Komponenten verwendest, so musst du die Einstellungen
      kennen und prüfen, ob sie den Anforderungen von OpenBSD entsprechen.
  </ul>
<li>Die gewünschte Installationsmethode (CD-ROM, FTP etc.)
<li>Wie soll das System »gepatcht« werden, falls ein wichtiger Fehler entdeckt
    wird?
  <ul>
  <li>Wenn dies lokal geschehen soll, so musst du
      <a href="#Partitioning">genügend freien Speicher</a> für den
      Quelltext-Baum und dessen Erzeugung haben.
  <li>Ansonsten muss es Zugang zu einer anderen Maschine geben, um dort ein
      »gepatchtes« »<a href="faq5.html#Release">Release</a>« zu erzeugen.
  </ul>
<li>Die gewünschte Plattenaufteilung
  <ul>
  <li>Müssen vorhandene Daten irgendwo gesichert werden?
  <li>Soll OpenBSD neben einem anderen Betriebssystem auf dem Rechner
      existieren?
      Wenn ja: wie sollen die beiden Systeme gestartet werden?
      Wird ein »Bootmanager« benötigt?
  <li>Wird OpenBSD die ganze Festplatte belegen, oder möchtest du eine
      existierende Partition/ein existierendes Betriebssystem behalten (oder
      Speicher für zukünftige Solche)?
  <li>Wie willst du den für OpenBSD reservierten Platz
      weiter unterteilen?
  </ul>
<li>Netzwerkeinstellungen, falls DHCP nicht verwendet wird:
  <ul>
  <li>Domänenname
  <li>DNS-Server Adresse(n) (zur Auflösung von Domänennamen in Adressen)
  <li>IP-Adressen und Subnetzmasken für jede Netzwerkkarte (NIC)
  <li>Gateway-Adressen
  </ul>
<li>Hast du vor, das grafische »X Window System« zu benutzen?
</ul>


<a name="MkInsMedia"></a>
<h2>4.3 - Startbare OpenBSD-Installationsmedien erzeugen</h2>

<p>
Als Beispiele werden wir die Installationsmedien betrachten, die für die
Plattformen <a href="../../de/i386.html">i386</a> und
<a href="../../de/sparc.html">sparc</a> bereitstehen.

<p>
Die <a href="../../de/i386.html">i386</a>-Plattform besitzt sechs
separate Installations-Laufwerksabbilder, aus denen gewählt werden kann:

<ul>
<li><b><tt>cd50.iso</tt></b> ist ein ISO9660-Abbild, das für die Erstellung
  einer startbaren CD mit den allermeisten bekannten CD-ROM-Brennprogrammen
  auf den allermeisten Plattformen verwendet werden kann.
  Dieses Abbild hat die größte Auswahl an Treibern, und ist normalerweise
  die empfohlene Wahl, wenn deine Hardware von CD-ROM starten kann.
<li><b><tt>cdemu50.iso</tt></b> ist ein ISO9660-Abbild, das zum Starten
  eine »Disketten-Emulation« und ein 2.88&nbsp;MB Diskettenabbild benutzt.
  Es wird gehofft, dass nur wenige Leute dieses Abbild benutzen -- die meisten
  werden <tt>cd50.iso</tt> benutzen.  Verwende <tt>cdemu50.iso</tt> nur,
  wenn <tt>cd50.iso</tt> bei dir nicht funktioniert.
<li><b><tt>install50.iso</tt></b> ist ein ISO9660-Abbild, das alle
  Standard-Dateisets enthält.
  Es kann dazu verwendet werden, eine startbare CD zu erzeugen,
  die eine vollständige OpenBSD-Installation durchführen kann.
<li><b><tt>floppy50.fs</tt></b> (Desktop-PC) unterstützt viele
  PCI- und ISA-Netzwerkkarten, IDE-, SATA- und einfache SCSI-Adapter,
  sowie einige PCMCIA-Karten. Die meisten Benutzer werden dieses Abbild
  verwenden, wenn sie von einer Diskette aus starten.
<li><b><tt>floppyB50.fs</tt></b> (Server) unterstützt viele RAID-Controller
  und einige der selteneren SCSI-Adapter.  Jedoch wurde die Unterstützung
  für viele Standard-SCSI-Adapter und viele EISA- und ISA-Netzwerkkarten
  entfernt.
<li><b><tt>floppyC50.fs</tt></b> (Laptops) unterstützt viele der
  Cardbus- und PCMCIA-Karten, die man in Laptops findet.
</ul>

<p>
Die <a href="../../de/sparc.html">sparc</a>-Plattform besitzt vier
separate Installations-Laufwerksabbilder, aus denen gewählt werden kann:

<ul>
<li><b><tt>floppy50.fs</tt></b>: Unterstützt Systeme mit Diskettenlaufwerk.
<li><b><tt>cd50.iso</tt></b>: Ein ISO-Abbild, mit dem eine CD erzeugt werden
    kann, um SPARC-Systeme von einer CD-ROM aus starten zu können.
<li><b><tt>miniroot50.fs</tt></b>: Kann auf eine Auslagerungs-Partition
    geschrieben, und daraufhin gestartet werden.
<li><b><tt>install50.iso</tt></b>: ein ISO9660-Abbild, das alle
    Standard-Dateisets enthält.  Es kann dazu verwendet werden, eine startbare
    CD zu erzeugen, die eine vollständige OpenBSD-Installation durchführen
    kann.
</ul>

Auf modernen Plattformen ist man am Besten beraten, wenn man eines der
startbaren CDROM-Abbilder benutzt, da auf einigen der »größeren« Plattformen
(wie etwa amd64, sparc64) eine Menge Treiber und Werkzeuge aus den
Diskettenabbildern haben entfernt werden müssen, was die Installation schwierig
machen kann.  Ältere Plattformen, wie z.&nbsp;B. i386 und sparc, sind jedoch
auch weiterhin sehr gut per Diskette installierbar.

<p>
<a name="MkCD-ROM"></a>
<h3>4.3.1 - Eine »Boot«-CD erzeugen</h3>

<p>
Um eine CD-ROM zu brennen, kannst du die <tt>cd50.iso</tt>- oder
<tt>install50.iso</tt>-Datei verwenden.
Es sei an dieser Stelle dem Leser selbst überlassen, die exakten
Details für die zur Verfügung stehenden Anwendungen herauszufinden.

<p>
In OpenBSD selbst kann eine CD von einem ISO-Abbild mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>
erzeugt werden:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cdio tao cd50.iso</b>
</pre></td></tr></table>

<p>
Die meisten CD-Brenner, die für Windows- und Macintosh-Systeme verkauft werden,
beinhalten eine Software, um ISO-Abbilder auf »blanke« Medien zu brennen.
Sollte deiner eine Ausnahme sein, gibt es verschiedene kostenlose Programme,
die diese Aufgabe für dich übernehmen können.

<p>
Andere Unix-ähnliche Systeme benutzen Applikationen wie
<a href="http://www.cdrkit.org/">cdrkit</a>.

<p>
<a name="MkFlop"></a>
<a name="UnixFlop"></a>
<h3>4.3.2 - Disketten unter Unix erzeugen</h3>

<p>
Präzise Details und Gerätenamen differieren von Unix-Variante zu
Unix-Variante; benutze, was immer für dein System zutrifft.

<p>
Um eine formatierte Diskette zu erzeugen, benutze das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdformat&amp;sektion=1&amp;arch=i386">fdformat(1)</a>-Kommando,
das sowohl formatiert, als auch auf schlechte Sektoren untersucht.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>fdformat /dev/rfd0c</b>
  Format 1440K floppy `/dev/rfd0c'? (y/n): y
  Processing VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV done.
</pre></td></tr></table>

<p>
Ist deine Ausgabe wie im obigen Beispiel, dann ist die Diskette in Ordnung.
Wenn du andererseits nicht ALLE »V«s siehst, dann ist die Diskette
höchstwahrscheinlich fehlerhaft, und du solltest eine andere versuchen.

<p>
Um das Abbild auf das Laufwerk zu schreiben, benutze
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=0">dd(1)</a>.
Ein Beispiel für <tt>dd(1)</tt>:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>dd if=floppy50.fs of=/dev/rfd0c bs=32k</b>
</pre></td></tr></table>

<p>
Ist das Abbild geschrieben, überprüfe mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cmp&amp;sektion=1">cmp(1)</a>-Kommando,
ob das kopierte Abbild mit dem Original identisch ist.  Wenn die Diskette mit
dem Abbild identisch ist, so wirst du keine Ausgabe erhalten, sondern einfach
nur den nächsten Prompt sehen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cmp /dev/rfd0c floppy50.fs</b>
</pre></td></tr></table>

<p>
<a name="DosFlop"></a>
<h3>4.3.3 - Disketten unter Windows erzeugen</h3>

<p>
Um eine Diskette in Windows vorzubereiten, benutze die eingebauten
Formatierungs-Werkzeuge, um die Diskette zu formatieren, und verifiziere,
dass die Diskette keine schlechten Sektoren hat.

<p>
Um das Installationsabbild auf die vorbereitete Diskette zu schreiben, kannst
du <tt>ntrw.exe</tt> benutzen, das in dem
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/5.0/tools/">tools</a>-Verzeichnis
jedes OpenBSD FTP-Spiegelservers zur Verfügung steht.

<p>
Ein Beispiel für <i>ntrw</i>:
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\&gt; <strong>ntrw floppy50.fs a:</strong>
  3.5", 1.44MB, 512 bytes/sector
  bufsize is 9216
  1474560 bytes written
</pre></td></tr></table>

<p>
<a name="Boot"></a>
<h2>4.4 - Starten eines OpenBSD-Installationsmediums</h2>

<h3>i386/amd64 starten</h3>

Ein Installationsabbild auf den i386 und amd64 PC-Architekturen zu starten
ist nichts Neues für die meisten Leute.
Dein System muss instruiert werden, von welchem Medium es zu starten hat,
was normalerweise durch eine BIOS-Option geschieht.
Wenn du von CD starten willst, so muss das System-BIOS dazu imstande sein,
und so konfiguriert werden, dass es von CD startet.
Einige ältere Systeme besitzen diese Option nicht, sodass eine Diskette benutzt
werden muss, um das Installationsabbild zu starten.
Dies ist jedoch kein Grund, beunruhigt zu sein; selbst wenn du von Diskette
startest, kannst du immer noch von der CD installieren, wenn das CD-Laufwerk
von OpenBSD unterstützt wird (d.&nbsp;h. praktisch alle IDE-Laufwerke).

<p>
Du kannst ebenfalls installieren, indem du <a href="#bsd.rd">bsd.rd</a>
von einer existierenden OpenBSD-Partition, oder, unter Verwendung des
<a href="faq6.html#PXE">PXE-»Bootprozesses«</a>, über das Netzwerk startest.

<h3>sparc/sparc64 starten</h3>

<b>HINWEIS:</b>
Auf der <a href="../../de/sparc64.html">sparc64</a>-Plattform können nur
die SBus-Maschinen (Ultra 1, Ultra 2) von einer Diskette gestartet werden.

<p>
Das System muss sich an einem Monitor-ROM-Prompt befinden, der typischerweise
so aussieht: »<tt>ok </tt>«.  Benutzt du eine Sun-Tastatur, drücke and halte
»STOP«, während du »A« drückst.  Wenn du eine serielle Konsole benutzt, sollte
dich ein »BREAK« zum Monitor-Prompt zurück bringen.

<p>
Benutze das folgende Kommando, um von Diskette zu starten:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot floppy</b>
</pre></td></tr></table>

<p>
Normalerweise kannst du vom CDROM-Laufwerk eines Sun-Systems vom »Boot«-Prompt
aus starten, indem du »<tt>boot cdrom</tt>« eingibst:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot cdrom</b>
</pre></td></tr></table>

<p>
<a name="Install"></a>
<h2>4.5 - Eine einfache Installation durchführen</h2>

OpenBSDs neuer Installationsprozess ist so konzipiert, das er OpenBSD mit sehr
wenig Benutzer-Interaktion zu einer schon sehr benutzbaren Umgebung installiert
und konfiguriert.  Tatsächlich genügt es oft, einfach nur einige Male
<i>ENTER</i> zu drücken, um eine sehr gute OpenBSD-Installation zu erhalten,
sodass du deine Hand eigentlich nur zur Eingabe des »root«-Passworts auf andere
Regionen der Tastatur bewegen musst.

<p>
Der Installierer wird ein Partitionsschema basierend auf der Größe deiner
Festplatte erstellen.  Obwohl dies KEINE perfekte Einteilung für alle ist und
sein kann, bietet es doch einen guten Ansatzpunkt und eine gute grundlegende
Strategie, um herauszufinden, was du benötigst.

<p>
Wir starten mit einer sehr einfachen Installation, mit kurzen Beschreibungen
der gezeigten Optionen, und benutzen die Magie von Hypertext-Verweisen, um es
dir zu ermöglichen, mehr über die Themen zu lesen, die dich interessieren, und
deine Möglichkeiten herauszufinden.

<p>
Plattform-spezifische Anmerkungen zur Installation finden sich auf den
Installations-CDs und FTP-Servern, in den Dateien
<tt>INSTALL.<i>&lt;plat&gt;</i></tt>, wobei <i>&lt;plat&gt;</i> durch deine
<a href="../../de/plat.html">Plattform</a> ersetzt werden muss, z.&nbsp;B.
<tt>i386</tt>.

<p>
<a name="InstStart"></a>
<h3>4.5.1 - Mit der Installation beginnen</h3>
<!-- XXXrelease -->
Was auch immer für eine Startmethode gewählt wurde - nun ist es an der Zeit,
sie zu benutzen. Während des Startens werden der Kernel und alle für die
OpenBSD-Installation nötigen Programme in den Hauptspeicher geladen.  Es wird
daher das »Boot«-Medium, ist der Installationskernel erst einmal geladen, nicht
länger benötigt, da sich alle Dateien im RAM-Laufwerk befinden.  Deshalb kann
die CD oder Diskette, von der gestartet wurde, an diesem Punkt aus ihrem
Laufwerk entfernt werden, vorausgesetzt, sie wird nicht mehr als Quelle für zu
installierende Dateisets gebraucht.

<p>
Der OpenBSD-Installationsprozess kann an praktisch jeder Stelle durch das
Drücken von STRG-C abgebrochen-, und durch den am Shell-Prompt einzugebenden
Befehl <tt>install</tt> ohne Neustart von vorne begonnen werden.  Außerdem ist
es während eines Großteils der Installation möglich, durch die Eingabe von »!«
einen Shell-Prompt zu bekommen; ein Beenden dieses Shell-Prozesses führt
automatisch zurück zur Installation.

<p>
Bei einem erfolgreichen Startvorgang wirst du eine Menge Textmeldungen
vorbeiziehen sehen.  Dieser Text (auf vielen Plattformen in weißer Schrift auf
blauem Hintergrund) ist die sogenannte
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg</a>«,
in der der Kernel über gefundene Geräte, und wie diese Geräte mit anderen
Geräten verknüpft sind, Auskunft gibt.  Eine Kopie dieser Meldungen wird in der
Datei <tt>/var/run/dmesg.boot</tt> gespeichert.

<p>
Dann wirst du Folgendes sehen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ...
  root on rd0a swap on rd0b dump on rd0b
  erase ^?, werase ^W, kill ^U, intr ^C, status ^T

  Welcome to the OpenBSD/i386 5.0 installation program.
  (I)nstall, (U)pgrade or (S)hell? <b>i</b>
</pre></td></tr></table>

<p>
Und damit erreichen wir auch schon die erste Frage.
Du bekommst drei Möglichkeiten angeboten:

<ul>
<li><b>Install</b>: installiert OpenBSD auf dem System und überschreibt dabei
alles, was vielleicht vorher dort war.  Es ist anzumerken, das es möglich ist,
einige Partitionen während dieses Prozesses unberührt zu lassen, z.&nbsp;B.
<tt>/home</tt>, aber abgesehen davon sollte davon ausgegangen werden, das alles
überschrieben wird.

<li><b>Upgrade</b>: installiert neue
<a href="#FilesNeeded">Installations-Dateisets</a>
auf dieser Maschine, aber überschreibt keine Konfigurations-Informationen,
Benutzerdaten, oder zusätzlich installierte Programme.  Keinerlei Formatierung
von Laufwerken wird vorgenommen, noch werden die <tt>/etc</tt> oder
<tt>/var</tt> Verzeichnisse überschrieben.  Einige wichtige Informationen:

<ul>
<li>Es wird keine Möglichkeit angeboten, <tt>etc50.tgz</tt> zu installieren.
Nach der Installation müssen daher die Änderungen
<a href="../upgrade50.html#etcUpdates">von Hand in das System eingebunden werden</a>,
die <tt>etc50.tgz</tt> beinhaltet, bevor das System voll funktionsfähig ist.
Dies ist ein sehr wichtiger Schritt, der getan werden muss, da sonst einige
Schlüsseldienste (wie beispielsweise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4">pf(4)</a>),
möglicherweise nicht starten werden.

<li>Der »Upgrade«-Prozess ist nicht dafür konzipiert, ganze »Releases« zu
überspringen!  Obwohl das meist funktioniert, wird es in keinem Fall
unterstützt.  Für OpenBSD 5.0 gilt, das das »Upgrade« von 4.9 auf 5.0 das
einzige unterstützte »Upgrade« ist.  Soll von einem älteren »Release« aus
aktualisiert werden, so aktualisiere erst auf die dazwischen liegenden
Versionen; oder aber, sollte dein System sehr alt sein, ziehe eine vollständige
Neuinstallation in Erwägung.
</ul>

<!-- XXXversion -->
Weitere Informationen über »Upgrades« zwischen den einzelnen »Releases« können
in der <a href="../upgrade50.html">OpenBSD »Upgrade«-Anleitung für 5.0</a>
gefunden werden.

<li><b>Shell</b>: Manchmal ist es notwendig, Teile des Systems zu reparieren
oder Wartungsarbeiten für ein System durchzuführen, das einen normalen Kernel
nicht starten kann (oder soll).  Diese Option erlaubt die Durchführung der
Wartungsarbeiten.  Dazu finden sich einige wichtige Werkzeuge auf dem
Start-Medium.
</ul>

Wir nehmen im Folgenden an, dass du »(I)nstall« auswählst.

<p>
<a name="InstQuestions"></a>
<h3>4.5.2 - Die Fragen der Installation</h3>

Nun beginnen die Fragen, die definieren, wie das System konfiguriert wird.
Du wirst bemerken, das in den meisten Fällen erst die Fragen gestellt werden,
woraufhin dann im Anschluss die Installation stattfindet.
Auf diese Weise kann bei einem langsamen Computer oder einer langsamen
Internet-Anbindung zuerst eine Beantwortung der Fragen stattfinden, dann
weggegangen- und später zurückgekommen werden, und alles was noch zu tun
bleibt, um die Installation abzuschließen, ist ein Neustart.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  At any prompt except password prompts you can escape to a shell by
  typing '!'. Default answers are shown in []'s and are selected by
  pressing RETURN.  You can exit this program at any time by pressing
  Control-C, but this can leave your system in an inconsistent state.

  Choose your keyboard layout ('?' or 'L' for list) [default] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
In den meisten Fällen wird die vorgewählte Tastaturbelegung (oder der
Terminal-Typ, sollte die Installation über eine serielle Konsole erfolgen) das
Richtige sein; es sollte jedoch nicht einfach der Standard genommen werden,
antworte angemessen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  System hostname? (short form, e.g. 'foo') <i><b>puffy</b></i>
</pre></td></tr></table>

<p>
Dieser Wert wird, gemeinsam mit dem DNS-Domänennamen (der
<a href="#MoreNetwork">weiter unten</a> definiert wird), in der Datei
<tt>/etc/myname</tt> gespeichert, welche während eines normalen Startvorgangs
dazu benutzt wird, den Hostnamen des Systems zu setzen.  Wird der Domänenname
des Systems nicht gesetzt, so wird stattdessen der Standardwert »my.domain«
benutzt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available network interfaces are: fxp0 vlan0.
  Which one do you wish to configure? (or 'done') [fxp0] <i><b>Enter</b></i>
</pre></td></tr></table>

<p>
<tt>vlan0</tt> ist die virtuelle VLAN-Schnittstelle.  Für unsere Zwecke hier
haben wir diese Option ignoriert und uns stattdessen an die physisch
vorhandenen Schnittstellen gehalten.  Wenn der Rechner mehrere physikalische
Schnittstellen besitzt, so sollten sie hier aufgelistet sein.  Wie zu sehen
ist, werden sie über ihren Gerätetreiber identifiziert, und tauchen nicht als
generische Ethernet-Geräte auf.  In unserem Fall meint »<tt>fxp0</tt>« also das
erste Gerät, das den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>-Treiber
benutzt; <tt>fxp1</tt> wäre das zweite Gerät, etc...  Mehr zum Thema
Gerätenamen findet sich in <a href="faq6.html#Setup.if">FAQ 6</a>.

<p>
Nachdem das zu konfigurierende Gerät ausgewählt wurde, kann es nun konfiguriert
werden.  In vielen Fällen wird man es über DHCP automatisch konfigurieren
wollen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IPv4 address for fxp0? (or 'dhcp' or 'none') [dhcp] <b><i>Enter</i></b>
  Issuing hostname-associated DHCP request for fxp0.
  DHCPDISCOVER on fxp0 to 255.255.255.255 port 67 interval 1
  DHCPOFFER from 192.168.1.250 (08:00:20:94:0b:c8)
  DHCPREQUEST on fxp0 to 255.255.255.255 port 67
  DHCPACK from 192.168.1.250 (08:00:20:94:0b:c8)
  bound to 192.168.1.199 -- renewal in 43200 seconds.
</pre></td></tr></table>

<p>
DHCP wird die IP-Adresse, die Subnetz-Maske, den Standard-Zugang,
den DNS-Domänennamen und die DNS-Server automatisch konfigurieren.
Wenn DHCP nicht benutzt wird, so müssen alle genannten Dinge
von Hand eingegeben werden; siehe auch die detailliertere Diskussion
<a href="#MoreNetwork">weiter unten</a>.
<a name="backMoreNetwork"></a>

<p>
Sollte es nötig sein IPv6 zu konfigurieren, oder sollten andere Geräte zu
konfigurieren sein (oder dir nicht gefallen, wie du das vorherige konfiguriert
hast), so kannst du dies nun tun, aber in unserem Fall sind wir fertig:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IPv6 address for fxp0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
  Available network interfaces are: fxp0 vlan0.
  Which one do you wish to configure? (or 'done') [done] <b><i>Enter</i></b>
  Using DNS domainname example.org
  Using DNS nameservers at 192.168.1.252
  Do you want to do any manual network configuration? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Wenn »yes« auf die Frage nach der »manual network configuration« geantwortet
wird, so wird eine Shell gestartet, an deren Prompt alles das manuell
konfiguriert werden kann, das einer Konfiguration bedarf; ein Beenden dieser
Shell mit »exit« führt automatisch zurück zum Installationsprogramm.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Password for root account? (will not echo) <i>PaSsWoRd</i>
  Password for root account? (again) <i>PaSsWoRd</i>
</pre></td></tr></table>

<p>
Benutze ein sicheres Passwort für das root-Benutzerkonto, und bedenke: im
Internet TRACHTEN SIE danach, in deinen Computer zu gelangen, und sie werden
eine ganze Menge häufig benutzter Passwörter ausprobieren, von denen man denkt,
dass sie wirklich clever sind.

<p>
Später wird es noch die Möglichkeit geben, ein Administrations-Benutzerkonto zu
erzeugen, und den Remote-Zugang (SSH) für das root-Benutzerkonto unmöglich zu
machen, aber nichtsdestotrotz ist ein gutes Passwort für das root-Benutzerkonto
sehr wichtig.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start sshd(8) by default? [yes] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Üblicherweise will man den sshd(8) laufen haben.  Sollte dein Anwendungsgebiet
jedoch keinen Bedarf für ihn haben, so ergibt sich ein kleiner theoretischer
Sicherheitsgewinn dadurch, ihn nicht zu benutzen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start ntpd(8) by default? [no] <b>y</b>
  NTP server? (hostname or 'default') [default] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Hier wird die Möglichkeit geboten, den
<a href="faq6.html#OpenNTPD">OpenNTPD</a>,
OpenBSDs NTP-Implementierung, laufen zu lassen.  OpenNTPD braucht wenig
Ressourcen und ist ein problemloser Weg, die eingebaute Uhr des Rechners
akkurat zu synchronisieren.  Die Standardkonfiguration nutzt
<a href="http://www.pool.ntp.org">pool.ntp.org</a>,
und bindet damit eine große Anzahl frei zugänglicher, über die ganze Welt
versteuter Zeit-Server ein.

<p>
Ein Grund warum man den ntpd(8) NICHT benutzen will, kann sein, dass man ein
»<a href="#Multibooting">Multiboot</a>«-System benutzt, auf dem meistens ein
anderes System läuft, welches seine Uhr nicht mit einer auf GMT-Zeit
eingestellten Hardware-Uhr abstimmen kann, da man schwerlich möchte, das
OpenBSD die Uhr des anderen Betriebssystems verstellt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you expect to run the X Window System? [yes] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Nicht alle Plattformen werden nach X fragen, und die, die es tun, verlangen das
Setzen eines sysctl, um X benutzbar zu machen.  Antwortet man hier mit »y«, so
wird die Datei <tt>/etc/sysctl.conf</tt> derart modifiziert, das sich, abhängig
von der Plattform, entweder <tt>machdep.allowaperture=1</tt> oder
<tt>machdep.allowaperture=2</tt> darin findet.

<p>
Wenn du nicht vorhast, X auf deinem System laufen zu lassen, oder dir darüber
nicht sicher bist, so antworte einfach »N«, denn es ist später durch einfaches
Editieren von <tt>/etc/sysctl.conf</tt>, gefolgt von einem Neustart, möglich,
das Verhalten entsprechend zu ändern.  Es liegt ein potentieller
Sicherheitsvorteil darin, den »aperture«-Treiber
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xf86&amp;sektion=4">xf86(4)</a>
nicht zu benutzen, da die Maschinerie einer Grafikkarte potentiell dazu benutzt
werden kann, Speicherbereiche ohne Kontrolle des Prozessors zu verändern.
Es ist anzumerken, das nicht-grafische Programme, die X-Bibliotheken und
-Werkzeuge benutzen, das Setzen dieses sysctl's NICHT benötigen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want the X Window System to be started by xdm(1)? [no] <b>y</b>
</pre></td></tr></table>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdm&amp;sektion=1">xdm(1)</a>
startet die X-Umgebung während des Systemstarts.  Wir empfehlen dies nur dann
während der Installation zu setzen, wenn man sich gewiss ist, das X auf dem
System direkt und ohne Anpassungen laufen wird. Anderenfalls sollte man
<a href="faq11.html">X konfigurieren</a>, bevor man xdm(1) benutzt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Change the default console to com0? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Solltest du vorhaben, eine serielle Konsole konfigurieren, anstatt den Standard
deines Systems (üblicherweise Tastatur und Monitor) zu nutzen, dies ist deine
Chance.  Änderst du die Vorgabe auf »y«, so wirst du nach der zu nutzenden
Bit-Rate gefragt werden.  Für serielle Konsolen gilt, das schneller nicht immer
besser ist; es wird daher sehr empfohlen, den Standard der Plattform zu
benutzen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Setup a user? (enter a lower-case loginname, or 'no') [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Es wird dir die Möglichkeit geboten, einen Benutzer für die Systemwartung zu
erzeugen, der NICHT root ist.  Dieser Benutzer wird Mitglied der »wheel«-Gruppe
und kann daher sowohl
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su(1)</a>
benutzen, als auch als Empfänger für an root adressierte E-Mail eingesetzt
werden.  Du wirst nach einem Passwort gefragt.

<p>
Wenn du diesen Benutzer erzeugen willst, so gib den gewünschten Namen des
Nutzers ein, nicht »y« oder »yes«.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  What timezone are you in? ('?' for list) [Canada/Mountain] <b>US/Michigan</b>
</pre></td></tr></table>

<p>
OpenBSD erwartet, das die »Real-Time-Clock« (RTC) des Rechners auf GMT Zeit
eingestellt ist, aber du musst außerdem die Zeitzone angeben, in der du dich
befindest.  Es kann mehrere gültige Antworten für deinen physischen
Aufenthaltsort geben.  Die Eingabe von »?« am gezeigten Prompt sollte dir
Assistenz zum Auffinden des richtigen Zeitzonennamens geben.

<p>
Sehr oft wird das Installationsprogramm einfach den korrekten Namen für deine
Zeitzone erraten, sodass du nur »Enter« zu drücken brauchst.

<p>
Mehr über das Setzen der Zeitzone <a href="#MoreTimeZone">findet sich hier</a>.
<a name="backMoreTimeZone"></a>

<a name="InstDisks"></a>
<h3>4.5.3 - Laufwerke einrichten</h3>

<i><b>Wichtiger Hinweis:</b>
Benutzer mit einer großen Festplatte (größer als das, was normal war, als der
Rechner hergestellt wurde) sollten sich unbedingt
<a href="faq14.html#LargeDrive">diese Sektion</a> anschauen, bevor sie
weiterlesen.</i>

<p>
Die passende Unterteilung für das Laufwerk zu finden ist vielleicht der
schwierigste Teil einer OpenBSD-Installation.

<p>
Die Einrichtung von Laufwerken unter OpenBSD variiert ein wenig zwischen den
Plattformen.
Für <a href="../../de/i386.html">i386</a>,
<a href="../../de/amd64.html">amd64</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/zaurus.html">zaurus</a>
und <a href="../../de/armish.html">armish</a> geschieht es in zwei Ebenen.
Zuerst wird der Abschnitt (»slice«) der Festplatte, der OpenBSD beherbergen
soll, mit fdisk(8) festgelegt, woraufhin dann dieser »slice« mit Hilfe von
disklabel(8) in OpenBSD-Partitionen aufgeteilt wird.

<p>
Einige Benutzer mögen ein wenig verwundert oder gar ein bisschen verwirrt über
die verwendete Terminologie sein.  Es sieht aus, als ob wir das Wort
»Partition« auf zwei verschiedene Art und Weisen benutzen.  Diese Beobachtung
ist korrekt.  Es gibt zwei Schichten der Partitionierung auf den oben genannten
Plattformen; die erste, die man als die Betriebssystem-Partitionierung
bezeichnen könnte, beschreibt, wie verschiedene Betriebssysteme auf einem
Computer den ihnen zugewiesenen Bereich der Festplatte als für sich reserviert
ausweisen, während die zweite beschreibt, wie die OpenBSD-Partition in einzelne
Dateisysteme unterteilt ist.  Die erstgenannte Schicht ist als
Festplattenpartition für DOS, Windows und jedes andere Betriebssystem sichtbar,
das dieses Festplatten-Partitionierungs-System benutzt, währenddessen die
zweite Schicht nur für OpenBSD und andere Betriebssysteme, die direkt ein
OpenBSD-Dateisystem lesen können, sichtbar ist.

<p>
Das neue Installationsprogramm von OpenBSD versucht, die Einrichtung von
Laufwerken einfacher zu machen, indem es eine akzeptable Standardeinteilung für
die »durchschnittliche« Nutzung anbietet.  Sicher werden viele Leute diesen
Standard für ihre eigenen Bedürfnisse anpassen-, oder ihre komplett eigene
Laufwerksbelegung definieren wollen, aber neue Benutzer sollten vielleicht mit
der Standardkonfiguration starten, bis sie wissen, was sie anders machen
müssen.  Zu bemerken ist, das die Standardkonfiguration abhängig von der Größe
des Dateisystems ist.

<p>
Für's erste nehmen wir die Voreinstellung für unsere 40&nbsp;G Platte.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available disks are: wd0.
  Which one is the root disk? (or 'done') [wd0] <i><b>Enter</b></i>
  Use DUIDs rather than device names in fstab? [yes] <i><b>Enter</b></i>
  Disk: wd0       geometry: 5221/255/63 [40960 Megabytes]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 06      0   1   1 -    521 254  63 [          63:     8385867 ] DOS > 32MB
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Use (W)hole disk or (E)dit the MBR? [whole] <i><b>Enter</b></i>
  Setting OpenBSD MBR partition to whole wd0...done.
</pre></td></tr></table>
Es ist zu erwähnen, das diese Festplatte eine bereits existierende Partition
besitzt -- <i>das Auswählen von »whole disk« würde sie entfernen!</i>

<p>
Das Auswählen von »whole disk«, und damit die Zuweisung des gesamten Laufwerks
für OpenBSD, initiiert eine Reihe wichtiger Dinge:
<ul>
<li>alle bereits existierenden Partitionen des Laufwerks werden gelöscht
<li>ein MBR (»Master-Boot-Record«) und eine Laufwerks-Signatur werden erzeugt,
    sodass von dem Laufwerk gestartet werden kann (»boot«)
<li>eine OpenBSD-Partition wird erzeugt, die das komplette Laufwerk einnimmt
<li>diese Partition wird »aktiv« markiert
</ul>

Es gibt eine Reihe von Gründen, warum dies nicht gewünscht sein könnte,
einschließlich:
<ul>
<li>Du möchtest die Partitionen anderer Betriebssysteme erhalten
<li>Du möchtest »Setup«, »Suspend to Disk«, oder andere System-Partitionen
    behalten
<li>Du möchtest ein »<a href="#Multibooting">Multiboot</a>«-System erzeugen
</ul>

Es ist äußerst wichtig, das ein neues Laufwerk (oder eines, von dem noch nie
gestartet wurde) einen gültigen MBR, eine gültige Signatur, eine
OpenBSD-Partition, sowie eine als »aktiv« markierte Partition besitzt.  Durch
anwählen der »whole disk«-Option werden diese Schritte vom
Installationsprogramm automatisch durchgeführt; anderenfalls muss
sichergestellt sein, dass sie manuell durchgeführt werden.

<p>
Mehr Information über die fdisk-Partitionierung deines Laufwerks findet sich
<a href="#Morefdisk">weiter unten</a>.
<a name="BackMorefdisk"></a>

<p>
Jetzt werden wir unsere OpenBSD fdisk-Partition in OpenBSD
Laufwerks-Partitionen mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
unterteilen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Setting OpenBSD MBR partition to whole wd0...done.
  The auto-allocated layout for wd0 is:
  #                size           offset  fstype [fsize bsize  cpg]
    a:          1024.0M               64  4.2BSD   2048 16384    1 # /
    b:           199.0M          2097216    swap                   
    c:         40960.0M                0  unused                   
    d:          2822.9M          2504768  4.2BSD   2048 16384    1 # /tmp
    e:          4295.0M          8286112  4.2BSD   2048 16384    1 # /var
    f:          2048.0M         17082240  4.2BSD   2048 16384    1 # /usr
    g:          1024.0M         21276544  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          5426.7M         23373696  4.2BSD   2048 16384    1 # /usr/local
    i:          1699.7M         34487520  4.2BSD   2048 16384    1 # /usr/src
    j:          2048.0M         37968576  4.2BSD   2048 16384    1 # /usr/obj
    k:         20367.4M         42162880  4.2BSD   2048 16384    1 # /home
  Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout? [a] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Das Installationsprogramm hat uns seinen Vorschlag einer »Automatischen
Einteilung« für die OpenBSD-Partitionen auf dem Laufwerk präsentiert, was wir
in dieser Form akzeptieren werden.

<p>
Sollte die vorgeschlagene Einteilung für deine Zwecke nicht angemessen sein,
ist es selbstverständlich möglich, den Vorschlag zu bearbeiten oder gar eine
komplett eigene Einteilung zu kreieren; mehr Details über die
disklabel-Partitionierung findet sich
<a href="#Moredisklabel">weiter unten</a>.
<a name="BackMoredisklabel"></a>

<p>
<b>ANMERKUNG für Wieder-Installierer:</b>
Das neue Installationsprogramm löscht nicht das alte disklabel,
wenn »(C)ustom Layout« ausgewählt wurde; stattdessen muss jeder Einhängepunkt
mit Hilfe der »m«-Option von disklabel(8) neu spezifiziert werden.

<p>
Nun erzeugt das Installationsprogramm die Partitionen, kreiert darauf
Dateisysteme mit Hilfe des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>-Programms,
und hängt sie danach für die Installation ein (es »mount«et sie):

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  /dev/rwd0a: 1024.0MB in 2097152 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0k: 20367.4MB in 41712448 sectors of 512 bytes
  101 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0d: 2822.9MB in 5781344 sectors of 512 bytes
  14 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0f: 2048.0MB in 4194304 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0g: 1024.0MB in 2097152 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0h: 5426.7MB in 11113824 sectors of 512 bytes
  27 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0j: 2048.0MB in 4194304 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0i: 1699.7MB in 3481056 sectors of 512 bytes
  9 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0e: 4295.0MB in 8796128 sectors of 512 bytes
  22 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local)
  /dev/wd0k on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0d on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0f on /mnt/usr type ffs (rw, asynchronous, local, nodev)
  /dev/wd0g on /mnt/usr/X11R6 type ffs (rw, asynchronous, local, nodev)
  /dev/wd0h on /mnt/usr/local type ffs (rw, asynchronous, local, nodev)
  /dev/wd0j on /mnt/usr/obj type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0i on /mnt/usr/src type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0e on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid)</pre>
</td></tr></table>

<p>
Du wirst bemerkt haben, dass es so aussieht, als ob wir die Partition <i>c</i>
ignoriert hätten.  Diese Partition identifiziert das gesamte Laufwerk; versuche
nicht, sie zu verändern.

<p>
<a name="InstMedia"></a>
<h3>4.5.4 - Auswahl des Installationsmediums und der Dateisets</h3>

Als Nächstes steht die Auswahl des Installationsmediums an.
In diesem Fall installieren wir von einem FTP Server.
<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Location of sets? (cd disk ftp http or 'done') [cd] <b>ftp</b>
  HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none') [none] <b><i>Enter</i></b>
  Server? (hostname, list#, 'done' or '?') [mirror.example.org] <b>obsd.cec.mtu.edu</b>
</pre></td></tr></table>
Solltest du dich nicht an die Adresse deines favorisierten (oder jedweden)
Spiegelservers erinnern können, wird das Installationsprogramm meistens in der
Lage sein, dir einen funktionierenden Spiegelserver vorzuschlagen.
Anderenfalls drücke »?«, um dir eine Liste von Spiegelservern aufzeigen zu
lassen, und wähle die Nummer dessen aus, der dir am meisten zusagt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Server directory? [pub/OpenBSD/5.0/i386] <b><i>Enter</i></b>
  Login? [anonymous] <b><i>Enter</i></b>
</pre></td></tr></table>

Die öffentlichen FTP-Spiegelserver unterstützen natürlich alle das anonyme
Herunterladen von Dateien, aber da du eine lokale Maschine haben könntest, die
nach Login und Passwort verlangt, besteht die Möglichkeit zur Eingabe dieser
Werte.

<p>
Nun kann die Liste der <a href="#FilesNeeded">Dateisets</a> angepasst werden.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Select sets by entering a set name, a file name pattern or 'all'. De-select
  sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
  sets are labelled '[X]'.
      [X] bsd           [X] etc50.tgz     [X] xbase50.tgz   [X] xserv50.tgz
      [X] bsd.rd        [X] comp50.tgz    [X] xetc50.tgz
      [ ] bsd.mp        [X] man50.tgz     [X] xshare50.tgz
      [X] base50.tgz    [X] game50.tgz    [X] xfont50.tgz
  Set name(s)? (or 'abort' or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table>


<p>
Als absolutes Minimum wird ein Kernel (<tt>bsd</tt>) benötigt, sowie die
Dateisets base50.tgz und etc50.tgz.  Solange du nicht genau weißt, was du tust,
solltest du vielleicht einfach bei der Standard-Selektion bleiben.  Dateisets
können durch das Voranstellen der »+« und »-« Zeichen an- und abgewählt werden;
aber auch die Benutzung von Wildcards ist möglich:
<ul>
<li><tt><b>-comp50.tgz</b></tt> entfernt <tt>comp50.tgz</tt>
<li><tt><b>+bsd.mp</b></tt> fügt bsd.mp hinzu
<li><tt><b>-x*</b></tt> entfernt alle X Komponenten
</ul>

Wir entscheiden uns auch hier für die Voreinstellung.  Diese Maschine ist ein
Einprozessorsystem, sodass bsd.mp nicht installiert wird, alles andere jedoch
schon.  Wenn die Maschine später zu einem Mehrfachprozessorsystem ausgebaut
werden könnte, so kann es sein, dass du zusätzlich bsd.mp installieren willst.

<p>
Und nun ... starten wir unsere Installation!
Dies ist der Punkt, an dem du als Besitzer eines langsamen Computers oder einer
langsamen Internet-Verbindung vielleicht gehen und später wiederkommen
möchtest; mit einem schnellen Computer und lokal vorhandenen Dateisets mag
diese Prozedur jedoch nur einige Minuten oder auch noch weniger dauern!

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  bsd          100% |*************************************|  8764 KB    00:05
  bsd.rd       100% |*************************************|  6268 KB    00:03
  base50.tgz   100% |*************************************| 53928 KB    00:26
  etc50.tgz    100% |*************************************|   513 KB    00:00
  comp50.tgz   100% |*************************************| 57224 KB    00:28
  man50.tgz    100% |*************************************|  9482 KB    00:06
  game50.tgz   100% |*************************************|  2568 KB    00:02
  xbase50.tgz  100% |*************************************| 11331 KB    00:06
  xetc50.tgz   100% |*************************************| 71741       00:00
  xshare50.tgz 100% |*************************************|  3357 KB    00:04
  xfont50.tgz  100% |*************************************| 38868 KB    00:17
  xserv50.tgz  100% |*************************************| 31205 KB    00:15
  Location of sets? (cd disk ftp http or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Ja, es fragt uns erneut, aus welchen Quellen wir Dateisets beziehen wollen.
Dies geschieht, damit fehlende oder vergessene Dateisets, oder solche, deren
Installation fehlgeschlagen ist, erneut installiert werden können, und
außerdem, um die Installation von
<a href="#site">selbst angepassten Dateisets</a> zu ermöglichen.

<p>
Erneut wählen wir die Voreinstellung, wir habe alle benötigten Dateien
installiert.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Saving configuration files...done.
  Generating initial host.random file...done.
  Install non-free firmware files on first boot? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

Einige Systeme besitzen Geräte, die, um zu funktionieren, eine so genannte
»Firmware« benötigen, welche aber aus lizenzrechtlichen Gründen nicht Teil von
OpenBSD sein kann.  Wenn man hier die Option zur Installation dieser Dateien
anwählt, so wird das System, wenn es zum ersten Mal gestartet wird, versuchen,
sich mit dem Internet zu verbinden, und die verfügbaren unfreien
»Firmware«-Dateien herunterzuladen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Making all device nodes...done.

  CONGRATULATIONS! Your OpenBSD install has been successfully completed!
  To boot the new system, enter 'reboot' at the command prompt.
  When you login to your new system the first time, please read your mail
  using the 'mail' command.

  #
</pre></td></tr></table>

<p>
<a name="Inst1stBoot"></a>
<h3>4.5.5 - Der erste Start!</h3>
OpenBSD ist jetzt auf deinem System installiert und bereit für den ersten
Start, aber vorher ...

<p>
<h4>Vor dem Neustart</h4>
An diesem Punkt ist dein System installiert und bereit, neu gestartet und
für den Dienst konfiguriert zu werden.  Bevor dies getan wird, wäre es jedoch ratsam,
auf der <a href="../../de/errata.html">Errataseite</a> nachzuschauen, ob nicht wie auch immer
geartete Fehler bekannt sind, die dein System direkt betreffen könnten.

<h4>Nach dem Neustart</h4>

Während des ersten Starts werden Schlüssel für
<a href="http://www.openssh.com">SSH</a>
generiert.  Auf modernen Computern benötigt dieser Prozess nur wenige Sekunden,
und es mag nicht einmal auffallen, das er abläuft.  Auf älteren Systemen kann
er jedoch viele Minuten benötigen, und potentiell ist eine Stunde und mehr auf
wirklich langsamen Systemen nicht unmöglich.

<p>
Eines der ersten Dinge, die nach der Installation des Systems gelesen werden
sollten, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=afterboot&amp;sektion=8">afterboot(8)</a>.

<p>
Du könntest auch die folgenden Links nützlich finden:
<ul>
<li><a href="faq10.html#AddDelUser">Benutzerkonten in OpenBSD erzeugen</a>
<li><a href="faq6.html#Setup">Erste Netzwerkkonfiguration</a>
<li><a href="faq2.html#ManPages">Handbuch-Seiten von populären/nützlichen Kommandos</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD Handbuch-Seiten im Web</a>
<li><a href="faq15.html">Das OpenBSD »Packages«- und »Ports«-System zur Installation von Software</a>
</ul>

<a name="InstFinish"></a>
<h3>4.5.6 - Eine letzte Sache...</h3>

Die OpenBSD-Entwickler bitten dich darum,
<a href="#SendDmesg">eine Kopie deiner »dmesg« einzuschicken</a>.
Dies wird von den Entwicklern wirklich sehr geschätzt, und, letztendlich, von
allen Benutzern.

<p>
<a name="More"></a>
<h2>4.6 - Details für eine komplexere Installation</h2>
Manchmal kann man einfach nicht die Standardvorgaben benutzen.
Hier sind ein paar mehr Details über Teile des Installationsprozesses.

<p>
<a name="MoreNetwork"></a>
<h3>4.6.1 - Einrichtung des Netzwerks</h3>

Ist kein DHCP Server verfügbar, so muss man seine Netzwerkadapter manuell
einrichten.  Hier ist ein Beispiel:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Which one do you wish to configure? (or 'done') [xl0] <b><i>Enter</i></b>
  IPv4 address for xl0? (or 'dhcp' or 'none') [dhcp] <b>192.168.1.37</b>
  Netmask? [255.255.255.0] 255.255.254.0
  IPv6 address for xl0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Nach dieser Gruppe von Fragen bekommt man die Möglichkeit, die anderen
Netzwerkadapter der Maschine zu konfigurieren.  Spezifizierst du hier einen
anderen Netzwerkadapter, so wiederholen sich obige Fragen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available network interfaces are: xl0 vlan0.
  Which one do you wish to configure? (or 'done') [done]
</pre></td></tr></table>

<p>
Jetzt richten wir den Standard-Zugang und DNS-Server ein,
Dinge, die alle Netzwerkadapter betreffen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Default IPv4 route? (IPv4 address, 'dhcp' or 'none') <b>192.168.1.1</b>
  add net default: gateway 192.168.1.1
  DNS domain name? (e.g. 'bar.com') [my.domain] <b>example.org</b>
  DNS nameservers? (IP address list or 'none') [none] <b>192.168.1.250 192.168.1.251</b>
</pre></td></tr></table>

<p>
Es ist hier möglich mehrere, durch Leerzeichen getrennte DNS-Server anzugeben.

<p>
Manchmal wird man etwas darüber hinaus zu tun haben, zum Beispiel die
Einrichtung eines drahtlosen Zugangsschlüssels, oder aber die Festlegung von
Duplex- oder Geschwindigkeitsangaben (was man nicht machen sollte, wenn es
nicht ABSOLUT NÖTIG ist, da das Anpassen der Switch-Konfiguration eine viel
bessere Idee ist!).  Es wird nun die Möglichkeit geboten, zu einer Shell zu
gelangen, wo man jedwede manuelle Konfiguration durchführen kann.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want to do any manual network configuration? [no] <b>y</b>
  Type 'exit' to return to install.
  # <b>ifconfig xl0 media</b>
  xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
          lladdr 00:08:74:2c:df:9c
          groups: egress
          media: Ethernet autoselect (100baseTX full-duplex)
          status: active
          supported media:
                  media 10baseT
                  media 10baseT mediaopt full-duplex
                  media 100baseTX
                  media 100baseTX mediaopt full-duplex
                  media autoselect
          inet 192.168.1.37 netmask 0xfffffe00 broadcast 192.168.1.255
  # <b>ifconfig xl0 media 100baseTX mediaopt full-duplex</b>
  # <b>ifconfig xl0</b>
  xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
          lladdr 00:08:74:2c:df:9c
          groups: egress
          media: Ethernet 100baseTX full-duplex
          status: active
          inet6 fe80::208:74ff:fe2c:df9c%xl0 prefixlen 64 scopeid 0x1
          inet 192.168.1.37 netmask 0xfffffe00 broadcast 192.168.1.255
  # <b>exit</b>
<i>...setup resumes...</i>
</pre></td></tr></table>

<p>
<a href="#backMoreNetwork">(zurück dorthin, wo wir vielleicht gewesen sind)</a>

<p>
<a name="MoreTimeZone"></a>
<h3>4.6.2 - Festlegung der Zeitzone</h3>
Zeit ist in Unix kein einfaches Ding (oder, um es anders zu sagen, Zeit in Unix
ist ein <i>wirklich</i> einfaches Ding, da menschliche Zeit ein politisch
manipuliertes Durcheinander ist).  Zeitzonendateien helfen dem System,
Unix-Zeit (die Anzahl von Sekunden, die seit dem 1.1.1970, Schlag Mitternacht
GMT [Greenwhich-Mean-Time], vergangen sind) in menschliche Zeit zu
konvertieren, und dabei Dinge wie Zeitzonen, Sommerzeiten (DST, »Daylight
Saving Time«), Sommerzeit-Regeländerungen etc. in Betracht zu ziehen.  Sie
beinhalten auch die Geschichte der Änderungen.

<p>
Mehrere Zeitzonendefinitionsdateien werden manchmal dieselbe <i>Jetztzeit</i>
angeben, aber vielleicht eine unterschiedliche Historie haben.  Zum Beispiel
besitzen EST5EDT und US/Michigan HEUTE dieselbe Zeit, aber im Jahre 1975 waren
die Regeln unterschiedlich, sodass Berechnungen mit Daten und Zeiten, die das
Jahr 1975 betreffen, sich Gedanken über die Unterschiede machen müssen.  Aus
diesen Gründen solltest du jene Zeitzonendatei benutzen, die die am meisten
spezifische und akkurateste für deine Region ist, und nicht nur eine, die im
Moment eine korrekte Zeit kreiert.

<p>
Das Installationsprogramm von OpenBSD bietet Hilfe zum Auffinden der passenden
Zeitzonendatei, solltest du dir nicht sicher sein.  Drücke einfach »<tt>?</tt>«
an jedem Prompt, und er wird dir Optionen anbieten.  Bietet dir die erste Ebene
an Antworten keine passende Datei, wähle einen Kontinent oder ein Land aus, und
schaue dir an, welche Optionen sich dort auftun:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  What timezone are you in? ('?' for list) [right/EST5EDT] <b>?</b>
  Africa/      Chile/       GB-Eire      Israel       NZ-CHAT      UCT
  America/     Cuba         GMT          Jamaica      Navajo       US/
  Antarctica/  EET          GMT+0        Japan        PRC          UTC
  Arctic/      EST          GMT-0        Kwajalein    PST8PDT      Universal
  Asia/        EST5EDT      GMT0         Libya        Pacific/     W-SU
  Atlantic/    Egypt        Greenwich    MET          Poland       WET
  Australia/   Eire         HST          MST          Portugal     Zulu
  Brazil/      Etc/         Hongkong     MST7MDT      ROC          posix/
  CET          Europe/      Iceland      Mexico/      ROK          posixrules
  CST6CDT      Factory      Indian/      Mideast/     Singapore    right/
  Canada/      GB           Iran         NZ           Turkey
  What timezone are you in? ('?' for list) [right/EST5EDT] <b>US</b>
  What sub-timezone of 'US' are you in? ('?' for list) ?
  Alaska          Central         Hawaii          Mountain        Samoa
  Aleutian        East-Indiana    Indiana-Starke  Pacific
  Arizona         Eastern         Michigan        Pacific-New
  What sub-timezone of 'US' are you in? ('?' for list) <b>Michigan</b>
</pre></td></tr></table>

<p>
Wir haben nun die Zeit auf »US/Michigan« festgelegt.  Dies erzeugt einen
symbolischen Link in <tt>/etc</tt>, der auf die ausgewählte »zoneinfo«-Datei in
<tt>/usr/share/zoneinfo</tt> zeigt, etwas wie:

<blockquote><pre>
  /etc/localtime -> /usr/share/zoneinfo/US/Michigan
</pre></blockquote>

Nun wende deine Aufmerksamkeit für einen Moment dem Verzeichnis
»<tt>right/</tt>« (im Sinne von »korrekt«) zu, es dupliziert die
Standard-»zoneinfo«-Auswahl, beinhaltet jedoch Anpassungen für Schaltsekunden.
Mehr dazu kann <a href="faq8.html#NTPerror">hier</a> gefunden werden.

<p>
<a href="#backMoreTimeZone">(zurück dorthin, wo wir vielleicht gewesen sind)</a>

<p>
<a name="Morefdisk"></a>
<h3>4.6.3 - Anpassung der fdisk(8)-Konfiguration</h3>

Bemerkung: nur einige OpenBSD-Plattformen benutzen überhaupt fdisk, und
normalerweise müssen sich nur Benutzer von
<a href="../../de/i386.html">i386</a> und
<a href="../../de/amd64.html">amd64</a> mit fdisk anfreunden.
Benutzer der meisten anderen, fdisk(8) benutzenden Plattformen müssen sich im
allgemeinen keinerlei Gedanken über »Multibooting« oder Setup- und
Diagnose-Partitionen machen.  Aus diesem Grunde beschränkt sich dieser
Abschnitt auf i386 und amd64.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8">fdisk(8)</a>
wird dazu benutzt, einen Teil der Festplatte für OpenBSD zu reservieren.
Es hilft, den Abschnitt des Laufwerks, der von OpenBSD benutzt wird, von denen
anderer Betriebssysteme oder Systemfunktionen abzugrenzen.

<p>
Sollte es eine Partition auf dem Laufwerk geben, die Bestand haben soll, oder
solltest du es wünschen, Speicher für eine weitere Partition zu reservieren,
dann wirst du NICHT »(W)hole disk« wählen wollen, sondern die Partitionstabelle
mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8">fdisk(8)</a>
zu editieren wünschen.  Mehr Informationen zum manuellen Aufruf von fdisk(8)
kann <a href="faq14.html#fdisk">hier</a> gefunden werden.

<b>Bevor du mit irgendeinem System arbeiten willst, dessen Daten du nicht
verlieren möchtest, stelle sicher, das eine gute Sicherungskopie vorhanden
ist.</b>
Es ist sehr einfach, im folgenden Schritt wichtige Daten zu vernichten, deshalb
stelle sicher, das du sie wiederherstellen kannst, sollte es nötig werden.

<p>
Wenn du OpenBSD zu einem bestehenden System hinzufügen willst, wirst du
vielleicht ein wenig freien Speicher auf deinem System erzeugen müssen, bevor
OpenBSD installiert werden kann.  Dies wird im Normalfall das Löschen-, oder
möglicherweise die Verkleinerung von bestehenden Partitionen beinhalten.  Das
Programm <a href="http://gparted.sourceforge.net/">gparted</a> wurde für
nützlich zur Verkleinerung von Partitionen vieler populärer Betriebssysteme
befunden, und macht es möglich, OpenBSD auf dem freigegebenen Speicher zu
installieren.

<p>
In diesem Beispiel gehen wir davon aus, das wir auf einer leeren 40&nbsp;G
Festplatte ein »Multiboot«-System erzeugen möchten, mit einer 5&nbsp;G großen,
für Windows reservierten Partition am Anfang der Festplatte, und für OpenBSD
den gesamten Rest reservieren.  Beachte das auf ein leeres Laufwerk ein
gültiger MBR-Startcode und eine Signatur geschrieben werden müssen, bevor von
ihm gestartet werden kann.

<p>
Für den Fall, das eine bereits vorhandene Partition um eine OpenBSD Partition
ergänzt werden soll, so ist der Ablauf praktisch identisch, blättere einfach
über jene Abschnitte hinweg, in denen wir die Windows-Partition erzeugen und
uns um die Installation des MBR »Boot-Codes« kümmern.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available disks are: wd0.
  Which one is the root disk? (or 'done') [wd0] <b><i>Enter</i></b>
  MBR has invalid signature; not showing it.
</pre></td></tr></table>
WENN das Laufwerk bereits einen gültigen MBR hätte, würde hier die existierende
Partitionstabelle dargestellt werden, was auch ein guter Anhaltspunkt dafür
sein kann, ob sich auf dem Laufwerk schon Daten befinden, oder nicht.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Use (W)hole disk or (E)dit the MBR? [whole] <b>e</b>

  You will now create a single MBR partition to contain your OpenBSD data. This
  partition must have an id of 'A6'; must *NOT* overlap other partitions; and
  must be marked as the only active partition.  Inside the fdisk command, the
  'manual' command describes all the fdisk commands in detail.

  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
Enter 'help' for information
fdisk: 1>
</pre></td></tr></table>

<p>
Nimm als Erstes Notiz vom fdisk-Prompt.  Die Zahl »1« zeigt an, dass es sich um
die erste Ebene von Partitionstabellen handelt -- würdest du eine erweiterte
Partition bearbeiten, so würde hier »2« stehen (oder eine noch größere Zahl).
Erweiterte Partitionen sind Partitionen, die ihre eigene
Unter-Partitionstabelle besitzen, und damit die IBM AT
Vier-Partitionen-Designbeschränkung umgehen.  Erweiterte Partitionen werden
hier nicht weiter behandelt.

<p>
Als Erstes erzeugen wir Partition »0«, eine 5&nbsp;G große Windows-Partition
(die das NTFS-Dateisystem benutzt), und Partition »1« wird als unsere
OpenBSD-Partition den gesamten Rest der Festplatte einnehmen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk: 1> <b>e 0</b>
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help)
</pre></td></tr></table>

<p>
Da wir gerade die gültige Partitions-ID für NTFS nicht aus unserer Erinnerung
rekapitulieren können, drücken wir »?«, um eine Liste zu erhalten.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>?</b>
  Choose from the following Partition id values:
  00 unused         20 Willowsoft     66 NetWare 386    A9 NetBSD
  01 DOS FAT-12     24 NEC DOS        67 Novell         AB MacOS X boot
  02 XENIX /        27 Win Recovery   68 Novell         AF MacOS X HFS+
  03 XENIX /usr     38 Theos          69 Novell         B7 BSDI filesy*
  04 DOS FAT-16     39 Plan 9         70 DiskSecure     B8 BSDI swap
  05 Extended DOS   40 VENIX 286      75 PCIX           BF Solaris
  06 DOS > 32MB     41 Lin/Minux DR   80 Minix (old)    C0 CTOS
  07 NTFS           42 LinuxSwap DR   81 Minix (new)    C1 DRDOSs FAT12
  08 AIX fs         43 Linux DR       82 Linux swap     C4 DRDOSs < 32M
  09 AIX/Coherent   4D QNX 4.2 Pri    83 Linux files*   C6 DRDOSs >=32M
  0A OS/2 Bootmgr   4E QNX 4.2 Sec    84 OS/2 hidden    C7 HPFS Disbled
  0B Win95 FAT-32   4F QNX 4.2 Ter    85 Linux ext.     DB CPM/C.DOS/C*
  0C Win95 FAT32L   50 DM             86 NT FAT VS      DE Dell Maint
  0E DOS FAT-16     51 DM             87 NTFS VS        E1 SpeedStor
  0F Extended LBA   52 CP/M or SysV   8E Linux LVM      E3 SpeedStor
  10 OPUS           53 DM             93 Amoeba FS      E4 SpeedStor
  11 OS/2 hidden    54 Ontrack        94 Amoeba BBT     EB BeOS/i386
  12 Compaq Diag.   55 EZ-Drive       99 Mylex          EE EFI GPT
  14 OS/2 hidden    56 Golden Bow     9F BSDI           EF EFI Sys
  16 OS/2 hidden    5C Priam          A0 NotebookSave   F1 SpeedStor
  17 OS/2 hidden    61 SpeedStor      A5 FreeBSD        F2 DOS 3.3+ Sec
  18 AST swap       63 ISC, HURD, *   A6 OpenBSD        F4 SpeedStor
  19 Willowtech     64 NetWare 2.xx   A7 NEXTSTEP       FF Xenix BBT
  1C ThinkPad Rec   65 NetWare 3.xx   A8 MacOS X
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>07</b>
</pre></td></tr></table>

<p>
Nun definieren wir die Start- und Endpunkte:
<p>

<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you wish to edit in CHS mode? [n]
</pre></td></tr></table>

<p>
Der CHS-Modus ermöglicht es dir, den Speicherplatz in Zylindern, Köpfen und
Sektoren zu spezifizieren.  Behalte in Erinnerung, das für moderne Festplatten
die CHS-Nummern absolut nichtssagend sind, einfach nur drei Zahlen, die zu
einem Sektor auf der Platte übersetzt werden, der dann auf die physikalische
Geometrie der Platte übersetzt wird (welche vielleicht auch noch, über die
gesamte Kapazität der Platte hinweg betrachtet, variabel ist).

<p>
Antwortest du hier mit »y«, so wirst du für Zylinder, Kopf und Sektor nach
Start- und Endwerten gefragt werden.  Solltest du mit »no« antworten (wie wir
es tun), so wirst du nach dem Start- und Endsektor und der Größe gefragt
werden.  Die Bearbeitung via CHS ist oft einfacher, wenn eine bestehende
Partition eingebunden werden soll, während die Angabe von Sektor und Größe oft
einfacher ist, wenn man schnell eine Partition einer bestimmten Größe erzeugen
möchte.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  offset: [0] <b>64</b>
</pre></td></tr></table>

<a name="trackoffset"></a>
<p>
Die fdisk-Plattformen benötigen einen Zwischenraum vor der ersten Partition.
Die exakte Größe spielt auf modernen Maschinen keine Rolle, OpenBSD benutzt
standardmäßig 64 Sektoren.  Dies wird aus Performance-Gründen für moderne
Laufwerke empfohlen, bei älteren Laufwerken spielt es keine Rolle.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  size: [0] <b>5g</b>
  Rounding to nearest cylinder: 10490382
</pre></td></tr></table>

<p>
Der »size«-Wert (Größe) kann als Anzahl von Sektoren (jeder von 512 Byte Größe)
angegeben werden, oder aber als gewünschte Kapazität, wenn als Suffix »k«, »m«
oder »g« benutzt wird.  Wenn die Bearbeitung mit Hilfe von »offset« (Abstand)
und »size« erfolgt, so rundet fdisk die Partitionsgröße derart, dass die
Partition auf einer Zylindergrenze endet (OpenBSD kümmert sich nicht darum, und
es mag möglich sein, dass sich kein einziges modernes Betriebssystem darum
kümmert, aber einige mögen es einmal getan haben).

<p>
Jetzt lass uns einen Blick auf unsere neue Partition werfen:
<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> p
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -    652 254  63 [          63:    10490382 ] NTFS
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
Beachte das der Prompt nun ein »*« beinhaltet,
wodurch anzeigt wird, das ungesicherte Änderungen vorliegen.

<p>
Wir haben nun die Windows-Partition erzeugt.  Im Moment ist sie allerdings
nichts weiter als reservierter Speicher auf der Platte, sie ist nicht
formatiert; kein Dateisystem befindet sich darauf.  Darum musst du dich
kümmern, wenn du Windows installierst; wir haben unser Ziel des Reservierens
von Speicher für eine später zu erzeugende Windows-Partition erreicht.

<p>
Jetzt erzeugen wir unsere OpenBSD-Partition.
In diesem Fall wird die Partitions-ID »A6« lauten.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> e 1
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>a6</b>
  Do you wish to edit in CHS mode? [n] <b><i>Enter</i></b>
  offset: [0]
</pre></td></tr></table>

<p>
Uh!  Oh!  Was ist unser »offset«?  Einfach -- der der vorherigen Partition plus
ihrer Größe, in diesem Fall 63+10490382 = 10490445.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  offset: [0] <b>10490445</b>
  size: [0] <b>*</b>
  fdisk:*1>
</pre></td></tr></table>

<p>
Die Eingabe von »*« meint in diesem Fall »den gesamten Rest des Laufwerks«.
Wieder hätten wir die Größe in Sektoren oder mit »m«- oder »g«-Suffix
spezifizieren können, wenn wir Speicher für etwas anderes hätten übrig lassen
wollen.

<p>
Jetzt schauen wir auf unsere Partitionstabelle:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -    652 254  63 [          63:    10490382 ] NTFS
   1: A6    653   0   1 -   4998   5  63 [    10490445:    69802803 ] OpenBSD
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
<b>WIR SIND NOCH NICHT FERTIG!</b><br>
Von diesem Laufwerk kann noch nicht gestartet werden!
Da es ein komplett neues Laufwerk war, ist der
<a href="faq14.html#Boot386">MBR</a> komplett leer.
Die »Signature: 0x0« Meldung hier zeigt, das keine gültige Signatur (0xAA55)
vorhanden ist, was indiziert, das definitiv kein gültiger »Boot-Code«
existiert.  Natürlich ist es möglich, zwar eine gültige Signatur, aber dennoch
keinen gültigen »Boot-Code« zu haben, z.&nbsp;B. durch zufälliges Pech oder
einem Schaden an dem existierenden »Boot-Code«, aber eine ungültige Signatur
indiziert mit hoher Wahrscheinlichkeit, dass der »Boot-Code« fehlt, weshalb wir
ihn jetzt mit Hilfe des »update«-Kommandos installieren:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>update</b>
  Machine code updated.
  fdisk:*1>
</pre></td></tr></table>

<p>
Wir müssen außerdem eine Partition als »aktiv« »markieren«, sodass der »Boot
ROM« weiß, von welcher Partition er booten soll:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>f 1</b>
  Partition 1 marked active.
</pre></td></tr></table>

<p>
Jetzt lass uns mal schauen, wie es aussieht:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -    652 254  63 [          63:    10490382 ] NTFS
  *1: A6    653   0   1 -   4998   5  63 [    10490445:    69802803 ] OpenBSD
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
Eine Checkliste von Dingen, die du sicherstellen solltest, bevor du fdisk(8)
verlässt:

<ul>
<li>Ist die Signatur gültig?
<li>Sind die Partitionen nicht-überlappend?
<li>Besitzt die OpenBSD-Partition eine »A6« id?
<li>Ist die gewünschte Partition (vielleicht OpenBSD) als »aktiv« markiert?
</ul>

<p>
<a href="#BackMorefdisk">(zurück dorthin, wo wir vielleicht gewesen sind)</a>

<p>
<a name="Moredisklabel"></a>
<h3>4.6.4 - Anpassung der disklabel-Konfiguration</h3>

Innerhalb der OpenBSD fdisk(8)-Partition benutzen wir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>,
um OpenBSD-Dateisysteme zu erzeugen.  OpenBSD benennt seine
Dateisystem-Partitionen mit Hilfe von sechzehn Buchstaben, »a« bis »p«.
Partition »a« auf dem Startlaufwerk ist als Wurzelpartition definiert, »b« auf
dem Startlaufwerk ist die Standard-Auslagerungs-Partition.  »c« ist auf allen
Laufwerken identisch mit einer »das gesamte Laufwerk«-Partition, und wird von
Programmen benutzt, die direkten Zugriff auf das physikalische Laufwerk
benötigen, wie zum Beispiel fdisk(8) und disklabel(8).  Die Partition »c« wird
automatisch erzeugt und sollte weder gelöscht noch verändert werden.  Die
verbleibenden Buchstaben sind für dich frei verfügbar, um sie als
Einhängepunkte zu definieren.  Man kann Buchstaben auslassen, sie in jedweder
Reihenfolge definieren, und sie können in jeglicher Reihenfolge auf dem
Laufwerk auftauchen (obwohl einige Plattformen Bedingungen an die Position der
Partition »a« stellen).  Du kannst auch Zwischenräume auf dem Laufwerk
unbenutzt lassen und sie später zuteilen, oder eventuell vorhandene Partitionen
mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=growfs&amp;sektion=8">growfs(8)</a>
in den nicht-zugeteilten Speicher hinein vergrößern.

<p>
Alle Partitionen, die native FFS-Partitionen beherbergen, sollten sich
innerhalb der OpenBSD fdisk(8)-Partition befinden, jedoch können
<a href="faq14.html#foreignfs">nicht-OpenBSD</a>-Partitionen
außerhalb der OpenBSD fdisk-Partition liegen (und normalerweise sollten sie das
auch).

<p>
Mehr Informationen über die Benutzung von disklabel kann
<a href="faq14.html#disklabel">hier</a> gefunden werden.

<p>
Mehr Informationen darüber, warum Partitionierung gut ist, und wie man eine
Strategie für einen guten Partitionierungsplan findet, findet sich
<a href="#Partitioning">weiter unten</a>.

<p>
Das OpenBSD-Installationsprogramm wird, basierend auf der Größe des Laufwerks,
versuchen, für dein Laufwerk einen benutzbaren, »für jeden Zweck tauglichen«
Partitionierungsplan zu erstellen.  Ist das Laufwerk groß genug, wird
verbleibender freier Speicher der Partition <tt>/home</tt> zugeschrieben.
Obwohl dies oft nützlich ist, befriedigt es doch nicht die Bedürfnisse aller
Nutzer.

<p>
Für unser Beispiel nehmen wir an, das wir einen statischen Webserver für einige
unserer Freunde aufbauen.  Wir haben eine Maschine, die eine durchschnittliche
Internetanbindung besitzt, mit einer 40&nbsp;G Festplatte, von der das meiste
für die Benutzung durch OpenBSD zur Verfügung steht (mit derselben 5&nbsp;G
Windows-Partition wie in dem Beispiel weiter oben.  Warum?  Vielleicht weil
dieses System einen RAID-Controller besitzt, der zwar von OpenBSD unterstützt-,
jedoch nur aus Windows heraus verwaltet werden kann.  Eher wahrscheinlich ist
es allerdings, das der Verfasser dieser »FAQ« sich nicht danach fühlte, viele
unterschiedliche Beispiele verwalten zu müssen).

<p>
Die Internetseiten, serviert von einem OpenBSD Webserver, befinden sich in
<tt>/var/www</tt>, und nur sehr wenig wird in <tt>/home</tt> abgespeichert
werden, sodass dies eine klare Änderung der Standardvorgabe erfordert.  Zum
Zwecke der Diskussion nehmen wir weiterhin an, dass wir auf dieser Maschine das
Betriebssystem nicht aus den Quellen heraus neu zu erzeugen brauchen (das
machen wir woanders).  Das System wird ohne X laufen, aber da einige
Web-Applikationen <a href="#FilesNeededX">ein installiertes X erwarten</a>,
werden wir es zumindest installieren.  Die Maschine ist nicht wirklich schnell,
sie kann nicht mehr als 1&nbsp;G RAM beherbergen, und es ist unwahrscheinlich,
dass unsere Anwendung jemals mehr als dies verlangen wird.

<p>
Nach ein wenig Nachdenken ist dies unser Plan zur Partitionierung des Systems:
<ul>
<li><tt>/ - root</tt>: 100m.  Dies wird »a« sein.
<li><tt>swap</tt> (Auslagerung): 1G (damit wir immer genug Speicherplatz für
    einen »core dump« haben), dies wird Partition »b«
<li><tt>/usr</tt>: 2g, Partition d
<li><tt>/tmp</tt>: 100m (wir erwarten nicht allzu viel Nutzung), Partition e
<li><tt>/usr/local</tt>: 2g, Partition f
<li><tt>/usr/X11R6</tt>: 1g, Partition g
<li><tt>/home</tt>: 1g, Partition h
<li><tt>/var</tt>: 1g (eine Menge System-Logdateien), Partition j
<li><tt>/var/www</tt>: Rest der Platte, Partition k
</ul>

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  The auto-allocated layout for wd0 is:
  #                size           offset  fstype [fsize bsize  cpg]
    a:          1024.0M         10490445  4.2BSD   2048 16384    1 # /
    b:           252.1M         12587597    swap
    c:         39205.7M                0  unused
    d:          2319.3M         13103933  4.2BSD   2048 16384    1 # /tmp
    e:          3653.9M         17853877  4.2BSD   2048 16384    1 # /var
    f:          1149.8M         25337016  4.2BSD   2048 16384    1 # /usr
    g:          1024.0M         27691862  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          3422.6M         29789014  4.2BSD   2048 16384    1 # /usr/local
    i:          5122.3M               63    NTFS
    j:          1848.7M         36798433  4.2BSD   2048 16384    1 # /usr/src
    k:          1848.7M         40584654  4.2BSD   2048 16384    1 # /usr/obj
    l:         17540.2M         44370875  4.2BSD   2048 16384    1 # /home
  Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout? [a] <b>c</b>
</pre></td></tr></table>

<p>
Wenn wir nur einige kleine Änderungen vorhätten, könnten wir auch die
automatische Einteilung editieren, anstatt mit einem reinen Tisch zu beginnen,
aber wir gehen hier den harten Weg.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  You will now create an OpenBSD disklabel inside the OpenBSD MBR
  partition. The disklabel defines how OpenBSD splits up the MBR partition
  into OpenBSD partitions in which filesystems and swap space are created.
  You must provide each filesystem's mountpoint in this program.

  The offsets used in the disklabel are ABSOLUTE, i.e. relative to the
  start of the disk, NOT the start of the OpenBSD MBR partition.

  Label editor (enter '?' for help at any prompt)
  > <b>p</b>
  OpenBSD area: 10490445-80293248; size: 69802803; free: 69802803
  #                size           offset  fstype [fsize bsize  cpg]
    c:         80293248                0  unused
    i:         10490382               63    NTFS
  >
</pre></td></tr></table>

<p>
Wie du siehst sind bereits zwei Partitionen vorhanden -- die Partition »c« ist
immer präsent und wird automatisch erzeugt, aber disklabel(8) hat ebenfalls die
bestehende NTFS-Partition wahrgenommen und ihr eine disklabel-Partition
zugewiesen, sodass es theoretisch möglich wäre, sie aus OpenBSD heraus zu
benutzen (anzumerken ist jedoch, das im Moment die Unterstützung für NTFS
experimentell ist und einen angepassten Kernel benötigt; die Unterstützung für
FAT/FAT32 ist hingegen ziemlich gut).

<p>
Wir werden nun unsere Partitionen erzeugen.
Wir starten mit der Partition »a«, unserer root-Partition:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a a</b>
  offset: [10490445] <b><i>Enter</i></b>
  size: [69802803] <b>100m</b>
  Rounding to cylinder: 208845
  FS type: [4.2BSD]  <b><i>Enter</i></b>
  mount point: [none] <b>/</b>
  >
</pre></td></tr></table>

<p>
disklabel hat hier automatisch den ersten frei verfügbaren OpenBSD-Sektor auf
dem Laufwerk eingesetzt, was genau das ist, was wir wollen.  Allerdings hat es
als Größenvorgabe den gesamten freien Speicher eingesetzt, was NICHT das ist,
was wir wollen.  Hier haben wir diesen Wert mit unserer gewünschten Größe
überschrieben, die in Sektoren, »M« oder »G« angegeben werden kann.

<p>
Normalerweise wirst du den Standard-Dateisystemtyp »4.2BSD« für eine FFS-
(»Fast File System«) oder FFS2-Partition wollen, obwohl andere Typen, die du
nützlich finden könntest, »swap« und »RAID« beinhalten.

<p>
Das letzte ist der Einhängepunkt.
Unsere Partition »a« ist die root-Partition, durch Definition.

<p>
Nun erzeugen wir Auslagerung, das ist unsere Partition »b« (dies ist wieder
eine Bedingung -- »b« auf dem Startlaufwerk ist Auslagerung):

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a b</b>
  offset: [10699290] <b><i>Enter</i></b>
  size: [69593958] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [swap] <b><i>Enter</i></b>
  >
</pre></td></tr></table>

<p>
Wieder hat disklabel den Startsektor korrekt kalkuliert, und uns als Größe den
»kompletten verbleibenden Speicherplatz« vorgeschlagen, was wir wiederum mit
unserer gewünschten Größe überschrieben haben.  Weil dies die »b«-Partition
ist, nahm disklabel an, dass sie für Auslagerungszwecke bestimmt ist, und als
wir das bestätigten, hielt es sich gar nicht mehr damit auf, uns nach einem
Einhängepunkt zu fragen.

<p>
Wir sind nun bereit, die restlichen Partitionen zu erzeugen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a d</b>
  offset: [12803805] <b><i>Enter</i></b>
  size: [67489443] <b>2g</b>
  Rounding to cylinder: 4209030
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr</b>
  > <b>a e</b>
  offset: [17012835] <b><i>Enter</i></b>
  size: [63280413] <b>100m</b>
  Rounding to cylinder: 208845
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/tmp</b>
  > <b>a f</b>
  offset: [17221680] <b><i>Enter</i></b>
  size: [63071568] <b>2g</b>
  Rounding to cylinder: 4209030
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr/local</b>
  > <b>a g</b>
  offset: [21430710] <b><i>Enter</i></b>
  size: [58862538] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr/X11R6</b>
  > <b>a h</b>
  offset: [23535225] <b><i>Enter</i></b>
  size: [56758023] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/home</b>
  > <b>a j</b>
  offset: [25639740] <b><i>Enter</i></b>
  size: [54653508] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var</b>
  > <b>a k</b>
  offset: [27744255] <b><i>Enter</i></b>
  size: [52548993] <b><i>Enter</i></b>
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var/www</b>
  >
</pre></td></tr></table>

<p>
Bei der <tt>/var/www</tt> Partition (»k«) haben wir einfach den Standardwert
genommen, und nutzen damit den gesamten freien Speicherplatz auf dem Laufwerk.
Mit den modernen monströs riesigen Laufwerken ist dies normalerweise eine
schlechte Idee.  Wenn du weißt, das du ihn nie benutzen wirst, teile ihn nicht
zu, sondern hebe ihn für einen zukünftigen Zweck auf.

<p>
Nun lass uns, mit Hilfe der Kommandos »p« und »p m«, einen Blick auf unser
Ergebnis werfen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>p</b>
  OpenBSD area: 10490445-80293248; size: 69802803; free: 0
  #                size           offset  fstype [fsize bsize  cpg]
    a:           208845         10490445  4.2BSD   2048 16384    1 # /
    b:          2104515         10699290    swap
    c:         80293248                0  unused
    d:          4209030         12803805  4.2BSD   2048 16384    1 # /usr
    e:           208845         17012835  4.2BSD   2048 16384    1 # /tmp
    f:          4209030         17221680  4.2BSD   2048 16384    1 # /usr/local
    g:          2104515         21430710  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          2104515         23535225  4.2BSD   2048 16384    1 # /home
    i:         10490382               63    NTFS
    j:          2104515         25639740  4.2BSD   2048 16384    1 # /var
    k:         52548993         27744255  4.2BSD   2048 16384    1 # /var/www
  > <b>p m</b>
  OpenBSD area: 10490445-80293248; size: 34083.4M; free: 0.0M
    #                size           offset  fstype [fsize bsize  cpg]
    a:           102.0M         10490445  4.2BSD   2048 16384    1 # /
    b:          1027.6M         10699290    swap
    c:         39205.7M                0  unused
    d:          2055.2M         12803805  4.2BSD   2048 16384    1 # /usr
    e:           102.0M         17012835  4.2BSD   2048 16384    1 # /tmp
    f:          2055.2M         17221680  4.2BSD   2048 16384    1 # /usr/local
    g:          1027.6M         21430710  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          1027.6M         23535225  4.2BSD   2048 16384    1 # /home
    i:          5122.3M               63    NTFS
    j:          1027.6M         25639740  4.2BSD   2048 16384    1 # /var
    k:         25658.7M         27744255  4.2BSD   2048 16384    1 # /var/www
  >
</pre></td></tr></table>

<p>
Genau wie bei fdisk-, sollten auch die OpenBSD disklabel-Partitionen einander
nicht überlappen (anders als die Partition »c«, die alles überlappt, natürlich).

<p>
Schreibe die Änderungen und beende disklabel:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>w</b>
  > <b>q</b>
  No label changes.
  newfs: reduced number of fragments per cylinder group from 13048 to 12992 to
  enlarge last cylinder group
  /dev/rwd0a: 102.0MB in 208844 sectors of 512 bytes
  5 cylinder groups of 25.38MB, 1624 blocks, 3328 inodes each
  /dev/rwd0h: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  newfs: reduced number of fragments per cylinder group from 13048 to 12992 to
  enlarge last cylinder group
  /dev/rwd0e: 102.0MB in 208844 sectors of 512 bytes
  5 cylinder groups of 25.38MB, 1624 blocks, 3328 inodes each
  /dev/rwd0d: 2055.2MB in 4209028 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0g: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0f: 2055.2MB in 4209028 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0j: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0k: 25658.7MB in 52548992 sectors of 512 bytes
  127 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local)
  /dev/wd0h on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0e on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0d on /mnt/usr type ffs (rw, asynchronous, local, nodev)
  /dev/wd0g on /mnt/usr/X11R6 type ffs (rw, asynchronous, local, nodev)
  /dev/wd0f on /mnt/usr/local type ffs (rw, asynchronous, local, nodev)
  /dev/wd0j on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0k on /mnt/var/www type ffs (rw, asynchronous, local, nodev, nosuid)

  Let's install the sets!
...
</pre></td></tr></table>

<p>
<a href="#BackMoredisklabel">(zurück dorthin, wo wir vielleicht gewesen sind)</a>

<p>
<a name= "FilesNeeded"></a>
<h2>4.7 - Welche Dateien werden für die Installation benötigt?</h2>
<!-- XXXrelease -->

<p>
Eine vollständige OpenBSD Installation ist in eine Reihe von separaten
<i>Dateisets</i> aufgeteilt.  Nicht jede Anwendung benötigt jedes Dateiset,
jedoch wird neuen Benutzern geraten, ALLE zu installieren.

Hier ist ein Überblick über jedes Einzelne:
<p>
<ul>
  <li><b><i>bsd</i></b>          - Dies ist der Kernel. <b>Benötigt</b>
  <li><b><i>bsd.mp</i></b> - Mehrfach-Prozessor (SMP) Kernel (nur bei
      einigen Plattformen)
  <li><b><i>bsd.rd</i></b> - <a href="#bsd.rd">RAM-Disk Kernel</a>
  <li><b><i>base50.tgz</i></b>   - Beinhaltet das OpenBSD-Basissystem
      <b>Benötigt</b>
  <li><b><i>etc50.tgz</i></b>    - Beinhaltet alle Dateien aus /etc
      <b>Benötigt</b>
  <li><b><i>comp50.tgz</i></b>    - Beinhaltet den Übersetzer (»Compiler«) und
      seine Werkzeuge, Kopfdateien (»Header«) und Bibliotheken.
  <li><b><i>man50.tgz</i></b>    - Beinhaltet die Handbuchseiten
  <li><b><i>game50.tgz</i></b>   - Beinhaltet die Spiele für OpenBSD
  <li><b><i>xbase50.tgz</i></b>  - Beinhaltet die Basis-Bibliotheken und
      -Werkzeuge für X11
  <li><b><i>xetc50.tgz</i></b>   - Beinhaltet die /etc/X11 und /etc/fonts
      Konfigurationsdateien
  <li><b><i>xfont50.tgz</i></b>  - Beinhaltet den X11 Schriftartenserver und
      Schriftarten
  <li><b><i>xserv50.tgz</i></b>  - Beinhaltet die X11 X-Server
  <li><b><i>xshare50.tgz</i></b> - Beinhaltet Handbuchseiten,
      Lokalisierungseinstellungen, Kopfdateien etc. für X
</ul>

Die <b>etc50.tgz</b> und <b>xetc50.tgz</b> Dateisets werden als Teil eines
»Upgrades« nicht installiert, sondern nur als Teil einer kompletten
Installation, sodass Anpassungen, die du eventuell gemacht hast, nicht verloren
gehen.  Du musst die Verzeichnisse <tt>/etc</tt>, <tt>/dev</tt> und
<tt>/var</tt> manuell aktualisieren.

<a name="FilesNeededX"></a>
<h3>Warum muss ich X für meine nicht-grafische Anwendung installieren?</h3>

Selbst wenn du es nicht vorhaben solltest, X laufen zu lassen, werden einige
»<a href="faq15.html">Packages</a>« von Dritten die Bibliotheken oder andere
Werkzeuge von X auf deinem System voraussetzen.  Diese Anwendungen können
manchmal einfach durch die Installation von einzig xbase50.tgz zufrieden
gestellt werden, der Rest von X wird nicht immer benötigt.  Manchen Leute
widerstrebt es, X auf ihrem System zu installieren, jedoch ohne gültigen Grund:

<ul>
<li>Die einfache Installation von X ist noch nicht der Grund für die Ausführung
    irgendeines Programms auf dem System.
<li>Die einfache Installation von X auf einem System verändert nicht das Risiko
    der externen Sicherheitsanfälligkeit.
<li>Wenn irgend jemand bereits AUF deinem System ist, können sie wahrscheinlich
    installieren, was immer sie wünschen, sodass die An- oder Abwesenheit von
    X die Situation nicht wirklich verändert.
<li>Die einzigen Teile von X, die laufen, sind die Teile, die von deiner
    Applikation benötigt werden.
<li>Der Speicherbedarf von X ist auf moderner Hardware relativ moderat.
</ul>

Leute verschwenden manchmal eine Menge Zeit und Mühe bei dem Versuch, sich aus
xbase50.tgz nur die Dateien herauszupicken, die sie für die Installation ihrer
Applikation benötigen.  Dies geschieht nicht nur ohne Grund, es ist auch eine
Mühe, die für jeden »Upgrade«-Zyklus erneut durchgeführt werden muss, was
vielleicht bedeutet, das du dein System nicht vernünftig aktualisierst, und
damit ECHTE Sicherheitsprobleme erzeugst.

<p>
WENN du X benötigst, installiere es einfach.  Es wird dich nicht mehr schmerzen
als die Applikation, für die du es benötigst.

<a name="FilesNeededComp"></a>
<h3>Ich möchte die Quelltext-Übersetzer nicht installieren</h3>

Na gut, dann lass es, aber bitte rede dir nicht selbst ein, das es aus
"sicherheitstechnischen Gründen" geschieht.  Wenn jemand derart tief in dein
System eingedrungen ist, das die An- oder Abwesenheit eines Übersetzers eine
Rolle spielt, dann sind sie in jedem Fall weit genug, um selbst einen
Übersetzer installieren zu können.  Nichtsdestotrotz, das Dateiset compXX.tgz
ist relativ groß und beinhaltet eine Menge Dateien, sodass es eine Weile dauern
kann, es zu installieren oder upzugraden, und auf langsamen oder kleinen
Systemen kann dies einen Unterschied machen.

<p>
Wenn du dich dazu entscheidest, den Übersetzer nicht zu installieren, so wirst
du wahrscheinlich ein anderes System benötigen, um aktualisierte Software zu
warten und zu bauen.  Es gibt weit mehr Systeme, die durch untaugliche Wartung
komprimittiert wurden, als solche, die komprimittiert wurden, weil ein
Übersetzer installiert war.

<p>
<a name="Partitioning"></a>
<h2>4.8 - Wie sollte ich mein Laufwerk partitionieren?</h2>
<!-- XXXrelease -->

<p>
Offensichtlich variiert die Antwort auf diese Frage kolossal in Abhängigkeit
von deiner Nutzung des System.  OpenBSD kann selbst in wenigen 512&nbsp;MB
installiert werden, allerdings ist die Installation auf einem so kleinen Gerät
eine Sache für fortgeschrittene Benutzer. Bis du ein wenig Erfahrung besitzt,
ist eine 4&nbsp;G oder 8&nbsp;G große Festplatte die Empfehlung für einen
Anfang.

<p>
Anders als viele andere Betriebssysteme bestärkt OpenBSD seine Benutzer, ihre
Laufwerke in eine ganze Reihe von Partitionen zu unterteilen, anstatt nur eine
oder zwei große Partitionen zu nutzen.  Es gibt eine Reihe von Gründen, das
Laufwerk zu unterteilen:

<ul>
<li><b>Sicherheit:</b> Du kannst einige Dateisysteme als »nosuid«, »nodev«
    »noexec«, »readonly« etc. spezifizieren.  Dies übernimmt das
    Installationsprogramm für dich, solltest du die empfohlenen Partitionen
    nutzen.
<li><b>Stabilität:</b> Ein Benutzer, oder ein sich schlecht aufführendes
    Programm, kann das Dateisystem mit Müll anfüllen, wenn Schreibrechte dafür
    gelten.  Deine kritischen Programme, die hoffentlich auf einem anderen
    Dateisystem laufen, werden davon nicht beeinträchtigt.
<li><b>Geschwindigkeit:</b> Ein Dateisystem, das häufig beschrieben wird, kann
    ein wenig fragmentieren.  (Glücklicherweise ist das FFS-Dateisystem, das
    OpenBSD nutzt, nicht anfällig für sehr starke Fragmentierung.)
<li><b>Integrität:</b> Wenn ein Dateisystem aus irgendwelchen Gründen zugrunde
    gerichtet ist, dann sind deine anderen Dateisysteme sehr wahrscheinlich
    noch O.K.
<li><b>Größe:</b> Viele Maschinen besitzen eine Beschränkung für die Position
    auf dem Laufwerk, von der das »Boot-ROM« den Kernel laden kann.  In einigen
    Fällen kann dieses Limit sehr klein sein (504&nbsp;MB für ältere 486), in
    anderen viel größer (2&nbsp;G, 8&nbsp;G oder 128&nbsp;G auf i386 Systemen).
    Da der Kernel sich an jeder möglichen Position auf der root-Partition
    befinden kann, sollte die gesamte root-Partition innerhalb dieses
    beschränkten Bereichs liegen.  Für weitere Details siehe in
    <a href="faq14.html#LargeDrive">diesem Abschnitt</a>.  Eine gute Richtlinie
    mag sein, die Partition für / komplett kleiner als 2&nbsp;G zu halten, es
    sei denn, du weißt, das deine Plattform (oder spezielle Maschine) mit mehr
    (oder weniger) umgehen kann.
<li><b>Nur-Lesen:</b> Du kannst Partitionen, die nie oder nur selten
    beschrieben werden, für die meiste Zeit im »Nur-Lesen«-Modus einhängen, was
    die Notwendigkeit eines fsck(8)-Laufs nach einem Crash oder Stromausfall
    beseitigt, und ebenso vor unbeabsichtigter Veränderung von Daten schützen
    kann.
<li><b>fsck(8):</b> Sehr große Partitionen verlangen nach mehr RAM für den
    fsck(8), und auf Systemen mit wenig Hauptspeicher kann dies dazu führen,
    das Daten ausgelagert werden müssen, was zu sehr lang andauernden
    fsck-Läufen führt.
</ul>

Ausreichenden Speicherplatz auf dem Laufwerk vorausgesetzt, wird das
Installationsprogramm von OpenBSD die folgenden Partitionen standardmäßig
vorschlagen:

<ul>
<li><b>/ - root:</b>
Zusätzlich dazu, das dies der Punkt ist, an dem die anderen Dateisysteme
eingehängt werden, hält das root-Dateisystem alle Dateien vor, die für das
Starten von OpenBSD benötigt werden.  Dies beinhaltet den Kernel, dazu die
Basiswerkzeuge in <tt>/sbin</tt> und <tt>/bin</tt>, die Konfigurationsdateien
in <tt>/etc</tt>, und das Geräte-Verzeichnis, <tt>/dev</tt>, die alle benötigt
werden, um das System hochzufahren.  Für das root-Dateisystem genügen schon
60&nbsp;MB, obwohl es mit 100&nbsp;MB oder 200&nbsp;MB einfacher ist, wenn die
Maschine über viele »Upgrade«-Zyklen hinweg benutzt werden soll.  Die Partition
»a« deines Startlaufwerks wird automatisch zur root-Partition.  EINIGE
Plattformen besitzen Restriktionen für ihre physikalische Position auf der
Platte (d.&nbsp;h. sie muss sich am Anfang des Laufwerks befinden), um starten
zu können.

<li><b>Swap (Auslagerung):</b>
Zusätzlich zu ihrer Aufgabe, ausgelagerte Speicherseiten zu beherbergen, wird
diese Partition ebenfalls dazu benutzt, sogenannte »core dumps« nach
Systemabstürzen abzuspeichern, weshalb vorgeschlagen wird, den Speicher für
Auslagerung (wenn solcher überhaupt konfiguriert wird) größer zu machen, als
den Maximalausbau an Hauptspeicher, der wahrscheinlicherweise jemals auf diesem
System installiert wird.  Lies mehr zu diesem Thema in
<a href="faq14.html#Swap">FAQ 14, Swap</a>.

<li><b>/tmp:</b>
Dies ist ein für alle und jeden beschreibbares Verzeichnis, das (wie der Name
impliziert!) für die temporäre Speicherung von Daten benutzt wird.  Die meisten
Systeme können mit sehr moderaten Speichermengen hierfür auskommen, 50&nbsp;MB
ist üblicherweise ein Vielfaches von dem, was du jemals brauchen wirst, obwohl
es einige wenige Applikationen gibt, die sehr, sehr viel mehr benötigen.
Obwohl dieses Verzeichnis für alle beschreibbar ist, wird OpenBSD es, für den
Fall, das es eine eigene Partition besitzt, in der Voreinstellung mit »nodev«
und »nosuid« einhängen, was die Möglichkeit des Missbrauchs für dein System
minimiert.  Anzumerken ist, dass der Inhalt dieses Verzeichnisses bei einem
Neustart des Systems aufgeräumt wird, und dass enthaltene Dateien, die 24
Stunden nicht benutzt wurden, nächtlich gelöscht werden.

<li><b>/var:</b>
Dieses Verzeichnis/dieser Einhängepunkt wird für VIELE Dinge benutzt, und mag,
in Abhängigkeit deiner Nutzung, ein Hauptkandidat für die Unterteilung in
weitere Partitionen sein.  Einige der Dinge, die sich hier befinden (und
potenziell zusätzliche Einhängepunkte darstellen):
<ul>
<li><tt>/var/log</tt>: Logdateien des Systems.
<li><tt>/var/mail</tt>: Boxen für ankommenden E-Mail-Verkehr.
<li><tt>/var/spool</tt>: Abgehender E-Mail-Verkehr (und andere Sachen).
<li><tt>/var/www</tt>: OpenBSDs
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">Web-Server</a>
    lebt hier.
<li><tt>/var/tmp</tt>: Dies ist ein Verzeichnis für »persistente« temporäre
    Dateien, da Dateien, die sich hier befinden, bei einem Neustart NICHT
    gelöscht werden.  So nutzt zum Beispiel vi(1) dieses Verzeichnis als
    temporären Speicher, sodass, im Fall eines Systemcrashs oder -Neustarts
    während des Editierens einer Datei, diese Dateien dazu benutzt werden
    können, die Bearbeitungssitzung wiederherzustellen.  Dateien, die hier 24
    Stunden lang unbenutzt bleiben, werden jedoch ebenfalls durch den
    nächtlichen Lauf von
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily&amp;sektion=8">daily(8)</a>
    gelöscht.
<li><tt>/var/crash</tt>: Wenn das System abstürzt, wird es versuchen, vor
    dem Neustart einen »core dump« in die Auslagerungs-Partition zu
    schreiben.  Dieser »core dump« wird dann während des Neustarts in
    <tt>/var/crash</tt> gespeichert, sodass <tt>/var</tt> mindestens soviel
    freien Speicher benötigt, wie das System Hauptspeicher besitzt, damit
    dies automatisch ablaufen kann.
</ul>

<li><b>/usr:</b>
Dies ist der Platz, an dem das meiste von OpenBSD residiert.  Binärdateien von
Programmen, Bibliotheken, Dokumentation, Handbuchseiten, etc. befinden sich
alle im <tt>/usr</tt> Verzeichnis.  Die Dateien in diesem Einhängepunkt sind
relativ unveränderlich -- in vielen Fällen könntest du die
<tt>/usr</tt>-Partition im »Nur-Lesen«-Modus einhängen, und ohne jegliche
Änderung am System bis zum nächsten »Upgrade« oder »Update« auskommen.

<li><b>/usr/X11R6:</b>
Hier befindet sich das »X Window System«.  Die X Binärdateien,
Schriftartendateien, Bibliotheken etc., finden sich alle hier.  Der einzige
Teil von X, der sich nicht hier befindet, sind die Konfigurationsdateien.

<li><b>/usr/local:</b>
Im Fall einer standardmäßigen OpenBSD-Installation ist dieser
Einhängepunkt/dieses Verzeichnis komplett leer.  Es wird für lokal installierte
Binärdateien und Bibliotheken für lokale Applikationen benutzt.

<li><b>/usr/src:</b>
Dieses Verzeichnis enhält die Basissystem-Quelltextdateien, ausschließlich
X und den »Ports«.  Dieses Verzeichnis ist standardmäßig leer, es muss so
geladen werden, wie es im Detail in <a href="faq5.html#BldGetSrc">FAQ 5</a>
beschrieben wird.

<li><b>/usr/obj:</b>
Dieses Verzeichnis wird während des Übersetzens mit Objekt- und Binärdateien
gefüllt.  Dieses Verzeichnis als Einhängepunkt zu definieren, erlaubt seine
einfache Formatierung anstelle des Löschens von Datei zu Datei, was signifikant
schneller sein kann.

<li><b>/home:</b>
Hier befinden sich die Dateien der Benutzer.  Dies als separate Partition zu
definieren macht eine komplette Neuinstallation des Systems einfach; formatiere
einfach in diesem Fall nicht diese Partition.
</ul>

<p>
Einige weitere Gedanken über Partitionierung:
<ul>
<li>Für deinen ersten Versuch an einem experimentellen System mag es am
    einfachsten sein, eine große <tt>/</tt>-Partition und Auslagerung zu
    definieren, bis du weißt, wieviel Speicher du benötigst.  Dies zu tun
    opfert einige der Standard-Sicherheitsmerkmale von OpenBSD, die separate
    Dateisysteme für <tt>/, /tmp, /var, /usr</tt> und <tt>/home</tt> erwarten.
    Jedoch solltest du vielleicht nicht gerade deine erste OpenBSD-Installation
    im produktiven Einsatz benutzen.
<li>Ein System, das offen dem Internet oder anderen feindlichen Kräften
    gegenüber steht, sollte separate <tt>/var</tt> (und vielleicht sogar eine
    separate <tt>/var/log</tt>) für das Loggen besitzen.
<li>Eine <tt>/home</tt>-Partition kann nett sein.  Eine neue Version des
    Betriebssystems?  Schmeisse alles weg und erzeuge es neu, aber lass deine
    <tt>/home</tt>-Partition unberührt.  Vergiss aber nicht, eine Kopie deiner
    Konfigurationsdateien zu sichern!
<li>Eine eigene Partition für Alles, das große Mengen an Dateien ansammeln
    kann, die vielleicht auch gelöscht werden müssen, kann schneller zu
    reformatieren und neu zu erzeugen sein, als es dauert, die Dateien zu
    löschen.  Siehe
    <a href="faq5.html#ProbObjPt">FAQ für das Erzeugen aus den Quelltexten</a>
    für ein Beispiel (<tt>/usr/obj</tt>).
<li>Wenn du vorhast, aus welchen Gründen auch immer, das System aus dem
    Quelltext neu zu erzeugen, so werden die Quellen sich in <tt>/usr/src</tt>
    befinden.  Benutzt du keine separate Partition für <tt>/usr/src</tt>, so
    stelle sicher, dass <tt>/usr</tt> über genügend Speicher verfügt.
<li>Ein gerne vergessener Fakt: du musst <b>nicht</b> den gesamten Speicher
    eines Laufwerks zuteilen, wenn du ein System einrichtest.  Da es heutzutage
    bereits eine Herausforderung ist, Laufwerke zu kaufen, die kleiner als
    100&nbsp;G sind, kann es durchaus Sinn machen, Teile des Laufwerks frei zu
    belassen.  Sollte eine Partition über ihre Größe hinauswachsen, so kannst
    du eine neue Partition in dem unbenutzten Teil der Platte erzeugen, die
    bestehende Partition in die neue Partition
    <a href="faq10.html#DupFS">duplizieren</a>,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab</a>
    derart anpassen, das es die neue Partition einhängt, neu einhängen, und du
    wirst mehr Platz haben.
<li>Sind deine Partitionen zu nahe an der Minimalgröße, wirst du es vielleicht
    später bereuen, wenn die Zeit gekommen ist, dein System zu »upgraden«.
<li>Wenn du sehr große Partitionen erzeugst, behalte den Gedanken im
    Hinterkopf, das das Ausführen von Dateisystem-Checks mit
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
    ungefähr 1&nbsp;MB Hauptspeicher pro Gigabyte Dateisystemgröße benötigt,
    und auf alten, langsamen Systemen sehr zeitaufwendig oder sogar
    undurchführbar sein kann (bitte siehe auch
    <a href="faq14.html#LargeDrive">diese Sektion</a>).
<li>Wenn du es deinen Nutzern gestattest, in <tt>/var/www</tt> zu schreiben
    (d.&nbsp;h. persönliche Webseiten), dann möchtest du dies vielleicht als
    eigene Partition realisieren, sodass es möglich ist, mit Hilfe von
    »<a href="faq10.html#Quotas">Quotas</a>« den Platz, den sie benutzen, zu
    beschränken, und sollten sie die Partition füllen, so wird kein anderer
    Bereich deines Systems betroffen.
<li>Du möchtest vielleicht auch eine <tt>/altroot</tt>-Partition erzeugen,
    wie es in
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily&amp;sektion=8">daily(8)</a>
    beschrieben wird.  Dies erzeugt eine tägliche Kopie deiner
    <tt>/</tt>-Partition, und gibt dir somit eine Extra-Kopie deines Kernels
    und der <tt>/etc</tt> Konfigurationsdateien, sollte irgendetwas mit deiner
    root-Partition passieren.  Offensichtlich muss die
    <tt>/altroot</tt>-Partition mindestens so groß sein wie <tt>/</tt>.  Wenn
    du ein zweites Laufwerk besitzt, und etwas anderes zur Duplizierung des
    Rests des Laufwerks benutzt, entweder
    Software-<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">softraid(4)</a>
    oder eine periodische Kopie mit Hilfe von
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>,
    so kann dieses Laufwerk nach dem Entfernen des primären Laufwerks startbar
    sein.
<li>Das Übersetzen von »<a href="faq15.html#Ports">ports</a>« aus dem Quelltext
    kann einen riesigen Platzbedarf in den <tt>/usr</tt>- und
    <tt>/tmp</tt>-Partitionen erfordern.  Dies ist ein weiterer Grund, warum
    wir empfehlen, stattdessen
    <a href="faq15.html#PkgMgmt">bereits übersetzte »Packages«</a> zu benutzen.
<li>Zumindest einige Editoren nutzen <tt>/var/tmp</tt> als Datenspeicher, und
    dieser muss oft mindestens so groß, wenn nicht sogar größer sein als die
    größte Datei, die editiert werden soll.  Solltest du vorhaben, Dateien von
    500&nbsp;MB Größe zu editieren, so müssen deine <tt>/var</tt>- oder
    <tt>/var/tmp</tt>-Partitionen viel größer sein, als du vielleicht geplant
    hattest.
</ul>

<p>
<a name= "Multibooting"></a>
<h2>4.9 - »Multibooting« OpenBSD/i386</h2>

»Multibooting« bezeichnet den Umstand, mehrere Betriebssysteme auf einem
Computer zu haben, und ein bisschen auch die Auswahl des zu startenden
Betriebssystems.  Dies ist <i>keine</i> triviale Sache!  Wenn du nicht weißt,
was du machst, kann dies zum Verlust von großen Mengen an Daten auf deinem
Computer führen.  Neue Benutzer von OpenBSD werden <i>nachdrücklich</i> dazu
aufgefordert, mit einer leeren Festplatte auf einer extra dafür bestimmten
Maschine zu beginnen, um dann die gewünschte Konfiguration auf einer nicht für
den realen Einsatz vorgesehenen Maschine auszuprobieren, bevor man eine
»Multiboot«-Konfiguration auf einer Maschine im produktiven Einsatz einsetzt.
<a href="faq14.html">FAQ 14</a> hat mehr Informationen über den Startprozess
von OpenBSD.

<p>
Vorzugsweise nutzt man eine der vier <i>primären</i> MBR-Partitionen, um
OpenBSD zu starten (d.&nbsp;h. das erweiterte Partitionen eventuell nicht
funktionieren).

<p>
Anzumerken ist, das Windows 7 und Vista ihre Systempartitionen in der Größe
verändern können: öffne die Systemsteuerung, suche nach »Datenträgerverwaltung«
und benutze dieses Werkzeug.  Ein Rechtsklick auf das »Volume« (Partition) und
du wirst bemerken, dass du sie schrumpfen kannst.  Die Hauptbeschränkung des
Werkzeugs ist, dass die Windows-Auslagerungsdatei nicht bewegt werden kann,
d.&nbsp;h. das wenn du mehr Speicher brauchst, muss zuerst diese Datei bewegt
oder ausgeschaltet werden.

<p>
Hier sind mehrere Optionen für das »Multibooting«:

<h3>Einstellung der aktiven Partition</h3>
Dies ist vielleicht die am meisten übersehene, aber, nichtsdestotrotz, manchmal
die beste Lösung für das »Multibooten«.  Welches Betriebssystem du auch immer
gerade benutzt, setze einfach die aktive Partition auf jene, die du als
Nächstes starten willst.  Nahezu jedes Betriebssystem offeriert ein Programm,
das dies tun kann; das von OpenBSD heißt
<a href="faq14.html#fdisk">fdisk(8)</a>, Programme gleichen Names gibt es in
Windows 9x und DOS, und vielen anderen Betriebssystemen.  Dieser Weg kann für
Betriebssysteme, oder Systeme, die eine sehr lange Zeit für das Herunterfahren
und den Neustart benötigen, sehr wünschenswert sein -- setze die aktive
Partition und leite den Neustart ein, entferne dich für eine Tasse Kaffee, und
komme zurück zu einem System, das auf die gewünschte Art und Weise gestartet
ist -- kein Warten auf den magischen Moment, um das korrekte Betriebssystem
auszuwählen.

<h3>Startdiskette</h3>
Wenn du ein System besitzt, das OpenBSD nur unregelmäßig startet (oder nicht
willst, das andere Nutzer des Systems bemerken, das sich etwas geändert hat),
so ziehe eine Startdiskette in Erwägung.  Benutze einfach eine der
<a href="#MkFlop">OpenBSD Standard-Installationsdisketten</a>, und erzeuge eine
Datei <tt>/etc/boot.conf</tt> (ja, du wirst auch ein Verzeichnis <tt>/etc</tt>
auf der Diskette erzeugen müssen) mit folgendem Inhalt:

<pre>
     boot hd0a:/bsd
</pre>

um das System von Festplatte 0, OpenBSD-Partition »a«, Kernel-Binärdatei
<tt>/bsd</tt> starten zu lassen.  Mit einer Zeile wie »<tt>boot hd2a:/bsd</tt>«
ist es auch möglich, von anderen Laufwerken zu starten, im Beispiel von der
dritten Festplatte des Systems.  Um OpenBSD zu starten, lege die Diskette ein,
und starte das System neu.  Um das andere Betriebssystem zu starten, entferne
die Diskette, und starte das System neu.  (Du kannst natürlich diese Diskette
auch zum Erzeugen einer startbaren CD benutzen.)

<p>
Das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>-Programm
wird von der Diskette geladen, sucht nach und liest <tt>/etc/boot.conf</tt>.
Die Zeile »<tt>boot hd0a:/bsd</tt>« instruiert boot(8), woher der Kernel zu
laden ist -- in diesem Fall die erste Festplatte, die vom BIOS gesehen wird.
Behalte in Erinnerung,  das nur eine kleine Datei (<tt>/boot</tt>) von der
Diskette gelesen wird -- das System lädt den gesamten Kernel von der
Festplatte, sodass dies nur fünf Sekunden auf den Prozess des Startens
aufschlägt.

<h3>Windows NT/2000/XP NTLDR</h3>

Für das »Multibooten« von OpenBSD und Windows NT/2000/XP kann man NTLDR
benutzen, den »Bootloader«, den NT benutzt.  Um mit NT »multibooten« zu können,
benötigt man eine Kopie des OpenBSD-»Partition Boot Record« (PBR).  Nach dem
Aufruf von »installboot« kann man diesen mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
wie gezeigt in eine Datei kopieren:

<pre>
        # <strong>dd if=/dev/rsd0a of=openbsd.pbr bs=512 count=1</strong>
</pre>

Anmerkung: dies ist wirklich ein guter Zeitpunkt, um daran zu erinnern, das das
blinde Tippen von Kommandos, die man nicht versteht, eine wirklich schlechte
Idee ist.  Diese Zeile wird auf den meisten Computern, so wie gezeigt, nicht
funktionieren. Es wird dem Leser überlassen, es auf seine eigene Maschine zu
übertragen.

<p>
Nun starte NT und schreibe <tt>openbsd.pbr</tt> nach C:.  Füge eine Zeile wie
die Folgende an das Ende von <tt>C:\BOOT.INI</tt> an:

<pre>
        c:\openbsd.pbr="OpenBSD"
</pre>

<p>
Wenn du neu startest, sollte es möglich sein, OpenBSD aus dem NT-Starter-Menü
auszuwählen.  Es sind viele Informationen zu NTLDR beim
<a href="http://www.tburke.net/info/ntldr/ntldr_hacking_guide.htm">NTLDR Hacking Guide</a>
verfügbar.

<p>
Unter Windows XP kannst du die Startinformationen auch grafisch editieren;
siehe das
<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;289022">XP Boot.ini HOWTO</a>.

<p>
Es sind Programme verfügbar, die dir viel von dieser Arbeit abnehmen, zum
Beispiel <a href="http://www.winimage.com/bootpart.htm">BootPart</a>.
Dieses Programm kann unter Windows NT/2000/XP laufen, kann den OpenBSD PBR
auslesen, ihn auf der NT/2000/XP-Partition platzieren und ihn zu der
<tt>C:\BOOT.INI</tt> hinzufügen.

<p>
Anmerkung: der Windows NT/2000/XP »Bootloader« ist ausschließlich dazu in der
Lage, Betriebssysteme von der primären Festplatte zu starten.  Du kannst ihn
nicht dazu benutzen, OpenBSD von der zweiten Platte des Systems zu starten.

<h3>Windows Vista</h3>

<p>
Mit Vista hat Microsoft die Unterstützung von NTLDR zugunsten des neueren
»Boot Configuration Data« (BCD)-Speichers, der zur Kontrolle der Startumgebung
benutzt wird, aufgegeben.  Da <tt>BOOT.INI</tt> für die Anpassung nicht länger
zur Verfügung steht, nimmt ein Kommandozeilenwerkzeug, <tt>bcedit</tt>, seinen
Platz ein.

<p>
Sobald OpenBSDs PBR auf die Vista-Systempartition kopiert wurde, sind die
folgenden drei Kommandos nötig, um OpenBSD auszuwählen und zu starten, wenn das
System neu gestartet wird:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /create /d "OpenBSD/i386" /application bootsector
The entry {05a763ce-d81b-11db-b3ec-000000000000} was successfully created.

C:\Windows\System32>
</pre></blockquote>

<p>
Die GUID, die hier zurückgegeben wurde,
<tt>05a763ce-d81b-11db-b3ec-000000000000</tt>,
wird für illustrative Zwecke gezeigt.  Beachte die GUID, die gezeigt wird, wenn
du das Kommando laufen lässt, da dieser Wert für die folgenden Kommandos
gebraucht wird.  Das einfache Kopieren der oben gezeigten GUID wird nicht
funktionieren.

<p>
Die folgenden zwei Kommandos werden ebenfalls benötigt:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /set {05a763ce-d81b-11db-b3ec-000000000000} device boot
The operation completed successfully.

C:\Windows\system32> bcdedit /set {05a763ce-d81b-11db-b3ec-000000000000} path \openbsd.pbr
The operation completed successfully.

C:\Windows\system32>
</pre></blockquote>

<p>
Diese müssen in einer Shell mit Administrator-Rechten ausgeführt werden.
Sobald du cmd.exe lokalisiert hast, Rechtsklicke es, um in der Lage zu sein,
"run as administrator" auszuwählen.

<p>
Beachte den absolute Pfadnamen der importierten PBR-Datei.  Füge keinen
Laufwerksbuchstaben hinzu, da angenommen wird, das die Datei auf der
Systempartition platziert wird.  <tt>bcdedit</tt> wird sich über einen explizit
spezifizierten Laufwerksbuchstaben nicht beschweren, aber der »Bootmanager«
wird später stocken und angeben, das er den designierten Pfadnamen nicht
auflösen kann.

<p>
Während des Neustarts wird Vista als Erstes im »Bootmanager« gelistet, direkt
gefolgt von OpenBSD.  Das Selektieren eines Eintrags startet das entsprechende
Betriebssystem.

<p>
Wenn nichts geschieht, schaue in der Systemsteuerung nach Startinformationen.
Sehr wahrscheinlich ist der Start von Windows so eingestellt, dass er keine
Verzögerung benutzt, sodass du das Start-Menü nicht zu sehen bekommst.  Du
kannst dieses Werkzeug auch benutzen, um OpenBSD standardmäßig zu starten.

<p>
Für mehr Informationen, konsultiere <tt>bcdedit</tt>'s Hilfe durch die Eingabe
von:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /?
</pre></blockquote>

<p>
oder durch die Suche in Microsofts Dokumentation und auf ihrer Webseite.  Eine
gute Einführung kann in dem TechNet-Artikel
»<a href="http://technet.microsoft.com/en-us/library/cc721886%28WS.10%29.aspx">Frequently Asked Questions</a>«
gefunden werden.

<p>
Für diejenigen, die manuelle Konfiguration erschreckend finden, bietet
<a href="http://neosmart.net/dl.php?id=1">EasyBCD</a> eine grafische
Alternative.

<h3>Windows 7</h3>

<p>
Seit der Veröffentlichung von Vista hat Microsoft BCD verbessert, sodass es nun
mehrere Versionen von Windows über <tt>bcdedit</tt> starten kann.  Weil dies
eine viel größere Kontrolle ermöglicht, sind nun fünf Kommandos nötig, um eine
»Multiboot«-Umgebung mit OpenBSD einzurichten.

<p>
Nach dem Kopieren des OpenBSD-PBR auf die Systempartition von Windows 7,
benutze die folgenden Kommandos, um die erforderlichen Registraturdaten zu
initialisieren:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /create /d "OpenBSD/i386" /application bootsector
The entry {0154a872-3d41-11de-bd67-a7060316bbb1} was successfully created.

C:\Windows\system32>
</pre></blockquote>

<p>
Wie zuvor schon geschildert ist die gezeigte
<tt>{0154a872-3d41-11de-bd67-a7060316bbb1}</tt> GUID
Systemabhängig.  Merke dir den Wert, den du bei der Ausführung erhältst, und
benutze ihn mit den folgenden Kommandos:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} device boot
The operation completed successfully.

C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} path \openbsd.pbr
The operation completed successfully.

C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} device partition=c:
The operation completed successfully.

C:\Windows\system32> bcdedit /displayorder {0154a872-3d41-11de-bd67-7060316bbb1} /addlast
The operation completed successfully.

C:\Windows\system32>
</pre></blockquote>

<h3>Andere »Bootloader«</h3>

<p>
Andere »Bootloader«, die Benutzer von OpenBSD erfolgreich benutzt haben:
<a href="http://gag.sourceforge.net/">GAG</a>,
<a href="http://www.ranish.com/part/">The Ranish Partition Manager</a>,
<a href="http://refit.sourceforge.net/">rEFIt</a>,
und <a href="http://www.gnu.org/software/grub/">GRUB</a>.

<p>
<h3>OpenBSD und Linux (i386)</h3>
<!-- XXXversion -->

<p>
Bitte lese
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/5.0/i386/INSTALL.linux">INSTALL.linux</a>,
das detaillierte Instruktionen beinhaltet, um OpenBSD und Linux gemeinsam zum
Laufen zu bringen.

<h3>Probleme mit der Zeitzone</h3>
OpenBSD erwartet, das die Echtzeituhr des Computers auf UTC (Universal
Coordinated Time) eingestellt ist.  Andere Betriebssysteme erwarten, das diese
Uhr auf lokale Zeit eingestellt ist.  Offensichtlich kann dies zu Problemen
führen, wenn beide Betriebssysteme auf demselbem Computer laufen.  Das eine
oder andere von Ihnen muss sehr wahrscheinlich angepasst werden.  Mehr
Informationen zu diesem Thema findet sich in
<a href="faq8.html#TimeZone">FAQ 8 - Warum geht meine Uhr um mehrere Stunden falsch?</a>.

<p>
<a name= "SendDmesg"></a>
<h2>4.10 - Das Senden deiner »dmesg« an dmesg@openbsd.org nach der Installation</h2>

<p>
Nur um es den Leuten in Erinnerung zu rufen, es ist wichtig für die
OpenBSD-Entwickler, auf dem Laufenden zu bleiben, welche Hardware läuft, und
welche nicht richtig funktioniert, und dies schließt die Hardwaresensoren ein,
die in den Maschinen gefunden werden können.

<p>
Ein Zitat aus /usr/src/etc/root/root.mail
<blockquote><pre>
If you wish to ensure that OpenBSD runs better on your machines, please do us
a favor (after you have your mail system configured!) and type something like:
 # (dmesg; sysctl hw.sensors) | \
        mail -s "Sony VAIO 505R laptop, apm works OK" dmesg@openbsd.org
so that we can see what kinds of configurations people are running.  As shown,
including a bit of information about your machine in the subject or the body
can help us even further.  We will use this information to improve device driver
support in future releases.  (Please do this using the supplied GENERIC kernel,
not for a custom compiled kernel, unless you're unable to boot the GENERIC
kernel.  If you have a multi-processor machine, dmesg results of both GENERIC.MP
and GENERIC kernels are appreciated.)  The device driver information we get from
this helps us fix existing drivers. Thank you!
</pre></blockquote>

<p>
Versichere dich, das du die E-Mail von einem Benutzerkonto sendest, das nicht
nur senden, sondern auch E-Mail empfangen kann, sodass dich Entwickler
kontaktieren können, wenn sie wollen, dass du etwas testest oder änderst, um
dein Setup zum Laufen zu bringen.  Es ist überhaupt nicht wichtig, diese E-Mail
von derselben Maschine zu senden, auf der OpenBSD läuft; sollte diese Maschine
keine E-Mail empfangen können, so mache einfach das Folgende:

<pre>
$ (dmesg; sysctl hw.sensors) | mail your-account@yourmail.dom
</pre>
und dann »forward«e diese Nachricht an
<pre>
 dmesg@openbsd.org
</pre>
wobei hier <tt>your-account@yourmail.dom</tt> für dein reguläres E-Mail-Benutzerkonto steht.

<p>
<b>ANMERKUNGEN</b>

<ul>
<li>Bitte schicke nur »dmesg«s des GENERIC-Kernels.
    Angepasste Kernel mit entfernten Gerätetreibern sind nicht hilfreich.
<li>Wenn du ein unterstütztes Mehrfachprozessorsystem besitzt, und es
    normalerweise mit dem GENERIC.MP Kernel betreibst, so ist es für die
    Entwickler hilfreich, die »dmesg«-Ausgabe sowohl des GENERIC-, als auch des
    GENERIC.MP-Kernels zu sehen, also sei bitte so nett und sende diese beiden
    in getrennten E-Mails.
<li>Die »dmesg«s werden von einem Computer bearbeitet, der das
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=spamd&amp;sektion=8">spamd</a>
    Spam-Blocksystem benutzt.  Dies kann dazu führen, das deine
    »dmesg« von den E-Mail-Servern für eine gewisse Zeit nicht akzeptiert wird.
    Sei geduldig, nach einer halben Stunde, oder Stunde, oder so, wird sie
    durchkommen.
</ul>

<p>
Die oben gezeigte Methode ist sehr einfach, aber wenn du dich dazu entschieden
hast, E-Mail auf deinem OpenBSD-System nicht zu konfigurieren, so solltest du
dennoch deine »dmesg« an die Entwickler schicken.  Speichere deine »dmesg« in
einer Textdatei.

<pre>
$ (dmesg; sysctl hw.sensors) > ~/dmesg.txt
</pre>

Dann transferiere diese Datei (mit Hilfe von FTP/scp/Diskette/Brieftaube/...)
an das System, das du normalerweise für E-Mail benutzt.  Da die
»dmesg«-Ausgabe, die du einsendest, automatisch abgearbeitet wird, solltest du
die folgenden Punkte sicherstellen, wenn du alternative
E-Mail-Programme/-Systeme benutzt:
<ul>
<li>Konfiguriere dein E-Mail-Programm so, dass es Nachrichten als Text sendet;
    benutze keine HTML-formatierte E-Mail.
<li>Schalte automatische Zeilenumbrechung ab.
    Viele E-Mail-Programme sind so eingerichtet, das sie in der 72sten Spalte
    die Zeilen umbrechen (die Norm für Mailinglisten).
<li>Stelle sicher, das dein E-Mail-Programm Nachrichten nicht zu
    »text-flow«-Nonsens umformatiert.
<li>Sende die »dmesg«-Ausgabe nicht als Dateianhang.
    Benutze die »dmesg«-Ausgabe für den normalen Textkörper der Nachricht.
</ul>


<a name="AddFileSet"></a>
<h2>4.11 - Ein Dateiset nach der Installation hinzufügen</h2>
<!-- XXXversion -->
»Oh nein! Ich habe bei der Installation ein Dateiset vergessen!«
<p>
Manchmal realisiert man zu spät, das man WIRKLICH <tt>comp50.tgz</tt> (oder
eine andere Systemkomponente) benötigt hätte, es aber zum Zeitpunkt der
Installation nicht realisiert hat.  Gute Nachrichten: Es gibt zwei einfache
Wege, Dateisets nach der eigentlichen Installation aufzuspielen:

<h3>Durch Benutzung des »Upgrade«-Prozesses</h3>
Starte einfach das Installationsmedium (CD-ROM oder Diskette) und wähle
»Upgrade« (anstatt »Install«).  Wenn du zu der Liste der zu installierenden
Dateisets kommst, wähle jene Sets aus, die du bei der ersten Installation
vergessen hast, wähle die Quelle, und lass sie dir installieren.

<h3>Durch Benutzung von tar(1)</h3>
Die Installations-Dateisets sind einfach komprimierte tar-Dateien,
und du kannst sie manuell von der Wurzel des Dateisystems aus auspacken:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # cd /
  # tar xzvphf comp50.tgz
</pre></td></tr></table>

<p>
Vergiss NICHT die »<tt>p</tt>«-Option im oben gezeigten Kommando,
da sie dafür sorgt, das die Dateirechte korrekt wiederhergestellt werden!
<p>
Ein häufig gemachter Fehler ist, zu denken, dass man
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1">pkg_add(1)</a>
benutzen kann, um fehlende Dateisets hinzuzufügen.  Das funktioniert nicht.
pkg_add(1) ist das
<a href="faq15.html#PkgMgmt">Verwaltungswerkzeug für »Packages«</a>
zur Installation von Software Dritter.  Es kann mit »Package«-Dateien umgehen,
nicht mit generischen tar-Dateien, wie es die Dateisets sind.

<p>
Wenn du das <tt>xbase</tt>-Dateiset zum ersten Mal auf deinem System mit Hilfe
von tar(1) und ohne Neustart installierst, so muss der Cache für
dynamisch-gelinkte Bibliotheken durch Benutzung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldconfig&amp;sektion=8">ldconfig(8)</a>
nach der Installation aktualisiert werden.  Um alle Bibliotheken von X zu dem
Cache hinzuzufügen:

<blockquote><pre>
# <b>ldconfig -m /usr/X11R6/lib</b>
</pre></blockquote>

Alternativ kann man auch einfach sein System neu starten, da der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">rc(8)</a>-Skript,
der beim Starten des Systems läuft, diese Schritte automatisch ausführt.

<p>
<a name="bsd.rd"></a>
<h2>4.12 - Was ist »bsd.rd«?</h2>

<b><tt>bsd.rd</tt></b> ist ein RAM (»Random Access Memory«,
Hauptspeicher)-Laufwerk-Kernel. Diese Datei kann sehr nützlich sein; viele
Entwickler achten sorgsam darauf, sie immer im Wurzelverzeichnis ihres Systems
präsent zu haben.

<p>
Ihn einen RAM-Laufwerk-Kernel zu nennen, beschreibt das Wurzel-Dateisystem des
Kernels -- anstatt sich auf einem physischen Laufwerk zu befinden, befinden
sich die Werkzeuge, die nach dem Start von <tt>bsd.rd</tt> vorhanden sind, im
Kernel, und werden von einem RAM-basierten Dateisystem ausgeführt.
<tt>bsd.rd</tt> enthält ein brauchbares Set an Werkzeugen für die Systemwartung
und -installation.

<p>
Auf manchen Plattformen ist <tt>bsd.rd</tt> sogar die bevorzugte
Installationstechnik -- du platzierst diesen Kernel auf einem vorhandenen
Dateisystem, startest ihn, und führst darauf hin von ihm aus die Installation
aus. Auf den meisten Plattformen kannst du, solltest du eine ältere Version von
OpenBSD laufen haben, eine neue Version von <tt>bsd.rd</tt> per FTP beziehen,
damit neu starten, und eine neue Version von OpenBSD installieren - ohne
Benutzung jeglicher Wechselmedien.

<p>
Hier ist ein Beispiel des Startens von <tt>bsd.rd</tt> auf einem i386-System:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Using Drive: 0 Partition: 3
  reading boot.....
  probing: pc0 com0 com1 apm mem[639k 255M a20=on]
  disk: fd0 hd0+
  &gt;&gt; OpenBSD/i386 BOOT 3.02
  boot&gt; <b>boot hd0a:/bsd.rd</b>
<i>. . . normal boot to install . . .</i>
</pre></td></tr></table>

Wie schon gesagt wirst du in das Installationsprogramm gelangen, aber du kannst
auch auf die Shell zurückgreifen, um Wartungsarbeiten auf dem System
auszuführen.

<p>
Die einfache Regel zum Starten von <tt>bsd.rd</tt> ist schlicht der Austausch
des »Boot-Kernels« von <tt>/bsd</tt> zu <tt>bsd.rd</tt>, wie auch immer dies
auf deiner Plattform zu bewerkstelligen ist.

<p>
<a name="InstProb"></a>
<h2>4.13 - Geläufige Installationsprobleme</h2>

<a name="cpq16m"></a>
<h3>4.13.1 - Mein Compaq erkennt nur 16&nbsp;MB RAM</h3>
<i>Einige</i> Compaq-Systeme haben das Problem, dass nicht der gesamte Hauptspeicher von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">OpenBSDs »Secondstage-Bootloader«</a>
ordentlich erkannt wird, sondern nur 16&nbsp;MB erkannt und von OpenBSD
verwendet werden.  Du kannst dieses Problem beheben, indem du entweder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"><tt>/etc/boot.conf</tt></a>
erstellst/editierst, oder Befehle am <tt>boot></tt>-Prompt eingibst, bevor
OpenBSD lädt. Falls du eine Maschine mit 64&nbsp;MB RAM hast, aber OpenBSD nur
die ersten 16&nbsp;MB erkennt, wird der Befehl
<pre>
     machine mem +0x3000000@0x1000000
</pre>
48&nbsp;MB (<tt>0x3000000</tt>) nach den ersten 16&nbsp;MB (<tt>0x1000000</tt>)
hinzufügen.  Wenn du ein System mit diesem Problem hättest, würdest du
typischerweise den oben angegeben Befehl am Installationsprompt <tt>boot></tt>
der Diskette/CD-ROM eingeben, neu starten und eine
<tt>/etc/boot.conf</tt>-Datei anlegen, die den oben angegebenen Befehl
beinhaltet, sodass alle zukünftigen Starts des Systems den ganzen verfügbaren
Speicher erkennen können.

<p>
Es wurde ebenfalls berichtet, dass ein ROM-Update dieses Problem auf
<i>einigen</i> Systemen löst.

<p>
<a name="noboot"></a>
<h3>4.13.2 - Mein i386 startet nach der Installation nicht</h3>
Deine Installation verlief gut, doch beim ersten Start erkennst du keine
Anzeichen dafür, dass OpenBSD versucht zu starten. Es existieren einige
bekannte Gründe für dieses Problem:

<ul>
<li><b>Keine Partition wurde in fdisk(8) als aktiv markiert.</b> Um dies zu
beheben, starte das System unter Verwendung der Startdiskette oder anderer
Medien neu und markiere eine Partition als aktiv (startbar). Siehe
<a href="faq14.html#fdisk">hier</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">hier</a>.

<li><b>Es wurde niemals ein gültiger »Bootloader« auf das Laufwerk
geschrieben.</b>  Falls du mit einfachem »ENTER« oder »W« auf die Frage »Use
(W)hole disk or (E)dit the MBR?« während der Installation geantwortet hast,
oder die <tt>reinit</tt>-Option von fdisk(8) verwendet hast, wurde der
OpenBSD-»Boot-Record« im MBR (»Master-Boot-Record«) der Platte installiert;
ansonsten wurde der existierende Code des »Master-Boot-Record« nicht berührt.
Dies wird ein Problem sein, wenn kein anderer »Boot-Record« existierte.  Eine
Lösung ist, das Installationsmedium wieder zu starten, auf die Shell
zurückzugreifen und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
aufzurufen, um den MBR-Code von der Befehlszeile aus zu aktualisieren:
<pre>
    # fdisk -u wd0
</pre>
Hinweis: Die »update«-Option im interaktiven Modus (»-e«) von fdisk wird keine
Signaturbytes schreiben, die benötigt sind, um das Laufwerk startbar zu machen.

<li><b>In einigen wenigen Fällen kann etwas mit der Installation des
»Secondstage-Bootloaders« schief gelaufen sein.</b> Die Neuinstallation des
»Secondstage-Bootloaders« wird <a href="faq14.html#InstBoot">hier</a>
besprochen.
</ul>

<a name="sshhang"></a>
<h3>4.13.3 - Mein System startete, hing aber bei der
    ssh-Schlüsselgenerierung</h3>

Es ist sehr wahrscheinlich, dass dein System einwandfrei funktioniert, aber
eine Weile benötigt, um die ssh-Schlüssel zu generieren.  Auf einer
SPARCStation2 oder einem Macintosh Quadra können <i>mehrere Stunden</i>
vergehen, bis die drei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>-Schritte
ausgeführt sind.  Lass diesen Prozess einfach durchlaufen - es wird nur ein
einziges Mal pro Installation gemacht.

<p>
Benutzer von sehr langsamen Maschinen können ihre Schlüssel auch auf einem
anderen Computer generieren, in einer <a href="#site">site50.tgz</a> genannten
Datei abspeichern, und sie zusammen mit den restlichen Dateisets installieren.

<p>
<a name="noftplist"></a>
<h3>4.13.4 - Ich bekam die Meldung »Failed to change directory«, als ich die
Installation durchführte</h3>


Wenn du eine FTP-Installation eines
<a href="faq5.html#Flavors">Schnappschusses</a> während der
»<i>-beta</i>«-Phase des OpenBSD-Entwicklungszyklus durchführst, könntest du
dies lesen:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>

  Display the list of known ftp servers? [no] <b>yes</b>
  Getting the list from 192.128.5.191 (ftp.openbsd.org)... FAILED
  Failed to change directory.
  Server IP address or hostname?
</pre></td></tr></table>

Dies ist normal und ein erwartetes Verhalten während der Vor-»Release«-Phase
des Zyklus.  Das Installationsprogramm sucht nach der FTP-Liste auf dem
primären FTP-Server in einem Verzeichnis, das bis zum
<a href="faq1.html#Next">»Release«-Datum</a> nicht verfügbar ist, so dass du
die oben genannte Meldung bekommst.

<p>
Verwende einfach eine <a href="../../de/ftp.html">FTP-Spiegelserverliste</a>,
um deinen favorisierten FTP-Spiegelserver zu finden, und gib seinen Namen
manuell ein, wenn du danach gefragt wirst.

<p>
<b>Hinweis: Du solltest die Meldung nicht sehen, wenn du »<i>-release</i>«,
oder von einer CD-ROM installierst.</b>

<p>
<a name="blankfdisk"></a>
<h3>4.13.5 - Meine fdisk-Partitionstabelle ist kaputt oder leer!</h3>
Gelegentlich finden Benutzer ein funktionsfähiges System vor, das aber bei
Verwendung von <tt>fdisk wd0</tt> eine vollständig leere (oder ab und zu
vermüllte) Partitionstabelle aufweist.  Dies wird normalerweise dadurch
verursacht, dass eine Partition in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
erstellt wurde, die einen »offset« von 0 Sektoren besitzt, anstatt den
<a href="#trackoffset">»offset« einer Spur</a>, den sie haben sollte (Hinweis:
Dies nimmt an, dass es sich um die <a href="../../de/i386.html">i386</a>- oder
<a href="../../de/amd64.html">amd64</a>-Plattform handelt. Andere Plattformen
benötigen andere »offsets«, einige sogar GAR KEINEN »offset«).
Das System <a href="faq14.html#Boot386">startet</a> dann unter Verwendung des
PBR und nicht des MBR.

<p>
Obwohl diese Konfiguration funktionieren kann, kann dies ein Wartungsproblem
darstellen, und sollte korrigiert werden.  Um dies zu korrigieren, muss das
Dateisystem der Platte normalerweise von Grund auf neu erstellt werden (obwohl,
wenn du WIRKLICH weißt, was du tust, könntest du in der Lage sein, nur das
disklabel und den MBR neu zu erstellen, und dadurch nur die erste
OpenBSD-Partition der Festplatte zu verlieren, und neu erzeugen zu müssen).

<p>
<a name="noflopcd"></a>
<h3>4.13.6 - Mein System besitzt weder Disketten- noch CD-ROM-Laufwerk</h3>
Einige Computer, auf denen Leute OpenBSD laufen lassen möchten, besitzen keinen
offensichtlichen Weg, um OpenBSD installieren zu können, da sie weder
Disketten- noch CD-ROM-Laufwerk besitzen.  Entweder wurde die Maschine so
designt (zum Beispiel viele Laptops und »Flash«-basierte Maschinen, wie
Soekris- oder ALIX-Systeme), oder die Startlaufwerke gingen kaputt oder wurden
entfernt, und es wäre schwierig, sie zu ersetzen.  Hier sind einige Tipps und
Techniken, die man benutzen kann, um OpenBSD auf solchen Systemen installiert
zu bekommen.

<ul>
<li>Netzwerkstart, mit Hilfe von <a href="faq6.html#PXE">PXE</a> (i386 oder
    amd64) oder
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8">diskless(8)</a>
    (andere Plattformen).
<li>Externes USB-CD-ROM- oder -Diskettenlaufwerk, wenn deine Maschine von so
    etwas starten kann.
<li>USB-Flash-Laufwerk oder -Festplatte, wiederum nur, wenn dein Computer von
    einem USB-Gerät starten kann.  Bereite das Gerät auf einem anderen Computer
    so vor, wie es in <a href="faq14.html#flashmemLive">FAQ 14</a> beschrieben
    wird.  Starte davon, aber wähle den bsd.rd Kernel, dann installiere wie
    normal.  Du könntest ebenfalls die Dateisets auf dem Flash-Medium
    vorgeladen halten.
<li>Im schlimmsten Fall, wenn keiner der oben genannten Wege möglich ist,
    kannst du normalerweise das Laufwerk aus dem Zielsystem ausbauen, einen
    passenden Adapter zum Einbau in einem »normalen« Computer benutzen, OpenBSD
    installieren, und dann das Laufwerk zurück in das Zielsystem verbringen.
    OpenBSD wird dann einfach fein auf der Zielmaschine starten, obwohl du
    höchstwahrscheinlich die Netzwerkkonfiguration anpassen musst.  Es mag auch
    sein, dass <tt>/etc/fstab</tt> angepasst werden muss, wenn du (zum
    Beispiel) deine Installation mit einem USB-&gt;IDE/SATA-Adapter vollbracht
    hast, oder deine Ziel- oder Installationsmaschine
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4">ahci(4)</a>
    benutzen, und die jeweils andere es nicht tut.  IDE- und eine einige
    SATA-Laufwerke werden normalerweise als
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>-Geräte
    erkannt, aber, wenn sie an einen USB-Adapter angeschlossen sind, als
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4">sd(4)</a>-Geräte
    klassifiziert.  Ein SATA-Laufwerk, angeschlossen an eine
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>-Schnittstelle,
    wird als wd(4) gelten, aber angeschlossen an eine
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4">ahci(4)</a>-Schnittstelle,
    als sd(4)-Gerät erkannt.  Wie auch immer, ist die <tt>/etc/fstab</tt>-Datei
    erst einmal angepasst, sollte das System einfach fein starten.
</ul>

In allen Fällen, erinnere dich daran, das auf der Maschine einmal ein
Betriebssystem installiert war, und es war normalerweise vorgesehen, das das
Betriebssystem neu aufgespielt werden kann.  Wie dies ursprünglich vorgesehen
war, gibt dir oft eine gute Idee, wie du nun OpenBSD darauf installieren
kannst.

<p>
<a name="shamismatch"></a>
<h3>4.13.7 - Ich bekam einen SHA256-Prüfsummenfehler während der
    Installation!</h3>
Prüfsummen sind, für jene Dateisets, die für die Systeminstallation benötigt
werden, fest im Installationskernel verdrahtet.

<p>
Dateisets, die für »<i>-release</i>« benutzt werden, sollten alle ihren
gespeicherten Prüfsummen entsprechen.

<p>
<b>Es kann vorkommen, dass für <i>Schappschüsse</i> keine korrekte
Prüfsumme im Installationskernel gespeichert ist.</b>
Dies geschieht aus verschiedenen Gründen während der Erzeugung, und ist kein
Grund, in Panik über Entwicklungs-Schnappschüsse auszubrechen.  Wenn du dir
darüber Sorgen machst, so warte auf den nächsten Schnappschuss.

<p>
<a name="site"></a>
<h2>4.14 - Anpassung des Installationsprozesses</h2>
<!-- XXXversion -->

<h3>Die <tt>siteXX.tgz</tt>-Datei</h3>
Mit den OpenBSD Installations- und »Upgrade«-Skripten kann ein vom Benutzer
erstelltes Set, das »<tt>siteXX.tgz</tt>« genannt wird, wobei XX für die
»Release«-Version (»Veröffentlichung«, z.&nbsp;B. 50) steht.  Das
<tt>siteXX.tgz</tt>-Dateiset ist, wie die anderen
<a href="#FilesNeeded">Dateisets</a>, ein mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gzip&amp;sektion=1">gzip(1)</a>
komprimiertes
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>-Archiv,
das im Wurzelverzeichnis »/« beheimatet ist und, wie die anderen Dateisets
auch, mit den Optionen <tt>xzphf</tt> ausgepackt werden muss.  Dieses Set wird
zuletzt installiert, nach allen anderen Dateisets.

<p>
Dieses Dateiset erlaubt es dem Benutzer, Dateien hinzuzufügen oder Solche zu
überschreiben, die von den »normalen Sets« installiert worden sind, und erlaubt
daher die Anpassung der Installation oder des »Upgrade«.

<p>
Es ist ebenfalls möglich, Hostnamen-spezifische Installationssets zu erzeugen
und zu benutzen; diese müssen dem Schema
<tt>siteXX-<i>&lt;hostname&gt;.tgz</i></tt> folgen, zum Beispiel
»<tt>site50-puffy.tgz</tt>«.  Dies erlaubt die einfache Host-spezifische
Anpassung für Installationen, »Upgrades« oder dem Wiederherstellen nach
Katastrophen.

<p>
Einige Beispiel-Anwendungen einer <tt>siteXX.tgz</tt>-Datei:
<ul>
<li>Erstelle eine siteXX.tgz-Datei, die alle Änderungen beinhaltet, die du seit
der ersten Installation von OpenBSD gemacht hast. Wenn du dann das System neu
erstellen musst, wähle einfach siteXX.tgz während der Neuinstallation aus, und
alle Änderungen von dir werden auf dem neuen System nachgebildet.

<li>Erstelle eine Serie maschinenspezifischer Verzeichnisse, die jeweils eine
siteXX.tgz-Datei beinhalten, die wiederum spezifische Dateien für diese
Maschine beinhalten.  Installationen von Maschinen (z.&nbsp;B. Systeme mit
unterschiedlichen Grafikkarten) einer bestimmten Kategorie können durch die
Auswahl der passenden siteXX.tgz-Datei abgeschlossen werden.

<li>Stecke die Dateien, die du routinemäßig auf einem gleichen oder ähnlichem
    Weg anpasst, in eine siteXX.tgz-Datei --
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"><tt>/etc/skel</tt></a>-Dateien,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><tt>/etc/pf.conf</tt></a>,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8"><tt>/var/www/conf/httpd.conf</tt></a>,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"><tt>/etc/rc.conf.local</tt></a>
    etc.
</ul>

<h3><tt>install.site</tt>/<tt>upgrade.site</tt> Skripte</h3>
Als letzten Schritt im Installations-/»Upgrade«-Prozess wird im
Wurzelverzeichnis des neu installierten/aktualisierten Systems je nach
aktuellem Prozess nach <tt>install.site</tt> oder <tt>upgrade.site</tt> gesucht
und das Skript in einer Umgebung ausgeführt, die auf das Wurzelverzeichnis des
installierten/aktualisierten System
ge»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=8">chroot</a>«et
ist. Denke daran, dass das »Upgrade« von einem gestarteten Dateisystem aus
ausgeführt wird, sodass dein Ziel tatsächlich auf <tt>/mnt</tt> eingehängt ist.
Trotzdem kann der Skript, aufgrund des »chroot«, so geschrieben werden, als ob
er im »normalen« Wurzelverzeichnis des Dateisystems läuft.  Da dieser Skript
ausgeführt wird, nachdem alle anderen Dateien installiert wurden, ist der
größte Teil der Funktionalität eines vollständigen Systems verfügbar.  Aber
denke daran, das nur ein minimaler Kernel läuft, nicht alle Möglichkeiten sind
verfügbar, und, aufgrund von Platzbeschränkungen, können Dinge, die heute
funktionieren, in einem zukünftigen »Release« nicht mehr funktionieren.

<p>
Beachte das das <tt>install.site</tt>-Skript in der <tt>siteXX.tgz</tt>-Datei
liegen sollte, während das <tt>upgrade.site</tt>-Skript vor dem »Upgrade« in
das Wurzelverzeichnis gelegt werden kann - oder in eine
<tt>siteXX.tgz</tt>-Datei.

<p>
Die Skripte können für viele Dinge verwendet werden:
<ul>
<li>Entfernen von Dateien, die installiert/aktualisiert worden sind, die du
    auf dem System aber nicht haben möchtest.
<li>Entfernen/aktualisieren/installieren von den
    »<a href="faq15.html#PkgMgmt">Packages</a>«, die du auf dem installierten
    System haben möchtest (muss nicht zwangsläufig für alle »Packages«
    funktionieren!).
<li>Erstellen eines
    <a href="faq14.html#Backup">sofortigen »Backup«s/Archivs</a>
    des neuen Systems, bevor es dem Rest der Welt ausgesetzt wird.
<li>Einstellen der Systemzeit via
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>
<li>Um ein Set wahlloser Kommandos nach dem ersten Start ausführen zu lassen.
    Dies geschieht, wenn install.site dazu benutzt wird, jedes solche Kommando
    an die
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.firsttime&amp;sektion=8">rc.firsttime(8)</a>-Datei
    anzuhängen (anhängen ist nötig, da das Installationsprogramm seinerseits in
    diese Datei schreiben könnte).  Während des Neustarts wird rc.firsttime
    einmal ausgeführt, und dann gelöscht.
</ul>

<p>
Die Kombination von <tt>siteXX.tgz</tt>- und
<tt>install.site-/upgrade.site</tt>-Dateien soll den Benutzern ein breites
Angebot an Möglichkeiten zur Anpassung der Installation eröffnen, ohne das es
nötig ist, das sie ihre eigenen, angepassten Installationssets erzeugen müssen.

<p>
Hinweis: Wenn du über einen HTTP-Server installierst, so musst du die
<tt>site*.tgz</tt>-Datei (oder Dateien) in der Datei <tt>index.txt</tt>
des Quellverzeichnisses auflisten, damit sie während der Installation als
Option angezeigt wird.  Dies gilt nicht für FTP- oder andere
Installationsmethoden.

<p>
<a name="Multiple"></a>
<h2>4.15 - Wie kann ich eine Anzahl gleichartiger Systeme installieren?</h2>
Hier sind einige Anwendungen aufgelistet, die du verwenden kannst, wenn du
mehrere ähnliche OpenBSD-Systemen installieren musst.

<h3><tt>siteXX.tgz</tt>- und <tt>install/upgrade.site</tt>-Dateien</h3>
Siehe den <a href="#site">vorherigen</a> Artikel.

<h3>Ein dump(8) wiederherstellen</h3>
Auf den meisten Plattformen beinhaltet das Startmedium das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>-Programm,
welches verwendet werden kann, um ein »Backup« zu extrahieren, das mit Hilfe
von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
erstellt wurde.  Du kannst daher von <a href="#MkFlop">Diskette</a>,
<a href="../../de/orders.html">CD</a> oder <a href="#bsd.rd">bsd.rd</a>-Datei
starten, dann »<a href="faq14.html#fdisk">fdisk</a>« und
»<a href="faq14.html#disklabel">disklabel</a>« ausführen und mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore</a>
die gewünschte Konfiguration von Band oder einem anderen Medium
wiederherstellen und die »<a href="faq14.html#InstBoot">Bootblöcke</a>«
installieren. Weitere Details gibt es <a href="faq14.html#Backup">hier</a>.

<h3>Plattenabbildung (»imaging«)</h3>
Leider ist kein Platten-Abbildungs-Programm bekannt, das FFS unterstützt, und
so nur den tatsächlich benutzten Speicher abbilden würde.  Viele der großen
bekannten Abbildungslösungen behandeln eine OpenBSD-Partition als »generische«
Partition, und können daher nur ein Abbild der kompletten Partition erzeugen.
Damit ist dein Ziel zwar meistens erreicht, jedoch werden dabei normalerweise
gigantische Mengen Speicher verschwendet -- eine leere 10&nbsp;G große
<tt>/home</tt>-Partition wird 10&nbsp;G Speicher im Abbild benötigen, selbst
wenn sich keine einzige Datei darin befindet.  Und während man normalerweise
ein Laufwerksabbild auf ein größeres Laufwerk installieren kann, würde es nicht
möglich sein, den überzähligen Speicher zu nutzen, und du würdest nicht in der
Lage sein, das Abbild auf ein kleineres Laufwerk zu installieren.

<p>
Sollte dies eine akzeptable Situation darstellen, so magst du in dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd</a>-Kommando
eine Lösung finden, die das tut, was du brauchst, und dir erlauben, ein
Laufwerk in ein anderes zu Kopieren, Sektor für Sektor.  Dies würde dieselbe
Funktionalität bieten wie die kommerziellen Programme, jedoch ohne Kosten.

<p>
<a name="getdmesg"></a>
<h2>4.16 - Woher bekomme ich eine dmesg(8), damit ich ein Installationsproblem
    melden kann?</h2>
Wenn man <a href="../../de/report.html">ein Problem meldet</a>, ist es
entscheidend, eine komplette
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
des Systems einzufügen.  Wie auch immer - oft ist es so, dass du dies machen
musst, wenn das System nicht ordnungsgemäß funktioniert, oder nicht
installieren will, sodass du weder Platten-, Netzwerk- oder andere Ressourcen
zur Verfügung hast, um deine »dmesg« an die passende
<a href="../../de/mail.html">Mailingliste</a> zu senden. Es gibt aber andere
Wege:

<ul>
<li><b>Diskette:</b> Die Startdisketten und -CD-ROMs bieten genügend Werkzeuge,
    um deine »dmesg« auf eine MSDOS-Diskette zu schreiben, sodass sie auf einer
    anderen Maschine ausgelesen werden kann.  Lege eine MSDOS-formatierte
    Diskette in dein Diskettenlaufwerk und führe folgende Befehle aus:
    <pre>
     mount -t msdos /dev/fd0a /mnt
     dmesg > /mnt/dmesg.txt
     umount /mnt
    </pre>
    Falls du ein anderes OpenBSD-System besitzt, kannst du es ebenfalls auf
    eine OpenBSD-kompatible Diskette schreiben -- oftmals hat die Startdiskette
    genügend freien Raum, um die »dmesg« aufzunehmen.  In diesem Fall verzichte
    auf das gezeigte »<tt>-t msdos</tt>«.
<p>
<li><b>Serielle Konsole:</b>
    Eine serielle Konsole zu verwenden, und die Ausgabe auf einer anderen
    Maschine abzufangen, ist oftmals der beste Weg, um Diagnoseinformationen
    erhalten zu können - insbesondere, wenn der Computer direkt nach dem Start
    in einer »panic« endet.  Neben einem zweitem Computer benötigst du
    ebenfalls ein passendes serielles Kabel (oft ein Nullmodemkabel) und ein
    Terminalemulator-Programm, das die Bildschirmausgabe in eine Datei
    schreiben kann.

    <p>
    Generelle Informationen über die Einrichtung eines seriellen Terminals
    sind <a href="faq7.html#SerCon">an einer anderen Stelle der FAQ</a>
    verfügbar; um eine Aufzeichnung der Installation abfangen zu können, sind
    in der Regel folgende Befehle ausreichend.

    <p><b>i386</b>

    <p>
    Gib am »Bootloader«-Prompt Folgendes ein:

    <p>
    <blockquote><pre>
    boot> <b>set tty com0</b>
    </pre></blockquote>

    <p>
    Dies teilt OpenBSD mit, dass die erste serielle Schnittstelle (in
    PC-Dokumentationen oft COM1 oder COMA genannt) als serielle Konsole
    verwendet werden soll.  Die Standardbaudrate ist 9600.

    <p><b>Sparc/Sparc64</b>

    <p>
    Diese Maschinen starten automatisch mit einer seriellen Konsole, wenn sie
    ohne angeschlossene Tastatur gestartet wurden. Falls du Tastatur und
    Monitor angeschlossen hast, kannst du das System trotzdem dazu bringen,
    eine serielle Konsole zu verwenden, indem du folgende Befehle am
    <tt>ok</tt>-Prompt aufrufst.

    <p>
    <blockquote><pre>
    ok <b>setenv input-device ttya</b>
    ok <b>setenv output-device ttya</b>
    ok <b>reset</b>
    </pre></blockquote>
</ul>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Starten mit OpenBSD]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq4.html,v 1.316 ]<br>
$Translation: faq4.html,v 1.153 2011/12/06 14:06:24 steffen Exp $<br>
-->
$OpenBSD: faq4.html,v 1.126 2011/12/07 06:30:19 ajacoutot Exp $
</small>
</body>
</html>
