<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>4 - OpenBSD-3.8-Installationsanleitung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2005.">
</head>

<!-- Passes validator.w3.org.  Please keep it this way -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Wo man OpenBSD herbekommt]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<h1><font color="#e00000">4 - OpenBSD-3.8-Installationsanleitung</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href= "#Overview"    >4.1 - Übersicht der
   OpenBSD-Installationsprozedur</a>
<li><a href= "#Checklist"   >4.2 - Checkliste für die Installation</a>
<li><a href="#MkInsMedia"   >4.3 - Bootfähige
   OpenBSD-Installationsmedien erzeugen</a>
    <ul>
    <li><a href="#UnixFlop" >4.3.1 - Disketten unter Unix erzeugen</a>
    <li><a href="#DosFlop"  >4.3.2 - Disketten unter Windows oder DOS
       erzeugen</a>
    <li><a href="#MkCD-ROM" >4.3.3 - Eine Boot-CD erzeugen</a>
    </ul>
<li><a href="#Boot"         >4.4 - Das Booten der
   OpenBSD-Installationsimages</a>
<li><a href="#Install"      >4.5 - Eine Installation durchführen</a>
  <ul>
  <li><a href="#Start"      >4.5.1 - Mit der Installation beginnen</a>
  <li><a href="#Disks"      >4.5.2 - Festplatte(n) einrichten</a>
  <li><a href="#Hostname"   >4.5.3 - Den Hostnamen des Systems
     setzen</a>
  <li><a href="#Network"    >4.5.4 - Das Netzwerk konfigurieren</a>
  <li><a href="#InstMedia"  >4.5.5 - Das Installationsmedium
     auswählen</a>
  <li><a href="#Filesets"   >4.5.6 - Dateisets auswählen</a>
  <li><a href="#Finish"     >4.5.7 - Zum Ende kommen</a>
  </ul>

<li><a href= "#FilesNeeded" >4.6 - Welche Dateien werden zur
   Installation benötigt?</a>
<li><a href= "#SpaceNeeded" >4.7 - Wieviel Platz brauche ich für eine
   OpenBSD-Installation?</a>
<li><a href= "#Multibooting">4.8 - Multibooting OpenBSD/i386</a>
<li><a href= "#SendDmesg"   >4.9 - Nach der Installation deine dmesg an
   dmesg@openbsd.org schicken</a>
<li><a href= "#AddFileSet"  >4.10 - Ein Dateiset nach der Installation
   hinzufügen</a>
<li><a href= "#bsd.rd"      >4.11 - Was ist ,bsd.rd'?</a>
<li><a href= "#InstProb"    >4.12 - Allgemeine
   Installationsprobleme</a>
  <ul>
  <li><a href="#cpq16m"     >4.12.1 - Mein Compaq erkennt nur 16M
     RAM</a>
  <li><a href="#noboot"     >4.12.2 - Mein i386 bootet nach der
     Installation nicht</a>
  <li><a href="#sshhang"    >4.12.3 - Mein System bootet, aber hängte
     beim ssh-keygen-Prozess</a>
  <li><a href="#noftplist"  >4.12.4 - Ich bekam die Meldung "Failed to
     change directory", als ich die Installation durchführte</a>
  <li><a href="#blankfdisk" >4.12.5 - Meine fdisk-Partitionstabelle ist
     kaputt oder leer!</a>
  </ul>
<li><a href= "#site"        >4.13 - Anpassen des
  Installationsprozesses</a>
<li><a href= "#Multiple"    >4.14 - Wie kann ich mehrere gleichartige
   Systeme installieren?</a>
<li><a href="#getdmesg"     >4.15 - Woher bekomme ich eine dmesg(8),
   damit ich ein Problem mit der Installation melden kann?</a>
<li><a href="#bsdrdaout"    >4.16 - OpenBSD unter Verwendung von
   <tt>bsd.rd-aout</tt> upgraden/neuinstallieren</a>.
</ul>
<hr>

<p>
<a name= "Overview"></a>
<h2>4.1 - Übersicht der OpenBSD-Installationsprozedur</h2>

<p>
OpenBSD hat eine robuste und anpassungsfähige textbasierte
Installationsroutine und kann von einer einzelnen Diskette aus
installiert werden. Die meisten Architekturen folgen einer ähnlichen
Installationsroutine; allerdings gibt es Unterschiede in den Details.
In jedem Fall wird dringend dazu geraten, das plattformspezifische
INSTALL-Dokument im <i>Plattform</i>-Verzeichnis auf der CD-ROM oder der
FTP-Seiten (z.B. <tt>i386/INSTALL.i386</tt>,
<tt>mac68k/INSTALL.mac68k</tt> oder <tt>sparc/INSTALL.sparc</tt>)
durchzulesen.

<p>
Auf den meisten Plattformen benutzt die OpenBSD-Installation einen
speziellen Kernel mit einigen Utilitys und Installationsskripten, die
sich auf einer vorgeladenen RAM-Disk befinden. Nachdem dieser Kernel
gebootet wurde, wird das Betriebssystem aus einigen komprimierten
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>-
(<tt>.tgz</tt>) -Dateien extrahiert.
Es existieren mehrere Wege, diesen Installationskernel zu booten:

<ul>
<li><b>Diskette:</b>
Diskettenimages werden zur Verfügung gestellt, die benutzt werden
können, um Installationsdisketten auf einem anderen
<a href="#UnixFlop">Unix-ähnlichen</a> System oder
<a href="#DosFlop">DOS/Windows</a>-System zu erstellen.
Typische Dateinamen sind <tt>floppy38.fs</tt>, obwohl für einige
Plattformen mehrere Diskettenimages vorhanden sind.

<li><b>CD-ROM:</b> Für einige Plattformen wird ein CD-ROM-Image
(<tt>cd38.iso</tt>) bereitgestellt, das die Erstellung von einer
bootfähigen CD-ROM ermöglicht. Dies beinhaltet nur den
Installationskernel - Installationsdateien müssen weiterhin via FTP
oder einer anderen Quelle beschaffen werden.
Du kannst natürlich deine eigene CD-ROM erstellen, die mit allen
Dateien und Programmen ausgestattet ist, die du haben möchtest.

<li><b><a href="#bsd.rd">bsd.rd</a>:</b> Der RAM-Disk-Kernel,
der dafür ausgelegt ist, entweder von einer bereits existierenden
OpenBSD-Partition oder über das Netzwerk gebootet zu werden.

<li><b>Netzwerk:</b> Manche Systeme unterstützen das Booten über
das Netzwerk (zum Beispiel unter Verwendung von
<a href="faq6.html#PXE">PXE</a> oder einem anderen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8">Netzwerkbootprozess</a>).

<li><b>Ein Dateisystemimage auf Platte schreiben:</b> ein
Dateisystemimage, das auf eine existierende Partition geschrieben und
daraufhin gebootet werden kann.

<li><b>Bootfähiges Band:</b> Einige Systeme unterstützen das Booten
von Band. Diese Bänder können anhand der
INSTALL.<i>Plattform</i>-Anleitung erstellt werden.

</ul>

Nicht jede <a href="../../de/plat.html">Plattform</a> unterstützt alle
Bootmöglichkeiten:

<ul>
<li><a href="../../de/alpha.html"><b>alpha:</b></a> Diskette, CD-ROM,
das Schreiben eines Diskettenimages auf Festplatte.

<li><a href="../../amd64.html"><b>amd64:</b></a> Diskette, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../cats.html"><b>cats:</b></a> CD-ROM.

<li><a href="../../de/hp300.html"><b>hp300:</b></a> CD-ROM, Netzwerk.

<li><a href="../../de/hppa.html"><b>hppa:</b></a> Netzwerk.

<li><a href="../../de/i386.html"><b>i386:</b></a> Diskette, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../de/mac68k.html"><b>mac68k:</b></a> Unter Verwendung
von Anwendungen unter Mac OS gebootet.
Siehe
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.8/mac68k/INSTALL.mac68k">INSTALL.mac68k</a>
für Details.

<li><a href="../../de/macppc.html"><b>macppc:</b></a> CD-ROM, Netzwerk.

<li><a href="../../de/mvme68k.html"><b>mvme68k:</b></a> Netzwerk,
bootfähiges Band.

<li><a href="../../de/mvme88k.html"><b>mvme88k:</b></a> Netzwerk,
bootfähiges Band.

<li><a href="../../de/sparc.html"><b>sparc:</b></a> Diskette, CD-ROM,
Netzwerk, Schreiben eines Images auf eine existierende Partition.

<li><a href="../../de/sparc64.html"><b>sparc64:</b></a> Diskette
(nur U1/U2), CD-ROM, Netzwerk, Schreiben eines Images auf eine
existierende Partition.

<li><a href="../../de/vax.html"><b>vax:</b></a> Diskette, Netzwerk.

</ul>

Alle Plattformen können ebenfalls einen
<a href="#bsd.rd">bsd.rd</a> zum Neuinstallieren oder
Aktualisieren verwenden.

<p>
Wenn der Installationskernel erst einmal gebootet ist, hast du mehrere
Möglichkeiten, von wo aus du die <a href="#FilesNeeded"
>Installations-Dateisets</a> herbekommen kannst. Auch hier bietet nicht
jede Plattform alle Möglichkeiten.

<ul>
<li><b>CD-ROM:</b> Natürlich bevorzugen wir, dass du das
<a href="../../de/orders.html">offizielle CD-ROM-Set</a> verwendest,
aber für spezielle Notwendigkeiten kannst du auch dein eigenes
erstellen.

<li><b>FTP:</b>
Entweder einen der
OpenBSD-<a href="../../de/ftp.html">FTP-,mirrors'</a>
oder deinen eigenen FTP-Server, der die Dateisets hält.

<li><b>HTML:</b>
Entweder einen der
OpenBSD-<a href="../../de/ftp.html#http">HTTP-,mirrors'</a>
oder deinen eigenen Webserver, der die Dateisets hält.

<li><b>Lokale Festplattenpartition:</b>
In vielen Fällen kannst du die Dateisets von einer anderen Partition
einer lokalen Festplatte aus installieren.
Zum Beispiel auf <a href="../../de/i386.html">i386</a> kannst du von
einer FAT-Partition oder einer CD-ROM mit ISO9660-, Rock-Ridge- oder
Joliet-Format aus installieren.
In einigen Fällen musst du das Dateisystem manuell einbinden, bevor
du es verwenden kannst.

<li><b>NFS:</b>
Manche Plattformen unterstützen NFS-mounts für die Dateisets.

<li><b>Band:</b>
Dateisets können ebenfalls von einem unterstützten Band
gelesen werden.
</ul>

<a name="Checklist"></a>
<h2>4.2 - Checkliste für die Installation</h2>

<p>
Bevor du mit der eigentlichen Installation beginnst, solltest du dir im
Klaren sein, was du eigentlich am Ende haben willst.

Mindestens die folgenden Punkte sollten daher vorher geklärt sein:
<ul>
<li>Name der Maschine
<li>Die installierte Hardware
  <ul>
  <li>Prüfe die Kompatibilität anhand der
      Kompatibilitätsseite für deine Hardware.
  <li>Wenn du ISA-Komponenten verwendest, musst du die Einstellungen
      kennen und prüfen, ob sie den Anforderungen von OpenBSD
      entsprechen.
  </ul>
<li>Die gewünschte Installationsmethode. (CDROM, FTP, etc.)
<li>Wie soll das System aktualisiert und gepatcht werden?
  <ul>
  <li>Wenn es lokal ausgeführt werden soll, musst du
      <a href="#SpaceNeeded">genügend freien Speicher</a> für den
      Source-Tree und dessen Erzeugung haben.
  <li>Ansonsten musst du Zugriff auf eine andere Maschine haben, das ein
      gepatchtes
      <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=release&amp;sektion=8">release</a>
      zur Verfügung stellt.
  </ul>
<li>Das erwünschte Plattenlayout
  <ul>
  <li>Müssen vorhandene Daten irgendwo gesichert werden?
  <li>Soll OpenBSD neben einem anderen Betriebssystem auf dem Rechner
      existieren? Wenn ja, auf welche Weise sollen die beiden Systeme
      gebootet werden? Brauchst du vielleicht einen Bootmanager?
  <li>Wird OpenBSD die ganze Festplatte belegen oder möchtest du eine
      existierende Partition/ein existierendes OS behalten (oder Platz
      für zukünftige Dinge)?
  <li>Wie willst du die OpenBSD-Partition selbst aufteilen?
  </ul>
<li>Netzwerk-Einstellungen, falls du nicht DHCP verwendest:
  <ul>
  <li>Domänenname
  <li>,Domain Name Server(s)'- (DNS) -Adresse
  <li>IP-Adressen und Subnetzmasken für jede Netzwerkkarte.
  <li>Gateway-Adressen
  </ul>
<li>Wirst du auf diesem System X benutzen?
</ul>


<a name="MkInsMedia"></a>
<h2>4.3 - Bootfähige OpenBSD-Installationsmedien erzeugen</h2>

<p>
Als Beispiel werden wir die Installationsmedien betrachten, die für
die <a href="../../de/i386.html">i386</a>- und
<a href="../../de/sparc.html">sparc</a>-Plattformen bereitstehen.

<p>
Die <a href="../../de/i386.html">i386</a> Plattform besitzt sechs
separate Installations-Diskimages, die ausgewählt werden können:

<ul>
<li><b><tt>floppy38.fs</tt></b> (Desktop-PC) unterstützt viele
  PCI- und ISA-Netzwerkkarten (NICs), IDE- und einfache SCSI-Adapter
  und bietet wenig Unterstützung für PCMCIA. Die meisten Benutzer
  werden dieses Image verwenden, wenn sie von einer Diskette aus
  booten.
<li><b><tt>floppyB38.fs</tt></b> (Server) unterstützt viele
  RAID-Controller und einige der selteneren SCSI-Adapter. Viele der
  Standard-SCSI-Adapter und viele EISA- und ISA-Netzwerkkarten werden
  nicht unterstützt.
<li><b><tt>floppyC38.fs</tt></b> (Laptops) unterstützt viele der
  Cardbus- und PCMCIA-Karten, die man in Laptops findet.
<li><b><tt>cdrom38.fs</tt></b> ist eine Kombination aller drei anderen
  Bootdisketten. Kann dazu verwendet werden, eine bootfähige
  2,88-M-Diskette zu erzeugen.
<li><b><tt>cd38.iso</tt></b> ist ein ISO9660-Image, das zum Erstellen
  einer bootfähigen CD mit den bekanntesten
  CD-ROM-Brennsoftwareprodukten auf den meisten Plattformen verwendet
  werden kann. Dieses Image hat die größte Auswahl an Treibern und ist
  normalerweise die empfohlene Wahl, wenn deine Hardware von CDROM
  booten kann.
<li><b><tt>cdemu38.iso</tt></b> ist ein ISO9660-Image, das zum Booten
  eine Diskettenemulation benutzt - und zwar das 2,88-M-Image
  <tt>cdrom36.fs</tt>. Hoffentlich brauchen nur wenige Leute dieses
  Image - die meisten Leute werden <tt>cd38.iso</tt> benutzen; verwende
  <tt>cdemu38.iso</tt> nur, wenn <tt>cd38.iso</tt> bei dir nicht
  funktioniert.
</ul>

Ja, es kann Situationen geben, in denen du eine Diskette für deinen
SCSI-Controller brauchst und eine andere für deine Netzwerkkarte.
Zum Glück geschieht das selten und kann normalerweise vermieden werden.

<p>
Die <a href="../../de/sparc.html">sparc</a>-Plattform besitzt drei
separate Installations-Diskimages, die ausgewählt werden können.

<ul>
<li><b><tt>floppy38.fs:</tt></b> Unterstützt Systeme mit
  Diskettenlaufwerk.
<li><b><tt>cd38.iso</tt></b> Ein ISO-Image, das zum Erstellen einer
  CD verwendet werden kann, um SPARC-Systeme von einer CD-ROM aus booten
  zu können.
<li><b><tt>miniroot38.fs</tt></b> Kann auf eine Swap-Partition
  geschrieben und gebootet werden.
</ul>

<a name="MkFlop"></a>
<a name="UnixFlop"></a>
<h3>4.3.1 - Disketten unter Unix erzeugen</h3>

<p>
Um eine formatierte Diskette zu erzeugen, benutze einfach das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdformat&amp;sektion=1&amp;arch=i386">fdformat(1)</a>-Kommando,
damit kannst du deine Diskette sowohl formatieren als auch auf defekte
Sektoren prüfen.

<p>
<table border=0 width="650"> <tr> <td nowrap bgcolor="#EEEEEE"><pre>
  # <b>fdformat /dev/rfd0c</b>
  Format 1440K floppy `/dev/rfd0c'? (y/n): y
  Processing VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV done.
</pre></td></tr> </table>

<p>
Ist deine Ausgabe wie im obigen Beispiel, dann ist deine Floppy in
Ordnung. Wenn du, warum auch immmer, nicht ALLE ,V's siehst, dann ist
deine Diskette höchstwahrscheinlich fehlerhaft und du solltest eine neue
verwenden.

<p>
Bedenke, dass einige Unix-ähnliche Systeme verschiedene Befehle zum
Formatieren von Disketten haben.
Konsultiere das Handbuch deines Systems für den exakten Ablauf.

<p>
Hast du dann eine korrekt formatierte Diskette, ist es an der Zeit, das
Installationsimage auf die Diskette zu schreiben. Wenn du sie auf einer
OpenBSD-Maschine oder auf einem anderen UNIX-ähnlichen OS erstellst,
kannst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=0">dd(1)</a>
verwenden.
Ein Beispiel für <tt>dd(1)</tt> findest du hier:

<p>
<table border=0 width="650"> <tr> <td nowrap bgcolor="#EEEEEE"><pre>
  # <b>dd if=floppy38.fs of=/dev/rfd0c bs=32k</b>
</pre></td></tr></table>

<p>
Ist das Image geschrieben, überprüfe es mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cmp&amp;sektion=1">cmp(1)</a>-Befehl,
um sicherzugehen, dass die Kopie dem Original entspricht. Wenn Diskette
und Image identisch sind, wirst du einfach einen weiteren Prompt sehen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cmp /dev/rfd0c floppy38.fs</b>
</pre></td> </tr> </table>

<a name="DosFlop"></a>
<h3>4.3.2 - Disketten unter Windows oder DOS erzeugen</h3>

<p>
Dieses Kapitel beschreibt, wie man Installationsimages unter Windows
oder DOS auf eine Diskette schreibt.
Du kannst die Anwendungen, die unten erwähnt werden, aus dem
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.8/tools/">tools</a>-Verzeichnis
von einem der FTP-,mirror' oder aus dem
<tt>3.8/tools</tt>-Verzeichnis auf CD1 des OpenBSD-CD-Sets bekommen.

<p>
Zur Vorbereitung der Diskette unter MS-DOS oder Windows benutzt man
einfach die bordeigenen Mittel zum Formatieren.

<p>
Das Installationsimage wird mittels
<i>rawrite</i>, <i>fdimage</i> oder <i>ntrw</i> auf die formatierte
Diskette geschrieben. <i>rawrite</i> funktioniert nicht unter
Windows NT, 2000 oder XP.

<p>
Bedenke, dass <tt>FDIMAGE.EXE</tt> und <tt>RAWRITE.EXE</tt>
MS-DOS-Applikationen sind und daher auch den
,8.3'-Dateinamen-Beschränkungen von MS-DOS unterliegen.
Da sowohl <tt>floppyB38.fs</tt> als auch <tt>floppyC38.fs</tt> längere
Dateinamen haben, wirst du überprüfen müssen,
wie dein System die Dateien an sein ,8.3'-Format angepasst hat,
bevor du <tt>FDIMAGE.EXE</tt> oder <tt>RAWRITE.EXE</tt> benutzen
kannst, um deine Bootdiskette zu schreiben.

<p>
Ein Beispiel für <i>rawrite</i>:
<table border=0 width="650"> <tr> <td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <b>rawrite</b>
  RaWrite 1.2 - Write disk file to raw floppy diskette

  Enter source file name: <b>floppy38.fs</b>
  Enter destination drive: <b>a</b>
  Please insert a formatted diskette into drive A: and press -ENTER- : <i><b>Enter</b></i>
</pre> </td> </tr> </table>

<p>
Eine Beispielanwendung von <i>fdimage</i>:
<table border=0 width="650"> <tr> <td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <strong>fdimage -q floppy38.fs a:</strong>
</pre></td></tr></table>

<p>
Eine Beispielanwendung von <i>ntrw</i>:
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <strong>ntrw floppy38.fs a:</strong>
  3.5", 1.44MB, 512 bytes/sector
  bufsize is 9216
  1474560 bytes written
</pre></td></tr></table>

<a name="MkCD-ROM"></a>
<h3>4.3.3 - Eine Boot-CD erzeugen</h3>

<p>
Um eine CD-ROM zu erstellen, kannst du die <tt>cd38.iso</tt>-Datei
verwenden, oder, im Falle der i386- und am64-Plattformen, kannst du
auch <tt>cdrom38.fs</tt> als bootfähiges Diskettenimage nutzen, das zum
Booten des i386-Systems von CD-ROM aus dient. Das Herausfinden der
exakten Details mit den zur Verfügung stehenden Anwendungen sei an
dieser Stelle dem Leser überlassen.

<p>
Einige der Anwendungen unter OpenBSD sind:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mkhybrid&amp;sektion=8">mkhybrid(8)</a>
<li><a href="http://cdrecord.berlios.de/old/private/cdrecord.html">cdrecord</a>,
Teil der cdrtools-Kollektion im
<a href="faq15.html">Packages- und Portssystem von OpenBSD</a>.
</ul>

<a name="Boot"></a>
<h2>4.4 - Das Booten der OpenBSD-Installationsimages</h2>

<h3>i386/amd64 booten</h3>

Das Installationsimage auf den i386- und am64-PC-Architekturen zu booten
ist nichts Neues für die meisten Leute. Wenn du die Diskette verwendest,
dann lege sie einfach in dein Diskettenlaufwerk und starte dein System.
Das Installationsimage wird automatisch laden, wenn in deinem BIOS das
Booten von Diskette aktiviert ist. Wenn du von CD starten willst, dann
musst du im System-BIOS das Booten von CD-ROM erlauben. Einige
ältere BIOSe haben diese Option nicht und du musst eine Diskette
zum Starten des Installationsimages verwenden. Keine Sorge, du kannst
auch dann von CD installieren, wenn von Diskette gebootet wurde.

<p>
Du kannst ebenfalls installieren, indem du <a href="#bsd.rd">bsd.rd</a>
von einer existierenden OpenBSD-Partition oder vom Netzwerk unter
Verwendung vom <a href="faq6.html#PXE">PXE-Bootprozess</a> aus bootest.

<h3>sparc/sparc64 booten</h3>

<b>HINWEIS:</b>
Auf der <a href="../../de/sparc64.html">sparc64</a>-Plattform können nur
die SBus-Maschinen (Ultra 1, Ultra 2) von einer Diskette aus gebootet
werden.

<p>
Um von Diskette zu starten, lege die OpenBSD-Installationsdiskette in
das Diskettenlaufwerk ein.
Dann verwende folgendes Kommando, um von der Diskette zu booten:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot floppy</b>
</pre></td></tr></table>

<p>
Um von CD-ROM zu starten, lege die OpenBSD-CD-ROM in dein Laufwerk.
Wenn deine Sun nur ein CD-ROM Laufwerk hat, dann gehe an den Bootprompt,
an dem du ,<tt>boot cdrom</tt>' ausführen kannst:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot cdrom</b>
</pre></td></tr></table>

<p>
Natürlich wird dies nur im neuen Befehlsmodus funktionieren. Wenn
du am alten Befehlsmodus bist (ein rechter Pfeil), gib ,n' ein, um in
den neuen zu gelangen (Wenn du eine alte sparc vor sun4c hast, dann
hast du vielleicht keinen neuen Befehlsmodus: Hier hilft dir nur
experimentieren). Wenn du mehrere CD-ROM-Laufwerke hast, dann musst du
vom richtigen starten. Verwende <tt>probe-scsi</tt> im neuen
Befehlsmodus.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>probe-scsi</b>

  Target 0
    Unit 0   Disk     QUANTUM LIGHTNING 365S
  Target 1
    Unit 0   Removable Disk     QUANTUM EMPIRE_1080S
  Target 3
    Unit 0   Removable Disk     Joe's CD ROM
</pre></td></tr></table>

<p>
Suche das richtige CD-ROM und merke dir die ,target'-Nummer.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot /sbus/esp/sd@X,0</b>
</pre></td></tr></table>


<a name="Install"></a>
<h2>4.5 - Eine Installation durchführen</h2>
<a name="Start"></a>
<h3>4.5.1 - Mit der Installation beginnen</h3>
<!-- XXXrelease -->
Was auch immer du für eine Methode zum Booten gewählt hast, nun ist es
an der Zeit, sie zu benutzen. Während des Bootprozesses werden der
Kernel und alle Programme zum Installieren von OpenBSD in den
Hauptspeicher geladen. Die größten Probleme entstehen beim Booten von
defekten Disketten oder bei der Zuweisung von Festplatten. Die
Bootdiskette ist ziemlich vollgepackt - jeder defekte Block wird
Probleme verursachen.

<p>
An fast jeder Stelle während des OpenBSD-Installationsprozesses kannst
du den aktuellen Installationsversuch abbrechen, indem du STRG-C
drückst, und kannst ihn ohne Neustart durch Aufruf von <tt>install</tt>
im Shellprompt wieder beginnen.

<p>
Wenn das Booten erfolgreich war, wirst du eine Menge Textmeldungen
vorbeiziehen sehen. Dieser Text, bei vielen Plattformen in weißer
Schrift auf blauem Hintergrund, ist die sogenannte
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg</a>,
der Kernel erzählt dir, welche Geräte gefunden wurden und wo.
Mach dir nicht die Mühe, den Text zu behalten, eine Kopie davon wird
in <tt>/var/run/dmesg.boot</tt> gespeichert. Auf den meisten
Architekturen kannst du mittels SHIFT+BILD AUF den Text wieder
zurückholen, der bereits vorbeigelaufen ist.

<p>
Dann wirst du das Folgende sehen:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  rootdev=0x1100 rrootdev=0x2f00 rawdev=0x2f02
  erase ^?, werase ^W, kill ^U, intr ^C, status ^T
  (I)nstall, (U)pgrade or (S)hell? <b>i</b>
</pre></td></tr></table>

<p>
Und damit erreichen wir auch schon die erste Frage. Meistens werden die
drei Möglichkeiten angeboten:
<ul>
<li><b>Install:</b> OpenBSD auf dein System installieren und dabei
alles überschreiben, was dort vorher war. Natürlich kann man hier auch
einige Teile der Festplatte unberührt lassen, wie zum Beispiel
<tt>/home</tt>, aber ansonsten wird alles andere überschrieben.
<li><b>Upgrade:</b> Installiere neue Sets an <a href="#FilesNeeded"
>Installationsdateien</a> auf dieser Maschine, aber überschreibe keine
Konfigurationsdateien, Benutzerdaten oder zusätzliche Programme.
Es wird keine Festplattenformatierung vorgenommen und auch die
Verzeichnisse /etc und /var werden nicht überschrieben.
Ein paar wichtige Hinweise:
<ul>
<li> Dir wird nicht die Möglichkeit angeboten, <tt>etc38.tgz</tt> zu
installieren. Nach der Installation musst du die Änderungen von
<tt>etc38.tgz</tt> selbst in dein System einbinden, bevor du erwarten
kannst, dass es voll funktionsfähig sein wird. Das zu tun ist dann sehr
wichtig, da sonst einige Dienste (wie z.&nbsp;B.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4">pf(4)</a>)
möglicherweise nicht starten werden.

<li>Der Upgradeprozess ist nicht dazu da, um ganze Versionen
zu überspringen! Obwohl das meist funktioniert, wird es in keinem Fall
unterstützt. Bei OpenBSD 3.8 wird nur das Upgrade von 3.7 her
unterstützt. Bei allen älteren Versionen sollte man unbedingt neu
installieren.<br>

</ul>

<li><b>Shell:</b> Manchmal muss man Reparaturen oder Schritte
unternehmen, da das System sonst nicht mit einem normalen Kernel booten
wird. Dazu ist diese Option gedacht.
</ul>

In einigen Fällen wirst du die ,Upgrade'-Option nicht vorfinden.
Nach einem ,<i>flag day</i>' ist es zum Beispiel nicht möglich, ein
direktes Upgrade zu machen, daher muss man das System von Grund auf
neuinstallieren.

<p>
In diesem Beispiel machen wir eine Installation, der Upgradeprozess
ist aber recht ähnlich.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Welcome to the OpenBSD/i386 3.8 install program.

  This program will help you install OpenBSD in a simple and rational way. At
  any prompt except password prompts you can run a shell command by typing
  '!foo', or escape to a shell by typing '!'. Default answers are shown in []'s
  and are selected by pressing RETURN. At any time you can exit this program by
  pressing Control-C and then RETURN, but quitting during an install can leave
  your system in an inconsistent state.

  Specify terminal type: [vt220] <b><i>Enter</i></b>
  kbd(8) mapping? ('?' for list) [none] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
In den meisten Fällen ist der vorgeschlagene Terminaltyp passend,
solltest du allerdings eine
<a href="faq7.html#SerCon">serielle Konsole</a> für die Installation
benutzen, wähle bitte die passende Konsole aus, nicht die
vorgeschlagene.

<p>
Wenn du keine Tastaturbelegung (keyboard encoding table) auswählst,
wird die US-Tastaturbelegung benutzt.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IS YOUR DATA BACKED UP? As with anything that modifies disk contents, this
  program can cause SIGNIFICANT data loss.

  It is often helpful to have the installation notes handy. For complex disk
  configurations, relevant disk hardware manuals and a calculator are useful.

  Proceed with install? [no] <b>y</b>
</pre></td></tr></table>

<p>
Wenn du hier die vorgeschlagene Antwort gibst, landest du in einer Shell
und bekommst einen Prompt, nachdem die Installation sich beendet hat.

<a name="Disks"></a>
<h3>4.5.2 - Festplatte(n) einrichten</h3>

<p>
Die Laufwerke unter OpenBSD einzurichten ist für alle Plattformen ein
wenig unterschiedlich. Bei <a href="../../de/i386.html">i386</a>,
<a href="../../amd64.html">amd64</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/zaurus.html">zaurus</a> und
<a href="../../cats.html">cats</a>
geschieht das Einrichten in zwei Etappen. Die eine geschieht mit
fdisk(8) und die andere mit disklabel(8).

<p>
Der ein oder andere wird ein wenig verwundert über die hier verwendete
Terminologie sein. Es sieht so aus, als ob wir das Wort ,Partition'
auf zwei verschiedene Weisen benutzen. Diese Beobachtung ist richtig.
Es gibt zwei Schichten von Partitionierung auf verschiedenen
OpenBSD-Plattformen, die erste könnte man als
Betriebssystempartitionierung bezeichnen, so etwa legen viele
Betriebssysteme ihre Partitionen an, und die zweite bezieht sich darauf,
wie OpenBSD seine Partition in weitere individuelle Dateisysteme
einteilt. Die erste Schicht ist sichtbar als eine Partition für DOS,
Windows und jedes weitere Betriebssystem auf den IBM-kompatiblen
Maschinen. Die zweite Schicht dagegen ist nur für OpenBSD und solche
Systeme sichtbar, die OpenBSD-Dateisysteme direkt lesen können.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Cool!  Let's get to it...

  You will now initialize the disk(s) that OpenBSD will use. To enable all
  available security features you should configure the disk(s) to allow the
  creation of separate filesystems for /, /tmp, /var, /usr, and /home.

  Available disks are: wd0.
  Which one is the root disk? (or done) [wd0] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Die ,root disk' ist die Festplatte, von der das System booten soll
und wo sich normalerweise der Swapbereich befindet. 
IDE-Fesplatten werden als <tt>wd0</tt>, <tt>wd1</tt>, etc. angezeigt,
SCSI-Festplatten und RAIDs als <tt>sd0</tt>, <tt>sd1</tt> und so weiter.
Alle Festplatten, die OpenBSD finden kann, sind hier aufgelistet --
wenn du welche hast, die hier nicht auftauchen, sind sie vermutlich
falsch konfiguriert oder werden gar nicht unterstützt.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want to use *all* of wd0 for OpenBSD? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Wenn du diese Frage mit ,yes' beantwortest, wird die gesamte Festplatte
für OpenBSD benutzt. Das resultiert in einem standardmäßigen
,Master Boot Record' und einer Partitionstabelle, die beide auf die
Festplatte geschrieben werden - eine Partition, die die ganze Festplatte
einnimmt, den OpenBSD-Partitionstyp hat und als bootfähig gekennzeichnet
ist. Das ist für die meisten Produktionssysteme unter OpenBSD die
brauchbarste Lösung, auf manchen Systemen sollte man das allerdings
nicht so machen. Viele Compaq-Systeme, viele Laptops, einige Dell- und
ein paar andere Systeme benutzen eine ,maintenance'-Partition, die
unbedingt intakt bleiben muss. Wenn dein System einige Partitionen hat,
die du nicht löschen willst, solltest du auf keinen Fall mit ,yes'
antworten.

<p>
Für dieses Beispiel nehmen wir an, dass die Festplatte zwischen OpenBSD
und einer bereits existierenden Installation von Windows 2000 aufgeteilt
werden soll, also beantworten wir die Frage hier mit ,no', was uns in
das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Programm
bringt. Mehr Informationen über fdisk findest du
<a href="faq14.html#fdisk">hier</a>.

<p>
<b>Wichtiger Hinweis:</b>
Benutzer mit einer großen Festplatte (größer als das, was normal war,
als dein Rechner hergestellt wurde) sollten unbedingt
<a href="faq14.html#LargeDrive">diese Sektion</a> lesen, bevor sie
weitermachen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  You will now create a single MBR partition to contain your OpenBSD data. This
  partition must have an id of 'A6'; must *NOT* overlap other partitions; and
  must be marked as the only active partition.

  The 'manual' command describes all the fdisk commands in detail.

  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 0B    0   1  1 -  202 239 63 [          63:     3069297 ] Win95 FAT-32
   1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  Enter 'help' for information
  fdisk: 1> <b>help</b>
          help            Command help list
          manual          Show entire OpenBSD man page for fdisk
          reinit          Re-initialize loaded MBR (to defaults)
          setpid          Set the identifier of a given table entry
          disk            Edit current drive stats
          edit            Edit given table entry
          flag            Flag given table entry as bootable
          update          Update machine code in loaded MBR
          select          Select extended partition table entry MBR
          swap            Swap two partition entries
          print           Print loaded MBR partition table
          write           Write loaded MBR to disk
          exit            Exit edit of current MBR, without saving changes
          quit            Quit edit of current MBR, saving current changes
          abort           Abort program without saving current changes
  fdisk: 1> 
</pre></td></tr></table>

<p>
Ein paar Befehle sollten wir uns näher ansehen:
<ul>
<li><b><tt>r</tt></b> oder <b><tt>reinit</tt>:</b> Löscht eine
vorhandene Partitionstabelle und erzeugt eine große OpenBSD-Partition,
diese wird als aktiv markiert, und installiert den OpenBSD-MBR-Code.
Ist das gleiche, als ob man mit ,yes' auf die
,<tt>use *all* of ...</tt>'-Frage antwortet.
<li><b><tt>p</tt></b> oder <b><tt>print:</tt></b> Zeigt die aktuelle
Partitionstabelle in Sektoren an. ,<tt>p m</tt>' dagegen zeigt die
Tabelle in MegaBytes an, ,<tt>p g</tt>' in GigaBytes.
<li><b><tt>e</tt></b> oder <b><tt>edit:</tt></b> Editieren oder
Ändern eines Tabelleneintrags.
<li><b><tt>f</tt></b> oder <b><tt>flag:</tt></b> Markiert eine Partition
als die aktive Partition, diejenige, von der gebootet wird.
<li><b><tt>u</tt></b> oder <b><tt>update:</tt></b> Aktualisiert den MBR
mit dem OpenBSD-Bootcode, ähnlich wie ,<tt>reinit</tt>', nur dass es die
bestehende Partitionstabelle nicht verändert.
<li><b><tt>exit</tt></b> und <b><tt>quit:</tt></b> Sei hiermit
vorsichtig, da einige Anwender nicht daran gewöhnt sind, dass
,exit' und ,quit' verschiedene Bedeutungen haben.
</ul>

Es ist nochmals wichtig darauf hinzuweisen, dass ein Fehler hier
durchaus im Verlust von Daten resultieren kann. Wenn du das
hier auf einer Platte mit wertvollen Daten machst, solltest du
vielleicht vorher auf einer ,Test'-Platte proben, zumal du
dann noch ein gutes Backup hast.

<p>
Unsere Festplatte hier hat eine 1,5-G-Partition für Windows 2000
(mit dem FAT-Dateisystem). Die Info oben zeigt, dass die
Windows-Partition bis zum Zylinder 202 reicht. Also werden wir den Rest,
sprich ab Zylinder 203, für OpenBSD reservieren. Du kannst auch den
Startsektor von OpenBSD berechnen (3069360), indem du den Startsektor
(63) und die Größe (3069297) zu der bereits vorhandenen Partition (hier
Windows 2000 mit FAT) addierst.

<p>
Du kannst das Festplatten-Layout entweder in Form von Cylinder/Heads/Sectors
editieren, oder auch in Form reiner Sektoren. Was einfacher ist, hängt
davon ab, was du tun willst, in diesem Fall ist es wahrscheinlich
einfacher das CHS Format zu benutzen.
Wenn du die erste Partition auf der Festplatte erstellst, ist das Verwenden
von reinen Sektoren wahrscheinlich einfacher.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk: 1> <b>e 1</b>
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>a6</b>
  Do you wish to edit in CHS mode? [n] <b>y</b>
  BIOS Starting cylinder [0 - 2585]: [0] <b>203</b>
  BIOS Starting head [0 - 239]: [0] <b><i>Enter</i></b>
  BIOS Starting sector [1 - 63]: [0] <b>1</b>
  BIOS Ending cylinder [0 - 2585]: [0] <b>2585</b>
  BIOS Ending head [0 - 239]: [0] <b>239</b>
  BIOS Ending sector [1 - 63]: [0] <b>63</b>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 0B    0   1  1 -  202 239 63 [          63:     3069297 ] Win95 FAT-32
   1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  fdisk:*1> <b>p m</b>
  Disk: wd0       geometry: 2586/240/63 [19092 Megabytes]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 0B    0   1  1 -  202 239 63 [          63:        1499M] Win95 FAT-32
   1: A6  203   0  1 - 2585 239 63 [     3069360:       17593M] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0M] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0M] unused
  fdisk:*1> 
</pre></td></tr></table>

<a name="trackoffset"></a>
<p>
Es ist wichtig, dass die erste Partition den ersten Track der Platte
auslässt, <i>in diesem Fall</i> also mit Sektor <tt>63</tt> beginnt.
Dies variiert von Maschine zu Maschine und Plattensystem zu
Plattensystem.
Wenn eine OpenBSD-Partition so erstellt wurde, dass sie mit einen Offset
von <tt>0</tt> beginnt, wird diese Partitionstabelle am Ende von dem
OpenBSD-,<a href="faq14.html#Boot386">Partition Boot Record</a>'
überschrieben. Das System könnte weiterhin bootfähig sein, aber es wird
sehr schwer verwaltbar sein und diese Konfiguration ist
<i>weder empfohlen noch unterstützt</i>.

<p>
Wie du sehen kannst, wurde der Prompt um einen Asterisk (,<tt>*</tt>')
erweitert, um anzuzeigen, dass du noch nicht gespeicherte Änderungen
gemacht hast. Wie wir an der Ausgabe von <tt>p&nbsp;m</tt> sehen können,
haben wir unsere Windows-Partition nicht geändert, wir haben den Rest
der Platte erfolgreich an OpenBSD vergeben. Wir sind fertig. Fast.

<p>
Was wir noch nicht gemacht haben ist, die Partition als aktiv zu
markieren, so dass nach dem nächsten Neustart OpenBSD geladen wird:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>f 1</b>
  Partition 1 marked active.
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   0: 0B    0   1  1 -  202 239 63 [          63:     3069297 ] Win95 FAT-32
  *1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
Und nun sind wir soweit, dass wir unsere Änderungen speichern können:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>w</b>
  Writing MBR at offset 0.
  wd0: no disk label
  fdisk: 1> <b>q</b>
</pre></td></tr></table> 

<p>

<a name="disklabel"></a>
<h3>Ein Disklabel erzeugen</h3>
Im nächsten Schritt benutzen wir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>,
um die OpenBSD-Partition aufzuteilen. Mehr Details über Disklabel
finden sich in der
<a href="faq14.html#disklabel">FAQ 14, Disklabel</a>.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Here is the partition information you chose:
  
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   0: 06    0   1  1 -  202 239 63 [          63:     3069297 ] DOS > 32MB
  *1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused

  You will now create an OpenBSD disklabel inside the OpenBSD MBR
  partition. The disklabel defines how OpenBSD splits up the MBR partition
  into OpenBSD partitions in which filesystems and swap space are created.

  The offsets used in the disklabel are ABSOLUTE, i.e. relative to the
  start of the disk, NOT the start of the OpenBSD MBR partition.

  disklabel: no disk label
  WARNING: Disk wd0 has no label. You will be creating a new one.
  
  # using MBR partition 1: type A6 off 3069360 (0x2ed5b0) size 36030960 (0x225c9f0)

  Treating sectors 3069360-39100320 as the OpenBSD portion of the disk.
  You can use the 'b' command to change this.

  Initial label editor (enter '?' for help at any prompt)
  > <b>?</b>
  Available commands:
          ? [cmnd]  - this message or command specific help.
          a [part]  - add new partition.
          b         - set OpenBSD disk boundaries.
          c [part]  - change partition size.
          D         - set label to default.
          d [part]  - delete partition.
          e         - edit drive parameters.
          g [b|d|u] - use [b]ios, [d]isk or [u]ser geometry.
          M         - show entire OpenBSD man page for disklabel.
          m [part]  - modify existing partition.
          n [part]  - set the mount point for a partition.
          p [unit]  - print label.
          q         - quit and save changes.
          r         - recalculate free space.
          s [path]  - save label to file.
          u         - undo last change.
          w         - write label to disk.
          X         - toggle expert mode.
          x         - exit without saving changes.
          z         - zero out partition table.
          ? [cmnd]  - this message or command specific help.
  Numeric parameters may use suffixes to indicate units:
          'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm' for megabytes,
          'g' for gigabytes or no suffix for sectors (usually 512 bytes).
          '%' for percent of total disk size, '&' for percent of free space.
          Non-sector units will be rounded to the nearest cylinder.
  Entering '?' at most prompts will give you (simple) context sensitive help.
  > 
</pre></td></tr></table>

<p>
Wieder sollten wir uns einige Kommandos näher ansehen:
<ul>
<li><b><tt>p</tt></b> - zeigt (prints) den aktuellen Disklabel auf
dem Schirm und du kannst <tt>k, m</tt> oder <tt>g</tt> für
Kilobytes, Megabytes oder Gigabytes benutzen.

<li><b><tt>D</tt></b> - Löscht jeglichen exisitierenden Disklabel,
erzeugt einen neuen Disklabel, der nur die aktuelle OpenBSD-Partition
beinhaltet. Das kann nützlich sein, wenn die Festplatte vorher ein
Disklabel hatte und die OpenBSD-Partition mit einer anderen
Größe erneut erzeugt wurde -- das alte Disklabel wird vielleicht
nicht gelöscht und könnte Verwirrung stiften.

<li><b><tt>m</tt></b> - Modifiziert einen existierenden Eintrag in
einem Disklabel. Überschätze nicht, was das hier bedeutet. Obwohl es
die Größe einer Disklabel-Partition ändern kann, wird das Dateisystem
auf der Festplatte NICHT geändert. Diese Option zu benutzen und zu
erwarten, man könne damit bereits existierende Partitionen in der Größe
verändern, ist ein guter Weg, große Mengen an Daten zu verlieren.

</ul>

<p>
Es ist wichtig, deine Festplatte gut aufzuteilen. Die Antwort auf die
Frage ,Wie soll ich mein System partitionieren?' ist ,Genauso,
wie du es benötigst'. Das ist nunmal von Fall zu Fall verschieden.
Es gibt keine universelle Antwort. Wenn du nicht sicher bist, wie du
dein System partitionieren sollst, sieh dir
<a href="#SpaceNeeded">diesen Abschnitt</a> an.

<p>
In diesem System haben wir für OpenBSD über 17 G verfügbar. Das ist eine
Menge Platz und wir werden wahrscheinlich nie den ganzen Platz brauchen.
Wir werden also mit der Platzverteilung etwas großzügig sein. Es ist
besser, ein paar hundert Megabytes zuviel und unbenutzt zu haben als
auch nur ein Kilobyte zu wenig.

<p>
Auf der ,root disk' <b>müssen</b> mindestens die Partitionen ,a' und
,b' erzeugt werden. Die Installation wird ohne diese beiden Partitionen
abgebrochen. ,a' wird für das root-Dateisystem (/) und ,b' für
den Swapbereich benutzt.

<p>
Nach einer kleinen Denkpause haben wir uns entschieden, die Menge
an Partitionen zu erzeugen, die wir für die empfohlenen
separaten Dateisysteme brauchen (<tt>/, /tmp, /var, /usr, /home</tt>),
zusätzlich zu einer Swappartition:
<ul>
<li><i><b>wd0a: /</b></i> (root) - 150 M.  Sollte mehr als genug sein.
<li><i><b>wd0b: </b></i>(swap) - 300 M.
<li><i><b>wd0d: /tmp</b></i> - 120 M.  <tt>/tmp</tt> wird für das
  Erzeugen von Software gebraucht, 120 M wird für die meisten Dinge
  genug sein.
<li><i><b>wd0e: /var</b></i> - 80 M.  Wenn das ein Web- oder Mail-Server
  wäre, müsste diese Partition viel größer sein, aber das machen wir
  hier ja nicht.
<li><i><b>wd0g: /usr</b></i> - 3 G.  Wir brauchen den Platz hier für
  viele Benutzeranwendungen und außerdem wollen wir das System updaten
  und neu erzeugen können, wenn es notwendig wird. Der
  <a href="faq15.html#Ports">Ports-Tree</a> wird sich hier auch
  befinden und vor dem Erzeugen von Ports bereits 140 Megabyte Platz
  brauchen. Wenn du viele Applikationen aus den 
  <a href="faq15.html#Ports">Ports</a> bauen willst, statt dich der
  fertig kompilierten <a href="faq15.html#PkgMgmt">Packages</a> zu
  bedienen, benötigst du hier sehr viel mehr Platz.
<li><i><b>wd0h: /home</b></i> - 4 G.  Das lässt jede Menge Platz
  für Benutzerdateien.
</ul>

Wenn du das alles zusammenzählst, wirst du bemerken, dass über
10 G Plattenplatz unbenutzt sind! Unbenutzter Platz tut uns nicht weh
und gibt uns die Flexibilität, die Dinge in Zukunft zu vergrößern. Du
brauchst mehr <i>/tmp</i>? Kein Problem, erzeuge welchen im unbenutzten
Platz, ändere die Datei <i>/etc/fstab</i> und das Problem ist gelöst.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>p m</b>
  device: /dev/rwd0c
  type: ESDI
  disk: ESDI/IDE disk
  label: ST320011A
  bytes/sector: 512
  sectors/track: 63
  tracks/cylinder: 16
  sectors/cylinder: 1008
  cylinders: 16383
  total sectors: 39102336
  free sectors: 36030960
  rpm: 3600
  
  16 partitions:
  #             size        offset  fstype [fsize bsize  cpg]
    a:      17593.2M       1498.7M  unused      0     0      
    c:      19092.9M          0.0M  unused      0     0      
    i:       1498.7M          0.0M  MSDOS                   
  > <b>d a</b>
  > <b>a a</b>
  offset: [3069360] <b><i>Enter</i></b>
  size: [36030960] <b>150m</b>
  Rounding to nearest cylinder: 307440
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/</b>
  > <b>a b</b>
  offset: [3376800] <b><i>Enter</i></b>
  size: [35723520] <b>300m</b>
  Rounding to nearest cylinder: 614880
  FS type: [swap] <b><i>Enter</i></b>
  > <b>a d</b>
  offset: [3991680] <b><i>Enter</i></b>
  size: [35108640] <b>120m</b>
  Rounding to nearest cylinder: 245952
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/tmp</b>
  > <b>a e</b>
  offset: [4237632] <b><i>Enter</i></b>
  size: [34862688] <b>80m</b>
  Rounding to nearest cylinder: 164304
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var</b>
  > <b>a g</b>
  offset: [4401936] <b><i>Enter</i></b>
  size: [34698384] <b>3g</b>
  Rounding to nearest cylinder: 6291936
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr</b>
  > <b>a h</b>
  offset: [10693872] <b><i>Enter</i></b>
  size: [28406448] <b>4g</b>
  Rounding to nearest cylinder: 8388576
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/home</b>
  > <b>p m</b>
  device: /dev/rwd0c
  type: ESDI
  disk: ESDI/IDE disk
  label: ST320011A
  bytes/sector: 512
  sectors/track: 63
  tracks/cylinder: 16
  sectors/cylinder: 1008
  cylinders: 16383
  total sectors: 39102336
  free sectors: 22115520
  rpm: 3600
  
  16 partitions:
  #             size        offset  fstype [fsize bsize  cpg]
    a:        150.1M       1498.7M  4.2BSD   2048 16384   16 # /
    b:        300.2M       1648.8M    swap                   
    c:      19092.9M          0.0M  unused      0     0      
    d:        120.1M       1949.1M  4.2BSD   2048 16384   16 # /tmp
    e:         80.2M       2069.2M  4.2BSD   2048 16384   16 # /var
    g:       2048.0M       2149.4M  4.2BSD   2048 16384   16 # /usr
    h:       4096.0M       4197.4M  4.2BSD   2048 16384   16 # /home
    i:       1498.7M          0.0M   MSDOS                   
  > <b>q</b>
  Write new label?: [y] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Du wirst bemerken, dass wir die <i>c</i>-Partition scheinbar komplett
ignoriert haben. Diese Partition ist deine gesamte Festplatte, versuche
sie nicht zu verändern. Du wirst außerdem bemerkt haben, dass wir
die <i>i</i>-Partition nicht angelegt haben, denn das ist die bereits
existierende Windows-2000-Partition. Partitionen werden hier keinem
vorbestimmten Buchstaben zugewiesen, abgesehen von
<i>a</i> (root), <i>b</i> (swap) und <i>c</i> (gesamte Festplatte), der
Rest der Partitionen (über den Buchstaben <i>p</i>) kann verwendet
werden, wie man will.

<p>
Wenn du dir Ausgaben von disklabel genau ansiehst, wirst du vermutlich
feststellen, dass die Angabe des RPM falsch ist. Das ist historisch
bedingt, die Plattengeschwindigkeit wird in keiner Weise vom System
benutzt. Mach dir also keine Sorgen darüber.

<h3>Deine Mountpunkte konfigurieren und deine Dateisysteme
formatieren</h3>

Jetzt kommt die finale Konfiguration deiner Mountpunkte. Wenn du deine
Mountpunkte mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
konfiguriert hast, reicht es in diesem Schritt aus, deine Auswahl zu
bestätigen, und wenn nicht, kannst du sie nun angeben.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Mount point for wd0d (size=122976k)? (or 'none' or 'done') [/tmp] <b><i>Enter</i></b>
  Mount point for wd0e (size=82152k)? (or 'none' or 'done') [/var] <b><i>Enter</i></b>
  Mount point for wd0g (size=3145968k)? (or 'none' or 'done') [/usr] <b><i>Enter</i></b>
  Mount point for wd0h (size=4194288k)? (or 'none' or 'done') [/home] <b><i>Enter</i></b>
  Mount point for wd0d (size=122976k)? (or 'none' or 'done') [/tmp] <b>done</b>
  No more disks to initialize.
 
  OpenBSD filesystems:
  wd0a /
  wd0d /tmp
  wd0e /var
  wd0g /usr
  wd0h /home

  The next step *DESTROYS* all existing data on these partitions!
  Are you really sure that you're ready to proceed? [no] <b>y</b>
  /dev/rwd0a:     307440 sectors in 305 cylinders of 16 tracks, 63 sectors
          150.1MB in 1 cyl groups (306 c/g, 150.61MB/g, 19328 i/g)
  /dev/rwd0d:     245952 sectors in 244 cylinders of 16 tracks, 63 sectors
          120.1MB in 1 cyl groups (244 c/g, 120.09MB/g, 15360 i/g)
  /dev/rwd0e:     164304 sectors in 163 cylinders of 16 tracks, 63 sectors
          80.2MB in 1 cyl groups (164 c/g, 80.72MB/g, 10368 i/g)
  /dev/rwd0g:     6291936 sectors in 6242 cylinders of 16 tracks, 63 sectors
          3072.2MB in 20 cyl groups (328 c/g, 161.44MB/g, 20608 i/g)
  /dev/rwd0h:     8388576 sectors in 8322 cylinders of 16 tracks, 63 sectors
          4096.0MB in 26 cyl groups (328 c/g, 161.44MB/g, 20608 i/g)
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local, ctime=Thu Oct 20 00:03:14 2
  005)
  /dev/wd0h on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid, ctime=T
  hu Oct 20 00:03:14 2005)
  /dev/wd0d on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid, ctime=Th
  u Oct 20 00:03:15 2005)
  /dev/wd0g on /mnt/usr type ffs (rw, asynchronous, local, nodev, ctime=Thu Oct 20
   00:03:15 2005)
  /dev/wd0e on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid, ctime=Th
  u Oct 20 00:03:15 2005)

</pre></td></tr></table>

<p>
Du fragst dich wahrscheinlich, wieso dich das Installationsprogramm
schon wieder nach den Mountpunkten fragt. Das erlaubt dir, Fehler
oder Probleme mit der bisherigen Auswahl einfach auszuräumen. Der
Installationsprozess wird zum Beispiel doppelte Mountpunkte einfach
löschen. Im disklabel-Programm kannst du solche Doppeleingaben
machen und daher muss das überprüft werden. Eine solche
doppelte Nennung wird zu Partitionen ohne Mountpunkt führen, denen
du dann neue Mountpunkte zuweisen musst, wenn du den Platz darin
benutzen willst.

<p>
Wie du sehen kannst, lautet die vorgegebene Antwort auf die Frage
,Are you really sure that you are ready to proceed?' ,no', du musst also
ausdrücklich ,yes' antworten, damit das Programm weitermacht und
deine Partitionen formatiert. Wenn du das nicht tust, landest du wieder
in der Shell und könntest die Installation erneut starten, indem
du ,install' eingibst oder einfach erneut mit deiner Bootdisk
hochfährst.

<p>
An diesem Punkt werden nun alle deine Dateisysteme formatiert. Wie lange
das dauert hängt von der Größe der Partitionen und der Geschwindigkeit
deiner Festplatte ab.

<a name="Hostname"></a>
<h3>4.5.3 - Den Hostnamen des Systems setzen</h3>
<p>
Du musst dem System nun seinen Hostnamen geben. Dieser Wert, neben dem
DNS-Domänennamen (<a href="#Network">weiter unten</a> angegeben), wird
in der Datei <tt>/etc/myname</tt>, die beim normalen Booten des Systems
ausgelesen wird, gespeichert.
Wenn du den FQDN des Systems nicht setzt, wird der vorgeschlagene Wert
,my.domain' benutzt.

<p>
Es ist wichtig, diesen Namen jetzt zu setzen, da er beim ersten Booten
des Systems nach der Installation dabei benutzt wird, die
kryptographischen Schlüssel zu erzeugen. Dieses Erzeugen geschieht
unabhängig davon, ob das Netzwerk konfiguriert ist oder nicht.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Enter system hostname (short form, e.g. 'foo'): <b>puffy</b>
</pre></td></tr></table>

<a name="Network"></a>
<h3>4.5.4 - Das Netzwerk konfigurieren</h3>

<p>
Jetzt ist es an der Zeit, dein Netzwerk zu konfigurieren. Das muss
unbedingt geschehen, wenn du eine FTP- oder NFS-basierte Installation
durchführen willst, da die Daten dazu notwendig sind. Hier
ein Beispieldurchlauf für die Netzwerkkonfiguration.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Configure the network? [yes] <b><i>Enter</i></b>
  Available interfaces are: fxp0.
  Which one do you wish to initialize? (or 'done') [fxp0] <b><i>Enter</i></b>
  Symbolic (host) name for fxp0? [puffy] <b><i>Enter</i></b>
  The default media for fxp0 is
          media: Ethernet autoselect (100baseTX full-duplex)
  Do you want to change the default media? [no] <b><i>Enter</i></b>
  IP address for fxp0 (or 'dhcp')? <b>199.185.137.55</b>
  Netmask? [255.255.255.0] <b><i>Enter</i></b>
  IPv6 address for fxp0? (or 'rtsol' or 'none') [none] 
  No more interfaces to initialize.
  DNS domain name? (e.g. 'bar.com') [my.domain] <b>example.com</b>
  DNS nameserver? (IP address or 'none') [none] <b>199.185.137.1</b>
  Use the nameserver now? [yes] <b><i>Enter</i></b>
  Default route? (IP address, 'dhcp' or 'none') <b>199.185.137.128</b>
  add net default: gateway 199.185.137.128
  Edit hosts with ed? [no] <b><i>Enter</i></b>
  Do you want to do any manual network configuration? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Im obigen Beispiel nutzen wir eine statische IP-Adresse. Wie angedeutet,
kannst du aber auch ,<tt>dhcp</tt>' auf den meisten Plattformen (nicht
<a href="../../de/alpha.html">Alpha</a>) auswählen, davon ausgehend,
dass deine Netzwerkumgebung es unterstützt. Im Falle von
DHCP werden die meisten dieser Daten von dem entfernten DHCP-Server
geholt; du wirst eine Gelegenheit bekommen, das zu bestätigen.
Hier ist ein Beispiel des Netzwerkkonfigurationsteils der Installation,
dieses Mal mit DHCP:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Configure the network? [yes] <b><i>Enter</i></b>
  Available interfaces are: fxp0.
  Which one do you wish to initialize? (or 'done') [fxp0] <b><i>Enter</i></b>
  Symbolic (host) name for fxp0? [puffy] <b><i>Enter</i></b>
  The default media for fxp0 is
          media: Ethernet autoselect (100baseTX full-duplex)
  Do you want to change the default media? [no] <b><i>Enter</i></b>
  IP address for fxp0 (or 'dhcp')? <b>dhcp</b>
  Issuing hostname-associated DHCP request for fxp0.
  Sending on   Socket/fallback/fallback-net
  DHCPDISCOVER on fxp0 to 255.255.255.255 port 67 interval 1
  DHCPOFFER from 199.185.137.128
  DHCPREQUEST on fxp0 to 255.255.255.255 port 67
  DHCPACK from 199.185.137.128
  New Network Number: 199.185.137.0
  New Broadcast Address: 199.185.137.255
  bound to 199.185.137.55 -- renewal in 43200 seconds.
  Done - no available interfaces found.
  DNS domain name? (e.g. 'bar.com') [example.org] <b><i>Enter</i></b>
  DNS nameserver? (IP address or 'none') [199.185.137.1] <b><i>Enter</i></b>
  Use the nameserver now? [yes] <b><i>Enter</i></b>
  Default route? (IP address, 'dhcp' or 'none') [199.185.137.128] <b><i>Enter</i></b>
  Edit hosts with ed? [no] <b><i>Enter</i></b>
  Do you want to do any manual network configuration? [no] <b><i>Enter</i></b>
</pre></td></tr></table>
<p>
<b>HINWEIS: </b>Nur <b>ein</b> Interface kann während der
Installation einfach mit DHCP konfiguriert werden. Es wird Fehler geben,
wenn du das mehrmals versuchst. Die anderen Interfaces musst du dann
nach der Installation per Hand konfigurieren.

<p>
Nun setzen wir das Passwort für den root-Account:
<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
Password for root account? (will not echo) <b><i>pAssWOrd</i></b>
Password for root account? (again) <b><i>pAssWOrd</i></b>
</pre></td></tr></table>
<p>
Verwende ein sicheres Passwort für den root-Account. Du wirst weitere
Benutzerkonten anlegen, wenn das System gebootet wurde. Aus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=passwd&amp;sektion=1">passwd(1)</a>:
<pre>
    The new password should be at least six characters long and not purely
    alphabetic.  Its total length must be less than _PASSWORD_LEN (currently
    128 characters).  A mixture of both lower and uppercase letters, numbers,
    and meta-characters is encouraged.
</pre>

<a name="InstMedia"></a>
<h3>4.5.5 - Das Installationsmedium auswählen</h3>

<p>
Nachdem dein Netzwerk eingerichtet ist, hast du die Chance, deine
Einstellungen per Hand zu justieren.

<p>
Danach bekommst du die Chance, dein Installationsmedium auszuwählen.
Die Optionen sind unten aufgelistet.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Let's install the sets!
  Location of sets? (cd disk ftp http or 'done') [cd] <b><i>Enter</i></b>
  Available CD-ROMs are: cd0.
</pre></td></tr></table>

<p>
In diesem Beispiel installierst du von CD-ROM. Dazu wird eine Liste an
Geräten erzeugt, die auf deiner Maschine als CD-ROM identifiziert
wurden. Die meisten Leute haben aber nur eins. Wähle einfach
das Gerät aus, von dem aus du OpenBSD installieren willst.

<p>
<b>HINWEIS: </b>Nicht alle Plattformen bieten alle
Installationsmöglichkeiten an. In diesem Fall unterstützt die
OpenBSD/i386-Plattform keine NFS-Installation, so dass diese nicht in
der Liste mit aufgeführt wird.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available CD-ROMs are: cd0.
  Which one contains the install media? (or 'done') [cd0] <b><i>Enter</i></b>
  Pathname to the sets?  (or 'done') [3.8/i386] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Hier wirst du gefragt, in welchem Verzeichnis sich die Dateisets
befinden, auf der offiziellen CD-ROM ist das <tt>3.8/i386/</tt>.

<a name="Filesets"></a>
<h3>4.5.6 - Dateisets auswählen</h3>

<p>
Nun ist es an der Zeit, auszuwählen, welche Dateisets du haben willst.
Eine Beschreibung dieser Pakete findest du im <a href="#FilesNeeded"
>nächsten Abschnitt</a>. Die Dateien, die das Installationsprogramm
findet, werden auf dem Bildschirm angezeigt.
Deine Aufgabe ist es, anzugeben, welche Dateien du haben willst.
Standardmäßig sind bis auf die X-Dateisets alle markiert, manche
Leute wollen aber wirklich nur das absolute Minimum haben, mit dem
OpenBSD noch funktioniert, also <tt>base38.tgz</tt>,
<tt>etc38.tgz</tt> und <tt>bsd</tt>.
Andere wiederum wollen alle Dateisets haben. Das Beispiel unten zeigt
eine komplette Installation mit allen Paketen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  The following sets are available. Enter a filename, 'all' to select
  all the sets, or 'done'. You may de-select a set by prepending a '-'
  to its name.

          [X] bsd
          [X] bsd.rd
          [ ] bsd.mp
          [X] base38.tgz
          [X] etc38.tgz
          [X] misc38.tgz
          [X] comp38.tgz
          [X] man38.tgz
          [X] game38.tgz
          [ ] xbase38.tgz
          [ ] xetc38.tgz
          [ ] xshare38.tgz
          [ ] xfont38.tgz
          [ ] xserv38.tgz

  File Name? (or 'done') [bsd.rd] <b>all</b>

  The following sets are available. Enter a filename, 'all' to select
  all the sets, or 'done'. You may de-select a set by prepending a '-'
  to its name.

          [X] bsd
          [X] bsd.rd
          [X] bsd.mp
          [X] base38.tgz
          [X] etc38.tgz
          [X] misc38.tgz
          [X] comp38.tgz
          [X] man38.tgz
          [X] game38.tgz
          [X] xbase38.tgz
          [X] xetc38.tgz
          [X] xshare38.tgz
          [X] xfont38.tgz
          [X] xserv38.tgz
</pre></td></tr></table>

<p>
Du kannst hier alle möglichen Sachen machen -- ,<tt>-x*</tt>' zum
Beispiel würde alle X-Komponenten entfernen, falls du es dir nochmal
anders überlegst. In diesem Fall wollen wir aber alle Sets. Wenn das
System auch mit viel weniger Sets läuft, ist der empfohlene Weg,
entweder die standardmäßigen Vorgaben oder alles zu installieren.
Weitere Details zum Auswählen der Sets befinden sich
<a href="#FilesNeeded">hier</a>.

<p>
Nachdem du deine gewünschten Dateisets ausgewählt hast, wirst du noch
einmal gefragt, ob du die gewählten Dateisets wirklich entpacken willst,
und dann werden sie installiert. Es wird ein Fortschrittsbalken
angezeigt, der dir zeigt, wie lange das ganze noch etwa dauert. Die
Dauer hängt natürlch stark von der Geschwindigkeit deines Systems ab,
den Dateisets, die du installieren willst, und der Geschwindigkeit des
Installationsmediums. Somit liegt die Dauer irgendwo zwischen ein paar
Minuten und ein paar Stunden, je nachdem.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  File Name? (or 'done') [done] <b><i>Enter</i></b>
  Ready to install sets? [yes] <b><i>Enter</i></b>

  Getting bsd ...
  100% |**************************************************|  5157 KB    00:08
  Getting bsd.rd ...
  100% |**************************************************|  4549 KB    00:02
  Getting bsd.mp ...
  100% |**************************************************|  5202 KB    00:03
  Getting base38.tgz ...
  100% |**************************************************| 35928 KB    00:25
  Getting etc38.tgz ...
  100% |**************************************************|  1123 KB    00:01
  Getting misc38.tgz ...
  100% |**************************************************|  2222 KB    00:01
  Getting comp38.tgz ...
  100% |**************************************************| 20522 KB    00:17
  Getting man38.tgz ...
  100% |**************************************************|  7234 KB    00:05
  Getting game38.tgz ...
  100% |**************************************************|  2538 KB    00:01
  Getting xbase38.tgz ...
  100% |**************************************************| 10225 KB    00:07
  Getting xetc38.tgz ...
  100% |**************************************************| 93384       00:00
  Getting xshare38.tgz ...
  100% |**************************************************|  1986 KB    00:02
  Getting xfont38.tgz ...
  100% |**************************************************| 32438 KB    00:23
  Getting xserv38.tgz ...
  100% |**************************************************| 18172 KB    00:14
  Location of sets? (cd disk ftp http or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
An dieser Stelle hast du die Möglichkeit, weitere Dateien von anderen
Quellen zu installieren (inklusive <a href="#site">individuellen
Dateisets</a>), wenn du das möchtest oder gib ,<tt>done</tt>' ein, wenn
du alle Dateisets installiert hast, die du benötigst.

<a name="Finish"></a>
<h3>4.5.7 - Zum Ende kommen</h3>

Als nächstest werden dir einige Fragen bezüglich der Einstellungen
deines installierten Systems gestellt. Die erste ist, ob
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
beim Hochfahren gestartet werden soll. Üblicherweise möchtest du, dass
sshd(8) läuft, aber gelegentlich vielleicht auch nicht. Wenn deine
Verwendung von OpenBSD keinen Gebrauch für sshd(8) hat, liegt ein
kleiner theoretischer Sicherheitsvorteil vor, wenn er nicht läuft.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start sshd(8) by default? [yes] <b>y</b>
</pre></td></tr></table>

<p>
(Falls du deine Meinung später änderst, passe deine
<a href="faq10.html"><tt>/etc/rc.conf.local</tt></a> oder
<tt>/etc/rc.conf</tt> an.)

<p>
Dir wird nun die Möglichkeit gegeben,
<a href="faq6.html#OpenNTPD">OpenNTPD</a> beim Booten zu starten.
OpenNTPD ist ein Weg mit geringen Auswirkungen, die Uhr deines
Computers genau synchron zu halten, und hat eine standardmäßige
Konfiguration, die für die Verwendung von vielen Benutzern ausreicht.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start ntpd(8) by default? [no] <b>y</b>
</pre></td></tr></table>

<p>
(Falls du deine Meinung später änderst, passe deine
<a href="faq10.html"><tt>/etc/rc.conf.local</tt></a> oder
<tt>/etc/rc.conf</tt> an.)

<p>
Du wirst nun gefragt werden, ob du auf dem System X laufen lassen
willst. Wenn du mit ,Y' antwortest, wird die Datei
<tt>/etc/sysctl.conf</tt> so modifiziert, dass die Zeile
<tt>machdep.allowaperture=1</tt> oder <tt>machdep.allowaperture=2</tt>
darinsteht, abhängig von deiner Plattform. Einige Plattformen werden
diese Frage überhaupt nicht stellen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you expect to run the X Window System? [yes] <b>y</b>
</pre></td></tr></table>

<p>
Als nächstes wirst du gefragt, ob du eine
<a href="faq7.html#SerCons">serielle Konsole</a> an diesem Computer
anstatt von einer Standard-Tastatur und einem Monitor betreiben willst.
Wenn du "<tt>yes</tt>" auswählst und ein paar weitere einfache Fragen
beantwortest, werden
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8">/etc/boot.conf</a></tt>
und 
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5">/etc/ttys</a></tt>
automatisch für dich angepasst.
Die meisten Benutzer werden hier jedoch die Voreinstellung
<b><tt>no</tt></b> verwenden.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Change the default console to com0? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Deine letzte Aufgabe ist es, deine entsprechende Zeitzone einzustellen.
Abhängig davon, wo deine Maschine steht, kann es mehrere richtige
Antworten geben. Im folgenden Beispiel benutzen wir <tt>US/Eastern</tt>,
könnten aber auch <tt>EST5EDT</tt> oder <tt>US/Michigan</tt> benutzen
und zum selben Ergebnis kommen. Wenn man <tt>?</tt> drückt, bekommt
man eine Liste mit möglichen Auswahlen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Saving configuration files......done.
  Generating initial host.random file ......done.
  What timezone are you in? ('?' for list) [Canada/Mountain] <b>?</b>
  Africa/      Chile/       GB-Eire      Israel       NZ-CHAT      Turkey
  America/     Cuba         GMT          Jamaica      Navajo       UCT
  Antarctica/  EET          GMT+0        Japan        PRC          US/
  Arctic/      EST          GMT-0        Kwajalein    PST8PDT      UTC
  Asia/        EST5EDT      GMT0         Libya        Pacific/     Universal
  Atlantic/    Egypt        Greenwich    MET          Poland       W-SU
  Australia/   Eire         HST          MST          Portugal     WET
  Brazil/      Etc/         Hongkong     MST7MDT      ROC          Zulu
  CET          Europe/      Iceland      Mexico/      ROK          posix/
  CST6CDT      Factory      Indian/      Mideast/     Singapore    posixrules
  Canada/      GB           Iran         NZ           SystemV/     right/
  What timezone are you in? ('?' for list) [Canada/Mountain] <b>US</b>
  What sub-timezone of 'US' are you in? ('?' for list) <b>?</b>
  Alaska          Central         Hawaii          Mountain        Samoa
  Aleutian        East-Indiana    Indiana-Starke  Pacific
  Arizona         Eastern         Michigan        Pacific-New
  Select a sub-timezone of 'US' ('?' for list): <b>Eastern</b>
  Setting local timezone to 'US/Eastern'...done
</pre></td></tr></table>

<p>
Wenn du auf besonders genaue Zeitangaben aus bist, möchtest du
vielleicht <a href="faq8.html#NTPerror">das hier</a> lesen.

<p>
Die letzten Schritte für das System sind das Erzeugen des
<tt>/dev</tt>-Verzeichnisses (was auf manchen Maschinen ganz schön lange
dauert, insbesondere, wenn du nur wenig RAM besitzt) und das
Installieren des Bootblocks.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Making all device nodes...done.
  Installing boot block...
  boot: /mnt/boot
  proto: /usr/mdec/biosboot
  device: /dev/rwd0c
  /usr/mdec/biosboot: entry point 0
  proto bootblock size 512
  /mnt/boot is 3 blocks x 16384 bytes
  fs block shift 2; part offset 3069360; inode block 152, offset 4136
  using MBR partition 1: type 166 (0xa6) offset 3069360 (0x2ed5b0)
  done.

  CONGRATULATIONS! Your OpenBSD install has been successfully completed!
  To boot the new system, enter halt at the command prompt. Once the
  system has halted, reset the machine and boot from the disk.
  # <b>halt</b>
  syncing disks... done

  The operating system has halted.
  Please press any key to reboot.
</pre></td></tr></table>

<p>
OpenBSD ist jetzt auf deinem System installiert und bereit für den
ersten Boot, aber vorher ...

<p>

<h4>Bevor du neustartest</h4>
Nun ist dein System also installiert und fertig zum ersten Booten,
um danach noch konfiguriert zu werden. Zuvor wäre es allerdings
weise, die <a href="../../de/errata.html">Errata Seite</a> zu
überprüfen, ob es nicht irgendwelche Bugs gibt, die dich sofort
betreffen könnten.

<p>
Ein Trick, um eine ,vor dem ersten Start'-Konfiguration durchführen
zu können, ist:
<pre>
    # <b>/mnt/usr/sbin/chroot /mnt</b>
</pre>
beim Shellprompt einzugeben.
Dies setzt deine Mountpunkte so, wie sie nach einem normalen Neustart
deines frisch installierten Systems sein werden.
Du kannst grundlegende Systemkonfiguration durchführen, wie das
Hinzufügen von Benutzern, Mountpunkte ändern, etc.

<h4>Nach dem Neustart</h4>

<p>
Eines der ersten Dinge, die du nach der Installation lesen solltest, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=afterboot&amp;sektion=8">afterboot(8)</a>.

<p>
Die folgenden Links könnten ebenfalls recht nützlich sein:
<ul>
<li><a href="faq10.html#AddDelUser">Benutzer in OpenBSD
  hinzufügen</a>
<li><a href="faq6.html#Setup">Erste Netzwerkkonfiguration</a>
<li><a href="faq2.html#ManPages">Manualseiten von nützlichen/häufigen
  Befehlen</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD-Manualseiten
  im Web</a>
<li><a href="faq15.html">Das OpenBSD-Packages- und -Ports-System, um
  Software zu installieren</a>
</ul>

<h4>Noch eine Sache ...</h4>
Die OpenBSD-Entwickler bitten dich darum,
<a href="#SendDmesg">eine Kopie deiner dmesg einzuschicken</a>. Das
hilft den Entwicklern und schlussendlich auch den Anwendern.

<p>
<a name= "FilesNeeded"></a>
<h2>4.6 - Welche Dateien werden zur Installation benötigt?</h2>
<!-- XXXrelease -->

<p>
Die komplette OpenBSD-Installation ist in eine Vielzahl einzelner
<i>Dateisets</i> aufgeteilt. Nicht jede Verwendung verlangt nach jedem
Dateiset.  Hier ist eine Übersicht:
<p>
<ul>
  <li><b><i>bsd</i></b>          - Dies ist der Kernel. <b>Zwingend
    notwendig</b>
  <li><b><i>bsd.mp</i></b> - Multi-Prozessor- (SMP) -Kernel (nur auf
     einigen Plattformen)
  <li><b><i>bsd.rd</i></b> - <a href="#bsd.rd">RAM-Disk-Kernel</a>
  <li><b><i>base38.tgz</i></b>   - Enthät das Basissystem von OpenBSD
    <b>Zwingend notwendig</b>
  <li><b><i>etc38.tgz</i></b>    - Enthält alle Dateien in /etc
    <b>Zwingend notwendig</b>
  <li><b><i>comp38.tgz</i></b>    - Enthält den Compiler und alle seine
    Anwendungen, ,headers' und Bibliotheken. <b>Empfohlen</b>
  <li><b><i>man38.tgz</i></b>    - Enthält alle Manualseiten
    <b>Empfohlen</b>
  <li><b><i>misc38.tgz</i></b>   - Enthält alle misc-, info- und
    setup-Dokumentationen
  <li><b><i>game38.tgz</i></b>   - Enthält die Spiele für OpenBSD
  <li><b><i>xbase38.tgz</i></b>  - Enthält die Basisinstallation
    für X11
  <li><b><i>xetc38.tgz</i></b>   - Beinhaltet die /etc/X11- und
    /etc/fonts-Konfigurationsdateien
  <li><b><i>xfont38.tgz</i></b>  - Enthält den X11-Font-Server und Fonts
  <li><b><i>xserv38.tgz</i></b>  - Enthält die X11-X-Server
  <li><b><i>xshare38.tgz</i></b> - Enthält Manualseiten, lokale
    Einstellungen, ,includes', etc. für X
</ul>

Das <b>etc38.tgz</b>- und das <b>xetc38.tgz</b>-Set werden nicht als
Teil eines Upgrades installiert, sondern nur als Teil einer kompletten
Installation, so dass jegliche Änderungen, die du vorgenommen hast,
nicht verloren gehen.
Du musst deine Verzeichnisse <tt>/etc</tt>, <tt>/dev</tt> und
<tt>/var</tt> manuell aktualisieren.

<p>
<a name= "SpaceNeeded"></a>
<h2> 4.7 - Wieviel Platz brauche ich für eine OpenBSD-Installation?</h2>
<!-- XXXrelease -->

<p>
Es ist offensichtlich, dass die Antwort auf diese Frage gewaltig von
deiner Verwendung des Systems abhängig ist.
Jedoch können diese Werte als ein <i>Start</i>-Punkt angesehen werden:

<blockquote><pre>
(root)             100 MB
/usr               250 MB (kein X) oder 400 MB (mit X)
/var               25 MB
/tmp               50 MB
swap               32 MB
</pre></blockquote>

Dies sind die minimal empfohlene Dateisystemgrößen für eine gesamte
Systeminstallation.
Die Werte beinhalten zusätzlichen Platz um dir zu ermöglichen, ein
typisches Heimsystem zu nutzen, das eine Internetverbindung hat, aber
nicht sehr viel mehr.

<p>
Behalte die folgenden Fakten jedoch im Hinterkopf:
<ul>
<li>Dies sind Minimalwerte.
Plattenspeicher ist zurzeit recht günstig, der Versuch, das System auf
die kleinst mögliche Platte zu quetschen ist normalerweise den Aufwand
nicht wert. Für bestimmte Einsatzgebiete können diese Werte kleiner
gemacht werden, aber du musst experimentieren.
<li>Wenn du planst, eine Menge Software von dritter Seite zu
installieren, wähle deine <tt>/usr</tt>-Partition groß!
Wie groß hängt natürlich von deiner Verwendung ab.
<li>Für ein System, das eine Menge E-Mails oder Web-Seiten handhabt (die
in <tt>/var/mail</tt> und <tt>/var/www</tt> gespeichert werden),
solltest du deine <tt>/var</tt>-Partition bedeutend vergrößern oder lege
sie auf separate Partitionen.
<li>Für ein Mehrbenutzersystem, das eine Menge Aufzeichnungen erzeugt,
solltest du deine <tt>/var</tt>-Partition noch größer wählen oder
eine separate Log-Partition (<tt>/var/log</tt>) einrichten.
<li>Wenn du planst, <a href="faq5.html">den Kernel oder das ganze System
aus dem Source neu zu erzeugen</a>, sollte deine <tt>/usr</tt>-Partition
deutlich größer ausfallen - 3 G ist keine schechte Idee.
<li>Das Kompilieren von einien <a href="faq15.html#Ports">Ports</a> vom
Quelltext aus kann gewaltig viel Speicher auf deinen <tt>/usr</tt>-
und <tt>/tmp</tt>-Partitionen in Anspruch nehmen. Dies ist ein weiterer
Grund, warum wir empfehlen, stattdessen
<a href="faq15.html#PkgMgmt">vorkompilierte Packages</a> zu
nutzen.
<li>Die <tt>/tmp</tt>-Parition wird während dem Kompilieren von Ports
und anderen Dingen benutzt, die Größe hängt also davon ab, was du damit
machen willst. 50 MB mag für viele Leute viel sein, aber einige
große Applikationen brauchen 100 MB und mehr <tt>/tmp</tt>-Platz.

<li>Die ,b'-Partition deines ersten Laufwerks wird automatisch deine
System-Swappartition -- wir empfehlen ein
Minimum von 32 MB, aber wenn du genug Platz hast, mach wenigstens 64 MB
daraus. Wenn du aber wirklich viel Plattenplatz hast, scheu dich nicht,
dein Swap mit 256 MB oder sogar 512 MB einzurichten.
Auf der anderen Seite, wenn du einen Flashspeicher benutzt, solltest
du vielleicht überhaupt gar keine Swappartition nutzen.
Viele Leute folgen einer alten Bauernregel, die besagt, dass deine
Swappartition doppelt so viel Speicher haben sollte wie dein RAM.
Diese Regel ist Unsinn.
Auf modernen Systemen wäre das SEHR VIEL Swap, die meisten Leute
bevorzugen eher, dass ihre System niemals ,swappen'.
Setze das ein, was für deine Ansprüche am besten ist.
<li>Swap- und <tt>/var</tt>-Speicher werden genutzt, um
,system core dumps' im Fall eines
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crash&amp;sektion=8">crash(8)</a>
zu speichern.
Falls dies eine Überlegung von dir ist, sollte dein Swapbereich ein
wenig größer sein als der Speicherplatz des Hauptspeichers, den du
jemals in deinem System verwenden wirst.
Beim Neustart versucht
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8">savecore(8)</a>,
den Inhalt der Swappartition in eine Datei unter
<tt>/var/crash</tt> zu speichern, also wieder einmal, wenn dies wichtig
für dich ist, sollte deine <tt>/var</tt>-Partition über genug
<i>freien Speicher</i> verfügen, um diese ,dump'-Dateien halten zu
können.
Sei realistisch -- nur wenige Entwickler möchten sich deine
1-GB-,dump'-Datei ansehen, solltest du also nicht vorhaben, einen
Absturz lokal zu überprüfen, ist dies vermutlich nicht wichtig für dich.
</ul>

<p>
Es gibt mehrere Hauptgründe, anstelle von nur ein oder zwei
Dateisystemen, mehr separate Dateisysteme zu benutzen:

<ul>
<li><b>Sicherheit</b>: Du kannst einige Dateisysteme als ,nosuid',
  ,nodev', ,noexec', ,readonly', etc. markieren. Das wird vom
  Installationsprozess erledigt, wenn du die oben beschriebenen
  Partitionen benutzt.
<li><b>Stabilität</b>: Ein Anwender oder amoklaufendes Programm kann ein
  Dateisystem mit Müll auffüllen, wenn sie darauf Schreibrechte
  haben. Deine kritischen Programme, dann natürlich auf einem anderen
  Dateisystem laufend, werden nicht unterbrochen.
<li><b>Geschwindigkeit</b>: Ein Dateisystem, in das dauernd
  hineingeschrieben wird, kann schnell fragmentieren (Glücklicherweise
  ist das ffs-Dateisystem, das von OpenBSD benutzt wird, nicht für
  sowas anfällig).
<li><b>Integrität</b>: Wenn ein Dateisystem aus irgendeinem Grund defekt
  ist, sind deine anderen Dateisysteme immer noch OK.
<li><b>Größe</b>: Viele Maschinen haben Grenzen im Bezug auf den
  Ort, von dem aus das ROM den Kernel laden kann. In einigen Fällen
  kann die Grenze sehr niedrig sein (504 M für ältere 486), in
  anderen Fällen ist de Grenze recht hoch (zum Beispiel 2 G, 8 G
  oder 128 G auf i386-Systemen). Da sich der Kernel irgendwo in der
  root-Partition befinden kann, muss die gesamte root-Partition
  innerhalb dieser Grenze liegen. Mehr Details gibt es in
  <a href="faq14.html#LargeDrive">diesem Kapitel</a>. Eine gute
  Richtlinie ist, deine /-Partition einfach komplett unterhalb der
  ersten 2 GB zu lassen, es sei denn, du weißt, dass deine Plattform
  (und besonders deine Maschine) damit umgehen kann.
</ul>

<p>
Noch ein paar Gedanken zur Partitionierung:
<ul>
 <li>Bei deinem ersten Versuch und einem experimentellen System ist eine
   große <tt>/</tt>-Partition und Swap das einfachste, bis du
   weißt, wieviel Platz du brauchst. Dadurch wirst du einige der
   Standard-Sicherheitsmechanismen opfern, die OpenBSD bietet, die
   separate Dateisysteme für <tt>/, /tmp, /var, /usr</tt> und
   <tt>/home</tt> benötigen. Du solltest mit deiner ersten
   OpenBSD-Installation jedoch nicht in produktiven Einsatz gehen.
 <li>Ein sich im Internet befindliches oder anderweitig angreifbares
   System sollte eine separate Partition für <tt>/var</tt> haben (und
   vielleicht sogar eine separate für <tt>/var/log</tt>) für die
   Logdateien.
 <li>Eine <tt>/home</tt>-Partition ist durchaus nützlich. Neue Version
   des OS? Alles andere löschen und neu machen, aber die
   <tt>/home</tt>-Partition einfach unberührt lassen. Denke aber
   trotzdem daran, eine Sicherungskopie deiner Konfigurationsdateien
   anzulegen!
 <li>Eine separate Partition für alles, was eine große Anzahl
   Dateien erzeugen kann, kann man gegebenenfalls schneller formatieren
   und neu anlegen, als alle Dateien zu löschen. Siehe auch die <a
   href="faq5.html#ProbObjPt">Vom-Source-aus-erzeugen-FAQ</a> für ein
   Beispiel (<tt>/usr/obj</tt>).
 <li>Wenn du dein System aus irgendeinem Grund aus dem Quellcode neu
   erzeugen willst, sollte der Source sich in <tt>/usr/src</tt>
   befinden. Wenn du kein separates Dateisystem für <tt>/usr/src</tt>
   hast, dann sorge unbedingt dafür, dass du in <tt>/usr</tt> genug
   Platz hast.
 <li>Ein oftmals vergessener Punkt: du musst auf deinem System
   <b>nicht</b> allen Platz sofort vergeben! Da du jetzt vermutlich kaum
   noch eine Festplatte unter 20 GB finden wirst, kann es durchaus Sinn
   machen, einfach ein bisschen Platz zu lassen. Wenn dir dann eine
   Partition zu klein wird, kannst du dann einfach aus deinem
   ungenutzten Platz eine neue Partition erstellen, deine existierende
   Partition auf die neue
   <a href="faq10.html#DupFS">duplizieren</a>, die
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab</a>
   ändern und auf die neue Partition verweisen lassen, neu mounten,
   und schon hast du mehr Platz.
 <li>Wenn du deine Partitionen zu klein wählst, wirst du das
   vermutlich später bereuen, wenn es an der Zeit ist, dein System
   auf den neuesten Stand zu bringen.
<li>Wenn du sehr große Partitionen anlegst, solltest du im Hinterkopf
   behalten, dass die Dateisystemüberprüfung mittels
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
   ungefähr 1 M RAM für jedes Gigabyte der Dateisystemgröße benötigt
   und zudem sehr zeitaufwendig ist; oder sogar nicht ausführbar auf
   älteren, langsameren Systemen (Greife bitte auf
   <a href="faq14.html#LargeDrive">diese Sektion</a> zurück).
 <li>Wenn du deinen Benutzern erlaubst, auf <tt>/var/www</tt> zu
   schreiben (z.B. persönliche Webseiten), möchtest du es vielleicht auf
   eine separate Partition legen, so dass du
   <a href="faq10.html#Quotas">quotas</a> verwenden kannst, um den
   Speicher, den sie verwenden, zu begrenzen, und wenn sie die Partition
   füllen, keine anderen Teile des Systems betroffen sind.
</ul>


<p>
<a name= "Multibooting"></a>
<h2>4.8 - Multibooting OpenBSD/i386</h2>

Multibooting ist, wenn man mehrere Betriebssysteme auf einem Computer
hat und auf irgendeine Art und Weise auswählen kann, welches OS
gebootet werden soll. Das ist <i>keine</i> unbedeutende Aufgabe! Wenn du
nicht verstehst, was du da machst, könntest du am Ende große
Mengen an Daten von deinem Computer gelöscht haben. Neuen
OpenBSD-Benutzern wird <i>dringend</i> dazu geraten, mit einer leeren
Festplatte auf einer extra hierfür freigestellten Maschine anzufangen
und dann mit der gewünschten Konfiguration auf einer nicht im Einsatz
befindlichen Maschine zu üben, bevor eine Multiboot-Konfiguration
auf einer eingesetzten Maschine versucht wird. <a href="faq14.html">FAQ
14</a> hat weitere Informationen über den OpenBSD-Bootprozess.

<p>
Hier sind einige Optionen zum Multibooten:

<h3>Aktive Partitionen markieren</h3>
Dieses ist die wahrscheinlich am häufigsten übersehende und
doch ab und zu beste Lösung für das Multibooten. Markiere einfach
die aktive Partition in welchem OS auch immer du dich befindest so, dass
sie diejenige ist, die beim nächsten Booten standardmäßig
gebootet wird. So gut wie jedes OS bietet ein Programm, mit dem das
bewerkstelligt werden kann; OpenBSDs ist <a
href="faq14.html#fdisk">fdisk(8)</a>; ähnlich genannte Programme gibt
es unter Windows 9x und DOS, sowie unter vielen anderen
Betriebssystemen. Dies kann sehr wünschenswert für Betriebssysteme oder
Systeme sein, die sehr lange zum Herunterfahren und Neustarten brauchen
-- du kannst sie markieren und das System neustarten, dann weggehen,
eine Tasse Kaffee holen und dann zum System wiederkehren, das so
hochgefahren ist, wie du es wolltest -- kein Warten auf den magischen
Moment, wenn du das nächste OS auswählen musst.

<h3>Bootdiskette</h3>
Wenn du ein System hast, das nicht häufig zum Booten von OpenBSD
verwendet wird (oder nicht möchtest, dass andere Benutzer des Computers
mitbekommen, dass sich irgendwas geändert hat), ziehe das Verwenden
einer Bootdiskette in Betracht. Verwende einfach eine der <a
href="#MkFlop">normalen OpenBSD-Installationsdisketten</a> und erstelle
eine <tt>/etc/boot.conf</tt>-Datei (ja, du musst außerdem ein
<tt>/etc</tt>-Verzeichnis auf der Diskette anlegen) mit dem Inhalt:

<pre>
     boot hd0a:/bsd
</pre>

um das System zu veranlassen, von Festplatte 0, OpenBSD-Partition ,a',
Kerneldatei <tt>/bsd</tt> zu booten. Denke daran, dass du mit einer
Zeile wie dieser auch von anderen Laufwerken booten kannst:
,<tt>boot hd2a:/bsd</tt>' von der dritten Festplatte deines Systems.
Um OpenBSD zu booten, lege die Diskette ein und starte neu.
Um das andere OS zu booten, nehme die Diskette aus dem Laufwerk und
starte neu.

<p>
In diesem Fall wird das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>-Programm
geladen; es sucht nach <tt>/etc/boot.conf</tt> und ließt sie
aus. Die Zeile ,<tt>boot hd0a:/bsd</tt>' weist boot(8) zu, von wo aus
der Kernel geladen werden soll -- in diesem Fall von der ersten HD, die
das BIOS sieht. Behalte im Hinterkopf, dass nur eine kleine Datei
(<tt>/boot</tt>) von der Diskette geladen wird -- das System lädt den
gesamten Kernel von der Festplatte, so dass ungefähr nur fünf
Sekunden zum Bootprozess hinzugefügt werden.

<h3>Windows NT/2000/XP NTLDR</h3>

Um OpenBSD und Windows NT/2000/XP starten zu können, kannst du den
NTLDR, den Bootloader von NT, benutzen. Um mit NT einen Multiboot
durchführen zu können, benötigst du
eine Kopie des OpenBSD-,Partition Boot Record' (PBR).
Nach dem Ausführen von installboot kannst du ihn mit einem Aufruf
wie dem folgenden unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
in eine Datei kopieren:

<pre>
	# <strong>dd if=/dev/rsd0a of=openbsd.pbr bs=512 count=1</strong>
</pre>

Hinweis: Jetzt ist ein guter Zeitpunkt, dich daran zu erinnern,
dass es eine wirklich schlechte Idee ist, Befehle einzutippen, die du
nicht verstehst. Dieser Aufruf wird auf den meisten Computern nicht
direkt verwendet werden können. Es bleibt nun dem Leser überlassen,
ihn an seine Maschine anzupassen.

<p>
Starte nun NT und platziere <tt>openbsd.pbr</tt> auf C:. Füge eine
Zeile wie folgende am Ende von <tt>C:\BOOT.INI</tt> hinzu:

<pre>
	c:\openbsd.pbr="OpenBSD"
</pre>

<p>
Nach einem Neustart solltest du OpenBSD im NT-Loadermenü
auswählen können. Zum NTLDR gibt es im
<a href="http://www.tburke.net/info/ntldr/ntldr_hacking_guide.htm">NTLDR
Hacking Guide</a> mehr Informationen.

<p>
Auf Windows XP kannst du die Bootinformationen auch mit Hilfe der GUI
editieren; siehe auch das
<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;289022">XP Boot.ini HOWTO</a>.

<p>
Programme, die vieles von diesen Tätigkeiten dir abnehmen, stehen zur
Verfügung, zum Beispiel <a
href="http://www.winimage.com/bootpart.htm">BootPart</a>.
Dieses Programm kann unter Windows NT/2000/XP ausgeführt werden und
lädt den OpenBSD-PBR, platziert ihn auf deine NT/2000/XP-Partition und
fügt ihn zur <tt>C:\BOOT.INI</tt> hinzu.

<p>
<!-- XXXVersion: issue "expires" after last 3.4 systems are upgraded. -->
Die OpenBSD-Installation und der Upgradeprozess installieren den
OpenBSD-<a href="faq14.html#Boot386">Bootloader</a>, dessen Pfad im PBR
eingetragen ist, so dass du, wenn du deine OpenBSD-Installation
neuinstallierst oder aktualisierst, den oben angegebenen Prozess
wiederholen musst, damit eine neue Kopie des OpenBSD-PBR geladen wird.

<p>
Hinweis: Der Windows-NT/2000/XP-Bootloader ist nur in der Lage,
Betriebssysteme von der primären Festplatte zu booten.
Du kannst ihn nicht verwenden, um OpenBSD von der zweiten Festplatte zu
laden.

<p>
<h3>Andere Bootloader</h3>

<p>
Zu einigen anderen Bootloadern, die von OpenBSD-Anwendern erfolgreich
eingesetzt worden sind, gehöhren
<a href="http://gag.sourceforge.net/">GAG</a>,
OS-BS,
<a href="http://www.ranish.com/part/">The Ranish Partition Manager</a>
und <a href="http://www.gnu.org/software/grub/">GRUB</a>.

<p>
<h3>OpenBSD und Linux (i386)</h3>
<!-- XXXversion -->

<p>
Bitte lies dir
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.8/i386/INSTALL.linux">INSTALL.linux</a>
durch, um genaue Informationen zur Zusammenarbeit zwischen OpenBSD und
Linux zu bekommen.

<a name= "SendDmesg"></a>
<h2>4.9 - Nach der Installation deine dmesg an dmesg@openbsd.org
schicken</h2>

<p>
Um es nochmal allen ins Gedächtnis zu rufen: Es ist wichtig für
die OpenBSD-Entwickler, im Auge zu behalten, welche Art von Hardware
funktioniert und welche eben nicht perfekt funktioniert.

<p>
Ein Zitat aus /usr/src/etc/root/root.mail
<pre>
If you wish to ensure that OpenBSD runs better on your machines, please do us
a favor (after you have your mail system configured!) and type something like:
 # dmesg | mail -s "Sony VAIO 505R laptop, apm works OK" dmesg@openbsd.org
so that we can see what kinds of configurations people are running.  As shown,
including a bit of information about your machine in the subject or the body
can help us even further.  We will use this information to improve device driver
support in future releases.  (Please do this using the supplied GENERIC kernel,
not for a custom compiled kernel, unless you're unable to boot the GENERIC
kernel).  The device driver information we get from this helps us fix existing
drivers. Thank you!
</pre>

<p>
Stelle sicher, dass du nicht nur E-Mail von deinem Konto senden sondern
auch empfangen kannst, für den Fall, dass dich ein Entwickler
kontaktieren will, um etwas zu testen oder um deine Konfiguration zum
Laufen zu bringen. Es ist nicht wichtig, dass du die E-Mail von einem
Rechner mit OpenBSD verschickst, wenn also dieser Rechner keine E-Mail
empfangen kann, dann gib einfach

<pre>
$ dmesg | mail your-account@yourmail.dom
</pre>
ein und leite dann diese Nachricht weiter an
<pre>
 dmesg@openbsd.org
</pre>
wobei <tt>your-account@yourmail.dom</tt> dein regulärer Email-Account
ist.
(oder transferiere die dmesg-Ausgabe mittels
FTP/scp/floppydisk/carrier-pigeon/...)

<p>
<strong>ANMERKUNG</strong> - Bitte schicke nur GENERIC-Kernel-dmesgs.
Eigenkompilierte Kernel sind nicht hilfreich, wenn Gerätetreiber fehlen.

<p>
Bedenke auch, dass die dmesgs von einem Computer erhalten werden, der
das Spamblockersystem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=spamd&amp;sektion=8">spamd</a>
einsetzt.
Dies könnte dazu führen, dass deine dmesg vom Mailserver für
eine gewisse Zeit nicht angenommen wird.
Habe Geduld, nach einer halben Stunde, Stunde oder so wird sie
durchkommen.

<a name="AddFileSet"></a>
<h2>4.10 - Ein Dateiset nach der Installation hinzufügen</h2>
<!-- XXXversion -->
,Oh nein!  Ich habe bei der Installation eines der Dateisets vergessen!'
<p>
Manchmal merkt man, dass man <tt>comp38.tgz</tt> (oder irgendeine andere
Systemkomponente) DOCH benötigt, erst nachdem man mit der
Installation schon fertig ist.  Kein Problem: Es gibt zwei einfache
Wege, diese Komponenten aus der Installation noch nachträglich
einzuspielen:

<h3>Indem man den Upgradeprozess benutzt</h3>
Boote einfach von deinem Installationsmedium (CD-ROM oder Diskette) und
wähle ,Upgrade' (und nicht Install).  Wenn du zur Liste mit den
Dateisets kommst, wähle die Sets, die du beim ersten Mal vergessen
hast, wähle deine Quelle aus und lass die Installation beginnen.

<h3>Indem man tar(1) benutzt</h3>
Die Installationsdateien sind einfach komprimierte tar-Dateien und du
kannst sie dementsprechend am root (/) des Dateisystems auspacken:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # cd /
  # tar xzvpf comp38.tgz
</pre></td></tr></table>

<p>
Du darfst NICHT die <tt>,p'</tt>-Option im oben genannten Kommando
vergessen, sonst werden die Dateirechte nicht richtig gesetzt!
<p>
Ein häufig gemachter Fehler ist, zu denken, man könne 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1">pkg_add(1)</a>
benutzen, um fehlende Dateisets einzuspielen. Das funktioniert aber
nicht. pkg_add(1) ist das <a href="faq15.html#PkgMgmt">Werkzeug für die
Packagesverwaltung</a>, um Software von Drittanbietern zu installieren.
Es verarbeitet Packagedateien, jedoch keine normalen Tardateien wie
zum Beispiel die Installationssets.


<a name="bsd.rd"></a>
<h2>4.11 - Was ist ,bsd.rd'?</h2>

<b><tt>bsd.rd</tt></b> ist ein RAM-Disk-Kernel.  Diese Datei kann sehr
nützlich sein; viele Entwickler lassen sie mit Absicht immer im
Quellverzeichnis ihres Dateisystems.

<p>
Ihn einen ,RAM-Disk-Kernel' zu nennen, beschreibt das root-Dateisystem
des Kernels -- es ist kein physikalisches Laufwerk, die Werkzeuge,
die nach dem Booten von <tt>bsd.rd</tt> nutzbar sind, befinden sich im
Kernel und werden aus einem RAM-basierten Dateisystem geladen.
<tt>bsd.rd</tt> enthält auch ein brauchbares Set an Werkzeugen für
Systemwartung und -installation.

<p>
Auf manchen Plattformen ist <tt>bsd.rd</tt> sogar die bevorzugte
Installationstechnik. Du plazierst diesen Kernel in ein vorhandenes
Dateisystem, bootest ihn und führst daraus die Installation aus. Auf den
meisten Plattformen kannst du, falls du eine ältere Version von OpenBSD
hast, eine neue Version von <tt>bsd.rd</tt> per FTP holen, davon booten
und eine neue Version von OpenBSD installieren, ohne eine Diskette oder
CD-ROM zu benutzen.

<p>
Hier zum Beispiel das Booten von <tt>bsd.rd</tt> auf einem i386-System:

<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Using Drive: 0 Partition: 3
  reading boot.....
  probing: pc0 com0 com1 apm mem[639k 255M a20=on]
  disk: fd0 hd0
  &gt;&gt; OpenBSD/i386 BOOT 2.10
  boot&gt; <b>boot hd0a:/bsd.rd</b>
<i>. . . normal boot to install . . .</i>
</pre></td></tr></table>

Wie schon gesagt, wirst du in das Installationsprogramm geführt, aber
du kannst natürlich auch auf die Shell gehen, um dein System zu pflegen
oder zu administrieren.
<p>
Die einfache Regel, um <tt>bsd.rd</tt> booten zu können, lautet:
Tausche <tt>/bsd</tt> durch <tt>bsd.rd</tt> aus, was auch immer das auf
deiner Plattform heißen mag.


<a name="InstProb"></a>
<h2>4.12 - Allgemeine Installationsprobleme</h2>

<a name="cpq16m"></a>
<h3>4.12.1 - Mein Compaq erkennt nur 16 M RAM</h3>
<i>Einige</i> Compaq-Systeme haben das Problem, dass der gesamte
Hauptspeicher vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">OpenBSD
,second stage' Bootloader</a> nicht ordentlich erkannt wird und nur 16 M
erkannt und von OpenBSD verwendet werden. Dies kann entweder durch das
Erstellen/Editieren von der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"><tt>/etc/boot.conf</tt></a>
oder durch das Eingeben von Befehlen am ,<tt>boot></tt>'-Prompt, bevor
OpenBSD lädt, behoben werden. Falls du eine Maschine mit 64 M RAM hast,
aber OpenBSD nur die ersten 16 M erkennt, sieht der Befehl, den du
benutzen würdest, wie folgt aus:

<pre>
     machine mem +0x3000000@0x1000000
</pre>
um 48 M (<tt>0x3000000</tt>) nach den ersten 16 M (<tt>0x1000000</tt>)
hinzuzufügen. Typischerweise würdest du den oben angegeben
Befehl am Installationsprompt <tt>boot></tt> der Diskette/CD-ROM eingeben,
neustarten und eine <tt>/etc/boot.conf</tt>-Datei anlegen, die den oben
angegebenen Befehl beinhaltet, so dass alle zukünftigen Starts des
Systems den ganzen verfügbaren Speicher erkennen können, wenn du
ein System mit diesem Problem hättest.

<p>
Es wurde ebenfalls berichtet, dass ein ROM-Update dieses Problem auf
<i>einigen</i> Systemen löst.

<a name="noboot"></a>
<h3>4.12.2 - Mein i386 bootet nach der Installation nicht</h3>
Deine Installation verlief gut, doch beim ersten Hochfahren erkennst du
keine Anzeichen dafür, dass OpenBSD versucht zu starten. Es existieren
einige bekannte Gründe für dieses Problem:

<ul>
<li><b>Keine Partition wurde in fdisk(8) als aktiv markiert.</b> Um dies
zu beheben, starte das System unter Verwendung der Bootdiskette oder
anderer Medien neu und ,markiere' eine Partition als ,aktiv'
(bootfähig). Siehe <a href="faq14.html#fdisk">hier</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">hier</a>.

<li><b>Kein gültiger Bootloader wurde jemals auf die Platte
geschrieben</b>
Falls du mit ,Y' auf die Frage ,Use entire disk for OpenBSD?' während
der Installation geantwortet hast oder die ,<tt>reinit</tt>'-Option von
fdisk(8) verwendet hast, wurde der OpenBSD-,Boot Record' im
,Master Boot Record' der Platte installiert; ansonsten wurde der
existierende ,Master Boot Record'-Code nicht berührt. Dies wird ein
Problem sein, wenn kein anderer ,Boot Record' existierte.
Eine Lösung ist, das Installationsmedium wieder zu booten, auf die
Shell zurückzugreifen und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
aufzurufen, um den MBR-Code von der Befehlszeile aus zu aktualisieren:
<pre>
    # fdisk -u wd0
</pre>
Hinweis: Die ,update'-Option im interaktiven (,-e') Modus von fdisk
wird keine Signaturbytes schreiben, die benötigt sind, um die
Platte bootfähig zu machen.

<li><b>In einigen wenigen Fällen kann etwas mit der ,second
stage'-Bootloaderinstallation schief gelaufen sein.</b> Das
Neuinstallieren des ,second stage'-Bootloaders wird
<a href="faq14.html#InstBoot">hier</a> besprochen.

</ul>

<a name="sshhang"></a>
<h3>4.12.3 - Meine (ältere, langsamere) Maschine bootet, aber hängte
beim ssh-keygen-Prozess</h3>
Es ist sehr wahrscheinlich, dass dein System einwandfrei funktioniert,
nur dass die ssh-Schlüsselgenerierung eine Weile dauert. Eine
SPARCStation2 oder ein Macintosh Quadra können <i>mehrere Stunden</i>
oder länger in Anspruch nehmen, um die drei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>-Schritte
auszuführen.
Lass es einfach abschließen; es wird nur ein einziges Mal pro
Installation gemacht.

<p>
Beachte, dass die Standardschlüsselgröße mit 3.8 vergrößert wurde,
so dass die benötigte Zeit für die Generation noch länger geworden
ist als sie bisher schon war. Benutzer von sehr langsamen Maschinen
sollten daher in Betracht ziehen, ihre Schlüssel auf einem anderen
Computer zu erzeugen, diese dann in einer
<a href="#site">site38.tgz</a>-Datei abzulegen und sie mit dem Rest
der Dateisets zu installieren.


<a name="noftplist"></a>
<h3>4.12.4 - Ich bekam die Meldung ,Failed to change
directory' als ich die Installation durchführte</h3>

Wenn du eine FTP-Installation eines
<a href="faq5.html#Flavors">,flavors'</a> während der
<i>-beta</i>-Phase des OpenBSD-Entwicklungszyklus durchführst, könntest
du dies lesen:

<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>

  Do you want to see a list of potential FTP servers?  [yes] <b><i>Enter</i></b>
  Getting the list from 192.128.5.191 (ftp.openbsd.org)... FAILED
  Failed to change directory.
  Server IP address or hostname?
</pre></td></tr></table>

Dies ist normal und ein erwartetes Verhalten während der
,pre-release'-Phase des Zyklus. Das Installationsprogramm sucht nach
der FTP-Liste auf dem primären FTP-Server in einem Verzeichnis, das bis
zum <a href="faq1.html#Next">Releasedatum</a> nicht verfügbar ist, so
dass du die oben genannte Meldung bekommst.

<p>
Verwende einfach eine
<a href="../../de/ftp.html">FTP-,mirror'-Liste</a>, um deinen
favorisierten FTP-,mirror' zu finden und gib ihn manuell ein, wenn du
danach gefragt wirst.

<p>
<b>Hinweis: Du solltest die Meldung nicht sehen, wenn du <i>-release</i>
oder von einer CD-ROM installierst.</b>

<a name="blankfdisk"></a>
<h3>4.12.5 - Meine fdisk-Partitionstabelle ist kaputt oder leer!</h3>
Gelegentlich finden Benutzer ein funktionsfähiges System vor,
das aber beim Verwenden von <tt>fdisk wd0</tt> eine vollständig
leere (oder ab und zu, vermüllte) Partitionstabelle aufweist.
Dies ist normalerweise verursacht, wenn eine Partition in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
erstellt wurde, die ein Offset von 0 Sektoren hat, anstatt dem
<a href="#trackoffset">einem Track Offset</a>, den sie haben
sollte (Hinweis: Dies nimmt an, dass es sich um die
<a href="../../de/i386.html">i386</a>- oder
<a href="../../amd64.html">amd64</a>-Plattform handelt. Andere
Plattformen benötigen andere Offsets, einige sogar GAR KEINEN
Offset).
Das System <a href="faq14.html#Boot386">bootet</a> dann unter Verwendung
des PBR und nicht des MBR.

<p>
Obwohl diese Konfiguration funktioniert, kann es ein Wartungsproblem
sein und sollte korrigiert werden.
Um dies zu korrigieren, muss das Dateisystem der Platte normalerweise
von Grund auf neu erstellt werden (obwohl, wenn du WIRKLICH weißt
was du tust, kannst du in der Lage sein, nur dein Disklabel und den
MBR neu zu erstellen und musst nur die erste OpenBSD-Partition der
Festplatte neu errichten).

<a name="site"></a>
<h2>4.13 - Anpassen des Installationsprozesses</h2>
<!-- XXXversion -->

<h3><tt>siteXX.tgz</tt>-Datei</h3>
Die OpenBSD-Installationsskripte erlauben das Auswählen eines
benutzererstellten Sets, genannt ,<tt>siteXX.tgz</tt>', wobei XX die
Releaseversion (z.&nbsp;B. 38) ist. Das ,<tt>siteXX.tgz</tt>'-Dateiset
ist, wie die anderen <a href="#FilesNeeded">Dateisets</a>, ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gzip&amp;sektion=1">gzip(1)</a>-komprimiertes
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>-Archiv
basierend auf ,/' und wird wie die anderen Sets mit den
Optionen <tt>xzpf</tt> ent,tar'rt. Dieses Set wird zuletzt installiert,
nach allen anderen Dateisets.

<p>
Dieses Dateiset erlaubt es dem Benutzer, Dateien hinzuzufügen oder
Dateien zu überschreiben, die von den ,normalen' Sets installiert
worden sind, um so die Installation oder das Upgrade anpassen zu können.

<p>
Einige Beispielverwendungen einer <tt>siteXX.tgz</tt>-Datei:
<ul>
<li>Erstelle eine siteXX.tgz-Datei, die alle Änderungen beinhaltet,
die du seit dem ersten Installieren von OpenBSD gemacht hast. Dann,
wenn du das System neuerstellen musst, wählst du einfach siteXX.tgz
während der Neuinstallation aus und alle Änderungen von dir
werden auf dem neuen System nachgebildet.

<li>Erstelle eine Serie an maschinenspezifischen Verzeichnissen, die
jeweils eine siteXX.tgz-Datei beinhalten, die wiederum spezifische
Dateien für diese Maschine beinhalten. Installationen von Maschinen
(z.B. Systeme mit unterschiedlichen Grafikkarten) einer bestimmten
Kategorie können durch das Auswählen der passenden siteXX.tgz-Datei
abgeschlossen werden.

<li>Stecke die Dateien, die du routinemäßig auf einen gleichen
oder ähnlichen Weg anpasst, in eine siteXX.tgz-Datei --
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"><tt>/etc/skel</tt></a>-Dateien,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><tt>/etc/pf.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8"><tt>/var/www/conf/httpd.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"><tt>/etc/rc.conf.local</tt></a>,
etc.
</ul>

<h3><tt>install.site</tt>/<tt>upgrade.site</tt>-Skripte</h3>
Als letzten Schritt im Installations/Upgrade-Prozess sucht das Skript im
root-Verzeichnis des neu installierten/aktualisierten System nach
<tt>install.site</tt> oder <tt>upgrade.site</tt>, je nach aktuellem
Prozess, und führt das Skript in einer Umgebung aus, die auf das 
Wurzelverzeichnis des installierten/aktualisierten System
,<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=8">chroot</a>ed'
ist. Denke daran, dass das Upgrade von einem gebootetem Dateisystem
aus ausgeführt wird, so dass dein Ziel tatsächlich auf <tt>/mnt</tt>
gemountet ist. Trotzdem kann dein Skript so geschrieben werden, als ob
es im ,normalen' Wurzelverzeichnis deines Dateisystems ausgeführt
wird. Da das Skript ausgeführt wird, wenn alle Dateien bereits
installiert worden sind, hast du fast volle Funktionalität deines
Systems (allerdings im ,single user'-Modus), wenn dein Skript läuft.

<p>
Bedenke, dass das <tt>install.site</tt>-Skript in der
<tt>siteXX.tgz</tt>-Datei liegen sollte, während das
<tt>upgrade.site</tt>-Skript vor dem Upgrade in das Wurzelverzeichnis
gelegt werden kann; oder in eine <tt>siteXX.tgz</tt>-Datei.

<p>
Die Skripte können für viele Dinge verwendet werden:
<ul>
<li>Entferne Dateien, die installiert/aktualisiert worden sind, die du
auf dem System aber nicht haben möchtest.
<li>Entferne/aktualisiere/installiere die
<a href="faq15.html#PkgMgmt">Packages</a>, die du auf dem installierten
System haben möchtest.
<li>Erstelle ein <a href="faq14.html#Backup">sofortiges Backup/Archiv</a>
des neuen Systems, bevor du es dem Rest der Welt aussetzt.
<li>Verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>,
um die Systemzeit einzustellen.
</ul>

<p>
Die Kombination von <tt>siteXX.tgz</tt>- und
<tt>install.site/upgrade.site</tt>-Dateien sollen den Benutzern eine
breite Palette von Fähigkeiten bieten, ohne dass sie selbst eigene
Installationssets erstellen müssen.

<a name="Multiple"></a>
<h2>4.14 - Wie kann ich eine Anzahl gleichartiger Systeme
installieren?</h2>
Hier sind einige Anwendungen aufgelistet, die du verwenden kannst, wenn
du eine Anzahl von ähnlichen OpenBSD-Systemen installieren musst.

<h3><tt>siteXX.tgz</tt>- und <tt>install/upgrade.site</tt>-Dateien</h3>
Siehe den <a href="#site">vorherigen</a> Artikel.

<h3>Von dump(8) wiederherstellen</h3>
Auf den meisten Plattformen beinhaltet das Bootmedium das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>-Programm,
welches verwendet werden kann, um ein Backup, das mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
erstellt wurde, zu extrahieren.
Daher kannst du von
<a href="#MkFlop">Diskette</a>,
<a href="../../de/orders.html">CD</a> oder
<a href="#bsd.rd">bsd.rd</a>-Datei booten, dann
<a href="faq14.html#fdisk">fdisk</a>,
<a href="faq14.html#disklabel">disklabel</a> ausführen und mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore</a>
die gewünschte Konfiguration von Band oder einem anderen Medium
wiederhestellen und die <a href="faq14.html#InstBoot">Bootblöcke</a>
installieren. Weitere Details gibt es
<a href="faq14.html#Backup">hier</a>.

<h3>Platten-,imaging'</h3>
Leider existiert kein bekanntes Platten-,imaging'-Programm, das FFS
unterstützt und so nur den aktiv genutzten Dateispeicher nutzen
könnte. Die meisten der größeren Platten-,imaging'-Lösungen
behandeln OpenBSD-Partitionen als ,allgemeine' Partition und können ein
Image der gesamten Platte erzeugen. Damit erreichst
du zwar dein Ziel, aber verbrauchst für gewöhnlich eine
große Menge an Speicher -- eine leere, 10 G große
<tt>/home</tt>-Partition wird 10 G Speicher im Image verbrauchen, selbst
wenn sich dort keine einzige Datei befindet. Während du normalerweise
ein Laufwerksimage auf ein größeres Laufwerk installieren kannst, wirst
du nicht in der Lage sein, den zusätzlichen Speicher direkt zu nutzen,
und du wirst auch nicht in der Lage sein, ein Image auf ein kleineres
Laufwerk zu installieren.

<p>
Falls das eine akzeptable Situation für dich ist, könnte der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd</a>-Befehl
deinen Ansprüchen, eine Platte auf eine andere zu kopieren,
Sektor für Sektor, genügen. Dies bietet dir die gleiche
Funktionalität wie die der kommerziellen Produkte ohne den Kosten.

<a name="getdmesg"></a>
<h2>4.15 - Woher bekomme ich eine dmesg(8), damit ich ein Problem mit
der Installation melden kann?</h2>
Wenn man <a href="../../de/report.html">ein Problem meldet</a>, ist es
entscheidend, eine komlette
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
des Systems einzufügen.
Wie auch immer, oft ist es so, dass du dies machen musst, wenn das
System nicht ordnungsgemäß funktioniert oder nicht installieren
will, so dass du weder Platten-, Netzwerk- oder andere Ressourcen zur
Verfügung hast, um deine dmesg an die passende
<a href="../../de/mail.html">Mailingliste</a> zu senden. Es gibt aber
andere Wege:

<ul>
<li><b>Diskette</b>  Die Bootdisketten und die CD-ROM haben
genügend Anwendungen, um deine dmesg auf eine MSDOS-Diskette
zu schreiben, damit eine andere Maschine sie lesen kann. Lege eine
MSDOS-formatierte Diskette in dein Diskettenlaufwerk und führe
folgende Befehle aus:

<pre>
     mount -t msdos /dev/fd0a /mnt
     dmesg > /mnt/dmesg.txt
     umount /mnt
</pre>
Falls du ein anderes OpenBSD-System besitzt, kannst du es ebenfalls
auf eine OpenBSD-kompatible Diskette schreiben -- oftmals hat die
Bootdiskette genügend freien Raum, um die dmesg zu halten. In
dem Fall lasse das ,<tt>-t msdos</tt>' oben weg.

<p>
<li><b>Serielle Konsole:</b>
Eine serielle Konsole verwenden und die Ausgabe auf einer anderen
Maschine abzufangen ist oftmals der beste Weg, um Diagnoseinformationen
erhalten zu können - insbesondere, wenn der Computer direkt nach dem
Hochfahren in einem ,panic' endet. Neben einem weiteren Computer
benötigst du ebenfalls ein passendes serielles Kabel (oft ein
Null-Modem-Kabel) und ein Terminalemulator-Programm, das die
Bildschirmausgabe in eine Datei schreiben kann.

<p>
Generelle Informationen zum Aufsetzen eines seriellen Terminals
sind <a href="faq7.html#SerCon">an einer anderen Stelle der FAQ</a>
verfügbar;
um eine Aufzeichnung der Installation abfangen zu können, sind in der
Regel folgende Befehle ausreichend.

<p><b>i386</b>

<p>
Gib am Bootloaderprompt ein

<p>
<blockquote>
<pre>
boot> <b>set tty com0</b>
</pre>
</blockquote>

<p>
Dies teilt OpenBSD mit, dass die erste serielle Schnittstelle
(in PC-Dokumentationen oft COM1 oder COMA genannt) als serielle Konsole
verwendet werden soll.
Die standardmäßige Baudrate ist 9600.

<p><b>Sparc/Sparc64</b>

<p>
Diese Maschinen starten automatisch mit einer seriellen Konsole, wenn
sie ohne angeschlossene Tastatur gestartet wurden.
Falls du Tastatur und Monitor angeschlossen hast, kannst du das System
trotzdem dazu bringen, eine serielle Konsole zu verwenden, indem du
folgende Befehle am <tt>ok</tt>-Prompt aufrufst.

<p>
<blockquote>
<pre>
ok <b>setenv input-device ttya</b>
ok <b>setenv output-device ttya</b>
ok <b>reset</b>
</pre>
</blockquote>

<p>
<li><b>FTP:</b>  Unter bestimmten Umständen und der Voraussetzung,
dass du zuerst dein Netzwerk richtig eingrichtet hast, kann es dir
möglich sein, mit Hilfe des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>-Clients
der Bootdiskette oder CD-ROM, die dmesg zu einem lokalen
FTP-Server zu senden, von wo aus du sie später wiederholen kannst.
</ul>
<p>

<a name="bsdrdaout"></a>
<h2>4.16 - OpenBSD unter Verwendung von <tt>bsd.rd-aout</tt>
upgraden/neuinstallieren</h2>

Es ist normalerweise möglich, Upgrades und Installationen mit
dem <a href="faq4.html#bsd.rd">bsd.rd</a>-Kernel durchzuführen.
Mit OpenBSD 3.4 allerdings wechselte die i386-Plattform das
ausführbare Format von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=a.out&amp;sektion=5">a.out</a> auf
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=elf&amp;sektion=5">ELF</a>,
so dass ältere
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>Bootloader</a> (OpenBSD 3.3 und früher) nicht unter dem
Neuen-Format-<tt>bsd.rd</tt>-Kernel ausgeführt werden können.

<p>
Um dieses Problem zu umgehen und Upgrades unter Verwendung von
<tt>bsd.rd</tt> gewährleisten zu können, wurde eine
a.out-Version von <tt>bsd.rd</tt> in der <a href="../../de/ftp.html">
OpenBSD/i386-v3.5-FTP-Distribution</a> zur Verfügung gestellt.
Diese Datei, <tt>bsd.rd-a.out</tt>, kann von OpenBSD 3.3 und niedriger
gebootet werden, aber es ist ein authentischer OpenBSD-3.5-Kernel, mit
eingebundenem ELF-Bootloader, so dass er zum Bootstrappen von
OpenBSD/i386 3.5 von einem älteren System aus verwendet werden kann.

<p>
Lade einfach <tt>bsd.rd-a.out</tt> herunter und platziere ihn in dem
root-Verzeichnis deines Systems.
Lade ihn anstatt dem normalen <tt>/bsd</tt>- oder
<tt>/bsd.rd</tt>-Kernels, so wie es <a href="faq4.html#bsd.rd">hier</a>
gezeigt wird (Natürlich unter Angabe von <tt>bsd.rd-a.out</tt> als
Bootkernel).

<p>
Nach der Installation einer minimalen 3.5-Installation (<tt>base35.tgz,
etc35.tgz, bsd</tt>), lade dir eine 3.8- (oder <i>-snapshot</i>)
-<tt>bsd.rd</tt>-Datei herunter und installiere davon.

<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Wo man OpenBSD herbekommt]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a> 
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq4.html,v 1.212 ]
$Translation: faq4.html,v 1.93 2005/12/06 20:37:27 paldium Exp $
-->
$OpenBSD: faq4.html,v 1.79 2005/12/07 15:31:45 saad Exp $
</small>
</body>
</html>
