<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>4 - Installationsanleitung für OpenBSD 4.0</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2006 by OpenBSD.">
</head>

<!-- Passes validator.w3.org.  Please keep it this way -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Wo man OpenBSD herbekommt]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<h1><font color="#e00000">4 - Installationsanleitung für
OpenBSD 4.0</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href= "#Overview"    >4.1 - Übersicht der
   OpenBSD-Installationsprozedur</a>
<li><a href= "#Checklist"   >4.2 - Checkliste für die Installation</a>
<li><a href="#MkInsMedia"   >4.3 - Bootfähige
   OpenBSD-Installationsmedien erzeugen</a>
    <ul>
    <li><a href="#UnixFlop" >4.3.1 - Disketten unter Unix erzeugen</a>
    <li><a href="#DosFlop"  >4.3.2 - Disketten unter Windows oder DOS
       erzeugen</a>
    <li><a href="#MkCD-ROM" >4.3.3 - Eine Boot-CD erzeugen</a>
    </ul>
<li><a href="#Boot"         >4.4 - Das Booten der
   OpenBSD-Installationsimages</a>
<li><a href="#Install"      >4.5 - Eine Installation durchführen</a>
  <ul>
  <li><a href="#Start"      >4.5.1 - Mit der Installation beginnen</a>
  <li><a href="#Disks"      >4.5.2 - Festplatte(n) einrichten</a>
  <li><a href="#Hostname"   >4.5.3 - Den Hostnamen des Systems
     setzen</a>
  <li><a href="#Network"    >4.5.4 - Das Netzwerk konfigurieren</a>
  <li><a href="#InstMedia"  >4.5.5 - Das Installationsmedium
     auswählen</a>
  <li><a href="#Filesets"   >4.5.6 - Dateisets auswählen</a>
  <li><a href="#Finish"     >4.5.7 - Zum Ende kommen</a>
  </ul>

<li><a href= "#FilesNeeded" >4.6 - Welche Dateien werden zur
   Installation benötigt?</a>
<li><a href= "#Partitioning" >4.7 - Wie viel Platz brauche ich für eine
   OpenBSD-Installation?</a>
<li><a href= "#Multibooting">4.8 - Multibooting OpenBSD/i386</a>
<li><a href= "#SendDmesg"   >4.9 - Nach der Installation deine dmesg an
   dmesg@openbsd.org schicken</a>
<li><a href= "#AddFileSet"  >4.10 - Ein Dateiset nach der Installation
   hinzufügen</a>
<li><a href= "#bsd.rd"      >4.11 - Was ist bsd.rd?</a>
<li><a href= "#InstProb"    >4.12 - Allgemeine
   Installationsprobleme</a>
  <ul>
  <li><a href="#cpq16m"     >4.12.1 - Mein Compaq erkennt nur 16&nbsp;M
     RAM</a>
  <li><a href="#noboot"     >4.12.2 - Mein i386 bootet nach der
     Installation nicht</a>
  <li><a href="#sshhang"    >4.12.3 - Mein System bootet, aber hängte
     bei der ssh-Schlüsselgenerierung</a>
  <li><a href="#noftplist"  >4.12.4 - Ich bekam die Meldung »Failed to
     change directory« als ich die Installation durchführte</a>
  <li><a href="#blankfdisk" >4.12.5 - Meine fdisk-Partitionstabelle ist
     kaputt oder leer!</a>
  </ul>
<li><a href= "#site"        >4.13 - Anpassen des
  Installationsprozesses</a>
<li><a href= "#Multiple"    >4.14 - Wie kann ich mehrere gleichartige
   Systeme installieren?</a>
<li><a href="#getdmesg"     >4.15 - Woher bekomme ich eine dmesg(8),
   damit ich ein Problem mit der Installation melden kann?</a>
</ul>
<hr>

<p>
<a name= "Overview"></a>
<h2>4.1 - Übersicht der OpenBSD-Installationsprozedur</h2>

<p>
OpenBSD hat eine robuste und anpassungsfähige textbasierte
Installationsroutine und kann von einer einzelnen Diskette aus
installiert werden. Die meisten Architekturen folgen einer ähnlichen
Installationsroutine; allerdings gibt es Unterschiede in den Details.
In jedem Fall wird dringend dazu geraten, das plattformspezifische
INSTALL-Dokument im <i>Plattform</i>-Verzeichnis auf der CD-ROM oder der
FTP-Seiten (z.&nbsp;B. <tt>i386/INSTALL.i386</tt>,
<tt>mac68k/INSTALL.mac68k</tt> oder <tt>sparc/INSTALL.sparc</tt>)
durchzulesen.

<p>
Die OpenBSD-Installation benutzt einen speziellen Kernel mit einigen
Werkzeugen und Installationsskripten, die sich auf einer vorgeladenen
RAM-Disk befinden. Nachdem dieser Kernel
gebootet wurde, wird das Betriebssystem aus einigen komprimierten
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>-Dateien
(<tt>.tgz</tt>) extrahiert, die sich nicht auf der vorgelandenen
RAM-Disk befinden und daher von einer anderen Quelle bezogen werden
müssen.
Es existieren mehrere Wege, diesen Installationskernel zu booten:

<ul>
<li><b>Diskette:</b>
Diskettenimages werden zur Verfügung gestellt, die benutzt werden
können, um Installationsdisketten auf einem anderen
<a href="#UnixFlop">Unix-ähnlichen</a> System oder
<a href="#DosFlop">DOS/Windows</a>-System zu erstellen.
Typische Dateinamen sind <tt>floppy40.fs</tt>, obwohl für einige
Plattformen mehrere Diskettenimages vorhanden sind.

<li><b>CD-ROM:</b> Für einige Plattformen wird ein CD-ROM-Image
(<tt>cd40.iso</tt>) bereitgestellt, das die Erstellung von einer
bootfähigen CD-ROM ermöglicht. Dies beinhaltet nur den
Installationskernel - Installationsdateien müssen weiterhin via FTP
oder einer anderen Quelle beschaffen werden.
Du kannst natürlich deine eigene CD-ROM erstellen, die mit allen
Dateien und Programmen ausgestattet ist, die du haben möchtest.

<li><b>Bestehende Partition:</b> Der <a href="#bsd.rd">RAM-Disk</a>-Kernel
kann von einer bereits existierenden OpenBSD-Partition geladen
werden (z.&nbsp;B. nach einem Upgrade oder einer Neuinstallation).

<li><b>Netzwerk:</b> Manche Systeme unterstützen das Booten über
das Netzwerk (zum Beispiel unter Verwendung von
<a href="faq6.html#PXE">PXE</a> oder einem anderen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8">Netzwerkbootprozess</a>).

<li><b>Ein Dateisystemimage auf Platte schreiben:</b> ein
Dateisystemimage, das auf eine existierende Partition geschrieben und
daraufhin gebootet werden kann.

<li><b>Bootfähiges Band:</b> Einige Systeme unterstützen das Booten
von Band. Diese Bänder können anhand der
INSTALL.<i>Plattform</i>-Anleitung erstellt werden.

</ul>

Nicht jede <a href="../../de/plat.html">Plattform</a> unterstützt alle
Bootmöglichkeiten:

<ul>
<li><a href="../../de/alpha.html"><b>alpha:</b></a> Diskette, CD-ROM,
das Schreiben eines Diskettenimages auf Festplatte.

<li><a href="../../amd64.html"><b>amd64:</b></a> Diskette, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../cats.html"><b>cats:</b></a> CD-ROM.

<li><a href="../../de/hp300.html"><b>hp300:</b></a> CD-ROM, Netzwerk.

<li><a href="../../de/hppa.html"><b>hppa:</b></a> Netzwerk.

<li><a href="../../de/i386.html"><b>i386:</b></a> Diskette, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../de/mac68k.html"><b>mac68k:</b></a> Unter Verwendung
von Anwendungen unter Mac OS gebootet.
Siehe
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/4.0/mac68k/INSTALL.mac68k">INSTALL.mac68k</a>
für Details.

<li><a href="../../de/macppc.html"><b>macppc:</b></a> CD-ROM, Netzwerk.

<li><a href="../../de/mvme68k.html"><b>mvme68k:</b></a> Netzwerk,
bootfähiges Band.

<li><a href="../../de/mvme88k.html"><b>mvme88k:</b></a> Netzwerk,
bootfähiges Band.

<li><a href="../../de/sparc.html"><b>sparc:</b></a> Diskette, CD-ROM,
Netzwerk, Schreiben eines Images auf eine existierende Partition.

<li><a href="../../de/sparc64.html"><b>sparc64:</b></a> Diskette
(nur U1/U2), CD-ROM, Netzwerk, Schreiben eines Images auf eine
existierende Partition.

<li><a href="../../de/vax.html"><b>vax:</b></a> Diskette, Netzwerk.

</ul>

Alle Plattformen können ebenfalls einen
<a href="#bsd.rd">bsd.rd</a> zum Neuinstallieren oder
Aktualisieren verwenden.

<p>
Wenn der Installationskernel erst einmal gebootet ist, hast du mehrere
Möglichkeiten, von wo aus du die <a href="#FilesNeeded"
>Installationsdateisets</a> herbekommen kannst. Auch hier bietet nicht
jede Plattform alle Möglichkeiten.

<ul>
<li><b>CD-ROM:</b> Natürlich bevorzugen wir, dass du das
<a href="../../de/orders.html">offizielle CD-ROM-Set</a> verwendest.
Für spezielle Notwendigkeiten kannst du aber auch dein eigenes
erstellen.

<li><b>FTP:</b>
Entweder einen der
OpenBSD-<a href="../../de/ftp.html">FTP-Mirror</a>
oder deinen eigenen FTP-Server, der die Dateisets hält.

<li><b>HTML:</b>
Entweder einen der
OpenBSD-<a href="../../de/ftp.html#http">HTTP-Mirror</a>
oder deinen eigenen Webserver, der die Dateisets hält.

<li><b>Lokale Festplattenpartition:</b>
In vielen Fällen kannst du die Dateisets von einer anderen Partition
einer lokalen Festplatte aus installieren.
Zum Beispiel auf <a href="../../de/i386.html">i386</a> kannst du von
einer FAT-Partition oder einer CD-ROM mit ISO9660-, Rock-Ridge- oder
Joliet-Format aus installieren.
In einigen Fällen musst du das Dateisystem manuell einbinden, bevor
du es verwenden kannst.

<li><b>NFS:</b>
Manche Plattformen unterstützen NFS-Mounts für die Dateisets.

<li><b>Band:</b>
Dateisets können ebenfalls von einem unterstützten Band
gelesen werden. Details darüber, wie ein solches Band erstellt werden
muss, befinden sich im <tt>INSTALL.</tt><i>Plattform</i>-Dokument.
</ul>

<a name="Checklist"></a>
<h2>4.2 - Checkliste für die Installation</h2>

<p>
Bevor du mit der eigentlichen Installation beginnst, solltest du dir im
Klaren sein, was du eigentlich am Ende haben willst.

Mindestens die folgenden Punkte sollten daher vorher geklärt sein:
<ul>
<li>Name der Maschine
<li>Die eingebaute Hardware
  <ul>
  <li>Prüfe die Kompatibilität anhand der
      Kompatibilitätsseite für deine Hardware.
  <li>Wenn du ISA-Komponenten verwendest, musst du die Einstellungen
      kennen und prüfen, ob sie den Anforderungen von OpenBSD
      entsprechen.
  </ul>
<li>Die gewünschte Installationsmethode. (CD-ROM, FTP etc.)
<li>Wie soll das System gepatcht werden falls ein wichtiges Problem
    entdeckt wird?
  <ul>
  <li>Wenn es lokal ausgeführt werden soll, musst du
      <a href="#Partitioning">genügend freien Speicher</a> für den
      Source-Tree und dessen Erzeugung haben.
  <li>Ansonsten musst du Zugriff auf eine andere Maschine haben, das ein
      gepatchtes <a href="faq5.html#Release">Release</a>
      zur Verfügung stellt.
  </ul>
<li>Das erwünschte Plattenlayout
  <ul>
  <li>Müssen vorhandene Daten irgendwo gesichert werden?
  <li>Soll OpenBSD neben einem anderen Betriebssystem auf dem Rechner
      existieren? Wenn ja: auf welche Weise sollen die beiden Systeme
      gebootet werden, brauchst du vielleicht einen Bootmanager?
  <li>Wird OpenBSD die ganze Festplatte belegen oder möchtest du eine
      existierende Partition oder ein existierendes OS behalten (oder
      Platz für zukünftige Dinge)?
  <li>Wie willst du die OpenBSD-Partition selbst aufteilen?
  </ul>
<li>Netzwerkeinstellungen, falls du nicht DHCP verwendest:
  <ul>
  <li>Domänenname
  <li>Domainnameserveradresse(n) (DNS)
  <li>IP-Adressen und Subnetzmasken für jede Netzwerkkarte.
  <li>Gatewayadressen
  </ul>
<li>Wirst du auf diesem System X benutzen?
</ul>


<a name="MkInsMedia"></a>
<h2>4.3 - Bootfähige OpenBSD-Installationsmedien erzeugen</h2>

<p>
Als Beispiel werden wir die Installationsmedien betrachten, die für
die <a href="../../de/i386.html">i386</a>- und
<a href="../../de/sparc.html">sparc</a>-Plattformen bereitstehen.

<p>
Die <a href="../../de/i386.html">i386</a>-Plattform besitzt sechs
separate Installationsdiskimages, die ausgewählt werden können:

<ul>
<li><b><tt>floppy40.fs</tt></b> (Desktop-PC) unterstützt viele
  PCI- und ISA-Netzwerkkarten (NICs), IDE- und einfache SCSI-Adapter
  und bietet wenig Unterstützung für PCMCIA. Die meisten Benutzer
  werden dieses Image verwenden, wenn sie von einer Diskette aus
  booten.
<li><b><tt>floppyB40.fs</tt></b> (Server) unterstützt viele
  RAID-Controller und einige der selteneren SCSI-Adapter. Viele der
  Standard-SCSI-Adapter und viele EISA- und ISA-Netzwerkkarten werden
  nicht unterstützt.
<li><b><tt>floppyC40.fs</tt></b> (Laptops) unterstützt viele der
  Cardbus- und PCMCIA-Karten, die man in Laptops findet.
<li><b><tt>cdrom40.fs</tt></b> ist eine Kombination aller drei anderen
  Bootdisketten. Das Image kann dazu verwendet werden, eine bootfähige
  2,88-M-Diskette zu erzeugen.
<li><b><tt>cd40.iso</tt></b> ist ein ISO9660-Image, das zum Erstellen
  einer bootfähigen CD mit den bekanntesten
  CD-ROM-Brennsoftwareprodukten auf den meisten Plattformen verwendet
  werden kann. Dieses Image hat die größte Auswahl an Treibern und ist
  normalerweise die empfohlene Wahl, wenn deine Hardware von CD-ROM
  booten kann.
<li><b><tt>cdemu40.iso</tt></b> ist ein ISO9660-Image, das zum Booten
  eine Diskettenemulation benutzt - und zwar das 2,88-M-Image
  <tt>cdrom40.fs</tt>. Hoffentlich brauchen nur wenige Leute dieses
  Image - die meisten Leute werden <tt>cd40.iso</tt> benutzen. Verwende
  <tt>cdemu40.iso</tt> nur, wenn <tt>cd40.iso</tt> bei dir nicht
  funktioniert.
</ul>

Ja, es kann Situationen geben, in denen du eine Diskette für deinen
SCSI-Controller brauchst und eine andere für deine Netzwerkkarte.
Zum Glück geschieht das selten und kann normalerweise vermieden werden.

<p>
Die <a href="../../de/sparc.html">sparc</a>-Plattform besitzt drei
separate Installationsdiskimages, die ausgewählt werden können.

<ul>
<li><b><tt>floppy40.fs:</tt></b> Unterstützt Systeme mit
  Diskettenlaufwerk.
<li><b><tt>cd40.iso</tt></b> Ein ISO-Image, das zum Erstellen einer
  CD verwendet werden kann, um SPARC-Systeme von einer CD-ROM aus booten
  zu können.
<li><b><tt>miniroot40.fs</tt></b> Kann auf eine Swappartition
  geschrieben und gebootet werden.
</ul>

<a name="MkFlop"></a>
<a name="UnixFlop"></a>
<h3>4.3.1 - Disketten unter Unix erzeugen</h3>

<p>
Um eine formatierte Diskette zu erzeugen, benutze einfach das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdformat&amp;sektion=1&amp;arch=i386">fdformat(1)</a>-Kommando.
Damit kannst du deine Diskette sowohl formatieren als auch auf defekte
Sektoren prüfen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>fdformat /dev/rfd0c</b>
  Format 1440K floppy `/dev/rfd0c'? (y/n): y
  Processing VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV done.
</pre></td></tr></table>

<p>
Ist deine Ausgabe wie im obigen Beispiel, dann ist deine Diskette in
Ordnung. Wenn du - warum auch immmer - nicht ALLE Vs siehst, dann ist
deine Diskette höchstwahrscheinlich fehlerhaft und du solltest eine neue
verwenden.

<p>
Bedenke, dass einige Unix-ähnliche Systeme verschiedene Befehle zum
Formatieren von Disketten haben.
Konsultiere das Handbuch deines Systems für den exakten Ablauf.

<p>
Hast du dann eine korrekt formatierte Diskette, ist es an der Zeit, das
Installationsimage auf die Diskette zu schreiben. Wenn du sie auf einer
OpenBSD-Maschine oder auf einem anderen UNIX-ähnlichen OS erstellst,
kannst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=0">dd(1)</a>
verwenden.
Ein Beispiel für <tt>dd(1)</tt> findest du hier:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>dd if=floppy40.fs of=/dev/rfd0c bs=32k</b>
</pre></td></tr></table>

<p>
Ist das Image geschrieben, überprüfe es mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cmp&amp;sektion=1">cmp(1)</a>-Befehl,
um sicherzugehen, dass die Kopie dem Original entspricht. Wenn Diskette
und Image identisch sind, wirst du einfach einen weiteren Prompt sehen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cmp /dev/rfd0c floppy40.fs</b>
</pre></td></tr></table>

<a name="DosFlop"></a>
<h3>4.3.2 - Disketten unter Windows oder DOS erzeugen</h3>

<p>
Dieses Kapitel beschreibt, wie man Installationsimages unter Windows
oder DOS auf eine Diskette schreibt.
Du kannst die Anwendungen, die unten erwähnt werden, aus dem
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/4.0/tools/">tools</a>-Verzeichnis
von einem der FTP-Mirror oder aus dem <tt>4.0/tools</tt>-Verzeichnis auf
CD1 des OpenBSD-CD-Sets bekommen.

<p>
Zur Vorbereitung der Diskette unter MS-DOS oder Windows benutzt man
einfach die bordeigenen Mittel zum Formatieren.

<p>
Das Installationsimage wird mittels
<i>rawrite</i>, <i>fdimage</i> oder <i>ntrw</i> auf die formatierte
Diskette geschrieben. Unter Windows NT, 2000 und XP funktioniert
<i>rawrite</i> nicht.

<p>
Bedenke, dass <tt>FDIMAGE.EXE</tt> und <tt>RAWRITE.EXE</tt>
MS-DOS-Applikationen sind und daher auch den
8.3-Dateinamenbeschränkungen von MS-DOS unterliegen.
Da sowohl <tt>floppyB40.fs</tt> als auch <tt>floppyC40.fs</tt> längere
Dateinamen haben, wirst du überprüfen müssen,
wie dein System die Dateien an sein 8.3-Format angepasst hat,
bevor du <tt>FDIMAGE.EXE</tt> oder <tt>RAWRITE.EXE</tt> benutzen
kannst, um deine Bootdiskette zu schreiben.

<p>
Ein Beispiel für <i>rawrite</i>:
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <b>rawrite</b>
  RaWrite 1.2 - Write disk file to raw floppy diskette

  Enter source file name: <b>floppy40.fs</b>
  Enter destination drive: <b>a</b>
  Please insert a formatted diskette into drive A: and press -ENTER- : <i><b>Enter</b></i>
</pre></td></tr></table>

<p>
Ein Beispiel für <i>fdimage</i>:
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <strong>fdimage -q floppy40.fs a:</strong>
</pre></td></tr></table>

<p>
Ein Beispiel für <i>ntrw</i>:
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <strong>ntrw floppy40.fs a:</strong>
  3.5", 1.44MB, 512 bytes/sector
  bufsize is 9216
  1474560 bytes written
</pre></td></tr></table>

<a name="MkCD-ROM"></a>
<h3>4.3.3 - Eine Boot-CD erzeugen</h3>

<p>
Um eine CD-ROM zu erstellen, kannst du die <tt>cd40.iso</tt>-Datei
verwenden, oder (im Falle der i386- und am64-Plattformen) auch
<tt>cdrom40.fs</tt> als bootfähiges Diskettenimage nutzen, das zum
Booten des i386-Systems von CD-ROM aus dient. Das Herausfinden der
exakten Details mit den zur Verfügung stehenden Anwendungen sei an
dieser Stelle dem Leser überlassen.

<p>
Einige der Anwendungen unter OpenBSD sind:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mkhybrid&amp;sektion=8">mkhybrid(8)</a>
<li><a href="http://cdrecord.berlios.de/old/private/cdrecord.html">cdrecord</a>,
Teil der cdrtools-Kollektion im
<a href="faq15.html">Packages- und Portssystem von OpenBSD</a>.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>s
»track at once«-Schreiboption (tao), die mit 4.0 neu eingeführt wurde.
</ul>

<a name="Boot"></a>
<h2>4.4 - Das Booten der OpenBSD-Installationsimages</h2>

<h3>i386/amd64 booten</h3>

Das Installationsimage auf den i386- und am64-PC-Architekturen zu booten
ist nichts Neues für die meisten Leute. Wenn du die Diskette verwendest,
dann lege sie einfach in dein Diskettenlaufwerk und starte dein System.
Das Installationsimage wird automatisch laden, wenn in deinem BIOS das
Booten von Diskette aktiviert ist. Wenn du von CD starten willst, dann
musst du im System-BIOS das Booten von CD-ROM erlauben. Einige
ältere BIOSe haben diese Option nicht und du musst eine Diskette
zum Starten des Installationsimages verwenden. Keine Sorge, du kannst
auch dann von CD installieren, wenn von Diskette gebootet wurde.

<p>
Du kannst ebenfalls installieren, indem du <a href="#bsd.rd">bsd.rd</a>
von einer existierenden OpenBSD-Partition oder vom Netzwerk unter
Verwendung vom <a href="faq6.html#PXE">PXE-Bootprozess</a> aus bootest.

<h3>sparc/sparc64 booten</h3>

<b>HINWEIS:</b>
Auf der <a href="../../de/sparc64.html">sparc64</a>-Plattform können nur
die SBus-Maschinen (Ultra 1, Ultra 2) von einer Diskette aus gebootet
werden.

<p>
Um von Diskette zu starten, lege die OpenBSD-Installationsdiskette in
das Diskettenlaufwerk ein.
Dann verwende folgendes Kommando, um von der Diskette zu booten:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot floppy</b>
</pre></td></tr></table>

<p>
Um von CD-ROM zu starten, lege die OpenBSD-CD-ROM in dein Laufwerk.
Wenn deine Sun nur ein CD-ROM Laufwerk hat, dann gehe an den Bootprompt,
an dem du <tt>boot cdrom</tt> ausführen kannst:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot cdrom</b>
</pre></td></tr></table>

<p>
Natürlich wird dies nur im neuen Befehlsmodus funktionieren. Wenn
du am alten Befehlsmodus bist (ein rechter Pfeil), gib »n« ein, um in
den neuen zu gelangen (wenn du eine alte sparc vor sun4c hast, dann
hast du vielleicht keinen neuen Befehlsmodus: hier hilft dir nur
experimentieren). Wenn du mehrere CD-ROM-Laufwerke hast, dann musst du
vom richtigen starten. Verwende <tt>probe-scsi</tt> im neuen
Befehlsmodus.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>probe-scsi</b>

  Target 0
    Unit 0   Disk     QUANTUM LIGHTNING 365S
  Target 1
    Unit 0   Removable Disk     QUANTUM EMPIRE_1080S
  Target 3
    Unit 0   Removable Disk     Joe's CD ROM
</pre></td></tr></table>

<p>
Suche das richtige CD-ROM und merke dir die Targetnummer.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot /sbus/esp/sd@X,0</b>
</pre></td></tr></table>


<a name="Install"></a>
<h2>4.5 - Eine Installation durchführen</h2>
<a name="Start"></a>
<h3>4.5.1 - Mit der Installation beginnen</h3>
<!-- XXXrelease -->
Was auch immer du für eine Methode zum Booten gewählt hast - nun ist es
an der Zeit, sie zu benutzen. Während des Bootprozesses werden der
Kernel und alle Programme zum Installieren von OpenBSD in den
Hauptspeicher geladen. Die größten Probleme entstehen beim Booten von
defekten Disketten oder bei der Zuweisung von Festplatten. Die
Bootdiskette ist ziemlich vollgepackt - jeder defekte Block wird
Probleme verursachen.

<p>
An fast jeder Stelle während des OpenBSD-Installationsprozesses kannst
du den aktuellen Installationsversuch abbrechen, indem du STRG-C
drückst, und kannst ihn ohne Neustart durch Aufruf von <tt>install</tt>
im Shellprompt wieder beginnen.

<p>
Wenn das Booten erfolgreich war, wirst du eine Menge Textmeldungen
vorbeiziehen sehen. Dieser Text (bei vielen Plattformen in weißer
Schrift auf blauem Hintergrund) ist die sogenannte
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg</a>.
Der Kernel erzählt dir, welche Geräte gefunden wurden und wo.
Mach dir nicht die Mühe, den Text zu behalten. Eine Kopie davon wird
in <tt>/var/run/dmesg.boot</tt> gespeichert.

<p>
Dann wirst du das Folgende sehen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  rootdev=0x1100 rrootdev=0x2f00 rawdev=0x2f02
  erase ^?, werase ^W, kill ^U, intr ^C, status ^T
  (I)nstall, (U)pgrade or (S)hell? <b>i</b>
</pre></td></tr></table>

<p>
Und damit erreichen wir auch schon die erste Frage. Meistens werden die
drei Möglichkeiten angeboten:
<ul>
<li><b>Install:</b> OpenBSD auf dein System installieren und dabei
alles überschreiben, was dort vorher war. Natürlich kann man hier auch
einige Teile der Festplatte unberührt lassen (z.&nbsp;B.
<tt>/home</tt>), aber ansonsten wird alles andere überschrieben.
<li><b>Upgrade:</b> Installiere neue <a href="#FilesNeeded"
>Installationsdateisets</a> auf dieser Maschine, aber überschreibe keine
Konfigurationsdateien, Benutzerdaten oder zusätzliche Programme.
Es wird keine Festplattenformatierung vorgenommen und auch die
Verzeichnisse /etc und /var werden nicht überschrieben.
Ein paar wichtige Hinweise:
<ul>
<li>Dir wird nicht die Möglichkeit angeboten, <tt>etc40.tgz</tt> zu
installieren. Nach der Installation musst du die Änderungen von
<tt>etc40.tgz</tt> <a href="upgrade40.html#etcUpdates">selbst in dein
System einbinden</a>, bevor du erwarten kannst, dass es voll
funktionsfähig sein wird. Das zu tun ist dann sehr wichtig, da sonst
einige Dienste wie beispielsweise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4">pf(4)</a>
möglicherweise nicht starten werden.

<li>Der Upgradeprozess ist nicht dazu da, um ganze Versionen
zu überspringen! Obwohl das meist funktioniert, wird es in keinem Fall
unterstützt. Mit OpenBSD 4.0 wird nur das Upgrade von 3.9 auf 4.0
unterstützt. Wenn du von einer älteren Version aktualisieren musst,
upgrade erst auf die darauf folgende Version. Sollte dein System sehr
alt sein, ziehe eine vollständige Neuinstallation in Erwägung.

</ul>
<!-- XXXversion -->
Weitere Informationen über das Upgraden zwischen den einzelnen Releases
können <a href="upgrade40.html">hier</a> gefunden werden.

<li><b>Shell:</b> Manchmal muss man Reparaturen oder Schritte
unternehmen, da das System sonst nicht mit einem normalen Kernel booten
wird. Dazu ist diese Option gedacht. Eine Anzahl weitere wichtiger
Werkzeuge befinden sich auf dem Bootmedium.
</ul>

In einigen Fällen wirst du die Upgrade-Option nicht vorfinden.
Nach einem <i>Flagday</i> ist es zum Beispiel nicht möglich, ein
direktes Upgrade zu machen - daher muss man das System von Grund auf
neuinstallieren.

<p>
In diesem Beispiel machen wir eine Installation. Der Upgradeprozess
ist aber recht ähnlich.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Welcome to the OpenBSD/i386 4.0 install program.

  This program will help you install OpenBSD in a simple and rational way. At
  any prompt except password prompts you can run a shell command by typing
  '!foo', or escape to a shell by typing '!'. Default answers are shown in []'s
  and are selected by pressing RETURN. At any time you can exit this program by
  pressing Control-C and then RETURN, but quitting during an install can leave
  your system in an inconsistent state.

  Specify terminal type: [vt220] <b><i>Enter</i></b>
  kbd(8) mapping? ('L' for list) [none] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
In den meisten Fällen ist der vorgeschlagene Terminaltyp passend.
Solltest du allerdings eine
<a href="faq7.html#SerCon">serielle Konsole</a> für die Installation
benutzen, wähle bitte die passende Konsole aus - nicht die
vorgeschlagene.

<p>
Wenn du keine Tastaturbelegung (keyboard encoding table) auswählst,
wird die US-Tastaturbelegung benutzt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IS YOUR DATA BACKED UP? As with anything that modifies disk contents, this
  program can cause SIGNIFICANT data loss.

  It is often helpful to have the installation notes handy. For complex disk
  configurations, relevant disk hardware manuals and a calculator are useful.

  Proceed with install? [no] <b>y</b>
</pre></td></tr></table>

<p>
Wenn du hier die vorgeschlagene Antwort gibst, landest du in einer Shell
und bekommst einen Prompt, nachdem die Installation sich beendet hat.

<p>
Die Installationshinweise beziehen sich hierbei auf die Installation von
CDs oder FTP-Servern, die dort in der Datei
<tt>INSTALL.<i>&lt;plat&gt;</i></tt> gefunden werden können (wobei
<i>&lt;plat&gt;</i> gegen deine
<a href="../../de/plat.html">Plattform</a> ausgetauscht werden muss
[zum Beispiel <tt>i386</tt>]).

<a name="Disks"></a>
<h3>4.5.2 - Festplatte(n) einrichten</h3>

<p>
Die Laufwerke unter OpenBSD einzurichten ist für alle Plattformen ein
wenig unterschiedlich. Bei <a href="../../de/i386.html">i386</a>,
<a href="../../amd64.html">amd64</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/zaurus.html">zaurus</a> und
<a href="../../cats.html">cats</a>
geschieht das Einrichten in zwei Etappen. Die eine geschieht mit
fdisk(8) und die andere mit disklabel(8).

<p>
Der ein oder andere wird ein wenig verwundert über die hier verwendete
Terminologie sein. Es sieht so aus, als ob wir das Wort Partition
auf zwei verschiedene Weisen benutzen. Diese Beobachtung ist richtig.
Es gibt zwei Schichten von Partitionierung auf den zuvor genannten
OpenBSD-Plattformen. Die erste könnte man als
Betriebssystempartitionierung bezeichnen: so legen zum Beispiel viele
Betriebssysteme ihre Partitionen an. Die zweite bezieht sich darauf,
wie OpenBSD seine Partition in weitere individuelle Dateisysteme
einteilt. Die erste Schicht ist sichtbar als eine Partition für DOS,
Windows und jedes weitere Betriebssystem, das dieses Plattenlayout
verwenden. Die zweite Schicht dagegen ist nur für OpenBSD und solche
Systeme sichtbar, die OpenBSD-Dateisysteme direkt lesen können.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Cool!  Let's get to it...

  You will now initialize the disk(s) that OpenBSD will use. To enable all
  available security features you should configure the disk(s) to allow the
  creation of separate filesystems for /, /tmp, /var, /usr, and /home.

  Available disks are: wd0.
  Which one is the root disk? (or done) [wd0] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Die Rootdisk ist die Festplatte, von der das System booten soll
und wo sich normalerweise der Swapbereich befindet. 
IDE-Fesplatten werden als <tt>wd0</tt>, <tt>wd1</tt> etc. angezeigt,
SCSI-Festplatten und RAIDs als <tt>sd0</tt>, <tt>sd1</tt> und so weiter.
Alle Festplatten, die OpenBSD finden kann, sind hier aufgelistet -
wenn du welche hast, die hier nicht auftauchen, dann sind sie vermutlich
falsch konfiguriert oder werden gar nicht unterstützt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want to use *all* of wd0 for OpenBSD? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Wenn du diese Frage mit »yes« beantwortest, wird die gesamte Festplatte
für OpenBSD benutzt. Das resultiert in einem standardmäßigen
Masterbootrecord und einer Partitionstabelle, die beide auf die
Festplatte geschrieben werden - eine Partition, die die ganze Festplatte
einnimmt, den OpenBSD-Partitionstyp hat und als bootfähig gekennzeichnet
ist. Das ist für die meisten Produktionssysteme unter OpenBSD die
brauchbarste Lösung; auf manchen Systemen sollte man das allerdings
nicht so machen. Viele Compaq-Systeme, viele Laptops, einige Dell- und
ein paar andere Systeme benutzen eine Verwaltungspartition, die
unbedingt intakt bleiben muss. Wenn dein System einige Partitionen hat,
die du nicht löschen willst, solltest du auf keinen Fall mit »yes«
antworten. Falls du jedoch eine brandneue Platte hast, die noch
nie zuvor verwendet wurde, solltest du eventuell besser mit »yes«
antworten (oder verwende die »update«-Option von fdisk), so dass du
einen gültigen Masterbootrecord und eine gültige -signatur erhälst.

<p>
Für dieses Beispiel nehmen wir an, dass die Festplatte zwischen OpenBSD
und einer bereits existierenden Installation von Windows 2000 aufgeteilt
werden soll. Wir beantworten also die Frage hier mit »no«, was uns in
das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Programm
bringt. Mehr Informationen über fdisk findest du
<a href="faq14.html#fdisk">hier</a>.

<p>
<b>Wichtiger Hinweis:</b>
Benutzer mit einer großen Festplatte (größer als das, was normal war,
als dein Rechner hergestellt wurde) sollten unbedingt
<a href="faq14.html#LargeDrive">diese Sektion</a> lesen, bevor sie
weitermachen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  You will now create a single MBR partition to contain your OpenBSD data. This
  partition must have an id of 'A6'; must *NOT* overlap other partitions; and
  must be marked as the only active partition.

  The 'manual' command describes all the fdisk commands in detail.

  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 0B    0   1  1 -  202 239 63 [          63:     3069297 ] Win95 FAT-32
   1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  Enter 'help' for information
  fdisk: 1> <b>help</b>
          help            Command help list
          manual          Show entire OpenBSD man page for fdisk
          reinit          Re-initialize loaded MBR (to defaults)
          setpid          Set the identifier of a given table entry
          disk            Edit current drive stats
          edit            Edit given table entry
          flag            Flag given table entry as bootable
          update          Update machine code in loaded MBR
          select          Select extended partition table entry MBR
          swap            Swap two partition entries
          print           Print loaded MBR partition table
          write           Write loaded MBR to disk
          exit            Exit edit of current MBR, without saving changes
          quit            Quit edit of current MBR, saving current changes
          abort           Abort program without saving current changes
  fdisk: 1> 
</pre></td></tr></table>

<p>
Ein paar Befehle sollten wir uns näher ansehen:
<ul>
<li><b><tt>r</tt></b> oder <b><tt>reinit</tt>:</b> löscht eine
vorhandene Partitionstabelle und erzeugt eine große OpenBSD-Partition.
Diese wird als aktiv markiert und installiert den OpenBSD-MBR-Code.
Das ist das Gleiche, als ob man mit »yes« auf die Frage »<tt>use *all*
of ...</tt>« antwortet.
<li><b><tt>p</tt></b> oder <b><tt>print:</tt></b> zeigt die aktuelle
Partitionstabelle in Sektoren an, wohingegen »<tt>p m</tt>« die
Tabelle in Megabytes anzeigt und »<tt>p g</tt>« in Gigabytes.
<li><b><tt>e</tt></b> oder <b><tt>edit:</tt></b> editieren oder
Ändern eines Tabelleneintrags.
<li><b><tt>f</tt></b> oder <b><tt>flag:</tt></b> markiert eine Partition
als die aktive Partition. Diejenige also, von der gebootet wird.
<li><b><tt>u</tt></b> oder <b><tt>update:</tt></b> aktualisiert den MBR
mit dem OpenBSD-Bootcode. Ähnelt <tt>reinit</tt>, nur dass es die
bestehende Partitionstabelle nicht verändert.
<li><b><tt>exit</tt></b> und <b><tt>quit:</tt></b> sei hiermit
vorsichtig, da einige Anwender nicht daran gewöhnt sind, dass
exit und quit verschiedene Bedeutungen haben.
</ul>

Es ist nochmals wichtig darauf hinzuweisen, dass ein Fehler hier
durchaus in Datenverlust resultieren kann. Wenn du das
hier auf einer Platte mit wertvollen Daten machst, solltest du
vielleicht vorher auf einer Testplatte proben - zumal du
dann noch eine gute Datensicherung hast.

<p>
Unsere Festplatte hier hat eine 1,5-G-Partition für Windows 2000
(mit dem FAT-Dateisystem). Die Info oben zeigt, dass die
Windows-Partition bis zum Zylinder 202 reicht. Also werden wir den Rest
(sprich ab Zylinder 203) für OpenBSD reservieren. Du kannst auch den
Startsektor von OpenBSD berechnen (3069360), indem du den Startsektor
(63) und die Größe (3069297) zu der bereits vorhandenen Partition (hier
Windows 2000 mit FAT) addierst.

<p>
Du kannst das Festplattenlayout entweder in Form von
Zylindern/Köpfen/Sektoren editieren oder in Form reiner Sektoren
editieren. Was einfacher ist, hängt davon ab, was du tun willst. In
diesem Fall ist es wahrscheinlich einfacher, das CHS-Format zu benutzen.
Wenn du die erste Partition auf der Festplatte erstellst, ist das
Verwenden von reinen Sektoren wahrscheinlich einfacher.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk: 1> <b>e 1</b>
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>a6</b>
  Do you wish to edit in CHS mode? [n] <b>y</b>
  BIOS Starting cylinder [0 - 2585]: [0] <b>203</b>
  BIOS Starting head [0 - 239]: [0] <b><i>Enter</i></b>
  BIOS Starting sector [1 - 63]: [0] <b>1</b>
  BIOS Ending cylinder [0 - 2585]: [0] <b>2585</b>
  BIOS Ending head [0 - 239]: [0] <b>239</b>
  BIOS Ending sector [1 - 63]: [0] <b>63</b>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 0B    0   1  1 -  202 239 63 [          63:     3069297 ] Win95 FAT-32
   1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  fdisk:*1> <b>p m</b>
  Disk: wd0       geometry: 2586/240/63 [19092 Megabytes]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 0B    0   1  1 -  202 239 63 [          63:        1499M] Win95 FAT-32
   1: A6  203   0  1 - 2585 239 63 [     3069360:       17593M] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0M] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0M] unused
  fdisk:*1> 
</pre></td></tr></table>

<a name="trackoffset"></a>
<p>
Bei Plattformen, die fdisk verwenden, ist es wichtig, dass die erste
Partition die erste Spur der Platte auslässt; <i>in diesem Fall</i> also
mit Sektor <tt>63</tt> beginnt. Dies variiert von Maschine zu Maschine
und Plattensystem zu Plattensystem.
Wenn eine OpenBSD-Partition so erstellt wurde, dass sie mit einen Offset
von <tt>0</tt> beginnt, wird diese Partitionstabelle am Ende von dem
OpenBSD-<a href="faq14.html#Boot386">Partitionbootrecord</a>
überschrieben. Das System könnte zwar weiterhin bootfähig sein, wird
aber sehr schwer verwaltbar sein. Diese Konfiguration
<i>wird weder empfohlen noch ist sie unterstützt</i>.

<p>
Wie du sehen kannst wurde der Prompt um einen Asterisk (<tt>*</tt>)
erweitert, um anzuzeigen, dass du noch nicht gespeicherte Änderungen
gemacht hast. Wie wir an der Ausgabe von <tt>p&nbsp;m</tt> sehen können,
haben wir unsere Windows-Partition nicht geändert: wir haben den Rest
der Platte erfolgreich an OpenBSD vergeben. Wir sind somit fast fertig.

<p>
Was wir noch nicht gemacht haben, ist die Partition als aktiv zu
markieren, so dass nach dem nächsten Neustart OpenBSD geladen wird:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>f 1</b>
  Partition 1 marked active.
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   0: 0B    0   1  1 -  202 239 63 [          63:     3069297 ] Win95 FAT-32
  *1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
Und nun sind wir so weit, dass wir unsere Änderungen speichern können:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>w</b>
  Writing MBR at offset 0.
  wd0: no disk label
  fdisk: 1> <b>q</b>
</pre></td></tr></table> 

<p>

<a name="disklabel"></a>
<h3>Ein Disklabel erzeugen</h3>
Im nächsten Schritt benutzen wir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>,
um die OpenBSD-Partition aufzuteilen. Mehr Details über Disklabel
finden sich in der
<a href="faq14.html#disklabel">FAQ 14, Disklabel</a>.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Here is the partition information you chose:
  
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   0: 06    0   1  1 -  202 239 63 [          63:     3069297 ] DOS > 32MB
  *1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused

  You will now create an OpenBSD disklabel inside the OpenBSD MBR
  partition. The disklabel defines how OpenBSD splits up the MBR partition
  into OpenBSD partitions in which filesystems and swap space are created.

  The offsets used in the disklabel are ABSOLUTE, i.e. relative to the
  start of the disk, NOT the start of the OpenBSD MBR partition.

  disklabel: no disk label
  WARNING: Disk wd0 has no label. You will be creating a new one.
  
  # using MBR partition 1: type A6 off 3069360 (0x2ed5b0) size 36030960 (0x225c9f0)

  Treating sectors 3069360-39100320 as the OpenBSD portion of the disk.
  You can use the 'b' command to change this.

  Initial label editor (enter '?' for help at any prompt)
  > <b>?</b>
  Available commands:
          ? [cmnd]  - this message or command specific help.
          a [part]  - add new partition.
          b         - set OpenBSD disk boundaries.
          c [part]  - change partition size.
          D         - set label to default.
          d [part]  - delete partition.
          e         - edit drive parameters.
          g [b|d|u] - use [b]ios, [d]isk or [u]ser geometry.
          M         - show entire OpenBSD man page for disklabel.
          m [part]  - modify existing partition.
          n [part]  - set the mount point for a partition.
          p [unit]  - print label.
          q         - quit and save changes.
          r         - recalculate free space.
          s [path]  - save label to file.
          u         - undo last change.
          w         - write label to disk.
          X         - toggle expert mode.
          x         - exit without saving changes.
          z         - zero out partition table.
          ? [cmnd]  - this message or command specific help.
  Numeric parameters may use suffixes to indicate units:
          'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm' for megabytes,
          'g' for gigabytes or no suffix for sectors (usually 512 bytes).
          '%' for percent of total disk size, '&' for percent of free space.
          Non-sector units will be rounded to the nearest cylinder.
  Entering '?' at most prompts will give you (simple) context sensitive help.
  > 
</pre></td></tr></table>

<p>
Wieder sollten wir uns einige Kommandos näher ansehen:
<ul>
<li><b><tt>p</tt></b> - Zeigt das aktuelle Disklabel. Du kannst
<tt>k, m</tt> oder <tt>g</tt> für Kilobytes, Megabytes oder Gigabytes
benutzen.

<li><b><tt>D</tt></b> - Löscht jegliches exisitierende Disklabel und
erzeugt ein neues Disklabel, das nur die aktuelle OpenBSD-Partition
beinhaltet. Das kann nützlich sein, wenn die Festplatte vorher ein
Disklabel hatte und die OpenBSD-Partition mit einer anderen
Größe erneut erzeugt wurde - das alte Disklabel wird vielleicht
nicht gelöscht und könnte Verwirrung stiften.

<li><b><tt>m</tt></b> - Modifiziert einen existierenden Eintrag in
einem Disklabel. Überschätze nicht, was das hier bedeutet. Obwohl es
die Größe einer Disklabelpartition ändern kann, wird das Dateisystem
auf der Festplatte NICHT geändert. Diese Option zu benutzen und zu
erwarten, man könne damit bereits existierende Partitionen in der Größe
verändern, ist ein guter Weg, große Datenmengen zu verlieren.

</ul>

<p>
Es ist wichtig, deine Festplatte gut aufzuteilen. Die Antwort auf die
Frage »Wie soll ich mein System partitionieren?« ist »Genauso,
wie du es benötigst«. Das ist nunmal von Fall zu Fall verschieden.
Es gibt keine universelle Antwort. Wenn du nicht sicher bist, wie du
dein System partitionieren sollst, sieh dir
<a href="#Partitioning">diesen Abschnitt</a> an.

<p>
In diesem System haben wir für OpenBSD über 17 G verfügbar. Das ist eine
Menge Platz und wir werden wahrscheinlich nie den ganzen Platz brauchen.
Wir werden also mit der Platzverteilung etwas großzügig sein. Es ist
besser, ein paar hundert Megabytes zu viel und unbenutzt zu haben als
auch nur ein Kilobyte zu wenig.

<p>
Auf der Rootdisk <b>müssen</b> mindestens die Partitionen a und
b erzeugt werden. Die Installation wird ohne diese beiden Partitionen
abgebrochen. Für das Rootdateisystem (/) wird a und für den Swapbereich
b benutzt.

<p>
Nach einer kleinen Denkpause haben wir uns entschieden, die Menge
an Partitionen zu erzeugen, die wir für die empfohlenen
separaten Dateisysteme brauchen (<tt>/, /tmp, /var, /usr, /home</tt>,
zusätzlich zu einer Swappartition):
<ul>
<li><i><b>wd0a: /</b></i> (root) - 150 M.  Sollte mehr als genug sein.
<li><i><b>wd0b: </b></i>(swap) - 300 M.
<li><i><b>wd0d: /tmp</b></i> - 120 M.  <tt>/tmp</tt> wird für das
  Erzeugen von Software gebraucht, 120 M wird für die meisten
  Anwendungen genug sein.
<li><i><b>wd0e: /var</b></i> - 80 M.  Wenn das ein Web- oder Mail-Server
  wäre, müsste diese Partition viel größer sein - aber das machen wir
  hier ja nicht.
<li><i><b>wd0g: /usr</b></i> - 6 G.  Wir brauchen den Platz hier für
  viele Benutzeranwendungen und außerdem wollen wir das System
  aktualisieren und neu erzeugen können, wenn es notwendig wird. Der
  <a href="faq15.html#Ports">Ports-Tree</a> wird sich hier auch
  befinden und vor dem Erzeugen von Ports bereits 160 Megabyte Platz
  brauchen. Wenn du viele Applikationen aus den 
  <a href="faq15.html#Ports">Ports</a> bauen willst, statt dich der
  fertig kompilierten <a href="faq15.html#PkgMgmt">Packages</a> zu
  bedienen, benötigst du hier sehr viel mehr Platz.
<li><i><b>wd0h: /home</b></i> - 4 G.  Das lässt jede Menge Platz
  für Benutzerdateien.
</ul>

Wenn du das alles zusammenzählst, wirst du bemerken, dass über
6 G Plattenplatz ungenutzt ist! Ungenutzter Platz tut uns nicht weh
und gibt uns die Flexibilität, die Dinge in Zukunft zu vergrößern. Du
brauchst mehr <i>/tmp</i>? Erstelle eine neue Partition im ungenutzten
Bereich, formatiere diese mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8"
>newfs(8)</a> und ändere
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"
><i>/etc/fstab</i></a> so ab, dass die neue Partition unter <i>/tmp</i>
gemountet wird - Problem gelöst.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>p m</b>
  device: /dev/rwd0c
  type: ESDI
  disk: ESDI/IDE disk
  label: ST320011A
  bytes/sector: 512
  sectors/track: 63
  tracks/cylinder: 16
  sectors/cylinder: 1008
  cylinders: 16383
  total sectors: 39102336
  free sectors: 36030960
  rpm: 3600
  
  16 partitions:
  #             size        offset  fstype [fsize bsize  cpg]
    a:      17593.2M       1498.7M  unused      0     0      
    c:      19092.9M          0.0M  unused      0     0      
    i:       1498.7M          0.0M  MSDOS                   
  > <b>d a</b>
  > <b>a a</b>
  offset: [3069360] <b><i>Enter</i></b>
  size: [36030960] <b>150m</b>
  Rounding to nearest cylinder: 307440
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/</b>
  > <b>a b</b>
  offset: [3376800] <b><i>Enter</i></b>
  size: [35723520] <b>300m</b>
  Rounding to nearest cylinder: 614880
  FS type: [swap] <b><i>Enter</i></b>
  > <b>a d</b>
  offset: [3991680] <b><i>Enter</i></b>
  size: [35108640] <b>120m</b>
  Rounding to nearest cylinder: 245952
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/tmp</b>
  > <b>a e</b>
  offset: [4237632] <b><i>Enter</i></b>
  size: [34862688] <b>80m</b>
  Rounding to nearest cylinder: 164304
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var</b>
  > <b>a g</b>
  offset: [4401936] <b><i>Enter</i></b>
  size: [34698384] <b>6g</b>
  Rounding to nearest cylinder: 12582864
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr</b>
  > <b>a h</b>
  offset: [16984800] <b><i>Enter</i></b>
  size: [22115520] <b>4g</b>
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/home</b>
  > <b>p m</b>
  device: /dev/rwd0c
  type: ESDI
  disk: ESDI/IDE disk
  label: ST320011A
  bytes/sector: 512
  sectors/track: 63
  tracks/cylinder: 16
  sectors/cylinder: 1008
  cylinders: 16383
  total sectors: 39102336
  free sectors: 22115520
  rpm: 3600
  
  16 partitions:
  #             size        offset  fstype [fsize bsize  cpg]
    a:        150.1M       1498.7M  4.2BSD   2048 16384   16 # /
    b:        300.2M       1648.8M    swap                   
    c:      19092.9M          0.0M  unused      0     0      
    d:        120.1M       1949.1M  4.2BSD   2048 16384   16 # /tmp
    e:         80.2M       2069.2M  4.2BSD   2048 16384   16 # /var
    g:       6144.0M       2149.4M  4.2BSD   2048 16384   16 # /usr
    h:       4096.0M       8293.4M  4.2BSD   2048 16384   16 # /home
    i:       1498.7M          0.0M   MSDOS                   
  > <b>q</b>
  Write new label?: [y] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Du wirst bemerken, dass wir die <i>c</i>-Partition scheinbar komplett
ignoriert haben. Diese Partition ist deine gesamte Festplatte - versuche
sie nicht zu verändern. Du wirst außerdem bemerkt haben, dass wir
die <i>i</i>-Partition nicht angelegt haben, denn das ist die bereits
existierende Windows-2000-Partition. Partitionen werden hier mit
Ausnahme von <i>a</i> (root), <i>b</i> (swap) und <i>c</i> (gesamte
Festplatte) keinem vorbestimmten Buchstaben zugewiesen: der Rest der
Partitionen (über den Buchstaben <i>p</i>) kann verwendet werden, wie
man will.

<p>
Wenn du dir Ausgaben von disklabel genau ansiehst, wirst du vermutlich
feststellen, dass die Angabe der RPM falsch ist. Das ist historisch
bedingt: die Plattengeschwindigkeit wird in keiner Weise vom System
benutzt. Mach dir also keine Sorgen darüber.

<h3>Deine Mountpunkte konfigurieren und deine Dateisysteme
formatieren</h3>

Jetzt kommt die finale Konfiguration deiner Mountpunkte. Wenn du deine
Mountpunkte mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
konfiguriert hast, reicht es in diesem Schritt aus, deine Auswahl zu
bestätigen. Falls du das noch nicht getan hast, kannst du sie hier nun
angeben.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Mount point for wd0d (size=122976k)? (or 'none' or 'done') [/tmp] <b><i>Enter</i></b>
  Mount point for wd0e (size=82152k)? (or 'none' or 'done') [/var] <b><i>Enter</i></b>
  Mount point for wd0g (size=6291432k)? (or 'none' or 'done') [/usr] <b><i>Enter</i></b>
  Mount point for wd0h (size=4194288k)? (or 'none' or 'done') [/home] <b><i>Enter</i></b>
  Mount point for wd0d (size=122976k)? (or 'none' or 'done') [/tmp] <b>done</b>
  No more disks to initialize.
 
  OpenBSD filesystems:
  wd0a /
  wd0d /tmp
  wd0e /var
  wd0g /usr
  wd0h /home

  The next step *DESTROYS* all existing data on these partitions!
  Are you really sure that you're ready to proceed? [no] <b>y</b>
  /dev/rwd0a:     307440 sectors in 305 cylinders of 16 tracks, 63 sectors
          150.1MB in 1 cyl groups (306 c/g, 150.61MB/g, 19328 i/g)
  /dev/rwd0d:     245952 sectors in 244 cylinders of 16 tracks, 63 sectors
          120.1MB in 1 cyl groups (244 c/g, 120.09MB/g, 15360 i/g)
  /dev/rwd0e:     164304 sectors in 163 cylinders of 16 tracks, 63 sectors
          80.2MB in 1 cyl groups (164 c/g, 80.72MB/g, 10368 i/g)
  /dev/rwd0g:     12582864 sectors in 12483 cylinders of 16 tracks, 63 sectors
          6144.0MB in 39 cyl groups (328 c/g, 161.44MB/g, 20608 i/g)
  /dev/rwd0h:     8388576 sectors in 8322 cylinders of 16 tracks, 63 sectors
          4096.0MB in 26 cyl groups (328 c/g, 161.44MB/g, 20608 i/g)
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local, ctime=Sat Oct  7 19:49:44 2
  006)
  /dev/wd0h on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid, ctime=S
  at Oct  7 19:49:44 2 006)
  /dev/wd0d on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid, ctime=Sa
  t Oct  7 19:49:44 2006)
  /dev/wd0g on /mnt/usr type ffs (rw, asynchronous, local, nodev, ctime=Sat Oct  7
   19:49:44 2006)
  /dev/wd0e on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid, ctime=Sa
  t Oct  7 19:49:44 2006)
</pre></td></tr></table>

<p>
Du fragst dich wahrscheinlich, wieso dich das Installationsprogramm
schon wieder nach den Mountpunkten fragt. Das erlaubt dir, Fehler
oder Probleme mit der bisherigen Auswahl einfach auszuräumen. Der
Installationsprozess wird zum Beispiel doppelte Mountpunkte einfach
löschen. Im Programm disklabel kannst du solche Doppeleingaben
machen - daher muss das überprüft werden. Eine solche
doppelte Nennung wird zu Partitionen ohne Mountpunkt führen, denen
du dann neue Mountpunkte zuweisen musst, wenn du den Platz darin
benutzen willst.

<p>
Wie du sehen kannst, lautet die vorgegebene Antwort auf die Frage
"Are you really sure that you are ready to proceed?" »no«: du musst also
ausdrücklich »yes« antworten, damit das Programm weitermacht und
deine Partitionen formatiert. Wenn du das nicht tust, landest du wieder
in der Shell und könntest die Installation erneut starten, indem
du »install« eingibst oder einfach erneut mit deiner Bootdisk
hochfährst.

<p>
An diesem Punkt werden nun alle deine Dateisysteme formatiert. Wie lange
das dauert hängt von der Größe der Partitionen und der Geschwindigkeit
deiner Festplatte ab.

<a name="Hostname"></a>
<h3>4.5.3 - Den Hostnamen des Systems setzen</h3>
<p>
Du musst dem System nun seinen Hostnamen geben. Dieser Wert - neben dem
DNS-Domänennamen (<a href="#Network">weiter unten</a> angegeben) - wird
in der Datei <tt>/etc/myname</tt> gespeichert, die beim normalen Booten
des Systems ausgelesen wird. Wenn du den FQDN des Systems nicht setzt,
wird der vorgeschlagene Wert my.domain benutzt.

<p>
Es ist wichtig, diesen Namen jetzt zu setzen, da er beim ersten Booten
des Systems nach der Installation dabei benutzt wird, die
kryptographischen Schlüssel zu erzeugen. Dieses Erzeugen geschieht
unabhängig davon, ob das Netzwerk konfiguriert ist oder nicht.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Enter system hostname (short form, e.g. 'foo'): <b>puffy</b>
</pre></td></tr></table>

<a name="Network"></a>
<h3>4.5.4 - Das Netzwerk konfigurieren</h3>

<p>
Jetzt ist es an der Zeit, dein Netzwerk zu konfigurieren. Das muss
unbedingt geschehen, wenn du eine FTP- oder NFS-basierte Installation
durchführen willst, da die Daten dafür notwendig sind. Hier
ein Beispieldurchlauf für die Netzwerkkonfiguration.
In diesem Beispiel hängt an einem Interface (fxp0) ein Kabelmodem;
dieses Interface wird über DHCP konfiguriert. Das andere Interface
führt zu unserem internen Netzwerk und wird statisch konfiguriert.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Configure the network? [yes] <b><i>Enter</i></b>
  Available interfaces are: fxp0 xl0.
  Which one do you wish to initialize? (or 'done') [fxp0] <b>xl0</b>
  Symbolic (host) name for fxp0? [puffy] <b><i>Enter</i></b>
  The default media for fxp0 is
          media: Ethernet autoselect (100baseTX full-duplex)
  Do you want to change the default media? [no] <b><i>Enter</i></b>
  IPv4 address for fxp0 (or 'dhcp')? <b>199.185.137.55</b>
  Netmask? [255.255.255.0] <b><i>Enter</i></b>
  IPv6 address for fxp0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
  Available interfaces are: fxp0.
  Which one do you wish to initialize? (or 'done') [fxp0] <b><i>Enter</i></b>
  Symbolic (host) name for fxp0? [puffy] <b><i>Enter</i></b>
  The media options for fxp0 are currently
          media: Ethernet autoselect (10baseT)
  Do you want to change the media options? [no] <b><i>Enter</i></b>
  IPv4 address for fxp0? (or 'none' or 'dhcp') <b>dhcp</b>
  Issuing hostname-associated DHCP request for fxp0.
  DHCPDISCOVER on fxp0 to 255.255.255.255 port 67 interval 1
  DHCPOFFER from 73.34.136.1
  DHCPREQUEST on fxp0 to 255.255.255.255 port 67
  DHCPACK from 73.34.136.1
  bound to 69.241.244.76 -- renewal in 1800 seconds.
  IPv6 address for fxp0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
  No more interfaces to initialize.
  DNS domain name? (e.g. 'bar.com') [my.domain] <b>example.com</b>
  DNS nameserver? (IP address or 'none') [68.87.77.130 68.87.72.130] <b><i>Enter</i></b>
  Use the nameserver now? [yes] <b><i>Enter</i></b>
  Default route? (IP address, 'dhcp' or 'none') [dhcp] <b><i>Enter</i></b>
  Edit hosts with ed? [no] <b><i>Enter</i></b>
  Do you want to do any manual network configuration? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
<b>HINWEIS: </b>Nur <b>ein</b> Interface kann während der
Installation einfach mit DHCP konfiguriert werden. Es wird Fehler geben,
wenn du das mehrmals versuchst. Die anderen Interfaces musst du dann
nach der Installation per Hand konfigurieren.

<p>
Nun setzen wir das Passwort für root:
<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
Password for root account? (will not echo) <b><i>pAssWOrd</i></b>
Password for root account? (again) <b><i>pAssWOrd</i></b>
</pre></td></tr></table>
<p>
Verwende ein sicheres Passwort für das Root-Benutzerkonto. Du wirst
weitere Benutzerkonten anlegen, wenn das System gebootet wurde. Aus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=passwd&amp;sektion=1">passwd(1)</a>:
<pre>
    The new password should be at least six characters long and not purely
    alphabetic.  Its total length must be less than _PASSWORD_LEN (currently
    128 characters).  A mixture of both lower and uppercase letters, numbers,
    and meta-characters is encouraged.
</pre>

<a name="InstMedia"></a>
<h3>4.5.5 - Das Installationsmedium auswählen</h3>

<p>
Nachdem dein Netzwerk eingerichtet ist, hast du die Chance, deine
Einstellungen per Hand zu justieren.

<p>
Danach bekommst du die Chance, dein Installationsmedium auszuwählen.
Die Optionen sind unten aufgelistet.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Let's install the sets!
  Location of sets? (cd disk ftp http or 'done') [cd] <b><i>Enter</i></b>
  Available CD-ROMs are: cd0.
</pre></td></tr></table>

<p>
In diesem Beispiel installierst du von CD-ROM. Dazu wird eine Liste der
Geräten erzeugt, die auf deiner Maschine als CD-ROM identifiziert
wurden. Die meisten Leute haben aber nur eins. Wähle einfach
das Gerät aus, von dem aus du OpenBSD installieren willst.

<p>
<b>HINWEIS: </b>Nicht alle Plattformen bieten alle
Installationsmöglichkeiten an. In diesem Fall unterstützt die
OpenBSD/i386-Plattform keine NFS-Installation, so dass diese nicht in
der Liste mit aufgeführt wird.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available CD-ROMs are: cd0.
  Which one contains the install media? (or 'done') [cd0] <b><i>Enter</i></b>
  Pathname to the sets?  (or 'done') [4.0/i386] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Hier wirst du gefragt, in welchem Verzeichnis sich die Dateisets
befinden - auf der offiziellen CD-ROM ist das <tt>4.0/i386/</tt>.

<a name="Filesets"></a>
<h3>4.5.6 - Dateisets auswählen</h3>

<p>
Nun ist es an der Zeit auszuwählen, welche Dateisets du haben willst.
Eine Beschreibung dieser Pakete findest du im <a href="#FilesNeeded"
>nächsten Abschnitt</a>. Die Dateien, die das Installationsprogramm
findet, werden auf dem Bildschirm angezeigt.
Deine Aufgabe ist es anzugeben, welche Dateien du haben willst.
Standardmäßig sind bis auf die X-Dateisets alle markiert - manche
fortgeschrittene Anwender wollen aber wirklich nur das absolute Minimum
haben, mit dem OpenBSD noch funktioniert: <tt>base40.tgz</tt>,
<tt>etc40.tgz</tt> und <tt>bsd</tt>. Die meisten Anwender wollen alle
Dateisets haben. Das Beispiel unten zeigt eine komplette Installation
mit allen Paketen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Select sets by entering a set name, a file name pattern or 'all'. De-select
  sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
  sets are labeled '[x]'.

          [X] bsd
          [X] bsd.rd
          [ ] bsd.mp
          [X] base40.tgz
          [X] etc40.tgz
          [X] misc40.tgz
          [X] comp40.tgz
          [X] man40.tgz
          [X] game40.tgz
          [ ] xbase40.tgz
          [ ] xetc40.tgz
          [ ] xshare40.tgz
          [ ] xfont40.tgz
          [ ] xserv40.tgz
  Set name? (or 'done') [bsd.mp] <b>all</b>

          [X] bsd
          [X] bsd.rd
          [X] bsd.mp
          [X] base40.tgz
          [X] etc40.tgz
          [X] misc40.tgz
          [X] comp40.tgz
          [X] man40.tgz
          [X] game40.tgz
          [X] xbase40.tgz
          [X] xetc40.tgz
          [X] xshare40.tgz
          [X] xfont40.tgz
          [X] xserv40.tgz
</pre></td></tr></table>

<p>
Du kannst hier alle möglichen Sachen machen: <tt>-x*</tt> zum
Beispiel würde alle X-Komponenten entfernen, falls du es dir nochmal
anders überlegst. In diesem Fall wollen wir aber alle Sets. Wenn das
System auch mit viel weniger Sets läuft, ist der empfohlene Weg,
entweder die standardmäßigen Vorgaben oder alles zu installieren.
Weitere Details zum Auswählen der Sets befinden sich
<a href="#FilesNeeded">hier</a>.

<p>
Nachdem du deine gewünschten Dateisets ausgewählt hast, wirst du noch
einmal gefragt, ob du die gewählten Dateisets wirklich entpacken willst
- dann werden sie installiert. Es wird ein Fortschrittsbalken
angezeigt, der dir zeigt, wie lange das ganze noch etwa dauert. Die
Dauer hängt natürlich stark von der Geschwindigkeit deines Systems ab,
den Dateisets, die du installieren willst, und der Geschwindigkeit des
Installationsmediums. Somit liegt die Dauer je nachdem irgendwo zwischen
ein paar Minuten und ein paar Stunden.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Set Name? (or 'done') [done] <b><i>Enter</i></b>
  Ready to install sets? [yes] <b><i>Enter</i></b>

  Getting bsd ...
  100% |**************************************************|  5904 KB    00:09
  Getting bsd.rd ...
  100% |**************************************************|  4889 KB    00:03
  Getting bsd.mp ...
  100% |**************************************************|  5952 KB    00:03
  Getting base40.tgz ...
  100% |**************************************************| 40675 KB    00:33
  Getting etc40.tgz ...
  100% |**************************************************|  1133 KB    00:01
  Getting misc40.tgz ...
  100% |**************************************************|  2233 KB    00:02
  Getting comp40.tgz ...
  100% |**************************************************| 77933 KB    01:03
  Getting man40.tgz ...
  100% |**************************************************|  7427 KB    00:07
  Getting game40.tgz ...
  100% |**************************************************|  2548 KB    00:02
  Getting xbase40.tgz ...
  100% |**************************************************| 10341 KB    00:08
  Getting xetc40.tgz ...
  100% |**************************************************| 90762       00:00
  Getting xshare40.tgz ...
  100% |**************************************************|  2027 KB    00:03
  Getting xfont40.tgz ...
  100% |**************************************************| 32455 KB    00:25
  Getting xserv40.tgz ...
  100% |**************************************************| 19418 KB    00:16
  Location of sets? (cd disk ftp http or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
An dieser Stelle hast du die Möglichkeit, weitere Dateien von anderen
Quellen zu installieren (einschließlich <a href="#site">individuellen
Dateisets</a>) wenn du das möchtest oder gib <tt>done</tt> ein, wenn
du alle Dateisets installiert hast, die du benötigst.

<a name="Finish"></a>
<h3>4.5.7 - Zum Ende kommen</h3>

Als nächstest werden dir einige Fragen bezüglich der Einstellungen
deines installierten Systems gestellt. Die erste ist, ob
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
beim Hochfahren gestartet werden soll. Üblicherweise möchtest du, dass
sshd(8) läuft - gelegentlich vielleicht auch nicht. Wenn deine
Verwendung von OpenBSD keinen Gebrauch für sshd(8) hat, liegt ein
kleiner theoretischer Sicherheitsvorteil vor, wenn er nicht läuft.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start sshd(8) by default? [yes] <b>y</b>
</pre></td></tr></table>

<p>
(Falls du deine Meinung später änderst, passe deine
<a href="faq10.html"><tt>/etc/rc.conf.local</tt></a> oder
<tt>/etc/rc.conf</tt> an.)

<p>
Dir wird nun die Möglichkeit gegeben,
<a href="faq6.html#OpenNTPD">OpenNTPD</a> beim Booten zu starten.
OpenNTPD ist ein Weg, mit geringen Auswirkungen die Uhr deines
Computers genau synchron zu halten, und hat eine standardmäßige
Konfiguration, die für die Verwendung von vielen Benutzern ausreicht.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start ntpd(8) by default? [no] <b>y</b>
</pre></td></tr></table>

<p>
(Falls du deine Meinung später änderst, passe deine
<a href="faq10.html"><tt>/etc/rc.conf.local</tt></a> oder
<tt>/etc/rc.conf</tt> an.)

<p>
Auf einigen Systemen wirst du nun gefragt werden, ob du auf dem
System X laufen lassen willst. Wenn du mit »Y« antwortest, wird die
Datei <tt>/etc/sysctl.conf</tt> so modifiziert, dass abhängig von deiner
Plattform <tt>machdep.allowaperture=1</tt> oder
<tt>machdep.allowaperture=2</tt> darinsteht. Einige Plattformen werden
diese Frage überhaupt nicht stellen. Wenn du nicht vorhast, X auf
diesem System zu verwenden oder du dir noch unsicher bist, solltest du
mit N antworten, da du die benötigte Änderung später immer noch ganz
einfach machen kannst, indem du <tt>/etc/sysctl.conf</tt> änderst.
Es liegt ein potentieller Sicherheitsvorteil vor, wenn der
Aperturetreiber
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xf86&amp;sektion=4">xf86(4)</a>
deaktiviert bleibt, da die Grafikengine moderner Grafikkarten
verwenden werden könnten, um den Speicher zu modifizieren, ohne dass
der Prozessor etwas dagegen unternehmen könnte.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you expect to run the X Window System? [no] <b>y</b>
</pre></td></tr></table>

<p>
Als nächstes wirst du gefragt, ob du eine
<a href="faq7.html#SerCons">serielle Konsole</a> an diesem Computer
anstatt von einer Standardtastatur und einem -monitor betreiben willst.
Wenn du »<tt>yes</tt>« auswählst und ein paar weitere einfache Fragen
beantwortest, werden
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8">/etc/boot.conf</a></tt>
und 
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5">/etc/ttys</a></tt>
automatisch für dich angepasst.
Die meisten Benutzer werden hier jedoch die Voreinstellung
<b><tt>no</tt></b> verwenden.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Change the default console to com0? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Deine letzte Aufgabe ist es, deine entsprechende Zeitzone einzustellen.
Abhängig davon, wo deine Maschine steht, kann es mehrere richtige
Antworten geben. Im folgenden Beispiel benutzen wir <tt>US/Eastern</tt>,
könnten aber auch <tt>EST5EDT</tt> oder <tt>US/Michigan</tt> benutzen
und zum selben Ergebnis kommen. Wenn man <tt>?</tt> drückt, bekommt
man eine Liste mit möglichen Auswahlen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Saving configuration files......done.
  Generating initial host.random file ......done.
  What timezone are you in? ('?' for list) [Canada/Mountain] <b>?</b>
  Africa/      Chile/       GB-Eire      Israel       NZ-CHAT      UCT
  America/     Cuba         GMT          Jamaica      Navajo       US/
  Antarctica/  EET          GMT+0        Japan        PRC          UTC
  Arctic/      EST          GMT-0        Kwajalein    PST8PDT      Universal
  Asia/        EST5EDT      GMT0         Libya        Pacific/     W-SU
  Atlantic/    Egypt        Greenwich    MET          Poland       WET
  Australia/   Eire         HST          MST          Portugal     Zulu
  Brazil/      Etc/         Hongkong     MST7MDT      ROC          posix/
  CET          Europe/      Iceland      Mexico/      ROK          posixrules
  CST6CDT      Factory      Indian/      Mideast/     Singapore    right/
  Canada/      GB           Iran         NZ           Turkey       zone.tab
  What timezone are you in? ('?' for list) [Canada/Mountain] <b>US</b>
  What sub-timezone of 'US' are you in? ('?' for list) <b>?</b>
  Alaska          Central         Hawaii          Mountain        Samoa
  Aleutian        East-Indiana    Indiana-Starke  Pacific
  Arizona         Eastern         Michigan        Pacific-New
  Select a sub-timezone of 'US' ('?' for list): <b>Eastern</b>
  Setting local timezone to 'US/Eastern'...done
</pre></td></tr></table>

<p>
Wenn du auf besonders genaue Zeitangaben aus bist, möchtest du
vielleicht <a href="faq8.html#NTPerror">das hier</a> lesen.

<p>
Die letzten Schritte für das System sind das Erzeugen des
<tt>/dev</tt>-Verzeichnisses (was auf manchen Maschinen ganz schön lange
dauert - insbesondere, wenn du nur wenig RAM besitzt) und das
Installieren des Bootblocks.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Making all device nodes...done.
  Installing boot block...
  boot: /mnt/boot
  proto: /usr/mdec/biosboot
  device: /dev/rwd0c
  /usr/mdec/biosboot: entry point 0
  proto bootblock size 512
  /mnt/boot is 3 blocks x 16384 bytes
  fs block shift 2; part offset 3069360; inode block 152, offset 4136
  using MBR partition 1: type 166 (0xa6) offset 3069360 (0x2ed5b0)
  done.

  CONGRATULATIONS! Your OpenBSD install has been successfully completed!
  To boot the new system, enter halt at the command prompt. Once the
  system has halted, reset the machine and boot from the disk.
  # <b>halt</b>
  syncing disks... done

  The operating system has halted.
  Please press any key to reboot.
</pre></td></tr></table>

<p>
OpenBSD ist jetzt auf deinem System installiert und bereit für den
ersten Boot, aber vorher ...

<p>

<h4>Bevor du neustartest</h4>
Nun ist dein System also installiert und fertig zum ersten Booten,
um danach noch konfiguriert zu werden. Zuvor wäre es allerdings
weise, die <a href="../../de/errata.html">Errataseite</a> zu
überprüfen, ob es nicht irgendwelche Bugs gibt, die dich sofort
betreffen könnten.

<p>
Ein Trick, um eine Konfiguration vor dem ersten Start durchführen
zu können, ist
<pre>
    # <b>/mnt/usr/sbin/chroot /mnt</b>
</pre>
beim Shellprompt einzugeben.
Dies setzt deine Mountpunkte so, wie sie nach einem normalen Neustart
deines frisch installierten Systems sein werden.
Du kannst grundlegende Systemkonfiguration durchführen, z.&nbsp;B.
Benutzer hinzufügen, Mountpunkte ändern etc.

<h4>Nach dem Neustart</h4>

<p>
Eines der ersten Dinge, die du nach der Installation lesen solltest, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=afterboot&amp;sektion=8">afterboot(8)</a>.

<p>
Die folgenden Links könnten ebenfalls recht nützlich sein:
<ul>
<li><a href="faq10.html#AddDelUser">Benutzer unter OpenBSD
  hinzufügen</a>
<li><a href="faq6.html#Setup">Erste Netzwerkkonfiguration</a>
<li><a href="faq2.html#ManPages">Manualseiten von nützlichen/häufigen
  Befehlen</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD-Manualseiten
  im Web</a>
<li><a href="faq15.html">Das OpenBSD-Packages- und -Ports-System, um
  Software zu installieren</a>
</ul>

<h4>Noch eine Sache ...</h4>
Die OpenBSD-Entwickler bitten dich darum,
<a href="#SendDmesg">eine Kopie deiner dmesg einzuschicken</a>. Das
hilft den Entwicklern und schlussendlich auch den Anwendern.

<p>
<a name= "FilesNeeded"></a>
<h2>4.6 - Welche Dateien werden zur Installation benötigt?</h2>
<!-- XXXrelease -->

<p>
Die komplette OpenBSD-Installation ist in eine Vielzahl einzelner
<i>Dateisets</i> aufgeteilt. Nicht jede Verwendung verlangt nach jedem
Dateiset.  Hier ist eine Übersicht:
<p>
<ul>
  <li><b><i>bsd</i></b>          - Dies ist der Kernel. <b>Zwingend
    notwendig</b>
  <li><b><i>bsd.mp</i></b> - Multi-Prozessor-Kernel (SMP) (nur auf
     einigen Plattformen)
  <li><b><i>bsd.rd</i></b> - <a href="#bsd.rd">RAM-Disk-Kernel</a>
  <li><b><i>base40.tgz</i></b>   - Enthät das Basissystem von OpenBSD.
    <b>Zwingend notwendig</b>
  <li><b><i>etc40.tgz</i></b>    - Enthält alle Dateien in /etc.
    <b>Zwingend notwendig</b>
  <li><b><i>comp40.tgz</i></b>    - Enthält den Kompiler und alle seine
    Anwendungen, Headers und Bibliotheken. <b>Empfohlen</b>
  <li><b><i>man40.tgz</i></b>    - Enthält alle Manualseiten.
    <b>Empfohlen</b>
  <li><b><i>misc40.tgz</i></b>   - Enthält alle misc-, info- und
    setup-Dokumentationen.
  <li><b><i>game40.tgz</i></b>   - Enthält die Spiele für OpenBSD.
  <li><b><i>xbase40.tgz</i></b>  - Enthält die Basisdateien für X11.
  <li><b><i>xetc40.tgz</i></b>   - Beinhaltet die /etc/X11- und
    /etc/fonts-Konfigurationsdateien.
  <li><b><i>xfont40.tgz</i></b>  - Enthält den X11-Fontserver und
    Schriftarten
  <li><b><i>xserv40.tgz</i></b>  - Enthält die X11-X-Server
  <li><b><i>xshare40.tgz</i></b> - Enthält Manualseiten, lokale
    Einstellungen, Includes etc. für X
</ul>

Das <b>etc40.tgz</b>- und das <b>xetc40.tgz</b>-Set werden nicht als
Teil eines Upgrades installiert, sondern nur als Teil einer kompletten
Installation, so dass jegliche Änderungen, die du vorgenommen hast,
nicht verloren gehen.
Du musst deine Verzeichnisse <tt>/etc</tt>, <tt>/dev</tt> und
<tt>/var</tt> manuell aktualisieren.

<p>
Selbst wenn du nicht vorhast, X auf deinem System zu benutzen, kann es
sein, dass <a href="faq15.html">Packages</a> von Drittanbietern die
Grafikbibliotheken aus <b>xbase40.tgz</b> voraussetzen. Solche
Anwendungen können normalerweise zufrieden gestellt werden, indem
<b>xbase40.tgz</b> installiert wird - die restlichen X-Komponenten
werden nicht benötigt.


<p>
<a name="Partitioning"></a>
<a name= "SpaceNeeded"></a>  <!-- XXXobsolete tag -->
<h2> 4.7 - Wie viel Platz brauche ich für eine
OpenBSD-Installation?</h2>
<!-- XXXrelease -->

<p>
Es ist offensichtlich, dass die Antwort auf diese Frage gewaltig von
deiner Verwendung des Systems abhängig ist.
Jedoch können diese Werte als ein <i>Start</i>-Punkt angesehen werden:

<blockquote><pre>
(root)             60 MB
/usr               420 MB (kein X) oder 550 MB (mit X)
/var               25 MB
/tmp               50 MB
swap               32 MB
</pre></blockquote>

Dies sind die minimal empfohlene Dateisystemgrößen für eine gesamte
Systeminstallation.
Die Werte beinhalten zusätzlichen Platz um dir zu ermöglichen, ein
typisches Heimsystem zu nutzen, das eine Internetverbindung hat - aber
nicht sehr viel mehr.

<p>
Behalte die folgenden Fakten jedoch im Hinterkopf:
<ul>
<li>Dies sind Minimalwerte.
Plattenspeicher ist zurzeit recht günstig. Der Versuch, das System auf
die kleinst mögliche Platte zu quetschen, ist normalerweise den Aufwand
nicht wert. Für bestimmte Einsatzgebiete können diese Werte kleiner
gemacht werden. Du musst aber experimentieren.
<li>Diese Angaben enthalten NICHT den Ports-Tree.
<li>Wenn du planst, eine Menge Software von Drittanbietern zu
installieren, wähle deine <tt>/usr</tt>-Partition groß!
Wie groß hängt natürlich von deiner Verwendung ab.
<li>Für ein System, das eine Menge E-Mails oder Webseiten handhabt (die
in <tt>/var/mail</tt> und <tt>/var/www</tt> gespeichert werden),
solltest du deine <tt>/var</tt>-Partition bedeutend vergrößern oder lege
sie auf separate Partitionen.
<li>Für ein Mehrbenutzersystem, das eine Menge Aufzeichnungen erzeugt,
solltest du deine <tt>/var</tt>-Partition noch größer wählen oder
eine separate Logpartition (<tt>/var/log</tt>) einrichten.
<li>Wenn du planst, <a href="faq5.html">den Kernel oder das ganze System
aus dem Quelltext neu zu erzeugen</a>, sollte deine
<tt>/usr</tt>-Partition deutlich größer ausfallen - 4 G ist keine
schlechte Idee.
<li>Das Kompilieren von einigen <a href="faq15.html#Ports">Ports</a> vom
Quelltext aus kann gewaltig viel Speicher auf deinen <tt>/usr</tt>-
und <tt>/tmp</tt>-Partitionen in Anspruch nehmen. Dies ist ein weiterer
Grund, warum wir empfehlen, stattdessen
<a href="faq15.html#PkgMgmt">vorkompilierte Packages</a> zu
nutzen.
<li>Die <tt>/tmp</tt>-Partition wird während des Kompilierens von Ports
und anderen Dingen benutzt. Die Größe hängt also davon ab, was du damit
machen willst. 50 MB mag für viele Leute viel sein, aber einige
große Applikationen brauchen 100 MB und mehr <tt>/tmp</tt>-Platz.

<li>Die b-Partition deines ersten Laufwerks wird automatisch deine
System-Swappartition - wir empfehlen ein Minimum von 32 MB, aber wenn du
genug Platz hast, mach wenigstens 64 MB daraus. Wenn du aber wirklich
viel Plattenplatz hast, scheu dich nicht, dein Swap mit 256 MB oder
sogar 512 MB einzurichten. Wenn du allerdings einen Flashspeicher
benutzt, solltest du vielleicht überhaupt gar keine Swappartition nutzen.
Viele Leute folgen einer alten Bauernregel, die besagt, dass deine
Swappartition doppelt so viel Speicher haben sollte wie dein RAM.
Diese Regel ist Unsinn.
Auf modernen Systemen wäre das SEHR VIEL Swap. Die meisten Leute
bevorzugen eher, dass ihre System niemals swappen. Setze ein, was für
deine Ansprüche am besten ist.
<li>Swap- und <tt>/var</tt>-Speicher werden genutzt, um
Coredumps des Systems im Fall eines
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crash&amp;sektion=8">crash(8)</a>
zu speichern.
Falls dies eine Überlegung von dir ist, sollte dein Swapbereich ein
wenig größer sein als der Speicherplatz des Hauptspeichers, den du
jemals in deinem System verwenden wirst.
Beim Neustart versucht
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8">savecore(8)</a>,
den Inhalt der Swappartition in eine Datei unter
<tt>/var/crash</tt> zu speichern. Also wieder einmal: wenn dies wichtig
für dich ist, sollte deine <tt>/var</tt>-Partition über genug
<i>freien Speicher</i> verfügen, um diese Dumpdateien halten zu
können.
Sei realistisch - nur wenige Entwickler möchten sich deine
1-GB-Dumpdatei ansehen. Solltest du also nicht vorhaben, einen
Absturz lokal zu überprüfen, ist dies vermutlich nicht wichtig für dich.
</ul>

<p>
Es gibt mehrere Hauptgründe, anstelle von nur ein oder zwei
Dateisystemen mehr separate Dateisysteme zu benutzen:

<ul>
<li><b>Sicherheit</b>: Du kannst einige Dateisysteme als nosuid,
  nodev, noexec, readonly etc. markieren. Das wird vom
  Installationsprozess erledigt, wenn du die oben beschriebenen
  Partitionen benutzt.
<li><b>Stabilität</b>: Ein Anwender oder ein amoklaufendes Programm kann
  ein Dateisystem mit Müll auffüllen, wenn sie darauf Schreibrechte
  haben. Deine kritischen Programme - dann natürlich auf einem anderen
  Dateisystem laufend - werden nicht unterbrochen.
<li><b>Geschwindigkeit</b>: Ein Dateisystem, in das dauernd
  hineingeschrieben wird, kann schnell fragmentieren (glücklicherweise
  ist das ffs-Dateisystem, das von OpenBSD benutzt wird, nicht für
  sowas anfällig).
<li><b>Integrität</b>: Wenn ein Dateisystem aus irgendeinem Grund defekt
  ist, sind deine anderen Dateisysteme immer noch in Ordnung.
<li><b>Größe</b>: Viele Maschinen haben Grenzen im Bezug auf den
  Ort, von dem aus das ROM den Kernel laden kann. In einigen Fällen
  kann die Grenze sehr niedrig sein (504 M für ältere 486), in
  anderen Fällen ist die Grenze recht hoch (zum Beispiel 2 G, 8 G
  oder 128 G auf i386-Systemen). Da sich der Kernel irgendwo in der
  Rootpartition befinden kann, muss die gesamte Rootpartition
  innerhalb dieser Grenze liegen. Mehr Details gibt es in
  <a href="faq14.html#LargeDrive">diesem Kapitel</a>. Eine gute
  Richtlinie ist, deine /-Partition einfach komplett unterhalb der
  ersten 2 GB zu lassen - es sei denn du weißt, dass deine Plattform
  (und besonders deine Maschine) damit umgehen kann.
</ul>

<p>
Noch ein paar Gedanken zur Partitionierung:
<ul>
 <li>Bei deinem ersten Versuch und einem experimentellen System ist eine
   große <tt>/</tt>-Partition und Swap das Einfachste, bis du
   weißt, wie viel Platz du brauchst. Dadurch wirst du einige der
   Standardsicherheitsmechanismen opfern, die OpenBSD bietet, die
   separate Dateisysteme für <tt>/, /tmp, /var, /usr</tt> und
   <tt>/home</tt> benötigen. Du solltest mit deiner ersten
   OpenBSD-Installation jedoch nicht in produktiven Einsatz gehen.
 <li>Ein sich im Internet befindliches oder anderweitig angreifbares
   System sollte eine separate Partition für <tt>/var</tt> haben (und
   vielleicht sogar eine separate für <tt>/var/log</tt>) für die
   Logdateien.
 <li>Eine <tt>/home</tt>-Partition ist durchaus nützlich. Neue Version
   des OS? Alles andere löschen und neu machen, aber die
   <tt>/home</tt>-Partition einfach unberührt lassen. Denke aber
   trotzdem daran, eine Sicherungskopie deiner Konfigurationsdateien
   anzulegen!
 <li>Eine separate Partition für alles, was eine große Anzahl
   Dateien erzeugen kann, kann man gegebenenfalls schneller formatieren
   und neu anlegen, als alle Dateien zu löschen. Siehe auch die
   FAQ zum Thema <a href="faq5.html#ProbObjPt">Vom Quelltext aus
   erzeugen</a> für ein Beispiel (<tt>/usr/obj</tt>).
 <li>Wenn du dein System aus irgendeinem Grund vom dem Quelltext aus neu
   erzeugen willst, sollte der Quelltext sich in <tt>/usr/src</tt>
   befinden. Wenn du kein separates Dateisystem für <tt>/usr/src</tt>
   hast, dann sorge unbedingt dafür, dass du in <tt>/usr</tt> genug
   Platz hast.
 <li>Ein oftmals vergessener Punkt: du musst auf deinem System
   <b>nicht</b> allen Platz sofort vergeben! Da du jetzt vermutlich kaum
   noch eine Festplatte unter 20 GB finden wirst, kann es durchaus Sinn
   machen, einfach ein bisschen Platz zu lassen. Wenn dir dann eine
   Partition zu klein wird, kannst du dann einfach aus deinem
   ungenutzten Platz eine neue Partition erstellen, deine existierende
   Partition auf die neue
   <a href="faq10.html#DupFS">duplizieren</a>, die
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab</a>
   ändern und auf die neue Partition verweisen lassen. Nach dem erneuten
   Mounten hast du bereits mehr Platz.
 <li>Wenn du deine Partitionen zu klein wählst, wirst du das
   vermutlich später bereuen, wenn es an der Zeit ist, dein System
   auf den neuesten Stand zu bringen.
<li>Wenn du sehr große Partitionen anlegst, solltest du im Hinterkopf
   behalten, dass die Dateisystemüberprüfung mittels
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
   ungefähr 1 M RAM für jedes Gigabyte der Dateisystemgröße benötigt
   und zudem sehr zeitaufwendig ist; oder sogar nicht ausführbar auf
   älteren, langsameren Systemen (greife bitte auf
   <a href="faq14.html#LargeDrive">diese Sektion</a> zurück).
 <li>Wenn du deinen Benutzern erlaubst, auf <tt>/var/www</tt> zu
   schreiben (z.&nbsp;B. persönliche Webseiten), möchtest du es
   vielleicht auf eine separate Partition legen, so dass du
   <a href="faq10.html#Quotas">Quotas</a> verwenden kannst, um den
   verwendbaren Speicher zu begrenzen. Wenn sie die Partition füllen,
   sind keine anderen Teile des Systems betroffen.
</ul>


<p>
<a name= "Multibooting"></a>
<h2>4.8 - Multibooting OpenBSD/i386</h2>

Multibooting ist, wenn man mehrere Betriebssysteme auf einem Computer
hat und auf irgendeine Art und Weise auswählen kann, welches OS
gebootet werden soll. Das ist <i>keine</i> unbedeutende Aufgabe! Wenn du
nicht verstehst, was du da machst, könntest du am Ende große
Datenmengen von deinem Computer gelöscht haben. Neuen OpenBSD-Benutzern
wird <i>dringend</i> dazu geraten, mit einer leeren Festplatte auf einer
extra hierfür freigestellten Maschine anzufangen und dann mit der
gewünschten Konfiguration auf einer nicht im Einsatz befindlichen
Maschine zu üben, bevor eine Multiboot-Konfiguration auf einer
eingesetzten Maschine versucht wird. <a href="faq14.html">FAQ
14</a> hat weitere Informationen über den OpenBSD-Bootprozess.

<p>
Hier sind einige Multibootmöglichkeiten:

<h3>Aktive Partitionen markieren</h3>
Dies ist die wahrscheinlich am häufigsten übersehende und
doch ab und zu beste Lösung für das Multibooten. Markiere einfach
die aktive Partition in welchem OS auch immer du dich befindest so, dass
sie diejenige ist, die beim nächsten Booten standardmäßig
gebootet wird. So gut wie jedes OS bietet ein Programm, mit dem das
bewerkstelligt werden kann; OpenBSDs ist <a
href="faq14.html#fdisk">fdisk(8)</a> - ähnlich genannte Programme gibt
es unter Windows 9x und DOS sowie unter vielen anderen
Betriebssystemen. Dies kann sehr wünschenswert für Betriebssysteme oder
Systeme sein, die sehr lange zum Herunterfahren und Neustarten brauchen
- du kannst sie markieren und das System neustarten, dann weggehen,
eine Tasse Kaffee holen und dann zum System wiederkehren, das so
hochgefahren ist, wie du es wolltest - kein Warten auf den magischen
Moment, in dem du das nächste OS auswählen musst.

<h3>Bootdiskette</h3>
Wenn du ein System hast, das nicht häufig zum Booten von OpenBSD
verwendet wird (oder nicht möchtest, dass andere Benutzer des Computers
mitbekommen, dass sich irgendwas geändert hat), ziehe das Verwenden
einer Bootdiskette in Betracht. Verwende einfach eine der <a
href="#MkFlop">normalen OpenBSD-Installationsdisketten</a> und erstelle
eine <tt>/etc/boot.conf</tt>-Datei (ja, du musst außerdem ein
<tt>/etc</tt>-Verzeichnis auf der Diskette anlegen) mit folgendem
Inhalt:

<pre>
     boot hd0a:/bsd
</pre>

Hiermit wird das System veranlasst, von Festplatte 0, OpenBSD-Partition
a mit Kerneldatei <tt>/bsd</tt> zu booten. Denke daran, dass du mit
einer Zeile wie dieser auch von anderen Laufwerken booten kannst:
<tt>boot hd2a:/bsd</tt> zum Beispiel bootet von der dritten Festplatte
deines Systems. Um OpenBSD zu booten, lege die Diskette ein und starte
neu. Um das andere OS zu booten, nehme die Diskette aus dem Laufwerk und
starte neu.

<p>
In diesem Fall wird das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>-Programm
geladen - es sucht nach <tt>/etc/boot.conf</tt> und liest sie
aus. Die Zeile <tt>boot hd0a:/bsd</tt> weist boot(8) zu, von wo aus
der Kernel geladen werden soll - in diesem Fall von der ersten
Festplatte, die das BIOS sieht. Behalte im Hinterkopf, dass nur eine
kleine Datei (<tt>/boot</tt>) von der Diskette geladen wird - das System
lädt den gesamten Kernel von der Festplatte, so dass ungefähr nur fünf
Sekunden zum Bootprozess hinzugefügt werden.

<h3>Windows NT/2000/XP NTLDR</h3>

Um OpenBSD und Windows NT/2000/XP starten zu können, kannst du den
NTLDR benutzen, den Bootloader von NT. Um mit NT einen Multiboot
durchführen zu können, benötigst du
eine Kopie des OpenBSD-Partitionbootrecords (PBR).
Nach dem Ausführen von installboot kannst du ihn mit einem Aufruf
wie dem folgenden unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
in eine Datei kopieren:

<pre>
	# <strong>dd if=/dev/rsd0a of=openbsd.pbr bs=512 count=1</strong>
</pre>

Hinweis: Jetzt ist ein guter Zeitpunkt, dich daran zu erinnern,
dass es eine wirklich schlechte Idee ist, Befehle einzutippen, die du
nicht verstehst. Dieser Aufruf wird auf den meisten Computern nicht
direkt verwendet werden können. Es bleibt nun dem Leser überlassen,
ihn an seine Maschine anzupassen.

<p>
Starte nun NT und platziere <tt>openbsd.pbr</tt> auf C:. Füge eine
Zeile wie die folgende am Ende von <tt>C:\BOOT.INI</tt> hinzu:

<pre>
	c:\openbsd.pbr="OpenBSD"
</pre>

<p>
Nach einem Neustart solltest du OpenBSD im NT-Loadermenü
auswählen können. Zum NTLDR gibt es im
<a href="http://www.tburke.net/info/ntldr/ntldr_hacking_guide.htm">NTLDR
Hacking Guide</a> mehr Informationen.

<p>
Auf Windows XP kannst du die Bootinformationen auch mit Hilfe der GUI
editieren; siehe auch das
<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;289022">XP Boot.ini HOWTO</a>.

<p>
Programme stehen zur Verfügung, die dir viele von diesen Tätigkeiten
abnehmen - zum Beispiel <a
href="http://www.winimage.com/bootpart.htm">BootPart</a>.
Dieses Programm kann unter Windows NT/2000/XP ausgeführt werden und
lädt den OpenBSD-PBR, platziert ihn auf deine NT/2000/XP-Partition und
fügt ihn zur <tt>C:\BOOT.INI</tt> hinzu.

<p>
Hinweis: Der Windows-NT/2000/XP-Bootloader ist nur in der Lage,
Betriebssysteme von der primären Festplatte zu booten.
Du kannst ihn nicht verwenden, um OpenBSD von der zweiten Festplatte zu
laden.

<p>
<h3>Andere Bootloader</h3>

<p>
Zu einigen anderen Bootloadern, die von OpenBSD-Anwendern erfolgreich
eingesetzt worden sind, gehöhren
<a href="http://gag.sourceforge.net/">GAG</a>,
OS-BS,
<a href="http://www.ranish.com/part/">The Ranish Partition Manager</a>
und <a href="http://www.gnu.org/software/grub/">GRUB</a>.

<p>
<h3>OpenBSD und Linux (i386)</h3>
<!-- XXXversion -->

<p>
Bitte lies dir
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/4.0/i386/INSTALL.linux">INSTALL.linux</a>
durch, um genaue Informationen zur Zusammenarbeit zwischen OpenBSD und
Linux zu bekommen.

<a name= "SendDmesg"></a>
<h2>4.9 - Nach der Installation deine dmesg an dmesg@openbsd.org
schicken</h2>

<p>
Um es nochmal allen ins Gedächtnis zu rufen: Es ist wichtig für
die OpenBSD-Entwickler, im Auge zu behalten, welche Art von Hardware
funktioniert und welche eben nicht perfekt funktioniert.

<p>
Ein Zitat aus /usr/src/etc/root/root.mail
<pre>
If you wish to ensure that OpenBSD runs better on your machines, please do us
a favor (after you have your mail system configured!) and type something like:
 # dmesg | mail -s "Sony VAIO 505R laptop, apm works OK" dmesg@openbsd.org
so that we can see what kinds of configurations people are running.  As shown,
including a bit of information about your machine in the subject or the body
can help us even further.  We will use this information to improve device driver
support in future releases.  (Please do this using the supplied GENERIC kernel,
not for a custom compiled kernel, unless you're unable to boot the GENERIC
kernel).  The device driver information we get from this helps us fix existing
drivers. Thank you!
</pre>

<p>
Stelle sicher, dass du nicht nur E-Mails von deinem Konto senden sondern
auch empfangen kannst - für den Fall, dass dich ein Entwickler
kontaktieren will, um etwas zu testen oder um deine Konfiguration zum
Laufen zu bringen. Es ist nicht wichtig, dass du die E-Mail von einem
Rechner mit OpenBSD verschickst, wenn also dieser Rechner keine E-Mail
empfangen kann, dann gib einfach

<pre>
$ dmesg | mail your-account@yourmail.dom
</pre>
ein und leite dann diese Nachricht weiter an
<pre>
 dmesg@openbsd.org
</pre>
wobei <tt>your-account@yourmail.dom</tt> dein reguläres E-Mail-Konto
ist
(oder transferiere die dmesg-Ausgabe mittels
FTP/scp/Diskette/carrier-pigeon/...).

<p>
<strong>ANMERKUNG</strong> - Bitte schicke nur dmesgs des
GENERIC-Kernels. Eigenkompilierte Kernel sind nicht hilfreich, wenn
Gerätetreiber fehlen.

<p>
Bedenke auch, dass die Dmesgs von einem Computer erhalten werden, der
das Spamblockersystem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=spamd&amp;sektion=8">spamd</a>
einsetzt. Dies könnte dazu führen, dass deine Dmesg vom Mailserver für
eine gewisse Zeit nicht angenommen wird. Habe Geduld - nach einer
halben Stunde, Stunde oder so wird sie durchkommen.

<a name="AddFileSet"></a>
<h2>4.10 - Ein Dateiset nach der Installation hinzufügen</h2>
<!-- XXXversion -->
»Oh nein! Ich habe bei der Installation eines der Dateisets vergessen!«
<p>
Manchmal merkt man erst nach Abschluss der Installation, dass man
<tt>comp40.tgz</tt> (oder irgendeine andere Systemkomponente) DOCH
benötigt.  Kein Problem: Es gibt zwei einfache Wege, diese Komponenten
aus der Installation noch nachträglich einzuspielen:

<h3>Indem man den Upgradeprozess benutzt</h3>
Boote einfach von deinem Installationsmedium (CD-ROM oder Diskette) und
wähle Upgrade (und nicht Install). Wenn du zur Liste mit den
Dateisets kommst, wähle die Sets, die du beim ersten Mal vergessen
hast. Wähle deine Quelle aus und lass die Installation beginnen.

<h3>Indem man tar(1) benutzt</h3>
Die Installationsdateien sind einfach komprimierte tar-Dateien. Du
kannst sie dementsprechend am Root (/) des Dateisystems auspacken:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # cd /
  # tar xzvpf comp40.tgz
</pre></td></tr></table>

<p>
Du darfst NICHT die Option <tt>p</tt> im oben genannten Kommando
vergessen: die Dateirechte werden sonst nicht richtig gesetzt!
<p>
Ein häufig gemachter Fehler ist, zu denken, man könne 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1">pkg_add(1)</a>
benutzen, um fehlende Dateisets einzuspielen. Das funktioniert aber
nicht. pkg_add(1) ist das <a href="faq15.html#PkgMgmt">Werkzeug für die
Packagesverwaltung</a>, um Software von Drittanbietern zu installieren.
Es verarbeitet Packagedateien, jedoch keine normalen Tardateien wie
zum Beispiel die Installationssets.


<a name="bsd.rd"></a>
<h2>4.11 - Was ist bsd.rd?</h2>

<b><tt>bsd.rd</tt></b> ist ein RAM-Disk-Kernel. Diese Datei kann sehr
nützlich sein; viele Entwickler lassen sie mit Absicht immer im
Quellverzeichnis ihres Dateisystems.

<p>
Ihn einen RAM-Disk-Kernel zu nennen, beschreibt das Rootdateisystem
des Kernels - es ist kein physikalisches Laufwerk. Die Werkzeuge,
die nach dem Booten von <tt>bsd.rd</tt> genutzt werden können, befinden
sich im Kernel und werden aus einem RAM-basierten Dateisystem geladen.
<tt>bsd.rd</tt> enthält auch ein brauchbares Set an Werkzeugen für
Systemwartung und -installation.

<p>
Auf manchen Plattformen ist <tt>bsd.rd</tt> sogar die bevorzugte
Installationstechnik. Du plazierst diesen Kernel in ein vorhandenes
Dateisystem, bootest ihn und führst daraus die Installation aus. Auf den
meisten Plattformen kannst du, falls du eine ältere Version von OpenBSD
hast, eine neue Version von <tt>bsd.rd</tt> per FTP holen, damit booten
und eine neue Version von OpenBSD installieren - ohne eine Diskette oder
CD-ROM zu benutzen.

<p>
Hier zum Beispiel das Booten von <tt>bsd.rd</tt> auf einem i386-System:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Using Drive: 0 Partition: 3
  reading boot.....
  probing: pc0 com0 com1 apm mem[639k 255M a20=on]
  disk: fd0 hd0
  &gt;&gt; OpenBSD/i386 BOOT 2.10
  boot&gt; <b>boot hd0a:/bsd.rd</b>
<i>. . . normal boot to install . . .</i>
</pre></td></tr></table>

Wie schon gesagt wirst du in das Installationsprogramm geführt. Du
kannst natürlich auch auf die Shell gehen, um dein System zu pflegen
oder zu administrieren.
<p>
Die einfache Regel, um <tt>bsd.rd</tt> booten zu können, lautet:
Tausche <tt>/bsd</tt> durch <tt>bsd.rd</tt> aus - was auch immer das auf
deiner Plattform heißen mag.


<a name="InstProb"></a>
<h2>4.12 - Allgemeine Installationsprobleme</h2>

<a name="cpq16m"></a>
<h3>4.12.1 - Mein Compaq erkennt nur 16 M RAM</h3>
<i>Einige</i> Compaq-Systeme haben das Problem, dass der gesamte
Hauptspeicher von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">OpenBSDs
Secondstage-Bootloader</a> nicht ordentlich erkannt wird und nur 16 M
erkannt und von OpenBSD verwendet werden. Dies kann entweder durch das
Erstellen/Editieren von der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"><tt>/etc/boot.conf</tt></a>
oder durch das Eingeben von Befehlen am <tt>boot></tt>-Prompt behoben
werden, bevor OpenBSD lädt. Falls du eine Maschine mit 64 M RAM hast,
aber OpenBSD nur die ersten 16 M erkennt, sieht der Befehl, den du
benutzen würdest, wie folgt aus:

<pre>
     machine mem +0x3000000@0x1000000
</pre>
um 48 M (<tt>0x3000000</tt>) nach den ersten 16 M (<tt>0x1000000</tt>)
hinzuzufügen. Typischerweise würdest du den oben angegeben
Befehl am Installationsprompt <tt>boot></tt> der Diskette/CD-ROM eingeben,
neustarten und eine <tt>/etc/boot.conf</tt>-Datei anlegen, die den oben
angegebenen Befehl beinhaltet, so dass alle zukünftigen Starts des
Systems den ganzen verfügbaren Speicher erkennen können, wenn du
ein System mit diesem Problem hättest.

<p>
Es wurde ebenfalls berichtet, dass ein ROM-Update dieses Problem auf
<i>einigen</i> Systemen löst.

<a name="noboot"></a>
<h3>4.12.2 - Mein i386 bootet nach der Installation nicht</h3>
Deine Installation verlief gut, doch beim ersten Hochfahren erkennst du
keine Anzeichen dafür, dass OpenBSD versucht zu starten. Es existieren
einige bekannte Gründe für dieses Problem:

<ul>
<li><b>Keine Partition wurde in fdisk(8) als aktiv markiert.</b> Um dies
zu beheben, starte das System unter Verwendung der Bootdiskette oder
anderer Medien neu und markiere eine Partition als aktiv
(bootfähig). Siehe <a href="faq14.html#fdisk">hier</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">hier</a>.

<li><b>Kein gültiger Bootloader wurde jemals auf die Platte
geschrieben</b>
Falls du mit »Y« auf die Frage "Use entire disk for OpenBSD?" während
der Installation geantwortet hast oder die <tt>reinit</tt>-Option von
fdisk(8) verwendet hast, wurde der OpenBSD-Bootrecord im
Masterbootrecord der Platte installiert; ansonsten wurde der
existierende Masterbootrecord-Code nicht berührt. Dies wird ein
Problem sein, wenn kein anderer Bootrecord existierte.
Eine Lösung ist, das Installationsmedium wieder zu booten, auf die
Shell zurückzugreifen und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
aufzurufen, um den MBR-Code von der Befehlszeile aus zu aktualisieren:
<pre>
    # fdisk -u wd0
</pre>
Hinweis: Die Updateoption im interaktiven Modus (-e) von fdisk
wird keine Signaturbytes schreiben, die benötigt sind, um die
Platte bootfähig zu machen.

<li><b>In einigen wenigen Fällen kann etwas mit der
Secondstage-Bootloaderinstallation schief gelaufen sein.</b> Das
Neuinstallieren des Secondstage-Bootloaders wird
<a href="faq14.html#InstBoot">hier</a> besprochen.

</ul>

<a name="sshhang"></a>
<h3>4.12.3 - Meine (ältere, langsamere) Maschine bootet, aber hängte
bei der ssh-Schlüsselgenerierung</h3>
Es ist sehr wahrscheinlich, dass dein System einwandfrei funktioniert,
nur dass die ssh-Schlüsselgenerierung eine Weile dauert. Eine
SPARCStation2 oder ein Macintosh Quadra können <i>mehrere Stunden</i>
oder länger in Anspruch nehmen, um die drei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>-Schritte
auszuführen.
Lass es einfach abschließen - es wird nur ein einziges Mal pro
Installation gemacht.

<p>
Beachte, dass die Standardschlüsselgröße mit 3.8 vergrößert wurde,
so dass die benötigte Zeit für die Generation noch länger geworden
ist als sie bisher schon war. Benutzer von sehr langsamen Maschinen
sollten daher in Betracht ziehen, ihre Schlüssel auf einem anderen
Computer zu erzeugen, diese dann in einer
<a href="#site">site40.tgz</a>-Datei abzulegen und sie mit dem Rest
der Dateisets zu installieren.


<a name="noftplist"></a>
<h3>4.12.4 - Ich bekam die Meldung »Failed to change
directory« als ich die Installation durchführte</h3>

Wenn du eine FTP-Installation eines
<a href="faq5.html#Flavors">Flavors</a> während der
<i>-beta</i>-Phase des OpenBSD-Entwicklungszyklus durchführst, könntest
du dies lesen:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>

  Do you want to see a list of potential FTP servers?  [yes] <b><i>Enter</i></b>
  Getting the list from 192.128.5.191 (ftp.openbsd.org)... FAILED
  Failed to change directory.
  Server IP address or hostname?
</pre></td></tr></table>

Dies ist normal und ein erwartetes Verhalten während der
Prerelease-Phase des Zyklus. Das Installationsprogramm sucht nach
der FTP-Liste auf dem primären FTP-Server in einem Verzeichnis, das bis
zum <a href="faq1.html#Next">Releasedatum</a> nicht verfügbar ist, so
dass du die oben genannte Meldung bekommst.

<p>
Verwende einfach eine
<a href="../../de/ftp.html">FTP-Mirrorliste</a>, um deinen
favorisierten FTP-Mirror zu finden, und gib ihn manuell ein, wenn du
gefragt wirst.

<p>
<b>Hinweis: Du solltest die Meldung nicht sehen, wenn du <i>-release</i>
oder von einer CD-ROM installierst.</b>

<a name="blankfdisk"></a>
<h3>4.12.5 - Meine fdisk-Partitionstabelle ist kaputt oder leer!</h3>
Gelegentlich finden Benutzer ein funktionsfähiges System vor,
das aber beim Verwenden von <tt>fdisk wd0</tt> eine vollständig
leere (oder ab und zu, vermüllte) Partitionstabelle aufweist.
Dies ist normalerweise verursacht, wenn eine Partition in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
erstellt wurde, die ein Offset von Sektor 0 hat, anstatt dem
<a href="#trackoffset">Offset von einer Spur</a>, den sie haben
sollte (Hinweis: Dies nimmt an, dass es sich um die
<a href="../../de/i386.html">i386</a>- oder
<a href="../../amd64.html">amd64</a>-Plattform handelt. Andere
Plattformen benötigen andere Offsets, einige sogar GAR KEINEN
Offset).
Das System <a href="faq14.html#Boot386">bootet</a> dann unter Verwendung
des PBR und nicht des MBR.

<p>
Obwohl diese Konfiguration funktioniert, kann es ein Wartungsproblem
sein und sollte korrigiert werden.
Um dies zu korrigieren, muss das Dateisystem der Platte normalerweise
von Grund auf neu erstellt werden (obwohl, wenn du WIRKLICH weißt
was du tust, kannst du in der Lage sein, nur dein Disklabel und den
MBR neu zu erstellen und musst nur die erste OpenBSD-Partition der
Festplatte neu errichten).

<a name="site"></a>
<h2>4.13 - Anpassen des Installationsprozesses</h2>
<!-- XXXversion -->

<h3><tt>siteXX.tgz</tt>-Datei</h3>
Die OpenBSD-Installationsskripte erlauben das Auswählen eines
benutzererstellten Sets. Dieses Set wird <tt>siteXX.tgz</tt> genannt,
wobei XX für die Releaseversion (z.&nbsp;B. 40) steht. Das
<tt>siteXX.tgz</tt>-Dateiset ist wie die anderen
<a href="#FilesNeeded">Dateisets</a> ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gzip&amp;sektion=1">gzip(1)</a>-komprimiertes
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>-Archiv,
daus auf / basiert und wird wie die anderen Sets mit den
Optionen <tt>xzpf</tt> enttart. Dieses Set wird zuletzt nach allen
anderen Dateisets installiert.

<p>
Dieses Dateiset erlaubt es dem Benutzer, Dateien hinzuzufügen oder
Dateien zu überschreiben, die von den normalen Sets installiert
worden sind, um so die Installation oder das Upgrade anpassen zu können.

<p>
Du kannst ebenfalls hostnamenspezifische Installationssets erstellen und
einsetzen. Der Name dieser Installationssets ist wie folgt aufgebaut:
<tt>siteXX-<i>&lt;hostname&gt;.tgz</i></tt> (zum Beispiel
»<tt>site40-puffy.tgz</tt>«).
Hiermit sollte es dir möglich sein, Installationen, Upgrades und
Wiederherstellungen besser an Hosts anzupassen.

<p>
Einige Beispielverwendungen einer <tt>siteXX.tgz</tt>-Datei:
<ul>
<li>Erstelle eine siteXX.tgz-Datei, die alle Änderungen beinhaltet,
die du seit dem ersten Installieren von OpenBSD gemacht hast. Dann,
wenn du das System neuerstellen musst, wählst du einfach siteXX.tgz
während der Neuinstallation aus und alle Änderungen von dir
werden auf dem neuen System nachgebildet.

<li>Erstelle eine Serie an maschinenspezifischen Verzeichnissen, die
jeweils eine siteXX.tgz-Datei beinhalten, die wiederum spezifische
Dateien für diese Maschine beinhalten. Installationen von Maschinen
(z.&nbsp;B. Systeme mit unterschiedlichen Grafikkarten) einer bestimmten
Kategorie können durch das Auswählen der passenden siteXX.tgz-Datei
abgeschlossen werden.

<li>Stecke die Dateien, die du routinemäßig auf einen gleichen
oder ähnlichen Weg anpasst, in eine siteXX.tgz-Datei:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"><tt>/etc/skel</tt></a>-Dateien,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><tt>/etc/pf.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8"><tt>/var/www/conf/httpd.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"><tt>/etc/rc.conf.local</tt></a>
etc.
</ul>

<h3><tt>install.site</tt>/<tt>upgrade.site</tt>-Skripte</h3>
Als letzten Schritt im Installations/Upgrade-Prozess sucht im
Wurzelverzeichnis des neu installierten/aktualisierten System je nach
aktuellem Prozess nach <tt>install.site</tt> oder <tt>upgrade.site</tt>
und führt das Skript in einer Umgebung aus, die auf das 
Wurzelverzeichnis des installierten/aktualisierten System
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=8">chroot</a>et
ist. Denke daran, dass das Upgrade von einem gebooteten Dateisystem
aus ausgeführt wird, so dass dein Ziel tatsächlich auf <tt>/mnt</tt>
gemountet ist. Trotzdem kann dein Skript aufgrund des Chroots so
geschrieben werden, als ob es im normalen Wurzelverzeichnis deines
Dateisystems ausgeführt wird. Da das Skript ausgeführt wird, wenn alle
Dateien bereits installiert worden sind, hast du fast volle
Funktionalität deines Systems (allerdings im Singleuser-Modus), wenn
dein Skript läuft.

<p>
Bedenke, dass das <tt>install.site</tt>-Skript in der
<tt>siteXX.tgz</tt>-Datei liegen sollte, während das
<tt>upgrade.site</tt>-Skript vor dem Upgrade in das Wurzelverzeichnis
gelegt werden kann - oder in eine <tt>siteXX.tgz</tt>-Datei.

<p>
Die Skripte können für viele Dinge verwendet werden:
<ul>
<li>Entferne Dateien, die installiert/aktualisiert worden sind, die du
auf dem System aber nicht haben möchtest.
<li>Entferne/aktualisiere/installiere die
<a href="faq15.html#PkgMgmt">Packages</a>, die du auf dem installierten
System haben möchtest.
<li>Erstelle ein <a href="faq14.html#Backup">sofortiges Backup/Archiv</a>
des neuen Systems, bevor du es dem Rest der Welt aussetzt.
<li>Verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>,
um die Systemzeit einzustellen.
</ul>

<p>
Die Kombination von <tt>siteXX.tgz</tt>- und
<tt>install.site/upgrade.site</tt>-Dateien sollen den Benutzern eine
breite Palette von Fähigkeiten bieten, ohne dass sie selbst eigene
Installationssets erstellen müssen.

<p>
Hinweis: wenn du über einen HTTP-Server installierst, so musst du die
<tt>site*.tgz</tt>-Datei (oder Dateien) in der Datei <tt>index.txt</tt>
im Quellverzeichnis auflisten, damit sie während der Installation als
Option angezeigt wird. Dies gilt nicht für FTP- oder andere
Installationsmethoden.


<a name="Multiple"></a>
<h2>4.14 - Wie kann ich eine Anzahl gleichartiger Systeme
installieren?</h2>
Hier sind einige Anwendungen aufgelistet, die du verwenden kannst, wenn
du mehrere ähnliche OpenBSD-Systemen installieren musst.

<h3><tt>siteXX.tgz</tt>- und <tt>install/upgrade.site</tt>-Dateien</h3>
Siehe den <a href="#site">vorherigen</a> Artikel.

<h3>Von dump(8) wiederherstellen</h3>
Auf den meisten Plattformen beinhaltet das Bootmedium das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>-Programm,
welches verwendet werden kann, um ein Backup zu extrahieren, das mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
erstellt wurde. Du kannst daher von
<a href="#MkFlop">Diskette</a>,
<a href="../../de/orders.html">CD</a> oder
<a href="#bsd.rd">bsd.rd</a>-Datei booten, dann
<a href="faq14.html#fdisk">fdisk</a> und
<a href="faq14.html#disklabel">disklabel</a> ausführen und mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore</a>
die gewünschte Konfiguration von Band oder einem anderen Medium
wiederhestellen und die <a href="faq14.html#InstBoot">Bootblöcke</a>
installieren. Weitere Details gibt es
<a href="faq14.html#Backup">hier</a>.

<h3>Plattenimaging</h3>
Leider existiert kein bekanntes Plattenimaging-Programm, das FFS
unterstützt und so nur den aktiv genutzten Dateispeicher nutzen
könnte. Die meisten der bekannteren Plattenimaging-Lösungen
behandeln OpenBSD-Partitionen als allgemeine Partition und können ein
Image der gesamten Platte erzeugen. Damit erreichst du zwar dein Ziel,
aber verbrauchst für gewöhnlich viel Speicher - eine leere, 10 G große
<tt>/home</tt>-Partition wird 10 G Speicher im Image verbrauchen, selbst
wenn sich dort keine einzige Datei befindet. Während du normalerweise
ein Laufwerksimage auf ein größeres Laufwerk installieren kannst, wirst
du nicht in der Lage sein, den zusätzlichen Speicher direkt zu nutzen.
Du wirst auch nicht in der Lage sein, ein Image auf ein kleineres
Laufwerk zu installieren.

<p>
Falls das eine akzeptable Situation für dich ist, könnte der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd</a>-Befehl
deinen Ansprüchen genügen, wenn es darum geht, eine Platte Sektor für
Sektor auf eine andere zu kopieren. Dies bietet dir die gleiche
Funktionalität wie die der kommerziellen Produkte ohne zusätzliche
Kosten.

<a name="getdmesg"></a>
<h2>4.15 - Woher bekomme ich eine dmesg(8), damit ich ein Problem mit
der Installation melden kann?</h2>
Wenn man <a href="../../de/report.html">ein Problem meldet</a>, ist es
entscheidend, eine komlette
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
des Systems einzufügen.
Wie auch immer - oft ist es so, dass du dies machen musst, wenn das
System nicht ordnungsgemäß funktioniert oder nicht installieren
will, so dass du weder Platten-, Netzwerk- oder andere Ressourcen zur
Verfügung hast, um deine dmesg an die passende
<a href="../../de/mail.html">Mailingliste</a> zu senden. Es gibt aber
andere Wege:

<ul>
<li><b>Diskette</b> Die Bootdisketten und die CD-ROM haben
genügend Anwendungen, um deine dmesg auf eine MSDOS-Diskette
zu schreiben, damit eine andere Maschine sie lesen kann. Lege eine
MSDOS-formatierte Diskette in dein Diskettenlaufwerk und führe
folgende Befehle aus:

<pre>
     mount -t msdos /dev/fd0a /mnt
     dmesg > /mnt/dmesg.txt
     umount /mnt
</pre>
Falls du ein anderes OpenBSD-System besitzt, kannst du es ebenfalls
auf eine OpenBSD-kompatible Diskette schreiben - oftmals hat die
Bootdiskette genügend freien Raum, um die Dmesg zu halten. In
dem Fall lasse das <tt>-t msdos</tt> oben weg.

<p>
<li><b>Serielle Konsole:</b>
Eine serielle Konsole verwenden und die Ausgabe auf einer anderen
Maschine abzufangen ist oftmals der beste Weg, um Diagnoseinformationen
erhalten zu können - insbesondere, wenn der Computer direkt nach dem
Hochfahren in einer Panic endet. Neben einem weiteren Computer
benötigst du ebenfalls ein passendes serielles Kabel (oft ein
Nullmodemkabel) und ein Terminalemulator-Programm, das die
Bildschirmausgabe in eine Datei schreiben kann.

<p>
Generelle Informationen zum Aufsetzen eines seriellen Terminals
sind <a href="faq7.html#SerCon">an einer anderen Stelle der FAQ</a>
verfügbar; um eine Aufzeichnung der Installation abfangen zu können,
sind in der Regel folgende Befehle ausreichend.

<p><b>i386</b>

<p>
Gib am Bootloaderprompt Folgendes ein:

<p>
<blockquote>
<pre>
boot> <b>set tty com0</b>
</pre>
</blockquote>

<p>
Dies teilt OpenBSD mit, dass die erste serielle Schnittstelle
(in PC-Dokumentationen oft COM1 oder COMA genannt) als serielle Konsole
verwendet werden soll.  Die Standardbaudrate ist 9600.

<p><b>Sparc/Sparc64</b>

<p>
Diese Maschinen starten automatisch mit einer seriellen Konsole, wenn
sie ohne angeschlossene Tastatur gestartet wurden. Falls du Tastatur
und Monitor angeschlossen hast, kannst du das System trotzdem dazu
bringen, eine serielle Konsole zu verwenden, indem du folgende Befehle
am <tt>ok</tt>-Prompt aufrufst.

<p>
<blockquote>
<pre>
ok <b>setenv input-device ttya</b>
ok <b>setenv output-device ttya</b>
ok <b>reset</b>
</pre>
</blockquote>

<p>
<li><b>FTP:</b> Unter bestimmten Umständen und der Voraussetzung,
dass du zuerst dein Netzwerk richtig eingrichtet hast, kann es dir
möglich sein, mit Hilfe des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>-Clients
der Bootdiskette oder CD-ROM, die Dmesg zu einem lokalen
FTP-Server zu senden, von wo aus du sie später wiederholen kannst.
</ul>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Wo man OpenBSD herbekommt]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a> 
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq4.html,v 1.236 ]<br>
$Translation: faq4.html,v 1.115 2007/02/09 18:13:47 paldium Exp $<br>
-->
$OpenBSD: faq4.html,v 1.99 2007/02/10 05:22:16 saad Exp $
</small>
</body>
</html>
