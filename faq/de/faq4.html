<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>4 - Installationsanleitung für OpenBSD 5.0</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 4 - Installation Guide">
<meta name= "keywords"      content= "openbsd,faq4">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2013 by OpenBSD.">
</head>

<!-- Passes validator.w3.org.  Please keep it this way -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Mit OpenBSD durchstarten]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<h1><font color="#e00000">4 - Installationsanleitung für OpenBSD 5.3</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#Overview"    >4.1 -
    Eine Übersicht über die OpenBSD-Installationsprozedur</a>
<li><a href="#Checklist"   >4.2 - Vor der Installation: Checkliste</a>
<li><a href="#MkInsMedia"  >4.3 -
    Startfähige OpenBSD-Installationsmedien erzeugen</a>
    <ul>
    <li><a href="#MkCD-ROM"  >4.3.1 - Erzeugung einer startfähigen CD-ROM</a>
    <li><a href="#UnixFlop"  >4.3.2 - Disketten unter Unix erzeugen</a>
    <li><a href="#DosFlop"   >4.3.3 - Disketten unter Windows erzeugen</a>
    </ul>
<li><a href="#Boot"        >4.4 - Starten eines OpenBSD-Installationsmediums</a>
<li><a href="#Install"     >4.5 - Eine einfache Installation durchführen</a>
  <ul>
  <li><a href="#InstStart"    >4.5.1 - Mit der Installation beginnen</a>
  <li><a href="#InstQuestions">4.5.2 - Die Fragen der Installation</a>
  <li><a href="#InstDisks"    >4.5.3 - Laufwerke einrichten</a>
  <li><a href="#InstMedia"    >4.5.4 -
        Auswahl des Installationsmediums und der Dateisets</a>
  <li><a href="#Inst1stBoot"  >4.5.5 - Der erste Start!</a>
  <li><a href="#InstFinish"   >4.5.6 - Eine letzte Sache&nbsp;...</a>
  </ul>
<li><a href="#More"        >4.6 - Details für eine komplexere Installation</a>
  <ul>
  <li><a href="#MoreNetwork"  >4.6.1 - Einrichtung des Netzwerks</a>
  <li><a href="#MoreTimeZone" >4.6.2 - Festlegung der Zeitzone</a>
  <li><a href="#Morefdisk"    >4.6.3 - Anpassung der fdisk(8)-Konfiguration</a>
  <li><a href="#Moredisklabel">4.6.4 - Anpassung der disklabel-Konfiguration</a>
  </ul>
<li><a href="#FilesNeeded" >4.7 -
    Welche Dateien werden für die Installation benötigt?</a>
<li><a href="#Partitioning">4.8 -
    Wie sollte ich mein Laufwerk partitionieren?</a>
<li><a href="#Multibooting">4.9 - »Multibooting« OpenBSD (amd64, i386)</a>
<li><a href="#SendDmesg"   >4.10 -
    Das Senden deiner »dmesg« an dmesg@openbsd.org nach der Installation</a>
<li><a href="#AddFileSet"  >4.11 -
    Ein Dateiset nach der Installation hinzufügen</a>
<li><a href="#bsd.rd"      >4.12 - Was ist »bsd.rd«?</a>
<li><a href="#InstProb"    >4.13 - Geläufige Installationsprobleme</a>
  <ul>
  <li><a href="#cpq16m"      >4.13.1 -
        Mein Compaq erkennt nur 16&nbsp;MB RAM</a>
  <li><a href="#noboot"      >4.13.2 -
        Mein i386 startet nach der Installation nicht</a>
  <li><a href="#sshhang"     >4.13.3 -
        Mein System startete, hing aber bei der SSH-Schlüsselgenerierung</a>
  <li><a href="#noftplist"   >4.13.4 -
        Ich bekam die Meldung »Failed to change directory«
        als ich die Installation durchführte</a>
  <li><a href="#blankfdisk"  >4.13.5 -
        Meine fdisk-Partitionstabelle ist kaputt oder leer!</a>
  <li><a href="#noflopcd"    >4.13.6 -
        Mein System besitzt weder Disketten- noch CD-ROM-Laufwerk</a>
  <li><a href="#shamismatch" >4.13.7 -
        Ich bekam einen SHA256-Prüfsummenfehler während der Installation!</a>
  </ul>
<li><a href="#site"        >4.14 - Anpassung des Installationsprozesses</a>
<li><a href="#Multiple"    >4.15 -
    Wie kann ich eine Anzahl gleichartiger Systeme installieren?</a>
<li><a href="#getdmesg"    >4.16 -
    Woher bekomme ich eine dmesg(8),
    damit ich ein Problem mit der Installation melden kann?</a>
</ul>
<hr>

<p>
<a name= "Overview"></a>
<h2>4.1 - Eine Übersicht über die OpenBSD-Installationsprozedur</h2>

<p>
OpenBSD wird seit langem für seinen einfachen und geradlinigen
Installationsprozess anerkannt, der auf allen Plattformen gleich aufgebaut ist.

<p>
Alle Plattformen besitzen eine sehr ähnliche Installationsprozedur, jedoch
gibt es auf ein paar Plattformen einige kleine Unterschiede im Detail.
In jedem Fall wird dringend dazu geraten, das plattformspezifische
INSTALL-Dokument im <i>Plattform</i>-Verzeichnis auf der CD-ROM oder den
FTP-Seiten (z.&nbsp;B. <tt>i386/INSTALL.i386</tt>,
<tt>macppc/INSTALL.macppc</tt> oder <tt>sparc/INSTALL.sparc</tt>) durchzulesen.

<p>
Das OpenBSD-Installationsprogramm ist ein <a href="#bsd.rd">spezieller</a>
Kernel mit einigen Werkzeugen und Installationsskripten, die sich auf einem
vorgeladenen RAM-Laufwerk befinden.
Nachdem dieser Kernel gestartet wurde, wird das Betriebssystem aus einigen
komprimierten
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1"
>tar(1)</a> (<tt>.tgz</tt>) Dateien extrahiert, die sich nicht auf dem
vorgeladenen RAM-Laufwerk befinden, und daher aus einer anderen Quelle bezogen
werden müssen.
Es existieren mehrere Wege, diesen Installationskernel zu starten:

<ul>
<li><b>Diskette:</b>
OpenBSD kann auf vielen Plattformen installiert werden, indem ein
Installationsprogramm von einer einzigen Diskette gestartet wird.
Einschränkungen des verfügbaren Speicherplatzes jedoch zwingt einige »größere«
Plattformen (sparc64, amd64, alpha), einige Werkzeuge auszulassen, die
vielleicht gerade für dich wichtig sind, so z.&nbsp;B. ein DHCP-Programm,
welches die Netzwerkanbindung konfigurieren könnte.
Auf diesen Plattformen wirst du wahrscheinlich mit einer CD-basierten
Installation besser fahren.
Auf Plattformen wie i386 und sparc jedoch wird dir der Inhalt der Startdiskette
sehr komplett erscheinen.

<p>
Die bereitgestellten Diskettenabbilder können dazu benutzt werden,
um Installationsdisketten auf einem anderen
<a href="#UnixFlop">Unix-ähnlichen</a>-, oder einem
<a href="#DosFlop">Windows</a>-System zu erstellen.
Ein typischer Dateiname ist <tt>floppy53.fs</tt>, obwohl für einige
Plattformen mehrere Diskettenabbilder vorhanden sind.

<li><b>CD-ROM:</b> Für einige Plattformen wird ein CD-ROM-Abbild
(<tt>cd53.iso</tt> für den reinen Systemstart oder <tt>install53.iso</tt> für
eine komplette Installation) bereitgestellt, mit dem eine startfähige CD-ROM
erzeugt werden kann.

<li><b>Bestehende Partition:</b> Der <a href="#bsd.rd">RAM-Laufwerk</a> Kernel
kann für ein Upgrade oder eine Neuinstallation von einer bereits existierenden
OpenBSD-Partition geladen werden.

<li><b>Netzwerk:</b> Manche Systeme können über das Netzwerk starten (zum
Beispiel unter Verwendung von <a href="faq6.html#PXE">PXE</a> oder einem
anderen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8"
>Netzwerk-Startprozess</a>).

<li><b>Ein Dateisystemabbild auf Platte schreiben (»miniroot«):</b> Ein
Dateisystemabbild, das auf eine existierende Partition geschrieben und
daraufhin gestartet werden kann.

<li><b>Startfähiges Band:</b> Einige Systeme unterstützen den Systemstart von
einem Bandlaufwerk.
Solche Bänder können erstellt werden, indem man den Instruktionen der Datei
INSTALL.<i>Plattform</i> folgt. 
</ul>

Nicht jede <a href="../../de/plat.html">Plattform</a> unterstützt alle
Startmöglichkeiten:

<ul>
<li><a href="../../de/alpha.html"><b>alpha:</b></a>
Diskette, CD-ROM, Netzwerk, Diskettenabbild auf Festplatte schreiben.

<li><a href="../../de/amd64.html"><b>amd64:</b></a>
Diskette, CD-ROM, <a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../de/armish.html"><b>armish:</b></a>
Je nach Maschine unterschiedlich.

<li><a href="../../de/hp300.html"><b>hp300:</b></a>
CD-ROM, Netzwerk.

<li><a href="../../de/hppa.html"><b>hppa:</b></a>
Netzwerk.

<li><a href="../../de/i386.html"><b>i386:</b></a>
Diskette, CD-ROM, <a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../de/landisk.html"><b>landisk:</b></a>
»miniroot«, das mit Hilfe eines anderen Rechners installiert wurde.

<li><a href="../../de/macppc.html"><b>macppc:</b></a>
CD-ROM, Netzwerk.

<li><a href="../../de/mvme68k.html"><b>mvme68k:</b></a>
Netzwerk, startfähiges Band.

<li><a href="../../de/mvme88k.html"><b>mvme88k:</b></a>
Netzwerk, startfähiges Band.

<li><a href="../../de/sparc.html"><b>sparc:</b></a>
Diskette, CD-ROM, Netzwerk, Schreiben eines Abbildes auf eine existierende
Partition, startfähiges Band.

<li><a href="../../de/sparc64.html"><b>sparc64:</b></a>
Diskette (nur U1/U2), CD-ROM, Netzwerk, Schreiben eines Abbildes auf eine
existierende Partition.

<li><a href="../../de/vax.html"><b>vax:</b></a>
Diskette, Netzwerk.

<li><a href="../../de/zaurus.html"><b>zaurus:</b></a>
Starte bsd.rd von einer Linux-Partition.
Lies <a href="ftp://ftp.openbsd.org/pub/OpenBSD/5.3/zaurus/INSTALL.zaurus"
>INSTALL.zaurus</a> für weitere Details.
</ul>

Alle Plattformen können ebenfalls einen <a href="#bsd.rd">bsd.rd</a> für eine
Neuinstallation oder ein »Upgrade« verwenden.

<p>
Sobald der Installationskernel gestartet ist, gibt es mehrere Möglichkeiten, um
die <a href="#FilesNeeded">Dateisets der Installations</a> zu beziehen.
Wie üblich unterstützt nicht jede Plattform dieselben Optionen.

<ul>
<li><b>CD-ROM:</b> Selbstverständlich bevorzugen wir, dass du das
<a href="../../de/orders.html">offizielle CD-ROM-Set</a> verwendest, aber du
kannst auch <tt>install53.iso</tt> benutzen oder dein Eigenes erstellen.

<li><b>FTP:</b>
Entweder über einen der OpenBSD
<a href="../../de/ftp.html">FTP-Spiegelserver</a>,
oder aber dein eigener lokaler FTP-Server, der die Dateisets vorhält.

<li><b>HTTP:</b>
Entweder über einen der OpenBSD
<a href="../../de/ftp.html#http">HTTP-Spiegelserver</a>,
oder aber dein eigener lokaler Webserver, der die Dateisets vorhält.

<li><b>Lokale Festplattenpartition:</b>
In vielen Fällen kannst du die Dateisets von einer anderen Partition einer
lokalen Festplatte aus installieren.
Um ein Beispiel zu nennen, kannst du auf <a href="../../de/i386.html">i386</a>
von einer FAT-Partition oder einer CD-ROM mit ISO9660-, Rock-Ridge- oder
Joliet-Format aus installieren.
In einigen Fällen musst du das Dateisystem manuell einhängen, bevor du es
verwenden kannst.

<li><b>NFS:</b>
Manche Plattformen unterstützen ein eingehängtes NFS (»Network File System«)
als Quelle für die Dateisets.

<li><b>Band:</b>
Dateisets können ebenfalls von einem unterstützten Bandlaufwerk gelesen werden.
Details darüber, wie ein entsprechendes Band erstellt werden kann, finden sich
im Dokument <tt>INSTALL.</tt><i>Plattform</i>.
</ul>

<a name="Checklist"></a>
<h2>4.2 - Vor der Installation: Checkliste</h2>

<p>
Bevor du mit der eigentlichen Installation beginnst, solltest du dir darüber im
Klaren sein, womit du am Ende dastehen willst.

Zumindest die folgenden Punkte sollten bekannt sein:
<ul>
<li>Der Name der Maschine.
<li>Die eingebaute und verfügbare Hardware.
  <ul>
  <li>Prüfe deren Kompatibilität anhand der Hardware-Kompatibilitätsseite
      deiner Plattform.
  <li>Handelt es sich um ISA-Komponenten, so musst du die nötigen Einstellungen
      kennen und prüfen, ob sie identisch mit den von OpenBSD erwarteten sind.
  </ul>
<li>Die gewünschte Installationsmethode (CD-ROM, FTP etc.).
<li>Sollte ein wichtiger Fehler gefunden werden, wie sollen entsprechende
    Korrekturroutinen in das System eingebracht werden?
  <ul>
  <li>Soll dies lokal geschehen, so muss <a href="#Partitioning">genügend
      freier Speicher</a> für den Quelltextbaum und dessen Übersetzung
      verfügbar sein.
  <li>Anderenfalls muss es Zugang zu einer anderen Maschine geben, um dort ein
      korrigiertes <a href="faq5.html#Release">Release</a> erzeugen zu können.
  </ul>
<li>Die gewünschte Plattenaufteilung.
  <ul>
  <li>Müssen vorhandene Daten irgendwo gesichert werden?
  <li>Soll OpenBSD neben einem anderen Betriebssystem auf dem Rechner
      existieren?
      Wenn ja: Wie sollen die vorhandenen Systeme gestartet werden?
      Wird ein »Bootmanager« benötigt?
  <li>Wird OpenBSD die ganze Festplatte belegen oder möchtest du eine
      existierende Partition/ein existierendes Betriebssystem behalten (oder
      Speicher für zukünftige Solche)?
  <li>Wie willst du den für OpenBSD reservierten Platz
      weiter unterteilen?
  </ul>
<li>Netzwerkeinstellungen, falls DHCP nicht verwendet wird:
  <ul>
  <li>Domänenname.
  <li>DNS-Serveradresse(n) (zur Auflösung von Domänennamen in Adressen).
  <li>IP-Adressen und Subnetzmasken für jede Netzwerkkarte (NIC).
  <li>Gatewayadressen.
  </ul>
<li>Hast du vor, das grafische X Fenstersystem zu benutzen?
</ul>


<a name="MkInsMedia"></a>
<h2>4.3 - Startfähige OpenBSD-Installationsmedien erzeugen</h2>

<p>
Als Beispiele werden wir die Installationsmedien betrachten, die für die
Plattformen <a href="../../de/i386.html">i386</a> und
<a href="../../de/sparc.html">sparc</a> bereitstehen.

<p>
Die <a href="../../de/i386.html">i386</a>-Plattform besitzt sechs
separate Installationslaufwerksabbilder, aus denen gewählt werden kann:

<ul>
<li><b><tt>cd53.iso</tt></b> ist ein ISO9660-Abbild, das für die Erstellung
  einer startfähige CD mit den allermeisten bekannten CD-ROM-Brennprogrammen
  auf den allermeisten Plattformen verwendet werden kann.
  Dieses Abbild hat die größte Treiberauswahl und ist normalerweise
  die empfohlene Wahl, wenn deine Hardware von CD-ROM starten kann.
<li><b><tt>cdemu53.iso</tt></b> ist ein ISO9660-Abbild, das zum Starten
  eine Disketten-Emulation und ein 2,88&nbsp;MB Diskettenabbild benutzt.
  Hoffentlich müssen nur wenige Leute dieses Abbild benutzen - die meisten
  werden <tt>cd53.iso</tt> benutzen.
  Verwende <tt>cdemu53.iso</tt> nur, wenn <tt>cd53.iso</tt> bei dir nicht
  funktioniert.
<li><b><tt>install53.iso</tt></b> ist ein ISO9660-Abbild, das alle
  Standard-Dateisets enthält.
  Es kann verwendet werden, um eine startfähige CD zu erzeugen,
  die eine vollständige OpenBSD-Installation durchführen kann.
<li><b><tt>floppy53.fs</tt></b> (Desktop-PC) unterstützt viele
  PCI- und ISA-Netzwerkkarten, IDE-, SATA- und einfache SCSI-Adapter,
  sowie einige PCMCIA-Karten.
  Die meisten Benutzer werden dieses Abbild verwenden, wenn sie von einer
  Diskette aus starten.
<li><b><tt>floppyB53.fs</tt></b> (Server) unterstützt viele RAID-Controller
  und einige der selteneren SCSI-Adapter.
  Jedoch wurde die Unterstützung für viele Standard-SCSI-Adapter und viele
  EISA- und ISA-Netzwerkkarten entfernt.
<li><b><tt>floppyC53.fs</tt></b> (Laptops) unterstützt viele der
  Cardbus- und PCMCIA-Karten, die man in Laptops findet.
</ul>

<p>
Die <a href="../../de/sparc.html">sparc</a>-Plattform besitzt vier
separate Installations-Laufwerksabbilder, aus denen gewählt werden kann:

<ul>
<li><b><tt>floppy53.fs</tt></b>: Unterstützt Systeme mit Diskettenlaufwerk.
<li><b><tt>cd53.iso</tt></b>: Ein ISO-Abbild, mit dem eine CD erzeugt werden
    kann, um SPARC-Systeme von einer CD-ROM aus starten zu können.
<li><b><tt>miniroot53.fs</tt></b>: Kann auf eine Auslagerungspartition
    geschrieben und daraufhin gestartet werden.
<li><b><tt>install53.iso</tt></b>: ein ISO9660-Abbild, das alle
    Standard-Dateisets enthält.
    Es kann verwendet werden, um eine startfähige CD zu erzeugen, die eine
    vollständige OpenBSD-Installation durchführen kann.
</ul>

Auf modernen Plattformen ist man am Besten beraten, wenn man eines der
startfähige CD-ROM-Abbilder benutzt, da auf einigen der »größeren« Plattformen
(wie etwa amd64, sparc64) eine Menge Treiber und Werkzeuge aus den
Diskettenabbildern entfernt werden mussten, was die Installation schwierig
gestalten kann.
Ältere Plattformen, wie z.&nbsp;B. i386 und sparc, sind jedoch auch weiterhin
sehr gut per Diskette installierbar.

<p>
<a name="MkCD-ROM"></a>
<h3>4.3.1 - Erzeugung einer startfähigen CD-ROM</h3>

<p>
Um eine CD-ROM zu brennen, kannst du eine der Dateien <tt>cd53.iso</tt> und
<tt>install53.iso</tt> verwenden.
Es sei an dieser Stelle dem Leser selbst überlassen, die exakten
Details für die zur Verfügung stehenden Anwendungen herauszufinden.

<p>
In OpenBSD selbst kann eine CD von einem ISO-Abbild mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1"
>cdio(1)</a> erzeugt werden:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cdio tao cd53.iso</b>
</pre></td></tr></table>

<p>
Den meisten CD-Brennern, die für Windows- und Macintosh-Systeme verkauft
werden, ist eine Software beigelegt, die ISO-Abbilder auf »blanke« Medien
brennen kann.
Sollte deiner eine Ausnahme sein, gibt es verschiedene kostenlose Programme,
die diese Aufgabe für dich übernehmen können.

<p>
Andere Unix-ähnliche Systeme benutzen Anwendungen wie
<a href="http://www.cdrkit.org/">cdrkit</a>.

<p>
<a name="MkFlop"></a>
<a name="UnixFlop"></a>
<h3>4.3.2 - Disketten unter Unix erzeugen</h3>

<p>
Präzise Details und Gerätenamen differieren von Unix-Variante zu
Unix-Variante; benutze, was immer für dein System zutrifft.

<p>
Um eine formatierte Diskette zu erzeugen, benutze das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdformat&amp;sektion=1&amp;arch=i386"
>fdformat(1)</a>, das sowohl formatiert, als auch auf schlechte Sektoren
untersucht.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>fdformat /dev/rfd0c</b>
  Format 1440K floppy `/dev/rfd0c'? (y/n): y
  Processing VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV done.
</pre></td></tr></table>

<p>
Ist deine Ausgabe wie im obigen Beispiel, dann ist die Diskette in Ordnung.
Wenn du andererseits nicht ALLE »V«s siehst, dann ist die Diskette
höchstwahrscheinlich fehlerhaft und du solltest eine andere versuchen.

<p>
Um das Abbild auf das Laufwerk zu schreiben, benutze
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=0"
>dd(1)</a>.
Ein Beispiel für <tt>dd(1)</tt>:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>dd if=floppy53.fs of=/dev/rfd0c bs=32k</b>
</pre></td></tr></table>

<p>
Ist das Abbild geschrieben, überprüfe mit Hilfe des Kommandos
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cmp&amp;sektion=1"
>cmp(1)</a>, ob das kopierte Abbild mit dem Original identisch ist.
Wenn die Diskette mit dem Abbild identisch ist, so wirst du keine Ausgabe
erhalten, sondern einfach nur den nächsten Prompt sehen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cmp /dev/rfd0c floppy53.fs</b>
</pre></td></tr></table>

<p>
<a name="DosFlop"></a>
<h3>4.3.3 - Disketten unter Windows erzeugen</h3>

<p>
Um eine Diskette in Windows vorzubereiten, benutze die eingebauten
Formatierungswerkzeuge, um die Diskette zu formatieren, und verifiziere,
dass die Diskette keine schlechten Sektoren hat.

<p>
Um das Installationsabbild auf die vorbereitete Diskette zu schreiben, kannst
du <tt>ntrw.exe</tt> benutzen, das sich im Verzeichnis
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/5.3/tools/">tools</a>
jedes OpenBSD FTP-Spiegelservers findet.

<p>
Ein Beispiel für <i>ntrw</i>:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\&gt; <strong>ntrw floppy53.fs a:</strong>
  3.5", 1.44MB, 512 bytes/sector
  bufsize is 9216
  1474560 bytes written
</pre></td></tr></table>

<p>
<a name="Boot"></a>
<h2>4.4 - Starten eines OpenBSD-Installationsmediums</h2>

<h3>i386/amd64 starten</h3>

Ein Installationsabbild auf den PC-Architekturen i386 und amd64 zu starten
ist nichts Neues für die meisten Leute.
Dein System muss instruiert werden, von welchem Medium es zu starten hat,
was normalerweise durch eine BIOS-Option geschieht.
Wenn du von CD starten willst, so muss das System-BIOS dazu imstande sein
und so konfiguriert werden, dass es von CD startet.
Einige ältere Systeme besitzen diese Option nicht, sodass eine Diskette benutzt
werden muss, um das Installationsabbild zu starten.
Dies ist jedoch kein Grund, beunruhigt zu sein; selbst wenn du von Diskette
startest, kannst du immer noch von der CD installieren, wenn das CD-Laufwerk
von OpenBSD unterstützt wird (d.&nbsp;h. praktisch alle IDE-Laufwerke).

<p>
Du kannst ebenfalls installieren, indem du <a href="#bsd.rd">bsd.rd</a>
von einer existierenden OpenBSD-Partition oder unter Verwendung des
<a href="faq6.html#PXE">PXE-Startprozesses</a> über das Netzwerk startest.

<h3>sparc/sparc64 starten</h3>

<b>HINWEIS:</b>
Auf der <a href="../../de/sparc64.html">sparc64</a>-Plattform können nur
die SBus-Maschinen (Ultra 1, Ultra 2) von einer Diskette gestartet werden.

<p>
Das System muss sich an einem Monitor-ROM-Prompt befinden, der typischerweise
so aussieht: »<tt>ok </tt>«.
Benutzt du eine Sun-Tastatur, drücke und halte »STOP« während du »A« drückst.
Wenn du eine serielle Konsole benutzt, sollte dich ein »BREAK« zum
Monitor-Prompt zurückbringen.

<p>
Benutze das folgende Kommando, um von Diskette zu starten:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot floppy</b>
</pre></td></tr></table>

<p>
Normalerweise kannst du vom CD-ROM-Laufwerk eines Sun-Systems vom »Boot«-Prompt
aus starten, indem du »<tt>boot cdrom</tt>« eingibst:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot cdrom</b>
</pre></td></tr></table>

<p>
<a name="Install"></a>
<h2>4.5 - Eine einfache Installation durchführen</h2>

OpenBSDs neuer Installationsprozess ist so konzipiert, dass er OpenBSD mit sehr
wenig Benutzerinteraktion zu einer schon sehr benutzbaren Umgebung installiert
und konfiguriert.
Tatsächlich genügt es oft, einfach nur einige Male <i>ENTER</i> zu drücken, um
eine sehr gute OpenBSD-Installation zu erhalten, sodass du deine Hand
eigentlich nur zur Eingabe des »root«-Passworts auf andere Regionen der
Tastatur bewegen musst.

<p>
Das Installationsprogramm wird ein Partitionsschema basierend auf der Größe
deiner Festplatte erstellen.
Obwohl dies KEINE perfekte Einteilung für alle ist und sein kann, so bietet es
doch einen guten Ansatzpunkt und eine gute grundlegende Strategie, um
herauszufinden, was du benötigst.

<p>
Wir starten mit einer sehr einfachen Installation, mit kurzen Beschreibungen
der gezeigten Optionen und benutzen die Magie von Hypertext-Verweisen, um es
dir zu ermöglichen, mehr über die Themen zu lesen, die dich interessieren, und
deine Möglichkeiten herauszufinden.

<p>
Plattformspezifische Anmerkungen zur Installation finden sich auf den
Installations-CDs und FTP-Servern in den Dateien
<tt>INSTALL.<i>&lt;plat&gt;</i></tt>, wobei <i>&lt;plat&gt;</i> durch deine
<a href="../../de/plat.html">Plattform</a> ersetzt werden muss, z.&nbsp;B.
<tt>i386</tt>.

<p>
<a name="InstStart"></a>
<h3>4.5.1 - Mit der Installation beginnen</h3>
Was auch immer für eine Startmethode gewählt wurde - nun ist es an der Zeit,
sie zu benutzen.
Während des Startens werden der Kernel und alle für die OpenBSD-Installation
nötigen Programme in den Hauptspeicher geladen.
Ist der Installationskernel erst einmal geladen, wird daher das Startmedium
nicht länger benötigt, da sich alle Dateien im RAM-Laufwerk befinden.
Deshalb kann die CD oder Diskette, von der gestartet wurde, an diesem Punkt aus
ihrem Laufwerk entfernt werden; vorausgesetzt, sie wird nicht mehr als Quelle
für zu installierende Dateisets gebraucht.

<p>
Der OpenBSD-Installationsprozess kann an praktisch jeder Stelle durch
Drücken von STRG-C abgebrochen und durch den am Shell-Prompt einzugebenden
Befehl <tt>install</tt> ohne Neustart von vorne begonnen werden.
Außerdem ist es während eines Großteils der Installation möglich, durch die
Eingabe von »!« einen Shell-Prompt zu bekommen; ein Beenden dieses
Shell-Prozesses führt automatisch zur Installation zurück.

<p>
Bei einem erfolgreichen Startvorgang wirst du eine Menge Textmeldungen
vorbeiziehen sehen.
Dieser Text (auf vielen Plattformen in weißer Schrift auf blauem Hintergrund)
ist die sogenannte
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8"
>dmesg</a>«, in der der Kernel über gefundene Geräte, und wie diese Geräte mit
anderen Geräten verknüpft sind, Auskunft gibt.
Eine Kopie dieser Meldungen wird in der Datei <tt>/var/run/dmesg.boot</tt>
gespeichert.

<p>
Dann wirst du Folgendes sehen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ...
  root on rd0a swap on rd0b dump on rd0b
  erase ^?, werase ^W, kill ^U, intr ^C, status ^T

  Welcome to the OpenBSD/i386 5.3 installation program.
  (I)nstall, (U)pgrade or (S)hell? <b>i</b>
</pre></td></tr></table>

<p>
Und damit erreichen wir auch schon die erste Frage.
Du bekommst drei Möglichkeiten angeboten:

<ul>
<li><b>Install</b>: installiert OpenBSD auf dem System und überschreibt dabei
alles, was vielleicht vorher dort war.
Es ist anzumerken, dass es möglich ist, einige Partitionen während dieses
Prozesses unberührt zu lassen, z.&nbsp;B. <tt>/home</tt>, aber abgesehen davon
sollte davon ausgegangen werden, dass alles überschrieben wird.

<li><b>Upgrade</b>: installiert neue
<a href="#FilesNeeded">Installations-Dateisets</a>
auf dieser Maschine, aber überschreibt keine Konfigurationsinformationen,
Benutzerdaten oder zusätzlich installierte Programme.
Weder werden Laufwerke formatiert, noch werden die Verzeichnisse <tt>/etc</tt>
oder <tt>/var</tt> überschrieben.
Einige wichtige Informationen:

<ul>
<li>Es wird keine Möglichkeit angeboten, <tt>etc53.tgz</tt> zu installieren.
Nach der Installation müssen daher alle Änderungen
<a href="../upgrade53.html#etcUpdates"
>von Hand in das System eingebunden werden</a>, die <tt>etc53.tgz</tt>
beinhaltet, bevor das System voll funktionsfähig ist.
Dies ist ein sehr wichtiger Schritt, der getan werden muss, da sonst einige
Schlüsseldienste (wie beispielsweise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4"
>pf(4)</a>), möglicherweise nicht starten werden.

<li>Der Upgrade-Prozess ist nicht dafür konzipiert, ganze Releases zu
überspringen!
Obwohl das meist funktioniert, wird es in keinem Fall unterstützt.
Für OpenBSD 5.3 gilt, dass das Upgrade von 5.2 auf 5.3 das einzige unterstützte
Upgrade ist.
Soll von einem älteren Release aus aktualisiert werden, so aktualisiere erst
auf die dazwischen liegenden Versionen; oder aber, sollte dein System sehr alt
sein, so ziehe eine vollständige Neuinstallation in Erwägung.
</ul>

<!-- XXXversion -->
<li>Weitere Informationen zum Upgraden zwischen einzelnen Releases können
in der <a href="../upgrade53.html">Upgrade-Anleitung für OpenBSD 5.3</a>
gefunden werden.

<li><b>Shell</b>: Manchmal ist es notwendig, Teile des Systems zu reparieren
oder Wartungsarbeiten für ein System durchzuführen, das einen normalen Kernel
nicht starten kann (oder soll).
Diese Option erlaubt die Durchführung der Wartungsarbeiten.
Dazu finden sich einige wichtige Werkzeuge auf dem Startmedium.
</ul>

Wir nehmen im Folgenden an, dass du »(I)nstall« auswählst.

<p>
<a name="InstQuestions"></a>
<h3>4.5.2 - Die Fragen der Installation</h3>

Nun beginnen die Fragen, die definieren, wie das System konfiguriert wird.
Du wirst bemerken, dass in den meisten Fällen erst die Fragen gestellt werden,
woraufhin dann im Anschluss die Installation stattfindet.
Auf diese Weise kannst du bei einem langsamen Computer oder einer langsamen
Internetverbindung zuerst Fragen beantworten, dann das System in Ruhe arbeiten
lassen, und brauchst später nur noch neu zu starten, um die Installation
abzuschließen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  At any prompt except password prompts you can escape to a shell by
  typing '!'. Default answers are shown in []'s and are selected by
  pressing RETURN.  You can exit this program at any time by pressing
  Control-C, but this can leave your system in an inconsistent state.

  Choose your keyboard layout ('?' or 'L' for list) [default] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
In den meisten Fällen wird die vorgewählte Tastaturbelegung (oder der
Terminaltyp, sollte die Installation über eine serielle Konsole erfolgen) die
Richtige sein; es sollte jedoch nicht einfach der Standard genommen werden,
antworte angemessen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  System hostname? (short form, e.g. 'foo') <i><b>puffy</b></i>
</pre></td></tr></table>

<p>
Dieser Wert wird, gemeinsam mit dem DNS-Domänennamen (der
<a href="#MoreNetwork">weiter unten</a> definiert wird), in der Datei
<tt>/etc/myname</tt> gespeichert, welche während eines normalen Startvorgangs
dazu benutzt wird, den Hostnamen des Systems zu setzen.
Wird der Domänenname des Systems nicht gesetzt, so wird stattdessen der
Standardwert »my.domain« benutzt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available network interfaces are: fxp0 vlan0.
  Which one do you wish to configure? (or 'done') [fxp0] <i><b>Enter</b></i>
</pre></td></tr></table>

<p>
<tt>vlan0</tt> ist die virtuelle VLAN-Schnittstelle.
Für unsere Zwecke hier haben wir diese Option ignoriert und uns stattdessen an
die physisch vorhandenen Schnittstellen gehalten.
Wenn der Rechner mehrere physikalische Schnittstellen besitzt, so sollten sie
hier aufgelistet sein.
Wie zu sehen ist, werden sie über ihren Gerätetreiber identifiziert und tauchen
nicht als generische Ethernetgeräte auf.
In unserem Fall meint »<tt>fxp0</tt>« also das erste Gerät, das den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"
>fxp(4)</a>-Treiber benutzt; <tt>fxp1</tt> wäre das zweite Gerät etc.&nbsp;...
Mehr zum Thema Gerätenamen findet sich in
<a href="faq6.html#Setup.if">FAQ 6</a>.

<p>
Nachdem das zu konfigurierende Gerät ausgewählt wurde, wirst du es jetzt
konfigurieren.
In vielen Fällen wirst du es über DHCP automatisch konfigurieren wollen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IPv4 address for fxp0? (or 'dhcp' or 'none') [dhcp] <b><i>Enter</i></b>
  Issuing hostname-associated DHCP request for fxp0.
  DHCPDISCOVER on fxp0 to 255.255.255.255 port 67 interval 1
  DHCPOFFER from 192.168.1.250 (08:00:20:94:0b:c8)
  DHCPREQUEST on fxp0 to 255.255.255.255 port 67
  DHCPACK from 192.168.1.250 (08:00:20:94:0b:c8)
  bound to 192.168.1.199 -- renewal in 43200 seconds.
</pre></td></tr></table>

<p>
DHCP wird die IP-Adresse, die Subnetzmaske, den Standardzugang,
den DNS-Domänennamen und die DNS-Server automatisch konfigurieren.
Wenn DHCP nicht benutzt wird, so müssen alle genannten Dinge
von Hand eingegeben werden; siehe auch die detailliertere Diskussion
<a href="#MoreNetwork">weiter unten</a>.
<a name="backMoreNetwork"></a>

<p>
Sollte es nötig sein, IPv6 oder andere Geräte zu konfigurieren (oder dir deine
vorherige Konfiguration nicht mehr gefallen), so kannst du dies nun tun.
In unserem Fall sind wir aber fertig:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IPv6 address for fxp0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
  Available network interfaces are: fxp0 vlan0.
  Which one do you wish to configure? (or 'done') [done] <b><i>Enter</i></b>
  Using DNS domainname example.org
  Using DNS nameservers at 192.168.1.252
</pre></td></tr></table>

<p>
Nun setzen wir das Passwort für das Benutzerkonto root:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Password for root account? (will not echo) <i>PaSsWoRd</i>
  Password for root account? (again) <i>PaSsWoRd</i>
</pre></td></tr></table>

<p>
Benutze ein sicheres Passwort für das Benutzerkonto root.
Bedenke: im Internet TRACHTEN SIE danach, in deinen Computer zu gelangen -
und sie werden eine ganze Menge häufig benutzter Passwörter ausprobieren, von
denen man denkt, dass sie wirklich clever seien.

<p>
Später wird es noch die Möglichkeit geben, ein Administrations-Benutzerkonto zu
erzeugen, und den Zugang von entfernten Rechnern (Remotezugang via SSH) für das
Benutzerkonto root auszuschalten, aber nichtsdestotrotz ist ein gutes Passwort
für das Benutzerkonto root sehr wichtig.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start sshd(8) by default? [yes] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Üblicherweise will man den sshd(8) laufen haben.
Sollte dein Anwendungsgebiet jedoch keinen Bedarf für ihn haben, so ergibt sich
ein kleiner theoretischer Sicherheitsgewinn dadurch, ihn nicht zu benutzen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start ntpd(8) by default? [no] <b>y</b>
  NTP server? (hostname or 'default') [default] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Hier wird die Möglichkeit geboten, den
<a href="faq6.html#OpenNTPD">OpenNTPD</a>, OpenBSDs NTP-Implementierung, laufen
zu lassen.
OpenNTPD braucht wenig Ressourcen und ist ein problemloser Weg, die eingebaute
Uhr des Rechners akkurat zu synchronisieren.
Die Standardkonfiguration nutzt
<a href="http://www.pool.ntp.org">pool.ntp.org</a> und bindet damit eine große
Anzahl frei zugänglicher und über die ganze Welt verstreuter Zeitserver ein.

<p>
Ein Grund, warum man den ntpd(8) NICHT benutzen will, kann sein, dass man ein
»<a href="#Multibooting">Multiboot</a>«-System benutzt, auf dem meistens ein
anderes System läuft, welches seine Uhr nicht mit einer auf GMT-Zeit
eingestellten Hardwareuhr abstimmen kann, da man schwerlich möchte, dass
OpenBSD die Uhr des anderen Betriebssystems verstellt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you expect to run the X Window System? [yes] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Nicht alle Plattformen werden nach X fragen, und die, die es tun, verlangen das
Setzen eines sysctl, um X benutzbar zu machen.
Antwortet man hier mit »y«, so wird die Datei <tt>/etc/sysctl.conf</tt> derart
modifiziert, dass sich, abhängig von der Plattform, entweder
<tt>machdep.allowaperture=1</tt> oder <tt>machdep.allowaperture=2</tt> darin
findet.

<p>
Wenn du nicht vorhast, X auf deinem System laufen zu lassen, oder dir darüber
nicht sicher bist, so antworte einfach »N«, denn es ist später durch einfaches
Editieren von <tt>/etc/sysctl.conf</tt>, gefolgt von einem Neustart, möglich,
das Verhalten entsprechend zu ändern.
Es liegt ein potenzieller Sicherheitsvorteil darin, den »aperture«-Treiber
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xf86&amp;sektion=4"
>xf86(4)</a> nicht zu benutzen, da die Maschinerie einer Grafikkarte potentiell
dazu benutzt werden kann, Speicherbereiche ohne Kontrolle des Prozessors zu
verändern.
Es ist anzumerken, dass nicht-grafische Programme, die X-Bibliotheken und
-Werkzeuge benutzen, das Setzen dieses sysctls NICHT benötigen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want the X Window System to be started by xdm(1)? [no] <b>y</b>
</pre></td></tr></table>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdm&amp;sektion=1"
>xdm(1)</a> startet die X-Umgebung während des Systemstarts.
Wir empfehlen dies nur dann während der Installation zu setzen, wenn man sich
gewiss ist, dass X auf dem System direkt und ohne Anpassungen laufen wird.
Anderenfalls sollte man <a href="faq11.html">X konfigurieren</a>, bevor man
xdm(1) benutzt.

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Change the default console to com0? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

Manchmal möchte man, dass ein System eine serielle Schnittstelle anstatt einer
Tastatur mit Monitor als Konsole nutzt.
Hier mit »y« zu antworten wird die Installation veranlassen, dich nach einer
seriellen Bitrate zu fragen und das System für die Nutzung der seriellen
Schnittstelle als Konsole zu konfigurieren, anstatt Monitor und Tastatur dafür
zu nutzen.
Einige Plattformen machen dies automatisch wenn keine Tastatur vorhanden ist,
in welchem Fall diese Frage nicht gestellt wird.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Setup a user? (enter a lower-case loginname, or 'no') [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Es wird dir die Möglichkeit geboten, einen Benutzer für die Systemwartung zu
erzeugen, der NICHT root ist.
Dieser Benutzer wird Mitglied der Gruppe wheel und kann daher sowohl
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1"
>su(1)</a> benutzen als auch als Empfänger für an root adressierte E-Mails
eingesetzt werden.
Du wirst nach einem Passwort gefragt.

<p>
Wenn du diesen Benutzer erzeugen willst, so gib den gewünschten Namen des
Nutzers ein und nicht »y« oder »yes«.

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
What timezone are you in? ('?' for list) [Canada/Mountain] <b>US/Michigan</b>
</pre></td></tr></table>

<p>
OpenBSD erwartet, dass die Echtzeituhr (»Real-Time-Clock«, RTC) des Rechners
auf GMT-Zeit eingestellt ist.
Du musst aber außerdem die Zeitzone angeben, in der du dich befindest.
Es kann mehrere gültige Antworten für deinen physischen Aufenthaltsort geben.
Die Eingabe von »?« am gezeigten Prompt sollte dir Assistenz zum Auffinden des
richtigen Zeitzonennamens geben.

<p>
Sehr oft wird das Installationsprogramm einfach den korrekten Namen für deine
Zeitzone erraten, sodass du nur »Enter« zu drücken brauchst.

<p>
Mehr über das Setzen der Zeitzone <a href="#MoreTimeZone">findet sich hier</a>.
<a name="backMoreTimeZone"></a>

<a name="InstDisks"></a>
<h3>4.5.3 - Laufwerke einrichten</h3>

<i><b>Wichtiger Hinweis:</b>
Benutzer mit einer großen Festplatte (größer als das, was normal war, als der
Rechner hergestellt wurde) sollten sich unbedingt
<a href="faq14.html#LargeDrive">diese Sektion</a> anschauen, bevor sie
weiterlesen.</i>

<p>
Die passende Unterteilung für das Laufwerk zu finden, ist vielleicht der
schwierigste Teil einer OpenBSD-Installation.
Die gute Nachricht ist, dass das Standardlayout gut genug zum Erlernen von
OpenBSD ist.

<p>
Die Einrichtung von Laufwerken unter OpenBSD variiert ein wenig zwischen den
Plattformen.
Für <a href="../../de/i386.html">i386</a>,
<a href="../../de/amd64.html">amd64</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/zaurus.html">zaurus</a>
und <a href="../../de/armish.html">armish</a> geschieht es in zwei Ebenen.
Zuerst wird der Abschnitt (»slice«) der Festplatte, der OpenBSD beherbergen
soll, mit fdisk(8) festgelegt, woraufhin dann dieser »slice« mit Hilfe von
disklabel(8) in OpenBSD-Partitionen aufgeteilt wird.

<p>
Einige Benutzer mögen ein wenig verwundert oder gar ein bisschen verwirrt über
die verwendete Terminologie sein.
Es sieht aus, als ob wir das Wort »Partition« auf zwei verschiedene Art und
Weisen benutzen.
Diese Beobachtung ist korrekt.
Es gibt zwei Schichten der Partitionierung auf den oben genannten
Plattformen; die erste, die man als die Betriebssystem-Partitionierung
bezeichnen könnte, beschreibt, wie verschiedene Betriebssysteme auf einem
Computer den ihnen zugewiesenen Bereich der Festplatte als für sich reserviert
ausweisen, während die zweite beschreibt, wie die OpenBSD-Partition in einzelne
Dateisysteme unterteilt ist.
Die erstgenannte Schicht ist als Festplattenpartition für DOS, Windows und
jedes andere Betriebssystem sichtbar, das dieses
Festplatten-Partitionierungssystem benutzt, währenddessen die zweite Schicht
nur für OpenBSD und andere Betriebssysteme, die direkt ein OpenBSD-Dateisystem
lesen können, sichtbar ist.

<p>
Das neue Installationsprogramm von OpenBSD versucht, die Einrichtung von
Laufwerken einfacher zu machen, indem es eine akzeptable Standardeinteilung für
die »durchschnittliche« Nutzung anbietet.
Sicher werden viele Leute diesen Standard für ihre eigenen Bedürfnisse anpassen
oder ihre komplett eigene Laufwerksbelegung definieren wollen, aber neue
Benutzer sollten vielleicht mit der Standardkonfiguration starten, bis sie
wissen, was sie anders machen müssen.
Zu bemerken ist, dass die Standardkonfiguration abhängig von der Größe des
Dateisystems ist.

<p>
Fürs erste nehmen wir die Voreinstellung für unsere 40&nbsp;G Platte.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available disks are: wd0.
  Which one is the root disk? (or 'done') [wd0] <i><b>Enter</b></i>
  Use DUIDs rather than device names in fstab? [yes] <i><b>Enter</b></i>
  Disk: wd0       geometry: 5221/255/63 [40960 Megabytes]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 06      0   1   1 -    521 254  63 [          63:     8385867 ] DOS > 32MB
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Use (W)hole disk or (E)dit the MBR? [whole] <i><b>Enter</b></i>
  Setting OpenBSD MBR partition to whole wd0...done.
</pre></td></tr></table>

<p>
Es ist zu erwähnen, dass diese Festplatte eine bereits existierende Partition
besitzt - <i>das Auswählen von »whole disk« würde sie entfernen!</i>

<p>
Das Auswählen von »whole disk«, und damit die Zuweisung des gesamten Laufwerks
für OpenBSD, initiiert eine Reihe wichtiger Dinge:
<ul>
<li>Alle bereits existierenden Partitionen des Laufwerks werden gelöscht.
<li>Einen MBR (»Master-Boot-Record«) und eine Laufwerkssignatur werden erzeugt,
    sodass von dem Laufwerk gestartet werden kann (»boot«).
<li>Eine OpenBSD-Partition wird erzeugt, die das komplette Laufwerk einnimmt.
<li>Diese Partition wird »aktiv« markiert.
</ul>

Es gibt eine Reihe von Gründen, warum dies nicht gewünscht sein könnte,
einschließlich:
<ul>
<li>Du möchtest die Partitionen anderer Betriebssysteme erhalten.
<li>Du möchtest »Setup«, »Suspend to Disk«, oder andere Systempartitionen
    behalten.
<li>Du möchtest ein »<a href="#Multibooting">Multiboot</a>«-System erzeugen.
</ul>

Es ist äußerst wichtig, dass ein neues Laufwerk (oder eines, von dem noch nie
gestartet wurde) einen gültigen MBR, eine gültige Signatur, eine
OpenBSD-Partition, sowie eine als »aktiv« markierte Partition besitzt.
Durch Anwählen der »whole disk«-Option werden diese Schritte vom
Installationsprogramm automatisch durchgeführt; anderenfalls muss
sichergestellt sein, dass sie manuell durchgeführt werden.

<p>
Mehr Informationen über die fdisk-Partitionierung deines Laufwerks finden sich
<a href="#Morefdisk">weiter unten</a>.
<a name="BackMorefdisk"></a>

<p>
Jetzt werden wir unsere OpenBSD fdisk-Partition in
OpenBSD-Laufwerkspartitionen mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a> unterteilen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Setting OpenBSD MBR partition to whole wd0...done.
  The auto-allocated layout for wd0 is:
  #                size           offset  fstype [fsize bsize  cpg]
    a:          1024.0M               64  4.2BSD   2048 16384    1 # /
    b:           199.0M          2097216    swap                   
    c:         40960.0M                0  unused                   
    d:          2822.9M          2504768  4.2BSD   2048 16384    1 # /tmp
    e:          4295.0M          8286112  4.2BSD   2048 16384    1 # /var
    f:          2048.0M         17082240  4.2BSD   2048 16384    1 # /usr
    g:          1024.0M         21276544  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          5426.7M         23373696  4.2BSD   2048 16384    1 # /usr/local
    i:          1699.7M         34487520  4.2BSD   2048 16384    1 # /usr/src
    j:          2048.0M         37968576  4.2BSD   2048 16384    1 # /usr/obj
    k:         20367.4M         42162880  4.2BSD   2048 16384    1 # /home
  Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout? [a] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Das Installationsprogramm hat uns seinen Vorschlag einer »Automatischen
Einteilung« für die OpenBSD-Partitionen auf dem Laufwerk präsentiert, was wir
in dieser Form akzeptieren werden.

<p>
Sollte die vorgeschlagene Einteilung für deine Zwecke nicht angemessen sein,
ist es selbstverständlich möglich, den Vorschlag zu bearbeiten oder gar eine
komplett eigene Einteilung zu kreieren; mehr Details über die
disklabel-Partitionierung finden sich
<a href="#Moredisklabel">weiter unten</a>.
<a name="BackMoredisklabel"></a>

<p>
<b>ANMERKUNG für Wieder-Installierer:</b>
Das neue Installationsprogramm löscht nicht das alte disklabel,
wenn »(C)ustom Layout« ausgewählt wurde; stattdessen muss jeder Einhängepunkt
mit Hilfe der disklabel(8)-Option »m« neu spezifiziert werden.

<p>
Nun erzeugt das Installationsprogramm die Partitionen, kreiert darauf
Dateisysteme mit Hilfe des Programms
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8"
>newfs(8)</a> und hängt sie danach für die Installation ein (es »mount«et sie):

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  /dev/rwd0a: 1024.0MB in 2097152 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0k: 20367.4MB in 41712448 sectors of 512 bytes
  101 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0d: 2822.9MB in 5781344 sectors of 512 bytes
  14 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0f: 2048.0MB in 4194304 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0g: 1024.0MB in 2097152 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0h: 5426.7MB in 11113824 sectors of 512 bytes
  27 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0j: 2048.0MB in 4194304 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0i: 1699.7MB in 3481056 sectors of 512 bytes
  9 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0e: 4295.0MB in 8796128 sectors of 512 bytes
  22 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local)
  /dev/wd0k on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0d on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0f on /mnt/usr type ffs (rw, asynchronous, local, nodev)
  /dev/wd0g on /mnt/usr/X11R6 type ffs (rw, asynchronous, local, nodev)
  /dev/wd0h on /mnt/usr/local type ffs (rw, asynchronous, local, nodev)
  /dev/wd0j on /mnt/usr/obj type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0i on /mnt/usr/src type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0e on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid)</pre>
</td></tr></table>

<p>
Du wirst bemerkt haben, dass es so aussieht, als ob wir die Partition <i>c</i>
ignoriert hätten.
Diese Partition identifiziert das gesamte Laufwerk; versuche nicht, sie zu
verändern.

<p>
<a name="InstMedia"></a>
<h3>4.5.4 - Auswahl des Installationsmediums und der Dateisets</h3>

Als Nächstes steht die Auswahl des Installationsmediums an.
In diesem Fall installieren wir von einem FTP-Server.
<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Location of sets? (cd disk ftp http or 'done') [cd] <b>ftp</b>
  HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none') [none] <b><i>Enter</i></b>
  Server? (hostname, list#, 'done' or '?') [ftp5.usa.openbsd.org] <b>mirror.example.org</b>
</pre></td></tr></table>

<p>
Solltest du dich nicht an die Adresse deines favorisierten (oder jedweden)
Spiegelservers erinnern können, wird das Installationsprogramm meistens in der
Lage sein, dir einen funktionierenden Spiegelserver vorzuschlagen.
Anderenfalls drücke »?«, um dir eine Liste von Spiegelservern aufzeigen zu
lassen, und wähle die Nummer dessen aus, der dir am meisten zusagt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Server directory? [pub/OpenBSD/5.3/i386] <b><i>Enter</i></b>
  Login? [anonymous] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Die öffentlichen FTP-Spiegelserver unterstützen natürlich alle das anonyme
Herunterladen von Dateien, aber da du eine lokale Maschine haben könntest, die
nach Login und Passwort verlangt, besteht die Möglichkeit zur Eingabe dieser
Werte.

<p>
Nun kann die Liste der <a href="#FilesNeeded">Dateisets</a> angepasst werden.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Select sets by entering a set name, a file name pattern or 'all'. De-select
  sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
  sets are labelled '[X]'.
      [X] bsd           [X] etc53.tgz     [X] xbase53.tgz   [X] xserv53.tgz
      [X] bsd.rd        [X] comp53.tgz    [X] xetc53.tgz
      [ ] bsd.mp        [X] man53.tgz     [X] xshare53.tgz
      [X] base53.tgz    [X] game53.tgz    [X] xfont53.tgz
  Set name(s)? (or 'abort' or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table>


<p>
Als absolutes Minimum wird ein Kernel (<tt>bsd</tt>) benötigt, sowie die
Dateisets base53.tgz und etc53.tgz.
Solange du nicht genau weißt, was du tust, solltest du vielleicht einfach bei
der Standardauswahl bleiben.
Dateisets können durch das Voranstellen der Zeichen »+« und »-« an- und
abgewählt werden; aber auch die Benutzung von Wildcards ist möglich:
<ul>
<li><tt><b>-comp53.tgz</b></tt> entfernt <tt>comp53.tgz</tt>
<li><tt><b>+bsd.mp</b></tt> fügt bsd.mp hinzu
<li><tt><b>-x*</b></tt> entfernt alle X Komponenten
</ul>

Wir entscheiden uns auch hier für die Voreinstellung.
Diese Maschine ist ein Einprozessorsystem, sodass bsd.mp nicht installiert
wird, alles andere jedoch schon.
Wenn die Maschine später zu einem Mehrfachprozessorsystem ausgebaut werden
könnte, so kann es sein, dass du zusätzlich bsd.mp installieren willst.

<p>
Und nun&nbsp;... starten wir unsere Installation!
Dies ist der Punkt, an dem du als Besitzer eines langsamen Computers oder einer
langsamen Internetverbindung vielleicht gehen und später wiederkommen
möchtest; mit einem schnellen Computer und lokal vorhandenen Dateisets mag
diese Prozedur jedoch nur einige Minuten oder auch noch weniger dauern!

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  bsd          100% |*************************************|  8939 KB    00:05
  bsd.rd       100% |*************************************|  6334 KB    00:03
  base53.tgz   100% |*************************************| 55752 KB    00:26
  etc53.tgz    100% |*************************************|   511 KB    00:00
  comp53.tgz   100% |*************************************| 44757 KB    00:28
  man53.tgz    100% |*************************************|  9510 KB    00:06
  game53.tgz   100% |*************************************|  2567 KB    00:02
  xbase53.tgz  100% |*************************************|  9974 KB    00:06
  xetc53.tgz   100% |*************************************| 63695       00:00
  xshare53.tgz 100% |*************************************|  4235 KB    00:04
  xfont53.tgz  100% |*************************************| 38868 KB    00:17
  xserv53.tgz  100% |*************************************| 26388 KB    00:15
  Location of sets? (cd disk ftp http or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Ja, es fragt uns erneut, aus welchen Quellen wir Dateisets beziehen wollen.
Dies geschieht, damit fehlende oder vergessene Dateisets, oder solche, deren
Installation fehlgeschlagen ist, erneut installiert werden können, und
außerdem, um die Installation von
<a href="#site">selbst angepassten Dateisets</a> zu ermöglichen.

<p>
Erneut wählen wir die Voreinstellung, denn wir habe alle benötigten Dateien
installiert.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Saving configuration files...done.
  Generating initial host.random file...done.

  CONGRATULATIONS! Your OpenBSD install has been successfully completed!
  To boot the new system, enter 'reboot' at the command prompt.
  When you login to your new system the first time, please read your mail
  using the 'mail' command.

  #
</pre></td></tr></table>

<p>
<a name="Inst1stBoot"></a>
<h3>4.5.5 - Der erste Start!</h3>
OpenBSD ist jetzt auf deinem System installiert und bereit für den ersten
Start, aber vorher&nbsp;...

<p>
<h4>Vor dem Neustart</h4>
An diesem Punkt ist dein System installiert und bereit, neu gestartet und
für den Dienst konfiguriert zu werden.
Bevor dies getan wird, wäre es jedoch ratsam, auf der
<a href="../../errata53.html">Errataseite</a> nachzuschauen,
ob nicht wie auch immer geartete Fehler bekannt sind, die dein System direkt
betreffen könnten.

<h4>Nach dem Neustart</h4>

Während des ersten Starts werden Schlüssel für
<a href="http://www.openssh.com">SSH</a> generiert.
Auf modernen Computern benötigt dieser Prozess nur wenige Sekunden,
und es mag nicht einmal auffallen, dass er abläuft.
Auf älteren Systemen kann er jedoch viele Minuten benötigen, und potenziell ist
eine Stunde und mehr auf wirklich langsamen Systemen nicht unmöglich.

<p>
Eines der ersten Dinge, die nach der Installation des Systems gelesen werden
sollten, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=afterboot&amp;sektion=8"
>afterboot(8)</a>.

<p>
Du könntest auch die folgenden Links nützlich finden:
<ul>
<li><a href="faq10.html#AddDelUser">Benutzerkonten in OpenBSD erzeugen</a>
<li><a href="faq6.html#Setup">Erste Netzwerkkonfiguration</a>
<li><a href="faq2.html#ManPages">Handbuchseiten
von populären/nützlichen Kommandos</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD-Handbuchseiten
im Web</a>
<li><a href="faq15.html">OpenBSDs Paket- und Portierungssystem zur
Installation von Software</a>
</ul>

<a name="InstFinish"></a>
<h3>4.5.6 - Eine letzte Sache&nbsp;...</h3>

Die OpenBSD-Entwickler bitten dich darum,
<a href="#SendDmesg">eine Kopie deiner »dmesg« einzuschicken</a>.
Dies wird von den Entwicklern wirklich sehr geschätzt und, letztendlich, von
allen Benutzern.

<p>
<a name="More"></a>
<h2>4.6 - Details für eine komplexere Installation</h2>
Manchmal kann man einfach nicht die Standardvorgaben benutzen.
Hier sind ein paar mehr Details zu einigen Aspekten des Installationsprozesses.

<p>
<a name="MoreNetwork"></a>
<h3>4.6.1 - Einrichtung des Netzwerks</h3>

Ist kein DHCP-Server verfügbar, so muss man seine Netzwerkschnittstellen
manuell einrichten.
Hier ist ein Beispiel:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Which one do you wish to configure? (or 'done') [xl0] <b><i>Enter</i></b>
  IPv4 address for xl0? (or 'dhcp' or 'none') [dhcp] <b>192.168.1.37</b>
  Netmask? [255.255.255.0] 255.255.254.0
  IPv6 address for xl0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Nach diesen Fragen bekommt man die Möglichkeit, die anderen
Netzwerkschnittstellen der Maschine zu konfigurieren.
Spezifizierst du hier eine andere Schnittstelle, so wiederholen sich obige
Fragen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available network interfaces are: xl0 vlan0.
  Which one do you wish to configure? (or 'done') [done]
</pre></td></tr></table>

<p>
Jetzt richten wir den Standardzugang und DNS-Server ein;
Dinge, die alle Netzwerkschnittstellen betreffen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Default IPv4 route? (IPv4 address, 'dhcp' or 'none') <b>192.168.1.1</b>
  add net default: gateway 192.168.1.1
  DNS domain name? (e.g. 'bar.com') [my.domain] <b>example.org</b>
  DNS nameservers? (IP address list or 'none') [none] <b>192.168.1.250 192.168.1.251</b>
</pre></td></tr></table>

<p>
Es ist hier möglich, mehrere durch Leerzeichen getrennte DNS-Server anzugeben.

<p>
Manchmal wird man etwas darüber hinaus zu tun haben, zum Beispiel die
Einrichtung eines drahtlosen Zugangsschlüssels, oder aber die Festlegung von
Duplex- oder Geschwindigkeitsangaben (was man nicht machen sollte, wenn es
nicht ABSOLUT NÖTIG ist, da das Anpassen der Switch-Konfiguration eine viel
bessere Idee ist!).
Es wird nun die Möglichkeit geboten, zu einer Shell zu gelangen, wo man jedwede
manuelle Konfiguration durchführen kann.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want to do any manual network configuration? [no] <b>y</b>
  Type 'exit' to return to install.
  # <b>ifconfig xl0 media</b>
  xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
          lladdr 00:08:74:2c:df:9c
          groups: egress
          media: Ethernet autoselect (100baseTX full-duplex)
          status: active
          supported media:
                  media 10baseT
                  media 10baseT mediaopt full-duplex
                  media 100baseTX
                  media 100baseTX mediaopt full-duplex
                  media autoselect
          inet 192.168.1.37 netmask 0xfffffe00 broadcast 192.168.1.255
  # <b>ifconfig xl0 media 100baseTX mediaopt full-duplex</b>
  # <b>ifconfig xl0</b>
  xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
          lladdr 00:08:74:2c:df:9c
          groups: egress
          media: Ethernet 100baseTX full-duplex
          status: active
          inet6 fe80::208:74ff:fe2c:df9c%xl0 prefixlen 64 scopeid 0x1
          inet 192.168.1.37 netmask 0xfffffe00 broadcast 192.168.1.255
  # <b>exit</b>
<i>...setup resumes...</i>
</pre></td></tr></table>

<p>
<a href="#backMoreNetwork">(zurück dorthin, wo wir vielleicht gewesen sind)</a>

<p>
<a name="MoreTimeZone"></a>
<h3>4.6.2 - Festlegung der Zeitzone</h3>
Zeit ist in Unix keine einfache Sache (oder anders formuliert: Zeit in Unix
ist eine <i>wirklich</i> einfache Sache, da menschliche Zeit ein politisch
manipuliertes Durcheinander ist).
Zeitzonendateien helfen dem System, Unix-Zeit (die Anzahl von Sekunden, die
seit dem 1.1.1970, Schlag Mitternacht GMT [Greenwhich-Mean-Time], vergangen
sind) in menschliche Zeit zu konvertieren, und dabei Dinge wie Zeitzonen,
Sommerzeiten (DST, »Daylight Saving Time«), Sommerzeitregeländerungen etc. in
Betracht zu ziehen.
Sie beinhalten auch die Geschichte der Änderungen.

<p>
Mehrere Zeitzonendefinitionsdateien werden manchmal dieselbe <i>Jetztzeit</i>
angeben, aber vielleicht eine unterschiedliche Historie haben.
Zum Beispiel besitzen EST5EDT und US/Michigan HEUTE dieselbe Zeit, aber im
Jahre 1975 waren die Regeln unterschiedlich, sodass Berechnungen mit Daten und
Zeiten, die das Jahr 1975 betreffen, sich Gedanken über die Unterschiede machen
müssen.
Aus diesen Gründen solltest du jene Zeitzonendatei benutzen, die die am meisten
spezifische und akkurateste für deine Region ist, und nicht nur eine, die im
Moment eine korrekte Zeit kreiert.

<p>
Das Installationsprogramm von OpenBSD bietet Hilfe zum Auffinden der passenden
Zeitzonendatei, solltest du dir nicht sicher sein.
Drücke einfach »<tt>?</tt>« an jedem Prompt und es wird dir Optionen anbieten.
Bietet dir die erste Antwortsebene keine passende Datei, wähle einen Kontinent
oder ein Land aus, und schaue dir an, welche Optionen sich dort auftun:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  What timezone are you in? ('?' for list) [right/EST5EDT] <b>?</b>
  Africa/      Chile/       GB-Eire      Israel       NZ-CHAT      UCT
  America/     Cuba         GMT          Jamaica      Navajo       US/
  Antarctica/  EET          GMT+0        Japan        PRC          UTC
  Arctic/      EST          GMT-0        Kwajalein    PST8PDT      Universal
  Asia/        EST5EDT      GMT0         Libya        Pacific/     W-SU
  Atlantic/    Egypt        Greenwich    MET          Poland       WET
  Australia/   Eire         HST          MST          Portugal     Zulu
  Brazil/      Etc/         Hongkong     MST7MDT      ROC          posix/
  CET          Europe/      Iceland      Mexico/      ROK          posixrules
  CST6CDT      Factory      Indian/      Mideast/     Singapore    right/
  Canada/      GB           Iran         NZ           Turkey
  What timezone are you in? ('?' for list) [right/EST5EDT] <b>US</b>
  What sub-timezone of 'US' are you in? ('?' for list) ?
  Alaska          Central         Hawaii          Mountain        Samoa
  Aleutian        East-Indiana    Indiana-Starke  Pacific
  Arizona         Eastern         Michigan        Pacific-New
  What sub-timezone of 'US' are you in? ('?' for list) <b>Michigan</b>
</pre></td></tr></table>

<p>
Wir haben nun die Zeit auf »US/Michigan« festgelegt.
Dies erzeugt einen symbolischen Link in <tt>/etc</tt>, der auf die ausgewählte
»zoneinfo«-Datei in <tt>/usr/share/zoneinfo</tt> zeigt, etwas wie:

<blockquote><pre>
  /etc/localtime -> /usr/share/zoneinfo/US/Michigan
</pre></blockquote>

Nun wende deine Aufmerksamkeit für einen Moment dem Verzeichnis
»<tt>right/</tt>« (im Sinne von »korrekt«) zu.
Es dupliziert die Standard-»zoneinfo«-Auswahl, beinhaltet jedoch Anpassungen
für Schaltsekunden.
Mehr dazu kann <a href="faq8.html#NTPerror">hier</a> gefunden werden.

<p>
<a href="#backMoreTimeZone">(zurück dorthin, wo wir vielleicht gewesen sind)</a>

<p>
<a name="Morefdisk"></a>
<h3>4.6.3 - Anpassung der fdisk(8)-Konfiguration</h3>

Bemerkung: Nur einige OpenBSD-Plattformen benutzen überhaupt fdisk und
normalerweise müssen sich nur Benutzer von
<a href="../../de/i386.html">i386</a> und
<a href="../../de/amd64.html">amd64</a> mit fdisk anfreunden.
Benutzer der meisten anderen fdisk(8)-nutzenden Plattformen müssen sich im
allgemeinen keinerlei Gedanken über »Multibooting« oder Setup- und
Diagnose-Partitionen machen.
Aus diesem Grunde beschränkt sich dieser Abschnitt auf i386 und amd64.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8"
>fdisk(8)</a> wird dazu benutzt, einen Teil der Festplatte für OpenBSD zu
reservieren.
Es hilft, den Abschnitt des Laufwerks, der von OpenBSD benutzt wird, von denen
anderer Betriebssysteme oder Systemfunktionen abzugrenzen.

<p>
Sollte es eine Partition auf dem Laufwerk geben, die Bestand haben soll, oder
solltest du es wünschen, Speicher für eine weitere Partition zu reservieren,
dann wirst du NICHT »(W)hole disk« wählen wollen, sondern die Partitionstabelle
mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8"
>fdisk(8)</a> zu editieren wünschen.
Mehr Informationen zum manuellen Aufruf von fdisk(8) kann
<a href="faq14.html#fdisk">hier</a> gefunden werden.

<b>Bevor du mit irgendeinem System arbeiten willst, dessen Daten du nicht
verlieren möchtest, stelle sicher, das eine gute Sicherungskopie vorhanden
ist.</b>
Es ist sehr einfach, im folgenden Schritt wichtige Daten zu vernichten, deshalb
stelle sicher, das du sie wiederherstellen kannst, sollte es nötig werden.

<p>
Wenn du OpenBSD zu einem bestehenden System hinzufügen willst, wirst du
vielleicht ein wenig freien Speicher auf deinem System erzeugen müssen, bevor
OpenBSD installiert werden kann.
Dies wird im Normalfall das Löschen oder möglicherweise die Verkleinerung von
bestehenden Partitionen beinhalten.
Das Programm <a href="http://gparted.sourceforge.net/">gparted</a> wurde
zur Verkleinerung von Partitionen vieler populärer Betriebssysteme für nützlich
befunden und macht es möglich, OpenBSD auf dem freigegebenen Speicher zu
installieren.

<p>
In diesem Beispiel gehen wir davon aus, dass wir auf einer leeren 40&nbsp;G
Festplatte ein »Multiboot«-System erzeugen möchten, mit einer 5&nbsp;G großen,
für Windows reservierten Partition am Anfang der Festplatte und für OpenBSD
den gesamten Rest reservieren.
Beachte, dass auf ein leeres Laufwerk ein gültiger MBR-Startcode und eine
Signatur geschrieben werden müssen, bevor von ihm gestartet werden kann.

<p>
Für den Fall, dass eine bereits vorhandene Partition um eine OpenBSD-Partition
ergänzt werden soll, so ist der Ablauf praktisch identisch.
Blättere einfach über jene Abschnitte hinweg, in denen wir die
Windows-Partition erzeugen und uns um die Installation des MBR-Startcodes
kümmern.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available disks are: wd0.
  Which one is the root disk? (or 'done') [wd0] <b><i>Enter</i></b>
  MBR has invalid signature; not showing it.
</pre></td></tr></table>

<p>
Wenn das Laufwerk bereits einen gültigen MBR hätte, würde hier die existierende
Partitionstabelle dargestellt werden, was auch ein guter Anhaltspunkt dafür
sein kann, ob sich auf dem Laufwerk schon Daten befinden oder nicht.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Use (W)hole disk or (E)dit the MBR? [whole] <b>e</b>

  You will now create a single MBR partition to contain your OpenBSD data. This
  partition must have an id of 'A6'; must *NOT* overlap other partitions; and
  must be marked as the only active partition.  Inside the fdisk command, the
  'manual' command describes all the fdisk commands in detail.

  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
Enter 'help' for information
fdisk: 1>
</pre></td></tr></table>

<p>
Nimm als Erstes Notiz vom fdisk-Prompt.
Die Zahl »1« zeigt an, dass es sich um die erste Partitionstabellenebene
handelt - würdest du eine erweiterte Partition bearbeiten, so würde hier »2«
stehen (oder eine noch größere Zahl).
Erweiterte Partitionen sind Partitionen, die ihre eigene
Unterpartitionstabelle besitzen, und damit die
Vier-Partitionen-Designbeschränkung vom IBM AT umgehen.
Erweiterte Partitionen werden hier nicht weiter behandelt.

<p>
Als Erstes erzeugen wir Partition »0«, eine 5&nbsp;G große Windows-Partition
(die das NTFS-Dateisystem benutzt), und Partition »1« wird als unsere
OpenBSD-Partition den gesamten Rest der Festplatte einnehmen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk: 1> <b>e 0</b>
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help)
</pre></td></tr></table>

<p>
Da wir gerade die gültige Partitions-ID für NTFS nicht aus unserer Erinnerung
rekapitulieren können, drücken wir »?«, um eine Liste zu erhalten.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>?</b>
  Choose from the following Partition id values:
  00 unused         20 Willowsoft     66 NetWare 386    A9 NetBSD
  01 DOS FAT-12     24 NEC DOS        67 Novell         AB MacOS X boot
  02 XENIX /        27 Win Recovery   68 Novell         AF MacOS X HFS+
  03 XENIX /usr     38 Theos          69 Novell         B7 BSDI filesy*
  04 DOS FAT-16     39 Plan 9         70 DiskSecure     B8 BSDI swap
  05 Extended DOS   40 VENIX 286      75 PCIX           BF Solaris
  06 DOS > 32MB     41 Lin/Minux DR   80 Minix (old)    C0 CTOS
  07 NTFS           42 LinuxSwap DR   81 Minix (new)    C1 DRDOSs FAT12
  08 AIX fs         43 Linux DR       82 Linux swap     C4 DRDOSs < 32M
  09 AIX/Coherent   4D QNX 4.2 Pri    83 Linux files*   C6 DRDOSs >=32M
  0A OS/2 Bootmgr   4E QNX 4.2 Sec    84 OS/2 hidden    C7 HPFS Disbled
  0B Win95 FAT-32   4F QNX 4.2 Ter    85 Linux ext.     DB CPM/C.DOS/C*
  0C Win95 FAT32L   50 DM             86 NT FAT VS      DE Dell Maint
  0E DOS FAT-16     51 DM             87 NTFS VS        E1 SpeedStor
  0F Extended LBA   52 CP/M or SysV   8E Linux LVM      E3 SpeedStor
  10 OPUS           53 DM             93 Amoeba FS      E4 SpeedStor
  11 OS/2 hidden    54 Ontrack        94 Amoeba BBT     EB BeOS/i386
  12 Compaq Diag.   55 EZ-Drive       99 Mylex          EE EFI GPT
  14 OS/2 hidden    56 Golden Bow     9F BSDI           EF EFI Sys
  16 OS/2 hidden    5C Priam          A0 NotebookSave   F1 SpeedStor
  17 OS/2 hidden    61 SpeedStor      A5 FreeBSD        F2 DOS 3.3+ Sec
  18 AST swap       63 ISC, HURD, *   A6 OpenBSD        F4 SpeedStor
  19 Willowtech     64 NetWare 2.xx   A7 NEXTSTEP       FF Xenix BBT
  1C ThinkPad Rec   65 NetWare 3.xx   A8 MacOS X
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>07</b>
</pre></td></tr></table>

<p>
Nun definieren wir die Start- und Endpunkte:
<p>

<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you wish to edit in CHS mode? [n]
</pre></td></tr></table>

<p>
Der CHS-Modus ermöglicht es dir, den Speicherplatz in Zylindern, Köpfen und
Sektoren zu spezifizieren.
Behalte in Erinnerung, dass für moderne Festplatten die CHS-Nummern absolut
nichtssagend sind: einfach nur drei Zahlen, die zu einem Sektor auf der Platte
übersetzt werden, der dann auf die physikalische Geometrie der Platte übersetzt
wird (welche vielleicht auch noch, über die gesamte Kapazität der Platte hinweg
betrachtet, variabel ist).

<p>
Antwortest du hier mit »y«, so wirst du für Zylinder, Kopf und Sektor nach
Start- und Endwerten gefragt.
Solltest du mit »no« antworten (wie wir es tun), so wirst du nach dem Start-
und Endsektor und der Größe gefragt.
Die Bearbeitung via CHS ist oft einfacher, wenn eine bestehende
Partition eingebunden werden soll, während die Angabe von Sektor und Größe oft
einfacher ist, wenn man schnell eine Partition einer bestimmten Größe erzeugen
möchte.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  offset: [0] <b>64</b>
</pre></td></tr></table>

<a name="trackoffset"></a>
<p>
Die fdisk-Plattformen benötigen einen Zwischenraum vor der ersten Partition.
Die exakte Größe spielt auf modernen Maschinen keine Rolle, OpenBSD benutzt
standardmäßig 64 Sektoren.  Dies wird aus Performancegründen für moderne
Laufwerke empfohlen, bei älteren Laufwerken spielt es keine Rolle.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  size: [0] <b>5g</b>
  Rounding to nearest cylinder: 10490382
</pre></td></tr></table>

<p>
Der Wert »size« (Größe) kann als Anzahl von Sektoren (jeder von 512 Byte Größe)
angegeben werden, oder aber als gewünschte Kapazität, wenn als Suffix »k«, »m«
oder »g« benutzt wird.
Wenn die Bearbeitung mit Hilfe von »offset« (Abstand) und »size« erfolgt, so
rundet fdisk die Partitionsgröße derart, dass die Partition auf einer
Zylindergrenze endet (OpenBSD kümmert sich nicht darum, und es mag möglich
sein, dass sich kein einziges modernes Betriebssystem darum kümmert, aber
einige mögen es einmal getan haben).

<p>
Jetzt lass uns einen Blick auf unsere neue Partition werfen:
<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> p
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -    652 254  63 [          63:    10490382 ] NTFS
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
Beachte, dass der Prompt nun ein »*« beinhaltet,
wodurch angezeigt wird, dass ungesicherte Änderungen vorliegen.

<p>
Wir haben nun die Windows-Partition erzeugt.
Im Moment ist sie allerdings nichts weiter als reservierter Speicher auf der
Platte.
Sie ist nicht formatiert, d.&nbsp;h. kein Dateisystem befindet sich darauf.
Darum musst du dich kümmern, wenn du Windows installierst; in jedem Fall haben
unser Ziel des Reservierens von Speicher für eine später zu erzeugende
Windows-Partition erreicht.

<p>
Jetzt erzeugen wir unsere OpenBSD-Partition.
In diesem Fall wird die Partitions-ID »A6« lauten.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> e 1
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>a6</b>
  Do you wish to edit in CHS mode? [n] <b><i>Enter</i></b>
  offset: [0]
</pre></td></tr></table>

<p>
Uh!  Oh!  Was ist unser »offset«?
Einfach: Der der vorherigen Partition plus ihrer Größe.
In diesem Fall 63+10490382 = 10490445.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  offset: [0] <b>10490445</b>
  size: [0] <b>*</b>
  fdisk:*1>
</pre></td></tr></table>

<p>
Die Eingabe von »*« meint in diesem Fall »den gesamten Rest des Laufwerks«.
Wieder hätten wir die Größe in Sektoren oder mit »m«- oder »g«-Suffix
spezifizieren können, wenn wir Speicher für etwas anderes hätten übrig lassen
wollen.

<p>
Jetzt schauen wir auf unsere Partitionstabelle:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -    652 254  63 [          63:    10490382 ] NTFS
   1: A6    653   0   1 -   4998   5  63 [    10490445:    69802803 ] OpenBSD
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
<b>WIR SIND NOCH NICHT FERTIG!</b><br>
Von diesem Laufwerk kann noch nicht gestartet werden!
Da es ein komplett neues Laufwerk war, ist der
<a href="faq14.html#Boot386">MBR</a> komplett leer.
Die Meldung »Signature: 0x0« hier zeigt, dass keine gültige Signatur (0xAA55)
vorhanden ist, was indiziert, dass definitiv kein gültiger »Bootcode«
existiert.
Natürlich ist es möglich, zwar eine gültige Signatur, aber dennoch
keinen gültigen »Bootcode« zu haben, z.&nbsp;B. durch zufälliges Pech oder
einem Schaden an dem existierenden »Bootcode«, aber eine ungültige Signatur
indiziert mit hoher Wahrscheinlichkeit, dass der »Bootcode« fehlt, weshalb wir
ihn jetzt mit Hilfe des Kommandos »update« installieren:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>update</b>
  Machine code updated.
  fdisk:*1>
</pre></td></tr></table>

<p>
Wir müssen außerdem eine Partition als »aktiv« »markieren«, sodass der
»Boot-ROM« weiß, von welcher Partition er booten soll:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>f 1</b>
  Partition 1 marked active.
</pre></td></tr></table>

<p>
Jetzt lass uns mal schauen, wie es aussieht:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -    652 254  63 [          63:    10490382 ] NTFS
  *1: A6    653   0   1 -   4998   5  63 [    10490445:    69802803 ] OpenBSD
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
Eine Checkliste von Dingen, die du sicherstellen solltest, bevor du fdisk(8)
verlässt:

<ul>
<li>Ist die Signatur gültig?
<li>Sind die Partitionen nicht-überlappend?
<li>Besitzt die OpenBSD-Partition eine »A6«-ID?
<li>Ist die gewünschte Partition (vielleicht OpenBSD) als »aktiv« markiert?
</ul>

<p>
<a href="#BackMorefdisk">(zurück dorthin, wo wir vielleicht gewesen sind)</a>

<p>
<a name="Moredisklabel"></a>
<h3>4.6.4 - Anpassung der disklabel-Konfiguration</h3>

Innerhalb der OpenBSD fdisk(8)-Partition benutzen wir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a>, um OpenBSD-Dateisysteme zu erzeugen.
OpenBSD benennt seine Dateisystem-Partitionen mit Hilfe von sechzehn
Buchstaben, »a« bis »p«.
Partition »a« auf dem Startlaufwerk ist als Wurzelpartition definiert, »b« auf
dem Startlaufwerk ist die Standard-Auslagerungspartition.
»c« ist auf allen Laufwerken identisch mit einer »das gesamte
Laufwerk«-Partition, und wird von Programmen benutzt, die direkten Zugriff auf
das physikalische Laufwerk benötigen, wie zum Beispiel fdisk(8) und
disklabel(8).
Die Partition »c« wird automatisch erzeugt und sollte weder gelöscht noch
verändert werden.
Die verbleibenden Buchstaben sind für dich frei verfügbar, um sie als
Einhängepunkte zu definieren.
Man kann Buchstaben auslassen, sie in jedweder Reihenfolge definieren und sie
können in jeglicher Reihenfolge auf dem Laufwerk auftauchen (obwohl einige
Plattformen Bedingungen an die Position der Partition »a« stellen).
Du kannst auch Zwischenräume auf dem Laufwerk unbenutzt lassen und sie später
zuteilen, oder eventuell vorhandene Partitionen mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=growfs&amp;sektion=8"
>growfs(8)</a> in den nicht zugeteilten Speicher hinein vergrößern.

<p>
Alle Partitionen, die native FFS-Partitionen beherbergen, sollten sich
innerhalb OpenBSDs fdisk(8)-Partition befinden, jedoch können
<a href="faq14.html#foreignfs">Nicht-OpenBSD</a>-Partitionen
außerhalb OpenBSDs fdisk-Partition liegen (und normalerweise sollten sie das
auch).

<p>
Mehr Informationen über die Benutzung von disklabel kann
<a href="faq14.html#disklabel">hier</a> gefunden werden.

<p>
Mehr Informationen darüber, warum Partitionierung gut ist und wie man eine
Strategie für einen guten Partitionierungsplan findet, finden sich
<a href="#Partitioning">weiter unten</a>.

<p>
Das OpenBSD-Installationsprogramm wird, basierend auf der Größe des Laufwerks
versuchen, für dein Laufwerk einen benutzbaren, »für jeden Zweck tauglichen«
Partitionierungsplan zu erstellen.
Ist das Laufwerk groß genug, wird verbleibender freier Speicher der Partition
<tt>/home</tt> zugeschrieben.
Obwohl dies oft nützlich ist, befriedigt es doch nicht die Bedürfnisse aller
Nutzer.

<p>
Für unser Beispiel nehmen wir an, dass wir einen statischen Webserver für einige
unserer Freunde aufbauen.
Wir haben eine Maschine, die eine durchschnittliche Internetverbindung besitzt,
mit einer 40&nbsp;G Festplatte, von der das meiste für die Benutzung durch
OpenBSD zur Verfügung steht (mit derselben 5&nbsp;G Windows-Partition wie in
dem Beispiel weiter oben.
Warum?  Vielleicht weil dieses System einen RAID-Controller besitzt, der zwar
von OpenBSD unterstützt, jedoch nur aus Windows heraus verwaltet werden kann.
Eher wahrscheinlich ist es allerdings, dass der Verfasser dieser »FAQ« sich
nicht danach fühlte, viele unterschiedliche Beispiele verwalten zu müssen).

<p>
Die Internetseiten, serviert von einem OpenBSD-Webserver, befinden sich in
<tt>/var/www</tt> und nur sehr wenig wird in <tt>/home</tt> abgespeichert
werden, sodass dies eine klare Änderung der Standardvorgabe erfordert.
Zum Zwecke der Diskussion nehmen wir weiterhin an, dass wir auf dieser Maschine
das Betriebssystem nicht aus den Quellen heraus neu zu erzeugen brauchen (das
machen wir woanders).
Das System wird ohne X laufen, aber da einige Webanwendungen
<a href="#FilesNeededX">ein installiertes X erwarten</a>,
werden wir es zumindest installieren.
Die Maschine ist nicht wirklich schnell, sie kann nicht mehr als 1&nbsp;G RAM
beherbergen, und es ist unwahrscheinlich, dass unsere Anwendung jemals mehr als
dies verlangen wird.

<p>
Nach ein wenig Nachdenken ist dies unser Plan zur Partitionierung des Systems:
<ul>
<li><tt>/ - root</tt>: 100m.  Dies wird »a« sein.
<li><tt>swap</tt> (Auslagerung): 1g (damit wir immer genug Speicherplatz für
    einen »core dump« haben), dies wird Partition »b«
<li><tt>/usr</tt>: 2g, Partition d
<li><tt>/tmp</tt>: 100m (wir erwarten nicht allzu viel Nutzung), Partition e
<li><tt>/usr/local</tt>: 2g, Partition f
<li><tt>/usr/X11R6</tt>: 1g, Partition g
<li><tt>/home</tt>: 1g, Partition h
<li><tt>/var</tt>: 1g (eine Menge System-Logdateien), Partition j
<li><tt>/var/www</tt>: Rest der Platte, Partition k
</ul>

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  The auto-allocated layout for wd0 is:
  #                size           offset  fstype [fsize bsize  cpg]
    a:          1024.0M         10490445  4.2BSD   2048 16384    1 # /
    b:           252.1M         12587597    swap
    c:         39205.7M                0  unused
    d:          2319.3M         13103933  4.2BSD   2048 16384    1 # /tmp
    e:          3653.9M         17853877  4.2BSD   2048 16384    1 # /var
    f:          1149.8M         25337016  4.2BSD   2048 16384    1 # /usr
    g:          1024.0M         27691862  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          3422.6M         29789014  4.2BSD   2048 16384    1 # /usr/local
    i:          5122.3M               63    NTFS
    j:          1848.7M         36798433  4.2BSD   2048 16384    1 # /usr/src
    k:          1848.7M         40584654  4.2BSD   2048 16384    1 # /usr/obj
    l:         17540.2M         44370875  4.2BSD   2048 16384    1 # /home
  Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout? [a] <b>c</b>
</pre></td></tr></table>

<p>
Wenn wir nur einige kleine Änderungen vorhätten, könnten wir auch die
automatische Einteilung editieren, anstatt mit einem reinen Tisch zu beginnen,
aber wir gehen hier den harten Weg.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  You will now create an OpenBSD disklabel inside the OpenBSD MBR
  partition. The disklabel defines how OpenBSD splits up the MBR partition
  into OpenBSD partitions in which filesystems and swap space are created.
  You must provide each filesystem's mountpoint in this program.

  The offsets used in the disklabel are ABSOLUTE, i.e. relative to the
  start of the disk, NOT the start of the OpenBSD MBR partition.

  Label editor (enter '?' for help at any prompt)
  > <b>p</b>
  OpenBSD area: 10490445-80293248; size: 69802803; free: 69802803
  #                size           offset  fstype [fsize bsize  cpg]
    c:         80293248                0  unused
    i:         10490382               63    NTFS
  >
</pre></td></tr></table>

<p>
Wie du siehst, sind bereits zwei Partitionen vorhanden - die Partition »c« ist
immer präsent und wird automatisch erzeugt, aber disklabel(8) hat ebenfalls die
bestehende NTFS-Partition wahrgenommen und ihr eine disklabel-Partition
zugewiesen, sodass es theoretisch möglich wäre, sie aus OpenBSD heraus zu
benutzen (anzumerken ist jedoch, dass im Moment die Unterstützung für NTFS
experimentell ist und einen angepassten Kernel benötigt; die Unterstützung für
FAT/FAT32 ist hingegen ziemlich gut).

<p>
Wir werden nun unsere Partitionen erzeugen.
Wir starten mit der Partition »a«, unserer root-Partition:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a a</b>
  offset: [10490445] <b><i>Enter</i></b>
  size: [69802803] <b>100m</b>
  Rounding to cylinder: 208845
  FS type: [4.2BSD]  <b><i>Enter</i></b>
  mount point: [none] <b>/</b>
  >
</pre></td></tr></table>

<p>
disklabel hat hier automatisch den ersten frei verfügbaren OpenBSD-Sektor auf
dem Laufwerk eingesetzt, was genau das ist, was wir wollen.
Allerdings hat es als Größenvorgabe den gesamten freien Speicher eingesetzt,
was NICHT das ist, was wir wollen.
Hier haben wir diesen Wert mit unserer gewünschten Größe überschrieben, die in
Sektoren »M« oder »G« angegeben werden kann.

<p>
Normalerweise wirst du den Standard-Dateisystemtyp »4.2BSD« für eine FFS-
(»Fast File System«) oder FFS2-Partition wollen, obwohl andere Typen, die du
nützlich finden könntest, »swap« und »RAID« beinhalten.

<p>
Das letzte ist der Einhängepunkt.
Unsere Partition »a« ist die root-Partition, durch Definition.

<p>
Nun erzeugen wir Auslagerung, das ist unsere Partition »b« (dies ist wieder
eine Bedingung - »b« auf dem Startlaufwerk ist Auslagerung):

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a b</b>
  offset: [10699290] <b><i>Enter</i></b>
  size: [69593958] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [swap] <b><i>Enter</i></b>
  >
</pre></td></tr></table>

<p>
Wieder hat disklabel den Startsektor korrekt kalkuliert und uns als Größe den
»kompletten verbleibenden Speicherplatz« vorgeschlagen, was wir wiederum mit
unserer gewünschten Größe überschrieben haben.
Weil dies die »b«-Partition ist, nahm disklabel an, dass sie für
Auslagerungszwecke bestimmt ist, und als wir das bestätigten, hielt es sich gar
nicht mehr damit auf, uns nach einem Einhängepunkt zu fragen.

<p>
Wir sind nun bereit, die restlichen Partitionen zu erzeugen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a d</b>
  offset: [12803805] <b><i>Enter</i></b>
  size: [67489443] <b>2g</b>
  Rounding to cylinder: 4209030
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr</b>
  > <b>a e</b>
  offset: [17012835] <b><i>Enter</i></b>
  size: [63280413] <b>100m</b>
  Rounding to cylinder: 208845
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/tmp</b>
  > <b>a f</b>
  offset: [17221680] <b><i>Enter</i></b>
  size: [63071568] <b>2g</b>
  Rounding to cylinder: 4209030
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr/local</b>
  > <b>a g</b>
  offset: [21430710] <b><i>Enter</i></b>
  size: [58862538] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr/X11R6</b>
  > <b>a h</b>
  offset: [23535225] <b><i>Enter</i></b>
  size: [56758023] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/home</b>
  > <b>a j</b>
  offset: [25639740] <b><i>Enter</i></b>
  size: [54653508] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var</b>
  > <b>a k</b>
  offset: [27744255] <b><i>Enter</i></b>
  size: [52548993] <b><i>Enter</i></b>
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var/www</b>
  >
</pre></td></tr></table>

<p>
Bei der <tt>/var/www</tt>-Partition (»k«) haben wir einfach den Standardwert
genommen und nutzen damit den gesamten freien Speicherplatz auf dem Laufwerk.
Mit den modernen monströs riesigen Laufwerken ist dies normalerweise eine
schlechte Idee.
Wenn du weißt, das du ihn nie benutzen wirst, teile ihn nicht zu, sondern hebe
ihn für einen zukünftigen Zweck auf.

<p>
Nun lass uns mit Hilfe der Kommandos »p« und »p m« einen Blick auf unser
Ergebnis werfen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>p</b>
  OpenBSD area: 10490445-80293248; size: 69802803; free: 0
  #                size           offset  fstype [fsize bsize  cpg]
    a:           208845         10490445  4.2BSD   2048 16384    1 # /
    b:          2104515         10699290    swap
    c:         80293248                0  unused
    d:          4209030         12803805  4.2BSD   2048 16384    1 # /usr
    e:           208845         17012835  4.2BSD   2048 16384    1 # /tmp
    f:          4209030         17221680  4.2BSD   2048 16384    1 # /usr/local
    g:          2104515         21430710  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          2104515         23535225  4.2BSD   2048 16384    1 # /home
    i:         10490382               63    NTFS
    j:          2104515         25639740  4.2BSD   2048 16384    1 # /var
    k:         52548993         27744255  4.2BSD   2048 16384    1 # /var/www
  > <b>p m</b>
  OpenBSD area: 10490445-80293248; size: 34083.4M; free: 0.0M
    #                size           offset  fstype [fsize bsize  cpg]
    a:           102.0M         10490445  4.2BSD   2048 16384    1 # /
    b:          1027.6M         10699290    swap
    c:         39205.7M                0  unused
    d:          2055.2M         12803805  4.2BSD   2048 16384    1 # /usr
    e:           102.0M         17012835  4.2BSD   2048 16384    1 # /tmp
    f:          2055.2M         17221680  4.2BSD   2048 16384    1 # /usr/local
    g:          1027.6M         21430710  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          1027.6M         23535225  4.2BSD   2048 16384    1 # /home
    i:          5122.3M               63    NTFS
    j:          1027.6M         25639740  4.2BSD   2048 16384    1 # /var
    k:         25658.7M         27744255  4.2BSD   2048 16384    1 # /var/www
  >
</pre></td></tr></table>

<p>
Genau wie bei fdisk- sollten auch die OpenBSD-disklabel-Partitionen einander
nicht überlappen (anders als die Partition »c«, die selbstverständlich alles
überlappt).

<p>
Schreibe die Änderungen und beende disklabel:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>w</b>
  > <b>q</b>
  No label changes.
  newfs: reduced number of fragments per cylinder group from 13048 to 12992 to
  enlarge last cylinder group
  /dev/rwd0a: 102.0MB in 208844 sectors of 512 bytes
  5 cylinder groups of 25.38MB, 1624 blocks, 3328 inodes each
  /dev/rwd0h: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  newfs: reduced number of fragments per cylinder group from 13048 to 12992 to
  enlarge last cylinder group
  /dev/rwd0e: 102.0MB in 208844 sectors of 512 bytes
  5 cylinder groups of 25.38MB, 1624 blocks, 3328 inodes each
  /dev/rwd0d: 2055.2MB in 4209028 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0g: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0f: 2055.2MB in 4209028 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0j: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0k: 25658.7MB in 52548992 sectors of 512 bytes
  127 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local)
  /dev/wd0h on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0e on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0d on /mnt/usr type ffs (rw, asynchronous, local, nodev)
  /dev/wd0g on /mnt/usr/X11R6 type ffs (rw, asynchronous, local, nodev)
  /dev/wd0f on /mnt/usr/local type ffs (rw, asynchronous, local, nodev)
  /dev/wd0j on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0k on /mnt/var/www type ffs (rw, asynchronous, local, nodev, nosuid)

  Let's install the sets!
...
</pre></td></tr></table>

<p>
<a href="#BackMoredisklabel">(zurück dorthin, wo wir vielleicht gewesen sind)</a>

<p>
<a name= "FilesNeeded"></a>
<h2>4.7 - Welche Dateien werden für die Installation benötigt?</h2>
<!-- XXXrelease -->

<p>
Eine vollständige OpenBSD-Installation ist in eine Reihe separater
<i>Dateisets</i> aufgeteilt.
Nicht jede Anwendung benötigt jedes Dateiset, jedoch wird neuen Benutzern
geraten, ALLE zu installieren.

Hier ist ein Überblick über jedes Einzelne:
<p>
<ul>
  <li><b><i>bsd</i></b>          - Dies ist der Kernel. <b>Benötigt</b>
  <li><b><i>bsd.mp</i></b> - Mehrfachprozessor- (SMP) Kernel (nur bei
      einigen Plattformen)
  <li><b><i>bsd.rd</i></b> - <a href="#bsd.rd">RAM-Diskkernel</a>
  <li><b><i>base53.tgz</i></b>   - Beinhaltet das OpenBSD-Basissystem
      <b>Benötigt</b>
  <li><b><i>etc53.tgz</i></b>    - Beinhaltet alle Dateien aus /etc
      <b>Benötigt</b>
  <li><b><i>comp53.tgz</i></b>    - Beinhaltet den Übersetzer (»Compiler«) und
      seine Werkzeuge, Kopfdateien (»Header«) und Bibliotheken.
  <li><b><i>man53.tgz</i></b>    - Beinhaltet die Handbuchseiten
  <li><b><i>game53.tgz</i></b>   - Beinhaltet die Spiele für OpenBSD
  <li><b><i>xbase53.tgz</i></b>  - Beinhaltet die Basisbibliotheken und
      -Werkzeuge für X11
  <li><b><i>xetc53.tgz</i></b>   - Beinhaltet die /etc/X11- und
      /etc/fonts-Konfigurationsdateien
  <li><b><i>xfont53.tgz</i></b>  - Beinhaltet den X11-Schriftartenserver und
      Schriftarten
  <li><b><i>xserv53.tgz</i></b>  - Beinhaltet die X11-X-Server
  <li><b><i>xshare53.tgz</i></b> - Beinhaltet Handbuchseiten,
      Lokalisierungseinstellungen, Kopfdateien etc. für X
</ul>

Die Dateisets <b>etc53.tgz</b> und <b>xetc53.tgz</b> werden als Teil eines
»Upgrades« nicht installiert, sondern nur als Teil einer kompletten
Installation, sodass Anpassungen, die du eventuell gemacht hast, nicht verloren
gehen.
Du musst die Verzeichnisse <tt>/etc</tt>, <tt>/dev</tt> und <tt>/var</tt>
manuell aktualisieren.

<a name="FilesNeededX"></a>
<h3>Warum muss ich X für meine nicht-grafische Anwendung installieren?</h3>

Selbst wenn du es nicht vorhaben solltest, X laufen zu lassen, werden einige
<a href="faq15.html">Pakete</a> von Dritten die Bibliotheken oder andere
Werkzeuge von X auf deinem System voraussetzen.
Diese Anwendungen können manchmal einfach durch die Installation von lediglich
xbase53.tgz zufrieden gestellt werden, der Rest von X wird nicht immer
benötigt.
Manchen Leute widerstrebt es, X auf ihrem System zu installieren, jedoch ohne
gültigen Grund:

<ul>
<li>Die einfache Installation von X ist noch nicht der Grund für die Ausführung
    irgendeines Programms auf dem System.
<li>Die einfache Installation von X auf einem System verändert nicht das Risiko
    der externen Sicherheitsanfälligkeit.
<li>Wenn irgendjemand bereits AUF deinem System ist, können sie wahrscheinlich
    installieren, was immer sie wünschen, sodass die An- oder Abwesenheit von
    X die Situation nicht wirklich verändert.
<li>Die einzigen Teile von X, die laufen, sind die Teile, die von deiner
    Applikation benötigt werden.
<li>Der Speicherbedarf von X ist auf moderner Hardware relativ moderat.
</ul>

Leute verschwenden manchmal eine Menge Zeit und Mühe bei dem Versuch, sich aus
xbase50.tgz nur die Dateien herauszupicken, die sie für die Installation ihrer
Applikation benötigen.
Dies geschieht nicht nur ohne Grund, es ist auch eine Mühe, die für jeden
Upgrade-Zyklus erneut durchgeführt werden muss, was vielleicht bedeutet, dass
du dein System nicht vernünftig aktualisierst und damit ECHTE
Sicherheitsprobleme erzeugst.

<p>
WENN du X benötigst, installiere es einfach.
Es wird dich nicht mehr schmerzen als die Applikation, für die du es benötigst.

<a name="FilesNeededComp"></a>
<h3>Ich möchte die Quelltext-Übersetzer nicht installieren</h3>

Na gut, dann lass es, aber bitte rede dir nicht selbst ein, dass es aus
»sicherheitstechnischen Gründen« geschieht.
Wenn jemand derart tief in dein System eingedrungen ist, dass die An- oder
Abwesenheit eines Übersetzers eine Rolle spielt, dann sind sie in jedem Fall
weit genug, um selbst einen Übersetzer installieren zu können.
Nichtsdestotrotz, das Dateiset compXX.tgz ist relativ groß und beinhaltet eine
Menge Dateien, sodass es eine Weile dauern kann, es zu installieren oder
upzugraden.
Auf langsamen oder kleinen Systemen kann dies einen Unterschied machen.

<p>
Wenn du dich dazu entscheidest, den Übersetzer nicht zu installieren, so wirst
du wahrscheinlich ein anderes System benötigen, um aktualisierte Software zu
warten und zu bauen.
Es gibt weit mehr Systeme, die durch untaugliche Wartung komprimittiert wurden,
als solche, die komprimittiert wurden, weil ein Übersetzer installiert war.

<p>
<a name="Partitioning"></a>
<h2>4.8 - Wie sollte ich mein Laufwerk partitionieren?</h2>
<!-- XXXrelease -->

<p>
Offensichtlich variiert die Antwort auf diese Frage kolossal in Abhängigkeit
von deiner Nutzung des Systems.
OpenBSD kann selbst in wenigen 512&nbsp;MB installiert werden, allerdings ist
die Installation auf einem so kleinen Gerät eine Sache für fortgeschrittene
Benutzer.
Bis du ein wenig Erfahrung besitzt, ist eine 4&nbsp;G oder 8&nbsp;G große
Festplatte die Empfehlung für den Anfang.

<p>
Anders als viele andere Betriebssysteme bestärkt OpenBSD seine Benutzer, ihre
Laufwerke in eine ganze Reihe von Partitionen zu unterteilen, anstatt nur eine
oder zwei große Partitionen zu nutzen.
Es gibt einige Gründen, das Laufwerk zu unterteilen:

<ul>
<li><b>Sicherheit:</b>
    Du kannst einige Dateisysteme als »nosuid«, »nodev« »noexec«, »readonly«
    etc. spezifizieren.
    Dies übernimmt das Installationsprogramm für dich, solltest du die
    empfohlenen Partitionen nutzen.
<li><b>Stabilität:</b>
    Ein Benutzer, oder ein sich schlecht aufführendes Programm, kann das
    Dateisystem mit Müll anfüllen, wenn Schreibrechte dafür vorhanden sind.
    Deine kritischen Programme, die hoffentlich auf einem anderen Dateisystem
    laufen, werden davon nicht beeinträchtigt.
<li><b>Geschwindigkeit:</b>
    Ein Dateisystem, das häufig beschrieben wird, kann ein wenig fragmentieren.
    (Glücklicherweise ist das FFS-Dateisystem, das OpenBSD nutzt, nicht
    anfällig für sehr starke Fragmentierung.)
<li><b>Integrität:</b>
    Wenn ein Dateisystem aus irgendwelchen Gründen zugrunde gerichtet ist, dann
    sind deine anderen Dateisysteme sehr wahrscheinlich noch O.K.
<li><b>Größe:</b>
    Viele Maschinen besitzen eine Beschränkung für die Position auf dem
    Laufwerk, von der das »Boot-ROM« den Kernel laden kann.
    In einigen Fällen kann dieses Limit sehr klein sein (504&nbsp;MB für ältere
    486er), in anderen viel größer (2&nbsp;G, 8&nbsp;G oder 128&nbsp;G auf
    i386-Systemen).
    Da der Kernel sich an jeder möglichen Position auf der root-Partition
    befinden kann, sollte die gesamte root-Partition innerhalb dieses
    beschränkten Bereichs liegen.
    Für weitere Details siehe in
    <a href="faq14.html#LargeDrive">diesem Abschnitt</a>.
    Eine gute Richtlinie mag sein, die Partition für / komplett kleiner als
    2&nbsp;G zu halten.
    Es sei denn, du weißt, dass deine Plattform (oder spezielle Maschine) mit
    mehr (oder weniger) umgehen kann.
<li><b>Nur-Lesen:</b>
    Du kannst Partitionen, die nie oder nur selten beschrieben werden, für die
    meiste Zeit im »Nur-Lesen«-Modus einhängen, was die Notwendigkeit eines
    fsck(8)-Laufs nach einem Crash oder Stromausfall beseitigt, und ebenso vor
    unbeabsichtigter Veränderung von Daten schützen kann.
<li><b>fsck(8):</b>
    Sehr große Partitionen verlangen nach mehr RAM für den fsck(8), und auf
    Systemen mit wenig Hauptspeicher kann dies dazu führen, dass Daten
    ausgelagert werden müssen, was zu sehr lang andauernden fsck-Läufen führt.
</ul>

Ausreichenden Speicherplatz auf dem Laufwerk vorausgesetzt, wird das
Installationsprogramm von OpenBSD die folgenden Partitionen standardmäßig
vorschlagen:

<ul>
<li><b>/ - root:</b>
Zusätzlich dazu, dass dies der Punkt ist, an dem die anderen Dateisysteme
eingehängt werden, hält das Dateisystem root alle Dateien vor, die für das
Starten von OpenBSD benötigt werden.
Dies beinhaltet den Kernel, dazu die Basiswerkzeuge in <tt>/sbin</tt> und
<tt>/bin</tt>, die Konfigurationsdateien in <tt>/etc</tt>, und das
Geräteverzeichnis <tt>/dev</tt>, die alle benötigt werden, um das System
hochzufahren.
Für das Dateisystem root genügen schon 60&nbsp;MB, obwohl es mit 100&nbsp;MB
oder 200&nbsp;MB einfacher ist, wenn die Maschine über viele Upgrade-Zyklen
hinweg benutzt werden soll.
Die Partition »a« deines Startlaufwerks wird automatisch zur root-Partition.
EINIGE Plattformen besitzen Restriktionen für ihre physikalische Position auf
der Platte (d.&nbsp;h. sie muss sich am Anfang des Laufwerks befinden), um
starten zu können.

<li><b>Swap (Auslagerung):</b>
Zusätzlich zu ihrer Aufgabe, ausgelagerte Speicherseiten zu beherbergen, wird
diese Partition ebenfalls dazu benutzt, sogenannte »core dumps« nach
Systemabstürzen abzuspeichern, weshalb vorgeschlagen wird, den Speicher für
Auslagerung (wenn solcher überhaupt konfiguriert wird) größer zu machen, als
den Maximalausbau an Hauptspeicher, der wahrscheinlicherweise jemals auf diesem
System installiert wird.
Lies mehr zu diesem Thema in <a href="faq14.html#Swap">FAQ 14, Swap</a>.

<li><b>/tmp:</b>
Dies ist ein für alle und jeden beschreibbares Verzeichnis, das (wie der Name
impliziert!) für die temporäre Speicherung von Daten benutzt wird.
Die meisten Systeme können mit sehr moderaten Speichermengen hierfür auskommen,
50&nbsp;MB ist üblicherweise ein Vielfaches von dem, was du jemals brauchen
wirst, obwohl es einige wenige Applikationen gibt, die sehr, sehr viel mehr
benötigen.
Obwohl dieses Verzeichnis für alle beschreibbar ist, wird OpenBSD es, für den
Fall, dass es eine eigene Partition besitzt, in der Voreinstellung mit »nodev«
und »nosuid« einhängen, was die Möglichkeit des Missbrauchs für dein System
minimiert.
Anzumerken ist, dass der Inhalt dieses Verzeichnisses bei einem Neustart des
Systems aufgeräumt wird, und dass enthaltene Dateien, die 24 Stunden nicht
benutzt wurden, des Nachts gelöscht werden.

<li><b>/var:</b>
Dieses Verzeichnis/dieser Einhängepunkt wird für VIELE Dinge benutzt und mag
in Abhängigkeit deiner Nutzung ein Hauptkandidat für die Unterteilung in
weitere Partitionen sein.
Einige der Dinge, die sich hier befinden (und potenziell zusätzliche
Einhängepunkte darstellen):
<ul>
<li><tt>/var/log</tt>: Logdateien des Systems.
<li><tt>/var/mail</tt>: Speicherplatz für ankommenden E-Mail-Verkehr.
<li><tt>/var/spool</tt>: Abgehender E-Mail-Verkehr (und andere Sachen).
<li><tt>/var/www</tt>: OpenBSDs
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8"
    >Webserver</a> lebt hier.
<li><tt>/var/tmp</tt>: Dies ist ein Verzeichnis für »persistente« temporäre
    Dateien, da Dateien, die sich hier befinden, bei einem Neustart NICHT
    gelöscht werden.
    So nutzt zum Beispiel vi(1) dieses Verzeichnis als temporären Speicher,
    sodass im Fall eines Systemcrashs oder -Neustarts während des Editierens
    einer Datei diese Dateien dazu benutzt werden können, die
    Bearbeitungssitzung wiederherzustellen.
    Dateien, die hier 24 Stunden lang unbenutzt bleiben, werden jedoch
    ebenfalls durch den nächtlichen Lauf von
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily&amp;sektion=8"
    >daily(8)</a> gelöscht.
<li><tt>/var/crash</tt>: Wenn das System abstürzt, wird es versuchen, vor
    dem Neustart einen »core dump« in die Auslagerungspartition zu
    schreiben.
    Dieser »core dump« wird dann während des Neustarts in <tt>/var/crash</tt>
    gespeichert, sodass <tt>/var</tt> mindestens soviel freien Speicher
    benötigt, wie das System Hauptspeicher besitzt, damit dies automatisch
    ablaufen kann.
</ul>

<li><b>/usr:</b>
Dies ist der Platz, an dem das meiste von OpenBSD residiert.
Binärdateien von Programmen, Bibliotheken, Dokumentation, Handbuchseiten etc.
befinden sich alle im Verzeichnis <tt>/usr</tt>.
Die Dateien in diesem Einhängepunkt sind relativ unveränderlich - in vielen
Fällen könntest du die Partition <tt>/usr</tt> im »Nur-Lesen«-Modus einhängen,
und ohne jegliche Änderung am System bis zum nächsten Upgrade oder Update
auskommen.

<li><b>/usr/X11R6:</b>
Hier befindet sich das X Fenstersystem.
Die X-Binärdateien, -Schriftartendateien, -Bibliotheken etc., finden sich alle
hier.
Der einzige Teil von X, der sich nicht hier befindet, sind die
Konfigurationsdateien.

<li><b>/usr/local:</b>
Im Fall einer standardmäßigen OpenBSD-Installation ist dieser
Einhängepunkt/dieses Verzeichnis komplett leer.
Es wird für lokal installierte Binärdateien und Bibliotheken für lokale
Applikationen benutzt.

<li><b>/usr/src:</b>
Dieses Verzeichnis enthält die Basissystem-Quelltextdateien, ausschließlich
X und den Portierungen.
Dieses Verzeichnis ist standardmäßig leer, es muss so geladen werden, wie es im
Detail in <a href="faq5.html#BldGetSrc">FAQ 5</a> beschrieben wird.

<li><b>/usr/obj:</b>
Dieses Verzeichnis wird während des Übersetzens mit Objekt- und Binärdateien
gefüllt.
Dieses Verzeichnis als Einhängepunkt zu definieren, erlaubt seine einfache
Formatierung anstelle des Löschens von Datei zu Datei, was signifikant
schneller sein kann.

<li><b>/home:</b>
Hier befinden sich die Dateien der Benutzer.
Dies als separate Partition zu definieren macht eine komplette Neuinstallation
des Systems einfach; formatiere einfach in diesem Fall nicht diese Partition.
</ul>

<p>
Einige weitere Gedanken über Partitionierung:
<ul>
<li>Für deinen ersten Versuch an einem experimentellen System mag es am
    einfachsten sein, eine große <tt>/</tt>-Partition und Auslagerung zu
    definieren, bis du weißt, wieviel Speicher du benötigst.
    Dies zu tun opfert einige der Standard-Sicherheitsmerkmale von OpenBSD, die
    separate Dateisysteme für <tt>/, /tmp, /var, /usr</tt> und <tt>/home</tt>
    erwarten.
    Jedoch solltest du vielleicht nicht gerade deine erste OpenBSD-Installation
    im produktiven Einsatz benutzen.
<li>Ein System, das offen dem Internet oder anderen feindlichen Kräften
    gegenüber steht, sollte separate <tt>/var</tt> (und vielleicht sogar eine
    separate <tt>/var/log</tt>) für das Loggen besitzen.
<li>Eine <tt>/home</tt>-Partition kann nett sein.
    Eine neue Version des Betriebssystems?
    Schmeiß einfach alles weg und erzeuge es neu, aber lass deine
    <tt>/home</tt>-Partition unberührt.
    Vergiss aber nicht, eine Kopie deiner Konfigurationsdateien zu sichern!
<li>Eine eigene Partition für alles, das große Mengen an Dateien ansammeln
    kann, die vielleicht auch gelöscht werden müssen, kann schneller zu
    reformatieren und neu zu erzeugen sein, als es dauert, die Dateien zu
    löschen.
    Siehe <a href="faq5.html#ProbObjPt">FAQ für das Erzeugen aus den
    Quelltexten</a> für ein Beispiel (<tt>/usr/obj</tt>).
<li>Wenn du vorhast, aus welchen Gründen auch immer, das System aus dem
    Quelltext neu zu erzeugen, so werden die Quellen sich in <tt>/usr/src</tt>
    befinden.
    Benutzt du keine separate Partition für <tt>/usr/src</tt>, so stelle
    sicher, dass <tt>/usr</tt> über genügend Speicher verfügt.
<li>Ein gerne vergessener Fakt: Du musst <b>nicht</b> den gesamten Speicher
    eines Laufwerks zuteilen, wenn du ein System einrichtest.
    Da es heutzutage bereits eine Herausforderung ist, Laufwerke zu kaufen, die
    kleiner als 100&nbsp;G sind, kann es durchaus Sinn ergeben, Teile des
    Laufwerks frei zu belassen.
    Sollte eine Partition über ihre Größe hinauswachsen, so kannst du eine neue
    Partition in dem unbenutzten Teil der Platte erzeugen, die bestehende
    Partition in die neue Partition <a href="faq10.html#DupFS">duplizieren</a>,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"
    >/etc/fstab</a> derart anpassen, dass es die neue Partition einhängt, neu
    einhängen, und du wirst mehr Platz haben.
<li>Sind deine Partitionen zu nahe an der Minimalgröße, wirst du es vielleicht
    später bereuen, wenn die Zeit gekommen ist, dein System upzugraden.
<li>Wenn du sehr große Partitionen erzeugst, behalte den Gedanken im
    Hinterkopf, dass das Ausführen von Dateisystem-Checks mit
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8"
    >fsck(8)</a> ungefähr 1&nbsp;MB Hauptspeicher pro Gigabyte Dateisystemgröße
    benötigt, und auf alten, langsamen Systemen sehr zeitaufwendig oder sogar
    undurchführbar sein kann (bitte siehe auch
    <a href="faq14.html#LargeDrive">diese Sektion</a>).
<li>Wenn du es deinen Nutzern gestattest, in <tt>/var/www</tt> zu schreiben
    (d.&nbsp;h. persönliche Webseiten), dann möchtest du dies vielleicht als
    eigene Partition realisieren, sodass es möglich ist, mit Hilfe von
    »<a href="faq10.html#Quotas">Quotas</a>« den Platz, den sie benutzen, zu
    beschränken.
    Sollten sie die Partition füllen, so wird kein anderer Bereich deines
    Systems betroffen.
<li>Du möchtest vielleicht auch eine Partition <tt>/altroot</tt> erzeugen,
    wie es in
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily&amp;sektion=8"
    >daily(8)</a> beschrieben wird.
    Dies erzeugt eine tägliche Kopie deiner <tt>/</tt>-Partition, und gibt dir
    somit eine Extra-Kopie deines Kernels und der <tt>/etc</tt>
    Konfigurationsdateien, sollte irgendetwas mit deiner root-Partition
    passieren.
    Offensichtlich muss die <tt>/altroot</tt>-Partition mindestens so groß sein
    wie <tt>/</tt>.
    Wenn du ein zweites Laufwerk besitzt, und etwas anderes zur Duplizierung
    des Rests des Laufwerks benutzt, entweder
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4"
    >softraid(4)</a>, oder eine periodische Kopie mit Hilfe von
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8"
    >dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8"
    >restore(8)</a>, so kann dieses Laufwerk nach dem Entfernen des primären
    Laufwerks startfähig sein.
<li>Das Übersetzen von <a href="faq15.html#Ports">Portierungen</a> aus dem
    Quelltext kann einen riesigen Platzbedarf in den Partitionen <tt>/usr</tt>
    und <tt>/tmp</tt> erfordern.
    Dies ist ein weiterer Grund, warum wir empfehlen, stattdessen
    <a href="faq15.html#PkgMgmt">bereits übersetzte Pakate</a> zu benutzen.
<li>Zumindest einige Editoren nutzen <tt>/var/tmp</tt> als Datenspeicher.
    Dieser muss oft mindestens so groß, wenn nicht sogar größer sein als die
    größte Datei, die editiert werden soll.
    Solltest du vorhaben, Dateien von 500&nbsp;MB Größe zu editieren, so müssen
    die Partitionen <tt>/var</tt> oder <tt>/var/tmp</tt> viel größer sein, als
    du vielleicht geplant hattest.
</ul>

<p>
<a name= "Multibooting"></a>
<h2>4.9 - »Multibooting« OpenBSD (amd64, i386)</h2>

»Multibooting« bezeichnet den Umstand, mehrere Betriebssysteme auf einem
Computer zu haben, und ein bisschen auch die Auswahl des zu startenden
Betriebssystems.
Dies ist <i>keine</i> triviale Sache!
Wenn du nicht weißt, was du machst, kann dies zum Verlust von großen
Datenmengen auf deinem Computer führen.
Neue Benutzer von OpenBSD werden <i>nachdrücklich</i> dazu aufgefordert, mit
einer leeren Festplatte auf einer extra dafür bestimmten Maschine zu beginnen,
um dann die gewünschte Konfiguration auf einer nicht für den realen Einsatz
vorgesehenen Maschine auszuprobieren, bevor man eine »Multiboot«-Konfiguration
auf einer Maschine im produktiven Einsatz einsetzt.
<a href="faq14.html">FAQ 14</a> hat mehr Informationen über den Startprozess
von OpenBSD.

<p>
Vorzugsweise nutzt man eine der vier <i>primären</i> MBR-Partitionen, um
OpenBSD zu starten (d.&nbsp;h. dass erweiterte Partitionen eventuell nicht
funktionieren).

<p>
Anzumerken ist, das Windows 7 und Vista ihre Systempartitionen in der Größe
verändern können: öffne die Systemsteuerung, suche nach »Datenträgerverwaltung«
und benutze dieses Werkzeug.
Ein Rechtsklick auf das »Volume« (Partition) und du wirst bemerken, dass du sie
schrumpfen kannst.
Die Hauptbeschränkung des Werkzeugs ist, dass die Windows-Auslagerungsdatei
nicht bewegt werden kann, d.&nbsp;h. wenn du mehr Speicher brauchst, muss
zuerst diese Datei bewegt oder ausgeschaltet werden.

<p>
Hier sind mehrere Optionen für das »Multibooting«:

<h3>Einstellung der aktiven Partition</h3>
Dies ist vielleicht die am meisten übersehene, aber nichtsdestotrotz manchmal
die beste Lösung für das »Multibooten«.
Welches Betriebssystem du auch immer gerade benutzt, setze einfach die aktive
Partition auf jene, die du als Nächstes starten willst.
Nahezu jedes Betriebssystem offeriert ein Programm, das dies tun kann; das von
OpenBSD heißt <a href="faq14.html#fdisk">fdisk(8)</a>, Programme gleichen Names
gibt es in Windows 9x und DOS und vielen anderen Betriebssystemen.
Dieser Weg kann für Betriebssysteme oder Systeme, die eine sehr lange Zeit für
das Herunterfahren und den Neustart benötigen, sehr wünschenswert sein - setze
die aktive Partition und leite den Neustart ein, entferne dich für eine Tasse
Kaffee, und komme zurück zu einem System, das auf die gewünschte Art und Weise
gestartet ist: kein Warten auf den magischen Moment, um das korrekte
Betriebssystem auszuwählen.

<h3>Startdiskette</h3>
Wenn du ein System besitzt, das OpenBSD nur unregelmäßig startet (oder nicht
willst, dass andere Nutzer des Systems bemerken, dass sich etwas geändert hat),
so ziehe eine Startdiskette in Erwägung.
Benutze einfach eine der
<a href="#MkFlop">OpenBSD-Standardinstallationsdisketten</a> und erzeuge eine
Datei <tt>/etc/boot.conf</tt> (ja, du wirst auch ein Verzeichnis <tt>/etc</tt>
auf der Diskette erzeugen müssen) mit folgendem Inhalt:

<pre>
     boot hd0a:/bsd
</pre>

um das System von Festplatte 0, OpenBSD-Partition »a«, Kernel-Binärdatei
<tt>/bsd</tt> starten zu lassen.
Mit einer Zeile wie »<tt>boot hd2a:/bsd</tt>« ist es auch möglich, von anderen
Laufwerken zu starten, im Beispiel von der dritten Festplatte des Systems.
Um OpenBSD zu starten, lege die Diskette ein und starte das System neu.
Um das andere Betriebssystem zu starten, entferne die Diskette und starte das
System neu.
(Du kannst natürlich diese Diskette auch zum Erzeugen einer startfähigen CD
benutzen.)

<p>
Das Programm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot(8)</a> wird von der Diskette geladen, sucht nach und liest die
<tt>/etc/boot.conf</tt>.
Die Zeile »<tt>boot hd0a:/bsd</tt>« instruiert boot(8), woher der Kernel zu
laden ist - in diesem Fall die erste Festplatte, die vom BIOS gesehen wird.
Behalte in Erinnerung, dass nur eine kleine Datei (<tt>/boot</tt>) von der
Diskette gelesen wird.
Das System lädt den gesamten Kernel von der Festplatte, sodass dies nur fünf
Sekunden auf den Prozess des Startens aufschlägt.

<h3>Windows NT/2000/XP NTLDR</h3>

Für das »Multibooten« von OpenBSD und Windows NT/2000/XP kann man NTLDR
benutzen, den »Bootloader«, den NT benutzt.
Um mit NT »multibooten« zu können, benötigt man eine Kopie des
OpenBSD-»Partition Boot Record« (PBR).
Nach dem Aufruf von »installboot« kann man diesen mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1"
>dd(1)</a> wie gezeigt in eine Datei kopieren:

<pre>
        # <strong>dd if=/dev/rsd0a of=openbsd.pbr bs=512 count=1</strong>
</pre>

Anmerkung: Dies ist wirklich ein guter Zeitpunkt, um daran zu erinnern, dass
das blinde Tippen von Kommandos, die man nicht versteht, eine wirklich
schlechte Idee ist.
Diese Zeile wird auf den meisten Computern, so wie gezeigt, nicht
funktionieren.
Es wird dem Leser überlassen, es auf seine eigene Maschine zu übertragen.

<p>
Nun starte NT und schreibe <tt>openbsd.pbr</tt> nach C:.
Füge eine Zeile wie die Folgende an das Ende von <tt>C:\BOOT.INI</tt> an:

<pre>
        c:\openbsd.pbr="OpenBSD"
</pre>

<p>
Wenn du neu startest, sollte es möglich sein, OpenBSD aus dem NT-Starter-Menü
auszuwählen.
Es sind viele Informationen zu NTLDR beim
<a href="http://www.tburke.net/info/ntldr/ntldr_hacking_guide.htm"
>NTLDR Hacking Guide</a> verfügbar.

<p>
Unter Windows XP kannst du die Startinformationen auch grafisch editieren;
lies das
<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;289022">XP Boot.ini HOWTO</a>.

<p>
Es sind Programme verfügbar, die dir viel von dieser Arbeit abnehmen, zum
Beispiel <a href="http://www.winimage.com/bootpart.htm">BootPart</a>.
Dieses Programm kann unter Windows NT/2000/XP laufen, kann den OpenBSD-PBR
auslesen, ihn auf der NT/2000/XP-Partition platzieren und ihn zu der
<tt>C:\BOOT.INI</tt> hinzufügen.

<p>
Anmerkung: Der Windows NT/2000/XP »Bootloader« ist ausschließlich dazu in der
Lage, Betriebssysteme von der primären Festplatte zu starten.
Du kannst ihn nicht dazu benutzen, OpenBSD von der zweiten Platte des Systems
zu starten.

<h3>Windows Vista</h3>

<p>
Mit Vista hat Microsoft die Unterstützung von NTLDR zugunsten des neueren
»Boot Configuration Data« (BCD)-Speichers, der zur Kontrolle der Startumgebung
benutzt wird, aufgegeben.
Da <tt>BOOT.INI</tt> für die Anpassung nicht länger zur Verfügung steht, nimmt
das Kommandozeilenwerkzeug <tt>bcedit</tt> seinen Platz ein.

<p>
Sobald OpenBSDs PBR auf die Vista-Systempartition kopiert wurde, sind die
folgenden drei Kommandos nötig, um OpenBSD auszuwählen und zu starten, wenn das
System neu gestartet wird:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /create /d "OpenBSD/i386" /application bootsector
The entry {05a763ce-d81b-11db-b3ec-000000000000} was successfully created.

C:\Windows\System32>
</pre></blockquote>

<p>
Die GUID, die hier zurückgegeben wurde
(<tt>05a763ce-d81b-11db-b3ec-000000000000</tt>)
wird für illustrative Zwecke gezeigt.
Beachte die GUID, die gezeigt wird, wenn du das Kommando laufen lässt, da
dieser Wert für die folgenden Kommandos gebraucht wird.
Das einfache Kopieren der oben gezeigten GUID wird nicht funktionieren.

<p>
Die folgenden zwei Kommandos werden ebenfalls benötigt:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /set {05a763ce-d81b-11db-b3ec-000000000000} device boot
The operation completed successfully.

C:\Windows\system32> bcdedit /set {05a763ce-d81b-11db-b3ec-000000000000} path \openbsd.pbr
The operation completed successfully.

C:\Windows\system32>
</pre></blockquote>

<p>
Diese müssen in einer Shell mit Administratorrechten ausgeführt werden.
Sobald du cmd.exe lokalisiert hast, rechtsklicke es, um in der Lage zu sein,
"run as administrator" auszuwählen.

<p>
Beachte den absolute Pfadnamen der importierten PBR-Datei.
Füge keinen Laufwerksbuchstaben hinzu, da angenommen wird, dass die Datei auf
der Systempartition platziert wird.
<tt>bcdedit</tt> wird sich über einen explizit spezifizierten
Laufwerksbuchstaben nicht beschweren, aber der »Bootmanager« wird später
stocken und angeben, dass er den designierten Pfadnamen nicht auflösen kann.

<p>
Während des Neustarts wird Vista als Erstes im »Bootmanager« gelistet, direkt
gefolgt von OpenBSD.
Die Auswahl eines Eintrags startet das entsprechende Betriebssystem.

<p>
Wenn nichts geschieht, schaue in der Systemsteuerung nach Startinformationen.
Sehr wahrscheinlich ist der Start von Windows so eingestellt, dass er keine
Verzögerung benutzt, sodass du das Startmenü nicht zu sehen bekommst.
Du kannst dieses Werkzeug auch benutzen, um OpenBSD standardmäßig zu starten.

<p>
Für mehr Informationen konsultiere <tt>bcdedit</tt>s Hilfe durch die Eingabe
von:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /?
</pre></blockquote>

<p>
oder durch die Suche in Microsofts Dokumentation und auf ihrer Webseite.
Eine gute Einführung kann in dem TechNet-Artikel
»<a href="http://technet.microsoft.com/en-us/library/cc721886%28WS.10%29.aspx"
>Frequently Asked Questions</a>« gefunden werden.

<p>
Für diejenigen, die manuelle Konfiguration erschreckend finden, bietet
<a href="http://neosmart.net/dl.php?id=1">EasyBCD</a> eine grafische
Alternative.

<h3>Windows 7</h3>

<p>
Seit der Veröffentlichung von Vista hat Microsoft BCD verbessert, sodass es nun
mehrere Versionen von Windows über <tt>bcdedit</tt> starten kann.
Weil dies eine viel größere Kontrolle ermöglicht, sind nun fünf Kommandos
nötig, um eine »Multiboot«-Umgebung mit OpenBSD einzurichten.

<p>
Nach dem Kopieren des OpenBSD-PBR auf die Systempartition von Windows 7
benutze die folgenden Kommandos, um die erforderlichen Registraturdaten zu
initialisieren:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /create /d "OpenBSD/i386" /application bootsector
The entry {0154a872-3d41-11de-bd67-a7060316bbb1} was successfully created.

C:\Windows\system32>
</pre></blockquote>

<p>
Wie zuvor schon geschildert, ist die gezeigte GUID
<tt>{0154a872-3d41-11de-bd67-a7060316bbb1}</tt>
systemabhängig.
Merke dir den Wert, den du bei der Ausführung erhältst, und benutze ihn mit den
folgenden Kommandos:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} device boot
The operation completed successfully.

C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} path \openbsd.pbr
The operation completed successfully.

C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} device partition=c:
The operation completed successfully.

C:\Windows\system32> bcdedit /displayorder {0154a872-3d41-11de-bd67-7060316bbb1} /addlast
The operation completed successfully.

C:\Windows\system32>
</pre></blockquote>

<h3>Andere »Bootloader«</h3>

<p>
Andere »Bootloader«, die Benutzer von OpenBSD erfolgreich benutzt haben:
<a href="http://gag.sourceforge.net/">GAG</a>,
<a href="http://www.ranish.com/part/">The Ranish Partition Manager</a>,
<a href="http://refit.sourceforge.net/">rEFIt</a>,
und <a href="http://www.gnu.org/software/grub/">GRUB</a>.

<p>
<h3>OpenBSD und Linux (i386)</h3>
<!-- XXXversion -->

<p>
Bitte lies
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/5.3/i386/INSTALL.linux"
>INSTALL.linux</a>, das detaillierte Instruktionen beinhaltet, um OpenBSD und
Linux gemeinsam zum Laufen zu bringen.

<h3>Probleme mit der Zeitzone</h3>
OpenBSD erwartet, dass die Echtzeituhr des Computers auf UTC (Universal
Coordinated Time) eingestellt ist.
Andere Betriebssysteme erwarten, dass diese Uhr auf lokale Zeit eingestellt
ist.
Offensichtlich kann dies zu Problemen führen, wenn beide Betriebssysteme auf
demselbem Computer laufen.
Das eine oder andere von Ihnen muss sehr wahrscheinlich angepasst werden.
Mehr Informationen zu diesem Thema findet sich in
<a href="faq8.html#TimeZone"
>FAQ 8 - Warum geht meine Uhr um mehrere Stunden falsch?</a>

<p>
<a name= "SendDmesg"></a>
<h2>4.10 - Das Senden deiner »dmesg« an dmesg@openbsd.org
nach der Installation</h2>

<p>
Nur um es den Leuten in Erinnerung zu rufen: Es ist wichtig für die
OpenBSD-Entwickler, auf dem Laufenden zu bleiben, welche Hardware läuft, und
welche nicht richtig funktioniert, und dies schließt die Hardwaresensoren ein,
die in den Maschinen gefunden werden können.

<p>
Ein Zitat aus /usr/src/etc/root/root.mail
<blockquote><pre>
If you wish to ensure that OpenBSD runs better on your machines, please do us
a favor (after you have your mail system configured!) and type something like:
 # (dmesg; sysctl hw.sensors) | \
        mail -s "Sony VAIO 505R laptop, apm works OK" dmesg@openbsd.org
so that we can see what kinds of configurations people are running.  As shown,
including a bit of information about your machine in the subject or the body
can help us even further.  We will use this information to improve device driver
support in future releases.  (Please do this using the supplied GENERIC kernel,
not for a custom compiled kernel, unless you're unable to boot the GENERIC
kernel.  If you have a multi-processor machine, dmesg results of both GENERIC.MP
and GENERIC kernels are appreciated.)  The device driver information we get from
this helps us fix existing drivers. Thank you!
</pre></blockquote>

<p>
Versichere dich, dass du die E-Mail von einem Benutzerkonto sendest, das nicht
nur senden, sondern auch E-Mail empfangen kann, sodass dich Entwickler
kontaktieren können, wenn sie wollen, dass du etwas testest oder änderst, um
dein Setup zum Laufen zu bringen.
Es ist überhaupt nicht wichtig, diese E-Mail von derselben Maschine zu senden,
auf der OpenBSD läuft; sollte diese Maschine keine E-Mail empfangen können, so
mache einfach das Folgende:

<pre>
$ (dmesg; sysctl hw.sensors) | mail your-account@yourmail.dom
</pre>
und dann »forward«e diese Nachricht an
<pre>
 dmesg@openbsd.org
</pre>
wobei hier <tt>your-account@yourmail.dom</tt> für dein reguläres
E-Mail-Benutzerkonto steht.

<p>
<b>ANMERKUNGEN</b>

<ul>
<li>Bitte schicke nur »dmesg«s des GENERIC-Kernels.
    Angepasste Kernel mit entfernten Gerätetreibern sind nicht hilfreich.
<li>Wenn du ein unterstütztes Mehrfachprozessorsystem besitzt und es
    normalerweise mit dem GENERIC.MP Kernel betreibst, so ist es für die
    Entwickler hilfreich, die »dmesg«-Ausgabe sowohl des GENERIC-, als auch des
    GENERIC.MP-Kernels zu sehen.
    Sei also bitte so nett und sende diese beiden in getrennten E-Mails.
<li>Die »dmesg«s werden von einem Computer bearbeitet, der das
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=spamd&amp;sektion=8"
    >spamd</a> Spam-Blocksystem benutzt.
    Dies kann dazu führen, dass deine »dmesg« von den E-Mail-Servern für eine
    gewisse Zeit nicht akzeptiert wird.
    Sei geduldig, nach einer halben Stunde, oder Stunde, oder so, wird sie
    durchkommen.
</ul>

<p>
Die oben gezeigte Methode ist sehr einfach, aber wenn du dich dazu entschieden
hast, E-Mail auf deinem OpenBSD-System nicht zu konfigurieren, so solltest du
dennoch deine »dmesg« an die Entwickler schicken.
Speichere deine »dmesg« in einer Textdatei.

<pre>
$ (dmesg; sysctl hw.sensors) > ~/dmesg.txt
</pre>

Dann transferiere diese Datei (mit Hilfe von FTP/scp/Diskette/Brieftaube/...)
an das System, das du normalerweise für E-Mail benutzt.
Da die »dmesg«-Ausgabe, die du einsendest, automatisch abgearbeitet wird,
solltest du die folgenden Punkte sicherstellen, wenn du alternative
E-Mail-Programme/-Systeme benutzt:
<ul>
<li>Konfiguriere dein E-Mail-Programm so, dass es Nachrichten als Text sendet;
    benutze keine HTML-formatierte E-Mail.
<li>Schalte automatische Zeilenumbrechung ab.
    Viele E-Mail-Programme sind so eingerichtet, dass sie in der 72sten Spalte
    die Zeilen umbrechen (die Norm für Mailinglisten).
<li>Stelle sicher, das dein E-Mail-Programm Nachrichten nicht zu
    »text-flow«-Nonsens umformatiert.
<li>Sende die »dmesg«-Ausgabe nicht als Dateianhang.
    Benutze die »dmesg«-Ausgabe für den normalen Textkörper der Nachricht.
</ul>


<a name="AddFileSet"></a>
<h2>4.11 - Ein Dateiset nach der Installation hinzufügen</h2>
<!-- XXXversion -->
»Oh nein! Ich habe bei der Installation ein Dateiset vergessen!«
<p>
Manchmal erkennt man zu spät, dass man WIRKLICH <tt>comp53.tgz</tt> (oder
eine andere Systemkomponente) benötigt hätte, es aber zum Zeitpunkt der
Installation nicht installiert hat.
Gute Nachrichten: Es gibt zwei einfache Wege, Dateisets nach der eigentlichen
Installation aufzuspielen:

<h3>Durch Nutzung des Upgrade-Prozesses</h3>
Starte einfach das Installationsmedium (CD-ROM oder Diskette) und wähle
»Upgrade« (anstatt »Install«).
Wenn du zu der Liste der zu installierenden Dateisets kommst, wähle jene Sets
aus, die du bei der ersten Installation vergessen hast, wähle die Quelle, und
lass sie dir installieren.

<h3>Durch Benutzung von tar(1)</h3>
Die Installations-Dateisets sind einfach komprimierte tar-Dateien,
und du kannst sie manuell von der Wurzel des Dateisystems aus auspacken:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # cd /
  # tar xzvphf comp53.tgz
</pre></td></tr></table>

<p>
Vergiss NICHT die Option »<tt>p</tt>« im oben gezeigten Kommando,
da sie dafür sorgt, dass die Dateirechte korrekt wiederhergestellt werden!
<p>
Ein häufig gemachter Fehler ist, zu denken, dass man
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1"
>pkg_add(1)</a> benutzen kann, um fehlende Dateisets hinzuzufügen.
Das funktioniert nicht.
pkg_add(1) ist das
<a href="faq15.html#PkgMgmt">Verwaltungswerkzeug für Pakete</a>
zur Installation von Software Dritter.
Es kann mit Paketdateien umgehen, nicht mit generischen tar-Dateien, wie es die
Dateisets sind.

<p>
Wenn du das Dateiset <tt>xbase</tt> zum ersten Mal auf deinem System mit Hilfe
von tar(1) und ohne Neustart installierst, so muss der Cache für
dynamisch gelinkte Bibliotheken durch einen Aufruf von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldconfig&amp;sektion=8"
>ldconfig(8)</a> nach der Installation aktualisiert werden.
Um alle Bibliotheken von X zu dem Cache hinzuzufügen:

<blockquote><pre>
# <b>ldconfig -m /usr/X11R6/lib</b>
</pre></blockquote>

Alternativ kann man auch einfach sein System neu starten, da das Skript
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8"
>rc(8)</a>, das beim Starten des Systems läuft, diese Schritte automatisch
ausführt.

<p>
<a name="bsd.rd"></a>
<h2>4.12 - Was ist »bsd.rd«?</h2>

<b><tt>bsd.rd</tt></b> ist ein RAM (»Random Access Memory«,
Hauptspeicher)-Laufwerk-Kernel.
Diese Datei kann sehr nützlich sein; viele Entwickler achten sorgsam darauf,
sie immer im Wurzelverzeichnis ihres Systems präsent zu haben.

<p>
Ihn einen RAM-Laufwerk Kernel zu nennen, beschreibt das Wurzel-Dateisystem des
Kernels - anstatt sich auf einem physischen Laufwerk zu befinden, befinden
sich die Werkzeuge, die nach dem Start von <tt>bsd.rd</tt> vorhanden sind, im
Kernel und werden von einem RAM-basierten Dateisystem ausgeführt.
<tt>bsd.rd</tt> enthält ein brauchbares Set an Werkzeugen für die Systemwartung
und -installation.

<p>
Auf manchen Plattformen ist <tt>bsd.rd</tt> sogar die bevorzugte
Installationstechnik.
Du platzierst diesen Kernel auf einem vorhandenen Dateisystem, startest ihn,
und führst darauf hin von ihm aus die Installation durch.
Auf den meisten Plattformen kannst du, solltest du eine ältere Version von
OpenBSD laufen haben, eine neue Version von <tt>bsd.rd</tt> per FTP beziehen,
damit neu starten und eine neue Version von OpenBSD installieren - unter
Auslassung jeglicher Wechselmedien.

<p>
Hier ist ein Beispiel des Startens von <tt>bsd.rd</tt> auf einem i386-System:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Using Drive: 0 Partition: 3
  reading boot.....
  probing: pc0 com0 com1 apm mem[639k 255M a20=on]
  disk: fd0 hd0+
  &gt;&gt; OpenBSD/i386 BOOT 3.18
  boot&gt; <b>boot hd0a:/bsd.rd</b>
<i>. . . normal boot to install . . .</i>
</pre></td></tr></table>

<p>
Wie schon gesagt wirst du in das Installationsprogramm gelangen, aber du kannst
auch auf die Shell zurückgreifen, um Wartungsarbeiten auf dem System
auszuführen.

<p>
Die einfache Regel zum Starten von <tt>bsd.rd</tt> ist schlicht der Austausch
des »Boot-Kernels« von <tt>/bsd</tt> zu <tt>bsd.rd</tt>, wie auch immer dies
auf deiner Plattform zu bewerkstelligen ist.

<p>
<a name="InstProb"></a>
<h2>4.13 - Geläufige Installationsprobleme</h2>

<a name="cpq16m"></a>
<h3>4.13.1 - Mein Compaq erkennt nur 16&nbsp;MB RAM</h3>
<i>Einige</i> Compaq-Systeme haben das Problem, dass nicht der gesamte
Hauptspeicher von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>OpenBSDs »Secondstage-Bootloader«</a> ordentlich erkannt wird, sondern nur
16&nbsp;MB erkannt und von OpenBSD verwendet werden.
Du kannst dieses Problem beheben, indem du entweder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
><tt>/etc/boot.conf</tt></a> erstellst/editierst oder Befehle am Prompt
<tt>boot></tt> eingibst, bevor OpenBSD lädt.
Falls du eine Maschine mit 64&nbsp;MB RAM hast, aber OpenBSD nur die ersten
16&nbsp;MB erkennt, wird der Befehl
<pre>
     machine mem +0x3000000@0x1000000
</pre>
48&nbsp;MB (<tt>0x3000000</tt>) nach den ersten 16&nbsp;MB (<tt>0x1000000</tt>)
hinzufügen.
Wenn du ein System mit diesem Problem hättest, würdest du typischerweise den
oben angegeben Befehl am Installationsprompt <tt>boot></tt> der Diskette/CD-ROM
eingeben, neu starten und eine Datei <tt>/etc/boot.conf</tt> anlegen, die den
oben angegebenen Befehl beinhaltet, sodass alle zukünftigen Starts des Systems
den ganzen verfügbaren Speicher erkennen können.

<p>
Es wurde ebenfalls berichtet, dass ein ROM-Update dieses Problem auf
<i>einigen</i> Systemen löst.

<p>
<a name="noboot"></a>
<h3>4.13.2 - Mein i386 startet nach der Installation nicht</h3>
Deine Installation verlief gut, doch beim ersten Start erkennst du keine
Anzeichen dafür, dass OpenBSD versucht zu starten.
Es existieren einige bekannte Gründe für dieses Problem:

<ul>
<li><b>Keine Partition wurde in fdisk(8) als aktiv markiert.</b>
Um dies zu beheben, starte das System unter Verwendung der Startdiskette oder
anderer Medien neu und markiere eine Partition als aktiv (startfähig).
Siehe <a href="faq14.html#fdisk">hier</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386"
>hier</a>.

<li><b>Es wurde niemals ein gültiger »Bootloader« auf das Laufwerk
geschrieben.</b>
Falls du mit einfachem »ENTER« oder »W« auf die Frage
»Use (W)hole disk or (E)dit the MBR?« während der Installation geantwortet
hast, oder die Option <tt>reinit</tt> von fdisk(8) verwendet hast, wurde der
OpenBSD »Boot-Record« im MBR (»Master-Boot-Record«) der Platte installiert;
ansonsten wurde der existierende Code des »Master-Boot-Record« nicht berührt.
Dies wird ein Problem sein, wenn kein anderer »Boot-Record« existierte.
Eine Lösung ist, das Installationsmedium wieder zu starten, auf die Shell
zurückzugreifen und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386"
>fdisk(8)</a> aufzurufen, um den MBR-Code von der Befehlszeile aus zu
aktualisieren:
<pre>
    # fdisk -u wd0
</pre>
Hinweis: Die Option »update« im interaktiven Modus (»-e«) von fdisk wird keine
Signaturbytes schreiben, die benötigt werden, um das Laufwerk Systemstartfähig
zu machen.

<li><b>In einigen wenigen Fällen kann etwas mit der Installation des
»Secondstage-Bootloaders« schief gelaufen sein.</b>
Die Neuinstallation des »Secondstage-Bootloaders« wird
<a href="faq14.html#InstBoot">hier</a> besprochen.
</ul>

<a name="sshhang"></a>
<h3>4.13.3 - Mein System startete, hing aber bei der
SSH-Schlüsselgenerierung</h3>

Es ist sehr wahrscheinlich, dass dein System einwandfrei funktioniert, aber
eine Weile benötigt, um die SSH-Schlüssel zu generieren.
Auf einer SPARCStation2 oder einem Macintosh Quadra können <i>mehrere
Stunden</i> vergehen, bis die drei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1"
>ssh-keygen(1)</a>-Schritte ausgeführt sind.
Lass diesen Prozess einfach durchlaufen - es wird nur ein einziges Mal pro
Installation gemacht.

<p>
Benutzer von sehr langsamen Maschinen können ihre Schlüssel auch auf einem
anderen Computer generieren, in einer <a href="#site">site53.tgz</a> genannten
Datei abspeichern und sie zusammen mit den restlichen Dateisets installieren.

<p>
<a name="noftplist"></a>
<h3>4.13.4 - Ich bekam die Meldung »Failed to change directory« als ich die
Installation durchführte</h3>

Wenn du eine FTP-Installation eines
<a href="faq5.html#Flavors">Schnappschusses</a> während der
»<i>-beta</i>«-Phase des OpenBSD-Entwicklungszyklus durchführst, könntest du
dies lesen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>

  Display the list of known ftp servers? [no] <b>yes</b>
  Getting the list from 192.128.5.191 (ftp.openbsd.org)... FAILED
  Failed to change directory.
  Server IP address or hostname?
</pre></td></tr></table>

<p>
Dies ist normal und ein erwartetes Verhalten während der Vor-Release-Phase
des Zyklus.
Das Installationsprogramm sucht nach der FTP-Liste auf dem primären FTP-Server
in einem Verzeichnis, das bis zum <a href="faq1.html#Next">Release-Datum</a>
nicht verfügbar ist, sodass du die oben genannte Meldung bekommst.

<p>
Verwende einfach eine <a href="../../de/ftp.html">FTP-Spiegelserverliste</a>,
um deinen favorisierten FTP-Spiegelserver zu finden, und gib seinen Namen
manuell ein, wenn du danach gefragt wirst.

<p>
<b>Hinweis: Du solltest die Meldung nicht sehen, wenn du »<i>-release</i>«,
oder von einer CD-ROM installierst.</b>

<p>
<a name="blankfdisk"></a>
<h3>4.13.5 - Meine fdisk-Partitionstabelle ist kaputt oder leer!</h3>
Gelegentlich finden Benutzer ein funktionsfähiges System vor, das aber bei
Verwendung von <tt>fdisk wd0</tt> eine vollständig leere (oder ab und zu
vermüllte) Partitionstabelle aufweist.
Dies wird normalerweise dadurch verursacht, dass eine Partition in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386"
>fdisk(8)</a> erstellt wurde, die einen »offset« von 0 Sektoren besitzt,
anstatt den <a href="#trackoffset">»offset« einer Spur</a>, den sie haben
sollte (Hinweis: Dies nimmt an, dass es sich um die
<a href="../../de/i386.html">i386</a>- oder
<a href="../../de/amd64.html">amd64</a>-Plattform handelt.
Andere Plattformen benötigen andere »offsets«, einige sogar GAR KEINEN
»offset«).
Das System <a href="faq14.html#Boot386">startet</a> dann unter Verwendung des
PBR und nicht des MBR.

<p>
Obwohl diese Konfiguration funktionieren kann, kann dies ein Wartungsproblem
darstellen und sollte korrigiert werden.
Um dies zu korrigieren, muss das Dateisystem der Platte normalerweise von Grund
auf neu erstellt werden (obwohl, wenn du WIRKLICH weißt, was du tust, könntest
du in der Lage sein, nur das disklabel und den MBR neu zu erstellen, und
dadurch nur die erste OpenBSD-Partition der Festplatte zu verlieren, und neu
erzeugen zu müssen).

<p>
<a name="noflopcd"></a>
<h3>4.13.6 - Mein System besitzt weder Disketten- noch CD-ROM-Laufwerk</h3>
Einige Computer, auf denen Leute OpenBSD laufen lassen möchten, besitzen keinen
offensichtlichen Weg, um OpenBSD installieren zu können, da sie weder
Disketten- noch CD-ROM-Laufwerk besitzen.
Entweder wurde die Maschine so designt (zum Beispiel viele Laptops und
»Flash«-basierte Maschinen, wie Soekris- oder ALIX-Systeme), oder die
Startlaufwerke gingen kaputt oder wurden entfernt, und es wäre schwierig, sie
zu ersetzen.
Hier sind einige Tipps und Techniken, die man benutzen kann, um OpenBSD auf
solchen Systemen installiert zu bekommen.

<ul>
<li>Netzwerkstart mit Hilfe von <a href="faq6.html#PXE">PXE</a> (i386 oder
    amd64) oder
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8"
    >diskless(8)</a> (andere Plattformen).
<li>Externes USB-CD-ROM- oder -Diskettenlaufwerk, wenn deine Maschine von so
    etwas starten kann.
<li>USB-Flash-Laufwerk oder -Festplatte, wiederum nur, wenn dein Computer von
    einem USB-Gerät starten kann.
    Bereite das Gerät auf einem anderen Computer so vor, wie es in
    <a href="faq14.html#flashmemLive">FAQ 14</a> beschrieben wird.
    Starte davon, aber wähle den bsd.rd-Kernel, dann installiere wie normal.
    Du könntest ebenfalls die Dateisets auf dem Flash-Medium vorgeladen halten.
<li>Im schlimmsten Fall, wenn keiner der oben genannten Wege möglich ist,
    kannst du normalerweise das Laufwerk aus dem Zielsystem ausbauen, einen
    passenden Adapter zum Einbau in einem »normalen« Computer benutzen, OpenBSD
    installieren, und dann das Laufwerk zurück in das Zielsystem verbringen.
    OpenBSD wird dann einfach fein auf der Zielmaschine starten, obwohl du
    höchstwahrscheinlich die Netzwerkkonfiguration anpassen musst.
    Es mag auch sein, dass <tt>/etc/fstab</tt> angepasst werden muss, wenn du
    (zum Beispiel) deine Installation mit einem USB-&gt;IDE/SATA-Adapter
    vollbracht hast, oder deine Ziel- oder Installationsmaschine
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4"
    >ahci(4)</a> benutzen, und die jeweils andere es nicht tut.
    IDE- und eine einige SATA-Laufwerke werden normalerweise als
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4"
    >wd(4)</a>-Geräte erkannt, aber wenn sie an einen USB-Adapter angeschlossen
    sind, als
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4"
    >sd(4)</a>-Geräte klassifiziert.
    Ein SATA-Laufwerk, angeschlossen an eine
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4"
    >pciide(4)</a>-Schnittstelle wird als wd(4) gelten, aber angeschlossen an
    eine
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4"
    >ahci(4)</a>-Schnittstelle als sd(4)-Gerät erkannt.
    Wie auch immer: Ist die Datei <tt>/etc/fstab</tt> erst einmal angepasst,
    sollte das System einfach fein starten.
</ul>

Erinnere dich in allen Fällen daran, dass auf der Maschine einmal ein
Betriebssystem installiert war.
Es war normalerweise vorgesehen, dass das Betriebssystem neu aufgespielt werden
kann.
Wie dies ursprünglich vorgesehen war, gibt dir oft eine gute Idee, wie du nun
OpenBSD darauf installieren kannst.

<p>
<a name="shamismatch"></a>
<h3>4.13.7 - Ich bekam einen SHA256-Prüfsummenfehler während der
    Installation!</h3>
Prüfsummen sind für jene Dateisets, die für die Systeminstallation benötigt
werden, fest im Installationskernel verdrahtet.

<p>
Dateisets, die für »<i>-release</i>« benutzt werden, sollten alle ihren
gespeicherten Prüfsummen entsprechen.

<p>
<b>Es kann vorkommen, dass für <i>Schappschüsse</i> keine korrekte
Prüfsumme im Installationskernel gespeichert ist.</b>
Dies geschieht aus verschiedenen Gründen während der Erzeugung, und ist kein
Grund, in Panik über Entwicklungs-Schnappschüsse auszubrechen.
Wenn du dir darüber Sorgen machst, so warte auf den nächsten Schnappschuss.

<p>
<a name="site"></a>
<h2>4.14 - Anpassung des Installationsprozesses</h2>
<!-- XXXversion -->

<h3>Die <tt>siteXX.tgz</tt>-Datei</h3>
Die OpenBSD-Installations- und »Upgrade«-Skripte erlauben die Auswahl eines vom
Benutzer erzeugten Sets, das »<tt>siteXX.tgz</tt>« genannt wird, wobei hier XX
für die Release-Version (z.&nbsp;B. 53) steht.
Das Dateiset <tt>siteXX.tgz</tt> ist wie die anderen
<a href="#FilesNeeded">Dateisets</a> ein mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gzip&amp;sektion=1"
>gzip(1)</a> komprimiertes
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1"
>tar(1)</a>-Archiv, das im Wurzelverzeichnis »/« beheimatet ist, und wie die
anderen Dateisets auch mit den Optionen <tt>xzphf</tt> ausgepackt werden muss.
Dieses Set wird zuletzt, nach allen anderen Dateisets, installiert.

<p>
Dieses Dateiset erlaubt es dem Benutzer, Dateien hinzuzufügen oder Solche zu
überschreiben, die von den »normalen Sets« installiert worden sind, und erlaubt
daher die Anpassung der Installation oder des Upgrade.

<p>
Es ist ebenfalls möglich, hostnamenspezifische Installationssets zu erzeugen
und zu benutzen; diese müssen dem Schema
<tt>siteXX-<i>&lt;hostname&gt;.tgz</i></tt> folgen, zum Beispiel
»<tt>site53-puffy.tgz</tt>«.
Dies erlaubt die einfache hostspezifische Anpassung für Installationen,
Upgrades oder dem Wiederherstellen nach Katastrophen.

<p>
Einige Beispiel-Anwendungen einer <tt>siteXX.tgz</tt>-Datei:
<ul>
<li>Erstelle eine siteXX.tgz-Datei, die alle Änderungen beinhaltet, die du seit
der ersten Installation von OpenBSD gemacht hast.
Wenn du dann das System neu erstellen musst, wähle einfach siteXX.tgz während
der Neuinstallation aus und alle Änderungen von dir werden auf dem neuen System
nachgebildet.

<li>Erstelle eine Serie maschinenspezifischer Verzeichnisse, die jeweils eine
siteXX.tgz-Datei beinhalten, die wiederum spezifische Dateien für diese
Maschine beinhalten.
Installationen von Maschinen (z.&nbsp;B. Systeme mit unterschiedlichen
Grafikkarten) einer bestimmten Kategorie können durch die Auswahl der passenden
siteXX.tgz-Datei abgeschlossen werden.

<li>Stecke die Dateien, die du routinemäßig auf einem gleichen oder ähnlichem
    Weg anpasst, in eine siteXX.tgz-Datei -
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"><tt>/etc/skel</tt></a>-Dateien,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><tt>/etc/pf.conf</tt></a>,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8"><tt>/var/www/conf/httpd.conf</tt></a>,
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"><tt>/etc/rc.conf.local</tt></a>
    etc.
</ul>

<h3><tt>install.site</tt>/<tt>upgrade.site</tt>-Skripte</h3>
Als letzten Schritt im Installations-/Upgradeprozess wird im
Wurzelverzeichnis des neu installierten/aktualisierten Systems je nach
aktuellem Prozess nach <tt>install.site</tt> oder <tt>upgrade.site</tt> gesucht
und das Skript in einer Umgebung ausgeführt, die auf das Wurzelverzeichnis des
installierten/aktualisierten System
ge»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=8"
>chroot</a>«et ist.
Denke daran, dass das Upgrade von einem gestarteten Dateisystem aus ausgeführt
wird, sodass dein Ziel tatsächlich auf <tt>/mnt</tt> eingehängt ist.
Trotzdem kann das Skript aufgrund des »chroot« so geschrieben werden, als ob
es im »normalen« Wurzelverzeichnis des Dateisystems läuft.
Da dieses Skript ausgeführt wird, nachdem alle anderen Dateien installiert
wurden, ist der größte Teil der Funktionalität eines vollständigen Systems
verfügbar.
Aber vergiß nicht, dass nur ein minimaler Kernel läuft, nicht alle
Möglichkeiten verfügbar sind und aufgrund von Platzbeschränkungen Dinge, die
heute funktionieren, in einem zukünftigen Release nicht mehr funktionieren
könnten.

<p>
Beachte, dass das Skript <tt>install.site</tt> in einer
<tt>siteXX.tgz</tt>-Datei liegen sollte, während das Skript
<tt>upgrade.site</tt> vor dem Upgrade in das Wurzelverzeichnis gelegt werden
kann - oder in eine <tt>siteXX.tgz</tt>-Datei.

<p>
Die Skripte können für viele Dinge verwendet werden:
<ul>
<li>Entfernen von Dateien, die installiert/aktualisiert worden sind, die du
    auf dem System aber nicht haben möchtest.
<li>Entfernen/aktualisieren/installieren von den
    <a href="faq15.html#PkgMgmt">Paketen</a>, die du auf dem installierten
    System haben möchtest (muss nicht zwangsläufig für alle Pakete
    funktionieren!).
<li>Erstellen eines
    <a href="faq14.html#Backup">sofortigen Backups/Archivs</a>
    des neuen Systems, bevor es dem Rest der Welt ausgesetzt wird.
<li>Einstellen der Systemzeit via
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8"
    >rdate(8)</a>
<li>Um ein Set wahlloser Kommandos nach dem ersten Start ausführen zu lassen.
    Dies geschieht, wenn install.site dazu benutzt wird, jedes solche Kommando
    an die Datei
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.firsttime&amp;sektion=8"
    >rc.firsttime(8)</a> anzuhängen (anhängen ist nötig, da das
    Installationsprogramm seinerseits in diese Datei schreiben könnte).
    Während des Neustarts wird rc.firsttime einmal ausgeführt und dann
    gelöscht.
</ul>

<p>
Die Kombination von <tt>siteXX.tgz</tt>- und
<tt>install.site-/upgrade.site</tt>-Dateien soll den Benutzern ein breites
Angebot an Möglichkeiten zur Anpassung der Installation eröffnen, ohne dass es
nötig ist, dass sie ihre eigenen, angepassten Installationssets erzeugen
müssen.

<p>
Hinweis: Wenn du über einen HTTP-Server installierst, so musst du die Datei(en)
<tt>site*.tgz</tt> in der Datei <tt>index.txt</tt> des Quellverzeichnisses
auflisten, damit sie während der Installation als Option angezeigt wird.
Dies gilt nicht für FTP- oder andere Installationsmethoden.

<p>
<a name="Multiple"></a>
<h2>4.15 - Wie kann ich eine Anzahl gleichartiger Systeme installieren?</h2>
Hier sind einige Anwendungen aufgelistet, die du verwenden kannst, wenn du
mehrere ähnliche OpenBSD-Systemen installieren musst.

<h3><tt>siteXX.tgz</tt>- und <tt>install/upgrade.site</tt>-Dateien</h3>
Siehe den <a href="#site">vorherigen</a> Artikel.

<h3>Ein dump(8) wiederherstellen</h3>
Auf den meisten Plattformen beinhaltet das Startmedium das Programm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8"
>restore(8)</a>, welches verwendet werden kann, um ein Backup zu extrahieren,
das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8"
>dump(8)</a> erstellt wurde.
Du kannst daher von <a href="#MkFlop">Diskette</a>,
<a href="../../de/orders.html">CD</a> oder <a href="#bsd.rd">bsd.rd</a>-Datei
starten, dann »<a href="faq14.html#fdisk">fdisk</a>« und
»<a href="faq14.html#disklabel">disklabel</a>« ausführen und mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8"
>restore</a> die gewünschte Konfiguration von Band oder einem anderen Medium
wiederherstellen und die »<a href="faq14.html#InstBoot">Bootblöcke</a>«
installieren.
Weitere Details gibt es <a href="faq14.html#Backup">hier</a>.

<h3>Plattenabbildung (»imaging«)</h3>
Leider ist kein Platten-Abbildungsprogramm bekannt, das FFS unterstützt und
so nur den tatsächlich benutzten Speicher abbilden würde.
Viele der großen bekannten Abbildungslösungen behandeln eine OpenBSD-Partition
als »generische« Partition, und können daher nur ein Abbild der kompletten
Partition erzeugen.
Damit ist dein Ziel zwar meistens erreicht, jedoch werden dabei normalerweise
gigantische Mengen Speicher verschwendet - eine leere 10&nbsp;G große Partition
<tt>/home</tt> wird 10&nbsp;G Speicher im Abbild benötigen, selbst wenn sich
keine einzige Datei darin befindet.
Und während man normalerweise ein Laufwerksabbild auf ein größeres Laufwerk
installieren kann, würde es nicht möglich sein, den überzähligen Speicher zu
nutzen, und du würdest nicht in der Lage sein, das Abbild auf ein kleineres
Laufwerk zu installieren.

<p>
Sollte dies eine akzeptable Situation darstellen, so magst du in dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd</a>
eine Lösung finden, die das tut, was du brauchst, und dir erlauben, ein
Laufwerk in ein anderes zu kopieren, Sektor für Sektor.
Dies würde dieselbe Funktionalität bieten wie die kommerziellen Programme,
jedoch ohne Kosten.

<p>
<a name="getdmesg"></a>
<h2>4.16 - Woher bekomme ich eine dmesg(8), damit ich ein Installationsproblem
    melden kann?</h2>
Wenn man <a href="../../de/report.html">ein Problem meldet</a>, ist es
entscheidend, eine komplette
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8"
>dmesg(8)</a> des Systems einzufügen.
Wie auch immer - oft ist es so, dass du dies machen musst, wenn das System
nicht ordnungsgemäß funktioniert, oder nicht installieren will, sodass du weder
Platten-, Netzwerk- oder andere Ressourcen zur Verfügung hast, um deine »dmesg«
an die passende <a href="../../de/mail.html">Mailingliste</a> zu senden.
Es gibt aber andere Wege:

<ul>
<li><b>Diskette:</b> Die Startdisketten und -CD-ROMs bieten genügend Werkzeuge,
    um deine »dmesg« auf eine MS-DOS-Diskette zu schreiben, sodass sie auf
    einer anderen Maschine ausgelesen werden kann.
    Lege eine MS-DOS-formatierte Diskette in dein Diskettenlaufwerk und führe
    folgende Befehle aus:
    <pre>
     mount -t msdos /dev/fd0a /mnt
     dmesg > /mnt/dmesg.txt
     umount /mnt
    </pre>
    Falls du ein anderes OpenBSD-System besitzt, kannst du es ebenfalls auf
    eine OpenBSD-kompatible Diskette schreiben - oftmals hat die Startdiskette
    genügend freien Raum, um die »dmesg« aufzunehmen.
    In diesem Fall verzichte auf das gezeigte »<tt>-t msdos</tt>«.
<p>
<li><b>Serielle Konsole:</b>
    Eine serielle Konsole zu verwenden und die Ausgabe auf einer anderen
    Maschine abzufangen, ist oftmals der beste Weg, um Diagnoseinformationen
    erhalten zu können - insbesondere, wenn der Computer direkt nach dem Start
    in einer »panic« endet.
    Neben einem zweitem Computer benötigst du ebenfalls ein passendes serielles
    Kabel (oft ein Nullmodemkabel) und ein Terminalemulator-Programm, das die
    Bildschirmausgabe in eine Datei schreiben kann.

    <p>
    Generelle Informationen über die Einrichtung eines seriellen Terminals
    sind <a href="faq7.html#SerCon">an einer anderen Stelle der FAQ</a>
    verfügbar; um eine Aufzeichnung der Installation abfangen zu können, sind
    in der Regel folgende Befehle ausreichend.

    <p><b>i386</b>

    <p>
    Gib am »Bootloader«-Prompt Folgendes ein:

    <p>
    <blockquote><pre>
    boot> <b>set tty com0</b>
    </pre></blockquote>

    <p>
    Dies teilt OpenBSD mit, dass die erste serielle Schnittstelle (in
    PC-Dokumentationen oft COM1 oder COMA genannt) als serielle Konsole
    verwendet werden soll.
    Die Standardbaudrate ist 9600.

    <p><b>Sparc/Sparc64</b>

    <p>
    Diese Maschinen starten automatisch mit einer seriellen Konsole, wenn sie
    ohne angeschlossene Tastatur gestartet wurden.
    Falls du Tastatur und Monitor angeschlossen hast, kannst du das System
    trotzdem dazu bringen, eine serielle Konsole zu verwenden, indem du
    folgende Befehle am <tt>ok</tt>-Prompt aufrufst.

    <p>
    <blockquote><pre>
    ok <b>setenv input-device ttya</b>
    ok <b>setenv output-device ttya</b>
    ok <b>reset</b>
    </pre></blockquote>
</ul>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Mit OpenBSD durchstarten]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq4.html,v 1.325 ]<br>
$Translation: faq4.html,v 1.171 2013/08/15 13:56:24 steffen Exp $<br>
-->
$OpenBSD: faq4.html,v 1.142 2013/08/15 15:14:54 ajacoutot Exp $
</small>
</body>
</html>
