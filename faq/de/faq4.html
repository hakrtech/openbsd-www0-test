<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>4 - OpenBSD 3.6 Installationsanleitung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="de">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "Die OpenBSD FAQ Seiten - FAQ 4: Installationsanleitung">
<meta name= "keywords"      content= "openbsd,faq,Installation,CD,CDROM,Floppy">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
</head>

<!-- Passes validator.w3.org.  Please keep it this way -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>

<font color= "#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq3.html">[Zum Kapitel 3 - Wo man OpenBSD herbekommt]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Source-Code erzeugen]</a>
</font>

<h1><font color="#e00000">4 - OpenBSD 3.6 Installationsanleitung</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href= "#Overview"     >4.1 - Übersicht der OpenBSD
   Installationsprozedur</a>
<li><a href= "#Checklist"    >4.2 - Checkliste für die Installation</a>
<li><a href="#MkInsMedia"    >4.3 - Bootfähige OpenBSD
   Installationsmedien erzeugen</a>
    <ul>
    <li><a href="#UnixFlop"  >4.3.1 - Floppies unter Unix erzeugen</a>
    <li><a href="#DosFlop"   >4.3.2 - Floppies unter Windows oder DOS
       erzeugen</a>
    <li><a href="#MkCD-ROM"  >4.3.3 - Eine Boot-CD erzeugen</a>
    </ul>
<li><a href="#Boot"          >4.4 - Das Booten der OpenBSD
   Installations-Images</a>
<li><a href= "#Install"      >4.5 - Eine Installation durchführen</a>
  <ul>
  <li><a href="#Start"       >4.5.1 - Mit der Installation beginnen</a>
  <li><a href="#Disks"       >4.5.2 - Festplatte(n) einrichten</a>
  <li><a href="#Hostname"    >4.5.3 - Den Hostnamen des Systems setzen</a>
  <li><a href="#Network"     >4.5.4 - Das Netzwerk konfigurieren</a>
  <li><a href="#InstMedia"   >4.5.5 - Das Installationsmedium auswählen</a>
  <li><a href="#Filesets"    >4.5.6 - Datei Sets auswählen</a>
  <li><a href="#Finish"      >4.5.7 - Zum Ende kommen</a>
  </ul>

<li><a href= "#FilesNeeded"  >4.6 - Welche Dateien werden zur Installation
   benötigt?</a>
<li><a href= "#SpaceNeeded"  >4.7 - Wieviel Platz brauche ich für eine
   OpenBSD Installation?</a>
<li><a href= "#Multibooting" >4.8 - Multibooting OpenBSD/i386</a>
<li><a href= "#SendDmesg"    >4.9 - Nach der Installation deine dmesg an
   dmesg@openbsd.org schicken</a>
<li><a href= "#AddFileSet"   >4.10 - Ein Datei Set nach der Installation
   hinzufügen</a>
<li><a href= "#bsd.rd"       >4.11 - Was ist ,bsd.rd'?</a>
<li><a href= "#InstProb"     >4.12 - Allgemeine Installationsprobleme</a>
  <ul>
  <li><a href= "#cpq16m"     >4.12.1 - Mein Compaq erkennt nur 16M RAM</a>
  <li><a href= "#noboot"     >4.12.2 - Mein i386 bootet nach der Installation
     nicht</a>
  <li><a href= "#sshhang"    >4.12.3 - Mein System bootet, aber hängte
     beim ssh-keygen Prozess</a>
  <li><a href= "#noftplist"  >4.12.4 - Ich bekam die Meldung "Failed to change
     directory", als ich die Installation durchführte</a>
  <li><a href= "#krb4"       >4.12.5 - Wenn ich mich einlogge, bekomme ich
     "login_krb4-or-pwd: Exec format error"</a>
  <li><a href= "#blankfdisk" >4.12.6 - Meine fdisk Partitionstabelle ist
     kaputt oder leer!</a>
  </ul>
<li><a href= "#site"         >4.13 - Anpassen des Installationsprozesses</a>
<li><a href= "#Multiple"     >4.14 - Wie kann ich eine Anzahl gleichartiger
   Systeme installieren?</a>
<li><a href= "#getdmesg"     >4.15 - Woher bekomme ich eine dmesg(8), damit
   ich ein Problem mit der Installation melden kann?</a>
<li><a href= "#bsdrdaout"    >4.16 - OpenBSD unter Verwendung von
   <tt>bsd.rd-aout</tt> upgraden/neuinstallieren</a>.
</ul>
<hr>

<p>
<a name= "Overview"></a>
<h2>4.1 - Übersicht der OpenBSD Installationsprozedur</h2>

<p>
OpenBSD hat eine robuste und anpassungsfähige text-basierte
Installationsroutine und kann von einer einzelnen Diskette aus installiert
werden.
Die meisten Architekturen folgen einer ähnlichen Installationsroutine;
allerdings gibt es Unterschiede in den Details.
In jedem Fall wird dringend dazu geraten, das plattform-spezifische
INSTALL Dokument im <i>Plattform</i> Verzeichnis auf der CD-ROM oder der FTP
Seiten (z.B. <i>i386/INSTALL.i386</i>, <i>mac68k/INSTALL.mac68k</i> oder
<i>sparc/INSTALL.sparc</i>) durchzulesen.

<p>
Auf den meisten Plattformen benutzt die OpenBSD Installation einen speziellen
Kernel mit einigen Utilities und Installationsskripten, die sich auf einer
vorgeladenen RAM Disk befinden.
Nachdem dieser Kernel gebootet wurde, wird das Betriebssystem aus einigen
komprimierten
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1"
>tar(1)</a> Dateien extrahiert.
Es existieren mehrere Wege, diesen Installationskernel zu booten:

<ul>
<li><b>Floppy:</b>
Floppy Images werden zur Verfügung gestellt, die benutzt werden
können, um Installationsdisketten auf einem anderen
<a href="#UnixFlop">Unix-ähnlichen</a> System oder
<a href="#DosFlop">DOS/Windows</a> System zu erstellen.
Typische Dateinamen sind <tt>floppy36.fs</tt>, obwohl für einige
Plattformen mehrere Floppy Images vorhanden sind.

<li><b>CD-ROM:</b> Für einige Plattformen wird ein CD-ROM Image
(<tt>cd36.iso</tt>) bereitgestellt, das die Erstellung von einer
bootfähigen CD-ROM ermöglicht. Dies beinhaltet nur den
Installationskernel - Installationsdateien müssen weiterhin via FTP
oder einer anderen Quelle beschaffen werden.
Du kannst natürlich deine eigene CD-ROM erstellen, die mit allen
Dateien und Programmen ausgestattet ist, die du haben möchtest.

<li><b><a href="#bsd.rd">bsd.rd</a>:</b> Der RAM Disk Kernel,
der dafür ausgelegt ist, entweder von einer bereits existierenden
OpenBSD Partition oder über das Netzwerk gebootet zu werden.

<li><b>Netzwerk:</b> Manche Systeme unterstützen das Booten über
das Netzwerk.

<li><b>Ein Dateisystem Image auf Platte schreiben:</b> ein Dateisystem
Image, das auf eine existierende Partition geschrieben und daraufhin
gebootet werden kann.

<li><b>Bootfähiges Band</b> Einige Systeme unterstützen das Booten
von Band. Diese Bänder können anhand der INSTALL.<i>Plattform</i>
Anleitung erstellt werden.

</ul>

Nicht jede <a href="../de/plat.html">Plattform</a> unterstützt alle
Boot Optionen:

<ul>
<li><a href="../de/alpha.html"><b>alpha:</b></a> Floppy, CD-ROM, das
Schreiben eines Floppy Images auf Festplatte.

<li><a href="../de/amd64.html"><b>amd64:</b></a> Floppy, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../de/cats.html"><b>cats:</b></a> CD-ROM.

<li><a href="../de/hp300.html"><b>hp300:</b></a> CD-ROM, Netzwerk.

<li><a href="../de/hppa.html"><b>hppa:</b></a> Netzwerk.

<li><a href="../de/i386.html"><b>i386:</b></a> Floppy, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../de/mac68k.html"><b>mac68k:</b></a> Installiert (und
gebootet) unter der Verwendung von Anwendungen unter Mac OS.
Siehe
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.6/mac68k/INSTALL.mac68k">INSTALL.mac68k</a>
für Details.

<li><a href="../de/macppc.html"><b>macppc:</b></a> CD-ROM, Netzwerk.

<li><a href="../de/mvme68k.html"><b>mvme68k:</b></a> Netzwerk,
bootfähiges Band.

<li><a href="../de/mvme88k.html"><b>mvme88k:</b></a> Netzwerk,
bootfähiges Band.

<li><a href="../de/sparc.html"><b>sparc:</b></a> Floppy, CD-ROM, Netzwerk,
Schreiben eines Images auf eine existierende Partition.

<li><a href="../de/vax.html"><b>vax:</b></a> Floppy, Netzwerk.

</ul>

Alle Plattformen mit Ausnahme von mac68k können ebenfalls
<a href="#bsd.rd">bsd.rd</a> zum Neuinstallieren oder
Aktualisieren verwenden.

<p>
Wenn der Installationskernel erst einmal gebootet ist, hast du mehrere
Möglichkeiten, von wo aus du die <a href="#FilesNeeded"
>Installations-Datei Sets</a> herbekommen kannst. Auch hier bietet nicht jede
Plattform alle Möglichkeiten.

<ul>
<li><b>CD-ROM:</b> Natürlich bevorzugen wir, dass du das
<a href="../de/orders.html">offizielle CD-ROM Set</a> verwendest, aber
für spezielle Notwendigkeiten kannst du auch dein eigenes erstellen.

<li><b>FTP:</b>
Entweder eine der OpenBSD
<a href="../de/ftp.html">FTP mirror Seiten</a>
oder deinen eigenen FTP Server, der die Datei Sets hält.

<li><b>HTML:</b>
Entweder eine der OpenBSD
<a href="../de/ftp.html#http">HTTP mirror Seiten</a>
oder deinen eigenen Webserver, der die Datei Sets hält.

<li><b>Lokale Festplatten-Partition:</b>
In vielen Fällen kannst du die Datei Sets von einer anderen Partition
einer lokalen Festplatte aus installieren.
Zum Beispiel auf <a href="../de/i386.html">i386</a> kannst du von einer
FAT Partition oder einer CD-ROM mit ISO9660, Rock Ridge oder Joliet
Format aus installieren.
In einigen Fällen musst du das Dateisystem manuell einbinden, bevor
du es verwenden kannst.

<li><b>NFS:</b></li>
Manche Plattformen unterstützen NFS mounts für die Datei Sets.

<li><b>Band:</b></li>
Datei Sets können ebenfalls von einem unterstützten Band
gelesen werden.
</ul>

<a name="Checklist"></a>
<h2>4.2 - Checkliste für die Installation</h2>

<p>
Bevor du mit der eigentlichen Installation beginnst, solltest du dir im
Klaren sein, was du eigentlich am Ende haben willst.

Mindestens die folgenden Punkte sollten daher vorher geklärt sein:
<ul>
<li>Name der Maschine
<li>Die installierte Hardware
  <ul>
  <li>Prüfe die Kompatibilität anhand der passenden
      <a href="../../de/plat.html">Seite</a> für deine Hardware.
  <li> Wenn du ISA-Komponenten verwendest, musst du die Einstellungen kennen
       und prüfen, ob sie den Anforderugnen von OpenBSD entsprechen.
  </ul>
<li>Die gewünschte Installationsmethode. (CDROM, FTP, etc.)
<li>Verteilung/Aufteilung deiner Festplatte(n).
  <ul>
  <li>Müssen vorhandene Daten irgendwo gesichert werden?
  <li>Soll OpenBSD neben einem anderen Betriebssystem auf dem Rechner
      existieren? Wenn ja, auf welche Weise sollen die beiden Systeme
      gebootet werden? Brauchst du vielleicht einen "Boot Manager"?
  <li>Wird OpenBSD die ganze Festplatte belegen oder gibt es jetzt oder
      später einmal eine Partition, um die du "heruminstallieren"
      musst?
  <li>Wie willst du die OpenBSD Partition selbst aufteilen?
  </ul>
<li>Netzwerk-Einstellungen, falls du nicht DHCP verwendest:
  <ul>
  <li>Domain Name
  <li>Domain Name Server(s) (DNS Server)
  <li>IP Adressen und Subnetz-Masken für jede Netzwerk-Karte.
  <li>Gateway Adressen
  </ul>
<li>Wirst du auf diesem System X benutzen?
</ul>


<a name="MkInsMedia"></a>
<h2>4.3 - Bootfähige OpenBSD Installationsmedien erzeugen</h2>

<p>
Als Beispiel werden wir die Installationsmedien betrachten, die für
die <a href="../de/i386.html">i386</a> und <a href="../de/sparc.html">sparc</a>
Plattformen bereitstehen.

<p>
Die <a href="../de/i386.html">i386</a> Plattform besitzt fünf separate
Installations Disk Images, die ausgewählt werden können:

<ul>
<li><b><tt>floppy36.fs</tt></b> (Desktop PC) unterstützt viele
	PCI und ISA Netzwerkkarten (NICs), IDE und einfache SCSI Adapter
        und bietet wenig Unterstützung für PCMCIA. Die
        <i>meisten</i> Benutzer werden dieses Image verwenden.
<li><b><tt>floppyB36.fs</tt></b> (Server) unterstützt viele RAID
        Controller und einige der selteneren SCSI Adapter. Viele der Standard
        SCSI Adapter und viele EISA und ISA NICs werden nicht unterstützt.
<li><b><tt>floppyC36.fs</tt></b> (Laptops) unterstützt viele der Cardbus
        und PCMCIA Geräte, die man in Laptops findet.
<li><b><tt>cdrom36.fs</tt></b> ist eine Kombination aller drei anderen
        Boot-Disketten. Kann dazu verwendet werden, eine bootfähige
        2.88M Floppy zu erzeugen.
<li><b><tt>cd36.iso</tt></b> ist ein ISO9660 Image, das zum Erstellen einer
        bootfähigen CD mit den bekanntesten CD-ROM Brennsoftware
        Produkten auf den meisten Plattformen verwendet werden kann.
<li><b><tt>cdemu36.iso</tt></b> ist ein ISO9660 Image, das zum Booten eine
        "floppy emulation" benutzt und zwar das 2,88M Image,
        <tt>cdrom36.fs</tt>.
        Hoffentlich brauchen nur wenige Leute dieses Image -- die meisten
        Leute werden <tt>cd36.iso</tt> benutzen, verwende <tt>cdemu36.iso</tt>
        nur, wenn <tt>cd36.iso</tt> bei dir nicht funktioniert.
</ul>

Ja, es kann Situationen geben, in denen du eine Floppy für deinen
SCSI-Controller brauchst und eine andere für deine Netzwerk-Karte.
Zum Glück geschieht das selten und kann normalerweise vermieden werden.

<p>
Die <a href="../de/sparc.html">sparc</a> Plattform besitzt drei separate
Installations Disk Images, die ausgewählt werden können.

<ul>
<li><b><tt>floppy36.fs:</tt></b> Unterstützt Systeme mit
  Diskettenlaufwerk.
<li><b><tt>cd36.iso</tt></b> Ein ISO Image, das zum Erstellen einer
  CD verwendet werden kann, um SPARC Systeme von einer CD-ROM aus booten
  zu können.
<li><b><tt>miniroot36.fs</tt></b> Kann auf eine Swap Partition geschrieben
  und gebootet werden.
</ul>

<a name="MkFlop"></a>
<a name="UnixFlop"></a>
<h3>4.3.1 - Floppies unter Unix erzeugen</h3>
Um eine formatierte Floppy zu erzeugen, benutze einfach das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdformat&amp;sektion=1&amp;arch=i386">fdformat(1)</a>
Kommando, damit kannst du deine Floppy sowohl formatieren als auch auf
defekte Sektoren prüfen.

<p>
<table border=0 width="650"> <tr> <td nowrap bgcolor="#EEEEEE"><pre>
  # <b>fdformat /dev/rfd0c</b>
  Format 1440K floppy `/dev/rfd0c'? (y/n): y
  Processing VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV done.
</pre></td></tr> </table>

<p>
Ist deine Ausgabe wie im obigen Beispiel, dann ist deine Floppy OK. Wenn du,
warum auch immmer, nicht ALLE "V"s siehst, dann ist deine Floppy
höchstwahrscheinlich fehlerhaft und du solltest eine neue verwenden.

<p>
Bedenke, dass einige Unix-ähnliche Systeme verschiedene Befehle zum
Formatieren von Disketten haben.
Konsultiere das Handbuch deines Systems für den exakten Ablauf.

<p>
Hast du dann eine korrekt formatierte Floppy, ist es an der Zeit, das
Installationsimage auf die Floppy zu schreiben. Wenn du sie auf einer
OpenBSD Maschine oder auf einem anderen UNIX-ähnlichen OS erstellst,
kannst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=0">dd(1)</a>
verwenden.
Ein Beispiel für <i>dd(1)</i> findest du hier:

<p>
<table border=0 width="650"> <tr> <td nowrap bgcolor="#EEEEEE"><pre>
  # <b>dd if=floppy36.fs of=/dev/rfd0c bs=32k</b>
</pre></td></tr></table>

<p>
Ist das Image geschrieben, überprüfe es mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cmp&amp;sektion=1">cmp(1)</a>
Befehl, um sicherzugehen, dass die Kopie dem Original entspricht.
Wenn Diskette und Image identisch sind, wirst du einfach einen weiteren
Prompt sehen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cmp /dev/rfd0c floppy36.fs</b>
</pre></td> </tr> </table>

<a name="DosFlop"></a>
<h4>4.3.2 - Floppies unter Windows oder DOS erzeugen</h4>

<p>
Dieses Kapitel beschreibt, wie man Installationsimages unter Windows oder
DOS auf eine Diskette schreibt.
Du kannst die Anwendungen, die unten erwähnt werden, aus dem
<a href="ftp://ftp.openbsd.org/pub/unix/OpenBSD/3.6/tools/">tools</a>
Verzeichnis von einem der FTP mirror oder aus dem <tt>3.6/tools</tt>
Verzeichnis auf CD1 des OpenBSD CD Sets bekommen.

<p>
Zur Vorbereitung der Floppy unter MS-DOS oder Windows benutzt man
einfach die bordeigenen Mittel zum Formatieren.

<p>
Das Installations-Image wird mittels
<i>rawrite</i>, <i>fdimage</i> oder <i>ntrw</i> auf die formatierte
Floppy geschrieben. <i>rawrite</i> funktioniert nicht unter
Windows NT, 2000 oder XP.

<p>
Bedenke, dass <tt>FDIMAGE.EXE</tt> und <tt>RAWRITE.EXE</tt> beides
MS-DOS Applikationen sind und daher auch den "8.3"
Datei-Namen-Beschränkungen von MS-DOS unterliegen.
Da sowohl <tt>floppy32B.fs</tt> als auch <tt>floppy32C.fs</tt> längere
Dateinamen haben, wirst du überprüfen müssen,
wie dein System die Dateien an sein "8.3"-Format angepasst hat,
bevor du <i>FDIMAGE.EXE</i> oder <i>RAWRITE.EXE</i> benutzen
kannst, um deine Boot-Floppy zu schreiben.

<p>
Ein Beispiel für <i>rawrite</i>:
<table border=0 width="650"> <tr> <td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <b>rawrite</b>
  RaWrite 1.2 - Write disk file to raw floppy diskette

  Enter source file name: <b>floppy36.fs</b>
  Enter destination drive: <b>a</b>
  Please insert a formatted diskette into drive A: and press -ENTER- : <i><b>Enter</b></i>
</pre> </td> </tr> </table>

<p>
Ein Beispiel für <i>fdimage</i>:
<table border=0 width="650"> <tr> <td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <strong>fdimage -q floppy36.fs a:</strong>
</pre></td></tr></table>

<p>
Ein Beispiel für <i>ntrw</i>:
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <strong>ntrw floppy36.fs a:</strong>
  3.5", 1.44MB, 512 bytes/sector
  bufsize is 9216
  1474560 bytes written
</pre></td></tr></table>

<a name="MkCD-ROM"></a>
<h3>4.3.3 - Eine Boot-CD erzeugen</h3>

<p>
Um eine CD-ROM zu erstellen, kannst du die <tt>cd36.iso</tt> Datei verwenden,
oder, im Falle der i386 Plattform, kannst du auch <tt>cdrom36.fs</tt> als
bootfähiges Floppy Image nutzen, das zum Booten des i386 Systems
von CD-ROM aus dient.
Das Herausfinden der exakten Details mit den zur Verfügung stehenden
Anwendungen sei an dieser Stelle dem Leser überlassen.

<p>
Einige der Anwendungen unter OpenBSD sind:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mkhybrid&amp;sektion=8">mkhybrid(8)</a>
<li><a href="http://www.fokus.gmd.de/research/cc/glone/employees/joerg.schilling/private/cdrecord.html">cdrecord</a>,
Teil der cdrtools Kollektion im <a href="faq8.html#Ports">OpenBSD Ports
System</a>.
</ul>

<a name="Boot"></a>
<h3>4.4 - Das Booten der OpenBSD Installations-Images</h3>

<h3>i386 booten</h3>

<p>
Das Installationsimage auf der i386 Architektur zu booten ist nichts
Neues für die meisten Leute. Wenn du die Floppy verwendest, dann lege
sie einfach in dein Diskettenlaufwerk und starte dein System. Das
Installationsimage wird automatisch laden, wenn in deinem BIOS das Booten
von Diskette aktiviert ist. Wenn du von CD starten willst, dann musst du
im System BIOS das Booten von CD-ROM erlauben. Einige
ältere BIOSe haben diese Option nicht und du musst eine Floppydisk
zum Starten des Installationsimages verwenden. Keine Sorge, du kannst auch
dann von CD installieren, wenn von Diskette gebootet wurde.

<p>
Du kannst ebenfalls installieren, indem du <a href="#bsd.rd">bsd.rd</a>
von einer existierenden OpenBSD Partition oder vom Netzwerk unter
Verwendung vom <a href="faq6.html#PXE">PXE Boot Prozess</a> aus bootest.

<h4>sparc/sparc64 booten</h4>

<b>HINWEIS:</b> Unter sparc64 können nur die SBus Maschinen
(Ultra 1, Ultra 2) von einer Floppy aus gebootet werden.

<p>
Um von Diskette zu starten, lege die OpenBSD Installationsdiskette ein und
rufe folgenden Befehl auf:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot floppy</b>
</pre></td></tr></table>

<p>
Um von CD-ROM zu starten, lege die OpenBSD CD-ROM in dein Laufwerk.
Wenn deine Sun nur ein CD-ROM Laufwerk hat, dann gib am Boot Prompt
folgendes ein:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot cdrom</b>
</pre></td></tr></table>

<p>
Natürlich wird dies nur im neuen Befehlsmodus funktionieren. Wenn
du am alten Befehlsmodus bist (ein rechter Pfeil), gib ,n' ein, um in den
neuen zu gelangen (Wenn du eine alte sparc vor sun4c hast, dann
hast du vielleicht keinen neuen Befehlsmodus: Hier hilft dir nur
experimentieren).
Wenn du mehrere CD-ROM Geräte hast, dann musst du vom richtigen starten.
Verwende <tt>probe-scsi</tt> im neuen Befehlsmodus.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>probe-scsi</b>

  Target 0
    Unit 0   Disk     QUANTUM LIGHTNING 365S
  Target 1
    Unit 0   Removable Disk     QUANTUM EMPIRE_1080S
  Target 3
    Unit 0   Removable Disk     Joe's CD ROM
</pre></td></tr></table>

<p>
Suche das richtige CD-ROM und merke dir die ,target' Nummer.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot /sbus/esp/sd@X,0</b>
</pre></td></tr></table>

<p>


<a name="Install"></a>
<h2>4.5 - Eine Installation durchführen</h2>
<a name="Start"></a>
<h3>4.5.1 - Mit der Installation beginnen</h3>
<!-- XXXrelease -->
Was auch immer du für eine Methode zum Booten
gewählt hast, nun ist es an der Zeit sie zu benutzen. Während des
Boot-Prozesses werden der Kernel und alle Programme zum Installieren von
OpenBSD in den Hauptspeicher geladen. Die größten Probleme
entstehen beim Booten von defekten Floppies oder bei der
Zuweisung von Festplatten. Die Boot-Floppy ist ziemlich vollgepackt -
jeder defekte Block wird Probleme verursachen.

<p>
An fast jeder Stelle während des OpenBSD Installationsprozesses kannst
du den aktuellen Installationsversuch abbrechen, indem du STRG-C
drückst, und kannst ihn ohne Neustart durch Aufruf von <tt>install</tt>
im Shell Prompt wieder beginnen.

<p>
Wenn das Booten erfolgreich war, wirst du eine Menge von
Text-Meldungen vorbeiziehen sehen. Dieser Text, bei vielen
Plattformen in weißer Schrift auf blauem Hintergrund, ist
die sogenannte
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg</a>,
der Kernel erzählt dir, welche Geräte gefunden wurden und wo.
Mach dir nicht die Mühe, den Text zu behalten, eine Kopie davon wird
in <tt>/var/run/dmesg.boot</tt> gespeichert. Auf den meisten Architekturen
kannst du mittels SHIFT+BILD AUF den Text wieder zurückholen, der bereits
vorbeigelaufen ist.

<p>
Dann wirst du das folgende sehen:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  rootdev=0x1100 rrootdev=0x2f00 rawdev=0x2f02
  erase ^?, werase ^W, kill ^U, intr ^C, status ^T
  (I)nstall, (U)pgrade or (S)hell? <b>i</b>
</pre></td></tr></table>

<p>
Und damit erreichen wir auch schon die erste Frage. Meistens werden die
drei Optionen angeboten:
<ul>
<li><b>Install:</b> OpenBSD auf dein System installieren und dabei alles
überschreiben, was dort vorher war. Natürlich kann man hier auch
einige Teile der Festplatte unberührt lassen, wie zum Beispiel
<tt>/home</tt>, aber ansonsten wird alles andere überschrieben.
(Natürlich nur in den Partitionen, in die OpenBSD installiert werden
soll).
<li><b>Upgrade:</b> Installiere neue Sets von <a href="#FilesNeeded"
>Installations-Dateien</a> auf dieser Maschine, aber überschreibe keine
Konfigurations-Dateien, Benutzerdaten oder zusätzliche Programme.
Es wird keine Festplatten-Formatierung vorgenommen und auch die Verzeichnisse
/etc und /var werden nicht überschrieben.
Ein paar wichtige Hinweise:
<ul>
<li> Dir wird nicht die Möglichkeit angeboten, <tt>etc36.tgz</tt> zu
installieren. Nach der Installation musst du die Änderungen von
<tt>etc36.tgz</tt> selbst in dein System einbinden, bevor du erwarten kannst,
dass es voll funktionsfähig sein wird. Das zu tun ist dann sehr wichtig,
da sonst einige Dienste (wie z.B.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4">pf(4)</a>)
möglicherweise nicht starten werden.
<br>
<li>Der Upgrade-Prozess ist nicht dazu da, um ganze Versionen
zu überspringen! Obwohl das meist funktioniert, wird es in keinem Fall
unterstützt. Bei OpenBSD 3.6 wird nur das Upgrade von 3.5 her
unterstützt. Bei allen älteren Versionen sollte man unbedingt neu
installieren.
</ul>
<li><b>Shell:</b> Manchmal muss man Reparaturen oder Schritte unternehmen,
da das System sonst nicht mit einem normalen Kernel booten wird.
Dazu ist diese Option gedacht.
</ul>

In einigen Fällen wirst du die "Upgrade" Option nicht vorfinden.
Nach einem ,<i>flag day</i>' ist es zum Beispiel nicht möglich, ein
direktes Upgrade zu machen, daher muss man das System von Grund auf
neuinstallieren.

<p>
In diesem Beispiel machen wir eine Installation, der Upgrade-Prozess
ist aber recht ähnlich.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Welcome to the OpenBSD/i386 3.6 install program.

  This program will help you install OpenBSD in a simple and rational way. At
  any prompt except password prompts you can run a shell command by typing
  '!foo', or escape to a shell by typing '!'. Default answers are shown in []'s
  and are selected by pressing RETURN. At any time you can exit this program by
  pressing Control-C and then RETURN, but quitting during an install can leave
  your system in an inconsistent state.

  Specify terminal type: [vt220] <b><i>Enter</i></b>
  Do you wish to select a keyboard encoding table? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
In den meisten Fällen ist der vorgeschlagene Terminal-Typ passend,
solltest du allerdings eine <a href="faq7.html#SerCon">serielle Konsole</a>
zur Installation benutzen, wähle bitte die passende Konsole aus, nicht
die vorgeschlagene.

<p>
Wenn du keine Tastaturbelegung (keyboard encoding table) auswählst,
wird das US Tastatur-Layout benutzt.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IS YOUR DATA BACKED UP? As with anything that modifies disk contents, this
  program can cause SIGNIFICANT data loss.

  It is often helpful to have the installation notes handy. For complex disk
  configurations, relevant disk hardware manuals and a calculator are useful.

  Proceed with install? [no] <b>y</b>
</pre></td></tr></table>

<p>
Wenn du hier die vorgeschlagene Antwort gibst, landest du in einer Shell und
bekommst einen Prompt, nachdem die Installation sich beendet hat.

<a name="Disks"></a>
<h3>4.5.2 - Festplatte(n) einrichten</h3>

<p>
Die Laufwerke in OpenBSD einzurichten ist für alle Plattformen ein
wenig unterschiedlich. Bei
<a href="../../de/i386.html">i386</a> und <a href="../../de/macppc.html">macppc</a>
geschieht das Einrichten in zwei Etappen. Die eine geschieht mit
fdisk(8) und die andere mit disklabel(8).


<p>
Der ein oder andere wird ein wenig verwundert über die hier verwendete
Terminologie sein. Es sieht so aus, als ob wir das Wort "Partition"
in zwei verschiedenen Weisen benutzen. Diese Beobachtung ist richtig.
Es gibt zwei Schichten von Partitionierung auf verschiedenen
OpenBSD-Plattformen, die erste könnte man als
Betriebssystem-Partitionierung bezeichnen, so etwa legen viele
Betriebssysteme ihre Partitionen an, und die zweite bezieht sich darauf,
wie OpenBSD seine Partition in weitere individuelle Dateisysteme einteilt.
Die erste Schicht ist sichtbar als eine Partition für DOS, Windows
und jedes weitere Betriebssystem auf den IBM-kompatiblen Maschinen.
Die zweite Schicht dagegen ist nur für OpenBSD und solche
Systeme sichtbar, die OpenBSD-Dateisysteme direkt lesen können.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Cool!  Let's get to it...

  You will now initialize the disk(s) that OpenBSD will use. To enable all
  available security features you should configure the disk(s) to allow the
  creation of separate filesystems for /, /tmp, /var, /usr, and /home.

  Available disks are: wd0.
  Which one is the root disk? (or done) [wd0] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Die ,root disk' ist die Festplatte, von der das System booten soll
und wo sich normalerweise der Swap-Space befindet. 
IDE Fesplatten werden als <tt>wd0</tt>, <tt>wd1</tt>, etc. angezeigt,
SCSI Festplatten und RAIDs als <tt>sd0</tt>, <tt>sd1</tt> und so weiter.
Alle Festplatten, die OpenBSD finden kann, sind hier aufgelistet --
wenn du welche hast, die hier nicht auftauchen, sind sie vermutlich
falsch konfiguriert oder werden gar nicht unterstützt.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want to use *all* of wd0 for OpenBSD? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Wenn du diese Frage mit "yes" beantwortest, wird die gesamte Festplatte
für OpenBSD benutzt. Das resultiert in einem standardmäßigen
Master Boot Record und einer Partitionstabelle, die beide auf die Festplatte
geschrieben werden - eine Partition, die die ganze Festplatte einnimmt,
den OpenBSD Partitionstyp hat und als bootbar gekennzeichnet ist.
Das ist für die meisten Produktionssysteme unter OpenBSD die
brauchbarste Lösung, auf manchen Systemen sollte man das allerdings
nicht so machen. Viele Compaq Systeme, viele Laptops, einige Dell und ein paar
andere Systeme benutzen eine "maintenance" Partition, die unbedingt intakt
bleiben muss. Wenn dein System einige Partitionen hat, die du nicht
löschen willst, solltest du auf keinen Fall mit "yes" antworten.

<p>
Für dieses Beispiel nehmen wir an, dass die Festplatte zwischen OpenBSD
und einer bereits existierenden Installation von Windows 2000 aufgeteilt
werden soll, also beantworten wir die Frage hier mit "no", was uns in das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
Programm bringt. Mehr Informationen über fdisk findest du
<a href="../faq14.html#fdisk">hier</a>.

<p>
<b>Wichtiger Hinweis:</b>
Benutzer mit einer großen Festplatte (größer als 8GB auf
neueren i386, auf älteren Maschinen und anderen Plattformen oftmals noch
kleiner) sollten unbedingt <a href="../faq14.html#LargeDrive">diese Sektion</a>
lesen, bevor sie weitermachen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  You will now create a single MBR partition to contain your OpenBSD data. This
  partition must have an id of 'A6'; must *NOT* overlap other partitions; and
  must be marked as the only active partition.

  The 'manual' command describes all the fdisk commands in detail.

  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 06    0   1  1 -  202 239 63 [          63:     3069297 ] DOS > 32MB
   1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  Enter 'help' for information
  fdisk: 1> <b>help</b>
          help            Command help list
          manual          Show entire OpenBSD man page for fdisk
          reinit          Re-initialize loaded MBR (to defaults)
          setpid          Set the identifier of a given table entry
          disk            Edit current drive stats
          edit            Edit given table entry
          flag            Flag given table entry as bootable
          update          Update machine code in loaded MBR
          select          Select extended partition table entry MBR
          print           Print loaded MBR partition table
          write           Write loaded MBR to disk
          exit            Exit edit of current MBR, without saving changes
          quit            Quit edit of current MBR, saving current changes
          abort           Abort program without saving current changes
  fdisk: 1> 
</pre></td></tr></table>

<p>
Ein paar Befehle sollten wir uns näher ansehen:
<ul>
<li><b><tt>r</tt></b> oder <b><tt>reinit</tt>:</b> Löscht eine
vorhandene Partitionstabelle und erzeugt eine große OpenBSD Partition,
diese wird als aktiv markiert, und installiert den OpenBSD MBR Code.
Ist das gleiche, als ob man mit "yes" auf die "<tt>use *all* of ...</tt>"
Frage antwortet.
<li><b><tt>p</tt></b> oder <b><tt>print:</tt></b> Zeigt die aktuelle
Partitionstabelle in Sektoren an. "<tt>p m</tt>" dagegen zeigt die
Tabelle in MegaBytes an, "<tt>p g</tt>" in GigaBytes.
<li><b><tt>e</tt></b> oder <b><tt>edit:</tt></b> Editieren oder
Ändern eines Tabelleneintrags.
<li><b><tt>f</tt></b> oder <b><tt>flag:</tt></b> Markiert eine Partition
als die aktive Partition, diejenige, von der gebootet wird.
<li><b><tt>u</tt></b> oder <b><tt>update:</tt></b>: Aktualisiert den MBR mit
dem OpenBSD boot code, ähnlich wie "<tt>reinit</tt>", nur dass es die
bestehende Partitionstabelle nicht verändert.
<li><b><tt>exit</tt></b> und <b><tt>quit:</tt></b> Sei hiermit
vorsichtig, da einige Anwender nicht daran gewöhnt sind, dass
"exit" und "quit" verschiedene Bedeutungen haben.
</ul>

Es ist nochmals wichtig darauf hinzuweisen, dass ein Fehler hier
durchaus im Verlust von Daten resultieren kann. Wenn du das
hier auf einer Platte mit wertvollen Daten machst, solltest du
vielleicht vorher auf einer "Test"-Platte proben, zumal du
dann noch ein gutes Backup hast.

<p>
Unsere Festplatte hier hat eine 1.5G Partition für Windows 2000
(mit dem FAT Dateisystem). Die Info oben zeigt, dass die Windows-Partition
bis zum Zylinder 202 reicht. Also werden wir den Rest, sprich ab Zylinder
203, für OpenBSD reservieren. Du kannst auch den Start-Sektor
von OpenBSD berechnen (3069360), indem du den Startsektor (63) und die
Größe (3069297) zu der bereits vorhandenen Partition (hier
Windows 2000 mit FAT) addierst.

<p>
Du kannst das Festplatten-Layout entweder in Form von Cylinder/Heads/Sectors
editieren, oder auch in Form reiner Sektoren. Was einfacher ist, hängt
davon ab, was du tun willst, in diesem Fall ist es wahrscheinlich
einfacher das CHS Format zu benutzen.
Wenn du die erste Partition auf der Festplatte erstellst, ist das Verwenden
von reinen Sektoren wahrscheinlich einfacher.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk: 1> <b>e 1</b>
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   1: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>a6</b>
  Do you wish to edit in CHS mode? [n] <b>y</b>
  BIOS Starting cylinder [0 - 2585]: [0] <b>203</b>
  BIOS Starting head [0 - 239]: [0] <b><i>Enter</i></b>
  BIOS Starting sector [1 - 63]: [0] <b>1</b>
  BIOS Ending cylinder [0 - 2585]: [0] <b>2585</b>
  BIOS Ending head [0 - 239]: [0] <b>239</b>
  BIOS Ending sector [1 - 63]: [0] <b>63</b>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 06    0   1  1 -  202 239 63 [          63:     3069297 ] DOS > 32MB
   1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  fdisk:*1> <b>p m</b>
  Disk: wd0       geometry: 2586/240/63 [19092 Megabytes]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
  *0: 06    0   1  1 -  202 239 63 [          63:        1499M] DOS > 32MB
   1: A6  203   0  1 - 2585 239 63 [     3069360:       17593M] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0M] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0M] unused
  fdisk:*1> 
</pre></td></tr></table>

<a name="trackoffset"></a>
<p>
Es ist wichtig, dass die erste Partition den ersten Track der Platte
auslässt, in diesem Fall also mit Sektor <tt>63</tt> beginnt.
Wenn eine OpenBSD Partition so erstellt wurde, dass sie mit einen Offset von
<tt>0</tt> beginnt, wird diese Partitionstabelle am Ende von der OpenBSD
Partitions <a href="faq14.html#Boot386">Partition Boot Record</a>
überschrieben. Das System könnte weiterhin bootfähig sein,
aber es wird sehr schwer verwaltbar sein und diese Konfiguration ist
<i>weder empfohlen noch unterstützt</i>.

<p>
Wie du sehen kannst, wurde der Prompt um einen Asterisk (,<tt>*</tt>')
erweitert, um anzuzeigen, dass du noch nicht gespeicherte Änderungen
gemacht hast. Wie wir an der Ausgabe von <tt>p&nbsp;m</tt> sehen können,
haben wir unsere Windows Partition nicht geändert, wir haben den Rest
der Platte erfolgreich an OpenBSD vergeben. Wir sind fertig. Fast.

<p>
Was wir noch nicht gemacht haben, ist die Partition als aktiv zu markieren,
so dass nach dem nächsten Reboot OpenBSD geladen wird.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>f 1</b>
  Partition 1 marked active.
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   0: 06    0   1  1 -  202 239 63 [          63:     3069297 ] DOS > 32MB
  *1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
Und nun sind wir soweit, dass wir unsere Änderungen speichern können:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>w</b>
  Writing MBR at offset 0.
  wd0: no disk label
  fdisk: 1> <b>q</b>
</pre></td></tr></table> 

<p>

<a name="disklabel"></a>
<h3>Ein Disklabel erzeugen</h3>
Im nächsten Schritt benutzen wir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>,
um die OpenBSD Partition aufzuteilen. Mehr Details über Disklabel
finden sich in der
<a href="../faq14.html#disklabel">FAQ 14, Disklabel</a>.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Here is the partition information you chose:
  
  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   0: 06    0   1  1 -  202 239 63 [          63:     3069297 ] DOS > 32MB
  *1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused

  You will now create an OpenBSD disklabel inside the OpenBSD MBR
  partition. The disklabel defines how OpenBSD splits up the MBR partition
  into OpenBSD partitions in which filesystems and swap space are created.

  The offsets used in the disklabel are ABSOLUTE, i.e. relative to the
  start of the disk, NOT the start of the OpenBSD MBR partition.

  disklabel: no disk label
  WARNING: Disk wd0 has no label. You will be creating a new one.
  
  # using MBR partition 1: type A6 off 3069360 (0x2ed5b0) size 36030960 (0x225c9f0)

  Treating sectors 3069360-39100320 as the OpenBSD portion of the disk.
  You can use the 'b' command to change this.

  Initial label editor (enter '?' for help at any prompt)
  > <b>?</b>
  Available commands:
          ? [cmnd]  - this message or command specific help.
          a [part]  - add new partition.
          b         - set OpenBSD disk boundaries.
          c [part]  - change partition size.
          D         - set label to default.
          d [part]  - delete partition.
          e         - edit drive parameters.
          g [b|d|u] - use [b]ios, [d]isk or [u]ser geometry.
          M         - show entire OpenBSD man page for disklabel.
          m [part]  - modify existing partition.
          n [part]  - set the mount point for a partition.
          p [unit]  - print label.
          q         - quit and save changes.
          r         - recalculate free space.
          s [path]  - save label to file.
          u         - undo last change.
          w         - write label to disk.
          X         - toggle expert mode.
          x         - exit without saving changes.
          z         - zero out partition table.
          ? [cmnd]  - this message or command specific help.
  Numeric parameters may use suffixes to indicate units:
          'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm' for megabytes,
          'g' for gigabytes or no suffix for sectors (usually 512 bytes).
          '%' for percent of total disk size, '&' for percent of free space.
          Non-sector units will be rounded to the nearest cylinder.
  Entering '?' at most prompts will give you (simple) context sensitive help.
  > 
</pre></td></tr></table>

<p>
Wieder sollten wir uns einige Kommandos näher ansehen:
<ul>
<li><b><tt>p</tt></b> - zeigt (prints) den aktuellen Disklabel auf
dem Schirm und du kannst <tt>k, m</tt> oder <tt>g</tt> für
Kilobytes, Megabytes oder Gigabytes benutzen.

<li><b><tt>D</tt></b> - Löscht jeglichen exisitierenden Disklabel,
erzeugt einen neuen Disklabel der nur die aktuelle OpenBSD Partition
beinhaltet. Das kann nützlich sein, wenn die Festplatte vorher ein
Disklabel hatte und die OpenBSD Partition mit einer anderen
Größe erneut erzeugt wurde -- das alte Disklabel wird vielleicht
nicht gelöscht und könnte Verwirrung stiften.

<li><b><tt>m</tt></b> - Modifiziert einen existierenden Eintrag in
einem Disklabel. Überschätze nicht, was das hier bedeutet.
Obwohl es die Größe einer Disklabel-Partition ändern kann,
wird das Dateisystem auf der Festplatte NICHT geändert.
Diese Option zu benutzen und zu erwarten, man könne damit bereits
existierende Partitionen in der Größe verändern, ist ein
guter Weg, große Mengen an Daten zu verlieren.

</ul>

<p>
Es ist wichtig, deine Festplatte gut aufzuteilen. Die Antwort auf die
Frage "Wie soll ich mein System partitionieren?" ist "Genauso,
wie du es benötigst". Das ist nunmal von Fall zu Fall verschieden.
Es gibt keine universelle Antwort. Wenn du nicht sicher bist, wie du dein
System partitionieren sollst, sieh dir
<a href="#SpaceNeeded">diesen Abschnitt</a> an.

<p>
In diesem System haben wir für OpenBSD über 17Gbyte verfügbar.
Das ist eine Menge Platz, und wir werden wahrscheinlich nie den ganzen Platz
brauchen. Wir werden also mit der Platzverteilung etwas großzügig
sein. Es ist besser, ein paar hundert Megabytes zuviel und unbenutzt zu haben,
als auch nur ein Kilobyte zu wenig.

<p>
Auf der ,root disk' <b>müssen</b> mindestens die Partitionen ,a' und
,b' erzeugt werden. Die Installation wird ohne diese beiden Partitionen
abgebrochen. ,a' wird für das root Dateisystem (/) und ,b' für
den Swap-Space benutzt.

<p>
Nach einer kleinen Denkpause haben wir uns entschieden, die Menge
an Partitionen zu erzeugen, die wir für die empfohlenen
separaten Dateisysteme brauchen (<tt>/, /tmp, /var, /usr, /home</tt>),
zusätzlich zu einer Swap-Partition:
<ul>
<li><i><b>wd0a: /</b></i> (root) - 150M.  Sollte mehr als genug sein.
<li><i><b>wd0b: </b></i>(swap) - 300M.
<li><i><b>wd0d: /tmp</b></i> - 120M.  <tt>/tmp</tt> wird für das Erzeugen
  von Software gebraucht, 120M wird für die meisten Dinge genug sein.
<li><i><b>wd0e: /var</b></i> - 80M.  Wenn das ein Web- oder Mail-Server
 wäre, müsste diese Partition viel größer sein, aber
 das machen wir ja hier nicht.
<li><i><b>wd0g: /usr</b></i> - 2G.  Wir brauchen den Platz hier für
 Menge User-Anwendungen, und außerdem wollen wir das System updaten und
 neu erzeugen können, wenn es notwendig wird. Der
  <a href="../../de/ports.html">Ports Tree</a> wird sich hier auch befinden,
  und vor dem Erzeugen von Ports bereits 100Megabyte Platz brauchen.
  Wenn du viele Applikationen aus den 
  <a href="../faq8.html#Ports">ports</a> bauen willst, statt dich der fertig
  kompilierten <a href="../faq8.html#Packages">packages</a> zu bedienen,
  benötigst du hier eine Menge mehr Platz.
<li><i><b>wd0h: /home</b></i> - 4G.  Das lässt jede Menge Platz
für Benutzer-Dateien.
</ul>

Wenn du das alles zusammenzählst, wirst du bemerken, dass über
10Gigabyte Plattenplatz unbenutzt sind!
Unbenutzter Platz tut uns nicht weh und gibt uns die Flexibilität,
die Dinge in Zukunft zu vergrößern. Du brauchst mehr <i>/tmp</i>?
Kein Problem, erzeuge welchen im unbenutzten Platz, ändere die Datei
<i>/etc/fstab</i> und das Problem ist gelöst.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>p m</b>
  device: /dev/rwd0c
  type: ESDI
  disk: ESDI/IDE disk
  label: ST320011A
  bytes/sector: 512
  sectors/track: 63
  tracks/cylinder: 16
  sectors/cylinder: 1008
  cylinders: 16383
  total sectors: 39102336
  free sectors: 36030960
  rpm: 3600
  
  16 partitions:
  #        size   offset    fstype   [fsize bsize   cpg]
    a: 17593.2M  1498.7M    unused        0     0
    c: 19092.9M     0.0M    unused        0     0
    i:  1498.7M     0.0M     MSDOS
  > <b>d a</b>
  > <b>a a</b>
  offset: [3069360] <b><i>Enter</i></b>
  size: [36030960] <b>150M</b>
  Rounding to nearest cylinder: 307440
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/</b>
  > <b>a b</b>
  offset: [3376800] <b><i>Enter</i></b>
  size: [35723520] <b>300M</b>
  Rounding to nearest cylinder: 614880
  FS type: [swap] <b><i>Enter</i></b>
  > <b>a d</b>
  offset: [3991680] <b><i>Enter</i></b>
  size: [35108640] <b>120m</b>
  Rounding to nearest cylinder: 245952
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/tmp</b>
  > <b>a e</b>
  offset: [4237632] <b><i>Enter</i></b>
  size: [34862688] <b>80m</b>
  Rounding to nearest cylinder: 164304
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var</b>
  > <b>a g</b>
  offset: [4401936] <b><i>Enter</i></b>
  size: [34698384] <b>2g</b>
  Rounding to nearest cylinder: 4194288
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr</b>
  > <b>a h</b>
  offset: [8596224] <b><i>Enter</i></b>
  size: [30504096] <b>4g</b>
  Rounding to nearest cylinder: 8388576
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/home</b>
  > <b>p m</b>
  device: /dev/rwd0c
  type: ESDI
  disk: ESDI/IDE disk
  label: ST320011A
  bytes/sector: 512
  sectors/track: 63
  tracks/cylinder: 16
  sectors/cylinder: 1008
  cylinders: 16383
  total sectors: 39102336
  free sectors: 22115520
  rpm: 3600
  
  16 partitions:
  #        size   offset    fstype   [fsize bsize   cpg]
    a:   150.1M  1498.7M    4.2BSD     1024  8192    16  # /
    b:   300.2M  1648.8M      swap
    c: 19092.9M     0.0M    unused        0     0
    d:   120.1M  1949.1M    4.2BSD     1024  8192    16  # /tmp
    e:    80.2M  2069.2M    4.2BSD     1024  8192    16  # /var
    g:  2048.0M  2149.4M    4.2BSD     1024  8192    16  # /usr
    h:  4096.0M  4197.4M    4.2BSD     1024  8192    16  # /home
    i:  1498.7M     0.0M     MSDOS
  > <b>q</b>
  Write new label?: [y] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Du wirst bemerken, dass wir die <i>c</i> Partition scheinbar komplett
ignoriert haben. Diese Partition ist deine gesamte Festplatte, versuche
sie nicht zu verändern. Du wirst außerdem bemerkt haben, dass wir
die <i>i</i>-Partition nicht angelegt haben, denn das ist die bereits
existierende Windows 2000 Partition. Partitionen werden hier keinem
vorbestimmten Buchstaben zugewiesen, abgesehen von
<i>a</i> (root), <i>b</i> (swap) und <i>c</i> (gesamte Festplatte), der
Rest der Partitionen kann verwendet werden, wie man will.

<p>
Wenn du dir Ausgaben von disklabel genau ansiehst, wirst du vermutlich
feststellen, dass die Angabe des RPM falsch ist. Das ist historisch
bedingt, die Plattengeschwindigkeit wird in keiner Weise vom System
benutzt. Mach dir also keine Sorgen darüber.

<h3>Deine ,mount points' konfigurieren und deine Dateisysteme formatieren</h3>

Jetzt kommt die finale Konfiguration deiner ,mount points'. Wenn du deine
,mount points' mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
konfiguriert hast, reicht es in diesem Schritt aus, deine Auswahl zu
bestätigen, und wenn nicht, kannst du sie nun angeben.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  The root filesystem will be mounted on wd0a.
  wd0b will be used for swap space.
  Mount point for wd0d (size=122976k), none or done? [/tmp] <b><i>Enter</i></b>
  Mount point for wd0e (size=82152k), none or done? [/var] <b><i>Enter</i></b>
  Mount point for wd0g (size=2097144k), none or done? [/usr] <b><i>Enter</i></b>
  Mount point for wd0h (size=4194288k), none or done? [/home] <b><i>Enter</i></b>
  Mount point for wd0d (size=122976k), none or done? [/tmp] <b>done</b>
  Done - no available disks found.
 
  You have configured the following partitions and mount points:

  wd0a /
  wd0d /tmp
  wd0e /var
  wd0g /usr
  wd0h /home

  The next step creates a filesystem on each partition, ERASING existing data.
  Are you really sure that you're ready to proceed? [no] <b>y</b>
  /dev/rwd0a:     307440 sectors in 305 cylinders of 16 tracks, 63 sectors
          150.1MB in 20 cyl groups (16 c/g, 7.88MB/g, 1920 i/g)
  /dev/rwd0d:     245952 sectors in 244 cylinders of 16 tracks, 63 sectors
          120.1MB in 16 cyl groups (16 c/g, 7.88MB/g, 1920 i/g)
  /dev/rwd0e:     164304 sectors in 163 cylinders of 16 tracks, 63 sectors
          80.2MB in 11 cyl groups (16 c/g, 7.88MB/g, 1920 i/g)
  /dev/rwd0g:     4194288 sectors in 4161 cylinders of 16 tracks, 63 sectors
          2048.0MB in 261 cyl groups (16 c/g, 7.88MB/g, 1920 i/g)
  /dev/rwd0h:     8388576 sectors in 8322 cylinders of 16 tracks, 63 sectors
          4096.0MB in 521 cyl groups (16 c/g, 7.88MB/g, 1920 i/g)
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local, ctime=Thu Oct 10 21:
  50:36 2004)
  /dev/wd0h on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid,
   ctime=Thu Oct 10 21:50:36 2004)
  /dev/wd0d on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid, 
  ctime=Thu Oct 10 21:50:36 2004)
  /dev/wd0g on /mnt/usr type ffs (rw, asynchronous, local, nodev, ctime=Th
  u Oct 10 21:50:36 2004)
  /dev/wd0e on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid, 
  ctime=Th u Oct 10 21:50:36 2004)
</pre></td></tr></table>

<p>
Du fragst dich wahrscheinlich, wieso dich das Installationsprogramm schon
wieder nach den ,mount points' fragt. Das erlaubt dir einfach Fehler oder
Probleme mit der bisherigen Auswahl auszuräumen. Der
Installationsprozess wird zum Beispiel doppelte ,mount points' einfach
löschen. Im disklabel-Programm kannst du solche Doppel-Eingaben
machen, und daher muss das überprüft werden. Eine solche
doppelte Nennung wird zu Partitionen ohne ,mount point' führen, denen
du dann neue ,mount points' zuweisen musst, wenn du den Platz darin
benutzen willst.

<p>
Wie du sehen kannst, lautet die vorgegebene Antwort auf die Frage
"Are you really sure that you are ready to proceed?" "no", du musst also
ausdrücklich "yes" antworten, damit das Programm weitermacht und
deine Partitionen formatiert. Wenn du das nicht tust, landest du wieder
in der Shell und könntest die Installation erneut starten, indem
du "install" eingibst oder einfach erneut mit deiner Boot Disk
bootest.

<p>
An diesem Punkt werden nun alle deine Dateisysteme formatiert. Wie lange
das dauert hängt von der Größe der Partitionen und der
Geschwindigkeit deiner Festplatte ab.

<a name="Hostname"></a>
<h3>4.5.3 - Den Hostnamen des Systems setzen</h3>
<p>
Du musst dem System nun seinen Hostnamen geben. Dieser Wert, neben dem DNS
domain name (<a href="#Network">weiter unten</a> angegeben), wird in der
Datei <tt>/etc/myname</tt>, die beim normalen Booten des Systems ausgelesen
wird, gespeichert.
Wenn du den FQDN des Systems nicht setzt, wird der vorgeschlagene Wert
,my.domain' benutzt.

<p>
Es ist wichtig diesen Namen jetzt zu setzen, da er beim ersten Booten
des Systems nach der Installation dabei benutzt wird, die
kryptographischen Schlüssel zu erzeugen. Dieses Erzeugen geschieht
unabhängig davon, ob das Netzwerk konfiguriert ist oder nicht.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Enter system hostname (short form, e.g. 'foo'): <b>puffy</b>
</pre></td></tr></table>

<a name="Network"></a>
<h3>4.5.4 - Das Netzwerk konfigurieren</h3>

<p>
Jetzt ist es an der Zeit dein Netzwerk zu konfigurieren. Das muss
unbedingt geschehen, wenn du eine FTP- oder NFS-basierte Installation
durchführen willst, da die Daten dazu notwendig sind. Hier
ein Beispieldurchlauf für die Netzwerk-Konfiguration.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Configure the network? [yes] <b><i>Enter</i></b>
  Available interfaces are: fxp0.
  Which one do you wish to initialize? (or 'done') [fxp0] <b><i>Enter</i></b>
  Symbolic (host) name for fxp0? [puffy] <b><i>Enter</i></b>
  The default media for fxp0 is
          media: Ethernet autoselect (100baseTX full-duplex)
  Do you want to change the default media? [no] <b><i>Enter</i></b>
  IP address for fxp0 (or 'dhcp')? <b>199.185.137.55</b>
  Netmask? [255.255.255.0] <b><i>Enter</i></b>
  Done - no available interfaces found.
  DNS domain name? (e.g. 'bar.com') [my.domain] <b>example.com</b>
  DNS nameserver? (IP address or 'none') [none] <b>199.185.137.1</b>
  Use the nameserver now? [yes] <b><i>Enter</i></b>
  Default route? (IP address, 'dhcp' or 'none') <b>199.185.137.128</b>
  add net default: gateway 199.185.137.128
  Edit hosts with ed? [no] <b><i>Enter</i></b>
  Do you want to do any manual network configuration? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Im obigen Beispiel nutzen wir eine statische IP Adresse. Wie angedeutet,
kannst du aber auch "<tt>dhcp</tt>" auf den meisten Plattformen (nicht
<a href="../de/alpha.html">Alpha</a>) auswählen, davon ausgehend, dass
deine Netzwerkumgebung es unterstützt. Im Falle von
DHCP werden die meisten dieser Daten von dem entfernten DHCP Server geholt;
du wirst eine Gelegenheit bekommen, das zu bestätigen.
Hier ist ein Beispiel des Netzwerkkonfigurationsteils der Installation,
dieses Mal mit DHCP:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Configure the network? [yes] <b><i>Enter</i></b>
  Available interfaces are: fxp0.
  Which one do you wish to initialize? (or 'done') [fxp0] <b><i>Enter</i></b>
  Symbolic (host) name for fxp0? [puffy] <b><i>Enter</i></b>
  The default media for fxp0 is
          media: Ethernet autoselect (100baseTX full-duplex)
  Do you want to change the default media? [no] <b><i>Enter</i></b>
  IP address for fxp0 (or 'dhcp')? <b>dhcp</b>
  Issuing hostname-associated DHCP request for fxp0.
  Sending on   Socket/fallback/fallback-net
  DHCPDISCOVER on fxp0 to 255.255.255.255 port 67 interval 1
  DHCPOFFER from 199.185.137.128
  DHCPREQUEST on fxp0 to 255.255.255.255 port 67
  DHCPACK from 199.185.137.128
  New Network Number: 199.185.137.0
  New Broadcast Address: 199.185.137.255
  bound to 199.185.137.55 -- renewal in 43200 seconds.
  Done - no available interfaces found.
  DNS domain name? (e.g. 'bar.com') [example.org] <b><i>Enter</i></b>
  DNS nameserver? (IP address or 'none') [199.185.137.1] <b><i>Enter</i></b>
  Use the nameserver now? [yes] <b><i>Enter</i></b>
  Default route? (IP address, 'dhcp' or 'none') [199.185.137.128] <b><i>Enter</i></b>
  Edit hosts with ed? [no] <b><i>Enter</i></b>
  Do you want to do any manual network configuration? [no] <b><i>Enter</i></b>
</pre></td></tr></table>
<p>
<b>HINWEIS: </b>Nur <b>ein</b> Interface kann während der
Installation einfach mit DHCP konfiguriert werden. Es wird Fehler geben,
wenn du das mehrmals versuchst. Die anderen Interfaces musst du dann
nach der Installation per Hand konfigurieren.

<p>
Nun setzen wir das Passwort für den root Account:
<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
Password for root account? (will not echo) <b><i>pAssWOrd</i></b>
Password for root account? (again) <b><i>pAssWOrd</i></b>
</pre></td></tr></table>
<p>
Verwende ein sicheres Passwort für den root Account. Du wirst weitere
Benutzerkonten anlegen, wenn das System gebootet wurde. Aus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=passwd&amp;sektion=1">passwd(1)</a>:
<pre>
    The new password should be at least six characters long and not purely
    alphabetic.  Its total length must be less than _PASSWORD_LEN (currently
    128 characters).  A mixture of both lower and uppercase letters, numbers,
    and meta-characters is encouraged.
</pre>

<a name="InstMedia"></a>
<h3>4.5.5 - Das Installationsmedium auswählen</h3>

<p>
Nachdem dein Netzwerk eingerichtet ist, hast du die Chance deine
Einstellungen per Hand zu justieren. Danach werden die erzeugten
Dateisysteme gemountet und ein Passwort für den Benutzer root
gesetzt. Nun sind deine lokalen Festplatten bereit für die Aufnahme
der OpenBSD Datei Sets.

<p>
Danach bekommst du die Chance dein Installationsmedium auszuwählen.
Die Optionen sind unten aufgelistet.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  You will now specify the location and names of the install sets you want to
  load. You will be able to repeat this step until all of your sets have been
  successfully loaded. If you are not sure what sets to install, refer to the
  installation notes for details on the contents of each.
 
  Sets can be located on a (m)ounted filesystem; a (c)drom, (d)isk or (t)ape
  device; or a (f)tp, (n)fs or (h)ttp server.
  Where are the install sets? <b>c</b>
  Available CD-ROMs are: cd0.
</pre></td></tr></table>

<p>
In diesem Beispiel installierst du von CD-ROM. Dazu wird eine Liste von
Geräten erzeugt, die auf deiner Maschine als CD-ROM identifiziert
wurden. Die meisten Leute haben aber nur eins. Wähle einfach
das Gerät aus, von dem aus du OpenBSD installieren willst.

<p>
<b>HINWEIS: </b>Alle möglichen Quellen für Installations-Sets
werden aufgelistet, aber es sind nicht unbedingt alle auf deinem System
verfügbar. <tt>(n)fs</tt> z.B. wird zwar angezeigt, aber nicht alle
Architekturen erlauben auch solche Installationen. Eine Fehlermeldung
und eine weitere Chance ein anderes Medium zu wählen folgen,
nachdem du eines ausgewählt hast, das nicht zur Verfügung
steht.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available CD-ROMs are: cd0.
  Which one contains the install media? (or 'done') [cd0] <b><i>Enter</i></b>

  Pathname to the sets? (or 'done') [3.6/i386] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Hier wirst du gefragt, in welchem Verzeichnis sich die Datei Sets
befinden, auf der offiziellen CD-ROM ist das <i>3.6/i386/</i>.

<a name="Filesets"></a>
<h3>4.5.6 - Datei Sets auswählen</h3>

<p>
Nun ist es an der Zeit, auszuwählen, welche Datei Sets du haben willst.
Eine Beschreibung dieser Pakete findest du im <a href="#FilesNeeded">
nächsten Abschnitt</a>. Die Dateien, die das Installationsprogramm
findet, werden auf dem Bildschirm angezeigt.
Deine Aufgabe ist es, anzugeben, welche Dateien du haben willst.
Standardmäßig sind bis auf die X-Datei Sets alle markiert, manche
Leute wollen aber wirklich nur das absolute Minimum haben, mit dem
OpenBSD noch funktioniert, also <i>base36.tar.gz</i>, <i>etc36.tar.gz</i>
und <i>bsd</i>.
Andere wiederum wollen alle Datei Sets haben. Das Beispiel unten zeigt eine
komplette Installation mit allen Paketen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  The following sets are available. Enter a filename, 'all' to select
  all the sets, or 'done'. You may de-select a set by prepending a '-'
  to its name.

          [ ] bsd.rd
          [X] base36.tgz
          [X] etc36.tgz
          [X] misc36.tgz
          [X] comp36.tgz
          [X] man36.tgz
          [X] game36.tgz
          [ ] xbase36.tgz
          [ ] xshare36.tgz
          [ ] xfont36.tgz
          [ ] xserv36.tgz
          [X] bsd

  File Name? (or 'done') [bsd.rd] <b>all</b>

  The following sets are available. Enter a filename, 'all' to select
  all the sets, or 'done'. You may de-select a set by prepending a '-'
  to its name.

          [X] bsd.rd
          [X] base36.tgz
          [X] etc36.tgz
          [X] misc36.tgz
          [X] comp36.tgz
          [X] man36.tgz
          [X] game36.tgz
          [X] xbase36.tgz
          [X] xshare36.tgz
          [X] xfont36.tgz
          [X] xserv36.tgz
          [X] bsd
</pre></td></tr></table>

<p>
Du kannst hier alle möglichen Sachen machen -- <tt>-x*</tt> zum
Beispiel würde alle X-Komponenten entfernen, falls du es dir nochmal
anders überlegst. In diesem Fall wollen wir aber alle Sets. Wenn das
System auch mit viel weniger Sets läuft, ist der empfohlene Weg,
entweder die standardmäßigen Vorgaben oder alles zu
installieren. Weitere Details zum Auswählen der Sets befinden sich
<a href="#FilesNeeded">hier</a>.

<p>
Nachdem du deine gewünschten Datei Sets ausgewählt hast, wirst
du noch einmal gefragt, ob du die gewählten Datei Sets wirklich
entpacken willst, und dann werden sie installiert.
Es wird ein Fortschrittsbalken angezeigt, der dir zeigt, wie lange das ganze
noch etwa dauert. Die Dauer hängt natürlch stark von der
Geschwindigkeit deines Systems ab, den Datei Sets, die du installieren willst,
und der Geschwindigkeit des Installationsmediums. Somit liegt die Dauer
irgendwo zwischen ein paar Minuten und ein paar Stunden, je nachdem.

<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  File Name? (or 'done') [done] <b><i>Enter</i></b>
  Ready to install sets? [yes] <b><i>Enter</i></b>

  Getting bsd ...
  100% |**************************************************|  5232 KB    00:08    
  Getting bsd.rd ...
  100% |**************************************************|  4614 KB    00:02    
  Getting bsd.mp ...
  100% |**************************************************|  5285 KB    00:03    
  Getting base36.tgz ...
  100% |**************************************************| 31396 KB    00:22    
  Getting etc36.tgz ...
  100% |**************************************************|  1655 KB    00:01    
  Getting misc36.tgz ...
  100% |**************************************************|  2193 KB    00:01    
  Getting comp36.tgz ...
  100% |**************************************************| 18232 KB    00:15    
  Getting man36.tgz ...
  100% |**************************************************|  6792 KB    00:05    
  Getting game36.tgz ...
  100% |**************************************************|  2536 KB    00:01    
  Getting xbase36.tgz ...
  100% |**************************************************| 10121 KB    00:07    
  Getting xetc36.tgz ...
  100% |**************************************************|   430 KB    00:00    
  Getting xshare36.tgz ...
  100% |**************************************************|  1888 KB    00:02    
  Getting xfont36.tgz ...
  100% |**************************************************| 31742 KB    00:22    
  Getting xserv36.tgz ...
  100% |**************************************************| 15460 KB    00:11    

  Sets can be located on a (m)ounted filesystem; a (c)drom, (d)isk or (t)ape
  device; or a (f)tp, (n)fs or (h)ttp server.
  Where are the install sets? (or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
An dieser Stelle hast du die Möglichkeit, weitere Dateien von anderen
Quellen zu installieren (inklusive <a href="#site">individuellen Datei
Sets</a>), wenn du das möchtest oder gib ,<tt>done</tt>' ein, wenn du
alle Datei Sets installiert hast, die du benötigst.

<a name="Finish"></a>
<h3>4.5.7 - Zum Ende kommen</h3>

Als nächstest werden dir einige Fragen bezüglich der
Einstellungen deines installierten Systems gestellt.
Die erste ist, ob
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
beim Hochfahren gestartet werden soll.
Üblicherweise möchtest du, dass sshd(8) läuft, aber
gelegentlich vielleicht auch nicht. Wenn deine Verwendung keinen Gebrauch
für sshd(8) hat, liegt ein kleiner theoretischer Sicherheitsvorteil
vor, wenn es nicht läuft.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
Started sshd(8) by default? [yes] <b>y</b>
</pre></td></tr></table>

<p>
Du wirst nun gefragt werden, ob du auf dem System X laufen lassen willst.
Wenn du mit ,Y' antwortest, wird die Datei <tt>/etc/sysctl.conf</tt>
so modifiziert, dass die Zeile <tt>machdep.allowaperture=1</tt> oder
<tt>machdep.allowaperture=2</tt> darinsteht, abhängig von deiner
Plattform. Einige Plattformen werden diese Frage überhaupt nicht
stellen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you expect to run the X Window System? [yes] <b>y</b>
</pre></td></tr></table>

<p>
Als nächstes wirst du gefragt, ob du eine
<a href="../faq7.html#SerCons">serielle Konsole</a> an diesem Computer
anstatt von einer Standard Tastatur und einem Monitor betreiben willst.
Wenn du "<tt>yes</tt>" auswählst und ein paar weitere einfache Fragen beantwortest,
werden
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8">/etc/boot.conf</a></tt>
und 
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5">/etc/ttys</a></tt>
automatisch für dich angepasst.
Die meisten User werden hier jedoch die Voreinstellung <b><tt>no</tt></b> verwenden.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Change the default console to com0? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Deine letzte Aufgabe ist es, deine entsprechende Zeitzone einzustellen.
Abhängig davon, wo deine Maschine steht, kann es mehrere richtige
Antworten geben. Im folgenden Beispiel benutzen wir <tt>US/Eastern</tt>,
könnten aber auch <tt>EST5EDT</tt> oder <tt>US/Michigan</tt> benutzen
und zum selben Ergebnis kommen. Wenn man <tt>?</tt> drückt, bekommt
man eine Liste mit möglichen Auswahlen.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Saving configuration files......done.
  Generating initial host.random file ......done.
  What timezone are you in? ('?' for list) [US/Pacific] <b>?</b>
  Africa/      Chile/       GB-Eire      Israel       NZ-CHAT      Turkey
  America/     Cuba         GMT          Jamaica      Navajo       UCT
  Antarctica/  EET          GMT+0        Japan        PRC          US/
  Arctic/      EST          GMT-0        Kwajalein    PST8PDT      UTC
  Asia/        EST5EDT      GMT0         Libya        Pacific/     Universal
  Atlantic/    Egypt        Greenwich    MET          Poland       W-SU
  Australia/   Eire         HST          MST          Portugal     WET
  Brazil/      Etc/         Hongkong     MST7MDT      ROC          Zulu
  CET          Europe/      Iceland      Mexico/      ROK          posix/
  CST6CDT      Factory      Indian/      Mideast/     Singapore    posixrules
  Canada/      GB           Iran         NZ           SystemV/     right/
  What timezone are you in? ('?' for list) [US/Pacific] <b>US</b>
  What sub-timezone of 'US' are you in? ('?' for list) <b>?</b>
  Alaska          Central         Hawaii          Mountain        Samoa
  Aleutian        East-Indiana    Indiana-Starke  Pacific
  Arizona         Eastern         Michigan        Pacific-New
  Select a sub-timezone of 'US' ('?' for list): <b>Eastern</b>
  Setting local timezone to 'US/Eastern'...done
</pre></td></tr></table>

Wenn du auf besonders genaue Zeitangaben aus bist, möchtest du vielleicht
<a href="faq8.html#NTPerror">das hier</a> lesen.

<p>
Die letzten Schritte für das System sind das Erzeugen des
<tt>/dev</tt> Verzeichnisses (was auf manchen Maschinen ganz
schön lange dauert, insbesondere, wenn du nur wenig RAM besitzt)
und das Installieren des Boot-Blocks.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Making all device nodes...done.
  Installing boot block...
  boot: /mnt/boot
  proto: /usr/mdec/biosboot
  device: /dev/rwd0c
  /usr/mdec/biosboot: entry point 0
  proto bootblock size 512
  /mnt/boot is 3 blocks x 16384 bytes
  fs block shift 2; part offset 3069360; inode block 152, offset 4136
  using MBR partition 1: type 166 (0xa6) offset 3069360 (0x2ed5b0)
  done.

  CONGRATULATIONS! Your OpenBSD install has been successfully completed!
  To boot the new system, enter halt at the command prompt. Once the
  system has halted, reset the machine and boot from the disk.
  # <b>halt</b>
  syncing disks... done

  The operating system has halted.
  Please press any key to reboot.
</pre></td></tr></table>

<p>
OpenBSD ist jetzt auf deinem System installiert und bereit für den
ersten Boot, aber vorher..

<p>

<h4>Bevor du erneut bootest</h4>
Nun ist dein System also installiert und fertig zum ersten Booten,
um danach noch konfiguriert zu werden. Zuvor wäre es allerdings
weise, die <a href="../../de/errata.html">Errata Seite</a> zu
überprüfen, ob es nicht irgendwelche Bugs gibt, die
dich sofort betreffen könnten.

<h4>Nach dem Neustart</h4>

<p>
Eines der ersten Dinge, die du nach der Installation lesen solltest, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=afterboot&amp;sektion=8">afterboot(8)</a>.

<p>
Die folgenden Links könnten ebenfalls recht nützlich sein:
<ul>
<li><a href="../faq10.html#AddDelUser">Benutzer in OpenBSD hinzufügen</a>
<li><a href="faq6.html#Setup">Erste Netzwerk-Konfiguration</a>
<li><a href="faq2.html#ManPages">Manual Seiten von nützlichen/häufigen Befehlen</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD Manual Seiten im Web</a>
<li><a href="../../de/ports.html">Das OpenBSD Ports und Packages System
zum Installieren von Software</a>, genauso
<a href="../faq8.html#Ports">hier</a> und <a href="../faq8.html#Packages">hier</a>
</ul>

<h4>Noch eine Sache...</h4>
Die OpenBSD Entwickler bitten dich darum,
<a href="#SendDmesg">eine Kopie deiner dmesg einzuschicken</a>. Das hilft
den Entwicklern und schlussendlich auch den Anwendern.

<p>
<a name= "FilesNeeded"></a>
<h2>4.6 - Welche Dateien werden zur Installation benötigt?</h2>
<!-- XXXrelease -->

<p>
Die komplette OpenBSD Installation ist in eine Vielzahl einzelner
<i>Datei Sets</i> aufgeteilt. Nicht jede Verwendung verlangt nach jedem
Datei Set.  Hier ist eine Übersicht:
<p>
<ul>
  <li><b><i>bsd</i></b>          - Dies ist der Kernel. <b>Zwingend notwendig</b>
  <li><b><i>bsd.mp</i></b> - Multi-Prozessor (SMP) Kernel (nur auf einigen
     Plattformen)
  <li><b><i>bsd.rd</i></b> - <a href="#bsd.rd">RAM Disk Kernel</a>
  <li><b><i>base36.tgz</i></b>   - Enthät das Basis-System von OpenBSD
    <b>Zwingend notwendig</b>
  <li><b><i>etc36.tgz</i></b>    - Enthält alle Dateien in /etc
    <b>Zwingend notwendig</b>
  <li><b><i>comp36.tgz</i></b>    - Enthält den Compiler und alle seine
    Anwendungen, ,headers' und Bibliotheken. <b>Empfohlen</b>
  <li><b><i>man36.tgz</i></b>    - Enthält alle Manual Seiten
    <b>Empfohlen</b>
  <li><b><i>misc36.tgz</i></b>   - Enthält alle misc info und setup
    Dokumentationen
  <li><b><i>game36.tgz</i></b>   - Enthält die Spiele für OpenBSD
  <li><b><i>xbase36.tgz</i></b>  - Enthält die Basis-Installation
    für X11
  <li><b><i>xfont36.tgz</i></b>  - Enthält den X11 Font-Server und Fonts
  <li><b><i>xserv36.tgz</i></b>  - Enthält die X11 X Server
  <li><b><i>xshare32.tgz</i></b> - Enthält Manual Seiten, lokale
    Einstellungen, ,includes', etc. für X
</ul>

Die <b>etc36.tgz</b> und <b>xetc36.tgz</b> Sets werden nicht als Teil eines
Upgrades installiert, sondern nur als Teil einer kompletten Installation,
so dass jegliche Änderungen, die du vorgenommen hast, nicht verloren
gehen.
Du musst deine <tt>/etc</tt>, <tt>/dev</tt> und <tt>/var</tt> Verzeichnisse
manuell aktualisieren.

<p>
<a name= "SpaceNeeded"></a>
<h2> 4.7 - Wieviel Platz brauche ich für eine OpenBSD Installation?</h2>
<!-- XXXrelease -->

<p>
Die folgenden Angaben sind die minimalen Platzbedürfnisse für
eine Vollinstallation. Die Zahlen enthalten genug Platz, um dir ein
typisches Heim-System zu ermöglichen, das mit dem Internet
verbunden ist.

<ul>
<li>Dies sind Minimum-Werte.
<li>Wenn du planst, eine Menge Software von dritter Seite zu installieren,
wähle deine <tt>/usr</tt> Partition groß! Du solltest diese Werte
<b>mindestens</b> verdreifachen!
<li>Für ein System, das eine Menge E-Mails oder Web-Seiten handhabt (die
in <tt>/var/mail</tt> und <tt>/var/www</tt> gespeichert werden), solltest du
deine <tt>/var</tt> Partition bedeutend vergrößern oder lege sie auf
separate Partitionen.
<li>Für ein Mehrbenutzer-System, das eine Menge Logs erzeugt,
solltest du deine <tt>/var</tt> Partition noch größer
wählen (<tt>/var/log</tt>).
<li>Wenn du planst, den Kernel oder das ganze System aus dem Source neu zu
erzeugen, sollte deine <tt>/usr</tt> Partition deutlich größer
ausfallen, <b>mindestens</b> 800M-1G größer als unten angegeben.
</ul>

Behalte bitte im Auge, dass <tt>/usr</tt> und <tt>/usr/X11R6</tt> im
Normalfall Teile des selben Dateisystems sind, nämlich <tt>/usr</tt>,
und dass es keinen Vorteil bringt, sie in getrennte Dateisysteme zu verlegen.

<blockquote>
<pre>
<b>
SYSTEM          /       /usr    /var    /usr/X11R6
alpha           80M     250M    25M     140M
hp300           80M     250M    25M     140M
hppa           100M     200M    25M     120M
i386            60M     250M    25M     140M
mac68k          80M     250M    25M     100M
macppc          80M     250M    25M     140M
mvme68k         80M     250M    25M     100M
sparc           80M     250M    25M     120M
sparc64         80M     250M    25M     100M
vax            100M     200M    25M     180M
</b>
</pre>
</blockquote>

Zusätzlich wird empfohlen, dass man eine <tt>/tmp</tt> Partition benutzt.
Die <tt>/tmp</tt> Partition wird beim Kompilieren von Ports und anderen
Dingen benutzt, die Größe hängt also davon ab, was du damit
machen willst. 50MB mag für viele Leute viel sein, aber einige
große Applikationen brauchen 100MB und mehr <tt>/tmp</tt> Platz.

<p>
Wenn du im disklabel-Editor bist, kannst du dich entschließen,
deinem System nur ein ,a' (Haupt-Dateisystem) und ,b' (Swap) zu
geben. Das ,a' Dateisystem, das du in disklabel als deine
root-Partition eintragen willst, sollte die Summe aller 3 Haupt-Werte
oben haben (<tt>/</tt>, <tt>/usr</tt>, und <tt>/var</tt>) plus etwas
Extra-Platz für <tt>/tmp</tt>. Die ,b' Partition, die du aufsetzt,
wird automatisch zur Swap-Partition -- wir empfehlen ein Minimum von 32MB,
aber wenn du genug Platz hast, mach wenigstens 64MB daraus. Wenn du aber
wirklich viel Plattenplatz hast, scheu dich nicht, dein Swap mit 256MB
oder sogar 512MB einzurichten.

<p>
Swap Platz wird verwendet, um ,core dumps' zu speichern, falls ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crash&amp;sektion=8">crash(8)</a>
auftritt.
Falls dies eine Überlegung von dir ist, sollte dein Swap Platz ein
wenig größer sein als der Speicherplatz des Hauptspeiches, den du
jemals in deinem System verwenden wirst. Bedenke, dass beim Neustart
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8">savecore(8)</a>
versucht, den Inhalt der Swap Partition in eine Datei unter
<tt>/var/crash</tt> zu speichern, also wieder einmal, wenn dies wichtig
für dich ist, sollte deine <tt>/var</tt> Partition über genug
<i>freien Speicher</i> verfügen, um diese ,dump' Dateien halten zu
können.

<p>
Es gibt mehrere Hauptgründe anstelle von nur ein oder zwei
Dateisystemen mehr separate Dateisysteme zu benutzen:

<ul>
<li><b>Sicherheit</b>: Du kannst einige Dateisysteme als ,nosuid', ,nodev',
  ,noexec', ,readonly', etc. markieren. Das wird jetzt vom
   Installationsprozess erledigt, wenn du die oben beschriebenen Partitionen
   benutzt.
<li><b>Stabilität</b>: Ein Anwender oder amoklaufendes Programm kann ein
  Dateisystem mit Müll auffüllen, wenn sie darauf Schreibrechte
  haben. Deine kritischen Programme, dann natürlich auf einem anderen
  Dateisystem laufend, werden nicht unterbrochen.
<li><b>Geschwindigkeit</b>: Ein Dateisystem, in das dauernd
  hineingeschrieben wird, kann schnell fragmentieren. (Glücklicherweise
  ist das ffs-Dateisystem, das von OpenBSD benutzt wird, nicht für
  sowas anfällig.)
<li><b>Integrität</b>: Wenn ein Dateisystem aus irgendeinem Grund defekt
  ist, sind deine anderen Dateisysteme immer noch OK.
<li><b>Größe</b>: Viele Maschinen haben Grenzen in Bezug auf den
  Ort, von dem aus das ROM den Kernel laden kann. In einigen Fällen
  kann das Limit sehr klein sein (504M für ältere 486), in
  anderen Fällen ist das Limit recht groß (zum Beispiel 2G, 8G
  oder 128G auf i386 Systemen). Da sich der Kernel irgendwo in der
  root-Partition befinden kann, muss die gesamte root-Partition innerhalb
  dieser Grenze liegen. Mehr Details gibt es in <a
  href="../faq14.html#LargeDrive">diesem Kapitel</a>. Eine gute Richtlinie
  ist, deine / Partition einfach komplett unterhalb der ersten 2GB zu lassen,
  es sei denn, du weißt, dass deine Plattform (und besonders deine
  Maschine!) damit umgehen kann.
</ul>

<p>
Noch ein paar Gedanken zur Partitionierung:
<ul>
 <li>Bei deinem ersten Versuch und einem experimentellen System ist eine
   große <tt>/</tt> Partition und Swap das einfachste, bis du
   weißt, wieviel Platz du brauchst. Dadurch wirst du einige der
   Standard-Sicherheitsmechanismen opfern, die OpenBSD bietet, die
   separate  Dateisysteme für <tt>/, /tmp, /var, /usr</tt> und
   <tt>/home</tt> benötigen.
 <li>Ein sich im Internet befindliches oder anderweitig angreifbares System
   sollte eine separate Partition für <tt>/var</tt> haben (und vielleicht
   sogar eine separate für <tt>/var/log</tt>) für die Logdateien.
 <li>Eine <tt>/home</tt> Partition ist durchaus nützlich. Neue Version
   des OS? Alles andere löschen und neu machen, aber die <tt>/home</tt>
   Partition einfach unberührt lassen. Denke aber trotzdem daran,
   eine Sicherungskopie deiner Konfigurationsdateien anzulegen!
 <li>Eine separate Partition für alles, was eine große Anzahl
   Dateien erzeugen kann, kann man gegebenenfalls schneller formatieren und
   neu anlegen, als alle Dateien zu löschen. Siehe auch die <a
   href="../upgrade-minifaq.html#1.5">upgrade-minifaq</a> für ein
   Beispiel (<tt>/usr/obj</tt>).
 <li>Wenn du dein System aus irgendeinem Grund aus dem Quellcode neu
   erzeugen willst, sollte der Source sich in <tt>/usr/src</tt> befinden.
   Wenn du kein separates Dateisystem für <tt>/usr/src</tt> hast, dann
   sorge unbedingt dafür, dass du in <tt>/usr</tt> genug Platz hast.
 <li>Ein oftmals vergessener Punkt: du musst auf deinem System <b>nicht</b>
   allen Platz sofort vergeben! Da du jetzt vermutlich kaum noch eine
   Festplatte unter 20GB finden wirst, kann es durchaus Sinn machen,
   einfach ein bisschen Platz zu lassen. Wenn dir dann eine Partition zu klein
   wird, kannst du dann einfach aus deinem ungenutzten Platz eine neue
   Partition erstellen, deine existierende Partition auf die neue
   <a href="../faq10.html#DupFS">duplizieren</a>, die
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab</a>
   ändern und auf die neue Partition verweisen lassen, neu mounten,
   und schon hast du mehr Platz.
 <li>Wenn du deine Partitionen zu klein wählst, wirst du das
   vermutlich spälter bereuen, wenn es an der Zeit ist, dein System
   auf den neuesten Stand zu bringen.
 <li>Wenn du deinen Benutzern erlaubst auf <tt>/var/www</tt> zu schreiben
   (z.B. persönliche Webseiten), möchtest du es vielleicht auf
   eine separate Partition legen, so dass du <a
   href="faq10.html#Quotas">quotas</a> verwenden kannst, um den Speicher,
   den sie verwenden, zu begrenzen, und wenn sie die Partition füllen,
   keine anderen Teile des Systems betroffen sind.
</ul>


<p>
<a name= "Multibooting"></a>
<h2>4.8 - Multibooting OpenBSD/i386</h2>

Multibooting ist, wenn man mehrere Betriebssysteme auf einem Computer hat
und auf irgendeine Art und Weise auswählen kann, welches OS
gebootet werden soll. Das ist <i>keine</i> unbedeutende Aufgabe! Wenn du
nicht verstehst, was du da machst, könntest du am Ende große
Mengen an Daten von deinem Computer gelöscht haben. Neue OpenBSD
Benutzer werden <i>dringend</i> dazu geraten, mit einer leeren Festplatte
auf einer extra hierfür freigestellten Maschine anzufangen und dann
mit der gewünschten Konfiguration auf einer nicht im Einsatz
befindlichen Maschine zu üben, bevor eine Multiboot Konfiguration
auf einer eingesetzten Maschine versucht wird. <a href="faq14.html">FAQ
14</a> hat weitere Informationen über den OpenBSD Bootprozess.

<p>
Hier sind einige Optionen zum Multibooten:

<h3>Aktive Partitionen markieren</h3>
Dieses ist die wahrscheinlich am häufigsten übersehende und
doch ab und zu beste Lösung für das Multibooten. Markiere einfach
die aktive Partition in welchem OS auch immer du dich befindest so, dass
sie diejenige ist, die beim nächsten Booten standardmäßig
gebootet wird. So gut wie jedes OS bietet ein Programm, mit dem das
bewerkstelligt werden kann; OpenBSDs ist <a
href="faq14.html#fdisk">fdisk(8)</a>, ähnlich genannte Programme gibt
es unter Windows 9x und DOS, sowie in vielen anderen Betriebssystemen. Dies
kann sehr wünschenswert für Betriebssysteme oder Systeme sein,
die sehr lange zum Herunterfahren und Neustarten brauchen -- du kannst
sie markieren und das System neustarten, dann weggehen, eine Tasse Kaffee
holen und dann zum System wiederkehren, das so hochgefahren ist, wie du
es wolltest -- kein Warten auf den magischen Moment, wenn du das
nächste OS auswählen musst.

<h3>Boot Floppy</h3>
Wenn du ein System hast, das nicht häufig zum Booten von OpenBSD
verwendet wird (oder nicht möchtest, dass andere Benutzer des Computers
mitbekommen, dass sich irgendwas geändert hat), ziehe das Verwenden
einer Boot Floppy in Betracht. Verwende einfach eine der <a
href="#MkFlop">normalen OpenBSD Installationsdisketten</a> und erstelle
eine <tt>/etc/boot.conf</tt> Datei (ja, du musst außerdem ein
<tt>/etc</tt> Verzeichnis auf der Floppy anlegen) mit dem Inhalt:

<pre>
     boot hd0a:/bsd
</pre>

um das System zu veranlassen, von Festplatte 0, OpenBSD Partition ,a',
Kernel Datei <tt>/bsd</tt> zu booten. Denke daran, dass du auch von
anderen Laufwerken booten kannst mit einer Zeile wie:
"<tt>boot hd2a:/bsd</tt>" von der dritten Festplatte deines Systems.
Um OpenBSD zu booten, lege die Floppy ein und starte neu.
Um das andere OS zu booten, nehme die Floppy aus dem Laufwerk und starte
neu.

<p>
In diesem Fall wird das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
Programm geladen, sucht nach <tt>/etc/boot.conf</tt> und ließt sie
aus. Die Zeile "<tt>boot hd0a:/bsd</tt>" weist boot(8) zu, von wo aus der
Kernel geladen werden soll -- in diesem Fall von der ersten HD, die das
BIOS sieht. Behalte im Hinterkopf, dass nur eine kleine Datei
(<tt>/boot</tt>) von der Floppy geladen wird -- das System lädt den
gesamten Kernel von der Festplatte, so dass ungefähr nur fünf
Sekunden zum Bootprozess hinzugefügt werden.

<p>
<strong>OpenBSD und Windows NT/2000/XP</strong>

<p>
Um OpenBSD und Windows NT/2000/XP starten zu können, kannst du den
NTLDR, den Bootloader von NT, benutzen. Um mit NT einen Multiboot
durchführen zu können, benötigst du
eine Kopie des OpenBSD Partition Boot Record (PBR).
Nach dem Ausführen von installboot kannst du ihn mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
in eine Datei kopieren:

<pre>
	# <strong>dd if=/dev/rsd0a of=openbsd.pbr bs=512 count=1</strong>
</pre>

<p>
Starte nun NT und platziere <tt>openbsd.pbr</tt> auf C:. Füge eine
Zeile wie folgende am Ende von <tt>C:\BOOT.INI</tt> ein:

<pre>
	c:\openbsd.pbr="OpenBSD"
</pre>

<p>
Nach einem Neustart solltest du OpenBSD im NT Loader Menü
auswählen können. Zum NTLDR gibt es im
<a href="http://www.tburke.net/info/ntldr/ntldr_hacking_guide.htm">NTLDR
Hacking Guide</a> mehr Informationen.

<p>
Auf Windows XP kannst du die Bootinformationen auch mit Hilfe der GUI
editieren; siehe auch das
<a href="http://support.microsoft.com/default.aspx?scid=kb;EN-US;q289022">
XP Boot.ini HOWTO</a>.

<p>
Programme, die vieles von diesen Tätigkeiten dir abnehmen stehen zur
Verfügung, zum Beispiel <a
href="http://www.winimage.com/bootpart.htm">BootPart</a>.
Dieses Programm kann unter Windows NT/2000/XP ausgeführt werden und
lädt den OpenBSD PBR, platziert ihn auf deine NT/2000/XP Partition und
fügt ihn zur <tt>C:\BOOT.INI</tt> hinzu.

<p>
<!-- XXXVersion: issue "expires" after last 3.4 systems are upgraded. -->
Die OpenBSD Installation und der Upgrade Prozess installieren den OpenBSD
<a href="faq14.html#Boot386">Bootloader</a>, dessen Pfad im PBR
eingetragen ist, so, dass du, wenn du deine OpenBSD Installation
neuinstallierst oder aktualisierst, den oben angegebenen Prozess wiederholen
musst, damit eine neue Kopie des OpenBSD PBR geladen wird.

<p>
Hinweis: Der Windows NT/2000/XP Bootloader ist nur in der Lage,
Betriebssysteme von der primären Festplatte zu booten.
Du kannst ihn nicht verwenden, um OpenBSD von der zweiten Festplatte zu
laden.

<h3>Andere Bootloader</h3>

<p>
Zu einigen anderen Bootloadern, die von OpenBSD Anwendern erfolgreich
eingesetzt worden sind, gehöhren
<a href="http://gag.sourceforge.net/">GAG</a>,
OS-BS,
<a href="http://www.ranish.com/part/">The Ranish Partition Manager</a>
und <a href="http://www.gnu.org/software/grub/">GRUB</a>.

<p>
<h3>OpenBSD und Linux (i386)</h3>
<!-- XXXversion -->

<p>
Bitte lies dir
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.6/i386/INSTALL.linux">INSTALL.linux</a>
durch, um genaue Informationen zur Zusammenarbeit zwischen OpenBSD und
Linux zu bekommen.

<a name= "SendDmesg"></a>
<h2>4.9 - Nach der Installation deine dmesg an dmesg@openbsd.org schicken</h2>

<p>
Um es nochmal allen ins Gedächtnis zu rufen: Es ist wichtig für
die OpenBSD-Entwickler im Auge zu behalten, welche Art von Hardware
funktioniert, und welche eben nicht perfekt funktioniert.

<p>
Ein Zitat aus /usr/src/etc/root/root.mail
<pre>
If you wish to ensure that OpenBSD runs better on your machines, please do us
a favor (after you have your mail system configured!) and type something like:
 # dmesg | mail -s "Sony VAIO 505R laptop, apm works OK" dmesg@openbsd.org
so that we can see what kinds of configurations people are running.  As shown,
including a bit of information about your machine in the subject or the body
can help us even further.  We will use this information to improve device driver
support in future releases.  (Please do this using the supplied GENERIC kernel,
not for a custom compiled kernel, unless you're unable to boot the GENERIC
kernel).  The device driver information we get from this helps us fix existing
drivers. Thank you!
</pre>

<p>
Stelle sicher, dass du nicht nur E-Mail von deinem Konto senden, sondern
auch empfangen kannst, für den Fall, dass dich ein Entwickler
kontaktieren will, um etwas zu testen oder um deine Konfiguration zum
Laufen zu bringen. Es ist nicht wichtig, dass du die E-Mail von einem
Rechner mit OpenBSD verschickst, wenn also dieser Rechner keine E-Mail
empfangen kann, dann gib einfach

<pre>
$ dmesg | mail your-account@yourmail.dom
</pre>
ein und leite dann diese Nachricht weiter an
<pre>
 dmesg@openbsd.org
</pre>
wobei <tt>your-account@yourmail.dom</tt> dein regulärer Email-Account
ist.
(oder transferiere die dmesg Ausgabe mittels FTP/scp/floppydisk/carrier-pigeon/...)

<p>
<strong>ANMERKUNG</strong> - Bitte schicke nur GENERIC Kernel dmesgs.
Eigenkompilierte Kernel sind nicht hilfreich, wenn Gerätetreiber fehlen.

<p>
Bedenke auch, dass die dmesgs von einem Computer erhalten werden, der das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=spamd&amp;sektion=8">spamd</a>
Spam Blocker System einsetzt.
Dies könnte dazu führen, dass deine dmesg vom Mail Server für
eine gewisse Zeit nicht angenommen wird.
Habe Geduld, nach einer halben Stunde, Stunde oder so wird sie durchkommen.

<a name="AddFileSet"></a>
<h2>4.10 - Ein Datei Set nach der Installation hinzufügen</h2>
<!-- XXXversion -->
"Oh nein!  Ich habe bei der Installation eines der Datei Sets vergessen!"
<p>
Manchmal merkt man, dass man <tt>comp36.tgz</tt> (oder irgendeine andere
Systemkomponente) DOCH benötigt, erst nachdem man mit der
Installation schon fertig ist.  Kein Problem: Es gibt zwei einfache Wege,
diese Komponenten aus der Installation noch nachträglich einzuspielen:

<h3>Indem man den Upgrade Prozess benutzt</h3>
Boote einfach von deinem Installationsmedium (CD-ROM oder Floppy) und
wähle "Upgrade" (und nicht Install).  Wenn du zur Liste mit den
Datei Sets kommst, wähle die Sets, die du beim ersten Mal vergessen
hast, wähle deine Quelle aus und lass die Installation beginnen.

<h3>Indem man tar(1) benutzt</h3>
Die Installationsdateien sind einfach komprimierte tar Dateien und du
kannst sie dementsprechend am root (/) des Dateisystems auspacken:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # cd /
  # tar xzvpf comp36.tgz
</pre></td></tr></table>

<p>
Du darfst NICHT die <tt>,p'</tt> Option im oben genannten Kommando vergessen,
sonst werden die Dateirechte nicht richtig erzeugt!
<p>
Ein häufig gemachter Fehler ist, zu denken, man könne 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1">pkg_add(1)</a>
benutzen, um fehlende Datei Sets einzuspielen. Das funktioniert aber nicht.
pkg_add(1) ist für package Dateien, nicht einfache tar Dateien wie die
Installations-Sets.
<p>


<a name="bsd.rd"></a>
<h2>4.11 - Was ist ,bsd.rd'?</h2>

<b><tt>bsd.rd</tt></b> ist ein "RAM Disk" Kernel.  Diese Datei kann sehr
nützlich sein; viele Entwickler lassen sie mit Absicht immer im
Quellverzeichnis ihres Dateisystems.

<p>
Ihn einen "RAM Disk Kernel" zu nennen, beschreibt das root Dateisystem
des Kernels -- es ist kein physikalisches Laufwerk, die Werkzeuge,
die nach dem Booten von <tt>bsd.rd</tt> nutzbar sind, befinden sich im
Kernel und werden aus einem RAM-basierten Dateisystem geladen.
<tt>bsd.rd</tt> enthält auch ein brauchbares Set an Werkzeugen für
System-Wartung und Installation.

<p>
Auf manchen Plattformen ist <tt>bsd.rd</tt> sogar die bevorzugte
Installationstechnik. Du plazierst diesen Kernel in ein vorhandenes
Dateisystem, bootest ihn und führst daraus die Installation aus. Auf den
meisten Plattformen kannst du, falls du eine ältere Version von OpenBSD
hast, eine neue Version von <tt>bsd.rd</tt> per FTP holen, davon booten und
eine neue Version von OpenBSD installieren, ohne eine Floppy oder CD-ROM zu
benutzen.

<p>
Hier zum Beispiel das Booten von <tt>bsd.rd</tt> auf einem i386 System:

<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Using Drive: 0 Partition: 3
  reading boot.....
  probing: pc0 com0 com1 apm mem[639k 255M a20=on]
  disk: fd0 hd0
  &gt;&gt; OpenBSD/i386 BOOT 2.02
  boot&gt; <b>boot hd0a:/bsd.rd</b>
<i>. . . normal boot to install . . .</i>
</pre></td></tr></table>

Wie schon gesagt, wirst du in das Installationsprogramm geführt, aber
du kannst natürlich auch auf die Shell gehen, um dein System zu pflegen
oder zu administrieren.
<p>
Die einfache Regel, um <tt>bsd.rd</tt> booten zu können, lautet:
Tausche <tt>/bsd</tt> durch <tt>bsd.rd</tt> aus, was auch immer das auf
deiner Plattform heißen mag.
<p>
<br>

<a name="InstProb"></a>
<h2>4.12 - Allgemeine Installationsprobleme</h2>

<a name="cpq16m"></a>
<h3>4.12.1 - Mein Compaq erkennt nur 16M RAM</h3>
<i>Einige</i> Compaq Systeme haben das Problem, dass der gesamte System RAM
vom <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">OpenBSD
,second stage' Bootloader</a> nicht ordentlich erkannt wird und nur 16M
erkannt und von OpenBSD verwendet werden. Dies kann entweder durch das
Erstellen/Editieren von der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"><tt>/etc/boot.conf</tt></a>
oder durch das Eingeben von Befehlen am "<tt>boot></tt>" Prompt, bevor
OpenBSD lädt, behoben werden. Falls du eine Maschine mit 64M RAM hast,
aber OpenBSD nur die ersten 16M erkennt, sieht der Befehl, den du benutzen
würdest, wie folgt aus:

<pre>
     machine mem +0x3000000@0x1000000
</pre>
um 48M (<tt>0x3000000</tt>) nach den ersten 16M (<tt>0x1000000</tt>)
hinzuzufügen. Typischerweise würdest du den oben angegeben
Befehl am Installationsprompt <tt>boot></tt> der Floppy/CD-ROM eingeben,
neustarten und eine <tt>/etc/boot.conf</tt> Datei anlegen, die den oben
angegebenen Befehl beinhaltet, so dass alle zukünftigen Starts des
Systems den ganzen verfügbaren Speicher erkennen können, wenn du
ein System mit diesem Problem hättest.

<p>
Es wurde ebenfalls berichtet, dass ein ROM Update dieses Problem auf
<i>einigen</i> Systemen löst.

<a name="noboot"></a>
<h3>4.12.2 - Mein i386 bootet nach der Installation nicht</h3>
Deine Installation verlief gut, doch beim ersten Hochfahren erkennst du
keine Anzeichen dafür, dass OpenBSD versucht zu starten. Es existieren
einige bekannte Gründe für dieses Problem:

<ul>
<li><b>Keine Partition wurde in fdisk(8) als aktiv markiert.</b> Um dies
zu beheben, starte das System unter Verwendung der Boot Floppy oder anderer
Medien neu und "markiere" eine Partition als "aktiv" (bootfähig).
Siehe <a href="faq14.html#fdisk">hier</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i1386">hier</a>.

<li><b>Kein gültiger Bootloader wurde jemals auf die Platte
geschrieben</b>
Falls du mit "Y" auf die Frage "Use entire disk for OpenBSD?" während
der Installation geantwortet hast oder die "<tt>reinit</tt>" Option von
fdisk(8) verwendet hast, wurde der OpenBSD Boot Record im Master Boot Record
der Platte installiert; ansonsten wurde der existierende Master Boot Record
Code nicht berührt. Dies wird ein Problem sein, wenn kein anderer
Boot Record existierte.
Eine Lösung ist, das Installationsmedium wieder zu booten, auf die
Shell zurückzugreifen und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
aufzurufen, um den MBR Code von der Befehlszeile aus zu aktualisieren:
<pre>
    # fdisk -u wd0
</pre>
Hinweis: Die "update" Option im interaktiven Modus ("-e") von fdisk
wird keine Signatur Bytes schreiben, die benötigt sind, um die
Platte bootfähig zu machen.

<li><b>In einigen wenigen Fällen kann etwas mit der ,second stage'
Bootloader Installation schief gelaufen sein.</b> Das Neuinstallieren
des ,second stage' Bootloaders wird <a href="faq14.html#InstBoot">hier</a>
besprochen.

</ul>

<a name="sshhang"></a>
<h3>4.12.3 - Mein System bootet, aber hängte beim ssh-keygen Prozess</h3>
Es ist sehr wahrscheinlich, dass dein System einwandfrei funktioniert,
nur dass die ssh Schlüsselgenerierung eine Weile dauert. Eine
SPARCStation2 oder ein Macintosh Quadra können bis zu 45 Minuten
oder länger in Anspruch nehmen, um die drei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>
Schritte auszuführen, einige Systeme brauchen sogar noch länger.
Lass es einfach abschließen; es wird nur ein einziges Mal pro
Installation gemacht.

<a name="noftplist"></a>
<h3>4.12.4 - Ich bekam die Meldung "Failed to change
directory", als ich die Installation durchführte</h3>

Wenn du eine FTP Installation eines
<a href="../upgrade-minifaq.html#1.1">Snapshots</a> während der
<i>-beta</i> Phase des <a href="faq5.html#Flavors">OpenBSD Entwicklungs
Zyklus</a> durchführst, könntest du dies lesen:

<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>

  Do you want to see a list of potential FTP servers?  [yes] <b><i>Enter</i></b>
  Getting the list from 192.128.5.191 (ftp.openbsd.org)... FAILED
  Failed to change directory.
  Server IP address or hostname?
</pre></td></tr></table>

Dies ist normal und ein erwartetes Verhalten während der ,pre-release'
Phase des Zyklus. Das Installationsprogramm sucht nach der FTP Liste auf
dem primären FTP Server in einem Verzeichnis, das bis zum
<a href="faq1.html#Next">Release Datum</a> nicht verfügbar ist, so
dass du die oben genannte Meldung bekommst.

<p>
Verwende einfach eine <a href="../ftp.html">FTP mirror Liste</a> um deinen
favorisierten FTP mirror zu finden und gib ihn manuell ein, wenn du
danach gefragt wirst.

<p>
<b>Hinweis: Du solltest die Meldung nicht sehen, wenn du <i>-release</i>
oder von einer CD-ROM installierst.</b>

<a name="krb4"></a>
<h3>4.12.5 - Wenn ich mich einlogge, bekomme ich
"login_krb4-or-pwd: Exec format error"</h3>
Kerberos IV wurde aus OpenBSD 3.4 entfernt, aber wenn du ein Upgrade
ausgeführt hast, werden die Kerberos IV Binaries weiterhin auf
deinem System sein. Dies ist ein Problem auf der i386 Plattform, da die
alten Kerberos Dateien im
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=a.out&amp;sektion=5">a.out</a>
Format sind und daher nicht mit einem ELF Kernel (der die a.out Emulation
nicht aktiviert hat, wie <a href="faq1.html#WhatsNew">hier</a> vermerkt)
ausgeführt werden können.
Falls du auf dieses Problem gestoßen bist, musst du die krb4
Authentifikation überschreiben, wenn du dich einloggst:
<pre>
    OpenBSD/i386 (puffy.openbsd.org) (ttyC0)

    login: joeuser:passwd
    password:
</pre>
Du kannst die gleiche "<tt><i>username</i>:passwd</tt>" Syntax mit einer
ssh Verbindung und mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su(1)</a>
verwenden, um auf dein System zuzugreifen.
Nun editiere <tt>/etc/login.conf</tt> und entferne die krb4 Referenzen.

<a name="blankfdisk"></a>
<h3>4.12.6 - Meine fdisk Partitionstabelle ist kaputt oder leer!</h3>
Gelegentlich finden Benutzer ein funktionsfähiges System vor,
das aber beim Verwenden von <tt>fdisk wd0</tt> eine vollständig
leere (oder ab und zu, vermüllte) Partitionstabelle aufweist.
Dies ist normalerweise verursacht, wenn eine Partition in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
erstellt wurde, die ein Offset von 0 Sektoren hat, anstatt dem
<a href="#trackoffset">einem Track Offset</a>, den sie haben
sollte (Hinweis: Dies nimmt an, dass es sich um die
<a href="../de/i386.html">i386</a> oder
<a href="../de/amd64.html">amd64</a> Plattform handelt. Andere
Plattformen benötigen andere Offsets, einige sogar GAR KEINEN
Offset).
Das System <a href="faq14.html#Boot386">bootet</a> dann unter Verwendung
des PBR und nicht des MBR.

<p>
Obwohl diese Konfiguration funktioniert, kann es ein Wartungsproblem
sein und sollte korrigiert werden.
Um dies zu korrigieren, muss das Dateisystem der Platte normalerweise
von Grund auf neu erstellt werden (obwohl, wenn du WIRKLICH weißt
was du tust, kannst du in der Lage sein, nur dein Disklabel und den
MBR neu zu erstellen und musst nur die erste OpenBSD Partition der
Festplatte neu errichten).

<a name="site"></a>
<h2>4.13 - Anpassen des Installationsprozesses</h2>
<!-- XXXversion -->

<h3><tt>siteXX.tgz</tt> Datei</h3>
Die OpenBSD Installationsskripte erlauben das Auswählen eines
Benutzer-erstellten Sets, genannt "<tt>siteXX.tgz</tt>", wobei XX die
Release Version (z.B. 36. ist. Das <tt>siteXX.tgz</tt>" Datei Set ist,
wie die anderen <a href="#FilesNeeded">Datei Sets</a>, ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gzip&amp;sektion=1">gzip(1)</a>
komprimiertes
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>
Archiv basierend auf ,/' und wird wie die anderen Sets mit den Optionen
<tt>xzpf</tt> ent,tar'rt. Dieses Set wird zuletzt installiert, nach allen
anderen Datei Sets.

<p>
Dieses Datei Set erlaubt es dem Benutzer, Dateien hinzuzufügen oder
Dateien zu überschreiben, die von den ,normalen' Sets installiert
worden sind und daher die Installation oder das Upgrade anpassen zu
können.

<p>
Einige Beispielverwendungen einer <tt>siteXX.tgz</tt> Datei:
<ul>
<li>Erstelle eine siteXX.tgz Datei, die alle Änderungen beinhaltet,
die du seit dem ersten Installieren von OpenBSD gemacht hast. Dann,
wenn du das System neuerstellen musst, wählst du einfach siteXX.tgz
während der Neuinstallation aus und alle Änderungen von dir
werden auf dem neuen System nachgebildet.

<li>Erstelle eine Serie von Maschinen-spezifischen Verzeichnissen, die
jeweils eine siteXX.tgz Datei beinhalten, die wiederum spezifische
Dateien für diese Maschine beinhalten. Installationen von Maschinen
(z.B. Systeme mit unterschiedlichen Grafikkarten) einer bestimmten
Kategorie können durch das Auswählen der passenden siteXX.tgz
Datei abgeschlossen werden.

<li>Stecke die Dateien, die du routinemäßig auf einen gleichen
oder ähnlichen Weg anpasst, in eine siteXX.tgz Datei --
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"><tt>/etc/skel</tt></a> Dateien,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><tt>/etc/pf.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8"><tt>/var/www/conf/httpd.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"><tt>/etc/rc.conf.local</tt></a>,
etc.
</ul>

<h3><tt>install.site</tt>/<tt>upgrade.site</tt> Skripte</h3>
Als letzten Schritt im Installations/Upgrade Prozess sucht das Skript im
Wurzelverzeichnis des neu installierten/aktualisierten System nach
<tt>install.site</tt> oder <tt>upgrade.site</tt>, je nach aktuellem
Prozess, und führt das Skript in einer Umgebung, die auf das 
Wurzelverzeichnis des installierten/aktualisierten System
,<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=8">chroot</a>ed'
ist. Denke daran, dass das Upgrade von einem gebootetem Dateisystem
aus ausgeführt wird, so dass dein Ziel tatsächlich auf <tt>/mnt</tt>
gemountet ist. Trotzdem kann dein Skript so geschrieben werden, als ob
es im "normalen" Wurzelverzeichnis deines Dateisystems ausgeführt
wird. Da das Skript ausgeführt wird, wenn alle Dateien bereits
installiert worden sind, hast du fast volle Funktionalität deines
Systems (allerdings im Single User Modus), wenn dein Skript läuft.

<p>
Bedenke, dass das <tt>install.site</tt> Skript in der <tt>siteXX.tgz
Datei</tt> liegen sollte, während das <tt>upgrade.site</tt> Skript
vor dem Upgrade in das Wurzelverzeichnis gelegt werden kann, oder
in eine <tt>siteXX.tgz</tt> Datei.

<p>
Die Skripte können für alles verwendet werden, was mit Skripten
möglich ist
<ul>
<li>Entferne Dateien, die installiert/aktualisiert worden sind, die du
auf dem System aber nicht haben möchtest.
<li>Entferne/aktualisiere/installiere die
<a href="faq8.html#Packages">Packages</a>, die du auf dem installierten
System haben möchtest.
<li>Erstelle ein <a href="faq14.html#Backup">sofortiges Backup/Archiv</a>
des neuen Systems, bevor du es dem Rest der Welt aussetzt.
</ul>

Die Kombination von <tt>siteXX.tgz</tt> und <tt>install.site/upgrade.site</tt>
Dateien sollen dem Benutzer eine breite Palette von Fähigkeiten bieten,
ohne dass sie selbst eigene Installations-Sets erstellen müssen.

<a name="Multiple"></a>
<h2>4.14 - Wie kann ich eine Anzahl gleichartiger Systeme
installieren?</h2>
Hier sind einige Anwendungen aufgelistet, die du verwenden kannst, wenn
du eine Anzahl von ähnlichen OpenBSD Systemen installieren musst.

<h3><tt>siteXX.tgz</tt> und <tt>install/upgrade.site</tt> Dateien</h3>
Siehe den <a href="#site">vorherigen</a> Artikel.

<h3>Von dump(8) wiederherstellen</h3>
Auf den meisten Plattformen beinhaltet das Boot Medium das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
Programm, welches verwendet werden kann, um ein Backup, das mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
erstellt wurde, zu extrahieren.
Daher kannst du von
<a href="#MkFlop">Floppy</a>,
<a href="../de/orders.html">CD</a> oder
<a href="#bsd.rd">bsd.rd</a> Datei booten, dann
<a href="faq14.html#fdisk">fdisk</a>,
<a href="faq14.html#disklabel">disklabel</a> ausführen und mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore</a>
die gewünschte Konfiguration von Band oder einem anderen Medium
wiederhestellen und die <a href="faq14.html#InstBoot">Boot Blöcke</a>
installieren. Weitere Details gibt es <a href="faq14.html#Backup">hier</a>.

<h3>Platten ,imaging'</h3>
Leider existiert kein bekanntes Platten ,imaging' Programm, das FFS
unterstützt und so nur den aktiv genutzten Dateispeicher nutzen
könnte. Die meisten der größeren Platten ,imaging'
Lösungen behandeln OpenBSD Partitionen als "allgemeine" Partition
und können ein Image der gesamten Platte erzeugen. Damit erreichst
du zwar dein Ziel, aber verbrauchst für gewöhnlich eine
große Menge an Speicher -- eine leere, 10G <tt>/home</tt> Partition
wird 10G Speicher im Image verbrauchen, selbst wenn sich dort keine einzige
Datei befindet. Während du normalerweise ein Laufwerksimage auf
ein größeres Laufwerk installieren kannst, wirst du nicht
in der Lage sein, den zusätzlichen Speicher direkt zu nutzen, und
du wirst auch nicht in der Lage sein, ein Image auf ein kleineres
Laufwerk zu installieren.

<p>
Falls das eine akzeptable Situation für dich ist, könnte der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd</a>
Befehl deinen Ansprüchen, eine Platte auf eine andere zu kopieren,
Sektor-für-Sektor, genügen. Dies bietet dir die gleiche
Funktionalität wie die der kommerziellen Produkte ohne den Kosten.

<a name="getdmesg"></a>
<h2>4.15 - Woher bekomme ich eine dmesg(8), damit ich ein Problem mit
der Installation melden kann?</h2>
Wenn man <a href="../report.html">ein Problem meldet</a>, ist es
entscheidend, eine komlette
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
des Systems einzufügen.
Wie auch immer, oft ist es so, dass du dies machen musst, wenn das
System nicht ordnungsgemäß funktioniert oder nicht installieren
will, so dass du weder Platten, Netzwerk oder andere Ressourcen zur
Verfügung hast, um deine dmesg an die passende
<a href="../de/mail.html">Mailing Liste</a> zu senden. Es gibt aber
andere Wege:

<ul>
<li><b>Floppy</b>  Die Boot Disketten und die CD-ROM haben
genügend Anwendungen, um deine dmesg auf eine MSDOS Floppy
zu schreiben, damit eine andere Maschine sie lesen kann. Lege eine
MSDOS formatierte Floppy in dein Diskettenlaufwerk und führe
folgende Befehle aus:

<pre>
     mount -t msdos /dev/fd0a /mnt
     dmesg > /mnt/dmesg.txt
     umount /mnt
</pre>
Falls du ein anderes OpenBSD System besitzt, kannst du es ebenfalls
auf eine OpenBSD kompatible Floppy schreiben -- oftmals hat die
Boot Floppy genügend freien Raum, um die dmesg zu halten. In
dem Fall lasse das "<tt>-t msdos</tt>" oben weg.

<p>
<li><b>Serielle Konsole:</b>
Eine serielle Konsole verwenden und die Ausgabe auf einer anderen
Maschine abzufangen ist oftmals der beste Weg um Diagnose
Informationen erhalten zu können - insbesondere, wenn der
Computer direkt nach dem Hochfahren in einem ,panic' endet.
Neben einem weiteren Computer benötigst du ebenfalls ein
passendes serielles Kabel (oft ein Null-Modem Kabel) und ein Terminal
Emulator Programm, das die Bildschirmausgabe in eine Datei schreiben
kann.

<p>
Generelle Informationen zum Aufsetzen eines seriellen Terminals
sind <a href="faq7.html#SerCon">an einer anderen Stelle des FAQs</a>
verfügbar;
um eine Log der Installation abfangen zu können, sind in der
Regel folgende Befehle ausreichend.

<p><b>i386</b>

<p>
Gib am Bootloader Prompt ein

<p>
<blockquote>
<pre>
boot> <b>set tty com0</b>
</pre>
</blockquote>

<p>
Dies teilt OpenBSD mit, dass die erste serielle Schnittstelle
(in PC Dokumentationen oft COM1 oder COMA genannt) als serielle Konsole
verwendet werden soll.
Die standardmäße Baudrate ist 9600.

<p><b>Sparc/Sparc64</b>

<p>
Diese Maschinen starten automatisch mit einer seriellen Konsole, wenn
sie ohne angeschlossener Tastatur gestartet wurden.
Falls du Tastatur und Monitor angeschlossen hast, kannst du das System
trotzdem dazu bringen, eine serielle Konsole zu verwenden, indem du
folgende Befehle am <tt>ok</tt> Prompt aufrufst.

<p>
<blockquote>
<pre>
ok <b>setenv input-device ttya</b>
ok <b>setenv output-device ttya</b>
ok <b>reset</b>
</pre>
</blockquote>

<p>
<li><b>FTP:</b>  Unter bestimmten Umständen kann es dir
möglich sein, mit Hilfe des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
Clients der Boot Diskette oder CD-ROM, die dmesg zu einem lokalen
FTP Server zu senden, von wo aus du sie später wiederholen
kannst.
</ul>
<p>

<a name="bsdrdaout"></a>
<h2>4.16 - OpenBSD unter Verwendung von <tt>bsd.rd-aout</tt>
upgraden/neuinstallieren</h2>
Es ist normalerweise möglich, Upgrades und Installationen mit
dem <a href="faq4.html#bsd.rd">bsd.rd</a> Kernels durchzuführen.
Mit OpenBSD 3.4 allerdings wechselte die i386 Plattform das
,executable' Format von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=a.out&amp;sektion=5">a.out</a> auf
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=elf&amp;sektion=5">ELF</a>,
so dass ältere
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>Bootloader</a> (OpenBSD 3.3 und früher) nicht unter dem neuen-Format
<tt>bsd.rd</tt> Kernel ausgeführt werden können.

<p>
Um dieses Problem zu umgehen und Upgrades unter Verwendung von
<tt>bsd.rd</tt> gewährleisten zu können, wurde eine a.out
Version von <tt>bsd.rd</tt> in der <a href="../de/ftp.html">FTP
Distribution</a> zur Verfügung gestellt.
Diese Datei, <tt>bsd.rd-a.out</tt>,
kann von OpenBSD 3.3 und niedriger gebootet werden, aber es ist ein
authentischer OpenBSD 3.6 Kernel, mit eingebundenem ELF Bootloader,
so dass es zum Bootstrappen von OpenBSD/i386 3.6 von einem älteren
System aus verwendet werden kann.

<p>
Lade einfach <tt>bsd.rd-a.out</tt> herunter und platziere ihn in dem
root Verzeichnis deines Systems.
Lade ihn anstatt dem normalen <tt>/bsd</tt> oder <tt>/bsd.rd</tt> Kernels,
so wie es <a href="faq4.html#bsd.rd">hier</a> gezeigt wird
(Natürlich unter Angabe von <tt>bsd.rd-a.out</tt> als Boot Kernel).

<p>
Wenn du gerne <i>-current</i> installieren möchtest, wird
empfohlen, dass du erst ein minimales 3.6-release System (<tt>base36.tgz,
etc36.tgz, bsd</tt>) installierst und dann unter Verwendung der
<i>-snapshot</i> <tt>bsd.rd</tt> Datei neuinstallierst.

<p>

<font color= "#0000e0">
<a href= "index.html">[Zurück zum Haupt-Index]</a>
<a href="faq3.html">[Zum Kapitel 3 - Wo man OpenBSD herbekommt]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Source-Code erzeugen]</a>
</font>
<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a> 
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq4.html,v 1.189 ]
<br>
$Translation: faq4.html,v 1.63 2004/11/02 18:04:29 jufi Exp $
<br></small>
<small>$OpenBSD: faq4.html,v 1.53 2004/11/02 18:40:59 jufi Exp $</small>
</body>
</html>
