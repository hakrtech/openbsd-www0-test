<html>
<head>
<title>6.0 - Netzwerken</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name="resource-type" content="document">
<meta http-equiv="Content-Language" content="de">
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1998-2002 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">
<img SRC="../../images/smalltitle.gif" ALT="[OpenBSD]" height=30 width=141>
<h2>
<font color="#E00000">6.0 - Netzwerken</font>
<hr></h2>

<ul><h3>Inhaltsverzeichnis</h3>

<li> <a href="#Intro"	>6.0.1 - Bevor wir weiter gehen</a></li>
<li> <a href="#Setup"	>6.1 - Erste Netzwerkeinstellungen</a></li>
<li> <a href="#PF"	>6.2 - Packet Filter (PF)</a></li>
<li> <a href="#NAT"	>6.3 - NAT - Network Address Translation</a></li>
<li> <a href="#DHCP"	>6.4 - DHCP - Dynamic Host Configuration Protocol</a></li>
<li> <a href="#PPP"	>6.5 - PPP - Point to Point Protocol</a></li>
<li> <a href="#Tuning"	>6.6 - Optimieren der Netzwerkparameter</a></li>
<li> <a href="#NFS"	>6.7 - NFS benutzen</a></li>
<li> <a href= "#DNS"	>6.8 - DNS - Domain Name Service  - DNS, BIND und named</a>
<li> <a href= "#PPTP"	>6.9 - Eine PPTP Verbindung mit OpenBSD aufbauen</a>
</ul>
</p>

<hr>
<a name= "Intro"></a>
<p><a NAME="6.0.1"></a>
<h2>
6.0.1 - Bevor wir weiter gehen</h2>
F&uuml;r den Rest dieses Dokumentes sei gesagt, da&szlig; es hilfreich
ist, das Kapitel des FAQ <a href="faq5.html">Kernelkonfiguration und Einstellungen</a>
gelesen und zumindest teilweise verstanden zu haben, weiterhin helfen die
Manual Seiten <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&sektion=1">netstat(1)</a>.
<p>
Wenn du ein Netzwerkadministrator bist und Routingprotokolle aufsetzt
und dein OpenBSD Rechner dein Router wird, dann solltest du dein Wissen
&uuml;ber IP Netzwerke mit 
<A HREF="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">Understanding IP addressing</a>
(oder <a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">hier</a>)
vertiefen. Dies ist wirklich ein exzellentes Dokument. "Understanding IP addressing" 
beinhaltet grundlegendes Wissen, auf dem man beim IP Netzwerken aufbauen 
kann, insbesondere wenn man mit mehreren Netzwerken arbeitet oder f&uuml;r sie 
verantwortlich ist.
<p>
Wenn du mit Anwendungen wie Web-, FTP- oder Mailserver arbeitest, dann
k&ouml;nntest du viel vom Lesen der entsprechenden <a href="http://www.nexor.com/info/rfc/index/rfc.htm?index/rfc.html">RFCs</a>
profitieren. Nat&uuml;rlich kannst du nicht alle lesen. Aber dennoch, lies
jene, die dich interessieren oder die du bei deiner Arbeit brauchen k&ouml;nntest.
Lies nach, wie sie arbeiten sollten. Die RFCs definieren mehrere (tausende)
Standards f&uuml;r Protokolle im Internet und wie sie arbeiten sollten.&nbsp;

<a name= "Setup"></a>
<a name="6.1"></a>
<h2>
6.1 - Erste Netzwerkeinstellungen</h2>

<p>
<a name= "Setup.1"></a>
<a name="6.1.1"></a>
<h3>
6.1.1 - Identifzieren und Einstellen deiner Netzwerkkarten</h3>
Um beginnen zu k&ouml;nnen, mu&szlig;t du zun&auml;chst deine Netzwerkkarte
identifizieren k&ouml;nnen. Bei OpenBSD werden Netzwerkkarten nach ihrem
Typ, nicht nach Verbindungsart benannt. Du kannst sehen, ob deine Netzwerkkarte
initialisiert wurde, entweder schon beim Booten oder auch sp&auml;ter mittels des
Befehls <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&sektion=8">dmesg(8)</a>. 
Weiterhin kannst du mit dem Befehl 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>
deine Karte &uuml;berpr&uuml;fen. Zum Beispiel ist hier die Ausgabe in
dmesg f&uuml;r eine ne2k Netzwerkkarte, die den Ger&auml;tenamen ne hat.
<ul>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></ul>
Wenn du nicht weisst, wie der Name deiner Karte ist, sieh bitte in der
<a href="../../de/plat.html">Liste der unterst&uuml;tzten Hardware</a> unter deiner Plattform nach.
Dort findest du eine Liste der gebr&auml;chlichsten Kartennamen und ihrer OpenBSD device Namen.
Kombiniere den kurzen alphabetischen Namen (z.B. fxp) mit einer Nummer, die vom Kernel zugewiesen
wird, und du hast den "interface name" (z.B. fxp0).

Falls du von einer &auml;lteren Version von OpenBSD upgradest: Alte Ethernet-Treiber
werden manchmal durch neuere ersetzt, und wenn das passiert,
kann sich der Interfacename &auml;ndern. Nach OpenBSD 2.6, z.B., wurden die
mx, al, ax, und pn Treiber alle durch den dc Treiber ersetzt.
Alle Referenzen in <i>/etc/dhcpd.interfaces</i>, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">/etc/pf.conf(5)</a>, oder <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">/etc/nat.conf(5)</a>
m&uuml;ssen auf den neuen Interfacenamen ge&auml;ndert werden.
Genauso nat&uuml;rlich alle <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5">/etc/hostname.xxx</a> Dateien. ( Wobei xxx der alte Interfacename und die Zahl darstellt)
</p>
<p>
Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem du das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> Kommando benutzt.
Das folgende Kommando zeigt uns alle Netzwerk-Interfaces im System.
Diese Beispielausgabe zeigt ein physikalisches Ethernet Interface,
eine <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&sektion=4">fxp(4)</a>.
</p>

<ul>
<pre>$ <b>ifconfig -a</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000 
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::202:b3ff:fe2b:10f7%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
vlan1: flags=0&lt;&gt; mtu 1500
gre0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1450
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></ul>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> 
gibt uns eine Menge mehr Informationen, als wir zu diesem Zeitpunkt ben&ouml;tigen.
Nat&uuml;rlich sehen wir trotzdem unser Interface. Im obugen Beispiel ist die Netzwerkkarte bereits 
konfiguriert. Das ist offesichtlich, da auf fxp0 bereits ein IP Netzwerk konfiguriert ist, sprich die 
Werte &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;. 
Ausserdem sind die <strong>UP</strong> und <strong>RUNNING</strong> Flags gesetzt.
</p>
<p>
Schlussendlich f&auml;llt auf, das standarm&auml;ssig eine Menge mehr Interfaces aktiviert sind.
Dies sind virtuelle Interfaces, die verschiedene Funktionen haben. Informationen dazu findest 
du auf den folgenden man pages:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&sektion=4">lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&sektion=4">pflog</a> - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&sektion=4">sl</a> - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=4">ppp</a> - Point to Point Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&sektion=4">tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4">enc</a> - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4">bridge</a> - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&sektion=4">vlan</a> - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&sektion=4">gre</a> - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&sektion=4">gif</a> - Generic IPv4/IPv6 Tunnel Interface
</ul>

Der 1. Schritt zur Konfiguration deiner Netzwerkkarte ist das Erstellen
der <b>/etc/hostname.xxx</b> Datei. Wobei der Name deiner Karte den Platz
von xxx einnehmen sollte. Aus der Information der obigen Beispiele w&uuml;rde
der Name <b>/etc/hostname.fxp0 </b>lauten. Das Layout dieser Datei sollte
einfach so aussehen: <br>
<ul><pre>
address_family address netmask broadcast [other options]
</pre></ul>
(Viel mehr Details zu dieser Datei findest du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5">hostname.if(5)</a> man page.)

Eine typische Interface-Konfigurationsdatei f&uuml;r eine IPv4 Addresse 
w&uuml;rde so aussehen:
<ul>
<pre>$ <b>cat /etc/hostname.fxp0
</b>inet 10.0.0.38 255.255.255.0 NONE
</pre></ul>

<p>
Du solltest auch den media type f&uuml;r Ethernet angeben, wenn du z.B. den
100baseTX full-duplex Modus erzwingen willst.
</p>

<ul><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX media-opt full-duplex
</pre></ul>

(Auf keinen Fall solltest du das tun, wenn nicht beide Seiten der Verbindungen
auf Voll-Duplex gestellt sind ! Wenn du keine besonderen Anforderungen hast,
HIERGETHESWEITER!
kann du diese media settings einfach ignorieren.)

<p>
Oder vielleicht willst du auch spezielle flags f&uuml;r ein einzelnes Interface 
benutzen. Das Format der Datei &auml;ndert sich dabei nicht besonders!
</p>

<ul><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></ul>

<p>
Der n&auml;chste Schritt ist das Einstellen deines Gateways. Dazu trag
einfach die IP deines Gateways in die Datei <b>/etc/mygate</b> ein. Dies erlaubt
das Aktivieren deines Gateways beim Starten. Jetzt solltest du deine Nameserver
eintragen und die Datei <b>/etc/hosts</b> einrichten. F&uuml;r die Nameserver
ben&ouml;tigst du eine Datei namens <b>/etc/resolv.conf</b>. Mehr &uuml;ber
das Format dieser Datei findest du in der <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">resolv.conf(5)</a>
Manual Seite. F&uuml;r den Normalgebrauch ist hier ein Beispiel, in dem
deine Nameserver 125.2.3.4 und 125.2.3.5 sind. Du geh&ouml;rst zur Dom&auml;ne
&quot;deinedomaene.com&quot;.
</p>

<ul>
<pre>$ <b>cat /etc/resolv.conf
</b>search deinedomaene.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></ul>

<p>
Jetzt kannst du entweder rebooten oder das <b>/etc/netstart</b> Script
ausf&uuml;hren, indem du (als root) folgendes eingibst:
</p>

<ul>
<pre>$ <b>sh /etc/netstart
</b>writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></ul>

<p>
Die Fehlermeldung betrifft das loopback Interface. Daher kann dies ignoriert
werden. Ab jetzt sollte dein System funktionieren. Du kannst wiederum mit
<b>ifconfig(8)</b>
&uuml;berpr&uuml;fen, ob deine Netzwerkkarte aktiv ist. Die Routingtabelle
&uuml;berpr&uuml;fe mit <b>netstat(1)</b> oder <b>route(8)</b>. Hier ist
ein Beispiel f&uuml;r beides.
</p>

<ul><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  ne3
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  ne3
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  ne3
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)
$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></ul>

<p>
<a NAME="6.1.2"></a>
<h3>
6.1.2 - Einrichten deines OpenBSD Rechners als Gateway</h3>
<p>
Dies ist nur die grundlegende Information, um deinen OpenBSD Rechner als
Gateway (auch Router genannt) einzurichten. Wenn du OpenBSD als Router
im Internet verwenden willst, solltest du auch die IP Filter unten folgenden
Instruktionen beachten, um potentiell sch&auml;dliche IP Daten zu blockieren.
Auch solltest du wegen der Knappheit an IPv4 Adressen die Informationen
bez&uuml;glich Network Address Translation beachten, um deinen IP Adressbereich
zu schonen.
</p>

<p>
Der GENERIC Kernel hat bereits die F&auml;higkeit f&uuml;r IP Forwarding,
aber dies mu&szlig; erst eingeschaltet werden. Du solltest dies mit <b>sysctl(8)</b>
tun. Um diese &Auml;nderung permanent einzutragen, mu&szlig;t du die Datei
<b>/etc/sysctl.conf</b>
editieren. F&uuml;ge einfach folgende Zeile in diese Konfigurationsdatei
ein.
</p>

<ul>
<pre>net.inet.ip.forwarding=1
</pre></ul>

<p>
Ohne Reboot kannst du dies auch direkt mit <b>sysctl(8)</b> durchf&uuml;hren.
Beachte aber, da&szlig; diese &Auml;nderung nach einem Reboot weg ist und
der folgende Befehl als root ausgef&uuml;hrt werden mu&szlig;.
</p>

<ul>
<pre># <b>sysctl -w net.inet.ip.forwarding=1
</b>net.inet.ip.forwarding: 0  -&gt; 1
</pre></ul>

<p>
Nun modifiziere die Routen der anderen Hosts. Es gibt viele verschiedene
M&ouml;glichkeiten, OpenBSD als Router einzusetzen, z. B. mittels Software
wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&apropos=0&sektion=8&format=html">routed(8)</a>,
<a href="http://www.gated.org">gated</a>,
<a href="http://www.mrtd.net">mrtd</a>
und <a href="http://www.zebra.org">zebra</a>. OpenBSD hat Unterst&uuml;tzung
in der ports Kollektion sowohl f&uuml;r gated als auch mrtd. OpenBSD unterst&uuml;tzt
mehrere T1, HSSI, ATM, FDDI, Ethernet und serielle (PPP/SLIP) Schnittstellen.
</p>

<p>
<a NAME="6.1.3"></a>
<h3>
6.1.3 - Einrichten von Aliases auf deiner Netzwerkkarte.</h3>
<p>
<strong>Beginnend mit OpenBSD 2.8 wird <i>/etc/ifaliases</i> nicht mehr benutzt!</strong>
<p>
OpenBSD hat einen einfachen Mechanismus, um IP Aliases auf einer Schnittstelle
einzurichten. Dazu mu&szlig;t du nur die Datei 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html"><i>/etc/hostname.&lt;if&gt;</i></a>
editieren.
Diese Datei wird beim Starten vom <i>/etc/rc</i> Script gelesen, welches
Teil der <a href="../faq10.html#10.3">rc startup Hierarchie</a> ist. F&uuml;r
das Beispiel nehmen wir an, da&szlig; der Benutzer eine Schnittstelle <b>dc0</b>
hat und sich im Netzwerk 192.168.0.0 befindet. Weitere wichtige Informationen:
</p>

<ul>
<li>
IP f&uuml;r dc0 ist 192.168.0.2</li>
<li>
NETMASK ist 255.255.255.0</li>
</ul>

<p>
Bei OpenBSD verwendet man nur den Adapternamen. Es gibt keine Unterschiede
zwischen dem ersten und dem zweiten Alias. Daher mu&szlig; man sie nicht
- wie in einigen anderen Betriebssystemen - als dc0:0, dc0:1 bezeichnen.
Wenn du dich auf einen speziellen IP Alias beziehst oder einen hinzuf&uuml;gst, 
dann nimm "<tt>ifconfig int alias</tt>" anstelle nur "<tt>ifconfig int</tt>" 
auf der Befehlszeile. Du kannst Aliase mit "<tt>ifconfig int delete</tt>" 
l&ouml;schen. 
</p>

<p>
Angenommen du verwendest mehrere IP Adressen im selben IP Subnetz mit Aliases, 
dann ist die Netzmaskeneinstellung f&uuml;r jeden Alias 255.255.255.255.
Sie m&uuml;ssen nicht der Netzmaske der ersten IP der Netzwerkkarte folgen. 
In diesem Beispiel <i>/etc/hostname.dc0</i> werden zwei Alias zur Netzwerkkarte 
dc0 hinzugef&uuml;gt, die als 192.168.0.2 mit Netzmaske 255.255.255.0 
konfiguriert wurde.
</p>

<ul>
<pre>

# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255 NONE
inet alias 192.168.0.4 255.255.255.255 NONE
</pre>
</ul>

<p>
Wenn du einmal diese Datei erstellt hast, ben&ouml;tigst du einen Reboot,
um die &Auml;nderung automatisch durchf&uuml;hren. Du kannst aber auch
die Aliases manuell mit <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>
hochbringen. F&uuml;r das erste Alias:
</p>


<ul>
<pre># <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></ul>

<p>
Um die Aliases zu sehen:
</p>

<ul>
<pre>$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></ul>

<p>
<a NAME="6.2"></a>
<h2>
6.2 - IP Filter</h2></p>

<p>
Das IP Filter Packet wurde geschaffen, um zwei Aufgaben zu erf&uuml;llen:
Berechtigungen von packet level forwarding <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=8&manpath=OpenBSD+2.7">ipf(8)</a>
und das Umlegen von hosts/subnets auf einen externen Adressbereich <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a>. 
Die Konfigurationsdateien dieser zwei Dienste sind /etc/ipf.rules und /etc/ipnat.rules.</p>

<p>
Um diese Dienste in deinem System zu starten, musst du die <i>/etc/rc.conf</i> so editieren:
</p>

<ul><pre>
ipfilter=YES
ipnat=YES
</pre></ul>

<p>
<b>HINWEIS:</b> Du musst nicht unbedingt beide Optionen dauernd aktiviert haben, es sei denn du nutzt auch beide.  Wenn du allerdings
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a> benutzt, muss ipfilter auch zwingend aktiviert sein.
</p>

<p>
Wenn du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a> benutzt, musst du h&ouml;chstwahrscheinlich 
auch den sysctl Wert &quot;net.inet.ip.forwarding&quot; auf 1 setzen. Du kannst das tun, indem du die zugeh&ouml;rigen Zeilen
in der Datei <i>/etc/sysctl.conf</i> auskommentierst. 
</p>

<p>
Wenn du IP Filter im Kernel einkompiliert hast, aber nicht in <i>/etc/rc.conf</i>
eingeschalten hast, kannst du es einfach aktivieren.
<ul>
# <strong>ipf -Fa -f /etc/ipf.rules -E</strong><br>
# <strong>ipnat -CF -f /etc/ipnat.rules</strong>
</ul>

<p>
Die <tt>-E</tt> Option bei ipf aktiviert ('enables') IP Filter. <tt>-Fa</tt>
l&ouml;scht alle Regeln, die du noch hast. <tt>-f /etc/ipf.rules</tt> l&auml;dt
die Regeln aus der Datei <i>/etc/ipf.rules</i>.

<p>Wenn du <i>/etc/ipf.rules</i> nach dem Laden von ipf &auml;nderst, kannst du
deine Regeln sehr leicht neu laden!
<ul>
# <strong>ipf -Fa -f /etc/ipf.rules</strong>
</ul>
Gleiches f&uuml;r ipnat...
<ul>
# <strong>ipnat -CF -f /etc/ipnat.rules</strong>
</ul>
Um <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipmon&sektion=8&manpath=OpenBSD+2.7">ipmon(8)</a> im Debugmodus zu starten:
<ul>
# <strong>ipmon -Ds</strong>
</ul>

<p>
Dieses Dokument wird einige grundlegende <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=8&manpath=OpenBSD+2.7">ipf(8)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">ipnat(8)</a> Konfigurationen
im Folgenden darstellen. In <i>/usr/share/ipf/</i> findest du ein paar nette Beispiele
f&uuml;r ipnat und ipf. Wir empfehlen dir, jenes, da&szlig; dir am ehesten
pa&szlig;t, auszuw&auml;hlen und auf deine Bed&uuml;rfnisse abzu&auml;ndern.
Du kannst weitere Informationen im IP Filter
<a href="http://false.net/ipfilter/">Mailinglistenarchiv</a>,
auf der <a href="http://coombs.anu.edu.au/~avalon/">IP Filter Website</a>
und noch im <a href="http://www.obfuscation.org/ipf/">IP Filter HOWTO</a>
finden.
</p>

<p>
<h3>
IPF</h3>

<p>
Um ipf beim Booten zu aktivieren, mu&szlig;t du /etc/rc.conf modifzieren:
IPFILTER=YES. IP Filter (ipf) wird von /etc/ipf.rules gesteuert, welche
beim Booten gelesen wird. F&uuml;r weitere Erkl&auml;rungen siehe <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&sektion=5&manpath=OpenBSD+2.7">ipf(5)</a>.
In den folgenden Beispielen wird fxp0 das externe Netzwerkinterface zum
Internet sein. Dies wird f&uuml;r dich anders sein, wenn du einen anderen
Ethernetadapter in deinem Computer hast. Diese Regeln nehmen eine Standleitungsverbindung
an, so wie sie bei einem Webserver zu erwarten ist.
</p>

<p>IP Filter Regeln werden sequentiell von Anfang bis Ende abgearbeitet.
Es mag hilfreich sein, sich vorzustellen, da&szlig; jedes einzelne Paket
zun&auml;chst jede Regel erf&uuml;llen mu&szlig;, bevor es sein Ziel erreicht.
</p>

<p>Z. B. erlauben die Standardregeln, da&szlig; alle Pakete rein und raus
d&uuml;rfen:

<ul>
<pre>pass out from any to any&nbsp;
pass in from any to any</pre>
</ul>

Nun angenommen, wir wollen keine ankommenden Verbindungen zu Port 3306
(mysql) zulassen, weil die Datenbank nur mit dem localhost verbunden sein
soll. Die Regeln w&uuml;rden so aussehen:

<ul>
<pre>pass out from any to any
pass in from any to any
block in on fxp0 from any to any port = 3306</pre>
</ul>

Dies bedeutet, da&szlig; alle ankommenden Pakete von &uuml;berall nach
&uuml;berall mit Zielport 3306 auf dem Interface fxp0 blockiert werden.
Genauergesagt wird ein Paket f&uuml;r Port 3306 auf dem Adapter fxp0 zun&auml;chst
die erste "pass in" Regeln passieren und dann von der "block in port =
3306" Regel blockiert werden. Wenn du die Anordnung unserer ankommenden
Regel vertauschst (NB: die Reihenfolge ist wichtig):

<ul>
<pre>pass out from any to any
block in on fxp0 from any to any port = 3306
pass in from any to any</pre>
</ul>

Pakete mit Zielport 3306 w&uuml;rden passieren, weil die letzte Regel alle
Pakete passieren l&auml;&szlig;t. Dies mu&szlig; man immer im Hinterkopf
behalten, wenn man Paketfilterregeln schreibt: 
<b>Die letzte passende Regel gewinnt</b>.

<p>
Nat&uuml;rlich gibt es Ausnahmen zu jeder Regel. Die <em>quick</em> Option
l&auml;&szlig;t jedes Paket bei der ersten passenden Regel fallen. Bei
obigem "falschen" Beispiel mit <em>quick</em> zur "block in" Regel:

<ul>
<pre>pass out from any to any
block in quick on fxp0 from any to any port = 3306
pass in from any to any</pre>
</ul>

<p>
Ein Paket mit Ziel f&uuml;r unseren Rechner auf Port 3306 wird die "block
in quick" Regel treffen und sofort fallengelassen. Alle Pakete f&uuml;r
die anderen Ports werden keine passende Regel finden bis sie auf unsere
"pass in" Regel treffen, die alle Pakete passieren l&auml;&szlig;t.
</p>

<p><b>Standardm&auml;&szlig;iges Ablehnen</b>
<p>Die sicherste Paketfilterregel ist standardm&auml;&szlig;iges Ablehnen.
Jeder Datenverkehr, der nicht ausdr&uuml;cklich erlaubt ist, wird abgelehnt.
Diese Richtlinie ist bei weitem sicherer, als jeden gesch&uuml;tzten Dienst
ausdr&uuml;cklich zu erlauben. Erlaubt kleineren Umfang der Regeln und
kann Schutz bieten, wenn ein unabsichtlich mi&szlig;konfigurierter Dienst
ungesch&uuml;tzt zur&uuml;ckgelassen wurde.
<p>
Sehen wir uns einen anderen, realen Beispielregelsatz an und erkl&auml;ren
Zeile f&uuml;r Zeile. Hier ein Beispiel f&uuml;r einen Webserver mit standardm&auml;&szlig;igem
Ablehnen; erlaubt werden nur ssh Verbindungen (f&uuml;r Administration)
und Verbindung zu http (port 80) und https (port 443).
<ul>
<pre>
pass in quick on fxp0 from any to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre>
</ul>

<p>
Dies wird ankommende Verbindungen von &uuml;berall zu Ports 22 (ssh), 80
(http), and 443 (https) erlauben. Es werden alle anderen Verbindungsversuche
fallengelassen und alle ausgehenden Verbindungen erlaubt. Dies ist ein
recht fester Regelsatz. Aber wenn wir nur interne Rechner vom 1.1.1.0 Adressbereich
zu ssh verbinden lassen wollen, aber Verbindungen von au&szlig;erhalb zu
http und https zulassen wollen?
</p>

<ul>
<pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre>
</ul>
Recht nett, aber wenn nur eine einzige Machine (1.1.1.1) den Webserver
administrieren darf? In diesem Fall &auml;ndern wir dies:
<ul>
<pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
</pre>
</ul>
in:
<ul>
<pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22</pre>
</ul>
IP Filter unterst&uuml;tzt sowohl CIDR als auch Punkt/Dezimalformat der
Netzmaskenadresse. Obiges in anderer Schreibweise:
<ul>
<pre>pass in quick on fxp0 from 1.1.1.1/255.255.255.255 to any port = 22</pre>
</ul>
aber warum solltest du?
<b></b>

<p>
<b>Beispielregeln</b>
<p>Hier ein paar gute Regeln, die jeder verwenden kann (angenommen wird,
da&szlig; fxp0 das externe Interface mit Internetverbindung ist). Zun&auml;chst
einfacher Schutz gegen Adressenschwindel ("address spoofing").
<ul>
<pre>block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8</pre>
</ul>
Eine gute Idee ist es, das loopback Interface von deinen anderen Regeln
zu trennen.
<ul>
<pre>pass out quick on lo0
pass in quick on lo0</pre>
</ul>
Unsere Regelsatz schaut schon recht gut aus. Zusammen sieht er so aus:
<ul>
<pre>
# Loopback regeln

pass out quick on lo0
pass in quick on lo0

# anti-adressenschwindel von nicht-routebaren adressen

block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# nur unser administrationsrechner darf sich mittels ssh verbinden

pass in quick on fxp0 from 1.1.1.1/32 to any port = 22

# erlaube anderen http und https

pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443

# zuletzt standardmaessiges ablehnen</pre>

<pre>block in quick on fxp0 from any to any

# und lass ausgehenden datenverkehr raus

pass out on fxp0 from any to any

</pre>
</ul>
</p>

<b>Paket logging</b>
<p>Nun, dies ist zwar schon recht gut, aber es k&ouml;nnte besser sein.
Z. B. wenn wir alle Verbindungsversuche zu Port 22(ssh) loggen wollten,
die von unserer Firewall blockiert werden? Einfach - IP Filter hat daf&uuml;r
das <em>log</em> Stichwort:
<ul>
<pre>pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
block in log quick on fxp0 from any to any port = 22</pre>
</ul>
Diese Regel wird erlauben, da&szlig; sich unser Administrationsrechner
auf Port 22 verbinden darf, aber alle anderen Verbindungsversuche auf Port
22 ablehnt und aufzeichnet.
</p>

<b>Protokollbasierende Paketfilterung</b>
<p>IP Filter kann auch nach jedem IP Protokoll filtern, entweder nach seiner Nummer oder seinem Name, der in <a href="file://localhost/etc/protocols">/etc/protocols</a>
aufgelistet ist. Im Sinne der Klarheit werden wir uns nur mit tcp, udp
und icmp besch&auml;ftigen.
Dies sind die am meisten verwendeten Protokolle, auf denen alle grundlegenden Internetanwendungen basieren. 
<p>Damit IPF protokollbasierend filtert mu&szlig; das Stichwort <i>proto</i>
verwendet werden. Um unsere fr&uuml;here ssh Beispielsregel zu verwenden,
da ssh ja &uuml;ber tcp rennt,&nbsp; sollten wir nur tcp Pakete zur Verbindung
zulassen. Mit dem <i>proto</i> Stichwort erlauben wir nur tcp, und wir
bekommen eine Regel wie folgt:
<ul>
<pre>pass in quick on fxp0 proto tcp from 1.1.1.1/32 to any port = 22</pre>
</ul>
Aber wenn wir eine Verbindung f&uuml;r einen Dienst brauchen, die tcp und
udp ben&ouml;tigt (wie z. B. bind)? Nun im Falle von tcp/udp erlaubt uns
IP Filter beide Protokolle zusammen zu schreiben. NB: Dies gilt nur f&uuml;r
tcp/udp. F&uuml;r das bind Beispiel w&uuml;rde folgende Regel tcp und udp
Verbindungen (bei standardm&auml;&szlig;igem Ablehnen) erlauben:
<ul>
<pre>pass in quick on fxp0 proto tcp/udp from any to any port = 53</pre>
</ul>
</p>

<b>Paketfilterung</b>
<p>Zus&auml;tzlich zur protokollbasierenden Filterung ist IP Filter auch
zum Handhaben der zersplitterten IP Pakete f&auml;hig (eine allgemeine
Methode des Besiegens der Paketfilter). Es gibt zwei m&ouml;gliche Schl&uuml;sselw&ouml;rter:&nbsp;
<em>frag</em> f&uuml;r allgemein zersplitterte IP Pakete, oder <em>short</em>
f&uuml;r IP Pakete mit f&uuml;r Vergleiche zu kurzen Informationen (<em>headers</em>).
Da zersplitterte Pakete auch normalerweise auftreten k&ouml;nnen, abh&auml;ngig
von den Verbindungsumst&auml;nden, es ist am besten, Pakete mit den Vors&auml;tzen
nur zu filtern, die f&uuml;r g&uuml;ltigen Vergleich zu klein sind. Dieses
kann mit der folgenden Richtlinie vollendet werden:
<ul>
<pre>block in quick proto tcp all with short</pre>
</ul>
Und bzgl. IP Optionen? IP Filter kann jene Pakete auch behandeln. Pakete
k&ouml;nnen entweder fallengelassen werden, wenn sie IP Optionen haben,
oder sie spezifischen IP Optionen besitzen, die eingestellt werden. Z.
B. l&auml;&szlig;t die folgende Richtlinie fallen und protokolliert alle
Pakete mit den eingestellten IP Optionen.
<ul>
<pre>block in log quick on fxp0 all with ipopts</pre>
</ul>
Dies kann aber einige Dinge wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=traceroute&sektion=8&format=html">traceroute(8)</a>
brechen. Du kannst auch bestimmte Optionen verbieten. Z. B. ist eine gute
Regel, alle Pakete mit "source routing" Option zu verbieten. Dies geschieht
mit dieser Regel:
<ul>
<pre>block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr</pre>
</ul>
<b>TCP Flags, bestehende Verbindungen und keep state</b>
<p>Nun kommt IP Filter in vollem Ernst: IP Filters gr&ouml;&szlig;te
St&auml;rken liegen in der F&auml;higkeit, Pakete anhand ihrer TCP flags
(=Kennzeichen) zu filtern und bestehende Verbindungen und Verbindungszust&auml;nde
aufrechtzuerhalten. Man sollte die Rolle jedes TCP flags verstehen, wenn
man die Pakete danach filtern will. Z. B. wenn du alle Pakete mit den FIN,
URG und PSH flags filtern willst (f&uuml;r z. B. einen "nmap OS fingerprinting
attempt"), dann solltest du eine Regel wie diese einsetzen:
<ul>
<pre>block in quick on fxp0 proto tcp from any to any flags FUP</pre>
</ul>
(Danke an <a href="mailto:halogen@nol.net">Kyle Hargraves</a> f&uuml;r
diesen Tip)
</p>
<p>Die n&auml;chste F&auml;higkeit von IP Filter ist, Verbindungszust&auml;nde
beizubehalten. Den Zustand beizubehalten ist beschrieben worden, wie "
nicht sprechend bis gesprochen mit ", das hei&szlig;t, sobald ein Anschlu&szlig;
hergestellt ist, m&uuml;ssen Pakete die Regels&auml;tze nicht mehr &uuml;berqueren.
Dieses ist eine sehr leistungsf&auml;hige Eigenschaft, was viel einfacheres
und sichereres Richtlinie Schreiben erlaubt.
</p>
<p>Z. B. lassen sehen wir uns an, wie wir Zustand an unserem vorhergehenden
Beispielregelsatz anwenden k&ouml;nnen (schon verwirrt?). Zu Wiederholung,
wir erlauben Managementzugriff von unserem Klasse C Netz zu Kanal 22 (ssh)
und erlauben allen ankommenden Web-Verkehr auf Kan&auml;len 80 (http) und
443 (https). Wir blocken jeglichen weiteren Verkehr. Aber was, wenn ich
mit ssh aus dem webserver heraus w&uuml;nsche? Was, wenn ich lynx benutzen
mu&szlig;, um etwas im FAQ nachzuschauen? Gut, kann ich nicht, weil ich
alle ankommenden Anschl&uuml;sse anders als auf den spezifizierten Kan&auml;len
geblockt habe. W&auml;hrend dieses der sicherste Weg ist, kann es ziemlich
ung&uuml;nstig bzw. unhandlich sein. Indem wir die Schl&uuml;sselw&ouml;rter
<em>keep state</em> unserer "pass out" Richtlinie hinzuf&uuml;gen, k&ouml;nnen
wir ankommende Verbindungen in Erwiderung auf von uns selbst initialisierte
Verbindungen automatisch erlauben, wie z. B. beim Webbrowsen.
NB: Wir m&uuml;ssen das Protokol angeben, f&uuml;r das wir "keep state" 
halten.
<ul>
<pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
</ul>
Diese kleine &Auml;nderung wird die Flexibilit&auml;t und Sicherheit unseres
Regelsatzes dramatisch erh&ouml;hen, weil IP Filter extrem flexibel ist.
 Z. B. erlauben wir im obigen Regelsatz jeden TCP-Datenverkehr
auf Ports 80 &amp; 443. Wir k&ouml;nnen dies noch besser machen: Um eine
TCP Verbindung zu errichten, m&uuml;ssen wir nur die erste Verbindungsanfrage
erlauben. Sobald dies geschieht, k&ouml;nnen wir diesen Kanal blockieren
und unsere "keep state" Regel die Verbindung verwalten lassen. Um die erste
Verbindungsanfrage vollenden zu lassen, ben&ouml;tigen wir nur Pakete mit
SYN und SYNACK Kennzeichen. Indem wir nur solche Pakete durchlassen, k&ouml;nnen
wir z. B. viele Arten von "portscanning" aufgrund von FIN Kennzeichen verhindern.
Die Regel sieht nun so aus:
<ul>
<pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
</pre>
</ul>
Nun schreiben wir alles zusammen: Dieser Regelsatz hat standardm&auml;&szlig;iges
Ablehnen, erlaubt Administration nur via ssh vom internen Netzwerk und
erlaubt ankommenden Datenverkehr zu Ports 80 (http) und 443 (https). Er
wird auch gegen Adressenschwindel von nicht-routebaren Adressen sch&uuml;tzen
und alle zu fragmentierten Pakete verwerfen. Eine recht umfassende Einstellung
f&uuml;r einen Webserver. Hier unsere /etc/ipf.rules:
<ul>
<pre>
# loopback rules
pass out quick on lo0
pass in quick on lo0

# drop itsy bitsy frags
block in quick proto tcp all with short

# drop source routed packets
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr

# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# only allow our machines to connect via ssh
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22

# allow others to use http and https
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA

# finally lock the rest down with a default deny
block in quick on fxp0 from any to any

# and let out-going traffic out and maintain state on established connections
# -- The flags S on the keep state is to ensure that state tracking starts
#    only on the first outbound packet in a tcp session. 
#    unnecessary consumption of state table entries.
# -- The flag s only works on the tcp protocol, so three entries are required to 
#    to cover all three protocols (tcp, udp, icmp).

pass out      quick on fxp0 proto tcp  from any to any flags S keep state
pass out      quick on fxp0 proto udp  from any to any         keep state
pass out      quick on fxp0 proto icmp from any to any         keep state

</pre>
</ul>
</p>

<p>
Wenn du Schwierigkeiten hast, dann kannst du Logging f&uuml;r bestimmte 
Regels&auml;tze aktivieren; 
z.B.: pass in log quick on fxp0 from 1.1.1.0/24 to any port = 22
Wenn du die Konfigurationsdatei so modifizierst, um Pakete zu loggen, 
vergi&szlig; nicht, mit "ipf -Fa -f /etc/ipf.rules" die &Auml;nderungen auch 
zu aktivieren! 
ipmon wird die ip-Logeintr&auml;ge in /var/log/ipflog schreiben.
F&uuml;r weitere Informationen &uuml;ber ipf siehe das <a href="http://www.obfuscation.org/ipf/ipf-howto.txt">IPF
how-to</a> als exzellente Informationsquelle sowie die 
<a href="http://coombs.anu.edu.au/~avalon/ip-filter.html">IP
Filter</a> Homepage.
</p>


<p>
<a name="6.3"></a>
<h2>6.3 - IPNAT</h2>
</p>

<p>
Initiale Arbeit von Wayne Fergerstrom &lt;wayne@methadonia.net&gt;
</p>

<a name="nat1.0"></a>
<h3><u>6.3.1 NAT Einf&uuml;hrung</u></h3>

<a name="nat1.1"></a>
<b>Kapiteleinf&uuml;hrung</b>
<p>
Dieses Kapitel versucht jenen zu helfen, die Network Address Translation ("NAT") 
auf ihrem OpenBSD Rechner installieren und konfigurieren wollen. 

Der Benutzer sollte bereits den OpenBSD Rechner mit zwei Netzwerkkarten installiert 
und konfiguriert haben (eine mit dem Internet verbunden, die andere mit dem lokalen 
Netzwerk). 
IP NAT wird auch auf Rechnern mit nur einer Netzwerkkarte laufen, 
aber da die IP Pakete auf ein und demselben Interface ein- und ausgehen, 
werden Ethernetkollisionen die Leistung drastisch vermindern.  
</p>

<p>
Gem&auml;&szlig; <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a> bietet ipnat 
einen einfachen Weg, um interne Netzwerke auf eine einzige routebare (&quot;reale&quot;) 
Internetadresse umzulegen. 
Dies ist sehr n&uuml;tzlich, wenn man nicht f&uuml;r jeden Rechner des internen Netzwerkes eine 
offizielle Adresse zugewiesen bekommen hat.
Wenn man ein privates/internes Netzwerk besitzt, dann kann man die 
(in <A HREF="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a> definierten) Adressbereiche 
benutzen:
<P>

10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>

</p>

<a name="nat1.2"></a>
<b>Terminologie</b>

<p>
Die in diesem Dokument verwendeten Konventionen sind sehr einfach.
F&uuml;r Documentationszwecke werde ich einige der Terme und Formate erkl&auml;ren.
</p>

<ul>
<strong>"NAT"</strong>
<p>
Dies beschreibt die Funktion von "Network Address Translation" (Netzwerkadress&uuml;bersetzung).
Der Prozess des NAT wird sp&auml;ter in diesem Dokument beschrieben.
</p>
</ul>

<ul>
<strong>"ipnat"</strong>

<p>
Abk&uuml;rzung f&uuml;r "IP Network Address Translation", kann mit NAT austauschbar verwendet werden. 
In diesem Dokument wird der Terminus "ipnat" aber nur f&uuml;r die Kommandozeile verwendet werden.
</p>
</ul>

<ul>
<strong>"IPF"</strong>

<p>
Abk&uuml;rzung f&uuml;r "IP Filter." IP Filter ist eine portable Paketfilterungssoftware, welche 
Teil von OpenBSD ist. IP Filter mu&szlig; zuerst aktiviert werden, bevor man ipnat benutzen kann. 
Ganz einfach: Editiere /etc/rc.conf und &auml;ndere ipfilter=NO in ipfilter=YES. Dies &auml;ndert 
es aber erst f&uuml;r das n&auml;chste Rebooten. 
Mit 'ipf -E' schaltest du es im laufenden Betrieb ein. Genaueres nat&uuml;rlich sp&auml;ter. 
</p>
</ul>

<br>
<a name="nat1.3"></a>
<b>Konfiguration</b>

<p>
So sind die Computer eingerichtet, die in diesem Dokument beschrieben werden. Deine werden 
von diesen abweichen, aber der Zweck dieses Dokumentes ist, dir eine &Uuml;bersicht zu verschaffen, 
damit du diese Information f&uuml;r deine Bed&uuml;rfnisse verwenden kannst.
</p>

<ul>
<b>Computer Betriebssystem: </b>OpenBSD v2.7 i386<br>
<br>
<b>Netzwerkkarten: </b>
<ul>
	NetGear 10/100MB <b>dc0</b><br>
	Verbunden mit dem EXTERNEN LAN (oder WAN)<br>
	<b>IP Adresse: </b>24.5.0.5<br>
	<b>Netzmaske: </b>255.255.255.0<br>
	<br>
	NetGear 10/100MB <b>dc1</b><br>
	Verbunden mit dem INTERNEN LAN<br>
	<b>IP Adresse: </b>192.168.1.1<br>
	<b>Netzmaske: </b>255.255.255.0<br>	
</ul>
<br>
<b>Externe, Internet-routebare IP (vom ISP bereitgestellt, in diesem Beispiel ein Kabelmodemprovider)<br></b>
<ul>
	<b>IP Adresse: </b>24.5.0.5<br>
	<b>Netzmaske: </b>255.255.255.0<br>
	<b>Gateway: </b>24.5.0.1<br>
</ul>
<br>
<b>LAN - Lokales Netzwerk</b><br>
<ul>
In diesem Beispiel werden die Rechner im LAN das IP Adressierungsschema 
192.168.1.xxx (wobei xxx eine eindeutige Nummer darstellt) verwenden. 
Es gibt eine gro&szlig;e Anzahl verschiedener Betriebssysteme im internen LAN wie Windows 98,
Windows NT, OpenBSD und Linux. Jeder Rechner ist mit einem Hub, der f&uuml;r den internen 
Gebrauch bereitsteht, verbunden. F&uuml;r diese Dokument und dessen Beispiele wird der 
Rechner im LAN die IP Adresse 192.168.1.40 annehmen.
</ul>
<br>
<b>Diagramm der Konfiguration</b>
<ul><pre>
+-----+              +---------+         +----------+
| Hub |--------- dc1 |   NAT   | dc0 ----| Internet |
+-----+              +---------+         +----------+
  | |
  | +-- Rechner A
  +---- Weitere Rechner 

                              +-------------------------+
                              |         LEGENDE         |
                              +-------------------------+
                              |  NIC dc0 - 24.5.0.5     |
                              |  NIC dc1 - 192.168.1.1  |
                              |Rechner A - 192.168.1.40 |
                              +-------------------------+

</pre></ul>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Network Address Translation</u></h3>
<br>

<a name="nat2.1"></a>
<b>Einf&uuml;hrung zu NAT</b>

<p>
Da immer mehr und mehr Firmen und Private das Internet benutzen, 
mu&szlig; jeder eine IP Adresse haben. &Ouml;ffentliche IP Adressen sind immer 
schwieriger zu bekommen. Die L&ouml;sung f&uuml;r viele Leute ist Network 
Address Translation (oder "NAT"). NAT ist ein sehr einfaches, aber 
sehr wirkungsvoller Weg, um dein LAN mit dem Internet zu verbinden, 
ohne IP Adressen kaufen oder mieten zu m&uuml;ssen. NAT ist unter Linuxbenutzern 
auch als "IP Masquerading" bekannt.
</p>

<p>
Wenn NAT richtig eingerichtet ist, erlaubt es den Benutzern des internen 
LANs, das Internet mit einer anderen IP Adresse (jene von deinen Provider) 
zu benutzen. Jeder Rechner im LAN benutzt diese eine IP Adresse (transparent) 
vom Rechner mit der vom ISP zugewiesenen IP Adresse.
</p>

<p>
NAT arbeitet auf verbl&uuml;ffend einfache Weise. Wenn ein Rechner im LAN
sich mit einem Rechner im Internet verbinden will, sendet er ein TCP Paket 
mit einer Verbindungsanfrage. Innerhalb des TCP Paketdatenkopfes 
(&quot;headers&quot;) steht die Rechner IP Adresse (hier 192.168.1.40) und 
die erw&uuml;nschte Server IP Adresse (z. B. 123.45.67.89). Die Maschine mit NAT 
f&auml;ngt das TCP Paket ab und &auml;ndert die Rechner IP Adresse in die Adresse des 
Rechners, der mit dem Internet verbunden ist (z. B. 24.5.0.5). Dies t&auml;uscht 
den Server eigentlich, indem es ihn glauben macht, da&szlig; die Verbindung vom 
NAT Rechner und nicht vom eigentlichen Rechner A kommt. Der Server schickt 
dann die Antworten zur&uuml;ck zum NAT Rechner. Wenn der NAT Rechner 
die Antwort erh&auml;lt, dann &uuml;bersetzt er die Zieladresse zur&uuml;ck von seiner 
eigenen IP zu der von Rechner A und schickt das Paket an Rechner A weiter. 
Rechner A bekommt von alledem nichts mit und die vorget&auml;uschte Internetverbindung 
ist total transparent.
</p>

<p>
Das folgende Beispiel zeigt NAT noch ein bi&szlig;chen deutlicher:
</p>

<ul><pre>
Rechner ---------------- dc1 [ NAT ] dc0 ---------- Internetserver
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 ----- 123.45.67.89

AUSGEHENDES TCP Paket                   AUSGEHENDES TCP Paket
Von:  192.168.1.40   &gt;&gt;=== NAT ===&gt;&gt;     Von:  24.5.0.5
Nach: 123.45.67.89                      Nach: 123.45.67.89

INCOMING TCP Paket                     EINGEHENDES TCP Paket
Von:  123.45.67.89 			Von:  123.45.67.89
Nach: 192.168.1.40   &lt;&lt;=== NAT ===&lt;&lt;     Nach: 24.5.0.5
</pre></ul>

<br>
<a name="nat2.2"></a>
<b>Warum NAT verwenden</b>

<p>
In meiner neuen Wohnung bekam ich ein Kabelmodem und somit ein kleines 
Problem. Wie k&ouml;nnen meine Zimmerkameraden Internetanschlu&szlig; bekommen, wenn 
das Kabelmodem in meinem Zimmer steht? Ich hatte ein paar Alternativen wie 
zus&auml;tzliche IP Adressen kaufen, einen Proxyserver aufsetzen oder eben NAT 
einsetzen. 
(La&szlig; dich nicht vom Kabelmodembeispiel t&auml;uschen: NAT ist f&auml;hig, ein gro&szlig;es 
Netzwerk mit hunderten oder auch tausenden Computern zu maskieren!)
</p>

<p>
Es gibt viele Gr&uuml;nde, warum ich NAT aufsetzen wollte. Nummer eins: Geld sparen. 
Zwei Zimmerkameraden in meinem Haus haben ihre eigenen PCs und ich besitze 
insgesamt 3 Computer. Mein ISP erlaubt nur drei IP Adressen pro Haushalt.
D. h., da&szlig; wir nicht genug IPs h&auml;tten, um jedem Rechner Internetzugang zu 
verschaffen.
</p>

<p>
Mit NAT hat jeder Rechner eine eindeutige (interne) IP Adresse, aber 
alle teilen sich eine IP Adresse von meinem ISP. Die Kosten sinken.
</p>

<br>
<a name="nat2.3"></a>
<b>Setup</b>

<p>
Damit NAT auf deinem OpenBSD Rechner l&auml;uft, mu&szlig;t du zun&auml;chst 
IPF und NAT aktivieren. Dies geschieht einfach, indem du die unten angef&uuml;hrten 
Dateien editierst (&auml;ndere die Dateien gem&auml;&szlig; den folgenden Optionen):
</p>

<p>
<b>/etc/rc.conf</b> (diese Datei wird beim Booten f&uuml;rs Starten von Diensten gelesen)
</p>

<ul>
	ipfilter=YES<br>
	ipnat=YES
</ul>

<p>
<b>/etc/sysctl.conf</b>
</p>

<ul>
	net.inet.ip.forwarding=1
</ul>

<p>
Nachdem diese &Auml;nderungen durchgef&uuml;hrt wurden, ist der Rechner endlich f&uuml;r die 
Konfiguration von NAT bereit.
</p>

<br>
<a name="nat2.4"></a>
<b>Konfiguration</b>

<p>
Der erste Schritt ist die Konfiguration der IPF Regelsatzdatei (<i>/etc/ipf.rules</i>).
Daf&uuml;r werden wir in diesem Dokument jeden Datenverkehr durch diese Firewall passieren 
lassen. Die Datei sollte so aussehen:
</p>

<ul><pre>
pass in from any to any
pass out from any to any
</pre></ul>

<p>
Siehe wiederum <a href="#6.2">FAQ 6.2</a> f&uuml;r weitere Informationen.
</p>

<p>
Die NAT Konfigurationsdatei (<i>/etc/ipnat.rules</i>) folgt einer sehr einfachen Syntax.
Um obige Konfiguration fortzusetzen, sollte die Datei die folgenden Eintr&auml;ge enthalten: 
</p>

<ul><pre>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32
</pre></ul>

<p>
Hier eine Erkl&auml;rung f&uuml;r die obigen Zeilen.
</p>

<ul>
<strong>"map"</strong>
<p>
Der Befehl an ipnat. Er besagt, da&szlig; dieser Eintrag die IP Adressen zwischen 
LAN und the Internet &auml;ndert.
</p>
</ul>

<ul>
<strong>"dc0"</strong>
<p>
Die Netzwerkkarte, die mit dem Internet verbunden ist.
</p>
</ul>

<ul>
<b>"192.168.1.0/24"</b>
<p>
Die IP Adresse und Netzmaske (die Netzmaske ist im
CIDR Format). Kombiniert besagen sie, da&szlig; "jede IP Adresse von 
192.168.1.1 bis 192.168.1.254" umgelegt werden soll. Wenn du die CIDR 
nicht verwenden willst, dann kannst du "/24" f&uuml;r 
"/255.255.255.0" verwenden.
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
Diese IP Adresse und Netzmaske sind die IP Adresse, auf 
die die LAN IP Adressen umgelegt werden.  /32 bedeutet eine einzige 
IP Adresse.  Du kannst also auf /24, oder 256 IP Adressen (oder auf /27,
oder wieviele Bits du auch immer w&uuml;nscht) umlegen!! Dies ist
n&uuml;tzlich, wenn du  mehrere tausend Rechner hinter deinem NAT hast....
(Nat&uuml;rlich ist dies nur n&uuml;tzlich, wenn diese /24 &uuml;ber deinen 
OpenBSD Rechner gerouted werden!)
</p>
</ul>

<ul>
<b>"portmap tcp/udp 10000:60000"</b>
<p>
Dies legt alle tcp/udp Pakete
auf Ports von 10000 auf 60000.
</p>
</ul>

<p>
Die zweite Zeile hat beinahe den selben Eintrag au&szlig;er f&uuml;r den 
letzten Teil. Dies bedeutet f&uuml;r ipnat, auch alle anderen (nicht 
tcp/udp Pakete, die bereits von der ersten Zeile erfa&szlig;t worden sind) 
zu jenen Ports umzulegen, die erfragt werden (z. B. ICMP und andere 
Protokolle). Wenn dies einmal in dieser Datei ist, dann hat man alles, um 
den IPF Dienst zu betreiben.
</p>

<br>

<a name="nat2.5"></a>
<b>Selektives NAT</b>

<p>
Du m&ouml;chstest NAT vielleicht auf einige Adressbereiche beschr&auml;nken.
Aufbauend auf das obige Beispiel nehmen wir an es g&auml;be Hosts auf dem 
24.5.0.0/28 Netzwerk, f&uuml;r das dein NAT gateway als simpler Router
agieren soll, und zwar ohne Adressumsetzung.
Du kannst die "adress translation" f&uuml;r Netzwerkverkehr, der von dc0 in dieses
Subnetz geht, wie folgt unterdr&uuml;cken:
</p>

<ul><pre>
map dc0 from 192.168.1.0/24 ! to 24.5.0.0/28 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 from 192.168.1.0/24 ! to 24.5.0.0/28 -&gt; 24.5.0.5/32
</pre></ul>

<a name="nat2.6"></a>
<b>Betrieb</b>

<p>
NAT zu betreiben ist auch ein sehr einfacher Vorgang. Ist die Konfiguration 
erst einmal komplett, dann gibt es zwei M&ouml;glichkeiten, um NAT zu aktivieren. 
Die erste (und beste, um die Rebootphase zu testen), ist, deinen OpenBSD Rechner 
zu rebooten.
Dies geschieht mit dem Befehl "<i>reboot</i>"
</p>

<p>
Wenn du ipnat von der Kommandozeile starten willst, dann benutze die folgenden
Befehle:
</p>

<ul><pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre></ul>

<p>
Die erste Zeile aktiviert IPF (NB: NAT setzt auf IPF auf, daher mu&szlig; 
IPF initialisiert und gestartet werden, bevor NAT geladen werden kann).
Die Optionen der Kommandozeile "-Fa" kl&auml;ren alle noch existierende 
Eintr&auml;ge. "-f /etc/ipf.rules" sagt IPF, wo die Regeldatei gefunden werden 
kann. "-E" ist die Option, um den IPF Dienst zu aktivieren.
</p>

<p>
Die zweite Kommandozeile aktiviert NAT. "-CF" kl&auml;rt alle existierenden 
Entr&auml;ge in der NAT Tabelle. "-f /etc/ipnat.rules" sagt NAT, 
wo die NAT Regeldatei zu finden ist. NAT l&auml;uft nun. So einfach ist das.
</p>


<p>
<b>NB:</b> Um die NAT Einstellungen neu zu laden (im Falle, da&szlig; du die 
Datei editiert hast, aber nicht rebooten willst), mu&szlig;t du nur den zweiten
Befehl wiederholen. Die Einstellungen werden neu geladen. 
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 NAT Grundwissen</u></h3>

<br>
<a name="nat3.1"></a>
<b>&Uuml;berpr&uuml;fen des NAT Status</b>

<p>
Um herauszufinden, was NAT tut oder um sicherzustellen, da&szlig; die 
gew&uuml;nschten Einstellungen auch in Kraft sind, kannst du die "-l" Option 
verwenden. Diese Option listet alle Einstellungen und laufende Sitzungen:
</p>

<ul><pre>
# <b>ipnat -l</b>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32

List of active sessions:
MAP 192.168.1.40  2473  &lt;- -&gt; 24.5.0.5  13463 [129.128.5.191 80]
</pre></ul>

<p>
Der Zweck der ersten beiden Zeilen ist, die Einstellungen von /etc/ipnat.rules 
zu best&auml;tigen. Die Zeile(n) darunter zeigen die aktiven NAT Verbindungen.
</p>

<ul>
<b>"MAP 192.168.1.40  2473"</b>
<p>
Dies zeigt dir die IP Adresse des LAN Rechners, der NAT benutzt. Die Portnummer 
der Verbindung wird anschlie&szlig;end gezeigt.
</p>
</ul>

<ul>
<b>"&lt;- -&gt;"</b>
<p>
Dies zeigt, da&szlig; NAT den Datenverkehrflu&szlig; in beiden Richtungen 
behandelt.
</p>
</ul>

<ul>
<b>"24.5.0.5  13463"</b>
<p>
Dies stellt dar,  das&szlig; die Verbindung zum Internet &uuml;ber 
die IP Adresse 24.5.0.5 und Port 13463 abgewickelt wird.
</p>
</ul>

<ul>
<b>"129.128.5.191 80"</b>
<p>
Zuletzt werden IP Adresse und Port der Zieladresse angezeigt.
</p>
</ul>

<a name="nat3.2"></a>
<b> Einschr&auml;nkungen von NAT (bei FTP)</b>

<p>
Es gibt ein paar Einschr&auml;nkungen von NAT. Eine ist bei FTP. Wenn ein Benutzer 
sich zu einem entfernten FTP Server verbindet und Informationen oder Dateien 
verlangt, wird der FTP Server eine Verbindung zum Klient aufbauen und die Daten 
auf einem willk&uuml;rlichen freien Port &uuml;bertragen. 
Dies ist ein Problem f&uuml;r Benutzer innerhalb des LAN. 
Denn der FTP Server sendet seine Informationen an die externe Netzwerkkarte 
auf einem willk&uuml;rlichen Port. Der NAT Rechner wird dies zwar empfangen, 
aber weil es keine Umlegungsregeln f&uuml;r dieses unbekannte Paket oder f&uuml;r 
diesen Kanal gibt, wird er das Paket verwerfen und nicht liefern.

<p>
Die L&ouml;sung daf&uuml;r ist, das FTP Programm in "passive mode" zu setzen. 
Dies teilt dem Server mit, da&szlig; du dich selbst aktiv zum Server verbinden 
willst. Wenn du nun eine Verbindung nach draussen machst, wird NAT deine Verbindung 
richtig behandeln. 
<P>
IP Filter bietet eine andere L&ouml;sung f&uuml;r dieses Problem an:
ein FTP Proxy, der im NAT Quelltext eingebaut ist.
Um ihn zu aktivieren, f&uuml;ge etwas wie folgendes VOR deinen anderen NAT Regeln 
ein.
<PRE>
map dc0 192.168.1.0/24 -&gt; 24.5.0.5/32 proxy port ftp ftp/tcp
</pre>
Mit dieser Regel wird der Kernel deine FTP Verbindungen auf den 
"PORT" Befehl vom FTP Programm &uuml;berwachen und wird die IP Adresse und 
Port mit seiner eigenen externen IP Adresse austauschen und einen Port 
seiner Wahl bestimmen. Dann wird er einen Kanal &ouml;ffen und die Daten zum 
Port, nach dem dein FTP Programm gefragt hat, tunneln. 
Dies ist offensichtlich etwas ressourcenintensiver. Aber es sollte gehen, 
solange dein NAT/IP Filter Rechner nicht &uuml;berm&auml;&szlig;ig beansprucht 
wird.
<P>


<br>
<a name="nat3.3"></a>
<b>Datenverkehr umleiten</b>

<p>
Zuweilen willst du ankommenden oder ausgehenden Datenverkehr eines 
bestimmten Protokolles oder Kanals umleiten. Ein gutes Beispiel daf&uuml;r ist 
ein Webserver, der im internen LAN h&auml;ngt. Ankommende Verbindungen zu 
deiner g&uuml;ltigen, offziellen IP Adresse werden keine Verbindung aufbauen 
k&ouml;nnen, wenn auf deinem NAT Rechner kein Webserver rennt. Daf&uuml;r gibt 
es bei NAT die 'rdr' Direktive in der Regelsatzdatei, die festlegt, ob und 
wohin eine bestimmte Verbindung umgeleitet werden soll.
</p>

<p>

F&uuml;r unser Beispiel nehmen wir an, da&szlig; ein Webserver im LAN mit der 
IP Adresse 192.168.1.80 existiert. Die NAT Regeldatei ben&ouml;tigt eine 
neue Direktive. F&uuml;ge eine Zeile wie folgende in ipnat.rules ein: 
</p>

<ul><pre>
rdr dc0 24.5.0.5/32 port 80 -&gt; 192.168.1.80 port 80
</pre></ul>

<p>
Die Erkl&auml;rung:
</p>

<ul>
<b>"rdr"</b>
<p>
Diesen Befehl gibst du ipnat: Ipnat soll eine Verbindung umleiten. 
</p>
</ul>


<ul>
<b>"dc0"</b>
<p>
Die mit dem Internet verbundene Netzwerkkarte. 
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
Dies bezieht sich auf die ankommenden Verbindungen zu dieser IP Adresse (nur 
auf dc0, wie oben)
</p>
</ul>

<ul>
<b>"port 80"</b>
<p>
Der Port (80), der umgeleitet werden soll. Die Zahl "80" mu&szlig; nicht 
explizit benutzt werden. Du kannst auch "port www" verwenden. Wenn du den 
Namen anstelle der Nummer verwendest, dann m&uuml;ssen auch Name und die 
korrespondierende Zahl in der Datei /etc/services existieren.
</p>
</ul>

<ul>
<b>"192.168.1.80"</b>
<p>
Die IP Adresse und Netzmaske des LAN Rechners, zu dem die Pakete umgeleitet 
werden. Die Netzmaske ist immer "/32" (und m&uuml;ussen daher nicht 
spezifiert werden). 
</p>
</ul>

<p>
Danach lade die NAT Regeln neu und die Umleitungen werden sofort in Kraft treten.
</p>

<br>
<a name="nat3.4"></a>
<b>NAT versus Proxy</b>

<p>
Der Unterschied zwischen NAT und einem applikationsbasierten Proxy liegt darin,  
da&szlig; die Proxysoftware als Mittelsmann zwischen Internet und den im LAN 
verbundenen Rechnern agiert. Nur mu&szlig; f&uuml;r jede Anwendung und 
Internetverbindung ein daf&uuml;r geeigneter Proxy bereitstehen. Nicht alle 
Anwendungen k&ouml;nnen dies (vor allem Spiele nicht). 
NAT "mapped" dein internes Netzwerk transparent, sodass es mit dem Internet 
verbunden ist. Der einzige Sicherheitsvorteil von Proxysoftware gegen&uuml;ber 
NAT ist, da&szlig; die Proxysoftware sicherheitstechnisch im Vorteil ist, wenn 
wenn den Inhalt filtern kann; z. B. Makroviren f&uuml;r Windowsrechner filtert, 
oder gegen Buffer-overflows sch&uuml;tzt, udgl. Diese Filter zu administrieren 
bedeutet viel Arbeit.
</p>

<a name="nat4.0"></a>
<b>6.3.4 Links und Querverweise</b>

<p>
OpenBSD Dateien:
<ul>
<li>/etc/ipnat.rules - NAT Regelsatzdatei 
<li>/etc/rc.conf - editieren, damit ipnat und ipf beim Starten aktiviert werden
<li>/etc/sysctl.conf - editieren, damit IP Forwarding aktiviert wird
<li>/usr/share/ipf/nat.1 - Beispiele von ipnat.rules
</ul>
</p>

<p>
NAT Internet Links:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8&manpath=OpenBSD+2.7">http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=5&manpath=OpenBSD+2.7">Man page showing correct ipnat.rules syntax</a>
<li><a href="http://coombs.anu.edu.au/~avalon/">http://coombs.anu.edu.au/~avalon/</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>

<p> 
<a name= "6.4"></a> <h2>6.4 - DHCP</h2> </p>

<h3>6.4.1 DHCP Klient</h3>
<p>Um den DHCP Klient <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&apropos=0&sektion=8&format=html">dhclient(8)</a>
zu benutzen, der Teil von OpenBSD ist, editiere /etc/hostname.xl0
(wenn deine Hauptethernetkarte xl0 ist. Deine kann ep0 oder fxp0 oder 
irgendeine andere sein!). 
Alles, was du in dieser Datei zu schreiben hast, ist 'dhcp'.
<pre>
# <strong>echo dhcp &gt;/etc/hostname.xl0</strong>
</pre>
Dies wird OpenBSD veranlassen, den DHCP Klient automatisch beim Booten zu 
starten.  OpenBSD wird sich seine IP Adresse, sein Standardgateway und seine 
DNS Server vom DHCP Server besorgen.  
<p>
Wenn du den DHCP Klient von der Befehlszeile starten willst, stelle sicher, 
da&szlig; /etc/dhclient.conf existiert, dann versuche:
<PRE>
# <strong>dhclient fxp0</strong>
</pre>
Wobei fxp0 die Netzwerkkarte ist, auf der du DHCP empfangen willst.
<P>Wie du auch immer dhclient startest, du kannst die /etc/dhclient.conf Datei 
immer so editieren, da&szlig; dein DNS <b>nicht</b> erneuert wird aufgrund 
der neuen DNS Informationen, indem du die 'require' Zeilen auskommentierst 
(Es gibt Beispiele in den Standardeinstellungen, aber du mu&szlig;t die 
Standardeinstellungen von dhclient &uuml;berschreiben.). 
<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>
und dann <b>entferne</b> domain-name-servers.  Nat&uuml;rlich kannst du auch 
hostname oder andere Einstellungen entfernen.
<P>
<h3>6.4.2 DHCP Server</h3>

Wenn du OpenBSD als DHCP Server <A href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&apropos=0&sektion=8&format=html">dhcpd(8)</a> einstetzen willst, 
editiere /etc/rc.conf. Setze dhcpd_flags="-q" anstelle von dhcpd_flags=NO.
Und die Netzwerkkarten, auf denen dhcpd <b>lauschen</b> soll, stehen in /etc/dhcpd.interfaces.
<pre>
# <strong>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</strong>
</pre>
Dann editiere /etc/dhcpd.conf.
Die Optionen sind selbsterkl&auml;rend.
<pre>
        option  domain-name "xyz.mil";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>
<p>
Dies teilt deinen DHCP Klienten mit, da&szlig; die an DNS Anfragen 
anzuh&auml;ngende Dom&auml;ne xyz.mil ist (d. h., wenn der Benutzer schreibt 
'telnet joe', dann wird an joe.xyz.mil gesendet). Es wird auf die DNS Server 
192.168.1.3 und 192.168.1.5 verwiesen. F&uuml;r Hosts, die sich im selben 
Netzwerk wie die Netzwerkkarte des OpenBSD Rechners befinden, welche im 
192.168.1.0/24 Adressbereich liegt, wird der DHCP Server ihnen eine IP Adresse 
zwischen 192.168.1.32 und 192.168.1.127 und als Standardgateway 192.168.1.1 zuweisen.
<p>
Wenn du dhcpd von der Befehlszeile starten willst, nachdem du /etc/dhcpd.conf 
editiert hast, versuche:
<PRE>
# <strong>dhcpd -q fxp0</strong>
</PRE>
Wobei fxp0 die Netzwerkkarte ist, auf der DHCP serviert werden soll. 
Die -q Option setzt die Ausgabe von dhcpd auf ruhig, ansonsten ist sie sehr 
ausf&uuml;hrlich.
<P>
Wenn du DHCP Dienste f&uuml;r einen Windows Rechner bereitstellst, dann willst 
du vielleicht auch eine 'WINS' Serveradresse liefern.
Daf&uuml;r f&uuml;ge einfach die folgenden Zeilen zu deiner /etc/dhcpd.conf:
<pre>
option	netbios-name-servers	192.168.92.55;
</pre>
(wobei 192.168.92.55 die IP deines Windows oder Samba Servers ist.)
Siehe auch <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&apropos=0&sektion=5&format=html">dhcp-options(5)</a> f&uuml;r weitere Optionen, die 
deine DHCP Klienten w&uuml;nschen.
<p>
<a name= "6.5"></a>
<h2>6.5 - PPP </h2>
</p>

Das "Point-to-Protocol" wird verwendet, um eine Verbindung zu deinem ISP mit 
deinem Modem herzustellen. OpenBSD bietet daf&uuml;r 2 M&ouml;glichkeiten.

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8&format=html">pppd(8)</a> - der Kernel PPP D&auml;mon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> - der Userland PPP D&auml;mon. 
</ul>

<p>
Den ersten, den wir behandeln, wird der Userland PPP D&auml;mon sein. Um zu 
beginnen, ben&ouml;tigen wir einige einfache Informationen &uuml;ber deinen ISP. 
Hier eine Liste hilfreicher Informationen, die du brauchen wirst.
</p>

<ul>
<li>Die Einwahlnummer deines ISP
<li>Deinen Nameserver 
<li>Deinen Benutzernamen und Password
<li>Dein Gateway
</ul>

<p>
Einige von diesen ben&ouml;tigst du nicht unbedingt, aber sie w&auml;ren hilfreich. 
Der Userland PPP D&auml;mon benutzt die Datei <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> als
seine Konfigurationsdatei. Es gibt viele hilfreiche Dateien in <b>/etc/ppp</b>, 
die verschiedene Einstellungen f&uuml;r verschiedene Situationen zeigen. Du solltest 
dir dieses Verzeichnis ansehen und es durchforsten.
</p>

<p>
Solltest du keinen GENERIC Kernel verwenden, dann stelle sicher, da&szlig; du 
folgende Zeile in deiner Kernelkonfigurationsdatei hast:
</p>

<ul><pre><strong>
pseudo-device   tun             2
</strong></pre></ul>

<h3>Erste Einstellungen - f&uuml;r PPP(8)</h3>

<p>
Die ersten Einstellungen f&uuml;r den Userland PPP D&auml;mon bestehen im Erstellen 
deiner <b>/etc/ppp/ppp.conf</b> Datei. Diese Datei existiert nicht 
standardm&auml;&szlig;ig, aber du kannst einfach <b>/etc/ppp/ppp.conf.sample</b> 
editieren, um deine eigene <b>ppp.conf</b> Datei zu kreieren. Hier werde ich mit 
dem einfachsten und gebr&auml;chlichsten Einstellungen beginnen.
Hier eine schnelle <b>ppp.conf</b> Datei, die uns einfach zu deinem ISP verbindet 
und die Standardrouten und Nameserver setzt. F&uuml;r diese Datei brauchst du nur 
die Telefonnummer deines ISP sowie deinen Benutzernamen und dein Passwort.
</p>

<ul>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</ul>

<p>
<b>ANMERKUNG</b> - Mit OpenBSD 2.6 wurde das System mit einer <i>/etc/ppp/ppp.conf.example</i> 
ausgeliefert, die nicht korrekte Einstellungen f&uuml;r die Schnittstelle hatte, dessen 
Name war <i>"set device /dev/cuaa0"</i>. Es sollte aber <i>/dev/cua00</i> sein, was der seriellen 
Schnittstelle 1 (COM1) entspricht. Deine Schnittstelle mu&szlig; nicht COM1 sein, aber 
die Bezeichnung in OpenBSD 2.6 war falsch.
</p>

<p>
Der Absatz unter der <b>default:</b> Bezeichnung wird jedes Mal ausgef&uuml;hrt. 
Hier stehen alle wichtigen Informationen. Mit &quot;set log&quot; stellen wir die 
Loglevel ein. Um dies zu &auml;ndern, siehe <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> f&uuml;r weitere Info. Unsere Schnittstelle 
wird mit &quot;set device&quot; eingestellt. Dies ist die Schnittstelle, mit der das 
Modem verbunden ist. In diesem Beispiel h&auml;ngt das Modem auf COM Port 2. Daher 
wird COM Port 1 auf /dev/cua00 gesetzt. Mit &quot;set speed&quot; setzen wird die 
Geschwindigkeit unserer Dialup Verbindung und mit &quot;set dial&quot; setzen wir unsere 
Dialup Parameter, mit denen wir die timeout Zeit, usw. setzen k&ouml;nnen. Diese Zeile 
sollte eigentlich ziemlich genau so, wie sie jetzt ist, bleiben.
</p>

<p>
Nun k&ouml;nnen wir die ISP spezifischen Informationen eintragen. Wir tun dies, indem 
wir unter <b>default:</b> einen weiteren Absatz hinzuf&uuml;gen. Dieser kann als alles 
benannt werden, am einfachsten nimmst du den Namen deines ISP. Hier werde ich 
<b>myisp:</b> als Verweis auf unseren ISP nehmen. Hier ist ein einfaches Beispiel, 
das alles beinhaltet, um uns zu verbinden.
<p>

<ul>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</ul>

<p>
Hier stehen alle wichtigen Informationen f&uuml;r unseren spezifischen ISP. Die erste 
Option &quot;set phone&quot; setzt die Telefonnummer deines ISP. &quot;set login&quot; 
setzt unsere login-Optionen. Hier haben wir die timeout auf 5 gesetzt, was bedeutet, 
da&szlig; wir unseren login-Versuch nach 5 Sekunden abbrechen, wenn wir kein 
Tr&auml;gersignal bekommen. Ansonsten wird er auf &quot;login:&quot; warten und dann 
deinen Benutzernamen und Passwort senden. In diesem Beispiel ist unser username = ppp 
und das Password = ppp. Diese Werte m&uuml;ssen ge&auml;ndert werden. Die Zeile 
&quot;set timeout&quot; setzt den Idle timeout f&uuml;r die gesamte Verbindungsdauer auf 120 
Sekunden. Die &quot;set ifaddr&quot; Zeile ist ein bi&szlig;chen schwieriger. Hier ist 
eine genauere Erkl&auml;rung.
</p>

<ul><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></ul>

<p>
Die obigen Zeile folgt dem Format von 
&quot;<b>set ifaddr [meineAdr[/nn] [seineAdr[/nn] [netzmaske [startAdr]]]]</b>&quot;. 
Daher ist die erste spezifizierte IP diejenige, die wir als unsere IP wollen. Wenn du 
eine statische IP Adresse hast, dann kannst du sie hier einsetzen. In unserem Beispiel 
benutzen wir /0, was besagt, da&szlig; kein Bits von dieser IP Adresse &uuml;bereinstimmen 
mu&szlig; und der gesamte Ausdruck ersetzt werden kann. Die zweite IP behandelt die von 
uns erwartete IP unserer Gegenstelle. Wenn du sie wei&szlig;t, dann kannst du sie hier 
angeben. Wiederum wissen wir nicht in unserer Zeile, welche IP dies wird, also lassen 
wir sie um wieder mitteilen. Die dritte Option ist unsere Netzmaske, hier auf 
255.255.255.0 gesetzt. Wenn startAdr spezifiziert ist, dann wird diese anstelle von 
meineAdr w&auml;hrend der initialen IPCP Verhandlung; aber es wird nur eine Adresse aus 
dem meineAdr-Adressbereich akzeptiert. 
</p>

<p>
Die n&auml;chste Option &quot;add default HISADDR&quot; setzt unsere Standardroute 
zu deren IP. Dies ist 'klebrig', d. h falls deren IP sich &auml;ndern sollte, dann 
wird unsere Route auch automatisch upgedatet. Mit &quot;enable dns&quot; teilen wir 
unserem ISP mit, unsere Nameserveradresse zu authentifizieren. Tu dies NICHT, wenn du 
deinen eigenen lokalen DNS laufen hast, da PPP dies umgehen wird, indem es einige 
Zeilen in /etc/resolv.conf schreibt.
</p>

<h3>PPP(8) verwenden</h3>

<p>
Nun, da wir unsere <b>ppp.conf</b> Datei fertig eingerichtet haben, k&ouml;nnen wir 
beginnen, eine Verbindung zu unserem ISP aufzubauen. Hier einige Details &uuml;ber 
h&auml;ufig verwendete Parameter.
</p>

<ul>
<li><b>ppp -auto myisp</b> - Startet PPP, konfiguriert deine Schnittstellen und 
wird dich mit deinem ISP verbinden und dann in den Hintergrund verschwinden.
<li><b>ppp -ddial myisp</b> - &Auml;hnlich wie -auto, aber wenn deine Verbindung 
abbricht, wird PPP versuchen, sich erneut zu verbinden.
</ul>

<p>
Mit dem Aufruf von <b>/usr/sbin/ppp</b> ohne Optionen kommst du in den interaktiven 
Modus. Hier kannst du direkt mit dem Modem interagieren, was sich hervorragend eignet, 
um Probleme in deiner <b>ppp.conf</b> Datei zu debuggen.
</p>

<h3>ppp(8) Extras</h3>

<p>
In einigen Situationen m&ouml;chstest du Befehle ausf&uuml;hren, wenn die 
Verbindung gerade errichtet oder beendet wurde. F&uuml;r diese F&auml;lle gibts es zwei 
Dateien, die du kreieren kannst: <b>/etc/ppp/ppp.linkup</b> und 
<b>/etc/ppp/ppp.linkdown</b>.
Beispielskonfigurationen kannst du hier finden:
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Weitere Informationen findest du unter <a href="http://www.freebsd.org/handbook/userppp.html">http://www.freebsd.org/handbook/userppp.html</a> oder <a href="http://www.freebsd.org/faq/userppp.html">http://www.freebsd.org/faq/userppp.html</a>.
</p>

<p>
<a name= "6.6"></a>
<h2>6.6 - Netzwerkparameter tunen</h2>

<H3>6.6.1 - Wie kann ich den Kernel einstellen, damit es eine h&ouml;here
Anzahl an Verbindungsversuchen und l&auml;ngere Timeouts f&uuml;r TCP Sitzungen
gibt?</h3>
Du solltest dies normalerweise nur verwenden, wenn du Routing- oder
Verbindungsprobleme hast. Nat&uuml;rlich sollten - um die beste Wirkung zu
erzielen - beide Seiten der Verbindung dieselben Werte verwenden.
<P>
Um dies zu tunen, verwende <tt>sysctl</tt> und erh&ouml;he die Werte von:
<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>
Mittels <tt>sysctl -a</tt> kannst du die derzeitigen Werte dieser (und vieler
anderer) Parameter sehen. Um einen Wert zu ver&auml;ndern, verwende 
<tt>sysctl -w</tt>, wie z. B. <tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.  

<h3>6.6.2 - Wie kann ich "directed broadcasts" aktivieren?</h3>
Normalerweise willst du dies nicht tun.  Dies erlaubt jemand, Datenverkehr zu
der broadcast Adresse deines verbundenen Netzwerkes zu schicken, wenn du deinen 
OpenBSD Rechner als Router verwendest.<P>
Aber manchmal kann dies (in geschlossenen Netzwerken) n&uuml;tzlich sein,
vor allem wenn man &auml;ltere Implementierungen des NetBIOS Protokolles
verwendet.
Wiederum mit sysctl.  <tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> 
aktiviert dies.  Beachte aber <A HREF="http://www.netscan.org">Smurfangriffe</a>, 
wenn du wissen willst, warum dies standardm&auml;&szlig;ig nicht aktiviert ist.

<H3>6.6.3 - Der Kernel soll Ports nicht dynamisch allozieren</h3>
Wieder ein eigener sysctl Befehl daf&uuml;r.  Siehe <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:
<PRE>
Set the list of reserved TCP ports that should not be allocated by the
kernel dynamically.  This can be used to keep daemons from stealing a
specific port that another program needs to function.  List elements may
be separated by commas and/or whitespace.

   sysctl -w net.inet.tcp.baddynamic=749,750,751,760,761,871

It is also possible to add or remove ports from the current list.

   sysctl -w net.inet.tcp.baddynamic=+748
   sysctl -w net.inet.tcp.baddynamic=-871
</pre>

<a name="6.7"></a>
<h2>6.7 - Einfache NFS Anleitung</h2>

<p> NFS, oder Network File System (Netzwerkdateisystem), wird verwendet, um 
ein Dateisystem &uuml;ber das Netzwerk zu verwenden. Du solltest vorher noch 
folgende Manualseiten lesen, bevor du versuchst, einen eigenen NFS Server 
aufzusetzen:

<p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8&format=html">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8&format=html">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>
</ul>

<p>
Dieses Kapitel zeigt die Schritte, um ein einfaches NFS System aufzusetzen: 
Ein Server im LAN und Klienten im LAN, die NFS verwenden. Es behandelt nicht, 
wie man NFS sicher macht. Wir nehmen an, da&szlig; du bereits Paketfilterung 
oder irgendeinen anderen Firewallschutz eingerichtet hast, damit von 
au&szlig;erhalb nicht auf NFS zugegriffen werden kann.
Wenn du Zugriff via NFS von au&szlig;erhalb erlauben willst und sensible Daten 
dort gespeichert hast, dann empfehlen wir dir w&auml;rmstens den Gebrauch von 
<A HREF="../faq13.html">IPSec</a>.  Ansonsten k&ouml;nnen andere Leute 
m&ouml;glicherweise deinen NFS Datenverkehr sehen. Jemand k&ouml;nnte auch 
vort&auml;uschen, die IP Adresse zu sein, der du Zugriff auf den NFS Server 
l&auml;&szlig;t. Es gibt mehrere Angriffe, die m&ouml;glich sind. Wenn IPSec 
richtig konfiguriert ist, dann sch&uuml;tzt es gegen die Art von Angriffen. 
<P>
Noch eine wichtige Anmerkung wegen Sicherheit. F&uuml;ge niemals ein 
Dateisystem zu /etc/exports ohne eine Liste mit Rechnern, die explizit 
Zugriff haben sollen. Ohne einer solchen Liste, die ein bestimmtes Verzeichnis 
mounten k&ouml;nnen, kann jeder, der den Rechner erreichen kann, deine NFS 
exports mounten.
</p>

<p>
Der Server hat die IP <b>10.0.0.1</b>. Dieser Server soll nur NFS f&uuml;r 
Rechner innerhalb dieses Netzwerkes bereitstellen. Der erste Schritt ist 
deine <i>/etc/exports</i> Datei zu erstellen. Diese Datei listet die 
Dateisysteme auf, die du &uuml;ber NFS freigeben willst, und definiert, wer 
auf sie zugreifen darf. Es gibt viele Optionen, die du in deiner 
<i>/etc/exports</i> Datei haben kannst, und am besten ist, du liest 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>. 
F&uuml;r dieses Beispiel sieht <i>/etc/exports</i> so aus:
</p>

<ul><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></ul>

<p>
D.h., da&szlig; das lokale Dateisystem <b>/work</b> via NFS zug&auml;nglich 
gemacht wird. <b>-alldirs</b> bedeutet, da&szlig; Klienten jedes Verzeichnis 
unter dem <b>/work</b> Mount-point mounten k&ouml;nnen. <b>-ro</b> bedeutet,  
da&szlig; nur Leseberechtigung gestattet wird. Die letzten zwei Argumente 
bedeuten, da&szlig; nur Klienten innerhalb des 10.0.0.0 Netzwerkes mit einer 
Netzmaske von 255.255.255.0 dieses Dateisystem mounten d&uuml;rfen. Dies ist 
wichtig f&uuml;r einige Server, die von verschiedenen Netzwerken 
zug&auml;nglich sind.
</p>

<p> Ist einmal deine <i>/etc/exports</i> Datei eingerichtet, kannst du 
weitergehen und deinen NFS Server aufsetzen. Du solltest zuerst sicherstellen, 
da&szlig; deine Kernelkonfiguration die Optionen NFSSERVER & NFSCLIENT 
enth&auml;lt. (Der GENERIC Kernel beinhaltet diese Optionen.) Dann 
solltest du <strong>nfs_server=YES</strong> in <i>/etc/rc.conf</i> eintragen. 
Dies wird sowohl nfsd(8) und mountd(8) starten, wenn du rebootest.
Nun kannst du fortschreiten und die Dienste selber starten. Diese Dienste 
m&uuml;ssen als root gestartet werden und du mu&szlig;t sicherstellen, 
da&szlig; portmap(8) auf deinem System l&auml;uft. Hier ein Beispiel von 
nfsd(8), der sowohl mit TCP als auch mit UDP bedient mittels 4 Diensten. 
Du solltest eine angemessenene Anzahl von NFS Serverdiensten einsetzen, um 
die maximale Anzahl von gleichzeitigen Klientenanfragen, die du bedienen 
willst, zu bewerkstelligen.

<P>

<ul><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></ul>

<p>
Du mu&szlig;t nicht nur den nfsd(8) Server starten, sondern auch mountd(8). 
Dies ist der Dienst, der eigentlich die Mountanfragen auf NFS bedient. Um 
mountd(8) zu starten, gib einfach folgendes ein:
<p>

<ul><pre>
# <strong>/sbin/mountd</strong>
</pre></ul>

<P>
Wenn du &Auml;nderungen an /etc/exports durchf&uuml;hrst, w&auml;hrend 
NFS bereits l&auml;uft, mu&szlig;t du mountd dies mitteilen, indem du den 
Dienst neu startest!

<UL><PRE>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></ul>

<P>

<h3>NFS Status &uuml;berpr&uuml;fen</h3>

<p>
Um zu &uuml;berpr&uuml;fen, ob alle Dienste laufen und bei RPC registriert 
sind, verwende rpcinfo(8). 
<p>

<ul><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></ul>

<p> F&uuml;r den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen 
du den Status von NFS &uuml;berpr&uuml;fen kannst. Eines ist 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8&format=html">showmount(8)</a>, 
das dir anzeigt, was und wer gerade mountet. Dann gibt es auch noch nfsstat(8),
das genauere Statistiken anzeigt. F&uuml;r showmount(8), versuche 
<b>/usr/bin/showmount -a host</b>. Z. B.:

<P>

<ul><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></ul>

<h3>NFS Dateisysteme mounten</h3>

<p>
NFS Dateisysteme sollten mittels mount(8) geladen werden, oder genauer 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8&format=html">mount_nfs(8)</a>.
Um ein Dateisystem /work von Host 10.0.0.1 auf dem lokalen Dateisystem /mnt 
zu laden, tue folgendes (NB: du mu&szlig;t nicht IP Adressen verwenden, mount 
wird Hostnamen aufl&ouml;sen):
<p>

<ul><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></ul>

<P>
Damit dein System dies beim Hochfahren wieder tut, f&uuml;ge folgendes zu 
deiner <i>/etc/fstab</i>:
<P>

<UL><PRE>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></ul>

<P>
Es ist wichtig, da&szlig; du <tt>0 0</tt> am Ende dieser Zeile verwendest, 
damit dein Rechner nicht versucht, das NFS Dateisystem beim Hochfahren mit 
fsck zu &uuml;berpr&uuml;fen!!!! Die anderen Sicherheitsoptionen wie noexec, 
nodev und nosuid, sollten auch immer - wenn anwendbar - verwendet werden. 
Z. B.:
<P>

<UL><PRE>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></ul>

<P>
Mit diesen Optionen k&ouml;nnen keine Ger&auml;te oder setuid Programme auf 
dem NFS Server Sicherheitsma&szlig;nahmen auf dem NFS Klient untergraben. 
Wenn du keine Programme auf diesem NFS Dateisystem auf dem NFS Klient 
ausf&uuml;hren willst, f&uuml;ge noexec hinzu:


<a name="6.8"></a>
<h2>6.8 - Domain Name Service  - DNS, BIND und named</h2>

<h3>6.8.1 Was ist DNS?</h3>

<p>
Domain Name Service bietet die M&ouml;glichkeit, Name-zu-IP Adresse 
Aufl&ouml;sung und IP Adresse-zu-Namen Aufl&ouml;sung auf eine Anfrage zu 
generieren. Deine OpenBSD Installation ist standardm&auml;&szlig;ig als DNS 
Klient, aber nicht als DNS Server konfiguriert. D.h., deine OpenBSD 
Installation kann eine DNS Anfrage an einen Domain Name Server f&uuml;r die
Adresse einer Maschine stellen, aber sie kann nicht selbst solche DNS 
Anfrage beantworten, bis du dies nicht selbst so konfigurierst.</p>

<p>
Meine OpenBSD Maschine ist derzeit mit dem Internet durch meinen ISP verbunden, 
so da&szlig; ich mit <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a> 
DNS Anfragen ausf&uuml;hren kann:
</p>

<ul><pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre></ul>

<p>
<b>165.87.201.244</b> ist der Nameserver, der geantwortet hat, weil es der 
Nameserver ist, den mein ISP mir zu meinem Konto zugeteilt hat und in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a> 
eingetragen ist. Aber die Antwort war nicht authoritativ. F&uuml;r eine 
authoritative Antwort m&uuml;ssen wir den DNS Server f&uuml;r
die <i>openbsd.org</i> Dom&auml;ne finden und ihn nach der Adresse von 
<i>www.openbsd.org</i> fragen:
</p>

<ul><pre>
# Identifiziere die Nameserver f&uuml;r openbsd.org
# mit der Hilfe des Nameservers meines ISP.
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet Adresse = 199.185.137.3
gandalf.sigmasoft.com   internet Adresse = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Verwende die gefundenen Informationen, um eine Anfrage 
# f&uuml;r eine authoritative Aufl&ouml;sung zu stellen:
# befrage zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Adresse:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre></ul>

<p>
Auf <i>zeus.theos.com</i> l&auml;ft OpenBSD und ist korrekt als DNS server 
f&uuml;r die <i>openbsd.org</i> Dom&auml;ne konfiguriert.
</p>

<a name="6.8.1.1"></a>
<h3>6.8.1.1 Wo kann ich alles &uuml;ber DNS und seine Implementationen unter 
OpenBSD lernen?</h3>

<ul>
<li>Siehe die RFCs <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, 
<a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a> und 
<a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> f&uuml;r weitere 
Informationen &uuml;ber DNS zu erhalten.</li>
<li>Lies das O'Reilly Associates Buch <i><a href="../../de/books.html#dns&bind">DNS and BIND</a> </i>.</li>
<li>Lies die <a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD Manualseiten</a> 
vorallem die Seiten von</li>
	<ul>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&sektion=3&format=html">gethostbyname(3)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&sektion=8&format=html">named(8)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=3&format=html">resolver(3)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=5&format=html">resolver(5)</a>
	</ul>
</ul>

<p>
Der <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> 
Befehl ist besonders n&uuml;tzlich, weil er eine Dom&auml;ne befragen kann 
und Informationen zur&uuml;ckliefert, die einem Format unterliegen, das 
BIND Konfigurationsdateien sehr &auml;hnlich ist. Du kannst mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> 
Nameserver untersuchen, von denen du wei&szlig;t, da&szlig; sie richtig 
funktionieren, und sie mit deinen Einstellungen vergleichen.
</p>

<h3>6.8.2 Mu&szlig; meine Maschine ein Domain Name Server sein?</h3>

<p>
Wenn du dir nicht sicher bist, ob dein Rechner die Rolle eines DNS Server 
spielen soll, dann konfiguriere ihn nicht als solchen. Die OpenBSD Installation
konfiguriert nicht standardm&auml;&szlig;ig deine Maschine als einen Domain 
Name Server, obwohl alle notwendigen Dateien daf&uuml;r installiert werden. 
F&uuml;r die meisten Arbeitsplatzrechner gen&uuml;gt die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5&format=html">/etc/hosts</a> 
Datei, um IP Adressen lokaler Rechner zu benennen und die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a> 
Datei, um die DNS Server im Intranet oder Internet einzustellen.
</p>

<p>
Aber wenn du vielleicht doch deinen Rechner als Domain Name Server 
konfigurieren mu&szlig;t:
<ul>
<li>Wenn du ein IP LAN betreibst, f&uuml;r das du nicht auf jedem Rechner 
die "hosts" Dateien mit den lokalen IP Adressen. In so einem Fall kannst du 
deinen OpenBSD Rechner als DNS Server konfigurieren und Anfragen der anderen 
Maschinen aus deinem LAN bedienen.</li>
<ul>
<li><b>Anmerkung:</b> Es gibt keine praktische Einschr&auml;kung bzgl. der 
Anzahl von DNS Servern in einem LAN. Einige oder alle Maschinen im LAN 
k&ouml;nnen DNS Dienste anbieten, wenn sie so konfiguriert sind. Ob einige 
dieser Server als authoritativ von au&szlig;erhalb deines LANs betrachtet 
werden (oder sie &uuml;berhaupt au&szlig;erhalb deines LANs bekannt sind), 
ist ein Konfigurationsfaktor, der typischerweise eine Ebene oberhalb deines 
LANs in der Dom&auml;nenhierarchie bestimmt wird.</li>
</ul>
<li>Wenn du ein IP LAN mit Rechnern hast, die auch via DNS von Rechnern 
anderer IP LANs und WANs auffindbar sein sollen.</li>
<li>Wenn du Schwierigkeiten hast, lokale Rechnernamen auf eine IP Adresse 
aufzul&ouml;sen oder andere lokale Namen zu IP Adressen, obwohl du korrekte 
<i>/etc/hosts</i> und <i>/etc/resolv.conf</i> Dateien hast (z.B.: Netscape 
auf OpenBSD hat manchmal dieses Verhalten, weil es seinen eigenen DNS 
Aufl&ouml;ser verwendet, anstatt einfach <i>gethostbyname(3)</i> zu 
ben&uuml;tzen, um IP Adressen nachzusehen.)</li>
</ul>

<p>
Eine weitere &Uuml;berlegung ist die Ausf&uuml;hrungsgeschwindigkeit. 
Da die Namensaufl&ouml;sung ein iterativer Prozess ist, in dem der Nameserver 
wiederholende Anfragen an andere Nameserver in entfernten Dom&auml;nen 
stellt, kann die Namensaufl&ouml;sung l&auml;nger dauern, wenn du eine 
Modemverbindung ins Internet hast und deinen DNS Server nach anderen, 
entfernten IP Adressen auf der Modemleitung befragst (die ihrerseits wieder 
andere entfernte DNS Server befragen), als wenn du den Nameserver deines ISP 
befragst (der wahrscheinlich eine schnellere Verbindung zu entfernten 
Nameservern hat). 
</p>

<h3>6.8.3 Was sind die Softwarekomponenten der DNS Server?</h3>

<ul>
<li>named <i>("name daemon")</i></li>
<li>Konfigurationsdateien in der Verzeichnishierarchie unter 
<i>/var/named/</i></li>
</ul>

<h4>6.8.3.1 Welche Versionen von BIND werden unterst&uuml;tzt?</h4>

<p>
BIND ist der Name einer Spezifikation eines Dom&auml;nennamensservers mit 
einem bestimmten Verhalten. Die DNS Komponenten ergeben gemeinsam 
die Implementation von BIND. 
</p>

<p>
Es gibt zwei getrennte BIND Specifikationen:
<ol>
<li>BIND 4</li>
<li>BIND 8</li>
</ol>

<p>
Standardm&auml;ssig unterst&uuml;tzt OpenBSDs <b>named</b> BIND 4.x.

<h4>6.8.3.2 Welche Alternativen zu der Standard-BIND 4.x-Implementation 
gibt, um DNS Dienste bereitzustellen?</h4>

<ul>
<li>Die BIND 9.x Implementation ist in <i>/usr/ports/net/bind9</i>.(Siehe <a href="../../de/ports.html">ports</a>)
</ul>

<h5>6.8.3.2.1 <u>Sicherheitsanmerkung</u></h5>

<p>
Wenn du diese alternativen Implementationen von DNS Diensten in betracht 
ziehst, dann stellst du einen kritischen Netzwerkdienst zur Verf&uuml;gung, 
dessen Software nicht dem selben Niveau an &Uuml;berpr&uuml;fung wie durch
<a href="../../de/security.html">Sicherheit</a> dem <b>named</b> name daemon in 
der Basisinstallation zu Teil wurde. Dies ist eine signifikante &Uuml;berlegung,
da, falls ein DNS Server kompromittiert wird, die Klients zu 
betr&uuml;gerischen Webseiten umgeleitet werden k&ouml;nnen.
</p>

<h3>6.8.4 Wieviel mu&szlig; ich installieren?</h3>

<p>
Wenn die standardm&auml;ssige Netzwerkinstallation korrekt bei der 
Installation von OpenBSD eingerichtet hast, dann ist bereits alles 
installiert. Du mu&szlig;t nur mehr den Nameserverdienst ("<tt>named</tt>") 
konfigurieren.
</p>

<h3>6.8.5 Wie konfiguriere ich DNS?</h3>

<p>
Du konfigurierst OpenBSD DNS, indem du Dateien editierst und/oder erstellst, 
die den Nameserverdienst <tt>named</tt> steuern. Diese Dateien liegen 
standardm&auml;&szlig;ig im Verzeichnis <i>/var/named</i> und dessen 
Unterverzeichnisse, haupts&auml;chlich in der Datei 
<i>/var/named/named.boot</i>, das die Initialisierungsdatei f&uuml;r 
<b>named</b> ist. Weiterhin gibt es ein paar andere notwendige 
Konfigurationsschritte in <i>/etc</i>.
</p>

<p>
In diesem Dokument werden wir den Nameserverdienst auf <i>nemo.yewtopia.com</i>
konfigurieren, der der prim&auml;re Nameserver f&uuml;r die (sehr kleine!) 
Dom&auml;ne <i>yewtopia.com</i> sein wird. Die Adresse von 
<i>nemo.yewtopia.com</i> ist <i>192.168.1.9</i>. Zwei andere Maschinen 
befinden sich im selben Subnet, <i>crater.yewtopia.com </i> auf 192.168.1.1 
und <i>earhart.yewtopia.com</i> auf 192.168.1.2.
</p>

<h4>6.8.5.1 Konfiguration in <i>/var/named</i></h4>

<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<ul><pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain                source host/file
; type    domain   source host/file backup file
cache     .       root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre></ul>

<p>
Dies teilt dem Initialisierungsproze&szlig; mit, in welchem Unterverzeichnis 
und unter welchem Dateinamen die Konfigurationsdateien f&uuml;r 
<i>yewtopia.com</i> zu finden sind. 

<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<ul><pre>
; Reverse lookup f&uuml;r localhost interface
@       IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre></ul>

<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<ul><pre>
; yewtopia.com domain database
yewtopia.com.        IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre></ul>

<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<ul><pre>
; yewtopia domain reverse lookup database
1.168.192.in-addr.arpa. IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre></ul>

<h4>6.8.5.2 Konfiguration in <i>/etc</i></h4>

<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>
<p>
Stelle sicher, da&szlig; <i>/etc/resolv.conf</i> nun auf die Dom&auml;ne 
des lokalen Rechners (anstatt auf, z. B., den Nameserver deines ISPs) zeigt, 
so da&szlig; die Namensaufl&ouml;sungsanfragen auch wirklich zu dem 
<b>named</b> geschickt werden, den du konfiguriert hast!
</p>

<ul><pre>
domain yewtopia.com
lookup file bind
</pre></ul>

<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>
Wenn du vorher die Adressen von diversen Rechnern zu der <i>/etc/hosts</i> 
Datei hinzugef&uuml;gt hattest, dann solltest du in Betracht ziehen, deine 
<i>/etc/hosts</i> Datei wieder auf Standardgr&ouml;&szlig;e zu k&uuml;rzen: 
</p>

<ul><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></ul>

<p>
Damit <b>named</b> nicht zugunsten von (m&ouml;glicherweise veralteten) 
Adressen in der <i>/etc/hosts</i> Datei &uuml;bergangen wird. <u>Stelle 
sicher, da&szlig; du zumindest den Standardeintrag<i>localhost</i></u> 
hast, oder dein Netzwerk wird nicht richtig starten!! Auch <i>nemo</i> 
mu&szlig; in seiner eigenen hosts-Datei aufscheinen, oder du wirst eine 
(eher harmlosen) Fehlermeldung zu Bootzeit bemerken,  wenn <i>/etc/netstart</i>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8&format=html">route(8)</a> 
aufruft, um <i>nemo</i> hinzuzuf&uuml;gen (dessen Name in <i>/etc/myname</i> 
aufscheint).
</p>

<h4>6.8.5.3 Mittels <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> 
die Ergebnis untersuchen.</h4>

<ul><pre>
$ <strong>dig @nemo.yewtopia yewtopia any any</strong>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia, type = ANY, class = ANY

;; ANSWERS:
yewtopia.        3600   SOA     nemo.yewtopia.
your_id.nemo.yewtopia. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.        3600   NS      nemo.yewtopia.

;; ADDITIONAL RECORDS:
nemo.yewtopia.   3600   A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre></ul>

<h3>6.8.6 Wie kann ich DNS starten und stoppen?</h3>

<h4>6.8.6.1 DNS starten</h4>

<p>
Der Nameserverdienst <b>named</b> wird beim Systemstart von 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8&format=html">/etc/rc</a> 
gestartet, wenn die folgende Zeile (standardm&auml;&szlig;ig vorhanden) sich 
in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8&format=html">/etc/rc.conf</a>
befindet.
</p>

<ul><pre>
named_flags=NO          # f&uuml;r normal use: ""
</pre></ul>
 
<p>
ver&auml;ndere in
</p>

<ul><pre>
named_flags=""          # f&uuml;r normal use: ""
</pre></ul>

<p>
Beachte auch diese Zeilen in /etc/rc.conf:
</p>

<ul><pre>
named_user=named                # Named should not run as root unless neccesary
named_chroot=/var/named         # Where to chroot named if not empty
</ul></pre>

<p>
Diese Standardeinstellungen werden f&uuml;r beinahe alle Installationen 
korrekt sein.
</p>

<p>
Um <b>named</b> h&auml;ndisch zu starten, verwende den 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> 
Befehl. Z. B.:
</p>

<ul><pre>
# <strong>ndc start</strong>
          oder
# <strong>ndc reload</strong>
</pre></ul>

<h4>6.8.6.2 DNS Stoppen</h4>

<p>
Der beste Weg, um den Nameserverdienst zu stoppen, ist den <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> 
Befehl zu verwenden. Z. B.:
</p>

<ul><pre>
# <strong>ndc stop</strong>
</pre></ul>

<p>
Wenn dies fehlschl&auml;gt, finde die Proze&szlig;-ID von named und 
verwende den <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&sektion=1&format=html">kill(1)</a> 
Befehl, um diesen Proze&szlig; zu beenden. Die PID f&uuml;r <b>named</b>, 
solange er l&auml;uft, kannst du in der ersten Zeile der Datei 
<i>/var/named/named.pid</i> finden.
</p>

<ul><pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</pre></ul>

<h4>6.8.6.3 Restarting DNS with an altered configuration</h4>

<p>
<h3>6.8.7 How do I block AXFR queries? </h3>
<p>
Beispiel:
<ul><pre>
garden:/home/jeremy$<strong>  host -l openssh.com</strong>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></ul>
<p>
Diese Information ist n&uuml;tzlich f&uuml;r das Debuggen von DNS, aber in manchen F&auml;llen willst du diesen
Output nicht in aller Welt zeigen.
Wenn du klassenloses in-addr(rfc2317) f&uuml;r reverse benutzt, k&ouml;nnte 'host -l' jede Domain anzeigen, die
dein System hostet!
Dies kann man einfach mit der 'allow-transfer' Formulierung in deinem zone file verhindern.
<br><br>
Wenn du Bind8 benutzt, musst du die Hosts spezifizieren, denen du den "Zonen-Transfer" erlauben willst, und zwar in deinen
individuellen Zone Datei(en):
<ul><pre>
zone "foo.com" in {
        type master;
        file "directory/zonefile";
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></ul>
Du kannst auch Transfers f&uuml;r alle Domains stoppen, indem du /var/named.conf anpasst und und den 'allow-transfer' Parameter 
zur options Sektion der Konfigurationsdatei hinzuf&uuml;gst:
<ul><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></ul>
Die Bind8 Methode funktioniert auch mit Bind9.<br>
Bei Bind 4 (Standard in OpenBSD) kannst du /var/named/named.boot anpassen und die 'xfrnets' Option nutzen.<br>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></ul><br>
Bind 4 erlaubt Transfers von ganzen Klassen, ist also nicht so exakt.
Typischerweise sind die einzigen Hosts, die Transfers durchf&uuml;hren m&uuml;ssen deine DNS Slaves und Hosts 
von denen du vielleicht 'debug'en  willst (127.0.0.1 ist meist ein guter Host, dem man Transfers erlauben sollte!)
AXFR queries zu blocken f&uuml;gt einen zus&auml;tzlichen Level an Privatsphere ein, kann aber ein sinnvolles DNS 
debugging behindern.
(Danke an <a href=mailto:ntang@nachtwache.org>Nicholas Tang</a> f&uuml;r diesen Tip)
</p>

<h3>6.8.8 Was hast du mir nicht &uuml;ber das Aufsetzen von DNS erz&auml;hlt?</h3>
Es gibt eine Menge von Dingen, die ich dir nicht erz&auml;hlt habe, z.B. wie man DNS so aufsetzt, dass Anfragen f&uuml;r Intranet Domains, die von 
der root der Domain-Hierarchie aus nicht sichtbar sind, zu Servern innerhalb deines Unternehmens weitergeleitet werden.
Lies die <a href="#6.8.1.1">empfohlenen Dokumente</a>, um mehr Informationen &uuml;ber DNS zu erhalten.
</p>

<a name="6.9"></a>
<h2>6.9 - Eine PPTP Verbindung mit OpenBSD aufsetzen</h2>

<p>
<strong>HINWEIS:</strong> Dies bezieht sich nicht auf <strong>ALLE</strong> ADSL Provider, aber viele der Informationen k&ouml;nnen aus diesem Setup 
&uuml;bernommen werden. Dieses Setup funktioniert auf jeden Fall bei <a href="http://www.inode.at">Inode</a>, einem ADSL Provider in &Ouml;sterreich.
</p>

<p>
Zun&auml;chst ben&ouml;tigt man ein pptp. Ein port wurde dem OpenBSD ports tree NACH der Ver&ouml;ffentlichung von OpenBSD 2.8 hinzugef&uuml;gt 
und arbeitet bestens. Der port ist unter <i>/ports/net/pptp</i> zu finden. Lies die <a href="../faq8.html#8.6">FAQ 8.6</a>,
wenn du mehr &uuml;ber den OpenBSD ports tree herausfinden willst.
</p>

<p>
Wegen des Konflikts der "Im-Kernel" <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html">gre(4)</a> Unterst&uuml;tzung und pptp wirst du deinen Kernel neu kompilieren m&uuml;ssen und die Unterst&uuml;tzung f&uuml;r gre(4) entfernen m&uuml;ssen.
</p>

<ul>Patch, um die GRE(4) Unterst&uuml;tzung zu entfernen.
<pre>
Index: sys/conf/GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.66
diff -u -r1.66 GENERIC
--- sys/conf/GENERIC    2000/10/13 04:21:14     1.66
+++ sys/conf/GENERIC    2000/12/26 19:55:31
@@ -97,6 +97,6 @@
pseudo-device  ksyms   1      # kernel symbols device
pseudo-device  bridge  2      # network bridging support
#pseudo-device vlan    2      # IEEE 802.1Q VLAN
pseudo-device  gre     1      # GRE encapsulation interface
#pseudo-device gre     1      # GRE encapsulation interface

 option                BOOT_CONFIG     # add support for boot -c
</pre></ul>

<p>
Um deinen Kernel neu zu kompilieren mache einen "check out" von OpenBSD 2.8-stable via cvs (siehe die <a href="../../de/stable.html">OpenBSD Stable</a> 
Webseite) , benutze den folgenden Patch, und baue einen neuen Kernel wie unter <a href="faq5.html#5.3">FAQ 5.3</a>.
</p>

<p>
Nachdem du das <b>pptp</b> package und einen neuen Kernel installiert hast, musst du ein paar Dateien f&uuml;r deine neue Verbindung editieren.
Diese packages benutzen das standarm&auml;ssige OpenBSD 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html">ppp(8)</a>, 
wenn du dich also mit ppp(8) auskennst, kommt dir vieles bekannt vor. Siehe auch <a href="#6.5">FAQ 6.5</a>.
</p>

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
F&uuml;r eine <i>/etc/ppp/options</i> Datei wird ein Setup wie das unten vermutlich alles notwendige tun:
</p>

<ul><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></ul>

<p>
<tt>LOGINNAME</tt> sollte mit deiner User-ID ersetzt werden.
</p>

<p>
In <i>/etc/ppp/pap-secrets</i> geh&ouml;rt eine Zeile wie diese hier:

<ul><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></ul>

<p>
Wobei LOGINNAME deine User-ID und PASSWORD dein Password ist. 10.0.0.138 ist die zugewiesene IP deines Modems im Falle, dass du ADSL nutzt, etc. 
Stelle sicher, dass diese Datei nur von root gelesen werden kann (mode 600).
</p>

<h3>6.9.1 - Deinem Network Interface eine Adresse zuweisen</h3>

<p>
Im obigen Beispiel hatte unser Modem eine vorkonfigurierte Adresse von 10.0.0.138. Jetzt m&uuml;ssen wir UNSEREM Interface noch eine Adresse zuweisen.
Es ist am besten eine IP zu w&auml;hlen, die nahe an der deines MODEMS liegt, oder einfach die statische Adresse zu benutzen, die dir zugewiesen wurde.
Mehr dar&uuml;ber, wie man Interfaces IP-Adressen zuweist, kannst du in <a href="#6.1">FAQ 6.1</a> lesen.
</p>

<p>
Wenn dein Interface eingerichtet ist, solltest du eine pptp Verbindung mit dem Kommando 

<ul><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &</strong>
</pre></ul>

aufbauen k&ouml;nnen.
<p>
Da hier auch der "in-house" OpenBSD ppp(8) benutzt wird, werden hier zwei Prozesse gestartet. Du kannst pptp beenden, indem du diesen beiden Prozesse
killst:
</p>

<ul><pre>
# <strong>kill -9 [pid of pppd]</strong>
% <strong>kill -9 [pid of pptp]</strong>
</pre></ul>

Wir empfehlen <tt>/var/log/messages</tt> in einem weiteren Terminalfenster zu &ouml;ffnen, um m&ouml;gliche Probleme zu erkennen.

<ul>
<pre>
# <strong>tail -f /var/log/message</strong>
</pre></ul>
</p>

<p>
Wir schlagen vor, die Startsequenz in <i>/etc/rc.local</i> unterzubringen, so dass bei jedem reboot die Verbindung automatisch 
aufgebaut wird.
</p>

<p>
<font color= "#0000e0">
<a href= "index.html">[Zur&uuml;ck zum Hauptindex]</a>
<a href= "faq5.html">[Zu Kapitel 5.0 - Kernelkonfiguration]</a>
<a href= "faq7.html">[Zu Kapitel 7.0 - Tastatureinstellungen]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[zur&uuml;ck]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
Originally [OpenBSD: faq6.html,v 1.107 ]
<br>
$Translation: faq6.html,v 1.43 2002/05/20 13:21:05 jufi Exp $
<br>
<small>$OpenBSD: faq6.html,v 1.36 2002/05/20 13:42:05 jufi Exp $</small>
</p>
</body>
</html>
