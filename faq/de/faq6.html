<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Netzwerk</title>
<link rev= "made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta http-equiv="Content-Language" content="de">
<meta name="description" content="Die OpenBSD FAQ Seiten - FAQ 6: Netzwerk">
<meta name="keywords" content="openbsd,faq,Netzwerk,DNS,PPTP,NFS,PPP,DHCP,NAT,PF">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1998-2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<img SRC="../../images/smalltitle.gif" ALT="[OpenBSD]" height=30 width=141>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Zu Sektion 5 - Neuerzeugen des Systems aus dem Quellcode]</a>
<a href="faq7.html">[Zu Sektion 7 - Tastatur- und Bildschirmkontrollen]</a>
</font>

<h2><font color="#E00000">6 - Netzwerk</font></h2>
<hr>

<h3>Inhaltsverzeichnis</h3>
<ul>

<li> <a href="#Intro"	>6.0.1 - Bevor wir weiter gehen</a></li>
<li> <a href="#Setup"	>6.1 - Erste Netzwerkeinstellungen</a></li>
<li> <a href="#PF"	>6.2 - Packet Filter (PF)</a></li>
<li> <a href="#DHCP"	>6.4 - DHCP - Dynamic Host Configuration Protocol</a></li>
<li> <a href="#PPP"	>6.5 - PPP - Point to Point Protocol</a></li>
<li> <a href="#Tuning"	>6.6 - Optimieren der Netzwerkparameter</a></li>
<li> <a href="#NFS"	>6.7 - NFS benutzen</a></li>
<li> <a href="#PPTP"	>6.9 - Eine PPTP Verbindung mit OpenBSD aufbauen</a>
<li> <a href="#Bridge"  >6.10 - Aufsetzen einer Bridge mit OpenBSD</a>
</ul>

<hr>
<p>
<a name="Intro"></a>
<h2>6.0.1 - Bevor wir weiter gehen</h2>

<p>
F&uuml;r den Rest dieses Dokumentes sei gesagt, da&szlig; es hilfreich
ist, das Kapitel des FAQ <a href="faq5.html">Kernelkonfiguration und Einstellungen</a>
gelesen und zumindest teilweise verstanden zu haben, weiterhin helfen die
Manual Seiten <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>.
<p>
Wenn du ein Netzwerkadministrator bist und Routingprotokolle aufsetzt
und dein OpenBSD Rechner dein Router wird, dann solltest du dein Wissen
&uuml;ber IP Netzwerke mit 
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">
Understanding IP addressing</a>
vertiefen. Dies ist wirklich ein exzellentes Dokument. "Understanding IP addressing" 
beinhaltet grundlegendes Wissen, auf dem man beim IP Netzwerken aufbauen 
kann, insbesondere wenn man mit mehreren Netzwerken arbeitet oder f&uuml;r sie 
verantwortlich ist.
<p>
Wenn du mit Anwendungen wie Web-, FTP- oder Mailserver arbeitest, dann
k&ouml;nntest du viel vom Lesen der entsprechenden 
<a href="http://the.rfc-editor.org/rfc.html">RFCs</a>
profitieren. Nat&uuml;rlich kannst du nicht alle lesen. Aber dennoch, lies
jene, die dich interessieren oder die du bei deiner Arbeit brauchen k&ouml;nntest.
Lies nach, wie alles funktionieren sollte. Die RFCs definieren mehrere (tausend)
Standards f&uuml;r Protokolle im Internet und wie sie arbeiten sollten.

<p>
<a name="Setup"></a>
<h2>
6.1 - Erste Netzwerkeinstellungen</h2>

<p>
<a name= "Setup.1"></a>
<h3>
6.1.1 - Identifzieren und Einstellen deiner Netzwerkkarten</h3>
Um beginnen zu k&ouml;nnen, mu&szlig;t du zun&auml;chst deine Netzwerkkarte
identifizieren k&ouml;nnen. Bei OpenBSD werden Netzwerkkarten nach ihrem
Typ, nicht nach Verbindungsart benannt. Du kannst sehen, ob deine 
Netzwerkkarte initialisiert wurde, entweder schon beim Booten oder auch 
sp&auml;ter mittels des Befehls 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>. 
Weiterhin kannst du mit dem Befehl 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
deine Karte &uuml;berpr&uuml;fen. Als Beispiel hier die Ausgabe in
dmesg f&uuml;r eine Intel Fast Ethernet Netzwerk-Karte, die als 
Ger&auml;tenamen fxp hat.
<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>
Wenn du deinen Ger&auml;te-Namen nicht weisst, sieh bitte in der 
<a href="../../de/plat.html">Liste der unterst&uuml;tzten Hardware</a> 
f&uuml;r deine Plattform nach. Du wirst eine Liste vieler bekannte Karten 
und ihre OpenBSD Ger&auml;te-Namen finden (wie etwa fxp), zusammen mit 
einer Nummer, die vom Kernel zugewiesen wird, und du hast den sogenannten 
"interface Name" (wie z.B. fxp0).
<p>

Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem 
du das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
Kommando benutzt.
Das folgende Kommando zeigt uns alle Netzwerk-Interfaces im System.
Diese Beispielausgabe zeigt ein physikalisches Ethernet Interface, eine 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.

<p>
<blockquote><pre>
$ <b>ifconfig -a</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
gibt uns eine Menge mehr Informationen, als wir zu diesem Zeitpunkt 
ben&ouml;tigen. Nat&uuml;rlich sehen wir trotzdem unser Interface. Im 
obigen Beispiel ist die Netzwerkkarte bereits konfiguriert. Das ist 
offensichtlich, da auf fxp0 bereits ein IP Netzwerk konfiguriert ist, 
sprich die Werte &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 
10.0.0.255&quot;. 
Ausserdem sind die <strong>UP</strong> und <strong>RUNNING</strong> 
Flags gesetzt.

<p>
Schlussendlich f&auml;llt auf, das standardm&auml;ssig eine Menge mehr 
Interfaces aktiviert sind. Dies sind virtuelle Interfaces, die verschiedene 
Funktionen haben. Informationen dazu findest du auf den folgenden man 
pages:

<!-- XXXrelease -->
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4&amp;manpath=OpenBSD+3.3">pflog</a> - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a> - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a> - Point to Point Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a> - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a> - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a> - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a> - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a> - Generic IPv4/IPv6 Tunnel Interface
</ul>

Der 1. Schritt zur Konfiguration deiner Netzwerkkarte ist das Erstellen
der <b>/etc/hostname.xxx</b> Datei, wobei der Name deiner Karte den Platz
von xxx einnehmen sollte. Aus der Information der obigen Beispiele w&uuml;rde
der Name <b>/etc/hostname.fxp0 </b>lauten. Das Layout dieser Datei sollte
einfach so aussehen: <br>

<blockquote><pre>
address_family address netmask broadcast [weitere Optionen]
</pre></blockquote>
(Viel mehr Details zu dieser Datei findest du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a> man page.)

Eine typische Interface-Konfigurationsdatei f&uuml;r eine IPv4 Addresse 
w&uuml;rde so aussehen:
<blockquote><pre>
$ <b>cat /etc/hostname.fxp0
</b>inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
Du solltest auch den media type f&uuml;r Ethernet angeben, wenn du z.B. den
100baseTX full-duplex Modus erzwingen willst.
</p>

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

(Auf keinen Fall solltest du das tun, wenn nicht beide Seiten der 
Verbindungen auf Voll-Duplex gestellt sind ! Wenn du keine besonderen 
Anforderungen hast, kannst du diese media settings einfach ignorieren.)

<p>
Oder vielleicht willst du auch spezielle flags f&uuml;r ein einzelnes 
Interface benutzen. Das Format der Datei &auml;ndert sich dabei nicht 
besonders!
</p>

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
Der n&auml;chste Schritt ist das Einstellen deines Standard-Gateways (default gateway).
Dazu trag einfach die IP deines Gateways in die Datei <b>/etc/mygate</b> ein. 
Dies erlaubt das Aktivieren deines Gateways beim Starten. Jetzt solltest 
du deine Nameserver eintragen und die Datei <b>/etc/hosts</b> einrichten. 
F&uuml;r die Nameserver ben&ouml;tigst du eine Datei namens 
<b>/etc/resolv.conf</b>. Mehr &uuml;ber das Format dieser Datei findest 
du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a>
Manual Seite. F&uuml;r den Normalgebrauch ist hier ein Beispiel, in dem
deine Nameserver 125.2.3.4 und 125.2.3.5 sind. Du geh&ouml;rst zur Domain
domain &quot;example.com&quot;.
</p>

<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
Jetzt kannst du entweder rebooten oder das <b>/etc/netstart</b> Script
ausf&uuml;hren, indem du (als root) folgendes eingibst:
</p>

<blockquote><pre>
# <b>sh /etc/netstart
</b>writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Dabei werden ein paar Fehlermeldungen ausgegeben. Indem du dieses Skript ausf&uuml;hrst, 
versuchst du ein paar Sachen zu konfigurieren, die bereits konfiguriert sind. 
Daher existieren bereits bereits einige der Routen in der kernel routing table. 
Von hier ab sollte dein System laufen und online sein. Du kannst hier erneut mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
pr&uuml;fen, ob deine Interfaces richtig konfiguriert wurden.
Deine Routen kannst via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a> oder 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a> 
&uuml;berpr&uuml;fen.
Wenn du Probleme mit dem Routing hast, m&ouml;chtest du vielleicht
das -n Flag f&uuml;r route(8) benutzen, dass die IP-Adressen ausgibt, statt 
einen DNS Lookup zu machen, und den Hostnamen anzuzeigen.
Hier ist ein Beispiel mit beiden Kommandos:
</p>

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)
$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name= "Setup.2"></a>
<h3>
6.1.2 - Einrichten deines OpenBSD Rechners als Gateway</h3>
<p>
Dies sind nur die grundlegende Informationen, um deinen OpenBSD Rechner als
Gateway (auch Router genannt) einzurichten. Wenn du OpenBSD als Router
im Internet verwenden willst, solltest du auch die unten folgenden Packet Filter
Instruktionen beachten, um potentiell sch&auml;dliche IP Daten zu blockieren.
Auch solltest du wegen der Knappheit an 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a> 
Adressen die Informationen bez&uuml;glich Network Address Translation beachten, 
um deinen IP Adressbereich zu schonen.
</p>

<p>
Der GENERIC Kernel hat bereits die F&auml;higkeit f&uuml;r IP Forwarding,
aber dies mu&szlig; erst eingeschaltet werden. Du solltest dies mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
tun. Um diese &Auml;nderung permanent einzutragen, mu&szlig;t du die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>
editieren. F&uuml;ge einfach folgende Zeile in diese Konfigurationsdatei
ein.
</p>

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Ohne Reboot kannst du dies auch direkt mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> 
durchf&uuml;hren. Beachte aber, da&szlig; diese &Auml;nderung nach einem Reboot weg ist und
dass der folgende Befehl als root ausgef&uuml;hrt werden mu&szlig;.
</p>

<blockquote><pre>
# <b>sysctl -w net.inet.ip.forwarding=1
</b>net.inet.ip.forwarding: 0  -&gt; 1
</pre></blockquote>

<p>
Nun modifiziere die Routen der anderen Hosts. Es gibt viele verschiedene
M&ouml;glichkeiten, OpenBSD als Router einzusetzen, z. B. mittels Software
wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>, 
und <a href="http://www.zebra.org">zebra</a>.
OpenBSD hat Unterst&uuml;tzung
in der ports Kollektion sowohl f&uuml;r gated, zebra als auch mrtd. OpenBSD unterst&uuml;tzt
mehrere T1, HSSI, ATM, FDDI, Ethernet und serielle (PPP/SLIP) Schnittstellen.
</p>

<p>
<a name= "Setup.3"></a>
<h3>
6.1.3 - Einrichten von Aliases auf deiner Netzwerkkarte</h3>
<p>
OpenBSD hat einen einfachen Mechanismus, um IP Aliase f&uuml;r deine Netzwerk-Karten
zu setzen. Dazu musst du einfach die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>
editieren. Sie wird beim Booten vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a> Skript gelesen,
das ein Teil der <a href="../faq10.html#rc">rc startup
Hierarchie</a> ist. F&uuml;r dieses Beispiel nehmen wir an, der User hat ein Interface
<b>dc0</b>  und befindet sich im Netzwerk 192.168.0.0. Weitere wichtige Informationen:
</p>

<ul>
<li>
IP f&uuml;r dc0 ist 192.168.0.2</li>
<li>
NETMASK ist 255.255.255.0</li>
</ul>

<p>
Ein paar Bemerkungen zu Aliasen: Bei OpenBSD verwendet man nur den Adapternamen. 
Es gibt keine Unterschiede zwischen dem ersten und dem zweiten Alias. 
Daher mu&szlig; man sie nicht - wie in einigen anderen Betriebssystemen - 
als dc0:0, dc0:1 bezeichnen.
Wenn du dich auf einen speziellen IP Alias beziehst oder einen hinzuf&uuml;gst, 
dann nimm "<tt>ifconfig int alias</tt>" anstelle nur "<tt>ifconfig int</tt>" 
auf der Befehlszeile. Du kannst Aliase mit "<tt>ifconfig int delete</tt>" 
l&ouml;schen. 
<p>

Angenommen du verwendest mehrere IP Adressen im selben IP Subnetz mit Aliases, 
dann ist die Netzmaskeneinstellung f&uuml;r jeden Alias 255.255.255.255.
Sie m&uuml;ssen nicht der Netzmaske der ersten IP der Netzwerkkarte folgen. 
In diesem Beispiel <i>/etc/hostname.dc0</i> werden zwei Aliase zur Netzwerkkarte 
dc0 hinzugef&uuml;gt, die als 192.168.0.2 mit Netzmaske 255.255.255.0 
konfiguriert wurde.

<blockquote><pre>

# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255 
inet alias 192.168.0.4 255.255.255.255 
</pre></blockquote>


<p>
Wenn du einmal diese Datei erstellt hast, ben&ouml;tigst du einen Reboot,
um die &Auml;nderung automatisch durchf&uuml;hren. Du kannst aber auch
die Aliase manuell mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
hochbringen. F&uuml;r den ersten Alias geht das so:
</p>


<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
Um die Aliases zu sehen:
</p>

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>

<p>
<a name="PF"></a>
<h2>6.2 - Packet Filter (PF)</h2>
Packet Filter (ab hier nur noch als PF bezeichnet) ist OpenBSD's System 
zum Filtern von TCP/IP Verkehr und zum Ausf&uuml;hren von Network Address 
Translation. PF ist ausserdem in der Lage TCP/IP-Verkehr zu normalisieren
und zu konditionieren und ausserdem eine Priorisierung von Paketen 
durchzuf&uuml;hren. PF ist seit OpenBSD Version 3.0 Teil des
OpenBSD GENERIC Kernels. Beschrieben wird PF im neuen
<a href="../pf/index.html"><b>PF User's Guide</b></a>.
 
Die alte PF FAQ ist nach wie vor <a href="../faq6pf.html">hier</a>
zu lesen.

<br>

<p> 
<a name= "DHCP"></a>
<h2>6.4 - DHCP</h2> 
</p>

<h3>6.4.1 DHCP Klient</h3>
<p>Um den DHCP Klient 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
zu benutzen, der Teil von OpenBSD ist, editiere /etc/hostname.xl0
(wenn deine Hauptethernetkarte xl0 ist. Deine kann ep0 oder fxp0 oder 
irgendeine andere sein!). 
Alles, was du in dieser Datei zu schreiben hast, ist 'dhcp'.
<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>
Dies wird OpenBSD veranlassen, den DHCP Klient automatisch beim Booten zu 
starten.  OpenBSD wird sich seine IP Adresse, sein Standardgateway und seine 
DNS Server vom DHCP Server besorgen.  
<p>
Wenn du den DHCP Klient von der Befehlszeile starten willst, stelle sicher, 
da&szlig; /etc/dhclient.conf existiert, dann versuche:
<PRE>
# <strong>dhclient fxp0</strong>
</pre>
Wobei fxp0 die Netzwerkkarte ist, auf der du DHCP empfangen willst.
<P>Wie du auch immer dhclient startest, du kannst die /etc/dhclient.conf Datei 
immer so editieren, da&szlig; dein DNS <b>nicht</b> erneuert wird aufgrund 
der neuen DNS Informationen, indem du die 'request' Zeilen auskommentierst 
(Es gibt Beispiele in den Standardeinstellungen, aber du mu&szlig;t die 
Standardeinstellungen von dhclient &uuml;berschreiben.). 
<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>
und dann <b>entferne</b> domain-name-servers.  Nat&uuml;rlich kannst du auch 
hostname oder andere Einstellungen entfernen.
<P>
<h3>6.4.2 DHCP Server</h3>

Wenn du OpenBSD als DHCP Server 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&sektion=8">dhcpd(8)</a>,
einstetzen willst, 
editiere /etc/rc.conf. Setze dhcpd_flags="-q" anstelle von dhcpd_flags=NO.
Und die Netzwerkkarten, auf denen dhcpd(8) <b>lauschen</b> soll, stehen in /etc/dhcpd.interfaces.
<pre>
# <strong>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</strong>
</pre>
Dann editiere /etc/dhcpd.conf.
Die Optionen sind selbsterkl&auml;rend.
<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>
<p>
Dies teilt deinen DHCP Klienten mit, da&szlig; die an DNS Anfragen 
anzuh&auml;ngende Dom&auml;ne example.com ist (d. h., wenn der Benutzer schreibt 
'telnet joe', dann wird an joe.example.com gesendet). Es wird auf die DNS Server 
192.168.1.3 und 192.168.1.5 verwiesen. F&uuml;r Hosts, die sich im selben 
Netzwerk wie die Netzwerkkarte des OpenBSD Rechners befinden, welche im 
192.168.1.0/24 Adressbereich liegt, wird der DHCP Server ihnen eine IP Adresse 
zwischen 192.168.1.32 und 192.168.1.127 und als Standardgateway 192.168.1.1 zuweisen.
<p>
Wenn du den dhcpd(8) von der Befehlszeile starten willst, nachdem du /etc/dhcpd.conf 
editiert hast, versuche:
<PRE>
    # <b>dhcpd -q fxp0</b>
</PRE>
Wobei <tt>fxp0</tt> die Netzwerkkarte ist, auf der DHCP serviert werden soll. 
Die <tt>-q</tt> Option setzt die Ausgabe von dhcpd(8) auf ruhig, ansonsten ist sie sehr 
ausf&uuml;hrlich.
<P>
Wenn du DHCP Dienste f&uuml;r einen Windows Rechner bereitstellst, dann willst 
du vielleicht auch eine 'WINS' Serveradresse liefern.
Daf&uuml;r f&uuml;ge einfach die folgenden Zeilen zu deiner /etc/dhcpd.conf:
<pre>
option	netbios-name-servers	192.168.92.55;
</pre>
(wobei <tt>192.168.92.55</tt> die IP deines Windows oder Samba Servers ist.)
Siehe auch 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&sektion=5">dhcp-options(5)</a>
f&uuml;r weitere Optionen, die 
deine DHCP Klienten w&uuml;nschen.
<p>
<a name="PPP"></a>
<h2>6.5 - PPP </h2>
</p>

Das "Point-to-Protocol" wird verwendet, um eine Verbindung zu deinem ISP mit 
deinem Modem herzustellen. OpenBSD bietet daf&uuml;r 2 M&ouml;glichkeiten.

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8">pppd(8)</a>
- der Kernel PPP D&auml;mon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
- der Userland PPP D&auml;mon. 
</ul>

<p>
Den ersten, den wir behandeln, wird der Userland PPP D&auml;mon sein. Um zu 
beginnen, ben&ouml;tigen wir einige einfache Informationen &uuml;ber deinen ISP. 
Hier eine Liste hilfreicher Informationen, die du brauchen wirst.
</p>

<ul>
<li>Die Einwahlnummer deines ISP
<li>Deinen Nameserver 
<li>Deinen Benutzernamen und Password
<li>Dein Gateway
</ul>

<p>
Einige von diesen ben&ouml;tigst du nicht unbedingt, aber sie w&auml;ren hilfreich. 
Der Userland PPP D&auml;mon benutzt die Datei 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> als
seine Konfigurationsdatei. Es gibt viele hilfreiche Dateien in <b>/etc/ppp</b>, 
die verschiedene Einstellungen f&uuml;r verschiedene Situationen zeigen. Du solltest 
dir dieses Verzeichnis ansehen und es durchforsten.
</p>

<p>
Solltest du keinen GENERIC Kernel verwenden, dann stelle sicher, da&szlig; du 
folgende Zeile in deiner Kernelkonfigurationsdatei hast:
</p>

<blockquote><pre><strong>
pseudo-device   tun             2
</strong></pre></blockquote>

<h3>Erste Einstellungen - f&uuml;r PPP(8)</h3>

<p>
Die ersten Einstellungen f&uuml;r den Userland PPP D&auml;mon bestehen im Erstellen 
deiner <b>/etc/ppp/ppp.conf</b> Datei. Diese Datei existiert nicht 
standardm&auml;&szlig;ig, aber du kannst einfach <b>/etc/ppp/ppp.conf.sample</b> 
editieren, um deine eigene <b>ppp.conf</b> Datei zu kreieren. Hier werde ich mit 
dem einfachsten und gebr&auml;chlichsten Einstellungen beginnen.
Hier eine schnelle <b>ppp.conf</b> Datei, die uns einfach zu deinem ISP verbindet 
und die Standardrouten und Nameserver setzt. F&uuml;r diese Datei brauchst du nur 
die Telefonnummer deines ISP sowie deinen Benutzernamen und dein Passwort.
</p>

<blockquote><pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>

<p>
Der Absatz unter der <b>default:</b> Bezeichnung wird jedes Mal ausgef&uuml;hrt. 
Hier stehen alle wichtigen Informationen. Mit &quot;set log&quot; stellen wir die 
Loglevel ein. Um dies zu &auml;ndern, siehe 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
f&uuml;r weitere Info. Unsere Schnittstelle 
wird mit &quot;set device&quot; eingestellt. Dies ist die Schnittstelle, mit der das 
Modem verbunden ist. In diesem Beispiel h&auml;ngt das Modem auf COM Port 2. Daher 
wird COM Port 1 auf /dev/cua00 gesetzt. Mit &quot;set speed&quot; setzen wird die 
Geschwindigkeit unserer Dialup Verbindung und mit &quot;set dial&quot; setzen wir unsere 
Dialup Parameter, mit denen wir die timeout Zeit, usw. setzen k&ouml;nnen. Diese Zeile 
sollte eigentlich ziemlich genau so, wie sie jetzt ist, bleiben.
</p>

<p>
Nun k&ouml;nnen wir die ISP spezifischen Informationen eintragen. Wir tun dies, indem 
wir unter <b>default:</b> einen weiteren Absatz hinzuf&uuml;gen. Dieser kann als alles 
benannt werden, am einfachsten nimmst du den Namen deines ISP. Hier werde ich 
<b>myisp:</b> als Verweis auf unseren ISP nehmen. Hier ist ein einfaches Beispiel, 
das alles beinhaltet, um uns zu verbinden.
<p>

<blockquote><pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre></blockquote>

<p>
Hier stehen alle wichtigen Informationen f&uuml;r unseren spezifischen ISP. Die erste 
Option &quot;set phone&quot; setzt die Telefonnummer deines ISP. &quot;set login&quot; 
setzt unsere login-Optionen. Hier haben wir die timeout auf 5 gesetzt, was bedeutet, 
da&szlig; wir unseren login-Versuch nach 5 Sekunden abbrechen, wenn wir kein 
Tr&auml;gersignal bekommen. Ansonsten wird er auf &quot;login:&quot; warten und dann 
deinen Benutzernamen und Passwort senden. In diesem Beispiel ist unser username = ppp 
und das Password = ppp. Diese Werte m&uuml;ssen ge&auml;ndert werden. Die Zeile 
&quot;set timeout&quot; setzt den Idle timeout f&uuml;r die gesamte Verbindungsdauer auf 120 
Sekunden. Die &quot;set ifaddr&quot; Zeile ist ein bi&szlig;chen schwieriger. Hier ist 
eine genauere Erkl&auml;rung.
</p>

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
Die obigen Zeile folgt dem Format von 
&quot;<b>set ifaddr [meineAdr[/nn] [seineAdr[/nn] [netzmaske [startAdr]]]]</b>&quot;. 
Daher ist die erste spezifizierte IP diejenige, die wir als unsere IP wollen. Wenn du 
eine statische IP Adresse hast, dann kannst du sie hier einsetzen. In unserem Beispiel 
benutzen wir /0, was besagt, da&szlig; kein Bits von dieser IP Adresse &uuml;bereinstimmen 
mu&szlig; und der gesamte Ausdruck ersetzt werden kann. Die zweite IP behandelt die von 
uns erwartete IP unserer Gegenstelle. Wenn du sie wei&szlig;t, dann kannst du sie hier 
angeben. Wiederum wissen wir nicht in unserer Zeile, welche IP dies wird, also lassen 
wir sie um wieder mitteilen. Die dritte Option ist unsere Netzmaske, hier auf 
255.255.255.0 gesetzt. Wenn startAdr spezifiziert ist, dann wird diese anstelle von 
meineAdr w&auml;hrend der initialen IPCP Verhandlung; aber es wird nur eine Adresse aus 
dem meineAdr-Adressbereich akzeptiert. 
</p>

<p>
Die n&auml;chste Option &quot;add default HISADDR&quot; setzt unsere Standardroute 
zu deren IP. Dies ist 'klebrig', d. h falls deren IP sich &auml;ndern sollte, dann 
wird unsere Route auch automatisch upgedatet. Mit &quot;enable dns&quot; teilen wir 
unserem ISP mit, unsere Nameserveradresse zu authentifizieren. Tu dies NICHT, wenn du 
deinen eigenen lokalen DNS laufen hast, da PPP dies umgehen wird, indem es einige 
Zeilen in /etc/resolv.conf schreibt.
</p>

<h3>PPP(8) verwenden</h3>

<p>
Nun, da wir unsere <b>ppp.conf</b> Datei fertig eingerichtet haben, k&ouml;nnen wir 
beginnen, eine Verbindung zu unserem ISP aufzubauen. Hier einige Details &uuml;ber 
h&auml;ufig verwendete Parameter.
</p>

<ul>
<li><b>ppp -auto myisp</b> - Startet PPP, konfiguriert deine Schnittstellen und 
wird dich mit deinem ISP verbinden und dann in den Hintergrund verschwinden.
<li><b>ppp -ddial myisp</b> - &Auml;hnlich wie -auto, aber wenn deine Verbindung 
abbricht, wird PPP versuchen, sich erneut zu verbinden.
</ul>

<p>
Mit dem Aufruf von <b>/usr/sbin/ppp</b> ohne Optionen kommst du in den interaktiven 
Modus. Hier kannst du direkt mit dem Modem interagieren, was sich hervorragend eignet, 
um Probleme in deiner <b>ppp.conf</b> Datei zu debuggen.
</p>

<h3>ppp(8) Extras</h3>

<p>
In einigen Situationen m&ouml;chstest du Befehle ausf&uuml;hren, wenn die 
Verbindung gerade errichtet oder beendet wurde. F&uuml;r diese F&auml;lle gibts es zwei 
Dateien, die du kreieren kannst: <b>/etc/ppp/ppp.linkup</b> und 
<b>/etc/ppp/ppp.linkdown</b>.
Beispielskonfigurationen kannst du hier finden:
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Weitere Informationen findest du im
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">FreeBSD Handbook entry on User PPP</a>. 
</p>

<p>
<a name= "Tuning"></a>
<h2>6.6 - Netzwerkparameter tunen</h2>
<!-- XXXrelease -->

<P>
Um dies zu tunen, verwende <tt>sysctl</tt> und erh&ouml;he die Werte von:
<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>
Mittels <tt>sysctl -a</tt> kannst du die derzeitigen Werte dieser (und vieler
anderer) Parameter sehen. Um einen Wert zu ver&auml;ndern, verwende 
<tt>sysctl -w</tt>, wie z. B. <tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.  

<h3>6.6.2 - Wie kann ich "directed broadcasts" aktivieren?</h3>
Normalerweise willst du dies nicht tun.  Dies erlaubt jemand, Datenverkehr zu
der broadcast Adresse deines verbundenen Netzwerkes zu schicken, wenn du deinen 
OpenBSD Rechner als Router verwendest.<P>
Aber manchmal kann dies (in geschlossenen Netzwerken) n&uuml;tzlich sein,
vor allem wenn man &auml;ltere Implementierungen des NetBIOS Protokolles
verwendet.
Wiederum mit sysctl.  <tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> 
aktiviert dies.  Beachte aber <a href="http://www.netscan.org">Smurfangriffe</a>, 
wenn du wissen willst, warum dies standardm&auml;&szlig;ig nicht aktiviert ist.

<H3>6.6.3 - Der Kernel soll Ports nicht dynamisch allozieren</h3>
Auch daf&uuml;r gibt es einen eigenen sysctl Befehl.  Siehe 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:
<PRE>
Setze die Liste der reservierten TCP ports, die nicht dynamisch vom
Kernel vergeben werden sollen. Das kann man benutzen, um daemons davon
abzuhalten, einen speziellen port zu benutzen, den ein anderes Programm
braucht, damit es funktionieren kann. Listen-Elemente k&ouml;nnen
mit Kommata und/oder Leerzeichen getrennt werden.

#  <strong>sysctl -w  net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

Es ist ebenso m&ouml;glich ports aus der aktuellen Liste hinzuzuf&uuml;gen 
oder zu entfernen.

 #  <strong>sysctl -w net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl -w net.inet.tcp.baddynamic=-871</strong>
</pre>

<p>
<a name= "NFS"></a>
<h2>6.7 - Einfache NFS Anleitung</h2>
</p>

<p>NFS, oder Network File System (Netzwerkdateisystem), wird verwendet, um 
ein Dateisystem &uuml;ber das Netzwerk zu verwenden. Du solltest vorher noch 
folgende Manualseiten lesen, bevor du versuchst, einen eigenen NFS Server 
aufzusetzen:

<p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
</ul>

<p>
Dieses Kapitel zeigt die Schritte, um ein einfaches NFS System aufzusetzen: 
Ein Server im LAN und Klienten im LAN, die NFS verwenden. Es behandelt nicht, 
wie man NFS sicher macht. Wir nehmen an, da&szlig; du bereits Paketfilterung 
oder irgendeinen anderen Firewallschutz eingerichtet hast, damit von 
au&szlig;erhalb nicht auf NFS zugegriffen werden kann.
Wenn du Zugriff via NFS von au&szlig;erhalb erlauben willst und sensible Daten 
dort gespeichert hast, dann empfehlen wir dir w&auml;rmstens den Gebrauch von 
IPsec.  Ansonsten k&ouml;nnen andere Leute 
m&ouml;glicherweise deinen NFS Datenverkehr sehen. Jemand k&ouml;nnte auch 
vort&auml;uschen, die IP Adresse zu sein, der du Zugriff auf den NFS Server 
l&auml;&szlig;t. Es gibt mehrere Angriffe, die m&ouml;glich sind. Wenn IPsec 
richtig konfiguriert ist, dann sch&uuml;tzt es gegen die Art von Angriffen. 
<P>
Noch eine wichtige Anmerkung wegen Sicherheit. F&uuml;ge niemals ein 
Dateisystem zu /etc/exports ohne eine Liste mit Rechnern, die explizit 
Zugriff haben sollen. Ohne einer solchen Liste, die ein bestimmtes Verzeichnis 
mounten k&ouml;nnen, kann jeder, der den Rechner erreichen kann, deine NFS 
exports mounten.
</p>

<p>
NFS h&auml;ngt von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
ab, bevor es funktionieren kann. Portmap(8) ist ab OpenBSD 3.2 
standardm&auml;ssig abgeschaltet, du musst es also in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
wieder einschalten, indem du die <tt>portmap</tt> Zeile wie folgt &auml;nderst:

<blockquote><pre>
portmap=YES
</pre></blockquote>
und ein Reboot ist notwendig, damit die &Auml;nderung wirksam wird.

<p>
Der Server hat die IP <b>10.0.0.1</b>. Dieser Server soll nur NFS f&uuml;r 
Rechner innerhalb dieses Netzwerkes bereitstellen. Der erste Schritt ist 
deine <i>/etc/exports</i> Datei zu erstellen. Diese Datei listet die 
Dateisysteme auf, die du &uuml;ber NFS freigeben willst, und definiert, wer 
auf sie zugreifen darf. Es gibt viele Optionen, die du in deiner 
<i>/etc/exports</i> Datei haben kannst, und am besten ist, du liest 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
F&uuml;r dieses Beispiel sieht <i>/etc/exports</i> so aus:
</p>

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
D.h., da&szlig; das lokale Dateisystem <b>/work</b> via NFS zug&auml;nglich 
gemacht wird. <b>-alldirs</b> bedeutet, da&szlig; Klienten jedes Verzeichnis 
unter dem <b>/work</b> Mount-point mounten k&ouml;nnen. <b>-ro</b> bedeutet,  
da&szlig; nur Leseberechtigung gestattet wird. Die letzten zwei Argumente 
bedeuten, da&szlig; nur Klienten innerhalb des 10.0.0.0 Netzwerkes mit einer 
Netzmaske von 255.255.255.0 dieses Dateisystem mounten d&uuml;rfen. Dies ist 
wichtig f&uuml;r einige Server, die von verschiedenen Netzwerken 
zug&auml;nglich sind.
</p>

<p> Ist einmal deine <i>/etc/exports</i> Datei eingerichtet, kannst du 
weitergehen und deinen NFS Server aufsetzen. Du solltest zuerst sicherstellen, 
da&szlig; deine Kernelkonfiguration die Optionen NFSSERVER &amp; NFSCLIENT 
enth&auml;lt. (Der GENERIC Kernel beinhaltet diese Optionen.) Dann 
solltest du <strong>nfs_server=YES</strong> in <i>/etc/rc.conf</i> eintragen. 
Dies wird sowohl nfsd(8) und mountd(8) starten, wenn du rebootest.
Nun kannst du fortschreiten und die Dienste selber starten. Diese Dienste 
m&uuml;ssen als root gestartet werden und du mu&szlig;t sicherstellen, 
da&szlig; portmap(8) auf deinem System l&auml;uft. Hier ein Beispiel von 
nfsd(8), der sowohl mit TCP als auch mit UDP bedient mittels 4 Diensten. 
Du solltest eine angemessenene Anzahl von NFS Serverdiensten einsetzen, um 
die maximale Anzahl von gleichzeitigen Klientenanfragen, die du bedienen 
willst, zu bewerkstelligen.

<P>

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Du mu&szlig;t nicht nur den nfsd(8) Server starten, sondern auch mountd(8). 
Dies ist der Dienst, der eigentlich die Mountanfragen auf NFS bedient. Um 
mountd(8) zu starten stelle sicher, dass eien leere mountdtab Datei
existiert, und starte den Daemon:
<p>

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<P>
Wenn du &Auml;nderungen an /etc/exports durchf&uuml;hrst, w&auml;hrend 
NFS bereits l&auml;uft, mu&szlig;t du mountd dies mitteilen, indem du den 
Dienst neu startest!

<UL><PRE>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<P>

<h3>NFS Status &uuml;berpr&uuml;fen</h3>

<p>
Um zu &uuml;berpr&uuml;fen, ob alle Dienste laufen und bei RPC registriert 
sind, verwende rpcinfo(8). 
<p>

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p> F&uuml;r den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen 
du den Status von NFS &uuml;berpr&uuml;fen kannst. Eines ist 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8">showmount(8)</a>
das dir anzeigt, was und wer gerade mountet. Dann gibt es auch noch nfsstat(8),
das genauere Statistiken anzeigt. F&uuml;r showmount(8), versuche 
<b>/usr/bin/showmount -a host</b>. Z. B.:

<P>

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<h3>NFS Dateisysteme mounten</h3>

<p>
NFS Dateisysteme sollten mittels mount(8) geladen werden, oder genauer 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8">mount_nfs(8)</a>.
Um ein Dateisystem /work von Host 10.0.0.1 auf dem lokalen Dateisystem /mnt 
zu laden, tue folgendes (NB: du mu&szlig;t nicht IP Adressen verwenden, mount 
wird Hostnamen aufl&ouml;sen):
<p>

<blockquote><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<P>
Damit dein System dies beim Hochfahren wieder tut, f&uuml;ge folgendes zu 
deiner <i>/etc/fstab</i>:
<P>

<UL><PRE>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<P>
Es ist wichtig, da&szlig; du <tt>0 0</tt> am Ende dieser Zeile verwendest, 
damit dein Rechner nicht versucht, das NFS Dateisystem beim Hochfahren mit 
fsck zu &uuml;berpr&uuml;fen!!!! Die anderen Sicherheitsoptionen wie noexec, 
nodev und nosuid, sollten auch immer - wenn anwendbar - verwendet werden. 
Z. B.:
<P>

<UL><PRE>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<P>
Mit diesen Optionen k&ouml;nnen keine Ger&auml;te oder setuid Programme auf 
dem NFS Server Sicherheitsma&szlig;nahmen auf dem NFS Klient untergraben. 
Wenn du keine Programme auf diesem NFS Dateisystem auf dem NFS Klient 
ausf&uuml;hren willst, f&uuml;ge noexec hinzu:

<p>
<a name= "PPTP"></a>
<h2>6.9 - Eine PPTP Verbindung mit OpenBSD aufsetzen</h2>
</p>

<p>
<strong>HINWEIS:</strong> Dies bezieht sich nicht auf <strong>ALLE</strong> ADSL Provider, aber viele der Informationen k&ouml;nnen aus diesem Setup 
&uuml;bernommen werden. Dieses Setup funktioniert auf jeden Fall bei <a href="http://www.inode.at">Inode</a>, einem ADSL Provider in &Ouml;sterreich.
</p>

<p>
Als Anfang musst du pptp installiert haben. Der Port befindet sich unter
<i>/usr/ports/net/pptp</i>. Lies <a href="../faq8.html#Ports">FAQ 8, 
Ports</a> um mehr Informationen &uuml;ber den OpenBSD ports tree zu 
bekommen.
</p>

<p>
Wegen des Konflikts der "Im-Kernel" 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&sektion=4">gre(4)</a>
Unterst&uuml;tzung und pptp wirst du deinen Kernel neu kompilieren 
m&uuml;ssen und die Unterst&uuml;tzung f&uuml;r gre(4) entfernen m&uuml;ssen.
</p>

<blockquote>Patch, um die GRE(4) Unterst&uuml;tzung zu entfernen.
<pre>
Index: GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.86
diff -u -r1.86 GENERIC
--- GENERIC     14 Mar 2002 00:42:25 -0000      1.86
+++ GENERIC     17 May 2002 01:52:17 -0000
@@ -87,7 +87,7 @@
 pseudo-device  enc     1       # option IPSEC needs the encapsulation interface
 pseudo-device  bridge  2       # network bridging support
 pseudo-device  vlan    2       # IEEE 802.1Q VLAN
-pseudo-device  gre     1       # GRE encapsulation interface
+#pseudo-device gre     1       # GRE encapsulation interface
 #pseudo-device strip   1       # Starmode Radio IP interface

 pseudo-device  pty     64      # pseudo-terminals
</pre></blockquote>

<p>
Um deinen Kernel neu zu kompilieren mache einen "check out" von OpenBSD 
via cvs (siehe die <a href="../../de/stable.html">OpenBSD Stable</a> 
Webseite) , benutze den folgenden Patch, und baue einen neuen Kernel 
wie unter <a href="faq5.html#Building">FAQ 5, Building a kernel</a>.
</p>

<p>
Nachdem du das <b>pptp</b> package und einen neuen Kernel installiert hast,
musst du ein paar Dateien f&uuml;r deine neue Verbindung editieren.
Diese packages benutzen das standarm&auml;ssige OpenBSD 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
wenn du dich also mit ppp(8) auskennst, kommt dir vieles bekannt vor. 
Siehe auch <a href="#Setup">FAQ 6, Setup</a>.
</p>

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
F&uuml;r eine <i>/etc/ppp/options</i> Datei wird ein Setup wie das unten vermutlich alles notwendige tun:
</p>

<blockquote><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></blockquote>

<p>
<tt>LOGINNAME</tt> sollte mit deiner User-ID ersetzt werden.
</p>

<p>
In <i>/etc/ppp/pap-secrets</i> geh&ouml;rt eine Zeile wie diese hier:

<blockquote><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></blockquote>

<p>
Wobei LOGINNAME deine User-ID und PASSWORD dein Password ist. 10.0.0.138 ist die zugewiesene IP deines Modems im Falle, dass du ADSL nutzt, etc. 
Stelle sicher, dass diese Datei nur von root gelesen werden kann (mode 600).
</p>

<h3>6.9.1 - Deinem Network Interface eine Adresse zuweisen</h3>

<p>
Im obigen Beispiel hatte unser Modem eine vorkonfigurierte Adresse von 10.0.0.138. Jetzt m&uuml;ssen wir UNSEREM Interface noch eine Adresse zuweisen.
Es ist am besten eine IP zu w&auml;hlen, die nahe an der deines MODEMS liegt, oder einfach die statische Adresse zu benutzen, die dir zugewiesen wurde.
Mehr dar&uuml;ber, wie man Interfaces IP-Adressen zuweist, kannst du in <a href="#6.1">FAQ 6.1</a> lesen.
</p>

<p>
Wenn dein Interface eingerichtet ist, solltest du eine pptp Verbindung mit dem Kommando 

<blockquote><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &amp;</strong>
</pre></blockquote>

aufbauen k&ouml;nnen.
<p>
Da hier auch der "in-house" OpenBSD ppp(8) benutzt wird, werden hier zwei Prozesse gestartet. Du kannst pptp beenden, indem du diesen beiden Prozesse
killst:
</p>

<blockquote><pre>
# <strong>kill -9 [pid of pppd]</strong>
$ <strong>kill -9 [pid of pptp]</strong>
</pre></blockquote>

Wir empfehlen <tt>/var/log/messages</tt> in einem weiteren Terminalfenster zu &ouml;ffnen, um m&ouml;gliche Probleme zu erkennen.

<blockquote><pre>
# <strong>tail -f /var/log/messages</strong>
</pre></blockquote>
</p>

<p>
Wir schlagen vor, die Startsequenz in <i>/etc/rc.local</i> unterzubringen, so dass bei jedem reboot die Verbindung automatisch 
aufgebaut wird.
</p>



<a name="Bridge"></a>
<h2>6.10 - Aufsetzen einer Bridge mit OpenBSD</h2>

Eine <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">Bridge</a>
ist ein Link zwischen zwei oder mehr separaten Netzwerken. Anders als 
ein Router reisen Pakete durch die Bridge "unsichtbar" -- logisch 
erscheinen die beiden Netzwerksegmente als eines f&uuml;r Rechner auf 
beiden Seiten der Bridge. Die Bridge wird nur Pakete weiterleiten, die 
auch von einem Segment in das andere m&uuml;ssen, sie bieten also
auch einen einfachen Weg den Traffic in einem komplexen Netzwerk zu 
reduzieren  und erlauben trotzdem den Zugriff jedes Rechners zu jedem
anderen, falls n&ouml;tig.

<p>
Denk daran, dass aufgrund dieser "unsichtbaren" Natur ein Interface in 
einer Bridge eine IP-Adresse haben kann, aber nicht muss. Wenn sie eine
hat, hat die Karte effektiv zwei Betriebsmodi, n&auml;mlich eine
als Teil der Bridge, die andere als normale, stand-alone Netzwerk-Karte.
Wenn keine der Karten eine IP-Adresse hat, wird die Bridge einfach
Netz-Daten verschieben, aber nicht von extern administrierbar 
oder wartbar sein (was auch ein Feature sein kann).

<h3>Ein Beispiel einer Bridge Anwendung</h3>
Eines meiner Computer Racks hat eine Anzahl alter Systeme, von denen keines
eine eingebaute 10BASE-TX Netzwerk-Karte hat. W&auml;hrend sie alle einen 
AUI oder AAUI Stecker haben, sind die Transceiver auf Koax beschr&auml;nkt.
Eine der Maschinen in diesem Rack ist ein OpenBSD-basierender 
Terminal-Server, der dauerhaft eingeschaltet und auch immer mit einem
High-Speed-Netzwerk verbunden ist. Das Hinzuf&uuml;gen  einer zweiten 
Netzwerk-Karte mit einem Koax-Port erlaubt mir, diese Maschine als Bridge 
in das Koax-Netzwerk zu benutzen.

<p>
Dieses System hat jetzt zwei Netzwerk-Karten (NICs), eine Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
und eine 3c590-Combo Karte 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
f&uuml;r den Koax Port. <tt>fxp0</tt> ist der Link in mein restliches 
Netzwerk und wird daher eine IP-Adresse haben, <tt>ep0</tt> macht nur
Bridging und hat daher keine.
Maschinen, die an das Koax-Segment angeschlossen sind, sollen genauso
kommunizieren, als wenn sie im Rest meines Netzwerkes w&auml;ren.
Wie also bewerkstelligen wir das ?

<p>
Die Datei <tt>hostname.fxp0</tt> enth&auml;lt die Konfigurationsdaten 
f&uuml;r die <tt>fxp0</tt> Karte.  Diese Maschine soll DHCP machen,
also sieht die Datei etwa so aus:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

Noch keinerlei &Uuml;berraschungen

<p>
Die <tt>ep0</tt> Karte ist ein wenig anders, wie du dir denken kannst:
<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

Hier sagen wir dem System, es m&ouml;ge das Interface mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
aktivieren und auf 10BASE-2 (Koax) setzen. Keine IP Addresse oder &auml;hnliche 
Information muss f&uuml;r dieses Interface spezifiziert werden. Die 
Optionen, die von der <tt>ep</tt> Karte akzeptiert werden, sind
detailliert in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">man
page</a> aufgef&uuml;hrt.

<p>
Jetzt m&uuml;sen wir die Bridge aufsetzen. Bridges werden durch die Existenz einer Datei
namens
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
initialisiert. Hier ist zum Beispiel ein Datei f&uuml;r meine Situation:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

Das sagt aus, es soll eine Bridge aus zwei NICs aufgesetzt und aktiviert 
werden, fxp0 und ep0.
Es ist egal, in welche Reihenfolge die Karten aufgef&uuml;hrt werden.
Denke daran, die Bridge ist symmetrisch -- Pakete fliessen ja in beide
Richtungen.

<p>
Das war es!  Reboote, und du wirst eine funktionierende Bridge haben.

<h3>Filtern auf der Bridge</h3>
W&auml;hrend es sicher auch eine Menge Anwendungen f&uuml;r eine 
solch einfache Bridge gibt, ist es doch wahrscheinlich, dass du
etwas mit den ganzen Paketen TUN willst, w&auml;hrend sie durch deine Bridge
laufen. Wie zu erwarten, kann man
<a href="#PF">Packet Filter</a> dazu benutzen, den Traffic einzuschr&auml;nken,
 der durch deine Bridge fliesst.

<p>
Denke daran, dass wegen der Natur der Bridge die gleichen Daten
&uuml;ber beide Interfaces fliessen, aber du nur auf einem Interface 
zu filtern brauchst. Deine "Pass all" Statements w&uuml;rden dann
wie folgt aussehen:

<blockquote>
<pre>
pass in  on ep0  any
pass out on ep0  any
pass in  on fxp0 any
pass out on fxp0 any
</pre>
</blockquote>

Sagen wir nun, ich wollte den Traffic filtern, der diesen alten Maschinen
trifft. Ich m&ouml;chte, dass nur Web und SSH-Traffic zu Ihnen durchkommt.
In diesem Fall lassen wir jeglichen Traffic nach draussen zu, filtern aber
auf dem fxp0 Interface, indem wir keep state f&uuml;r die Antwort-Daten
benutzen:

<blockquote>
<pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

Denke daran, dass diese Regelwerk jeglichen Netzwerk-Verkehr
mit Ausnahme von hereinkommendem HTTP und SSH-Traffic zur Bridge selbst und
den Maschinen "dahinter" verhindert. Andere Resultate werden erzielt,
wenn man auf dem anderen Interface filtert.

<p>
Um die Bridge zu &uuml;berwachen und zu kontrollieren, benutze das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&sektion=8">brconfig(8)</a>
Kommando, mit dem man eine Bridge auch nach dem Booten erzeugen kann.

<h3>Tips zum Bridging</h3>
<ul>
<li>Es wird W&Auml;RMSTENS empfohlen, nur auf einem Interface zu filtern.
Wenn es auch m&ouml;glich ist, auf beiden zu filtern, muss man das vorher 
jedoch sehr gut verstanden haben.

<li>Durch die Benutzung der <i>blocknonip</i> Option von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&sektion=8">brconfig(8)</a>
oder in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&sektion=5">bridgename.bridge0</a>,
kannst du jeglichen nicht-IP Traffic (wie etwa IPX oder NETBEUI) davon 
abhalten, sich um deine Filter herumzustehlen. Das kann in einigen Situationen
sehr wichtig sein, aber du solltest wissen, dass Bridges f&uuml;r jeglichen
Traffic funktionieren, nicht nur f&uuml;r IP.

<li>F&uuml;r Bridging m&uuml;ssen die NICs im "Promiscuous mode" sein -- sie
lauschen einfach am GESAMTEN Netzwerk-Verkehr, nicht nur an dem, der
an das Interface gerichtet ist. Das hat einen h&ouml;heren Load f&uuml;r 
CPU und Bus zur Folge, als man denkt. Einige NICs funktionieren leider
nicht sauber in diesem Modus, der TI ThunderLAN Chip
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&sektion=4">tl(4)</a>)
ist leider so ein Beispiel, der nicht als Teil einer Bridge funktioniert.
</ul>


<p>
<font color= "#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href= "faq5.html">[Zu Kapitel 5 - Neuerzeugen des Systems aus dem Quellcode]</a>
<a href= "faq7.html">[Zu Kapitel 7 - Tastatur- und Bildschirmkontrollen]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[zur&uuml;ck]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<br>
Originally [OpenBSD: faq6.html,v 1.177 ]
<br>
$Translation: faq6.html,v 1.74 2003/07/27 16:22:36 jufi Exp $
</small>
<br>
<small>$OpenBSD: faq6.html,v 1.58 2003/07/27 17:39:32 jufi Exp $</small>
</p>
</body>
</html>
