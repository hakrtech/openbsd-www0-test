<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Netzwerk</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content="Die OpenBSD-FAQ-Seite">
<meta name= "keywords"      content="openbsd,faq">
<meta name= "distribution"  content="global">
<meta name= "copyright"     content="This document copyright 1998-2004 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Source-Code erzeugen]</a>
<a href="faq7.html">[Zum Kapitel 7 - Tastatur- und Bildschirm-Kontrollen]</a>
</font>

<h1><font color="#e00000">6 - Netzwerk</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href= "#Intro" >6.1 - Bevor wir weiter gehen</a>
<li><a href= "#Setup" >6.2 - Erste Netzwerkeinstellungen</a>
<li><a href= "#PF"    >6.3 - Wie kann ich mit OpenBSD filtern und eine
                             Firewall aufsetzen?</a>
<li><a href= "#DHCP"  >6.4 - Dynamic Host Configuration Protokoll (DHCP)</a>
<li><a href= "#PPP"   >6.5 - Point to Point Protokoll (PPP)</a>
<li><a href= "#Tuning">6.6 - Netzwerkparameter tunen</a>
<li><a href= "#NFS"   >6.7 - NFS benutzen</a>
<li><a href= "#Bridge">6.9 - Aufsetzen einer Bridge mit OpenBSD</a>
<li><a href= "#PXE"   >6.10 - Wie boote ich mit PXE?</a>
<li><a href= "#CARP">6.11 - Das Common Address Redundancy Protokoll (CARP)</a>
<li><a href="#OpenNTPD">6.12 - OpenNTPD verwenden</a>
<li><a href="#Wireless">6.13 - Was sind meine Wireless Netzwerk Optionen?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Bevor wir weiter gehen</h2>

<p>
Für den Rest dieses Dokumentes sei gesagt, dass es hilfreich
ist, das Kapitel <a href="faq5.html">Kernelkonfiguration und
Einstellungen</a> der FAQ gelesen und zumindest teilweise verstanden zu
haben, weiterhin helfen die
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> und
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> Manual Seiten.

<p>
Wenn du ein Netzwerkadministrator bist, Routingprotokolle aufsetzt
und dein OpenBSD Rechner dein Router wird, dann solltest du dein Wissen
über IP Netzwerke mit 
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">Understanding
IP addressing</a> vertiefen.
Dies ist wirklich ein exzellentes Dokument. "Understanding IP
addressing" beinhaltet grundlegendes Wissen, auf dem man bei der Arbeit mit
IP Netzwerken aufbauen kann, insbesondere wenn man es mit mehreren Netzwerken
zu tun hat oder für sie verantwortlich ist.

<p>
Wenn du mit Anwendungen wie Web-, FTP- oder Mailservern arbeitest, dann
könntest du viel <a href="http://the.rfc-editor.org/rfc.html">vom
Lesen der entsprechenden RFCs</a> profitieren.
Natürlich kannst du nicht alle lesen. Aber dennoch, lies jene,
die dich interessieren oder die du bei deiner Arbeit brauchen könntest.
Lies nach, wie alles funktionieren sollte. Die RFCs definieren mehrere
(tausend) Standards für Protokolle im Internet und wie sie arbeiten
sollten.

<p>
<a name="Setup"></a>
<h2>6.2 - Erste Netzwerkeinstellungen</h2>

<p>
<a name= "Setup.1"></a>
<h3>6.2.1 - Identifizieren und Einstellen deiner Netzwerkkarten</h3>

<p>
Um beginnen zu können, musst du zunächst deine Netzwerkkarte
identifizieren können. Bei OpenBSD werden Netzwerkkarten nach ihrem
Typ, nicht nach Verbindungsart benannt. Du kannst sehen, ob deine 
Netzwerkkarte initialisiert wurde, entweder schon beim Booten oder auch 
später mit Hilfe des Befehls 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>. 
Weiterhin kannst du mit dem Befehl 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
deine Karte überprüfen. Als Beispiel hier die Ausgabe von
dmesg für eine Intel Fast Ethernet Netzwerkkarte, die als 
Gerätenamen fxp hat.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Wenn du deinen Geräte-Namen nicht kennst, sieh bitte in der 
<a href="../../de/plat.html">Liste der unterstützten Hardware</a> 
für deine Plattform nach. Du wirst eine Liste vieler bekannter Karten
und ihre OpenBSD Geräte-Namen finden (wie etwa fxp), zusammen mit 
einer Nummer, die vom Kernel zugewiesen wird, und du hast den sogenannten 
Interface-Namen (wie z.B. fxp0).

<p>
Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem 
du das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
Kommando benutzt.
Das folgende Kommando zeigt uns alle Netzwerk-Interfaces im System an.
Diese Beispielausgabe zeigt ein physikalisches Ethernet Interface, ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.

<blockquote><pre>
$ <b>ifconfig -a</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
Wie du hier sehen kannst, gibt uns
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
eine Menge mehr Informationen, als wir zu diesem Zeitpunkt 
benötigen. Natürlich sehen wir trotzdem unser Interface. Im 
obigen Beispiel ist die Netzwerkkarte bereits konfiguriert. Das ist 
offensichtlich, da auf fxp0 bereits ein IP Netzwerk konfiguriert ist, 
sprich die Werte &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 
10.0.0.255&quot;. Außerdem sind die <strong>UP</strong> und
<strong>RUNNING</strong> Flags gesetzt.

<p>
Schlussendlich fällt auf, dass standardmäßig eine Menge mehr 
Interfaces aktiviert sind. Dies sind virtuelle Interfaces, die verschiedene 
Funktionen haben. Informationen dazu findest du auf den folgenden Manual
Seiten:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a>
 - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - SLIP Netzwerk Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Point to Point Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
 - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Generic IPv4/IPv6 Tunnel Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp</a>
 - Common Address Redundancy Protocol Interface
</ul>

<p>
Falls du deine Netzwerkkarte noch nicht konfiguriert hast, ist der erste Schritt
das Erstellen der <i>/etc/hostname.xxx</i> Datei, wobei der Name deiner Karte
den Platz von xxx einnnimmt. Aus der Information der obigen Beispiele
würde der Name <i>/etc/hostname.fxp0</i> lauten. Das Layout dieser Datei
ist simpel:<br>

<blockquote><pre>
address_family address netmask broadcast [weitere Optionen]
</pre></blockquote>

(Viel mehr Details zu dieser Datei findest du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
Manual Seite.)

<p>
Eine typische Interface-Konfigurationsdatei für eine IPv4 Adresse
würde so aussehen:

<blockquote><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
Du solltest auch den ,media type' für Ethernet angeben, wenn du z.B. den
100baseTX full-duplex Modus erzwingen willst.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Auf keinen Fall solltest du das tun, wenn nicht beide Seiten der 
Verbindungen auf Voll-Duplex gestellt sind! Wenn du keine besonderen
Anforderungen hast, kannst du diese media Einstellungen einfach ignorieren.)

<p>
Oder vielleicht willst du auch spezielle Flags für ein einzelnes 
Interface benutzen. Das Format der Datei ändert sich dabei nicht 
besonders!

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
Der nächste Schritt ist das Einstellen deines Standard-Gateways
(default gateway). Dazu trage einfach die IP deines Gateways in die Datei
<i>/etc/mygate</i> ein. Dies erlaubt das Aktivieren deines Gateways beim
Starten. Jetzt solltest du deine Nameserver eintragen und die Datei
<i>/etc/hosts</i> einrichten. Für die Nameserver benötigst du eine
Datei namens <i>/etc/resolv.conf</i>. Mehr über das Format dieser
Datei findest du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a>
Manual Seite. Für den Normalgebrauch ist hier ein Beispiel, in dem
deine Nameserver 125.2.3.4 und 125.2.3.5 sind. Du gehörst zur Domain
&quot;example.com&quot;.

<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
Jetzt kannst du entweder rebooten oder das <strong>/etc/netstart</strong>
Skript ausführen, indem du (als root) folgendes eingibst:

<blockquote><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Dabei werden ein paar Fehlermeldungen ausgegeben. Indem du dieses Skript
ausführst, versuchst du ein paar Sachen zu konfigurieren, die bereits
konfiguriert sind. Daher existieren bereits einige der Routen in der
Kernel Routing Tabelle. Von hier ab sollte dein System laufen und online sein.
Du kannst hier erneut mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
prüfen, ob deine Interfaces richtig konfiguriert wurden.
Deine Routen kannst du via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>
oder <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a> 
überprüfen.
Wenn du Probleme mit dem Routing hast, möchtest du vielleicht
das -n Flag für route(8) benutzen, das die IP-Adressen ausgibt, statt 
einen DNS Lookup zu machen, und um den Hostnamen anzuzeigen.
Hier ist ein Beispiel mit beiden Kommandos, um die Routing Tabelle anzeigen
zu lassen:

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.2"></a>
<h3>6.2.2 - Einrichten deines OpenBSD Rechners als Gateway</h3>

<p>
Dies sind nur die grundlegenden Informationen, um deinen OpenBSD Rechner als
Gateway (auch Router genannt) einzurichten. Wenn du OpenBSD als Router
im Internet verwenden willst, solltest du auch die unten folgenden Packet Filter
Instruktionen beachten, um potentiell schädliche IP Daten zu blockieren.
Auch solltest du wegen der Knappheit an 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a>
Adressen die Informationen bezüglich Network Address Translation beachten, 
um deinen IP Adressbereich zu schonen.

<p>
Der GENERIC Kernel hat bereits die Fähigkeit für IP Forwarding,
aber dies muss erst eingeschaltet werden. Du solltest dies mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
tun. Um diese Änderung permanent einzutragen, musst du die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>
editieren. Füge einfach folgende Zeile in diese Konfigurationsdatei
ein.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Ohne Reboot kannst du dies auch direkt mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> 
durchführen. Beachte aber, dass diese Änderung nach einem Reboot
weg ist und dass der folgende Befehl als root ausgeführt werden muss.

<blockquote><pre>
# <strong>sysctl net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0  -&gt; 1
</pre></blockquote>

<p>
Nun modifiziere die Routen der anderen Hosts. Es gibt viele verschiedene
Möglichkeiten, OpenBSD als Router einzusetzen, z.B. mittels Software
wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>
und <a href="http://www.zebra.org">zebra</a>.
OpenBSD hat Unterstützung
in der Ports Kollektion sowohl für gated, zebra als auch mrtd. OpenBSD
unterstützt mehrere T1, HSSI, ATM, FDDI, Ethernet und serielle (PPP/SLIP)
Schnittstellen.

<p>
<a name= "Setup.3"></a>
<h3>6.2.3 - Einrichten von Aliases auf deiner Netzwerkkarte</h3>

<p>
OpenBSD hat einen einfachen Mechanismus, um IP Aliase für deine
Netzwerkkarten zu setzen. Dazu musst du einfach die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>
editieren. Sie wird beim Booten vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a>
Skript gelesen, das ein Teil der <a href="../faq10.html#rc">rc startup
Hierarchie</a> ist. Für dieses Beispiel nehmen wir an, dass der User ein
Interface <b>dc0</b> hat und sich im Netzwerk 192.168.0.0 befindet. Weitere
wichtige Informationen:

<ul>
<li>IP für dc0 ist 192.168.0.2
<li>NETMASK ist 255.255.255.0
</ul>

<p>
Ein paar Bemerkungen zu Aliasen: In OpenBSD verwendet man nur den Adapternamen.
Es gibt keine Unterschiede zwischen dem ersten und dem zweiten Alias. 
Daher muss man sie nicht - wie in einigen anderen Betriebssystemen - 
als dc0:0, dc0:1 bezeichnen.
Wenn du dich auf einen speziellen IP Alias beziehst oder einen hinzufügst, 
dann nimm "<tt>ifconfig int alias</tt>" anstelle nur "<tt>ifconfig int</tt>" 
auf der Befehlszeile. Du kannst Aliase mit "<tt>ifconfig int delete</tt>" 
löschen. 

<p>
Angenommen du verwendest mehrere IP Adressen im selben IP Subnetz mit Aliases, 
dann ist die Netzmaskeneinstellung für jeden Alias 255.255.255.255.
Sie müssen nicht der Netzmaske der ersten IP der Netzwerkkarte folgen. 
In diesem Beispiel <i>/etc/hostname.dc0</i> werden zwei Aliase zur
Netzwerkkarte dc0 hinzugefügt, die als 192.168.0.2 mit Netzmaske
255.255.255.0 konfiguriert wurde.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255 
inet alias 192.168.0.4 255.255.255.255 
</pre></blockquote>

<p>
Wenn du einmal diese Datei erstellt hast, benötigst du einen Reboot,
um die Änderung automatisch durchzuführen. Du kannst aber auch
die Aliase manuell mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
hochbringen. Für den ersten Alias geht das so:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
Um die Aliases zu sehen:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="NAT"></a>
<a name="PF"></a>
<h2>6.3 - Wie kann ich mit OpenBSD filtern und eine Firewall aufsetzen?</h2>
Packet Filter (ab hier nur noch als PF bezeichnet) ist OpenBSDs System 
zum Filtern von TCP/IP Verkehr und zum Ausführen von Network Address 
Translation. PF ist außerdem in der Lage, TCP/IP-Verkehr zu normalisieren
und zu konditionieren, eine Priorisierung von Paketen 
durchzuführen und kann verwendet werden, um eine mächtige und
flexible Firewall zu erzeugen.
Er wird im <a href="../pf/index.html"><b>PF Benutzerhandbuch</b></a>
beschrieben.
 
<p> 
<a name= "DHCP"></a>
<h2>6.4 - Dynamic Host Configuration Protokoll (DHCP)</h2> 

Das Dynamic Host Configuration Protokoll ist ein Weg, um die Netzwerkkarten
"automatisch" zu konfigurieren.
OpenBSD kann als DHCP Server (der andere Maschine konfiguriert), als ein
DHCP Client (der von einer anderen Maschine konfiguriert wird) und in
einigen Fällen auch als beides eingesetzt werden.

<p>
<h3>6.4.1 DHCP Client</h3>

<p>
Um den DHCP Client
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
zu benutzen, der Teil von OpenBSD ist, editiere <tt>/etc/hostname.xl0</tt>
(wenn deine Hauptethernetkarte xl0 ist. Deine kann ep0 oder fxp0 oder 
irgendeine andere sein!). 
Alles, was du in dieser Datei zu schreiben hast, ist '<tt>dhcp</tt>'.

<pre>
# <b>echo dhcp &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
Dies wird OpenBSD veranlassen, den DHCP Client automatisch beim Booten zu 
starten.  OpenBSD wird sich seine IP Adresse, sein Standardgateway und seine 
DNS Server vom DHCP Server besorgen.  

<p>
Wenn du den DHCP Client von der Befehlszeile aus starten willst, stelle sicher, 
dass <tt>/etc/dhclient.conf</tt> existiert, dann versuche:

<pre>
# <strong>dhclient fxp0</strong>
</pre>

<p>
Wobei ,<tt>fxp0</tt>' die Netzwerkkarte ist, auf der du dhcp empfangen willst.

<p>
Wie du auch immer dhclient startest, kannst du die <tt>/etc/dhclient.conf</tt>
Datei immer so editieren, dass dein DNS <b>nicht</b> erneuert wird aufgrund 
der neuen DNS Informationen, indem du die 'request' Zeilen auskommentierst 
(Es gibt Beispiele in den Standardeinstellungen, aber du musst die 
Standardeinstellungen von dhclient überschreiben). 

<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>

<p>
und dann <b>entferne</b> domain-name-servers.  Natürlich kannst du auch 
hostname oder andere Einstellungen entfernen.

<p>
<h3>6.4.2 DHCP Server</h3>

<p>
Wenn du OpenBSD als DHCP Server 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&sektion=8">dhcpd(8)</a>
einsetzen willst, editiere <tt>/etc/rc.conf.local</tt> so, dass
sie die Zeile <tt>dhcpd_flags=""</tt> beinhaltet.
Und die Netzwerkkarten, auf denen dhcpd(8) <b>lauschen</b> soll, stehen in
<tt>/etc/dhcpd.interfaces</tt>.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
Dann editiere <tt>/etc/dhcpd.conf</tt>.
Die Optionen sind selbsterklärend.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Dies teilt deinen DHCP Clients mit, dass die an DNS Anfragen 
anzuhängende Domäne example.com ist (d.h., wenn der Benutzer
'telnet joe' schreibt, dann wird an joe.example.com gesendet). Es wird auf
die DNS Server 192.168.1.3 und 192.168.1.5 verwiesen. Für Hosts, die
sich im selben Netzwerk wie die Netzwerkkarte des OpenBSD Rechners befinden,
welche im 192.168.1.0/24 Adressbereich liegt, wird der DHCP Server ihnen eine
IP Adresse zwischen 192.168.1.32 und 192.168.1.127 und als Standardgateway
192.168.1.1 zuweisen.

<p>
Wenn du den dhcpd(8) von der Befehlszeile aus starten willst, nachdem du
<tt>/etc/dhcpd.conf</tt> editiert hast, versuche:

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd fxp0</b>
</pre>

<p>
Die <tt>touch</tt> Zeile ist notwendig, um eine leere <tt>dhcpd.leases</tt>
Datei zu erzeugen, bevor dhcpd(8) starten kann.
Die OpenBSD <a href="../faq10.html#rc">Startup Skripte</a> erstellen diese
Datei beim Hochfahren, wenn es notwendig ist, aber wenn du dhcpd(8)
manuell startest, musst du sie zuerst erstellen.

<p>
Wenn du DHCP Dienste für einen Windows Rechner bereitstellst, dann willst 
du vielleicht auch eine 'WINS' Serveradresse liefern.
Dafür füge einfach die folgenden Zeilen zu deiner /etc/dhcpd.conf:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(wobei <tt>192.168.92.55</tt> die IP deines Windows oder Samba Servers ist.)
Siehe auch 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a>
für weitere Optionen, die 
deine DHCP Clients wünschen.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP</h2>

<p>
Das Point-to-Point Protokoll wird verwendet, um eine Verbindung zu deinem ISP
mit deinem Einwahl-Modem herzustellen. OpenBSD bietet dafür 2 Möglichkeiten:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8">pppd(8)</a>
- der Kernel PPP Daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
- der Userland PPP Daemon. 
</ul>

<p>
Sowohl ppp als auch pppd führen zwar die gleichen Funktionen auf, dieses
jedoch auf unterschiedliche Wege. pppd arbeitet mit dem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp(4)</a>-Treiber
des Kernels, während ppp mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun(4)</a>
im Userland arbeitet.
Dieses Dokument wird sich nur mit dem PPP-Daemon des Userlands beschäftigen,
da es mit ihm einfacher ist, Fehlfunktionen zu korrigieren sowie mit ihm zu
interagieren. Um zu beginnen, benötigen wir einige einfache Informationen
über deinen ISP. Hier eine Liste hilfreicher Informationen, die du brauchen
wirst.

<ul>
<li>Die Einwahlnummer deines ISPs
<li>Deinen Nameserver 
<li>Deinen Benutzernamen und dein Passwort
<li>Dein Gateway
</ul>

<p>
Einige von diesen benötigst du nicht unbedingt, aber sie wären
beim Aufsetzen des ppp hilfreich. Der Userland PPP Daemon benutzt die Datei 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
als seine Konfigurationsdatei. Es gibt viele hilfreiche Dateien in
<i>/etc/ppp</i>, die verschiedene Einstellungen für verschiedene
Situationen zeigen. Du solltest dir dieses Verzeichnis ansehen und es
durchforsten.

<p>
<h3>Erste Einstellungen - für PPP(8)</h3>

<p>
Die ersten Einstellungen für den Userland PPP Daemon bestehen im
Erstellen deiner <i>/etc/ppp/ppp.conf</i> Datei. Diese Datei existiert nicht 
standardmäßig, aber du kannst einfach
<i>/etc/ppp/ppp.conf.sample</i> editieren, um deine eigene <i>ppp.conf</i>
Datei zu erstellen. Hier werde ich mit den einfachsten und gebräuchlichsten
Einstellungen beginnen. Hier eine kurze <i>ppp.conf</i> Datei, die einfach
einige Standardwerte setzt:

<blockquote>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</blockquote>

<p>
Der Absatz unter der <tt>default:</tt> Bezeichnung wird jedes Mal
ausgeführt. Hier stehen alle wichtigen Informationen. Mit &quot;set
log&quot; stellen wir unsere Loglevel ein. Um dies zu ändern, siehe 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
für weitere Info. Unsere Schnittstelle wird mit
&quot;set device&quot; eingestellt. Dies ist die Schnittstelle, mit der das 
Modem verbunden ist. In diesem Beispiel hängt das Modem auf COM Port 2.
Daher wird COM Port 1 auf <i>/dev/cua00</i> gesetzt. Mit &quot;set speed&quot;
setzen wir die Geschwindigkeit unserer Einwahl-Verbindung und mit &quot;set
dail&quot; setzen wir unsere Dialup Parameter, mit denen wir den Timeout,
usw. setzen können. Diese Zeile sollte eigentlich ziemlich genau so bleiben,
wie sie jetzt ist.

<p>
Nun können wir die spezifischen Informationen von unserem ISP eintragen.
Wir tun dies, indem wir unter <b>default:</b> einen weiteren Absatz
hinzufügen. Dieser kann benannt werden, wie du willst - am einfachsten
nimmst du den Namen deines ISP. Hier werde ich <b>myisp:</b> als Verweis
auf unseren ISP nehmen. Hier ist ein einfaches Beispiel, das alles
beinhaltet, um uns zu verbinden:

<blockquote>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
Hier stehen alle wichtigen Informationen für unseren spezifischen ISP.
Die erste Option &quot;set phone&quot; setzt die Einwahlnummer deines ISPs.
&quot;set login&quot; setzt unsere login-Optionen. Hier haben wir den Timeout
auf 5 gesetzt, was bedeutet, dass wir unseren login-Versuch nach 5 Sekunden
abbrechen, wenn wir kein Trägersignal bekommen. Ansonsten wird er auf
&quot;login:&quot; warten und dann deinen Benutzernamen und dein Passwort
senden.

<p>
In diesem Beispiel ist unser Benutzername = ppp 
und das Passwort = ppp. Diese Werte müssen geändert werden. Die
Zeile &quot;set timeout&quot; setzt den Idle Timeout für die gesamte
Verbindungsdauer auf 120 Sekunden. Die &quot;set ifaddr&quot; Zeile ist ein
bisschen schwieriger. Hier ist eine genauere Erklärung.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
Die obige Zeile folgt dem Format von 
&quot;<b>set ifaddr [meineAdr[/nn] [seineAdr[/nn] [netzmaske
[startAdr]]]]</b>&quot;. Daher ist die erste spezifizierte IP diejenige,
die wir als unsere IP wollen. Wenn du eine statische IP Adresse hast, dann
kannst du sie hier einsetzen. In unserem Beispiel benutzen wir /0, was besagt,
dass keine Bits von dieser IP Adresse übereinstimmen müssen und der gesamte
Ausdruck ersetzt werden kann. Die zweite IP behandelt die von uns erwartete
IP unserer Gegenstelle. Wenn du sie weißt, dann kannst du sie hier 
angeben. Wiederum wissen wir nicht in unserer Zeile, welche IP dies wird, also
lassen wir sie uns wieder mitteilen. Die dritte Option ist unsere Netzmaske,
hier auf 255.255.255.0 gesetzt. Wenn startAdr spezifiziert ist, dann wird
diese anstelle von meineAdr während der initialen IPCP Verhandlung; aber
es wird nur eine Adresse aus dem meineAdr-Adressbereich akzeptiert. Dies ist
nützlich, wenn Verhandlungen mit einigen PPP Implementierungen durchgeführt
werden, die keine IP Nummer vergeben, es sei denn, ihr Peer fordert
``0.0.0.0'' an.

<p>
Die nächste Option &quot;add default HISADDR&quot; setzt unsere
Standardroute zu deren IP. Dies ist ,klebrig', d.h., falls deren IP sich
ändern sollte, dann wird unsere Route auch automatisch upgedatet. Mit
&quot;enable dns&quit; teilen wir unserem ISP mit, unsere Nameserveradresse
zu authentifizieren. Tu dies NICHT, wenn du deinen eigenen lokalen DNS
laufen hast, da PPP dies umgehen wird, indem es einige Zeilen in
<i>/etc/resolv.conf</i> schreibt.

<p>
Gegenüber den herkömmlichen Login-Methoden, verwenden viele IPS nun
entweder CHAP- oder PAP-Authentifizierung. Wenn das der Fall ist, wird
unsere Konfiguration etwas anders aussehen:

<blockquote>
<pre>
myisp:
set phone 1234567   
set authname ppp
set authkey ppp
set login
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
In dem oben genannten Beispiel geben wir unseren Benutzernamen (ppp) und
das Passwort (ppp) unter jeweiliger Verwendung von authname und authkey an.
Es ist nicht notwendig, anzugeben, ob CHAP- oder PAP-Authentifizierung
genutzt wird - es wird automatisch ermittelt. "set login" gibt lediglich
an, dass versucht wird, sich mit dem zuvor genannten Benutzernamen und
dem Passwort anzumelden.

<p>
<h3>PPP(8) verwenden</h3>

<p>
Nun, da wir unsere <i>ppp.conf</i> Datei fertig eingerichtet haben,
können wir beginnen, eine Verbindung zu unserem ISP aufzubauen. Hier
einige Details über häufig verwendete Parameter mit ppp:

<ul>
<li><tt>ppp -auto myisp</tt> - Startet PPP, konfiguriert deine
Schnittstellen und wird dich mit deinem ISP verbinden und dann in den
Hintergrund verschwinden.
<li><tt>ppp -ddial myisp</tt> - Ähnlich wie -auto, aber wenn deine
Verbindung abbricht, wird PPP versuchen, sich erneut zu verbinden.
</ul>

<p>
Mit dem Aufruf von <i>/usr/sbin/ppp</i> ohne Optionen kommst du in den
interaktiven Modus. Hier kannst du direkt mit dem Modem interagieren; das
eignet sich hervorragend, um Probleme in deiner <i>ppp.conf</i> Datei zu
debuggen.
Wenn das oben genannte fehlschlägt, versuche, <i>/usr/sbin/ppp</i> ohne
Optionen aufzurufen - somit wird ppp im interaktiven Modus gestartet.
Die Optionen können einzeln angegeben werden, um nach Fehlern oder anderen
Problemen zu suchen. Unter Verwendung der zuvor genannten Einstellungen,
wird ppp in /var/log/ppp.log schreiben. Diese Log enthält, wie die
Manual-Seite, hilfreiche Informationen.

<p>
<h3>ppp(8)-Extras</h3>

<p>
In einigen Situationen möchstest du Befehle ausführen, wenn die 
Verbindung gerade errichtet oder beendet wurde. Für diese Fälle
gibt es zwei Dateien, die du erstellen kannst: <i>/etc/ppp/ppp.linkup</i> und
<i>/etc/ppp/ppp.linkdown</i>.
Beispielkonfigurationen kannst du hier finden:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
<h3>ppp(8)-Varianten</h3>

<p>
Viele ISPs bieten nun xDSL-Dienste an, welche schneller als die
herkömmlichen Einwähl-Methoden sind. Dies beinhaltet Varianten wie
zum Beispiel ADSL und SDSL. Obwohl kein physikalisches Einwählen
stattfindet, basiert die Verbindung weiterhin auf dem
Point-to-Point-Protokoll. Beispiele beinhalten:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
Das ,Point to Point Protocol over Ethernet' (PPPoE) ist eine Methode,
um PPP-Pakete in Ethernet-Frames zu versenden.
Das ,Point to Point Protocol over ATM' (PPPoA) läuft typischerweise
in ATM-Netzwerken, wie sie in UK oder Belgien gefunden werden können.

<p>
Typischerweise bedeutet das, dass du eine Verbindung mit deinem ISP
über eine normale Ethernetkarte und Ethernet-basierendes DSL-Modem
herstellen kannst (im Gegensatzu zu einem Nur-USB-Modem).

<p>
Wenn du ein Modem hast, das PPPoE/PPPoA versteht, ist es möglich,
das Modem so zu konfigurieren, dass es selbst die Verbindung aufbaut.
Wenn das Modem einen ,bridge'-Modus hat, ist es alternativ möglich,
dies zu aktivieren und so das Modem die Pakete einfach zu einer Maschine
,durchleiten zu lassen', welche PPPoE-Software einsetzt (siehe unten).

<p>
Das Haupt-Softwareinterface für PPPoE/PPPoA unter OpenBSD ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8">pppoe(8)</a>,
welches die Userland-Implementierung ist (auf fast die gleiche Art und
Weise, wie wir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
weiter oben beschrieben haben).
Eine Kernel-PPPoE-Implementierung,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">pppoe(4)</a>,
wurde in OpenBSD -current eingebunden; jedoch wird diese für
Nicht-current-Benutzer nicht bis OpenBSD 3.7 verfügbar sein.
<!-- XXXrelease -->

<p>
<h3>PPTP</h3>

<p>
Das ,Point to Point Tunneling Protocol' (PPTP) ist eine proprietäres
Microsoft-Protokoll.
Ein pptp-Client ist verfügbar, welcher mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
kommuniziert und ist in der Lage, sich zu PPTP-basierenden
Virtuellen Privaten Netzwerken (VPN) zu verbindungen, die von einigen
Kabel- und xDSL-Anbietern verwendet werden.
pptp selbst muss von den <a href="../faq8.html#Ports">Ports</a> oder
<a href="faq8.html#Packages">Packages</a> aus installiert werden.
Weitere Anleitungen, wie man pptp einrichtet und verwendet, befinden
sich in der Manualseite, welche mit dem pptp-Package installiert wird.

<p>
<a name= "Tuning"></a>
<h2>6.6 - Netzwerkparameter tunen</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - Wie kann ich meinen Kernel optimieren, so dass er eine
größe Anzahl an Neuversuchen und längeren timeouts für
TCP Sitzungen hat?</h3>

<p>
Normalerweise möchtest du das tun, um Routing zuzulassen oder wegen
Verbindungsproblemen. Natürlich müssen beide Seiten der
Verbindung ähnliche Werte verwenden, damit es am effektivsten ist.

<p>
Um dies zu tunen, verwende <tt>sysctl</tt> und erhöhe die Werte von:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Mittels sysctl -a kannst du die derzeitigen Werte dieser (und vieler
anderer) Parameter sehen. Um einen Wert zu verändern, verwende etwas
wie <tt>sysctl net.inet.tcp.keepidle=28800</tt>.  

<p>
<h3>6.6.2 - Wie kann ich ,directed broadcasts' aktivieren?</h3>

<p>
Normalerweise willst du dies nicht tun.  Dies erlaubt jemandem, Datenverkehr
zu der broadcast Adresse deines verbundenen Netzwerkes zu schicken, wenn du
deinen OpenBSD Rechner als Router verwendest.

<p>
Aber manchmal kann dies, in geschlossenen Netzwerken, nützlich sein,
vor allem wenn man ältere Implementierungen des NetBIOS Protokolles
verwendet.
Wiederum mit sysctl.
<tt>sysctl net.inet.ip.directed-broadcast=1</tt> aktiviert dies.
Beachte aber <a href="http://www.netscan.org">Smurfangriffe</a>, 
wenn du wissen willst, warum dies standardmäßig nicht aktiviert ist.

<p>
<h3>6.6.3 - Der Kernel soll bestimmte Ports nicht dynamisch allozieren</h3>

<p>
Auch dafür gibt es einen eigenen sysctl Befehl.  Siehe 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:

<pre>
Setze die Liste der reservierten TCP Ports, die nicht dynamisch vom
Kernel vergeben werden sollen. Das kann man benutzen, um Daemons davon
abzuhalten, einen speziellen Port zu benutzen, den ein anderes Programm
braucht, damit es funktionieren kann. Listen-Elemente können
mit Kommata und/oder Leerzeichen getrennt werden.

#  <strong>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

Es ist ebenso möglich, Ports aus der aktuellen Liste hinzuzufügen 
oder zu entfernen.

 #  <strong>sysctl net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl net.inet.tcp.baddynamic=-871</strong>
</pre>


<p>
<a name="NFS"></a>
<h2>6.7 - Einfache NFS Anleitung</h2>

<p>NFS, oder Network File System (Netzwerkdateisystem), wird verwendet, um 
ein Dateisystem über das Netzwerk zu verwenden. Du solltest vorher noch 
folgende Manual Seiten lesen, bevor du versuchst, einen eigenen NFS Server 
aufzusetzen:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
</ul>

<p>
Dieses Kapitel zeigt die Schritte, um ein einfaches NFS System aufzusetzen: 
Einen Server im LAN und Clients im LAN, die NFS verwenden. Es behandelt nicht, 
wie man NFS sicher macht. Wir nehmen an, dass du bereits Paketfilterung 
oder irgendeinen anderen Firewallschutz eingerichtet hast, damit von 
außerhalb nicht auf NFS zugegriffen werden kann.
Wenn du Zugriff via NFS von außerhalb erlauben willst und sensible Daten 
dort gespeichert hast, dann empfehlen wir dir wärmstens den Gebrauch von 
IPsec.  Ansonsten können andere Leute 
möglicherweise deinen NFS Datenverkehr sehen. Jemand könnte auch 
vortäuschen, die IP Adresse zu haben, der du Zugriff auf den NFS Server 
zulässt. Es gibt mehrere Angriffe, die möglich sind. Wenn IPsec 
richtig konfiguriert ist, dann schützt es gegen die Art von Angriffen. 

<p>
Noch eine wichtige Anmerkung wegen Sicherheit. Füge niemals ein 
Dateisystem zu /etc/exports ohne eine Liste mit Rechnern, die explizit
Zugriff haben sollen. Ohne einer solchen Liste, die ein bestimmtes Verzeichnis 
mounten können, kann jeder, der den Rechner erreichen kann, deine NFS 
exports mounten.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
muss laufen, damit NFS funktionieren kann. Portmap(8) ist ab OpenBSD 3.2 
standardmäßig abgeschaltet, so dass du die Zeile

<blockquote><pre>
portmap=YES
</pre></blockquote>

in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a>
einfügen und neustarten musst.

<p>
Der Server hat die IP <b>10.0.0.1</b>. Dieser Server soll nur NFS für 
Rechner innerhalb dieses Netzwerkes bereitstellen. Der erste Schritt ist 
deine <i>/etc/exports</i> Datei zu erstellen. Diese Datei listet die 
Dateisysteme auf, die du über NFS freigeben willst, und definiert, wer 
auf sie zugreifen darf. Es gibt viele Optionen, die du in deiner 
<i>/etc/exports</i> Datei haben kannst, und am besten ist, du liest die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
Manual Seite. Für dieses Beispiel sieht <i>/etc/exports</i> so aus:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
D.h., dass das lokale Dateisystem <b>/work</b> via NFS zugänglich 
gemacht wird. <b>-alldirs</b> bedeutet, dass Clients jedes Verzeichnis 
unter dem <b>/work</b> Mount Point mounten können. <b>-ro</b> bedeutet,  
dass nur Leseberechtigung gestattet wird. Die letzten zwei Argumente 
bedeuten, dass nur Clients innerhalb des 10.0.0.0 Netzwerkes mit einer 
Netzmaske von 255.255.255.0 dieses Dateisystem mounten dürfen. Dies ist 
wichtig für einige Server, die von verschiedenen Netzwerken 
zugänglich sind.

<p>
Ist einmal deine <i>/etc/exports</i> Datei eingerichtet, kannst du 
weitergehen und deinen NFS Server aufsetzen. Du solltest zuerst sicherstellen, 
dass deine Kernelkonfiguration die Optionen NFSSERVER &amp; NFSCLIENT 
enthält. (Der GENERIC Kernel beinhaltet diese Optionen.) Dann 
solltest du die Zeile <strong>nfs_server=YES</strong> in
<i>/etc/rc.conf.local</i> einfügen. 
Dies wird sowohl nfsd(8) und mountd(8) starten, wenn du rebootest.
Nun kannst du fortschreiten und die Dienste selber starten. Diese Dienste 
müssen als root gestartet werden und du musst sicherstellen,
dass portmap(8) auf deinem System läuft. Hier ein Beispiel von 
nfsd(8), der sowohl mit TCP als auch mit UDP bedient mittels 4 Diensten. 
Du solltest eine angemessenene Anzahl an NFS Serverdiensten einsetzen, um 
die maximale Anzahl von gleichzeitigen Clientanfragen, die du bedienen 
willst, zu bewerkstelligen.

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Du musst nicht nur den nfsd(8) Server starten, sondern auch mountd(8). 
Dies ist der Dienst, der eigentlich die Mountanfragen auf NFS bedient. Um 
mountd(8) zu starten stelle sicher, dass eine leere mountdtab Datei
existiert und starte den Daemon:

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<p>
Wenn du Änderungen an /etc/exports durchführst, während 
NFS bereits läuft, musst du mountd dies mitteilen, indem du den 
Dienst neustartest!

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<p>
<h3>NFS Status überprüfen</h3>

<p>
Um zu überprüfen, ob alle Dienste laufen und bei RPC registriert 
sind, verwende rpcinfo(8). 

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Für den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen 
du den Status von NFS überprüfen kannst. Eines ist 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8">showmount(8)</a>
das dir anzeigt, was und wer gerade mountet. Dann gibt es auch noch nfsstat(8),
das genauere Statistiken anzeigt. Für showmount(8), versuche 
<tt>/usr/bin/showmount -a host</tt>. Zum Beispiel:

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>NFS Dateisysteme mounten</h3>

<p>
NFS Dateisysteme sollten mittels mount(8) geladen werden, oder genauer
gesagt,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8">mount_nfs(8)</a>.
Um ein Dateisystem /work von Host 10.0.0.1 auf dem lokalen Dateisystem /mnt 
zu laden, tue folgendes (bedenke, dass du nicht IP Adressen verwenden musst,
mount wird Hostnamen auflösen):

<blockquote><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
Damit dein System dies beim Hochfahren wieder tut, füge folgendes
deiner <i>/etc/fstab</i> hinzu:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
Es ist wichtig, dass du <tt>0 0</tt> am Ende dieser Zeile verwendest, 
damit dein Rechner nicht versucht, das NFS Dateisystem beim Hochfahren mit 
fsck zu überprüfen!!!! Die anderen Sicherheitsoptionen wie noexec, 
nodev und nosuid, sollten auch immer - wenn anwendbar - verwendet werden. 
Wie zum Beispiel:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
Mit diesen Optionen können keine Geräte oder setuid Programme auf 
dem NFS Server Sicherheitsmaßnahmen auf dem NFS Client untergraben. 
Wenn du keine Programme auf diesem NFS Dateisystem auf dem NFS Client 
ausführen willst, füge noexec hinzu:


<a name="Bridge"></a>
<h2>6.9 - Aufsetzen einer Bridge mit OpenBSD</h2>

<p>
Eine <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">Bridge</a>
ist ein Link zwischen zwei oder mehr separaten Netzwerken. Anders als 
ein Router reisen Pakete durch die Bridge "unsichtbar" -- logisch 
erscheinen die beiden Netzwerksegmente als eines für Rechner auf 
beiden Seiten der Bridge. Die Bridge wird nur Pakete weiterleiten, die 
auch von einem Segment in das andere müssen, sie bieten also
auch einen einfachen Weg den Verkehr in einem komplexen Netzwerk zu 
reduzieren und erlauben trotzdem den Zugriff jedes Rechners zu jedem
anderen, falls nötig.

<p>
Denk daran, dass aufgrund dieser "unsichtbaren" Natur ein Interface in 
einer Bridge eine IP-Adresse haben kann, aber nicht muss. Wenn sie eine
hat, hat die Karte effektiv zwei Betriebsmodi, nämlich eine
als Teil der Bridge, die andere als normale, stand-alone Netzwerk-Karte.
Wenn keine der Karten eine IP-Adresse hat, wird die Bridge einfach
Netz-Daten verschieben, aber nicht extern administrierbar 
oder wartbar sein (was auch ein Feature sein kann).

<p>
<h3>Ein Beispiel einer Bridge Anwendung</h3>

<p>
Eines meiner Computer Racks hat eine Anzahl alter Systeme, von denen keines
eine eingebaute 10BASE-TX Netzwerkkarte hat. Während sie alle einen 
AUI oder AAUI Stecker haben, sind die Transceiver auf Koax beschränkt.
Eine der Maschinen in diesem Rack ist ein OpenBSD-basierender 
Terminal-Server, der dauerhaft eingeschaltet und auch immer mit einem
High-Speed-Netzwerk verbunden ist. Das Hinzufügen einer zweiten 
Netzwerkkarte mit einem Koax-Port erlaubt mir, diese Maschine als Bridge 
zum Koax-Netzwerk zu benutzen.

<p>
Dieses System hat jetzt zwei Netzwerkkarten (NICs), eine Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
und eine 3c590-Combo Karte 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
für den Koax-Port. <tt>fxp0</tt> ist der Link in mein restliches 
Netzwerk und wird daher eine IP-Adresse haben, <tt>ep0</tt> macht nur
Bridging und hat daher keine.
Maschinen, die an das Koax-Segment angeschlossen sind, sollen genauso
kommunizieren, als wenn sie im Rest meines Netzwerkes wären.
Wie also bewerkstelligen wir das?

<p>
Die Datei <tt>hostname.fxp0</tt> enthält die Konfigurationsdaten 
für die <tt>fxp0</tt> Karte.  Diese Maschine soll DHCP machen,
also sieht die Datei etwa so aus:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

<p>
Noch keinerlei Überraschungen.

<p>
Die <tt>ep0</tt> Karte ist ein wenig anders, wie du dir denken kannst:

<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

<p>
Hier sagen wir dem System, es möge das Interface mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
aktivieren und auf 10BASE-2 (Koax) setzen. Keine IP Addresse oder ähnliche 
Information muss für dieses Interface spezifiziert werden. Die 
Optionen, die von der <tt>ep</tt> Karte akzeptiert werden, sind
detailliert in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">Manual
Seite</a> aufgeführt.

<p>
Jetzt müsen wir die Bridge aufsetzen. Bridges werden durch die Existenz
einer Datei namens
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
initialisiert. Hier ist zum Beispiel eine Datei für meine Situation:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

<p>
Das sagt aus, es soll eine Bridge aus zwei NICs aufgesetzt und aktiviert 
werden, fxp0 und ep0.
Es ist egal, in welcher Reihenfolge die Karten aufgeführt werden.
Denke daran, die Bridge ist symmetrisch -- Pakete fließen ja in beide
Richtungen.

<p>
Das war es!  Reboote, und du wirst eine funktionierende Bridge haben.

<p>
<h3>Filtern auf der Bridge</h3>

Während es sicher auch eine Menge Anwendungen für eine 
solch einfache Bridge gibt, ist es doch wahrscheinlich, dass du
etwas mit den ganzen Paketen TUN willst, während sie durch deine Bridge
laufen. Wie zu erwarten, kann man
<a href="#PF">Packet Filter</a> dazu benutzen, den Traffic einzuschränken,
der durch deine Bridge fließt.

<p>
Denke daran, dass wegen der Natur der Bridge die gleichen Daten
über beide Interfaces fließen, aber du nur auf einem Interface 
filtern brauchst. Deine "Pass all" Statements würden dann
wie folgt aussehen:

<blockquote>
<pre>
pass in  on ep0  any
pass out on ep0  any
pass in  on fxp0 any
pass out on fxp0 any
</pre>
</blockquote>

<p>
Sagen wir nun, ich wollte den Traffic filtern, der auf diese alten Maschinen
trifft. Ich möchte, dass nur Web- und SSH-Verkehr zu ihnen durchkommt.
In diesem Fall lassen wir jeglichen Verkehr nach draußen zu, filtern aber
auf dem fxp0 Interface, indem wir ,keep state' für die Antwort-Daten
benutzen:

<blockquote>
<pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

<p>
Denke daran, dass dieses Regelwerk jeglichen Netzwerk-Verkehr
mit Ausnahme von hereinkommendem HTTP- und SSH-Verkehr zur Bridge selbst und
den Maschinen "dahinter" verhindert. Andere Resultate werden erzielt,
wenn man auf dem anderen Interface filtert.

<p>
Um die Bridge zu überwachen und zu kontrollieren, benutze das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&sektion=8">brconfig(8)</a>
Kommando, mit dem man eine Bridge auch nach dem Booten erzeugen kann.

<p>
<h3>Tipps zum Bridging</h3>

<ul>
<li>Es wird WÄRMSTENS empfohlen, nur auf einem Interface zu filtern.
Wenn es auch möglich ist, auf beiden zu filtern, muss man das vorher 
jedoch sehr gut verstanden haben.

<li>Durch die Benutzung der <i>blocknonip</i> Option von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&sektion=8">brconfig(8)</a>
oder in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&sektion=5">bridgename.bridge0</a>
kannst du jeglichen nicht-IP Traffic (wie etwa IPX oder NETBEUI) davon 
abhalten, sich um deine Filter herumzustehlen. Das kann in einigen Situationen
sehr wichtig sein, aber du solltest wissen, dass Bridges für jeglichen
Traffic funktionieren, nicht nur für IP.

<li>Für Bridging müssen die NICs im "Promiscuous mode" sein -- sie
lauschen einfach am GESAMTEN Netzwerk-Verkehr, nicht nur an dem, der
an das Interface gerichtet ist. Das hat einen höheren Load für 
CPU und Bus zur Folge, als man denkt. Einige NICs funktionieren leider
nicht sauber in diesem Modus, der TI ThunderLAN Chip
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&sektion=4">tl(4)</a>)
ist leider so ein Beispiel, der nicht als Teil einer Bridge funktioniert.
</ul>

<a name="PXE"></a>
<h2>6.10 - Wie boote ich mit PXE? (i386, amd64)</h2>
Das ,Preboot Execution Environment', oder PXE, ist ein Weg, um einen
Computer aus dem Netzwerk heraus zu booten, statt von Festplatte, Diskette
oder CD-ROM. Diese Technologie wurde zuerst von Intel entwickelt,
doch wird nun von den meisten führenden Netzwerkkarten- und
Computer-Herstellern unterstützt. Bedenke, dass es viele verschiedene
Netzwerkboot Protokolle gibt, PXE ist relativ neu.
Traditionellerweise wird das PXE Booting unter Verwendung von ROMs auf
dem NIC oder dem Mainboard ausgeführt, doch sind ebenfalls Boot Floppies
von etlichen Quellen verfügbar, die ebenfalls das PXE Booting zulassen.
Viele ROMs auf älteren NICs unterstützen zwar das Booten vom
Netzwerk aus, allerdings NICHT PXE; OpenBSD/i386 oder am64 können
mit diesen zur Zeit nicht über das Netzwerk gebootet werden.



<p>
<h3>Wie funktioniert das PXE Booting?</h3>
Zuallerst ist es klug zu verstehen, wie der
<a href="faq14.html#Boot386">OpenBSD Bootprozess</a> auf i386 und
am64 Plattformen funktioniert.
Auf den Bootprozess folgend, sendet die PXE-fähige NIC einen DHCP
Request über das Netzwerk.
Der DHCP Server wird dem Adapter eine IP zuweisen und gibt ihm den Namen
einer Datei, die von einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1">tftp(1)</a>
Server bezogen und ausgeführt werden muss.
Diese Datei leitet dann den Rest des Bootprozesses ein.
Für OpenBSD ist es die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386">pxeboot</a>
Datei, die den Platz der standardmäßigen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
Datei einnimmt.
pxeboot(8) ist dann in der Lage, einen Kernel (wie zum Beispiel <tt>bsd</tt>
oder <a href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a> vom gleichen tftp(1)
Server zu laden und auszuführen.

<h3>Wie mache ich das?</h3>
Der erste und offensichtlichste Schritt ist, dass du einen
PXE-bootfähigen Computer oder Netzwerkadapter haben musst. Einige
Dokumente weisen darauf hin, dass alle modernen NICs und Computer PXE
Ünterstützung hätten, aber das ist einfach nicht wahr --
viele Niedrigpreis Systeme liefern keine PXE ROMs mit oder verwenden
ein älteres Netzwerkboot Protokoll.
Du brauchst außerdem einen ordentlich konfigurierten
<a href="#DHCP">DHCP</a> und TFTP Server.

<p>
Davon ausgehend, dass eine OpenBSD Maschine die Quelle der Bootdateien
ist, muss die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5">dhcpd.conf</a>
Datei des DHCP Servers folgende Zeile beinhalten:
<pre>
    filename "pxeboot";
</pre>
damit der DHCP Server diese Datei dem bootenden Arbeitsplatz anbietet.
Zum Beispiel:

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
Du musst außerdem den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8">tftpd(8)</a>
Daemon aktivieren. Dies wird normalerweise durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a> realisiert.
Die standardmäßige OpenBSD Installation hat eine Beispielzeile in
<tt>inetd.conf</tt>, die wunderbar für dich funktionieren wird:
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

von der lediglich das ,#' Zeichen entfernt werden muss und sende inetd(8)
ein -HUP Signal, um mitzuteilen, dass <tt>/etc/inetd.conf</tt> neu
geladen werden soll.
tftpd(8) bietet die Dateien von einem bestimmten Verzeichnis an, in dem
Fall von dieser Zeile ist es das <tt>/tftpboot</tt> Verzeichnis, welches
wir für dieses Beispiel verwenden werden.
Offensichtlich ist, dass dieses Verzeichnis angelegt und eingerichtet
werden muss. Typischerweise wirst du hier nur ein paar Dateien für das
PXE Booting haben:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, der PXE Bootloader (der die gleichen Funktionen bereitstellt
wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot</a> auf einem Platten-basierten System).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, der Installationskernel oder
<tt>bsd</tt>, ein angepasster Kernel.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
>/etc/boot.conf</a>, eine Boot Konfigurationsdatei.
</ul>

Denke daran, dass <tt>/etc/boot.conf</tt> nur gebraucht wird, wenn der Kernel,
den du booten möchtest, nicht <tt>bsd</tt> heißt oder andere
pxeboot Standardwerte nicht so sind, wie du sie haben möchtest
(zum Beispiel, wenn du eine serielle Konsole wünschst).
Du kannst deinen tftpd(8) Server mit einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a> Client testen, indem du sicherstellst, dass du die
benötigten Dateien herunterladen kannst.

<p>
Wenn deine DHCP und TFTP Server laufen, bist du bereit, es auszuprobieren.
Du wirst PXE boot auf deinem System oder auf der Netzwerkkarte aktivieren
müssen; konsultiere deine Systemdokumentation.
Wenn du es gesetzt hast, solltest du etwas sehen, das diesem ähnlich
ist:

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 1.00
    boot>
</pre>

Zu diesem Zeitpunkt hast du den normalen OpenBSD Bootprompt.
Wenn du hier einfach "<tt>bsd.rd</tt>" eintippst, wirst du die Datei
<tt>bsd.rd</tt> von dem TFTP Server laden.

<pre>
    >> OpenBSD/i386 PXEBOOT 1.00
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2004 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

    OpenBSD 3.6 (RAMDISK_CD) #378: Fri Sep 17 13:04:04 MDT 2004
      ...
</pre>
 
Der <a href="faq4.html#bsd.rd">bsd.rd Installationskernel</a> wird nun booten.

<p>

<h3>Kann ich andere Kerneltypen mit PXE booten, außer
<tt>bsd.rd</tt>?</h3>

Ja, obwohl mit den Programmen, die zur Zeit in OpenBSD 3.6 enthalten sind,
PXE Booting primär zum Installieren des OS gedacht ist.

<a name="CARP"></a>
<h2>6.11 - Das Common Address Redundancy Protokoll (CARP)</h2>
<h3>6.11.1 - Was ist CARP und wie funktioniert es?</h3>
<!-- This article written by Sunny Raspet, slr@mordac.info, and
released under the BSD license -->

<p>
CARP ist ein Werkzeug um beim Erreichen von System Redundanz zu helfen, indem
mehrere Computer ein einzelnes, virtuelles Netzwerk Interface zwischen sich
errichten, so dass, falls irgendein System ausfällt, ein anderes
antworten kann, und/oder einen gewissen Grad an Load Sharing zwischen Systemen
erlaubt.
CARP ist eine Verbesserung vom Virtual Router Redundancy Protokoll (VRRP)
Standard.
Es wurde entwickelt, nachdem VRRP als nicht frei genug wegen einem
möglicherweise-überlappendem Cisco Patent angesehen wurde.
Für weitere Informationen über CARPs Ursprünge und den
rechtlichen Problemen um VRRP, besuche bitte
<a href="../../lyrics.html#35">diese Seite</a>.

<p>
Um gesetzliche Konflikte zu umgehen, entwarf Ryan McBride (mit Hilfe von
Michael Shalayeff, Marco Pfatschbacher und Markus Friedl) CARP so, dass es
fundamental anders war.
Die Einbindung von Kryptographie ist eine der prominentesten Änderungen,
aber weiterhin nur eine von vielen.

<p>
Wie es funktioniert: CARP ist ein Multicast Protokoll.
Es gruppiert mehrere physikalische Computer unter einer oder mehrerer
virtuellen Adressen zusammen.
Von diesen ist ein System der Master und antwortet auf alle Pakete, die
für diese Gruppe bestimmt sind, während die anderen Systeme
als ,hot spares' agieren.
Unbedeutend wie die IP und MAC Adressen des lokalen Interfaces sind, werden
Pakete, die zum CARP Interface gesendet worden sind, mit CARP Informationen
zurückgesendet.

<p>
Zu konfigurierbaren Intervallen bekündet der Master seine Operation auf
der IP Protokoll Nummer 112.
Wenn der Master offline geht, beginnen die anderen Systeme in der CARP Gruppe
mit dem bekünden.
Der Host, der in der Lage ist am häufigsten zu bekünden, wird der
neue Master.
Wenn das Hauptsystem wieder online kommt, wird es standardmäßig
ein Backup Host, obwohl, wenn es wünschenswerter ist, dass ein Host
immer Master wird wenn das möglich ist (z.B. wenn ein Host eine schnelle
Sun Fire V120 ist und die anderen vergleichbar langsame SPARCstation IPCs
sind), kannst du sie so konfigurieren.

<p>
Während hoch redundante und Fehler-tolerante Hardware die Notwendigkeit
von CARP verringert, vernichtet sie sie nicht.
Es gibt keine Hardwarefehlertoleranz die in der Lage ist zu helfen, wenn
jemand das Stromkabel herauszieht oder wenn dein Systemadministrator
<tt>reboot</tt> im falschen Fenster eintippt.
CARP macht es außerdem einfacher den Patch- und Rebootzyklus transparent
den Anwendern gegenüber zu gestalten, und einfacher ein Software oder
Hardware Upgrade zu testen -- wenn es nicht funktioniert, kannst du auf deine
,spares' zurückgreifen, bis es behoben ist.

<p>Es gibt jedoch Situationen, in denen CARP nicht helfen wird.
CARPs Design setzt voraus, dass die Mitglieder einer Gruppe sich im selben
physikalischen Subnet befinden und jedes Interface benötigt eine reale,
statische IP Adresse zusätzlich zu einer statischen CARP IP Adresse.
Ähnlich werden Dienste, die eine durchgehende Verbindung zum Server
benötigen (so wie SSH oder IRC), nicht transparent auf andere Systeme
weitergeleitet -- obwohl in diesem Fall CARP helfen kann, die Ausfallzeit
zu minimieren.
CARP wird von sich aus Daten zwischen Applikationen nicht synchronisieren,
dies muss durch "alternative Kanäle" wie zum Beispiel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4">pfsync(4)</a>
(für redundantes Filtern), manuelles Duplizieren von Daten zwischen
Systemen mit <a href="http://rsync.samba.org/">rsync</a>, oder was auch immer
für deine Anwendungen geeignet ist, durchgeführt werden.

<h3>6.11.2 - Konfiguration</h3>

<p>
CARPs Kontrollen befinden sich an zwei Orten:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Lass uns nun zuerst die sysctls betrachten.

<p>Die erste sysctl, <tt>net.inet.carp.allow</tt>, definiert, ob der Host
überhaupt CARP Pakete handhabt.
Klarerweise ist dies notwendig, um CARP nutzen zu können.
Diese sysctl ist standardmäßig aktiviert.

<p>Die zweite, <tt>net.inet.carp.arpbalance</tt>, wird für das Load
Balancing verwendet.
Wenn diese Funktion aktiviert ist, wird CARP ein ,source-hash' auf die
Quell-IP der Anfrage durchführen.
Dieser ,hash' wird dann verwendet, um einen virtuellen Host aus dem
zur Verfügung stehenden Pool auszuwählen, damit dieser die Anfrage
verarbeitet.
Dies ist standardmäßig deaktiviert.

<p>Die dritte, <tt>net.inet.carp.log</tt>, loggt CARP Fehler.
Standardmäßig deaktiviert.

<p>Vierte, <tt>net.inet.carp.preempt</tt> aktiviert natürliche Auswahl
zwischen CARP Hosts.
Der passendste für den Job (das heißt, wer in der Lage ist am
schnellsten zu Bekünden) wird zum Master.
Standardmäßig deaktiviert, das bedeutet, dass ein System, das nicht
zum Master auserwählt wurde, nicht versuchen wird den Master Status
(wieder) zu erhalten.

<p>
Alle diese sysctl Variablen sind in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a> dokumentiert.

<p>Für den Rest von CARPs Konfiguration verlassen wir uns auf
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Zwei von den vier CARP-spezifischen Befehlen, <tt>advbase</tt> und
<tt>advskew</tt>, befassen sich mit dem Intervall zwischen CARP
Bekündungen.
Die Formel (in Sekunden) ist <tt>advskew</tt> dividiert durch 255 und dann
addiert zu <tt>advbase</tt>.
<tt>advbase</tt> kann verwendet werden, um Netzwerkverkehr zu verringern oder
eine längere Latenz zuzulassen, bevor ein Backup Host übernimmt;
<tt>advskew</tt> lässt dir die Möglichkeit zu verwalten, welcher
Host Master sein wird, ohne große ,failover´ Verzögerungen
(sollte das notwendig sein).

<p>Als nächstes setzt <tt>pass</tt> ein Passwort und <tt>vhid</tt> setzt
die virtuelle Hostidentifizierungsnummer der CARP Gruppe.
Du musst jeder CARP Gruppe eine einzigartige Nummer verteilen, selbst wenn
(für Load Balancing Zwecke) sie sich die gleiche IP Adresse teilen.
CARP ist auf 255 Gruppen begrenzt.

<p>Lass uns alle diese Einstellungen zusammen in eine Grundkonfiguration
packen. Angenommen du setzt zwei identische Web Server auf, <i>rachael</i>
(192.168.0.5) und <i>pris</i> (192.168.0.6), um ein älteres System
zu ersetzen, das unter 192.168.0.7 verfügbar war. Die Befehle:

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell 192.168.0.7</b>
</pre></blockquote>

<p>erstellen das carp0 Interface und geben es eine vhid von 1, ein Passwort
das <i>tyrell</i> lautet und die IP Adresse 192.168.0.7.
Um es über die nächsten Reboots hinaus permanent zu machen, kannst
du eine <tt>/etc/hostnamecarp0</tt> Datei anlegen, die wie folgt aussieht:

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell
</pre></blockquote>

<p>
Mache das gleiche auf <i>pris</i>. Welches System von beiden das CARP
Interface zu erst aufsetzt wird Master.

<p>
Bedenke, dass auf einer Maschine mit mehreren Interfaces das CARP Interface
im gleichen Subnet des physikalischen Interfaces liegt.

<p>

Aber lass uns sagen du setzt nicht von Anfang an auf.
<i>Rachael</i> war bereits unter der Adresse 192.168.0.7 vorhanden.
Wie umgehst du das?
Glücklicherweise hat CARP kein Problem mit einem System, das eine
IP als physikalische Interface Adresse und in einer CARP Gruppe besitzt,
so dass kein Grund besteht die vorherigen Befehle zu ändern.
Trotz allem tendiert es dazu sauberer zu sein jeweils eine IP für jedes
System zu haben -- es macht individuelle Überwachungen und Zugriffe
viel einfacher.

<p>Lass uns nun einen weiteren Schwierigkeitsgrad hinzufügen; wir
möchten, dass <i>rachael</i> so lange wie möglich Master bleibt.
Es gibt einige Gründe, warum wir das benötigen könnten:
Hardware Unterschiede, einfache Vorurteile, "wenn das System nicht Master
ist, wird es Probleme geben" oder zu wissen, wer der standardmäßige
Master ist ohne mit Skripten die Ausgabe von ifconfig zu verarbeiten und per
E-Mail zu versenden.

<p>Auf <i>rachael</i> werden wir die sysctl verwenden, die wir weiter oben
erstellt haben und editieren dann <tt>/etc/sysctl.conf</tt>, um sie
permanent zu machen.

<blockquote><pre>
rachael# <strong>sysctl net.inet.carp.preempt=1</strong>
</pre></blockquote>

<p>Wir werden ebenfalls die Konfiguration auf <i>pris</i> durchführen:

<blockquote><pre>
pris# <strong>ifconfig carp0 advskew 100</strong>
</pre></blockquote>

<p>Dies verzögert die Bekündungen von <i>pris</i> ein wenig, was
bedeutet, dass <i>rachael</i> Master sein wird, wenn der Host angeschlossen
ist.

<p>
Bedenke, dass du "proto carp" mit folgender Zeile an alle beteiligten
Interfaces übergeben musst, wenn du PF auf einem geCARPten Computer
verwendest:
<blockquote><pre>
pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Load Balancing</h3>

<p>Siehe nun einige Monate nach vorne. Unsere Firma des vorherigen Beispiels
ist so gewachsen, dass sie an dem Punkt angekommen ist, an dem ein einzelner
Web Server die Last gerade so verarbeiten kann. Was nun? CARP ist die
Rettung. Es ist Zeit, Load Balancing zu versuchen. Erstelle ein neues CARP
Interface und eine Gruppe auf <i>rachael</i>:

<blockquote><pre>
rachael# <strong>ifconfig carp1 create</strong>
rachael# <strong>ifconfig carp1 vhid 2 advskew 100 pass bryant
192.168.0.7</strong>
</pre></blockquote>

<p>Auf <i>pris</i> werden wir ebenfalls eine neue Gruppe und Interface
anlegen und dann das "preempt" sysctl setzen:

<blockquote><pre>
pris# <strong>ifconfig create carp1</strong>
pris# <strong>ifconfig carp1 vhid 2 pass bryant 192.168.0.7</strong>
pris# <strong>sysctl net.inet.carp.preempt=1</strong>
</pre></blockquote>

<p>Nun haben wir zwei CARP Gruppen mit der gleichen IP Adresse.
Jede Gruppe zeigt auf einen anderen Host, was bedeutet, dass <i>rachael</i>
Master der originalen Gruppe bleibt, aber <i>pris</i> wird die neue
übernehmen.

<p>Alles, was wir nun tun müssen, ist die Load Balancing sysctl auf
beiden Systemen zu laden, die wir zuvor besprochen haben:

<blockquote><pre>
# <strong>sysctl net.inet.carp.arpbalance=1</strong>
</pre></blockquote>

<p>Während diese Beispiele für einen zwei-Maschinen Cluster
sind, gelten die gleichen Prinzipien auch für mehrere Systeme.
Bitte bedenke, dass es trotzdem nicht erwartet wird, dass du perfekte
50/50 Distribution zwischen den beiden Maschinen erreichst -- CARP verwendet
einen ,hash' der ankommenden IP Adresse um zu ermitteln, welches System
die Anfrage verarbeitet, statt durch Auslastung zu entscheiden.

<h3>6.11.4 - Weitere Informationen zu CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">Firewall
Failover with pfsync and CARP</a> von Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - OpenNTPD verwenden</h2>
Genaue Zeit ist wichtig für viele Computer Applikationen.
Trotzdem haben viele Leute bemerkt, dass ihre $5 Uhr eine genauere Uhrzeit
halten kann als ihr $2000 Computer.
Zusätzlich zum Wissen, welche Uhrzeit gerade ist, ist es ebenfalls
häufig wichtig, Computer zu synchronisieren, so dass sie alle mit der
gleichen Uhrzeit übereinstimmen. Für eine gewisse Zeit hat
<a href="http://www.ntp.org">ntp.org</a> eine Network Time Protokoll
(<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>) Applikation
entwickelt, verfügbar durch <a href="../faq8.html#Ports">Ports</a>,
die verwendet werden kann, um die Uhren auf den Computern über das
Internet zu synchronisieren.
Trotzdem ist dies ein nicht-triviales Programm zum Einrichten, schwerer
Code zum Überprüfen und hat eine große Speicheranforderung.
Kurz gesagt spielt es eine wichtige Rolle für einige Leute, aber es ist
weit entfernt von einer Lösung für jedermann.

<p>
<a href="http://www.openntpd.org/de">OpenNTPD</a> ist ein Versuch, einige dieser
Probleme zu lösen, es einfacher-zu-administrieren zu machen und ein
sicherer und simpler NTP kompatibler Weg zu sein, um eine genaue Uhrzeit
auf deinem Computer zu haben.
OpenBSDs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8">ntpd(8)</a>
wird von einer einfach zu verstehenden Konfigurationsdatei gesteuert,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"><tt>/etc/ntpd.conf</tt></a>.

<p>
Aktiviere ntpd(8) einfach durch <a href="../faq10.html#rc">rc.conf.local</a>
und das Resultat wird sein, dass dein Computer sich selbst mit den
<a href="http://www.pool.ntp.org/">pool.ntp.org</a> Servern synchronisiert,
einer Sammlung von öffentlich verfügbaren Zeit Servern.
<!-- XXXversion 3.6 only -->
Wenn deine Uhr auf deinem Computer sehr falsch geht, solltest du sie zuerst
so genau wie möglichen einstellen, möglicherweise unter Verwendung
von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>,
da ntpd(8) deine Uhr nur SEHR langsam durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adjtime&amp;sektion=2">adjtime(2)</a>
angleicht
-- es kann <i>mehrere Stunden</i> dauern (oder Tage oder sogar noch länger) um
eine sehr ungenau eingestellte Uhr zu synchronisieren (<i>-current</i> wird
unmittelbar nach dem Boot die Uhr setzen).
Wenn deine Uhr erst einmal genau eingestellt ist, wird ntpd sie auf einem
sehr hohen Genauigkeitsgrad halten.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - "Aber OpenNTPD ist nicht so genau wie der ntp.org Daemon!"</h3>
Das mag wahr sein.
Es war nicht OpenNTPDs
<a href="http://www.openntpd.org/de/goals.html">Entwurfssziel</a>, es war
vorgesehen, dass es frei, simpel, zuverlässig und sicher ist.
Wenn du wirklich Mikrosekunden Präzision mehr als die Vorteile von
OpenNTPD brauchst, tu dir keinen Zwang an und verwende ntp.orgs ntpd, da
er weiterhin durch Ports und Packages verfügbar sein wird.
Es existieren weder ein Plan noch das Verlangen, OpenNTPD mit allen
vorstellbaren Funktionen vollzustopfen.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - "Jemand hat behauptet, dass OpenNTPD ,schädlich' ist!"</h3>
Das wird wahrscheinlich
<a href="http://bradknowles.typepad.com/considered_harmful/2004/09/openntpd.html">Brad
Knowles</a> gewesen sein.
Wenn genaue Zeit wichtig ist, haben einige Benutzer berichtet, dass die
Ergebnisse von OpenNTPD besser sind als die von ntp.orgs ntpd.
Wenn Sicherheit wichtig ist, ist OpenNTPDs Code sehr viel besser lesbar
(und daher, kontrollierbar) und wurde unter Verwendung von OpenBSD
Funktionsaufrufen wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3">strlcpy</a>
statt portableren Funktionen wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3">strcpy</a>
entwickelt und wurde von Anfang an sicher geschrieben, nicht "später
sicher gemacht". Wenn es wertvoll ist, dass so viele Leute wie möglich
Zeit Synchronisierung verwenden, macht es OpenNTPD einer großen
Anzahl an Leuten einfacher, diese zu nutzen.
Wenn das "schädlich" ist, stimmen wir dem voll und ganz zu.

<p>
Es gibt Anwendungsgebiete, bei denen ntp.orgs ntpd genauer ist, trotzdem
geht man davon aus, dass für 95% der anderen Anwender OpenNTPD mehr als
ausreichend sein wird.

<p>
Eine ausführlichere Antwort hierauf von den Entwicklern von OpenNTPD kann
<a href="http://www.advogato.org/person/dtucker/diary.html?start=52">hier</a>
gelesen werden.

<a name="Wireless"></a>
<h3>6.13 - Was sind meine Wireless Netzwerk Optionen?</h3>
OpenBSD hat für ein paar Wireless Chipsätze Unterstützung:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">awi(4)</a>
AMD 802.11 PCnet Mobile 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">an(4)</a>
Aironet Communications 4500/4800
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">wi(4)</a>
Prism2/2.5/3
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">atw(4)</a>
ADMtek ADM8211
</ul>

Karten, die auf diesen Chips basieren, können fast genauso wie andere
Netzwerkkarten genutzt werden, um ein OpenBSD System an ein existierendes
Wireless Netzwerk anzubinden (bitte siehe die Manual Seiten für
präzise Details).
Die Prism2 und Prism3-basierenden Karten können jedoch auch in dem
"Host-Based Access Point" Modus genutzt werden, das ihnen erlaubt, in deinen
Wireless Access Point für dein Netzwerk als Teil deiner Firewall gesetzt
zu werden. Unglücklicherweise werden die Prism2/3-basierenden
Netzwerkkarten nicht mehr von den meisten der "Massenmarkt" Herstellern
produziert, da sie auf die günstigeren und neuen Chips wechselten, oft,
<a href="#GenSupport">ohne die Modellnummer gewechselt zu haben</a>.
Die meisten der Hersteller von neuen Chips haben entschieden, keine
Dokumentation zu veröffentlichen, die für die Entwicklung von
freien und offenen Treibern für diese Devices benötigt werden
(Wenn du möchtest, kannst du die Hersteller kontaktieren und sie
darum bitten, ihre Richtlinien zu ändern).

<p>
Zum Glück sind Prism2/3-basierende Karten weiterhin durch den
Gebrauchthandel verfügbar und ein paar Hersteller verstehen den Wert
eines ordentlich dokumentierten, Open-Source freundlichen Chipsatzes und
setzen die professionelle Produktion von Prism-basierenden Karten fort.
Ein Verkäufer dieser Karten ist
<a href="http://www.netgate.com">Netgate.com</a>.
Wenn ein Hersteller nicht ausdrücklich ein aktuelles Produkt als
Prism-basierend kennzeichnet, kann man normalerweise davon ausgehen, dass
es nicht mit dem wi(4) Treiber kompatibel sein wird.
Bedenke, dass die neuesten Prism-Serien Chips (wie zum Beispiel Prism-GT)
nicht unterstützt werden.

<p>
Eine andere Möglichkeit, mit deiner OpenBSD-basierenden Firewall einen
Wireless Access anzubieten, ist die Verwendung einer konventionellen NIC
und einem externen Bridging Access Point.
Dies hat den zusätzlichen Vorteil, dass du die Position der Antenne
mit Leichtigkeit an die Stelle ändern kannst, an der sie am
effektivsten ist, was nicht häufig direkt auf der Rückseite
deiner Firewall ist.


<p>
<font color= "#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Source-Code erzeugen]</a>
<a href="faq7.html">[Zum Kapitel 7 - Tastatur- und Bildschirm-Kontrollen]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.212 ]
$Translation: faq6.html,v 1.89 2005/01/18 14:33:45 paldium Exp $
-->
$OpenBSD: faq6.html,v 1.72 2005/01/18 17:17:47 jufi Exp $
</small>

</body>
</html>
