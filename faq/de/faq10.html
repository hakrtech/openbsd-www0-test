<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>10 - Systemverwaltung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 10 - System Management">
<meta name= "keywords"      content= "openbsd,faq10">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2011 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq9.html">[Zum Kapitel 9 - Zu OpenBSD migrieren]</a>
<a href= "faq11.html">[Zum Kapitel 11 - Das X Fenstersystem]</a>
</font>

<h1><font color="#e00000">10 - Systemverwaltung</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#wheel"         >10.1 -
    Wenn ich mich per su zu root machen will, wird mir gesagt,
    dass ich in der falschen Gruppe sei.</a>
<li><a href="#DupFS"         >10.2 -
    Wie kann ich ein Dateisystem duplizieren?</a>
<li><a href="#rc"            >10.3 -
    Wie starte ich Daemons mit dem System? (Überblick über rc(8))</a>
<li><a href="#RelayingDenied">10.4 -
    Wieso erhalten Benutzer ein »relaying access denied« wenn sie versuchen,
    von woanders her Mails über mein OpenBSD-System zu verschicken?</a>
<li><a href="#POP"           >10.5 -
    Ich habe POP installiert, erhalte aber Fehler, wenn ich versuche,
    meine Mails per POP abzuholen.
    Was kann ich tun?</a>
<li><a href="#SendmailDNS"   >10.6 -
    Warum ignoriert Sendmail die /etc/hosts-Datei?</a>
<li><a href="#HTTPS"         >10.7 -
    Einen sicheren HTTP-Server mit Hilfe von SSL(8) aufsetzen</a>
<li><a href="#vipw"          >10.8 -
    Ich habe zwar mit vi(1) Änderungen an /etc/passwd gemacht,
    die Änderungen haben aber keinen Effekt.
    Warum?</a>
<li><a href="#AddDelUser"    >10.9 -
    Wie fügt man einen Benutzer hinzu?
    Oder wie löscht man einen?</a>
<li><a href="#FTPOnly"       >10.10 -
    Wie erzeugt man ein Benutzerkonto, das nur für FTP genutzt werden kann?</a>
<li><a href="#Quotas"        >10.11 -
    Wie man Benutzer-Diskquotas einrichtet</a>
<li><a href="#Kerberos"      >10.12 -
    Wie man KerberosV-Client/Server einrichtet</a>
<li><a href="#AnonFTP"       >10.13 -
    Wie man einen Anonymous-FTP-Server einrichtet</a>
<li><a href="#ftpchroot"     >10.14 -
    In ftpd(8) Benutzer in ihre Heimatverzeichnisse einsperren.</a>
<li><a href="#Patches"       >10.15 - Korrekturroutinen in OpenBSD einfügen.</a>
<li><a href="#httpdchroot"   >10.16 - Wie geht das mit dem chroot(2)-Apache?</a>
<li><a href="#rootshell"     >10.17 - Kann ich die Rootshell ändern?</a>
<li><a href="#ksh"           >10.18 - Was kann ich noch mit ksh machen?</a>
<li><a href="#Dir"           >10.19 - Verzeichnisdienste</a>
<ul>
  <li><a href="#Dir.available" >10.19.1 -
        Welche Verzeichnisdienste sind verfügbar?</a>
  <li><a href="#YP_secure"     >10.19.2 - YP Sicherheitsüberlegungen</a>
  <li><a href="#YP_server"     >10.19.3 - Einrichten eines YP-Servers</a>
  <li><a href="#YP_client"     >10.19.4 - Einrichten eines YP-Klienten</a>
</ul>
<li><a href="#locales"       >10.20 - Zeichensätze und Lokalisierung</a>
<ul>
  <li><a href="#charset"       >10.20.1 -
        Konfiguration des aktiven Zeichensatzes</a>
  <li><a href="#nls"           >10.20.2 -
        Ändern der in Anwendungen benutzten Sprache</a>
</ul>
</ul>

<hr>

<p>
<a name= "wheel"></a>
<h2>10.1 - Wenn ich mich per su zu root machen will, wird mir gesagt,
dass ich in der falschen Gruppe sei.</h2>

<p>
Unter OpenBSD ist es Benutzern der Gruppe <kbd>wheel</kbd> erlaubt,
mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1"
>su(1)</a> zum Benutzer root zu werden.
Anderenfalls wird der Benutzer einen Fehler erhalten.

<p>
Erzeugst du einen neuen Benutzer mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"
>adduser(8)</a>,
so kannst du ihn zu der Gruppe <kbd>wheel</kbd> hinzufügen,
indem du am Prompt der Frage "<tt>Invite <i>user</i> into other groups:</tt>"
mit »wheel« antwortest.
Bestehende Benutzer müssen per Hand zu der Gruppe <kbd>wheel</kbd> hinzugefügt
werden.  Hier ist das Beispiel eines Eintrags in <kbd>/etc/group</kbd>, das den
Benutzer <b>ericj</b> zu der Gruppe <kbd>wheel</kbd> hinzugefügt zeigt:

<blockquote><pre>
wheel:*:0:root,ericj
</pre></blockquote>

<p>
Möchtest du »Superuser«-Privilegien ermöglichen, ohne Benutzer zu der Gruppe
<kbd>wheel</kbd> hinzuzufügen, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8"
>sudo(8)</a>.

<p>
<a name= "DupFS"></a>
<h2>10.2 - Wie kann ich ein Dateisystem duplizieren?</h2>

<p>
Um ein Dateisystem zu duplizieren, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>.
Um zum Beispiel alles unter dem Verzeichnis <kbd>SRC</kbd> in das
Verzeichnis <kbd>DST</kbd> zu duplizieren, führe Folgendes aus:

<blockquote><pre>
# <b>cd /SRC; dump 0f - . | (cd /DST; restore -rf - )</b>
</pre></blockquote>

<p>
Das Programm dump wurde so entworfen, dass es dir reichliche
Backupmöglichkeiten gibt und es könnte viel zu viel sein, wenn du
einfach nur einen Teil (oder das gesamte) Dateisystem duplizieren möchtest.
Das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>
kann für diese Aufgabe schneller sein. Das Format sieht sehr ähnlich
aus:

<blockquote><pre>
# <b>cd /SRC; tar cf -  . | (cd /DST; tar xpf - )</b>
</pre></blockquote>

<p>
<a name= "rc"></a>
<h2>10.3 - Wie starte ich Daemons mit dem System? (Überblick über
rc(8))</h2>

OpenBSD selbst verwendet eine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">rc(8)</a>-orientierte
Startphase. Diese verwendet einige Schlüsseldateien.

<ul>
  <li>/etc/rc - Hauptskript. Sollte nicht verändert werden.
  <li>/etc/rc.conf - Konfigurationsdatei, die von <i>/etc/rc</i> genutzt
  wird, um Startparameter für das System zu setzen.
  Sollte nicht editiert werden.
  <li>/etc/rc.conf.local - Konfigurationsdatei für das Überschreiben
  von Einstellungen in /etc/rc.conf, sodass /etc/rc.conf selbst nicht
  verändert werden muss, was beim »Upgrade« des Systems wichtig ist.
  <li>/etc/netstart - Skript, das beim Initialisieren des Netzwerks
  genutzt wird. Sollte nicht verändert werden.
  <li>/etc/rc.local - Skript, das für die lokale Administration genutzt
  wird. Dies ist die Datei, in der neue Daemons oder hostspezifische
  Informationen gesetzt werden sollten.
  <li>/etc/rc.securelevel - Skript, das benötigte Kommandos ausführt,
  bevor das Sicherheitslevel sich verändert. Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>.
  <li>/etc/rc.shutdown - Skript, das beim Herunterfahren ausgeführt
  wird. Schreibe alles in diese Datei hinein, das vor dem Herunterfahren
  gemacht werden soll. Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.shutdown&amp;sektion=8">rc.shutdown(8)</a>.
</ul>

<h3>Wie funktioniert rc(8)?</h3>

<p>
Die Hauptdateien, auf die ein Systemadministrator zu achten hat, sind
<i>/etc/rc.conf</i> (als Anleitung), <i>/etc/rc.conf.local</i> (für
Änderungen), <i>/etc/rc.local</i> und <i>/etc/rc.shutdown</i>.
Um einen Überblick über die rc(8)-Prozedur zu erhalten, folgt der Ablaufplan:

<p>
Nachdem der Kernel geladen wurde, wird <i>/etc/rc</i> gestartet:
<ul>
  <li>Dateisysteme werden überprüft.
  <li>Konfigurationsvariablen werden von <i>/etc/rc.conf</i> gelesen,
      danach werden lokale Änderungen dieser Variablen aus 
      <i>/etc/rc.conf.local</i> gelesen.
      Einstellungen aus rc.conf.local werden jene aus rc.conf überschreiben.
  <li>Dateisysteme werden gemountet.
  <li>Löscht den Inhalt von <i>/tmp</i> und schützt jegliche
      Editordateien.
  <li>Konfiguriert das Netzwerk per <i>/etc/netstart</i>
  <ul>
    <li>Aktiviert dein Interface.
    <li>Setzt deinen Hostnamen, Domänennamen etc.
  </ul>
  <li>Startet Systemdaemons.
  <li>Führt etliche andere Überprüfungen durch (Quotas, savecore
      etc.)
  <li><i>/etc/rc.firsttime</i> wird ausgeführt
  <li><i>/etc/rc.local</i> wird ausgeführt
  <li>Lokale sowie Paket-Skripte aus <i>/etc/rc.d</i> werden abgearbeitet
</ul>

<h3>In OpenBSD enthaltene Daemons und Dienste starten</h3>

<p>
Die meisten der in OpenBSD enthaltenen Daemons und Dienste werden während des
Systemstarts durch Variablen kontrolliert, die in den Konfigurationsdateien des
Verzeichnisses <i>/etc/rc.conf</i> definiert sind.
Wirf einen Blick in die Datei
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/rc.conf?content-type=text/plain"
>/etc/rc.conf</a>.  Dort wirst du Zeilen ähnlich der Folgenden sehen:

<blockquote><pre>
ftpd_flags=NO           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Eine Zeile wie diese zeigt das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8"
>ftpd(8)</a> nicht mit dem System gestartet wird (zumindest nicht als Dämon
durch rc(8); ftpd wird oft durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a> gestartet, siehe die
<a href="faq10.html#AnonFTP">Anonymes FTP FAQ</a>, um mehr darüber zu lesen).
Jede Zeile besitzt ein Kommentar, das die benötigten Optionen für die geläufige
Form der Benutzung des Dämonen oder Service aufzeigt.
Dies bedeutet nicht, dass du diesen Dämon oder Service mit exakt diesen
Optionen starten musst.
Lies die relevanten Handbuchseiten, um in Erfahrung zu bringen, wie dieser eine
Dämon oder Service auf die gewünschte Art und Weise gestartet werden kann.

<p>
Wir empfehlen dringend <i>/etc/rc.conf</i> nicht zu ändern.
Stattdessen sollte die Datei <i>/etc/rc.conf.local</i> erzeugt oder editiert
werden; kopiere einfache jene Zeilen, die geändert werden sollen, aus
<i>/etc/rc.conf</i> und passe sie ganz nach Gusto an.
Diese Vorgehensweise macht zukünftige »Upgrades« einfacher - alle Änderungen
befinden sich in einer Datei, die während des »Upgrade« nicht berührt wird.
Tatsächlich nimmt der standardmäßige
<a href="../upgrade50.html">»Upgrade«-Prozess</a> an, dass <i>/etc/rc.conf</i>
nicht verändert wurde, und überschreibt diese Datei mit einer neuen Version.

<p>
Hier zum Beispiel ist die standardmäßige Zeile bezüglich httpd(8).

<blockquote><pre>
httpd_flags=NO          # for normal use: "" (or "-DSSL" after reading ssl(8))
</pre></blockquote>

<p>
Wie zu sehen ist benötigt httpd für den Programmstart normalerweise keinerlei
Optionen, sodass das Hinzufügen einer Zeile wie <tt>httpd_flags=""</tt> zu
<i>/etc/rc.conf.local</i> für die vollständige Einrichtung dieses Services
ausreicht.
Um aber httpd mit aktiviertem SSL zu starten
(siehe auch <a href="#HTTPS">SSL-FAQ</a> oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8"
>ssl(8)</a>), würde man mit einer Zeile wie <tt>httpd_flags="-DSSL"</tt>
beginnen, obwohl man eventuell andere Optionen aus anderen Gründen wird
hinzufügen müssen.

<h3>Lokale Daemons starten und konfigurieren</h3>

<p>
Für andere Daemons, die vielleicht auf dem System via Paket, oder auf
andere Art installiert werden, könnte die Datei <i>/etc/rc.local</i> verwendet
werden.
Zum Beispiel hat der Autor einen Dämon in /usr/local/sbin/daemonx installiert,
und möchte ihn zur Systemstartzeit gestartet haben.
Im dies zu erreichen, könnte er einen Eintrag wie den folgenden in
<i>/etc/rc.local</i> schreiben:

<blockquote><pre>
if [ -x /usr/local/sbin/daemonx ]; then
    echo 'Starting daemonx'; /usr/local/sbin/daemonx
fi
</pre></blockquote>

<p>
(Wenn der Daemon sich beim Starten nicht automatisch von der Konsole
löst, denke daran, dass du ein »&amp;« an das Ende der Kommandozeile
hängen musst.)

<p>
Von nun an wird dieser Daemon beim Booten gestartet. Du wirst in der
Lage sein, jegliche Fehler beim Hochfahren zu sehen, ein normaler Boot
ohne Fehler würde eine Zeile wie die folgende anzeigen:

<blockquote><pre>
Starting daemonx
</pre></blockquote>

<h3>Das Verzeichnis <i>/etc/rc.d/</i></h3>
Beginnend mit OpenBSD 5.0 werden Systemdämonen (»Services«) von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.d&amp;sektion=8"
><i>/etc/rc.d</i></a> gestartet, gestopped und kontrolliert.
Alle Systemdämonen werden durch diese Skripte gehandhabt,
und ebenso die meisten <a href="faq15.html">Pakete</a>.

<p>
Diese Skripte, einer pro Dämon, werden von <tt>rc</tt> aufgerufen.
Die Reihenfolge der Systemdämonen ist fest in <tt>rc</tt> codiert,
und die Reihenfolge für hinzugefügte Pakete wird von der
<tt>pkg_scripts</tt> Umgebungsvariable gesteuert, welche in
<tt>/etc/rc.conf.local</tt> gesetzt würde.
Beachte, dass das einfache Platzieren eines Skripts in diesem Verzeichnis nicht
dazu führt, dass es automatisch während des Systemstarts aufgerufen wird;
dafür muss der Name des Skripts in <tt>pkg_scripts</tt> vorkommen.

<p>
Das Starten von Systemskripten wird von Einträgen in der Datei
<tt>/etc/rc.conf.local</tt> bestimmt.
Zum Beispiel wird <tt>/etc/rc.d/httpd</tt> nicht
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=&amp;sektion=4"
>httpd(1)</a> starten bevor <tt>/etc/rc.conf</tt> oder
<tt>/etc/rc.conf.local</tt> eine Zeile beinhalten, die die Variable
»<tt>httpd_flags</tt>« definiert.
Um dabei zu helfen, dass das System sich genau wie erwartet beim nächsten
Systemstart verhält, starten die <tt>rc.d</tt>-Skripte ihren Dämon nicht,
es sei denn eine entsprechende Variable wurde definiert.
Man kann natürlich <tt>/usr/sbin/httpd</tt> direkt, mit was auch immer für
Optionen man will direkt aufrufen, will man das Programm denn manuell aufrufen.

<p>
Es ist anzumerken, dass Skripte in rc.d keineswegs die komplette »startup«-,
»shutdown«-, »reload«-, »restart«- und »check«-Funktionalität voll
implementieren müssen;
die meisten rc.d-Skripte können auf die Spezifikation einiger weniger Variablen
und den Aufruf des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.subr&amp;sektion=8"
>rc.subr</a>-Skripts reduziert werden, da der genannte Skript die meisten
normalen Wege zur Bewältigung dieser Aufgaben handhaben kann.

<p>
Zum Beispiel könnte die oben angeführte Anwendung <tt>daemonx</tt> mit einer
<tt>/etc/rc.d</tt>-Datei wie der Folgenden gestartet werden:

<blockquote><pre>
#!/bin/sh

daemon="/usr/local/sbin/daemonx"

. /etc/rc.d/rc.subr

rc_cmd $1
</pre></blockquote>

sowie dem Hinzufügen des Namen des Dämonen zu der Variable <tt>pkg_scripts</tt>
in <tt>/etc/rc.conf.local</tt>.

<h3>rc.shutdown</h3>

<p>
<i>/etc/rc.shutdown</i> ist ein Skript, das beim Herunterfahren
ausgeführt wird. Alles, was du zuvor erledigt haben möchtest, bevor das
System herunterfährt, sollte in diese Datei geschrieben werden. Falls du
apm hast, kannst du ebenfalls powerdown=YES setzen. Das wird dir das
Äquivalent zu »shutdown -p« geben.

<p>
<a name= "RelayingDenied"></a>
<h2>10.4 - Wieso erhalten Benutzer ein »relaying denied« wenn sie
versuchen, von woanders her Mails über mein OpenBSD-System zu
verschicken?</h2>
<p>
Versuch das hier:

<blockquote><pre>
# <b>grep relay-domains /etc/mail/sendmail.cf</b>
</pre></blockquote>

<p>
Die Ausgabe könnte wie folgt sein:

<blockquote><pre>
FR-o /etc/mail/relay-domains
</pre></blockquote>

<p>
Wenn diese Datei nicht vorhanden ist, erstelle sie. Du musst die Hosts
mit der folgenden Syntax eintragen, die Mails über dein System senden.

<blockquote><pre>
.domain.com    #Allow relaying for/to any host in domain.com
sub.domain.com #Allow relaying for/to sub.domain.com and any host in that domain
10.2           #Allow relaying from all hosts in the IP net 10.2.*.*
</pre></blockquote>

<p>
Vergiss nicht, ein HangUP-Signal an sendmail zu senden (ein Signal,
das die meisten Daemons veranlasst, ihre Konfigurationsdatei erneut
einzulesen):

<blockquote><pre>
# <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre></blockquote>

<p>

<h3>Weitere Informationen</h3>

<p>
<ul>
<li><a href="http://www.sendmail.org/~ca/email/relayingdenied.html">http://www.sendmail.org/~ca/email/relayingdenied.html</a>
<li><a href="http://www.sendmail.org/tips/relaying.php">http://www.sendmail.org/tips/relaying.php</a>
<li><a href="http://www.sendmail.org/antispam/">http://www.sendmail.org/antispam/</a>
</ul>

<p>
<a name= "POP"></a>
<h2>10.5 - Ich habe POP installiert, erhalte aber Fehler, wenn ich
versuche, meine Mails per POP abzuholen. Was kann ich tun?</h2>

<p>
Die meisten Konflikte mit POP sind Probleme mit temporären und
Lockdateien. Wenn dein POP-Server eine Fehlernachricht wie diese
sendet:

<blockquote><pre>
-ERR Couldn't open temporary file, do you own it?
</pre></blockquote>

<p>
Versuche, deine Berechtigungen wie folgt einzurichten:

<blockquote><pre>
permission in  /var
drwxrwxr-x   2 bin     mail     512 May 26 20:08 mail


permissions in  /var/mail
-rw-------   1 username   username        0 May 26 20:08 username
</pre></blockquote>

<p>
Eine andere Sache, die überprüft werden sollte, ist, dass der Benutzer
tatsächlich seine eigene /var/mail-Datei besitzt. Selbstverständlich
sollte das der Fall sein (also, dass /var/mail/joe joe gehört) aber wenn
das nicht richtig eingestellt ist, könnte es das Problem sein!

<p>
Selbstverständlich wird eine Schreibberechtigung der Gruppe mail ein
unwahrscheinliches und obskures Sicherheitsproblem hervorrufen. Es ist
sehr wahrscheinlich, dass du niemals Probleme damit haben wirst. Aber
es könnte sein (insbesondere, wenn du eine sehr beschäftigte Site hast,
ISP, ...)! Es gibt einige POP-Server, die du direkt von der
Portierungs-Kollektion aus installieren kannst. Wenn möglich, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=popa3d&amp;sektion=8">popa3d</a>,
das in der OpenBSD-Basisinstallation vorhanden ist.
Oder aber, du könntest einfach die falschen Optionen für deinen
POP-Daemon ausgewählt haben (wie Dotlocking). Vielleicht musst du
das Verzeichnis wechseln, in dem er ein Lockin durchführt (obwohl
das Locking dann nur für den POP-Daemon von Bedeutung sein wird).

<p>
<b>Hinweis:</b> Denke daran, dass OpenBSD keine Gruppe namens mail
hat. Du musst diese in deiner <i>/etc/group</i>-Datei erstellen, wenn du
sie brauchst. Ein Eintrag wie:

<blockquote><pre>
mail:*:6:
</pre></blockquote>

<p>
wäre ausreichend.

<p>
<a name="SendmailDNS"></a>
<h2>10.6 - Warum ignoriert Sendmail die <tt>/etc/hosts</tt>-Datei?</h2>

<p>
Standardmäßig verwendet Sendmail DNS für die Namensauflösung, nicht die
<tt>/etc/hosts</tt>-Datei. Die Vorgehensweise kann durch das Nutzen der
<tt>/etc/mail/service.switch</tt>-Datei geändert werden.

<p>
Wenn du die hosts-Datei vor den DNS-Servern überprüfen willst, erstelle
eine <tt>/etc/mail/service.switch</tt>-Datei, welche folgende Zeile
beinhaltet:

<blockquote><pre>
hosts       files dns
</pre></blockquote>

<p>
Wenn du NUR die hosts-Datei überprüfen willst, verwende die folgende:

<blockquote><pre>
hosts       files
</pre></blockquote>

<p>
Sende Sendmail ein HUP-Signal:

<blockquote><pre>
# <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre></blockquote>

<p>
und die Änderungen werden wirksam.


<p>
<a name= "HTTPS"></a>
<h2>10.7 - Einen sicheren HTTP-Server mit Hilfe von SSL(8)
aufsetzen</h2>

<p>
OpenBSD wird mit einem SSL-fähigen httpd und RSA-Bibliotheken
ausgeliefert. Für die Verwendung mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
musst du zuerst ein Zertifikat erstellen. Dieses wird unter
<i>/etc/ssl/</i> mit dem dazugehörigen Schlüssel unter
<i>/etc/ssl/private/</i> abgelegt.
Die Schritte, die hier gezeigt werden, sind Teil der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>-Handbuchseite.
Greife für weitere Informationen auf diese zurück.
Dieser FAQ-Eintrag zeigt nur, wie man ein RSA-Zertifikat für Webserver
erstellt, nicht ein Zertifikat für einen DSA-Server. Um zu erfahren, wie
man das macht, greife auf die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>-Handbuchseite
zurück.

<p>
Um zu beginnen, musst du deinen Serverschlüssel und dein -zertifikat
unter Verwendung von OpenSSL erstellen:

<blockquote><pre>
# <b>openssl genrsa -out /etc/ssl/private/server.key 1024</b>
</pre></blockquote>

<p>
Oder, wenn du möchtest, dass dein Schlüssel mit einem Passwort
verschlüsselt wird, das du beim Starten des Servers angeben wirst:

<blockquote><pre>
# <b>openssl genrsa -des3 -out /etc/ssl/private/server.key 1024</b>
</pre></blockquote>

<p>
Der nächste Schritt ist das Generieren eines »Certificate Signing
Request«, welches genutzt wird, um eine »Certifying Authority« (CA)
dazu zu bringen, dein Zertifikat zu signieren. Verwende hierfür dieses
Kommando:

<blockquote><pre>
# <b>openssl req -new -key /etc/ssl/private/server.key -out /etc/ssl/private/server.csr</b>
</pre></blockquote>

<p>
Diese <i>server.csr</i>-Datei kann danach zu einer »Certifying
Authority« übergeben werden, die den Schlüssel signieren wird. Eine
solche CA ist <b>Thawte Certification</b>, welche unter
<a href="http://www.thawte.com/">http://www.thawte.com/</a> erreicht
werden kann.

<p>
Wenn du dir das nicht leisten kannst oder du das Zertifikat einfach nur
selbst signieren möchtest, kannst du das Folgende nutzen.

<blockquote><pre>
# <b>openssl x509 -req -days 365 -in /etc/ssl/private/server.csr \
       -signkey /etc/ssl/private/server.key -out /etc/ssl/server.crt</b>
</pre></blockquote>

<p>
Mit <i>/etc/ssl/server.crt</i> und <i>/etc/ssl/private/server.key</i>
an der richtigen Stelle solltest du in der Lage sein,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
mit der Option <b>-DSSL</b> zu starten (siehe die
<a href="#rc">Sektion über rc(8)</a> in dieser FAQ), was
HTTPS-Transaktionen mit deiner Maschine über den Port 443 ermöglicht.

<p>
<a name= "vipw"></a>
<h2>10.8 - Ich habe zwar mit vi(1) Änderungen an /etc/passwd gemacht,
die Änderungen haben aber keinen Effekt. Warum?</h2>

<p>
Wenn du <i>/etc/passwd</i> direkt editierst, werden deine Änderungen
verloren gehen. OpenBSD generiert <i>/etc/passwd</i> dynamisch mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pwd_mkdb&amp;sektion=8">pwd_mkdb(8)</a>.
Die Hauptpasswortdatei unter OpenBSD ist <i>/etc/master.passwd</i>.
Laut pwd_mkdb(8),

<blockquote><pre>
FILES
     /etc/master.passwd  current password file
     /etc/passwd         a 6th Edition-style password file
     /etc/pwd.db         insecure password database file
     /etc/pwd.db.tmp     temporary file
     /etc/spwd.db        secure password database file
     /etc/spwd.db.tmp    temporary file
</pre></blockquote>

<p>
In einer traditionellen Unix-Passwortdatei, wie /etc/passwd, ist alles
für jeden auf dem System verfügbar, dazu zählt auch das verschlüsselte
Passwort des Benutzers (und ist somit das Hauptziel für Programme wie
zum Beispiel Crack).
4.4BSD führte die Datei master.passwd ein, welche ein erweitertes Format
hat (mit zusätzlichen Optionen, die über die hinausgehen, die in
/etc/passwd aufgelistet sind) und ist nur von root lesbar. Für
schnelleren Zugriff auf die Daten lesen die Bibliotheksaufrufe, die
auf jene Daten zugreifen, normalerweise /etc/pwd.db und /etc/spwd.db.

<p>
OpenBSD wird mit einem Tool ausgeliefert, mit welchen du deine
Passwortdatei editieren solltest. Es wird <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8"
>vipw(8)</a> genannt.
Vipw verwendet vi (oder deinen bevorzugten Editor, der mit $EDITOR
definiert wird), um /etc/master.passwd zu bearbeiten. Wenn du mit dem
Editieren fertig bist, wird es /etc/passwd, /etc/pwd.db und /etc/spwd.db
anhand deiner Änderungen aktualisieren. Vipw kümmert sich ebenfalls um
das Locking dieser Dateien, sodass, falls jemand zur gleichen Zeit
versucht, sie zu editieren, ihm der Zugriff verwehrt wird.

<p>
<a name= "AddDelUser"></a>
<h2>10.9 - Was ist der beste Weg, Benutzer hinzuzufügen oder zu
löschen?</h2>

<p>
OpenBSD bietet zwei Kommandos, um Benutzer auf einfache Weise dem
System hinzuzufügen:

<ul>
<li><a href="#adduser">adduser(8)</a>
<li><a href="#user">user(8)</a>
</ul>

Du kannst Benutzer ebenfalls manuell unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw(8)</a>
hinzufügen, aber das ist für die meisten Operationen umständlicher.

<a name="adduser"></a>
<p>
Der einfachste Weg, um einen Benutzer unter OpenBSD hinzuzufügen, ist
die Verwendung des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>-Skripts.
Du kannst adduser(8) durch das Editieren der <i>/etc/adduser.conf</i>
konfigurieren.
adduser(8) erlaubt Konsistenzüberprüfungen für <i>/etc/passwd</i>,
<i>/etc/group</i> und Shelldatenbanken. Es wird die Einträge und
$HOME-Verzeichnisse für dich erstellen. Es kann sogar eine Nachricht
an die Benutzer zur Begrüßung senden. Hier ist ein Beispielbenutzer,
<b>testuser</b>, der zu einem System hinzugefügt wird.
Er/Sie bekommt das $HOME-Verzeichnis <i>/home/testuser</i>, wird ein
Mitglied der Gruppe <b>guest</b> und bekommt die Shell <i>/bin/ksh</i>.

<blockquote><pre>
# <b>adduser</b>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. There will be a chance later to correct any input.
Enter username []: <b>testuser</b>
Enter full name []: <b>Test FAQ User</b>
Enter shell csh ksh nologin sh [ksh]: <b>ksh</b>
Uid [1002]: <b><i>Enter</i></b>
Login group testuser [testuser]: <b>guest</b>
Login group is ``guest''. Invite testuser into other groups: guest no
[no]: <b>no</b>
Login class authpf daemon default staff [default]: <b><i>Enter</i></b>
Enter password []: <b><i>Type password, then Enter</i></b>
Enter password again []: <b><i>Type password, then Enter</i></b>

Name:        testuser
Password:    ****
Fullname:    Test FAQ User
Uid:         1002
Gid:         31 (guest)
Groups:      guest
Login Class: default
HOME:        /home/testuser
Shell:       /bin/ksh
OK? (y/n) [y]: <b>y</b>
Added user ``testuser''
Copy files from /etc/skel to /home/testuser
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<p>
Um Benutzer zu entfernen, solltest du das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rmuser&amp;sektion=8">rmuser(8)</a>-Werkzeug
nutzen. Dieses wird jegliche Existenz eines Benutzers löschen. Es wird
jegliche
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=1">crontab(1)</a>-Einträge
entfernen, sein $HOME-Verzeichnis (wenn es dem Benutzer gehört) und
seine Mails. Selbstverständlich wird es ebenfalls seine
<i>/etc/passwd</i>- und <i>/etc/group</i>-Einträge löschen. Als nächstes
folgt ein Beispiel, in dem der Benutzer, der gerade hinzugefügt wurde,
wieder gelöscht wird. Achte darauf, dass du nach dem Namen gefragt wirst
und ob du das Heimatverzeichnis des Benutzers löschen möchtest oder
nicht.

<blockquote><pre>
# <b>rmuser</b>
Enter login name for user to remove: <b>testuser</b>
Matching password entry:

testuser:$2a$07$ZWnBOsbqMJ.ducQBfsTKUe3PL97Ve1AHWJ0A4uLamniLNXLeYrEie:1002
:31::0:0:Test FAQ User:/home/testuser:/bin/ksh

Is this the entry you wish to remove? <b>y</b>
Remove user's home directory (/home/testuser)? <b>y</b>
Updating password file, updating databases, done.
Updating group file: done.
Removing user's home directory (/home/testuser): done.
</pre></blockquote>

<a name="user"></a>
<h3>Benutzer mit user(8) hinzufügen</h3>

<p>
Diese Tools sind nicht so interaktiv wie das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>-Kommando,
wodurch sie einfacher in Skripten genutzt werden können.

<p>
Die gesamte Palette dieser Tools ist:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=8">group(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupadd&amp;sektion=8">groupadd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupdel&amp;sektion=8">groupdel(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupinfo&amp;sektion=8">groupinfo(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupmod&amp;sektion=8">groupmod(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=user&amp;sektion=8">user(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=useradd&amp;sektion=8">useradd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userdel&amp;sektion=8">userdel(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userinfo&amp;sektion=8">userinfo(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=usermod&amp;sektion=8">usermod(8)</a>
</ul>

<h4>Benutzer tatsächlich hinzufügen</h4>

<p>
Das Kommando <i>/usr/sbin/user</i> ist nur ein Frontend für den Rest der
<i>/usr/sbin/user*</i>-Kommandos.
Deshalb können die folgenden Kommandos sowohl per <b>user add</b> als auch per
<b>useradd</b> hinzugefügt werden,
wobei die Form hier am Ergebnis nichts ändert.
Erinnere: Da user(8) nicht interaktiv ist, ist adduser(8) der einfachste Weg,
Benutzer hinzuzufügen.

<p>
useradd(8) ist weniger entmutigend zu nutzen, wenn die Standardeinstellungen im
voraus bekannt sind.
Diese Einstellungen befinden sich in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=usermgmt.conf&amp;sektion=5"
>usermgmt.conf(5)</a> und können wie folgt angezeigt werden:

<blockquote><pre>
$ <b>user add -D</b>
group           users
base_dir        /home
skel_dir        /etc/skel
shell           /bin/csh
inactive        0
expire          Null (unset)
range           1000..60000
</pre></blockquote>

<p>
Diese Standards werden benutzt solange über Kommandozeilenoptionen keine
Alternativen spezifiziert werden.
Wenn zum Beispiel der Benutzer zur Gruppe <b>guest</b>, anstatt zur Gruppe
<b>users</b> hinzugefügt werden soll.
Eine weitere kleine Hürde beim Hinzufügen von Benutzern ist es, dass Passwörter
auf der Kommandozeile angegeben werden müssen.
Wichtiger, die Passwörter müssen verschlüsselt sein, sodass man das
Dienstprogramm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=encrypt&amp;sektion=1"
>encrypt(1)</a> benutzen muss.
Zum Beispiel: OpenBSDs Passwörter werden standardmäßig unter Verwendung des
Blowfish-Algorithmus mit 6 Runden verschlüsselt. Hier ist eine
Beispielzeile, die zeigt, wie man ein verschlüsseltes Passwort
erstellt, das man dann useradd(8) übergibt.

<blockquote><pre>
$ <b>encrypt -p -b 6</b>
Enter string:
$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq
</pre></blockquote>

<p>
Nun, da wir unser verschlüsseltes Passwort haben, sind wir bereit,
den Benutzer hinzuzufügen.
Wir fügen denselben Benutzer mit denselben Spezifikationen hinzu, den wir
weiter <a href="#adduser">oben</a> via adduser(8) hinzugefügt haben.

<blockquote><pre>
# <b>user add -p '$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq' -u 1002 \
-s /bin/ksh -c "Test FAQ User" -m -g guest testuser</b>
</pre></blockquote>

<p>
<b>Hinweis:</b> Stelle sicher, dass du '&nbsp;' (einfache
Anführungszeichen) um die Passwortzeichenkette legst, nicht etwa
"&nbsp" (doppelte Anführungszeichen), da die Shell diese
vor dem Übergeben an user(8) auswerten würde. Stelle zusätzlich dazu
sicher, dass du Option <b>-m</b> übergibst, wenn du möchtest, dass das
Heimatverzeichnis vom Benutzer angelegt und die Dateien aus
<i>/etc/skel</i> herüberkopiert werden.

<p>
Um zu sehen, ob der Benutzer korrekt angelegt wurde, können wir viele
verschiedene Werkzeuge nutzen. Unterhalb stehen ein paar Kommandos,
du du benutzen kannst, um schnell zu überprüfen, ob alles richtig
gemacht wurde.

<blockquote><pre>
$ <b>ls -la /home</b>
total 14
drwxr-xr-x   5 root      wheel   512 May 12 14:29 .
drwxr-xr-x  15 root      wheel   512 Apr 25 20:52 ..
drwxr-xr-x  24 ericj     wheel  2560 May 12 13:38 ericj
drwxr-xr-x   2 testuser  guest   512 May 12 14:28 testuser
$ <b>id testuser</b>
uid=1002(testuser) gid=31(guest) groups=31(guest)
$ <b>finger testuser</b>
Login: testuser                         Name: Test FAQ User
Directory: /home/testuser               Shell: /bin/ksh
Last login Sat Apr 22 16:05 (EDT) on ttyC2
No Mail.
No Plan.
</pre></blockquote>

<p>
Zusätzlich zu diesen Kommandos bietet user(8) sein eigenes Werkzeug,
um Benutzercharakteristiken anzuzeigen, welches userinfo(8) genannt
wird.

<blockquote><pre>
$ <b>userinfo testuser</b>
login   testuser
passwd  *
uid     1002
groups  guest
change  Wed Dec 31 19:00:00 1969
class
gecos   Test FAQ User
dir     /home/testuser
shell   /bin/ksh
expire  Wed Dec 31 19:00:00 1969
</pre></blockquote>

<h4>Benutzer löschen</h4>

<p>
Um Benutzer mit Kommandos der user(8)-Hierarchie zu entfernen, wirst
du userdel(8) nutzen müssen. Dies ist ein sehr einfaches, aber dennoch
sehr nützliches, Kommando. Um den Benutzer zu löschen, der im letzten
Beispiel angelegt wurde, verwende einfach:

<blockquote><pre>
# <b>userdel -r testuser</b>
</pre></blockquote>

<p>
Beachte die Option <b>-r</b>, die angegeben werden muss, wenn du
möchtest, dass das Heimatverzeichnis des Benutzers ebenfalls gelöscht
werden soll. Als Alternative dazu kannst du statt <b>-r</b> auch
<b>-p</b> angeben, wodurch der Account des Benutzers gesperrt wird,
aber keine Informationen gelöscht werden.

<p>
<a name= "FTPOnly"></a>
<h2>10.10 - Wie erzeugt man ein Benutzerkonto, das nur für FTP genutzt
werden kann?</h2>

<p>
Es gibt ein paar Wege, das zu bewerkstelligen, aber ein sehr
häufig genutzter Weg ist, <tt>/usr/bin/false</tt> in
<tt>/etc/shells</tt> einzufügen. Wenn du dann die Shell eines
Benutzers auf <tt>/usr/bin/false</tt> setzt, wird dieser Benutzer
nicht in der Lage sein, sich interaktiv anzumelden, kann aber noch
die FTP-Möglichkeiten nutzen. Du möchtest vielleicht ebenfalls den
Zugriff beschränken, indem du <a href="#ftpchroot">Benutzer unter
ftpd in ihre Heimatverzeichnisse einsperrst</a>.


<p>
<a name= "Quotas"></a>
<h2>10.11 - Quotas einrichten</h2>

<p>
Quotas werden genutzt, um den Speicher auf den Platten zu begrenzen, der
den Benutzern zur Verfügung steht. Das kann insbesondere dann sinnvoll
sein, wenn du Ressourcen begrenzen musst. Quotas können für Benutzer
und/oder für Gruppen gesetzt werden.

<p>
Der erste Schritt, um Quotas einzurichten, ist sicherzustellen, dass
»<tt>option QUOTA</tt>« sich in deiner
<a href="faq5.html#Options">Kernelkonfiguration</a> befindet. Diese
Option ist im GENERIC-Kernel. Hiernach musst du die Dateisysteme in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"><tt>/etc/fstab</tt></a>
markieren, für die Quotas aktiviert sein sollen.
Die Schlüsselwörter <tt>userquota</tt> und <tt>groupquota</tt> sollten
verwendet werden, um jedes einzelne Dateisystem zu markieren, für die
Quotas aktiviert sein sollen. Standardmäßig werden die Dateien
<tt>quota.user</tt> und <tt>quota.group</tt> im Root der Dateisysteme
erstellt, um die Quota-Informationen zu erfassen. Dieser Standard kann
geändert werden, indem der Dateiname mit der Quota-Option in
<tt>/etc/fstab</tt> angegeben wird, wie zum Beispiel
<tt>userquota=/var/quotas/quota.user</tt>.
Hier ist ein Beispiel für eine <tt>/etc/fstab</tt>, die ein Dateisystem
mit aktivierten userquotas hat und die Quotadatei sich an einer
nicht standardmäßigen Stelle befindet:

<blockquote><pre>
/dev/wd0a / ffs rw,userquota=/var/quotas/quota.user 1 1
</pre></blockquote>

<p>
Jetzt ist es Zeit, um die Quotas für die Benutzer einzurichten. Verwende
hierfür das Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=edquota&amp;sektion=8">edquota(8)</a>.
Ein einfacher Aufruf wäre »<tt>edquota&nbsp;&lt;user&gt;</tt>«. edquota(8)
wird vi(1) nutzen, um die Quotas zu ändern, es sei denn, die
Umgebungsvariable EDITOR wurde auf einen anderen Editor gesetzt. Zum
Beispiel:

<blockquote><pre>
# <b>edquota ericj</b>
</pre></blockquote>

<p>
Dies wird dir eine Ausgabe geben, die ähnlich dieser ist:

<blockquote><pre>
Quotas for user ericj:
/: KBytes in use: 62, limits (soft = 0, hard = 0)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Um Begrenzungen hinzuzufügen, editiere sie, um Resultate
wie diese hier zu erhalten:

<blockquote><pre>
Quotas for user ericj:
/: KBytes in use: 62, limits (soft = 1000, hard = 1050)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Beachte, dass die Quota-Allokierung auf 1-k-Blöcke gesetzt ist.
In diesem Fall wurde das Softlimit auf 1000 k gesetzt und das
Hardlimit auf 1050 k. Ein Softlimit ist eine Begrenzung, bei der der
Benutzer lediglich gewarnt wird, dass er sie überschritten hat und
weiterhin über ihr liegt, bis ihre Schonzeit vorbei ist und ihre
Plattennutzung wieder unter diese Grenze reduziert wird. Schonzeiten
können mit edquota(8) und der Option <b>-t</b> gesetzt werden.
Wenn die Schonzeit vorbei ist, dann wird das Softlimit als Hardlimit
angesehen. Dies führt normalerweise zu Allokierungsfehlern.

<p>
Nun, da die Quotas gesetzt sind, musst du die Quotas aktivieren. Um dies
zu tun, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quotaon&amp;sektion=8">quotaon(8)</a>.
Zum Beispiel:

<blockquote><pre>
# <b>quotaon -a</b>
</pre></blockquote>

<p>
Dies wird durch <tt>/etc/fstab</tt> gehen und alle Dateisysteme mit
Quota-Optionen aktivieren. Nun, da Quotas eingerichtet sind und laufen,
kannst du sie mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quota&amp;sektion=1">quota(1)</a>.
betrachten. Die Nutzung von einem Kommando wie
»<tt>quota &lt;user&gt;</tt>« gibt dir die Informationen über einen
Benutzer. Wenn es mit keinen Argumenten aufgerufen wird, wird das
quota(1)-Kommando deine Quota-Statistiken ausgeben. Zum Beispiel:

<blockquote><pre>
# <b>quota ericj</b>
</pre></blockquote>

<p>
Wird zu einer Ausgabe führen, die dieser ähnlich ist:

<blockquote><pre>
Disk quotas for user ericj (uid 1001):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
              /      62    1000    1050              27       0       0
</pre></blockquote>

<p>
Standardmäßig werden Quotas, die in <tt>/etc/fstab</tt> gesetzt sind,
automatisch beim Hochfahren aktiviert. Um sie auszuschalten, verwende:

<blockquote><pre>
# <b>quotaoff -a</b>
</pre></blockquote>

<p>
<a name= "Kerberos"></a>
<h2>10.12 - KerberosV-Clients und -Server einrichten</h2>

<p>
OpenBSD beinhaltet KerberosV als vorinstallierte Komponente des
Standardsystems.

<p>
Für weitere Informationen über KerberosV rufe folgendes Kommando von
deinem OpenBSD-System aus auf:
<blockquote><pre>
# <b>info heimdal</b>
</pre></blockquote>


<p>
<a name= "AnonFTP"></a>
<h2>10.13 - Anonymous-FTP-Dienste einrichten</h2>

<p>
Anonymous FTP erlaubt Benutzern ohne Accounts, auf Dateien auf deinem
Computer über das »File Transfer Protocol« zuzugreifen. Dies hier gibt
einen Überblick über das Einrichten eines Anonymous-FTP-Servers,
dem Aufzeichnen (logging) dieses Servers etc.

<h3>Das FTP-Benutzerkonto hinzufügen</h3>

<p>
Um beginnen zu können, musst du einen <i>ftp</i>-Account auf deinem System
haben. Dieser Account sollte kein nutzbares Passwort haben. Hier werden
wir das Login-Verzeichnis auf /home/ftp setzen, aber du kannst es
wohin du willst legen. Wenn Anonymous FTP genutzt wird, wird der
FTP-Daemon sich selbst in das Heimatverzeichnis des <i>ftp</i>-Users
chrooten. Um mehr hierüber zu erfahren, lies die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>-
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>-Handbuchseiten.
Hier ist ein Beispiel, wie man den Benutzer <i>ftp</i> hinzufügt. Ich
werde das unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>
machen.
Wir müssen ebenfalls /usr/bin/false in unsere <i>/etc/shells</i>
hinzufügen, dies ist die Shell, die wir dem <i>ftp</i>-User zuteilen.
Dies erlaubt ihnen nicht, sich einzuloggen, selbst wenn wir ihm ein
leeres Passwort geben. Um das zu tun, kannst du einfach Folgendes
ausführen:

<blockquote><pre>
echo /usr/bin/false &gt;&gt; /etc/shells
</pre></blockquote>

Hiernach ist alles vorbereitet, sodass der <i>ftp</i>-Benutzer
hinzugefügt werden kann:

<blockquote><pre>
# <b>adduser</b>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>ftp</b>
Enter full name []: <b>anonymous ftp</b>
Enter shell csh false ksh nologin sh [ksh]: <b>false</b>
Uid [1002]: <b><i>Enter</i></b>
Login group ftp [ftp]: <b><i>Enter</i></b>
Login group is ``ftp''. Invite ftp into other groups: guest no
[no]: <b>no</b>
Login class authpf daemon default staff [default]: <b><i>Enter</i></b>
Enter password []: <b><i>Enter</i></b>
Set the password so that user cannot logon? (y/n) [n]: <b>y</b>

Name:        ftp
Password:    ****
Fullname:    anonymous ftp
Uid:         1002
Gid:         1002 (ftp)
Groups:      ftp
Login Class: default
HOME:        /home/ftp
Shell:       /usr/bin/false
OK? (y/n) [y]: <b>y</b>
Added user ``ftp''
Copy files from /etc/skel to /home/ftp
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<h3>Verzeichniseinrichtung</h3>

<p>
Neben dem Benutzer wurde hiermit das Verzeichnis <i>/home/ftp</i>
angelegt. Das ist genau das, was wir wollen, aber es müssen einige
Änderungen vorgenommen werden, die wir machen müssen, um es für
Anonymous FTP bereit zu machen. Es sei wieder erwähnt, dass diese
Änderungen in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>-Handbuchseite
beschrieben werden.

<p>
Du <b>musst nicht</b> ein Verzeichnis namens /home/ftp/usr oder
/home/ftp/bin erstellen.
<ul>
<li><i>/home/ftp</i> - Dieses ist das Hauptverzeichnis. Es sollte root
gehören und die Rechte 555 haben.
<li><i>/home/ftp/etc</i> - Dieses ist vollkommen optional und nicht
empfohlen, da es nur dazu dient, Informationen über Benutzer
herauszugeben, die es auf deinem System gibt. Wenn du möchtest, dass
dein Anonymous-FTP-Verzeichnis so wirkt, als wenn deine Dateien
echten Benutzern gehören, solltest du /etc/pwd.db und /etc/group in
dieses Verzeichnis kopieren. Dieses Verzeichnis sollte die Rechte 511
haben und die beiden Dateien die Rechte 444. Diese werden benötigt, um
Benutzernamen in Abhängigkeit der Nummern zuzuweisen. Es werden keine
Passwörter in pwd.db gespeichert, die sind all in spwd.db, sodass du
die Datei nicht hineinkopieren solltest.
<li><i>/home/ftp/pub</i> - Dieses ist das Standardverzeichnis, in das
Dateien gelegt werden sollten, die du zur Verfügung stellen willst.
Dieses Verzeichnis sollte ebenfalls die Rechte 555 haben.
</ul>

<p>
Beachte, dass alle Verzeichnisse Root gehören sollten. Hier ist eine
Liste, wie die Verzeichnisse nach der Erstellung aussehen sollten.

<blockquote><pre>
# pwd
/home
# ls -laR ftp
total 5
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 .
drwxr-xr-x  7 root  wheel  512 Jul  6 10:58 ..
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 etc
dr-xr-xr-x  2 root  ftp    512 Jul  6 11:33 pub

ftp/etc:
total 43
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 .
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 ..
-r--r--r--  1 root  ftp    316 Jul  6 11:34 group
-r--r--r--  1 root  ftp  40960 Jul  6 11:34 pwd.db

ftp/pub:
total 2
dr-xr-xr-x  2 root  ftp  512 Jul  6 11:33 .
dr-xr-xr-x  5 root  ftp  512 Jul  6 11:33 ..
</pre></blockquote>

<h3>Den Server und das Aufzeichnen starten</h3>

<p>
Du kannst ftpd entweder über
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
oder von den <a href="#rc">rc</a>-Skripten aus starten.
Diese Beispiele zeigen, wie unser Daemon von inetd.conf aus
aufgerufen wird. Zuerst müssen wir uns mit den Optionen für ftpd
vertraut machen. Der Standardeintrag in <i>/etc/inetd.conf</i> sieht
wie folgt aus:

<blockquote><pre>
<b>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -US</b>
</pre></blockquote>

<p>
Hier wird ftpd mit <i>-US</i> augerufen. Hiermit werden alle
anonymen Verbindungen unter <i>/var/log/ftpd</i> aufgezeichnet und
zusammenwirkende Verbindungen unter <i>/var/run/utmp</i>. Somit können
diese Sitzungen per who(1) angesehen werden. Für einige gilt, dass sie
nur einen Anonymous-Server starten wollen und somit ftp für Benutzer
deaktivieren sollten. Rufe hierzu ftpd mit der Option <i>-R</i> auf.
Hier ist eine Zeile, die ftpd so startet, dass nur anonyme Verbindungen
zugelassen werden. Es verwendet ebenfalls <i>-ll</i>, wodurch jede
Verbindung mit syslog aufgezeichnet wird, zusätzlich zu den
FTP-Kommandos get, retrieve etc.

<blockquote><pre>
<b>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -llUSA</b>
</pre></blockquote>

<p>
<b>Hinweis:</b> Leute, die FTP-Server mit HOHER Netzauslastung
verwenden, sollten ftpd nicht von inetd.conf aus aufrufen. Die beste
Möglichkeit ist, die Zeile für ftpd aus inetd.conf zu kommentieren und
ftpd von rc.conf.local mit der Option <i>-D</i> aus zu starten. Somit
wird ftpd als Daemon gestartet, was weniger zusätzliche Auslastung
bewirkt als wenn der Start von inetd aus erfolgt.
Hier ist eine Beispielzeile, wenn der Start von rc.conf.local aus
erfolgt.

<blockquote><pre>
ftpd_flags="-DllUSA"           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Dies funktioniert selbstverständlich nur, wenn du ftpd aus
<i>/etc/inetd.conf</i> rausgenommen und inetd veranlasst hast, die
Konfigurationsdatei neu einzulesen.

<p>
Um anonyme Verbindungen zu erlauben, ist es ist nicht nötig, weitere,
zusätzliche Startoptionen zu übergeben.
Die vorangehenden Schritte des Erzeugens des Benutzers »ftp«, und der
Konfiguration der relevanten Verzeichnisse mit den korrekten Rechten ist genug.
Auf der anderen Seite ist es nicht nötig, alles rückgängig zu machen, wenn man
anonyme Verbindungen nicht länger gestatten will.
Starte ftpd einfach neu, einschließlich der Option <b>-n</b>.
Anonyme Verbindungen sind in diesem Fall nicht länger möglich.

<h3>Andere relevante Dateien</h3>

<ul>
<li><i>/etc/ftpwelcome</i> - Diese beinhaltet die Willkommensnachricht
für Personen, wenn sie sich mit deinem FTP-Server verbunden haben.
<li><i>/etc/motd</i> - Diese beinhaltet die Nachricht für Personen,
die sich erfolgreich an deinem FTP-Server angemeldet haben.
<li><i>.message</i> - Diese Datei kann in beliebige Verzeichnisse gelegt
werden. Sie wird angezeigt, sobald ein Benutzer in das Verzeichnis
wechselt.
</ul>


<p>
<a name= "ftpchroot"></a>
<h2>10.14 - In ftpd(8) Benutzer in ihre Heimatverzeichnisse
einsperren.</h2>

<p>
Standardmäßig können Benutzer, wenn sie sich über ftp angemeldet haben,
in jedes Verzeichnis auf deinem Dateisystem wechseln, wenn sie die
benötigten Rechte dafür haben.
In einigen Fällen kann es sein, dass das nicht erwünscht ist.
Es ist möglich, einzuschränken, was Benutzer über die FTP-Sitzung
sehen können, indem man sie in ihr Heimatverzeichnis einsperrt.

<p>
Wenn du nur in Chroot eingeschlossene FTP-Anmeldungen erlauben willst,
verwende die Option <b>-A</b> mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>.

<p>
Wenn du diese Begrenzung gezielter einsetzen willst, macht OpenBSDs
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=login.conf&amp;sektion=5">login
capability infrastructure</a>« zusammen mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>
das recht einfach.
<p>

Benutzer, die sich in einer Login-Klasse mit der gesetzten Variable
<tt>ftp-chroot</tt> befinden, werden automatisch in Chroot eingeschlossen.
Zusätzlich kannst du einen Benutzernamen zur Datei <b>/etc/ftpchroot</b>
hinzufügen, damit Chroot auch für diese Benutzer genutzt wird.
Ein Benutzer muss nur in einer dieser Orte aufgelistet werden.


<p>
<a name= "Patches"></a>
<h2>10.15 - Korrekturroutinen in OpenBSD einfügen.</h2>

<p>
Selbst unter OpenBSD treten Fehler auf.
Einige Fehler können zu Stabilitätsproblemen führen (z.&nbsp;B. dass etwas
dazu führen kann, dass etwas nicht mehr wie gewünscht funktioniert).
Andere Fehler könnten zu Sicherheitsproblemen führen (wodurch Andere
deinen Computer auf nicht beabsichtigte und nicht authorisierte Weise
»benutzen« können).
Wenn ein kritischer Fehler gefunden wurde, wird die Korrektur in den
<i>-current</i>-Quelltextbaum hinzugefügt und Korrekturroutinen für die
<a href="faq5.html#Flavors">unterstützten Releases</a> von OpenBSD
bereitgestellt.
Diese Korrekturroutinen werden auf der
<a href="../../de/errata.html">Errata-Webseite</a> aufgelistet,
wo sie in »gemeinsame« Errata, die für alle
<a href="../../de/plat.html">Plattformen</a> gelten,
und in solche, die nur für eine oder mehrere, nicht jedoch für alle Plattformen
gelten, unterteilt werden.

<p>
Bedenke jedoch, dass für neue Eigenschaften von, oder zusätzlichen
Hardwaresupport für OpenBSD keine Korrekturroutinen veröffentlicht werden,
und somit nur für wichtige Stabilitäts- oder
Sicherheitskorrekturen veröffentlicht werden, die sofort auf den betroffenen
Systemen eingespielt werden sollten (was meist NICHT für alle Systeme
gilt, je nach ihrem Anwendungsgebiet).

<p>
Es existieren drei Wege, wie du dein System mit korrigiertem Code
aktualisieren kannst:

<ul>
<li><b>Dein System auf <a href="../current.html"><i>-current</i></a>
upgraden.</b>
Da alle Korrekturen in die Codebasis von <i>-current</i> übernommen
werden, ist das Aktualisieren deines Systems auf den aktuellsten
Schnappschuss eine gute Möglichkeit, korrigierten Code zu nutzen.
Jedoch ist der Einsatz von <i>-current</i> nicht für jeden geeignet.
<li><b>Dein System auf <a href="../../de/stable.html"><i>-stable</i>
aktualisieren</a>.</b>
Dies wird gemacht, indem du deinen Quelltextbaum unter Verwendung des
dazu passenden <i>-stable</i>-Zweigs herunterlädst oder
aktualisierst, und dann den Kernel und die Dateien des Userland neu
übersetzt.
Generell ist das die einfachste Möglichkeit, obwohl sie länger dauern kann (da
das gesamte System neu übersetzt wird) und das Erstellen einer vollständigen
Arbeitskopie der Quelltexte eine lange Zeit in Anspruch nehmen kann, wenn deine
Bandbreite begrenzt ist.
<li><b>Pflege die Korrekturroutinen in deinen Quelltext ein, übersetze sie und
installiere einzelne, betroffene Dateien.</b>
Dies werden wir in unserem Beispiel weiter unten machen.
Obwohl diese Methode weniger Bandbreite und normalerweise auch weniger
Zeit in Anspruch nimmt als ein »checkout«/Update per cvs(1) und das
dazugehörige Übersetzen des Quelltextes, ist diese Methode manchmal
auch die schwierigste, da es keinen allgemein gültigen Instruktionssatz
gibt, den man befolgen könnte.
Manchmal musst du lediglich eine Applikation korrigieren, neu übersetzen
und installieren, manchmal aber auch ganze Sektionen des Baums, wenn
das Problem sich in einer Bibliotheksdatei befindet.
</ul>

Noch einmal: Das korrigieren von individuellen Dateien ist nicht immer
einfach, denke also gründlich darüber nach, ob du nicht dem
<a href="../../de/stable.html"><i>-stable</i></a> Zweig (oder »patch-branch«)
von OpenBSD folgen willst.
Das Kombinieren und Anpassen von Korrekturlösungen kann durchgeführt werden,
wenn man weiß, wie alles funktioniert, aber neue Benutzer sollten eine
Methode auswählen und bei dieser bleiben.

<h3>Wie unterscheiden sich die Errata-Korrekturen von dem, was sich im
CVS-Baum befindet?</h3>

<p>
Alle Korrekturroutinen, die auf der
<a href="../../de/errata.html">Errata-Webseite</a> landen, sind solche,
die direkt auf den Quelltextbaum vom angegebenen Release abgestimmt sind.
Korrekturen, die für den aktuellen CVS-Baum sind, beinhalten auch andere
Änderungen, die auf einem Release-System nicht gewollt sind.
Dies ist wichtig: Wenn du einen Schnappschuss installierst hast, eine
Arbeitskopie des Quelltextbaums zu jener Zeit gemacht hast, als du den
Schnappschuss heruntergeladen hast, und dann versuchst, eine freigegebene
Korrekturroutine zu verwenden, wirst du eventuell feststellen, dass diese
Korrektur nicht anwendbar ist, da der Quelltext sich vermutlich geändert hat.



<h3>Korrekturroutinen anwenden.</h3>

<p>
Korrekturroutinen (»patches«) für das OpenBSD-Betriebssystem werden als
»Unified diffs« verteilt; dies sind Textdateien, die Unterschiede zum
ursprünglichen Quelltext beschreiben.
Sie werden <b>NICHT</b> in Binärform verteilt.
Das heisst das zur Einspielung der Korrekturroutine der Quelltext der
<b>RELEASE</b>-Version auf dem System vorhanden sein muss.
Im Allgemeinen gilt, dass es ratsam ist, sich den kompletten Baum des
Quelltexts zu besorgen, bevor man eine Korrekturroutine anwendet.
Wird eine Veröffentlichung von einem offiziellen CD-ROM-Set benutzt, so ist der
Quelltext in Dateiform auf Scheibe 3 verfügbar, aber die Dateien können auch
von den <a href="../../de/ftp.html">FTP-Servern</a> heruntergeladen werden.
Wir nehmen an im Folgenden an, dass ein kompletter Baum vorliegt.

<p>
Für unser Beispiel hier betrachten wir die Korrektur 001 für OpenBSD 3.6,
der sich mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=st&amp;sektion=4">st(4)</a>-Treiber
befasst, der für die Verarbeitung von Bandlaufwerken zuständig ist.
Ohne diese Korrektur war die Wiederherstellung von Sicherungsdaten recht
schwierig.
Leute, die ein Bandlaufwerk nutzten, <i>brauchten</i> diesen »Patch«,
solche ohne ein Bandlaufwerk jedoch hatten keinen besonderen Bedard, ihn zu
installieren.
Lass uns einen Blick auf die Korrekturroutine werfen:

<blockquote><pre>
# <b>more 001_st.patch</b>
Apply by doing:
        cd /usr/src
        patch -p0 < 001_st.patch

Rebuild your kernel.

Index: sys/scsi/st.c
===================================================================
RCS file: /cvs/src/sys/scsi/st.c,v
retrieving revision 1.41
retrieving revision 1.41.2.1
diff -u -p -r1.41 -r1.41.2.1
--- sys/scsi/st.c       1 Aug 2004 23:01:06 -0000       1.41
+++ sys/scsi/st.c       2 Nov 2004 01:05:50 -0000       1.41.2.1
@@ -1815,7 +1815,7 @@ st_interpret_sense(xs)
        u_int8_t skey = sense->flags & SSD_KEY;
        int32_t info;

-       if (((sense->flags & SDEV_OPEN) == 0) ||
+       if (((sc_link->flags & SDEV_OPEN) == 0) ||
            (serr != 0x70 && serr != 0x71))
                return (EJUSTRETURN); /* let the generic code handle it */
</pre></blockquote>

Wie du sehen kannst, befindet sich am Anfang der Korrektur eine kurze
Einweisung, wie er eingefügt werden kann.
Wir nehmen an, dass du ihn in das Verzeichnis <tt>/usr/src</tt> gelegt
hast, wodurch in diesem Fall folgende Schritte gemacht werden müssen:

<blockquote><pre>
# <b>cd /usr/src</b>
# <b>patch -p0 &lt; 001_st.patch</b>
Hmm...  Looks like a unified diff to me...
The text leading up to this was:
--------------------------
|Apply by doing:
|        cd /usr/src
|        patch -p0 < 001_st.patch
|
|Rebuild your kernel.
|
|Index: sys/scsi/st.c
|===================================================================
|RCS file: /cvs/src/sys/scsi/st.c,v
|retrieving revision 1.41
|retrieving revision 1.41.2.1
|diff -u -p -r1.41 -r1.41.2.1
|--- sys/scsi/st.c      1 Aug 2004 23:01:06 -0000       1.41
|+++ sys/scsi/st.c      2 Nov 2004 01:05:50 -0000       1.41.2.1
--------------------------
Patching file sys/scsi/st.c using Plan A...
Hunk #1 succeeded at 1815.              <i>&lt;-- Look for this message!</i>
done
</pre></blockquote>

Achte auf die obrige Nachricht "<tt>Hunk #1 succeeded</tt>".
Diese weist darauf hin, dass die Korrektur erfolgreich eingefügt wurde.
Viele Korrekturen sind viel komplexer als diese hier und werden viele
Hunks und mehrere Dateien miteinbeziehen, daher solltest du in einem
solchen Fall sicherstellen, dass alle Hunks für alle Dateien
erfolgreich waren.
Wenn sie es nicht waren, heißt das normalerweise, dass dein Quelltextbaum
sich in irgendeiner Weise von dem Quelltextbaum der Veröffentlichung
unterscheidet, von welchem aus die Korrekturroutine erzeugt wurde,
oder dass du den Anweisungen nicht gründlich gefolgt bist,
oder aber die Korrekturroutine verunstaltet wurde.
Korrekturen sind sehr sensibel gegenüber Leerstellen - Copy&Paste von
deinem Browser wird oft Tabulatoren in Leerstellen umwandeln oder auf
andere Art und Weise die Leerstellen der Datei modifizieren, wodurch er
nicht eingefügt werden kann.

<p>
An diesem Punkt kannst du wie gewohnt den neuen Kernel
<a href="faq5.html#BldKernel">erzeugen und installieren</a>,
und danach das System neu starten.

<p>
Nicht alle Korrekturroutinen sind für den Kernel.
In einigen Fällen musst du individuelle Werkzeuge neuerzeugen. In
anderen Fällen musst du alle statisch gelinkten Werkzeuge
neukompilieren, da sich eine Bibliothek änderte.
Folge den Anweisungen am Anfang der Korrektur, und wenn du dir unsicher
bist, erstelle das gesamte System neu.

<p>
Korrekturen, die für bestimmte Systeme unbedeutend sind, müssen nicht
mit eingefügt werden - normalerweise.
Wenn du zum Beispiel kein Bandlaufwerk auf deinem System hattest,
würdest du von oben gezeigter Korrektur nicht profitieren.
Man nimmt jedoch an, dass die Korrekturroutinen »in der richtigen Reihenfolge«
eingefügt werden - es ist möglich, dass eine spätere Routine von einer
vorherigen abhängig ist. Sei dir dessen bewusst, wenn du dich dafür
entscheidest, bei der Installation von Korrekturen ,wählerisch' zu sein, so
dass du, wenn du dir unsicher bist, alle installieren solltest.

<p>
<a name="httpdchroot"></a>
<h2>10.16 - Wie geht das mit dem chroot()-Apache?</h2>

<p>
Unter OpenBSD wird der Apache-Server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
standardmäßig in einer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a> eingeschlossen.
Obwohl dies ein ungeheurer Sicherheitsvorteil ist, kann das zu Problemen
führen, wenn man nicht darauf vorbereitet ist.

<h3>Was ist ein chroot?</h3>

Eine in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>
eingeschlossene Anwendung wird in ein bestimmtes Verzeichnis eingesperrt
und ist nicht in der Lage, im Rest der Verzeichnisstruktur herumzuwandern,
da es das Verzeichnis als <tt>/</tt> (Root-)Verzeichnis sieht.
Im Fall von httpd(8) startet das Programm, öffnet seine Logdateien,
greift auf seine TCP-Ports zu (obwohl es zu diesem Zeitpunkt noch keine
Daten akzeptiert) und liest seine Konfiguration. Als nächstes sperrt es
sich in <i>/var/www</i> ein und lässt seine Privilegien fallen; erst
dann akzeptiert es Anfragen.
Dies bedeutet, dass alle Dateien, die von Apache zur Verfügung gestellt
und benutzt werden, sich im Verzeichnis <i>/var/www</i> befinden müssen.
In der Standardkonfiguration von OpenBSD kann der Apache-User
<i>www</i> die Dateien im <i>/var/www</i>-Verzeichnis nur lesen.
Dies hilft der Sicherheit ungemein - sollte es ein Sicherheitsproblem
mit Apache geben, wird der Schaden auf ein einziges Verzeichnis
begrenzt sein, dessen Rechte nur das Lesen erlauben und auch keine
Ressourcen hat, die jemand ausnutzen könnte.

<h3>Was bedeutet das für den Administrator?</h3>

<p>
Grob gesagt ist chroot(2)ing Apache etwas, das nicht standardmäßig
unter anderen Betriebssystemen eingesetzt wird.
Viele Applikationen und Systemkonfigurationsdateien werden in einem
chroot(2) ohne Anpassungen nicht funktionieren. Zusätzlich muss erwähnt
werden, dass sich Sicherheit und Komfort als Ziel gegenseitig
ausschließen. OpenBSDs Implementation von Apache gefährdet die
Sicherheit nicht, um Funktionen oder »Bequemlichkeiten« zu ermöglichen.

<ul>
<li><b>Historische Dateisystemlayouts:</b> Server, die von einer
älteren Version von OpenBSD upgegradet wurden, haben eventuell
Dateien im Verzeichnis der Benutzer liegen, welche selbstverständlich
nicht in einer chroot(2)-Umgebung funktionieren werden, da httpd(8)
das Verzeichnis <i>/home</i> nicht erreichen kann. Administratoren
werden vielleicht ebenfalls feststellen, dass die Partition von
/var/www zu klein ist, um alle Webdateien zu halten. Deine Möglichkeiten
sind zum Einen das Neustrukturieren oder das Ausschalten der
chroot(2)-Funktionalität. Du kannst selbstverständlich symbolische
Links von den Heimatverzeichnissen der Benutzer verwenden, die dann auf
Unterverzeichnisse von <i>/var/www</i> verweisen, aber du kannst
NICHT Links unter <i>/var/www</i> nutzen, die auf andere Teile des
Dateisystems verweisen - dies wird durch das chroot(2) verhindert.
Wenn du deinen Benutzern <a
href="faq10.html#ftpchroot">chroot(2)-geschützten FTP-Zugriff</a>
ermöglichen möchtest, musst du daran denken, dass das dann nicht
funktionieren wird, da der FTP-Chroot (wieder einmal)
den Zugriff auf die Ziele der symbolischen Links verhindern wird.
Eine Lösung hierfür ist es, nicht <i>/home</i> als Heimatverzeichnis
für solche Anwender zu benutzen sondern stattdessen etwas wie
<i>/var/www/users</i>. Symbolische Links können innerhalb der
chroot(2)-Umgebung verwendet werden - sie müssen aber relativ und
nicht absolut sein.

<li><b>Logrotation:</b> Normalerweise werden Logs rotiert, indem
die alten Dateien umbenannt werden, httpd(8) ein SIGUSR1-Signal
gesendet wird, das Apache dazu veranlasst, die alten Dateien zu
schließen und neue zu öffnen. Dies ist nicht länger möglich, da
httpd(8) nicht mehr in der Lage ist, neue Logdateien zu öffnen, um
in sie zu schreiben, sobald die Privilegien abgegeben worden sind. Daher
muss httpd(8) beendet und neugestartet werden. Es dauert manchmal
ein paar Sekunden, bis alle Kindprozesse beendet wurden. Diese
müssen beendet werden, bevor httpd(8) neugestartet werden kann. Ein
Möglichkeit, die Logs zu rotieren, ist diese:

<blockquote><pre>
# <b>apachectl stop</b>
    <i>rename your log files</i>
# <b>apachectl start ; sleep 10 ; apachectl start</b>
</pre></blockquote>

Ja, die letzte Zeile versucht, Apache sofort neuzustarten. Sollte dies
fehlschlagen, wird es nach einigen Sekunden wieder versucht. Und ja,
das bedeutet auch, dass dein Webserver jedes Mal, wenn deine Logs
rotiert werden, für kurze Zeit nicht erreichbar sein wird. Es mag zwar
nerven, doch würde der Sinn und Zweck des Chroots verworfen werden,
würde man Apache erlauben, Dateien nach dem Chroot(2)en zu öffnen!
Es gibt weitere Strategien hierfür, einschließlich die Möglichkeit,
über eine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pipe&amp;sektion=2">pipe(2)</a>
aufzuzeichnen, und einen externen Logrotator auf der anderen Seite
der pipe(2) einzusetzen.

<li><b>Existierende Apache-Module:</b> Fast alle werden geladen,
jedoch können einige nicht richtig in chroot(2) eingesetzt werden und
viele haben Probleme mit
»<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=apachectl&amp;sektion=8">apachectl</a>
restart</tt>«; sie erzeugen einen Fehler, welcher dazu führt, dass
httpd(8) beendet wird.

<li><b>Existierende CGIs:</b> Die meisten werden NICHT ohne weiteres
eingesetzt werden können. Sie benötigen vermutlich Programme oder
Bibliotheken, die sich außerhalb von <i>/var/www</i> befinden. Einige
können durch Kompilieren statisch gelinkt werden (keine Bibliotheken
in anderen Verzeichnissen werden benötigt), die meisten werden behoben
werden können, indem im <i>/var/www</i> die Verzeichnisse mit den
benötigten Dateien der Applikation angelegt werden, wobei dies nicht
so einfach ist, wie es klingt, und daher Wissen über das Programm
benötigt.

<li><b>Mountoptionen für das Dateisystem:</b>
Standardmäßig wird unter OpenBSD deine <i>/var</i>-Partition mit den
Optionen <tt>nosuid</tt> und <tt>nodev</tt> gemountet. Wenn du eine
Applikation im Chroot ausführen möchtest, so musst du diese Optionen
eventuell ändern. Selbstverständlich kann es auch vorkommen, dass du
diese Optionen ändern musst, wenn du kein Chroot betreibst.

<li><b>Namensauflösung:</b>
httpd(8) innerhalb der chroot(2) wird NICHT in der Lage sein, die
Dateien <i>/etc/hosts</i> und <i>/etc/resolv.conf</i> des Systems zu
verwenden. Daher musst du <i>/var/www/etc/hosts</i> und/oder
<i>/var/www/etc/resolv.conf</i> in der chroot(2)-Umgebung anlegen,
wenn du Anwendungen hast, die Namensauflösung benötigen. Beachte, dass
einige Anwendungen eine funktionierende Auflösung von »localhost«
voraussetzen.

<li><b>Zeitzone:</b>
httpd(8) innerhalb the chroot(2) wird NICHT in der Lage sein die Datei
<i>/etc/localtime</i> des Systems zu nutzen.
Wird die Ereignisprotokollierung in lokaler Zeit benötigt, so muss eine Kopie
(kein Link) der entsprechenden Zeitzone aus <i>/usr/share/zoneinfo/</i> unter
<i>/var/www/etc/localtime</i> erzeugt werden.

</ul>

In einigen Fällen können die Applikation oder die Konfiguration
geändert werden, damit sie im chroot(2) läuft.
In anderen Fällen wirst
du diese Funktionalität einfach unter Verwendung der Option <tt>-u</tt>
mit httpd(8) in der
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"
>/etc/rc.conf.local</a></i> abstellen.


<h3>Beispiel einer Einschließung einer Applikation in chroot(2):
wwwcount</h3>
Als ein Beispiel für die Vorgehensweise, die genutzt werden kann, um
eine Applikation in einer Chroot einzuschließen, werden wir einen Blick
auf wwwcount werfen, einem einfachen Webseitenzähler, der über die
<a href="faq15.html#PkgMgmt">Portierungen</a> verfügbar ist.
Obwohl dieses ein sehr effektives Programm ist, weiß es nichts über
den in chroot(2) eingeschlossenen Apache und wird in seiner
standardmäßigen Konfiguration nicht in chroot(2) funktionieren.

<p>
Zuerst werden wir das <a
href="http://www.muquit.com/muquit/software/Count/Count.html"
>wwwcount</a>-Paket installieren. Wir konfigurieren und testen es und
stellen fest, dass es nicht funktionieren will und dass wir eine
Apache-Nachricht erhalten, die »Internal Server Error« sagt.

Der erste Schritt ist das Beenden und Neustarten von Apache mit der
Option <tt>-u</tt>, um sicherzustellen, dass das Problem im
chroot(2) liegt und nicht in der Systemkonfiguration.

<blockquote><pre>
# <b>apachectl stop</b>
/usr/sbin/apachectl stop: httpd stopped
# <b>httpd -u</b>
</pre></blockquote>

Hiernach sehen wir, dass der Zähler einwandfrei läuft, zumindest nachdem
wir die Dateirechte umgestellt haben, sodass Apache (und die CGIs, die
er ausführt) in die Dateien schreiben können, die gehalten werden.
Somit haben wir ganz sicher ein Problem mit chroot, sodass wir Apache
wieder beenden und neustarten können, dieses Mal wieder mit
standardmäßigem Chroot:

<blockquote><pre>
# <b>apachectl stop</b>
/usr/sbin/apachectl stop: httpd stopped
# <b>httpd</b>
</pre></blockquote>

<p>
Ein guter Anfangspunkt wäre anzunehmen, dass wwwcount einige
Bibliotheken und andere Dateien benötigt, die im chroot nicht vorliegen.
Wir können das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldd&amp;sektion=1">ldd(1)</a>
benutzen, um alle dynamischen Objektabhängigkeiten festzustellen, die
das CGI hat:

<blockquote><pre>
# <b>cd /var/www/cgi-bin/</b>
# <b>ldd Count.cgi</b>
Count.cgi:
        Start    End      Type Open Ref GrpRef Name
        1c000000 3c007000 exe  1    0   0      /var/www/cgi-bin/Count.cgi
        0c085000 2c0be000 rlib 0    1   0      /usr/lib/libc.so.57.0
        08713000 08713000 rtld 0    1   0      /usr/libexec/ld.so
</pre></blockquote>

Ok, hier ist ein Problem, zwei Dateien sind in der chroot(2)-Umgebung
nicht verfügbar. Wir kopieren sie also hinein:

<blockquote><pre>
# <b>mkdir -p /var/www/usr/lib /var/www/usr/libexec</b>
# <b>cp /usr/lib/libc.so.57.0 /var/www/usr/lib</b>
# <b>cp /usr/libexec/ld.so /var/www/usr/libexec</b>
</pre></blockquote>

und testen den Zähler wieder.

<p>
Nun ja, jetzt läuft das Programm zumindest und gibt uns Fehlermeldungen
direkt: "Unable to open config file for reading".
Fortschritt, aber wir sind noch nicht fertig.
Die Konfigurationsdatei ist normalerweise in
<tt>/var/www/wwwcount/conf</tt>, aber innerhalb der chroot-Umgebung,
wäre das <tt>/wwwcount/conf</tt>.
Unsere Möglichkeiten sind nun entweder das Neukompilieren vom Programm,
sodass es mit den Dateien arbeitet, wo sie jetzt sind, oder aber das
Verschieben der Dateien.
Da wir vom Paket aus installiert haben, werden wir die Dateien
verschieben. Um die gleiche Konfig mit sowie ohne chroot(2) verwenden
zu können, benutzen wir einen symbolischen Link:

<blockquote><pre>
# <b>mkdir -p /var/www/var/www</b>
# <b>cd /var/www/var/www</b>
# <b>ln -s ../../wwwcount wwwcount</b>
</pre></blockquote>

Beachte, dass dieser symbolische Link so erstellt wurde, dass er
innerhalb vom chroot läuft. Und wir werden wieder einmal testen ...
und stellen fest, dass es noch ein Problem gibt.
Nun beschwert sich wwwcount darüber, dass es die Stripimage-Dateien,
die zum Anzeigen von Nachrichten genutzt werden, nicht finden kann.
Nach einer kurzen Suche finden wir heraus, dass sich diese unter
<tt>/usr/local/lib/wwwcount</tt> befinden, sodass wir diese ebenfalls
ins chroot kopieren müssen.

<blockquote><pre>
# <b>tar cf - /usr/local/lib/wwwcount | (cd /var/www; tar xpf - )</b>
</pre></blockquote>

wir testen wieder ... und es läuft!

<p>
Beachte, dass wir wirklich nur die Dateien kopiert haben, die absolut
notwendig sind, um das Programm ausführen zu können. Generell gilt,
dass die Mindestanzahl an Dateien in die Chroot-Umgebung kopiert
werden sollte, um das Programm ausführen zu können.

<h3>Sollte ich auf die Chroot-Funktion zurückgreifen?</h3>
Im obigen Beispiel war das Programm zwar recht einfach, doch hatten
wir unterschiedlichste Probleme, bis es lief.

<p>
<i>Nicht jede Anwendung kann oder sollte in einer Chroot(2)-Umgebung
laufen.</i>

<p>
Das Ziel ist ein sicherer Webserver. Chroot(2)ing ist nur ein Teil des
Weges, um dieses Ziel zu erreichen - und nicht das Ziel selbst. Denke
daran, dass die Standardkonfiguration von OpenBSDs Apache in chroot(2)
vorsieht, dass der Benutzer des httpd(8)-Programms keine anderen
Programme ausführen, keine Dateien verändern und auch nicht die
Identität des Benutzers ändern kann. Wenn du diese Einschränkungen
lockerst, so verringerst du die Gesamtsicherheit - mit oder ohne chroot.

<p>
Einige Applikationen sind recht einfach und chroot(2) macht für sie
Sinn. Andere sind recht komplex und sind die Anstrengungen, sie in ein
chroot zu zwingen, nicht wert, oder aber du wirst den kompletten Nutzen
der chroot(2)-Umgebung verloren haben, wenn du genügend Dateien vom
System kopiert hast. Zum Beispiel muss das Programm OpenWebMail auf das
Mailverzeichnis und auf das Heimatverzeichnis des Benutzers zugreifen
können sowie die Möglichkeit haben, Programme mit den Rechten aller
Anwender auszuführen. Ein Versuch, diese Anwendungen in eine
Chroot-Umgebung zu sperren wäre völlig sinnlos, da hiermit alle
Vorzüge einer solchen Umgebung umgangen werden. Selbst Applikationen,
die so einfach wie der zuvor beschrieben Counter sind, müssen auf die
Platte schreiben (um den Zähler zu speichern), sodass <i>einige</i>
Vorteile vom chroot(2) verloren gegangen sind.

<p>
Des Weiteren ist es nutzlos, chroot(2) für Programme umzusetzen, die
Rootrechte benötigen. Root kann generell aus einer Chroot(2)-Umgebung
ausbrechen.

<p>
Vergiss eine Sache nicht: Wenn die Einrichtung einer Chroot-Umgebung
sehr schwer war, so wirst du vielleicht der Versuchung erliegen, das
System seltener zu aktualisieren/upgraden als du solltest. Dies
wiederum würde dazu führen, dass dein System UNSICHERER ist als ein
System, das zwar auf Chroot verzichtet, dafür aber leichter zu
verwalten ist.

<p>
<a name="rootshell"></a>
<h2>10.17 - Kann ich die Rootshell ändern?</h2>
Es wird manchmal gesagt, dass man niemals die Rootshell ändern dürfte,
doch gibt es unter OpenBSD nichts, was dagegen spricht.

<p>
Die Standardshell für <i>root</i> ist unter OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>.

<p>
Eine geschichtliche Unix-Richtlinie ist, nur statisch kompilierte Shells
für root zu benutzen, da im Fall des Singleuser-Modus andere als die
root-Partitionen nicht gemountet werden und dynamisch gelinkte Shells
nicht auf die Bibliotheken auf der <tt>/usr</tt>-Partition zugreifen
können. Dies ist kein wirklich schlimmes Problem für OpenBSD, da das
System dich nach einer Shell fragt, wenn es im Singleuser-Modus
angekommen ist und der Standard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
ist.

Die drei standardmäßigen Shells unter OpenBSD
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>)
sind alle statisch gelinkt und daher im Singleuser-Modus
einsatzfähig.

<p>
<a name="ksh"></a>
<h2>10.18 - Was kann ich noch mit <i>ksh</i> machen?</h2>
Unter OpenBSD ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
<a href="http://web.cs.mun.ca/~michael/pdksh/">pdksh</a>, die »Public
Domain Korn Shell«, und die gleiche Binary wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>.

<p>
Anwender, die gerne <i>bash</i> benutzen, die oft unter Linux-Systemen
genutzt wird, werden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
als recht ähnlich einschätzen. Ksh(1) bietet die meisten häufig
genutzten Funktionalitäten von <i>bash</i>, einschließlich der
Tab-Erweiterung, Kommandozeileneditierung und History über die
Pfeiltasten und STRG+A/STRG+E, um zum Anfang/Ende der Kommandozeile
zu springen. Wenn andere Funktionalitäten der <i>bash</i> benötigt
sind, kann <i>bash</i> selbst entweder über
<a href="faq15.html#PkgMgmt">Pakete</a> oder
<a href="faq15.html#Ports">Portierungen</a> installiert werden.

<p>
Der Kommandoprompt von <i>ksh</i> kann auf einfache Weise auf etwas
informativeres geändert werden, weg vom standardmäßigen »$ «, indem die
Variable <tt>PS1</tt> gesetzt wird. Das Einfügen folgender Zeile:

<blockquote><pre>
export PS1='$PWD $ '
</pre></blockquote>

in deine <tt>/etc/profile</tt> führt beispielsweise zu folgendem
Kommandoprompt:

<blockquote><pre>
/home/nick $
</pre></blockquote>

Siehe dir die Datei
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/ksh.kshrc?content-type=text/plain"><tt>/etc/ksh.kshrc</tt></a>
an, in der viele nützliche Funktionalitäten und Beispiele stehen, die
in die <tt>.profile</tt> deines Benutzers geschrieben werden können.

<p>
OpenBSDs ksh(1) wurde mit einigen ,speziellen Zeichen' für den
primären Promptstring (PS1) verbessert, sodass sie ähnlich zu denen in
bash sind. Zum Beispiel:
<blockquote>
<tt>\e - </tt>Füge eine ASCII-Escapesequenz ein.<br>
<tt>\h - </tt>Der Hostname ohne Domänenname.<br>
<tt>\H - </tt>Der gesamte Hostname, einschließlich Domänennamen.<br>
<tt>\n - </tt>Füge einen Zeilenumbruch ein.<br>
<tt>\t - </tt>Die aktuelle Zeit im 24-Stunden-Format HH:MM:SS.<br>
<tt>\u - </tt>Der Benutzername vom aktuellen Anwender.<br>
<tt>\w - </tt>Das momente Arbeitsverzeichnis.  $HOME wird als ~
dargestellt.<br>
<tt>\W - </tt>Der Basisname vom aktuellen Arbeitsverzeichnis.<br>
<tt>\$ - </tt>Gibt # für root-User und $ für alle anderen aus.
</blockquote>

(lies die Handbuchseite über
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh(1)</a>
für weitere Details, und noch vielen, vielen weiteren Spezialzeichen!
Beachte bitte, dass das Zeichen $ innerhalb doppelter
Anführungszeichen eine besondere Bedeutung hat. Pass also auf!)

<p>
Man könnte folgendes Kommando nutzen:
<blockquote><pre>
export PS1="\n\u@\H\n\w \\$ "
</pre></blockquote>
um einen recht ausgiebigen aber nützlichen Prompt zu bekommen.

<p>
<a name="Dir"></a>
<h2>10.19 - Verzeichnisdienste</h2>

<p>
OpenBSD kann sowohl für Server, als auch für Klienten von Datenbanken, die
Benutzerausweisdaten, Gruppeninformationen und andere, mit dem Netzwerk in
Zusammenhang stehende Daten enthalten, benutzt werden.

<p>
<a name="Dir.available"></a>
<h3>10.19.1 - Welche Verzeichnisdienste sind verfügbar?</h3>

<p>
Selbstverständlich könnte man vielerlei Verzeichnisdienste unter OpenBSD
benutzen.
Aber YP ist der Einzige, auf den direkt durch die
Standard-C-Bibliotheksfunktionen wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getpwent&amp;sektion=3"
>getpwent(3)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getgrent&amp;sektion=3"
>getgrent(3)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&amp;sektion=3"
>gethostbyname(3)</a> und so weiter zugegriffen werden kann.
Werden also die Daten in einer YP-Datenbank vorgehalten, so müssen sie nicht in
lokale Konfigurationsdateien wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=master.passwd&amp;sektion=5"
>master.passwd(5)</a> übertragen werden, bevor man sie nutzen kann,
zum Beispiel zur Authentifizierung eines Nutzers.

<p>
YP ist ein Verzeichnisdienst der mit Sun Microsystems' NIS (»Network
Information System«, Netzwerkinformationssystem) kompatibel ist.  Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=yp&amp;sektion=8"
>yp(8)</a> für einen Überblick über die verfügbaren Handbuchseiten.
Vorsicht ist geboten, da einige Betriebssysteme Verzeichnisdienste enthalten,
die zwar ähnliche Namen tragen, jedoch vollständig unverträglich sind,
wie zum Beispiel NIS+.

<p>
Um andere Verzeichnisdienste als YP benutzen zu können, müssen entweder lokale
Konfigurationsdateien aus dem Verzeichnis heraus erzeugt werden,
oder aber es wird ein YP-Frontend benötigt.
Zum Beispiel kann man die Portierung <tt>sysutils/login_ldap</tt> nutzen,
wenn man den ersten Weg wählt, während der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypldap&amp;sektion=8"
>ypldap(8)</a>-Dämon letzteren anbietet.

<p>
Für einige Anwendungen stellt die Synchronisation einer kleinen Anzahl
Konfigurationsdateien unter einer Gruppe von Maschinen mit Hilfe von Werkzeugen
wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8"
>cron(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1"
>scp(1)</a> oder <tt>rsync</tt> (in den Portierungen verfügbar) eine einfache
und robuste Alternative zu einem vollwertigen Verzeichnisdienst dar.

<p>
<a name="YP_secure"></a> 
<h3>10.19.2 - YP Sicherheitsüberlegungen</h3>

<p>
Aus Kompatibilitätsgründen sind alle sicherheitsrelevanten Merkmale, die in
OpenBSDs Implementierung von YP eingebaut sind, standardmäßig
<em>ausgeschaltet</em>.
Selbst wenn sie alle eingeschaltet sind, gilt, dass das NIS-Protokoll immer
noch inhärent unsicher ist, und zwar aus zwei Gründen:
Alle Daten, einschließlich sensitiver Daten wie Passwort-Hashs, werden
unverschlüsselt über das Netzwerk übertragen, und weder der Klient, noch der
Server können zuverlässig die Identität des jeweils Anderen feststellen.

<p>
Deshalb sollte man prüfen, ob diese inhärenten Sicherheitslücken im
gewünschten Kontext akzeptabel sind, bevor man einen YP-Server einrichtet.
Insbesondere ist YP unzureichend, wenn potentielle Angreifer physischen Zugriff
auf das Netzwerk besitzen.
Jeder, der root-Zugriff auf irgendeinem Computer erlangen kann, der an
YP-Verkehr transportierende Netzwerksegmente angeschlossen ist, kann sich an
die YP-Domäne anbinden und Daten empfangen.
In einigen Fällen besteht die Option, YP-Verkehr durch SSL- oder IPSec-Tunnel
zu leiten, oder man kann erwägen, YP mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kerberos&amp;sektion=8"
>kerberos(8)</a>-Authentifizierung zu verknüpfen.

<p>
<a name="YP_server"></a> 
<h3>10.19.3 - Einrichten eines YP-Servers</h3>

<ol>
<li><p>
Ein YP-Server bedient eine Gruppe von Klienten, die »domain« (Domäne) genannt
wird.
Man sollte zuerst einen Domänennamen aussuchen; es kann eine beliebige
Zeichenfolge sein, und muss in keiner Weise etwas mit dem DNS-Domänennamen zu
tun haben.
Einen zufälligen Namen wie »Eepoo5vi« auszuwählen mag die Sicherheit marginal
verbessern, obwohl dieser Effekt größtenteils auf Sicherheit aus
Unklarheit zurückzuführen ist.
Für den Fall, das mehrere unterschiedliche YP-Domänen zu verwalten sind,
ist es wahrscheinlich besser, aussagekräftige Namen, wie »Verkauf«, »Marketing«
oder »Entwicklung« zu wählen, um Systemadministrierungsfehlern durch Unklarheit
vorzubeugen.
Anzumerken ist außerdem, dass einige Versionen von SunOS verlangen, das der
DNS-Domänenname des Hosts benutzt wird, sodass die Auswahl in einem Netzwerk
mit solchen Hosts beschränkt sein könnte.

<p>
Benutze das Dienstprogramm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=domainname&amp;sektion=1"
>domainname(1)</a>, um den Domänennamen zu setzen, und schreibe ihn in die
Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=defaultdomain&amp;sektion=5"
>defaultdomain(5)</a>, um ihn beim Systemstart automatisch setzen zu lassen.

<blockquote><pre>
echo "puffynet" > /etc/defaultdomain
domainname `cat /etc/defaultdomain`
</pre></blockquote>

<li><p>
Initialisiere den YP-Server mit Hile des interaktiven Kommandos

<blockquote><pre>
ypinit -m
</pre></blockquote>

An diesem Punkt ist es nicht notwendig, »Slave-Server« zu spezifizieren.
Um »Slave-Server« hinzuzufügen, kann man später erneut
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypinit&amp;sektion=8"
>ypinit(8)</a> mit Hilfe der Option <tt>-u</tt> aufrufen.

Das Einrichten von zumindest einem »Slave-Server« für jede Domäne ist
zweckmäßig, um Serviceunterbrechungen zu vermeiden, sollte der Master-Server
jemals untergehen oder seine Netzwerkverbindung verlieren, insbesondere da
Klienten, die versuchen, auf YP-Zuordnungen zuzugreifen, unbegrenzt blockieren,
bis sie die angeforderte Antwort erhalten.
Aus diesem Grunde führen YP Serviceunterbrechungen normalerweise dazu, dass
Klienten komplett unbenutzbar sind, bis YP wieder einsatzbereit ist.

<li><p>
Entscheide wo die Quelldateien gespeichert werden sollen, aus denen die
YP-Zuordnungen generiert werden sollen.
Die Serverkonfiguration unabhängig von der angedienten Konfiguration
aufzubewahren, hilft zu kontrollieren,
welche Informationen angedient werden und welche nicht,
sodass das standardmäßige <tt>/etc</tt> oft nicht die beste Wahl ist.

<p>
Die einzige Unbequemlichkeit, die sich aus der Änderung des
Quellverzeichnisses ergibt, ist, das man nicht in der Lage ist, Benutzer und
Gruppen mit Hilfe der Dienstprogramme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=user&amp;sektion=8"
>user(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=8"
>group(8)</a> zu der YP-Domäne hinzuzufügen, zu entfernen oder zu modifizieren.
Stattdessen muss man die Konfigurationsdateien mit einem Texteditor bearbeiten.

<p>
Um das Quellverzeichnis zu definieren, editiere die Datei
<tt>/var/yp/`domainname`/Makefile</tt>
und ändere die Variable <tt>DIR</tt>, z.&nbsp;B.

<blockquote><pre>
DIR=/etc/yp/src/puffynet
</pre></blockquote>

<li><p>
Erwäge die Anpassung weiterer Variablen in
<tt>/var/yp/`domainname`/Makefile</tt>.  Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Makefile.yp&amp;sektion=8"
>Makefile.yp(8)</a> für Details.

<p>
Zum Beispiel, selbst wenn das Standardquellverzeichnis <tt>/etc</tt> benutzt
wird, so wird man normalerweise nicht alle Benutzerkonten und Gruppen, die
auf dem Server existieren, auf allen Klienten benötigen.
Insbesondere ist es oft vorteilhaft für die Sicherheit, wenn man das root-Konto
nicht andient, und damit den Passwort-Hash von root geheim hält.
Überprüfe die Werte von <tt>MINUID</tt>, <tt>MAXUID</tt>, <tt>MINGID</tt>
und <tt>MAXGID</tt>, und passe sie deinen Bedürfnissen an.

<p>
Wenn alle deine YP-Klienten unter OpenBSD oder FreeBSD laufen, so schließe die
verschlüsselten Passwörter aus den <tt>passwd</tt>-Zuordnungen aus, indem du
<tt>UNSECURE=""</tt> in <tt>/var/yp/`domainname`/Makefile</tt> setzt.

<p>
Die bisherige Praxis des Editieren der Schablonendatei
<tt>/var/yp/Makefile.yp</tt> wird nicht länger empfohlen.
Änderungen an dieser Datei beeinflussen alle Domänen, die nach den Änderungen
initialisiert werden, nicht aber solche, die vor den Änderungen initialisiert
wurden, sodass dies ein auf jede Weise fehleranfälliger Weg ist: Man riskiert
sowohl, das die angestrebten Änderungen nicht wirksam werden, als auch,
sie zu vergessen, in welchem Fall sie später andere Domänen beeinflussen, für
die sie nie gedacht waren.

<li><p>
Erzeuge das Quellverzeichnis und fülle es mit den Konfigurationsdateien, die
gebraucht werden.  Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Makefile.yp&amp;sektion=8"
>Makefile.yp(8)</a> um zu lernen, welche YP-Zuordnungen welche Quelldateien
benötigen.  Für das Format der jeweiligen Quelldatei siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=passwd&amp;sektion=5"
>passwd(5)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=5"
>group(5)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5"
>hosts(5)</a> und so weiter, und prüfe die Beispiele in <tt>/etc</tt>.

<li><p>
Erzeuge die erste Version deiner YP-Zuordnungen mit Hilfe der Kommandos

<blockquote><pre>
cd /var/yp
make
</pre></blockquote>

Im Moment sind Sorgen über Fehlermeldungen von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=yppush&amp;sektion=8"
>yppush(8)</a> unnötig.
Der YP-Server wurde noch nicht gestartet.

<li><p>
YP benutzt
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rpc&amp;sektion=3"
>rpc(3)</a> (»remote procedure calls«) um mit Klienten zu kommunizieren,
sodass es nötig ist,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8"
>portmap(8)</a> zu ermöglichen.
Um dies zu tun, editiere
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"
>rc.conf.local(8)</a> und setze <tt>portmap=YES</tt>.
Dies wird beim nächsten Systemstart den »portmapper« starten.
Man kann den Neustart durch manuelles Starten vermeiden:

<blockquote><pre>
echo "portmap=YES" >> /etc/rc.conf.local
portmap
</pre></blockquote>

<li><p>
Erwäge die Benutzung von entweder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=securenet&amp;sektion=5"
>securenet(5)</a> oder den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypserv.acl&amp;sektion=5"
>ypserv.acl(5)</a> Sicherheitsfeatures des YP-Serverdämonen.
Aber beachte, dass diese beiden einzig IP-basierte Zugriffskontrolle bieten.
Aus diesem Grund helfen sie nur solange, wie potentielle Angreifer weder
physischen Zugriff auf die Hardware des Netzwerksegments haben, der den
YP-Verkehr transportiert, noch root-Zugriff auf einem an diese Netzwerksegmente
angeschlossenen Host besitzen.

<li><p>
Abschließend starte den YP-Serverdämon:

<blockquote><pre>
ypserv
</pre></blockquote>

Solange das Verzeichnis <tt>/var/yp/`domainname`</tt> existiert, wird der Dämon
bei einem Systemneustart automatisch gestartet werden.

<li><p>
Um den neuen Server zu testen, erwäge, ihn zu seinem eigenen Klienten zu
machen, indem du den Instruktionen des nächsten Abschnitts folgst.
Sollte es nicht erwünscht sein, den Server mit seinen eigenen Zuordnungen zu
benutzen, kann man den Klienten nach dem Test mit den folgenden Kommandos
deaktivieren:

<blockquote><pre>
pkill ypbind
rm -rf /var/yp/binding
</pre></blockquote>

<li><p>
Ist es erwünscht, Benutzern von Klienten die Änderung ihres Passworts zu
erlauben, so muss
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=yppasswdd&amp;sektion=8"
>yppasswdd(8)</a> aktiviert werden:

<blockquote><pre>
echo 'yppasswdd_flags="-d /etc/yp/src/puffynet"' >> /etc/rc.conf.local
rpc.yppasswdd
</pre></blockquote>

Für den Fall, dass das Quellverzeichnis beim standardmäßigen <tt>/etc</tt>
belassen wurde, kann dafür einfach <tt>yppasswdd_flags=""</tt> benutzt werden.

<li><p>
Präge dir ein, das jede Änderung an einer YP-Zuordnungs-Quelldatei eine
Erneuerung der YP-Zuordnungen erfordert.

<blockquote><pre>
cd /var/yp
make
</pre></blockquote>

Dies aktualisiert alle Datenbankdateien in <tt>/var/yp/`domainname`</tt>,
mit einer Ausnahme: Die Datei <tt>ypservers.db</tt>, die alle mit einer Domäne
assoziierten YP-Master und -»Slave-Server« auflistet, wird direkt von
<tt>ypinit -m</tt> erzeugt und ausschließlich mit <tt>ypinit -u</tt>
modifiziert.
Sollte sie zufällig gelöscht worden sein, führe <tt>ypinit -u</tt> aus, um sie
von Grund auf neu erzeugen zu lassen.
</ol>

<a name="YP_client"></a> 
<h3>10.19.4 - Einrichten eines YP-Klienten</h3>

Einen YP-Klienten einzurichten, besteht aus zwei getrennten Teilen.
Zuerst muss der YP-Klient-Dämon gestartet werden, der den Klienten an einen
YP-Server bindet.
Die folgenden Schritte zu vollenden wird es erlauben, Daten von einem YP-Server
zu beziehen, allerdings werden diese Daten noch nicht vom System benutzt
werden:

<ol>
<li><p>
Wie auf dem Server müssen zuerst der Domänenname gesetzt, und der »portmapper«
aktiviert werden:

<blockquote><pre>
echo "puffynet" > /etc/defaultdomain
domainname `cat /etc/defaultdomain`
echo "portmap=YES" >> /etc/rc.conf.local
portmap
</pre></blockquote>

<li><p>
Es wird empfohlen, eine Liste aller YP-Server in der Konfigurationsdatei 
<tt>/etc/yp/`domainname`</tt> anzugeben.
Anderenfalls wird der YP-Klient-Dämon Netzwerk-»Broadcasts« benutzen, um
YP-Server für seine Domäne zu finden.
Die Server explizit anzugeben ist sowohl robuster, als auch ein bißchen weniger
offen für Attacken.
Wurden keine »Slave-Server« eingerichtet, so schreibe einfach den Hostnamen des
Master-Servers in <tt>/etc/yp/`domainname`</tt>.

<li><p>
Der YP-Klient-Dämon ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypbind&amp;sektion=8"
>ypbind(8)</a>.
In manuell zu starten erzeugt das Verzeichnis <tt>/var/yp/binding</tt>,
sodass er in Zukunft bei Systemneustarts automatisch gestartet wird.

<blockquote><pre>
ypbind
</pre></blockquote>

<li><p>
Wenn alles gut gegangen ist, sollte es möglich sein, den YP-Server mit Hilfe
von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypcat&amp;sektion=1"
>ypcat(1)</a> zu befragen und die »passwd«-Zuordnung zurückzubekommen.

<blockquote><pre>
ypcat passwd
bob:*:5001:5000:Bob Nuggets:/home/bob:/usr/local/bin/zsh
...
</pre></blockquote>

Andere nützliche Werkzeuge zum »Debuggen« der YP-Konfiguration schliessen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypmatch&amp;sektion=1"
>ypmatch(1)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=yptest&amp;sektion=8"
>yptest(8)</a> ein.
</ol>

Der zweite Teil der Konfiguration eines YP-Klienten beinhaltet das Editieren
lokaler Konfigurationsdateien, sodass gewiss YP-Zuordnungen von den
verschiedenen Systemkomponenten benutzt werden.
Nicht alle Server dienen alle Standardzuordnungen an, die von den verschiedenen
Betriebssystemen unterstützt werden, einige Server bieten zusätzliche
nicht-standardisierte Zuordnungen, und man wird keineswegs gezwungen,
all diese Zuordnungen auch zu benutzen.
Welche der verfügbaren Zuordnungen benutzt oder nicht benutzt werden sollen,
und für welche Zwecke sie benutzt werden sollen, all dies liegt vollständig im
Ermessen des Systemadministrators des Klienten.

<p>
Für eine Liste aller Standard YP-Zuordnungen und ihrer standardmäßigen Nutzung,
siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Makefile.yp&amp;sektion=8"
>Makefile.yp(8)</a>.
Die üblichsten Fälle umfassen:

<ul>
<li><p>
Wenn alle Benutzerkonten in der YP-Domäne enthalten sein sollen,
hänge die Standard-YP-Markierung an die Master-Passwort-Datei an,
und erzeuge die Passwort-Datenbank neu:

<blockquote><pre>
echo '+:*::::::::' >> /etc/master.passwd
pwd_mkdb -p /etc/master.passwd
</pre></blockquote>

Für die Details des selektiven Ein- und Ausschlusses von Benutzerkonten siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=passwd&amp;sektion=5"
>passwd(5)</a>.
Um zu testen, ob die Aufnahme tatsächlich klappt, benutze das Dienstprogramm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=id&amp;sektion=1"
>id(1)</a>.

<li><p>
Sollen alle Gruppen in der YP-Domäne enthalten sein, 
hänge die Standard-YP-Markierung an die Gruppen-Datei an:

<blockquote><pre>
echo '+:*::' >> /etc/group
</pre></blockquote>

Für die Details des selektiven Einschlusses von Gruppen siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=5"
>group(5)</a>.

<li><p>
Werden Hostnamen via YP verteilt, sollte an dieser Stelle
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5"
>resolv.conf(5)</a> inspiziert und überprüft werden, ob die Suchreihenfolge des
Namensservice korrekt ist.
Die meisten Benutzer werden eine Zeile wie die Folgende benötigen:

<blockquote><pre>
lookup file yp bind
</pre></blockquote>
</ul>

<p>
<a name="locales"></a>
<h2>10.20 - Zeichensätze und Lokalisierung</h2>

OpenBSD benutzt standardmäßig den ASCII Zeichensatz.
Es unterstützt ebenfalls die Zeichensätze Latin (ISO-8859-*), KOI-8, und
Unicode (UTF-8).

<a name="charset"></a>
<h3>10.20.1 - Konfiguration des aktiven Zeichensatzes</h3>

<p>
Um einen der erweiterten Zeichensätze zu benutzen, muss die Umgebungsvariable
<i>LC_CTYPE</i> auf den Namen eines unterstützten »Locale« gesetzt werden.
<i>LC_CTYPE</i> beeinflusst nur den Zeichensatz, der für Anwendungen verfügbar
ist.
Sie ändert nicht die Sprache, in der Anwendungen ihre Meldungen präsentieren.

<p>
Die Liste der unterstützten »Locales« kann durch durch den Aufruf des folgenden
Kommandos erfragt werden:
<blockquote><pre>
ls /usr/share/locale
</pre></blockquote>

Die Umgebungsvariable <i>LC_CTYPE</i> kann auf einem der folgenden Wege gesetzt
werden:

<ul>
<li>
Meldet man sich mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdm&sektion=1">xdm(1)</a>
an das System an, so ist eine Zeile wie
<blockquote><pre>
export LC_CTYPE="en_US.UTF-8"
</blockquote></pre>
in der Datei <i>~/.xsession</i> einzufügen, und zwar vor dem Starten des
»Window-Managers« (siehe den Abschnitt über
<a href="faq11.html#CustomizingX">das Anpassen von X</a> für Details).
Das Beispiel aktiviert den Zeichensatz Unicode (UTF-8), und wird ebenfalls
Anwendungen wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xterm&sektion=1"
>xterm(1)</a> dazu veranlassen, UTF-8 standardmäßig zu aktivieren.

<li><p>
Findet die Anmeldung mittels Textkonsole statt, so fügt man eine Zeile wie
<blockquote><pre>
export LC_CTYPE="en_US.ISO8859-1"
</blockquote></pre>
zu der Datei <i>~/.profile</i> hinzu.
Anzumerken ist, daß die Textkonsole nur ASCII und ISO8859-1 unterstützt.
Sie unterstützt nicht UTF-8.
</ul>

<p>
Einige Dienstprogramme des Basissystems unterstützen UTF-8 zu diesem Zeitpunkt.
Die meisten werden im UTF-8 »Locale« ASCII benutzen.
Allerdings unterstützen viele Programme aus der Portierungs-Kollektion UTF-8.

<p>
UTF-8 kann auch mit bestimmten Anwendungen einzig dadurch benutzt werden,
dass man sie innerhalb von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=uxterm&sektion=1"
>uxterm(1)</a> startet.
Dies funktioniert selbst dann, wenn die Anmelde-Session keinen UTF-8-»Locale«
benutzt.

<p>
Wenn in ein entferntes System mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&sektion=1"
>ssh(1)</a> eingeloggt wird,
so wird die Umgebungsvariable <i>LC_CTYPE</i> nicht propagiert, und muss daher
manuell auf denselben Wert wie im lokalen Terminal gesetzt werden.

<a name="nls"></a>
<h3>10.20.2 - Ändern der in Anwendungen benutzten Sprache</h3>

<p>
Die Sprache, die für Anwendungsmeldungen benutzt wird, kann durch das Setzen
der Umgebungsvariable <i>LC_MESSAGES</i> auf den Namen eines unterstützten
»Locale« geändert werden.
Dies kann auf dieselbe Weise geschehen, wie es für <i>LC_CTYPE</i>
<a href="#charset">weiter oben</a> beschrieben wurde.
Sowohl <i>LC_MESSAGES</i> als auch <i>LC_CTYPE</i> sollten auf denselben Wert
gesetzt werden.

<p>
Nur wenige Dienstprogramme des Basissystems unterstützen im Moment eine andere
Sprache als Englisch.
Jedoch unterstützen viele Programme der Portierungs-Kollektion lokalisierte
Meldungen in vielerlei Sprachen.
Sie greifen auf Englisch zurück, sollte die gewünschte Sprache nicht verfügbar
sein.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq9.html">[Zum Kapitel 9 - Zu OpenBSD migrieren]</a>
<a href= "faq11.html">[Zum Kapitel 11 - Das X Fenstersystem]</a>
</font>
<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br><small>
<!--
Originally [OpenBSD: faq10.html,v 1.168 ]<br>
$Translation: faq10.html,v 1.42 2012/04/19 18:42:35 steffen Exp $<br>
-->
$OpenBSD: faq10.html,v 1.38 2012/04/19 23:56:50 ajacoutot Exp $
</small>
</body>
</html>
