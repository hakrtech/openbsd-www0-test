<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Pakete filtern</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta http-equiv="Content-Language" content="de">
<meta name="description"   content="die OpenBSD-FAQ-Seite">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, 2004 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="tables.html">Zurück: Tabellen</a>]
[<a href="index.html">Inhalt</a>]
[<a href="nat.html">Weiter: Network Address Translation</a>]

<h1><font color="#e00000">PF: Pakete filtern</font></h1>

<hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#intro">Einführung</a>
<li><a href="#syntax">Regelsyntax</a>
<li><a href="#defdeny">Standardmäßiges Blocken</a>
<li><a href="#pass">Verkehr durchlassen</a>
<li><a href="#quick">Das <tt>quick</tt>-Schlüsselwort</a>
<li><a href="#state">,state' halten</a>
<li><a href="#udpstate">,state' für UDP halten</a>
<li><a href="#tcpflags">TCP-Flags</a>
<li><a href="#synproxy">TCP-SYN-Proxy</a>
<li><a href="#antispoof">,spoofed' Pakete blocken</a>
<li><a href="#osfp">Passives Betriebssystem-,Fingerprinting'</a>
<li><a href="#ipopts">IP-Optionen</a>
<li><a href="#example">Beispiel-Filterregelsatz</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Einführung</h2>
Paket-Filtern ist das selektive Durchlassen oder Blocken von Datenpaketen,
sobald sie durch das Netzwerk-Interface gehen. Die Kriterien, die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>pf(4)</a> verwendet, wenn Pakete untersucht werden, basieren auf den
Layer-3-
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>IPv4</a> und 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>IPv6</a>) und Layer-4-
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>ICMP</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>ICMPv6</a>) Headern. Die meistgenutzten Kriterien sind Quell- und
Ziel-Adressen sowie Ziel-Port und das Protokoll.

<p>
Filterregeln geben die Kriterien an, auf die ein Paket zutreffen muss, und
die resultierende Handlung, entweder Blocken oder Durchlassen, die
durchgeführt wird, wenn eine Übereintreffung gefunden wird. Filterregeln
werden in sequentieller Reihenfolge verarbeitet, von der ersten bis zur
letzten. Solange das Paket nicht auf eine Regel trifft, die das
<tt>quick</tt>-Schlüsselwort beinhaltet, werden <i>alle</i> Filterregeln
überprüft, bevor die schlussendliche Aktion durchgeführt wird. Die letzte
Regel, die zutrifft, ist der ,Gewinner' und wird die Aktion angeben, die
auf das Paket angewandt wird. Es gibt ein impliziertes <tt>pass all</tt>
am Anfang des Filterregelsatzes, das bedeutet, dass, falls ein Paket auf
keine Filterregel zutrifft, die resultierende Aktion <tt>pass</tt> sein
wird.

<a name="syntax"></a>
<h2>Regelsyntax</h2>
Die generelle, <i>höchstgradig vereinfachte</i> Syntax für Filterregeln
ist:
<blockquote>
<tt>
<i>action</i> <i>direction</i> [log] [quick] on <i>interface</i> [<i>af</i>] 
[proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;from <i>src_addr</i> [port <i>src_port</i>] to 
<i>dst_addr</i> [port <i>dst_port</i>] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>Die Aktion, die für zutreffende Pakete angewandt werden soll, entweder
<tt>pass</tt> oder <tt>block</tt>. Die <tt>pass</tt>-Aktion wird das
Paket zurück zum Kernel für weitere Verarbeitung lassen, während die
<tt>block</tt>-Aktion je nach der
<a href="options.html#block-policy"><tt>block-policy</tt></a>-Option
anders reagieren wird. Die standardmäßige Reaktion kann entweder durch
das Angeben von <tt>block drop</tt> oder <tt>block return</tt>
verändert werden.

<dt><tt><i>direction</i></tt>
<dd>Die Richtung, in die das Paket sich bewegt, entweder rein (<tt>in</tt>)
oder raus (<tt>out</tt>).

<dt><tt>log</tt>
<dd>Gibt an, dass das Paket per 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.6"
>pflogd(8)</a> aufgezeichnet werden soll. Wenn die Regel die
<tt>keep state</tt>-, <tt>modulate state</tt>- oder
<tt>synproxy state</tt>-Option angibt, dann wird nur das Paket
aufgezeichnet, das den ,state' aufgebaut hat.
Um alle Pakete unabhängig davon aufzuzeichnen, verwende
<tt>log-all</tt>.

<dt><tt>quick</tt>
<dd>Wenn ein Paket auf eine Regel zutrifft, die <tt>quick</tt> angibt,
dann wird die Regel als letzte zutreffende Regel angesehen, wodurch
sie die Aktion (<tt><i>action</i></tt>) angibt, die durchgeführt werden soll.

<dt><tt><i>interface</i></tt>
<dd>Der Name eines Netzwerk-Interfaces, bzw. die Gruppe von Netzwerk-Interfaces,
durch das sich das Paket bewegt.
Eine Interface-Gruppe wird mit dem Namen des Interfaces angegeben, jedoch
ohne der angehängten Zahl am Ende.
Zum Beispiel: <tt>ppp</tt> oder <tt>fxp</tt>.
Dies wird dazu führen, dass die Regel für jedes Paket zutrifft, das
das <tt>ppp</tt>- oder <tt>fxp</tt>-Interface durchläuft, je nachdem.

<dt><tt><i>af</i></tt>
<dd>Die Adress-Familie des Pakets, entweder <tt>inet</tt> für IPv4 oder
<tt>inet6</tt> für IPv6. PF ist normalerweise in der Lage, anhand der
Parameter für die Quell- und/oder Ziel-Adresse(n) das selbst zu
erkennen.

<dt><tt><i>protocol</i></tt>
<dd>Die Layer-4-Protokolle des Pakets:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Ein gültiger Protokollname aus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.6"
><tt>/etc/protocols</tt></a>
<li>Eine Protokollnummer zwischen 0 und 255
<li>Ein Satz an Protokollen unter Verwendung einer
    <a href="macros.html#lists">Liste</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>Die Quell-/Ziel-Adresse im IP-Header. Adressen können wie folgt
angegeben werden:
<ul>
<li>Eine einzelne IPv4- oder IPv6-Adresse.
<li>Ein <a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>-Netzwerkblock
<li>Ein ,fully qualified domain name', der per DNS aufgelöst wird, wenn
der Regelsatz geladen wird. Alle resultierenden IP-Adressen werden in
die Regel eingesetzt.
<li>Der Name des Netzwerk-Interfaces. Jegliche IP-Adressen, die dem
Interface zugewiesen worden sind, werden in die Regel eingesetzt.
<li>Der Name des Netzwerk-Interfaces gefolgt von
<tt>/<i>netmask</i></tt> (z.B. <tt>/24</tt>). Jede IP-Adresse auf
dem Interface wird mit der Netzmaske kombiniert, um einen
CIDR-Netzwerkblock zu formen, welcher in die Regel eingesetzt wird.
<li>Der Name des Netzwerk-Interfaces in Klammern <tt>( )</tt>. Diese
teilen PF mit, dass die Regel sich aktualisieren soll, wenn sich die
IP-Adresse(n) des genannten Interfaces ändert/ändern. Dies ist insbesondere
dann sinnvoll, wenn die IP-Adresse per DHCP oder dial-up erhalten wird,
da der Regelsatz so nicht jedes Mal neugeladen werden muss, wenn sich
die Adresse ändert.
<li>Der Name eines Netzwerk-Interfaces gefolgt von einem dieser
Modifizierer:
  <ul>
  <li><tt>:network</tt> - fügt den CIDR-Netzwerkblock ein (z.B.
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - fügt die Netzwerk-Broadcast-Adresse ein
  (z.B. 192.168.0.255)
  <li><tt>:peer</tt> - fügt die IP-Adresse des Peers auf einem
  Point-to-Point-Link ein
  </ul>
  <dl>
  <dd>Zusätzlich kann der <tt>:0</tt>-Modifizierer einem Interface-Namen
  oder einem der vorherigen Modifizierer angehängt werden, um darauf
  hinzuweisen, dass PF keine IP-Adress-Aliase in die Einfügung mit
  übernehmen soll.
  Diese Modifizierer können ebenfalls verwendet werden, wenn sich das
  Interface in Klammern befindet.
  Beispiel: <tt>fxp0:network:0</tt>
  </dl>
<li>Eine <a href="tables.html">Tabelle</a>.
<li>Irgendeine der oben genannten, unter Verwendung der <tt>!</tt>-
("nicht") Modifikation.
<li>Ein Satz an Adressen unter Verwendung einer
<a href="macros.html#lists">Liste</a>.
<li>Das Schlüsselwort <tt>any</tt>, das bedeutet: alle Adressen
<li>Das Schlüsselwort <tt>all</tt>, welches eine Kurzschreibweise für
<tt>from any to any</tt> ist.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>Der Quell-/Ziel-Port in dem Layer-4-Paket-Header. Ports können
wie folgt angegeben werden:
<ul>
<li>Eine Nummer zwischen 1 und 65535
<li>Ein gültiger Servicename aus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.6"
><tt>/etc/services</tt></a>
<li>Ein Satz an Ports unter Verwendung einer
<a href="macros.html#lists">Liste</a>
<li>Ein Bereich:
	<ul>
	<li><tt>!=</tt> (ungleich)
	<li><tt>&lt;</tt> (kleiner als)
	<li><tt>&gt;</tt> (größer als)
	<li><tt>&lt;=</tt> (kleiner oder gleich)
	<li><tt>&gt;=</tt> (größer oder gleich)
	<li><tt>&gt;&lt;</tt> (Bereich)
	<li><tt>&lt;&gt;</tt> (umgekehrter Bereich)
	<dl>
	<dd>Die letzten beiden sind Binär-Operatoren (sie benötigen zwei
	Argumente) und fügen die Argumente nicht in den Bereich ein.
	</dl>
	<li><tt>:</tt> (inklusiver Bereich)
	<dl>
	<dd>Der Operator für den inklusiven Bereich ist ebenfalls ein
	Binär-Operator und fügt die Argumente mit in den Bereich ein.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Gibt die Flags an, die in dem TCP-Header gesetzt sein müssen, wenn
<tt>proto tcp</tt> verwendet wird. Flags werden als
<tt>flags <i>check</i>/<i>mask</i></tt> angegeben. Zum Beispiel: <tt>flags
S/SA</tt> - dies sagt PF, dass nur auf die S- und A- (SYN und ACK) Flags
geachtet werden und zutreffen soll, wenn nur das SYN-Flag ,an' ist.

<dt><tt><i>state</i></tt>
<dd>Gibt an, ob die ,state'-Information für das Paket gehalten werden
soll, das auf diese Regel zutrifft.
<ul>
<li><tt>keep state</tt> - funktioniert mit TCP, UDP und ICMP.
<li><tt>modulate state</tt> - funktioniert nur mit TCP. PF wird
starke ,Initial Sequence Numbers' (ISNs) für Pakete erstellen, die auf
diese Regel zutreffen.
<li><tt>synproxy state</tt> - eingehende TCP-Verbindungen werden durch
den Proxy geschickt, um bei der Beschützung der Server vor ,spoofed'
TCP-SYN-Floods zu helfen.
Diese Option beinhaltet die Funktionalität von <tt>keep state</tt> und
<tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Standardmäßiges Blocken</h2>
Die empfohlene Praxis, wenn eine Firewall aufgesetzt wird, ist, einen
,standardmäßiges Blocken'-Weg einzuschlagen. Dies bedeutet, dass
<i>alles</i> geblockt und dann selektiv bestimmter Verkehr durch
die Firewall gelassen wird. Dieser Weg ist empfohlen, da man trotz
entstehender Fehler auf der sicheren Seite ist und er das Schreiben eines
Regelsatzes einfacher macht.

<p>
Um eine ,standardmäßiges Blocken'-Richtlinie zu erstellen, sollten die
ersten beiden Filterregeln wie folgt sein:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Dies wird den gesamten Verkehr auf allen Interfaces blocken, egal in
welche Richtung und von wo nach wo.

<a name="pass"></a>
<h2>Verkehr durchlassen</h2>
Verkehr muss nun explizit durch die Firewall gelassen werden oder er
wird wegen der ,standardmäßiges Blocken'-Richtlinie fallen gelassen.
Dies ist, wo Paket-Kriterien wie Quell-/Ziel-Ports, Quell-/Ziel-Adressen
und das Protokoll ins Spiel kommen. Wann auch immer Verkehr durch die
Firewall gelassen wird, sollte(n) die Regel(n) so restriktiv wie möglich
geschrieben werden. Dies stellt sicher, dass der beabsichtigte Verkehr,
und zwar nur der beabsichtigte Verkehr, durchgelassen wird.

<p>
Einige Beispiele:
<blockquote>
<tt>
# Lasse den Verkehr auf dc0 vom lokalen Netzwerk 192.168.0.0/24<br>
# zur OpenBSD-Maschine mit der IP-Adresse 192.168.0.1 herein. Lasse<br>
# ebenfalls den Antwort-Verkehr durch dc0 wieder raus.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Lasse TCP-Verkehr auf fxp0 vom Web-Server herein, der auf der<br>
# OpenBSD-Maschine läuft. Der Interface-Name fxp0 wird als Ziel-Adresse<br>
# verwendet, so dass Pakete mit dieser Regel nur übereinstimmen, wenn<br>
# sie für die OpenBSD-Maschine gedacht sind.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>Das <tt>quick</tt>-Schlüsselwort</h2>
Wie zuvor angedeutet wurde, wird jedes Paket mit dem gesamten
Filterregelsatz von oben nach unten überprüft. Standardmäßig wird das
Paket als durchgelassen markiert, was aber von jeglicher Regel geändert
werden kann, und das wiederum mehrmals wechseln kann, bevor das Ende
der Filterregeln erreicht ist. <b>Die letzte zutreffende Regel
,gewinnt'.</b> Es gibt eine Ausnahme dafür: Die <tt>quick</tt>-Option
einer Filterregel hat zur Folge, dass jegliche Verarbeitung der weiteren
Regeln abgebrochen und die angegebene Aktion durchgeführt wird.
Lass uns nun einige Beispiele dafür ansehen:

<p>
Falsch:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
In diesem Fall wird die <tt>block</tt>-Zeile zwar verarbeit, aber
wird keinen Effekt haben, da sie von einer Zeile gefolgt wird, die alles
durchlassen wird.

<p>
Besser:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Diese Regeln werden auf eine etwas unterschiedliche Weise verarbeitet. Wenn
die <tt>block</tt>-Zeile zutrifft, wird das Paket geblockt und wegen
der <tt>quick</tt>-Option wird der Rest des Regelsatzes ignoriert.

<a name="state"></a>
<h2>,state' halten</h2>
Eine der wichtigen Fähigkeiten von Packet Filter ist ,keeping state',
bzw. ,stateful inspection'. ,Stateful inspection' verweist auf PFs
Fähigkeit, den ,state', oder Fortschritt, auf der Netzwerkverbindung
nachweisen zu können. Durch das Aufbewahren der Informationen über
jede Verbindung in einer ,state'-Tabelle ist PF in der Lage, schnell
herauszufinden, ob ein Paket, das durch die Firewall gelassen wird,
zu einer bereits erstellten Verbindung gehört. Wenn es das tut, wird
es durch die Firewall gelassen, ohne durch die Regelsätze geschickt
zu werden.
Beginnend mit OpenBSD 3.5 kann die <tt>modulate state</tt>-Option
in Regeln verwendet werden, die ein anderes Protokoll als TCP verwenden.

<p>
Den ,state' zu halten hat viele Vorteilen, einschließlich einfacherer
Regelsätze und besserer Leistung beim Paket-Filtern. PF ist in der
Lage, Pakete mit den Einträgen in der ,state'-Tabelle zu überprüfen,
egal, in welche Richtung sich das Paket bewegt, was bedeutet, dass
Filterregeln, die den Antwort-Verkehr hereinlassen, nicht geschrieben
werden müssen. Und da Pakete, die mit ,stateful'-Verbindungen
übereinstimmen, nicht durch die Regelsatz-Überprüfung gehen, kann
die Zeit, die PF zum Verarbeiten der Pakete benötigt, drastisch
verringert werden.

<p>
Wenn eine Regel die <tt>keep state</tt>-Option besitzt, erstellt das
erste zutreffende Paket einen ,state' zwischen Sender und Empfänger.
Nun werden nicht nur die Pakete ohne Überprüfung durchgelassen,
die vom Sender zum Empfänger gehen, sondern auch die Antwort-Pakete
vom Empfänger zum Sender. Zum Beispiel:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Dies erlaubt jeglichen ausgehenden TCP-Verkehr auf dem
<tt>fxp0</tt>-Interface und lässt ebenfalls Antwort-Verkehr zu, der
zurück durch die Firewall geht.
Während das Halten von ,states' eine schöne Funktionalität ist, kann
es die Leistung deiner Firewall signifikant erhöhen, da
,state'-Überprüfungen um ein vielfaches schneller sind als das Paket durch
die Filterregeln zu schicken.

<p>
Die <tt>modulate state</tt>-Option funktioniert genauso wie
<tt>keep state</tt> mit der Ausnahme, dass es nur auf TCP-Pakete
zutrifft. Mit <tt>modulate state</tt> wird die ,Initial Sequence
Number' (ISN) des ausgehenden Verkehrs zufällig gewählt. Dies ist
sinnvoll, um Verbindungen zu schützen, die von bestimmten
Betriebssystemen erstellt worden sind, die eine schlechte Leistung
beim Wählen von ISNs an den Tag legen.

<p>
Den ,state' von ausgehenden TCP-, UDP-, und ICMP-Paketen und
,modulate'-TCP-ISNs halten:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Ein anderer Vorteil beim Halten von ,states' ist, dass der
dazugehörige ICMP-Verkehr durch die Firewall gelassen wird. Wenn zum
Beispiel <tt>keep state</tt> für eine TCP-Verbindung angegeben wurde
und eine ICMP-,source-quench'-Nachricht für diese TCP-Verbindung
ankommt, wird sie mit dem dazugehörigem ,state' übereinstimmen und
durch die Firewall gelassen.

<p>
Der Bereich des ,state'-Eintrags wird systemweit durch die
<a href="options.html#state-policy"><tt>state-policy</tt></a>-Laufzeit-Option
auf einer Regel-spezifischen Basis durch die <tt>if-bound</tt>-,
<tt>group-bound</tt>- und <tt>floating</tt>-state-Option-Schlüsselwörter
kontrolliert. Diese Regel-spezifischen Schlüsselwörter haben die gleiche
Bedeutung, als wenn sie mit der <tt>state-policy</tt>-Option verwendet
werden. Beispiel:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Diese Regel bestimmt, dass, damit Pakete mit dem ,state'-Eintrag
übereinstimmen können, diese durch das <tt>fxp0</tt>-Interface gelangen
müssen.


<p>
Bedenke, dass <a href="nat.html"><tt>nat-</tt></a>, 
<a href="nat.html#binat"><tt>binat-</tt></a> und
<a href="rdr.html"><tt>rdr-</tt></a>Regeln implizit einen ,state'
für zutreffende Verbindungen erstellen, solange die Verbindung
durch den Filterregelsatz gelassen wird.

<a name="udpstate"></a>
<h2>,state' für UDP halten</h2>
Man wird ab und zu hören, dass jemand sagt: "Man kann keinen ,state'
mit UDP erstellen, da UDP ein ,stateless' Protokoll ist!" Obwohl es
wahr ist, dass UDP-Verbindungssitzungen kein Konzept eines ,states'
haben (einen expliziten Anfang und ein explizites Ende), hat dies keine
Wirkung auf PFs Fähigkeit, einen ,state' für eine UDP-Sitzung zu
erstellen. In dem Fall von Protokollen ohne ,Start'- und ,Ende'-Paketen,
merkt sich PF einfach, wie lange es her ist, dass ein zutreffendes
Paket durchgelassen wurde. Wenn der Timeout erreicht wurde, wird
der ,state' gelöscht. Der Timeout-Wert kann in der
<a href="options.html">options</a>-Sektion in der Datei
<tt>pf.conf</tt> gesetzt werden.

<a name="tcpflags"></a>
<h2>TCP-Flags</h2>
TCP-Pakete anhand ihrer Flags zu überprüfen wird meistens verwendet, um
TCP-Pakete zu filtern, die versuchen, eine neue Verbindung zu eröffnen.
Die TCP-Flags und ihre Bedeutungen sind hier aufgeführt:
<ul>
<li><b>F</b> : FIN  - Finish; Ende der Sitzung
<li><b>S</b> : SYN  - Synchronize; Weist auf eine Anfrage hin, eine Sitzung zu beginnen
<li><b>R</b> : RST  - Reset; Lasse eine Verbindung fallen
<li><b>P</b> : PUSH - Push; Paket wird umgehend gesendet
<li><b>A</b> : ACK  - Acknowledgement; Erhalten
<li><b>U</b> : URG  - Urgent; Dringend
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo
<li><b>W</b> : CWR  - Congestion Window Reduced
</ul>

<p>
Damit PF die TCP-Flags während der Überprüfung einer Regel inspiziert,
muss das <tt>flags</tt>-Schlüsselwort mit folgender Syntax verwendet
werden:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i>
</tt>
</blockquote>

<p>
Der <tt><i>mask</i></tt>-Teil teilt PF mit, nur die angegebenen Flags
zu inspizieren und der <tt><i>check</i></tt>-Teil gibt an, welche(r)
Flag(s) im Header aktiviert sein müssen, damit eine Übereinstimmung
stattfinden kann.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
Die hier angegebene Regel lässt TCP-Verkehr mit gesetztem SYN-Flag
durch, während nur die SYN- und ACK-Flags überprüft werden. Ein
Paket mit den SYN- und ECE-Flags würde der oben genannten Regel
entsprechen, während ein Paket mit SYN und ACK oder nur ACK keine
Übereinstimmung hätte.

<p>
Hinweis: in früheren Versionen von OpenSBD wurde die folgende Syntax
unterstützt:
<blockquote>
<tt>
. . . flags S
</tt>
</blockquote>

<p>
Dies gilt heute nicht mehr. Eine Maske muss nun <i>immer</i> angegeben
werden.

<p>
Flags werden oft in Verbindung mit <tt>keep state</tt>-Regeln verwendet,
um zu helfen, die Erstellung von ,state'-Einträgen besser kontrollieren
zu können:
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Dies würde das Erstellen eines ,states' für alle ausgehenden TCP-Pakete
mit gesetztem SYN-Flag erlauben, unter der Überprüfung von SYN- und
ACK-Flags.

<p>
Man sollte vorsichtig bei der Verwendung mit Flags sein -- zu verstehen,
was du warum tust, und vorsichtig mit den Ratschlägen von Leuten zu
sein, die häufig schlechte geben. Einige Leute empfehlen das Erstellen
von ,states', "nur, wenn das SYN-Flag gesetzt ist und kein anderes".
Solch eine Regel würde wie folgt enden:
<pre>
     . . . flags S/FSRPAUEW  <i>bad idea!!</i>
</pre>

<p>
Die Theorie dahinter ist, dass nur am Anfang der TCP-Sitzung ein ,state'
erzeugt wird und die Sitzung nur mit einem SYN-Flag starten sollte, keinem
anderen. Das Problem ist, dass einige Seiten anfangen, das ECN-Flag zu
verwenden und jegliche Seite, die ECN verwendet und versucht,
sich zu dir zu verbinden, bei einer solchen Regel abgeblockt werden würde.
Eine bessere Möglichkeit ist:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Während dies praktisch und sicher ist, ist das Überprüfen für die
FIN- und RST-Flags unnötig, wenn der Verkehr ebenfalls
ge<a href="scrub.html">,scrubbed'</a> wird. Der ,scrubbing'-Prozess
wird PF veranlassen, jegliche eingehenden Pakete mit ungültigen
TCP-Flag-Kombinationen (wie zum Beispiel SYN und FIN oder SYN und
RST) fallenzulassen. Es wird dringend empfohlen, immer <tt>scrub</tt>
auf eingehenden Verkehr anzuwenden:
<blockquote>
<tt>
scrub in on fxp0<br>
.<br>
.<br>
.<br>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state
</tt>
</blockquote>

<a name="synproxy"></a>
<h2>TCP-SYN-Proxy</h2>
<p>
Wenn ein Client normalerweise eine TCP-Verbindung zu einem Server
aufbaut, wird PF die
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/connections.html"
>Handschlag</a>-Pakete zwischen den beiden Endpunkten durchlassen, sobald
sie ankommen. PF hat jedoch die Fähigkeit, den Handschlag durch einen
Proxy zu senden.
Mit einem Handschlag, der durch einen Proxy gesendet wurde, wird PF selbst
den Handschlag mit dem Client absolvieren, einen Handschlag mit dem
Server beginnen und dann die Pakete zwischen den beiden durchlassen.
Der Vorteil von diesem Prozess ist, dass keine Pakete zum Server gesendet
werden, bevor der Client den Handschlag abgeschlossen hat.
Dies eliminiert die Gefahr eines ,spoofed' TCP-SYN-Floods, die den
Server beeinträchtigen könnten, weil die ,spoofed' Client-Verbindung
nicht in der Lage ist, den Handschlag zu vollenden.

<p>
Der TCP-SYN-Proxy wird durch die Verwendung der
<tt>synproxy state</tt>-Schlüsselworte in den Filterregeln aktiviert.
Beispiel:

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Hier werden die Verbindungen zum Webserver durch den TCP-Proxy von
PF gesendet.

<p>
Wegen der Funktionsweise von <tt>synproxy state</tt> beinhaltet es
die gleiche Funktionalität wie <tt>keep state</tt> und <tt>modulate
state</tt>.

<p>
Der SYN-Proxy wird nicht mit PF funktionieren, wenn dieser auf einer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;
manpath=OpenBSD+3.6"
>bridge(4)</a> läuft.

<a name="antispoof"></a>
<h2>,spoofed' Pakete blocken</h2>
Adress-,spoofing' liegt vor, wenn ein böswilliger Benutzer die
Quell-IP-Adresse in den Paketen ändert, die versendet werden, um entweder
seine tatsächliche Adresse zu verbergen oder um so zu wirken, als würde
er ein anderes Gerät im Netzwerk bedienen. Sobald ein Benutzer eine
,spoofed' Adresse hat, kann er Netzwerkattacken durchführen, ohne seine
wahre Herkunft offenzulegen, oder erreicht Zugriff auf Netzwerkdienste,
die nur bestimmten IP-Adressen ermöglicht werden sollen.

<p>
PF bietet einen gewissen Schutz gegen Adress-,spoofing' durch das
<tt>antispoof</tt>-Schlüsselwort:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Gibt ab, ob das zutreffende Paket via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.6"
>pflogd(8)</a> aufgezeichnet werden soll.

<dt><tt>quick</tt>
<dd>Wenn ein Paket auf diese Zeile zutrifft, wird es als ,Gewinner'-Regel
angesehen und die Verarbeitung des Regelsatzes angehalten.

<dt><tt><i>interface</i></tt>
<dd>Das Netzwerk-Interface, auf dem ,spoofing'-Schutz aktiviert werden
soll. Dies kann ebenfalls eine <a href="macros.html#lists">Liste</a>
von Interfaces sein.

<dt><tt><i>af</i></tt>
<dd>Die Adress-Familie, für die der ,spoofing'-Schutz aktiviert werden
soll, entweder <tt>inet</tt> für IPv4 oder <tt>inet6</tt> für IPv6.
</dl>

<p>
Beispiel:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Wenn ein Regelsatz geladen wird, wird jedes Vorkommen des
<tt>antispoof</tt>-Schlüsselwortes in zwei Filterregeln eingesetzt.
Angenommen, dass das Interface <tt>fxp0</tt> die IP-Adresse 10.0.0.1 und eine
Subnetz-Maske von 255.255.255.0 hat (z.B. /24), dann würde die
oben angegebene <tt>antispoof</tt>-Regel wie folgt entwickelt werden:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Diese Regeln erreichen zwei Dinge:
<ul>
<li>Blockt den gesamten Verkehr, der vom 10.0.0.0/24-Netzwerk kommt, der
<i>nicht</i> durch <tt>fxp0</tt> hereinkommt. Da das 10.0.0.0/24-Netzwerk
auf dem <tt>fxp0</tt>-Interface liegt, dürften Pakete mit Quell-Adressen aus
diesem Netzwerkblock niemals auf anderen Interfaces gesehen werden können.
<li>Blockt den gesamten Verkehr von 10.0.0.1, der IP-Adresse von
<tt>fxp0</tt>.
Die Host-Maschine dürfte niemals Pakete zu sich selbst durch ein externes
Interface senden, so dass alle eingehenden Pakete mit der Source-Adresse,
die an dieser Maschine ankommen, als böswillig angesehen werden können.
</ul>

<p>
<b>HINWEIS</b>. Die Filterregeln, die aus der <tt>antispoof</tt>-Regel
hervorgehen, blocken ebenfalls Pakete, die über das Loopback-Interface
zur lokalen Adresse gesendet werden. Diese Adressen sollten ebenfalls
explizit durchgelassen werden. Beispiel:
<blockquote>
<tt>
pass quick on lo0 all<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Die Verwendung von <tt>antispoof</tt> sollte auf Interfaces beschränkt
werden, denen eine IP-Adresse zugewiesen wurde. Wenn <tt>antispoof</tt>
auf ein Interface angewandt wird, das keine IP-Adresse hat, wird das in
Filterregeln enden, die so ähnlich wie folgende aussehen werden:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Mit diesen Regeln besteht die Gefahr, dass der <i>gesamte</i> eingehende
Verkehr auf <i>allen</i> Interfaces geblockt wird.

<a name="osfp"></a>
<h2>Passives Betriebssystem-,Fingerprinting'</h2>

<p>
Passives OS-,Fingerprinting' (OSFP) ist eine Methode zum passiven
Ermitteln des Betriebssystems auf dem gegenüberliegendem Host, basierend
auf bestimmten Kriterien in den TCP-SYN-Paketen des Hosts. Diese
Information kann dann als Kriterium in Filterregeln verwendet werden.

<p>
PF ermittelt das entfernte Betriebssystem, indem die Charakteristiken
des TCP-SYN-Pakets mit denen in der
<a href="options.html#fingerprints">,fingerprints'-Datei</a> verglichen
werden, welche standardmäßig
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manp
ath=OpenBSD+3.6"
><tt>/etc/pf.os</tt></a> ist.
Sobald PF aktiviert wurde, kann die aktuelle ,fingerprint'-Liste mit diesem
Kommando angesehen werden:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Innerhalb der Filterregel kann ein ,fingerprint' anhand der OS-Klasse,
-Version oder -Untertyp/-Patchlevel angegeben werden.
Jedes dieser Objekte wird in der Ausgabe des angegebenen
<tt>pfctl</tt>-Kommandos aufgelistet. Um einen ,fingerprint' in einer
Filterregel anzugeben, wird das <tt>os</tt>-Schlüsselwort verwendet:

<blockquote>
<tt>
pass &nbsp;in on $ext_if any os OpenBSD keep state<br>
block in on $ext_if any os "Windows 2000"<br>
block in on $ext_if any os "Linux 2.4 ts"<br>
block in on $ext_if any os unknown
</tt>
</blockquote>

<p>
Die spezielle Betriebssystem-Klasse <tt>unknown</tt> erlaubt es, dass
alle Pakete zutreffen, wenn der ,fingerprint' des OS unbekannt ist.

<p>
Folendes sollte <font color="#ff0000">ZUR KENNTNIS GENOMMEN WERDEN</font>:
<ul>
  <li>Betriebssytem-,fingerprints' sind ab und zu falsch, da ,spoofed'
  oder erstellte Pakete so gemacht worden sind, dass sie so aussehen,
  als wenn sie von einem spezifischen Betriebssystem kommen würden.
  <li>Bestimmte Revisionen oder Patchlevel eines Betriebssystems können
  das Verhalten vom ,stack' ändern und daher dazu führen, dass der
  ,fingerprint' nicht mehr übereinstimmt oder wie ein anderer Eintrag
  wirkt.
  <li>OSFP funktioniert nur mit TCP-SYN-Paketen; es wird nicht mit anderen
  Protokollen oder bereits aufgebauten Verbindungen funktionieren.
</ul>

<a name="ipopts"></a>
<h2>IP-Optionen</h2>
Standardmäßig blockt PF alle Pakete, die IP-Optionen haben. Dies kann
die Arbeit für ,OS fingerprinting'-Anwendungen wie nmap erschweren.
Wenn du eine Applikation hast, die das Durchlassen dieser Pakete
erfordert, wie zum Beispiel Multicast oder IGMP, kannst du die
<tt>allow-opts</tt>-Direktive verwenden:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Beispiel-Filterregelsatz</h2>
Weiter unten ist ein Beispiel für einen Filterregelsatz. Auf der
Maschine läuft PF, die als Firewall zwischen einem kleinen, internen
Netzwerk und dem Internet fungiert. Nur die Filterregeln werden
angezeigt;
<a href="queueing.html">queueing</a>, 
<a href="nat.html"><tt>nat</tt></a>, 
<a href="rdr.html"><tt>rdr</tt></a>, 
etc. wurden aus diesem Beispiel herausgelassen.
<br>
<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# tabelle, die alle IP-Adressen beinhaltet, die der firewall zugewiesen
# worden sind
table &lt;firewall&gt; const { self }

# ,scrub' auf alle eingehenden pakete anwenden
scrub in all

# eine richtlinie zum standardmäßigen blocken errichten
block in  all
block out all

# den verkehr auf dem loopback-interface in jede richtung durchlassen
pass quick on lo0 all

# ,spoofing'-schutz für das interne interface aktivieren.
antispoof quick for $int_if inet

# nur ssh-verbindungen vom lokalen netzwerk erlauben, wenn es von dem
# computer 192.168.0.15 kommt, dem man vertrauen kann. verwende
# ,block return', so dass ein TCP-RST gesendet wird, um blockierte
# Verbindungen sofort zu schließen. verwende ,quick', sodass diese
# regel nicht von der ,pass'-regel weiter unten überschrieben wird.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh flags S/SA

# den gesamten verkehr von und zum lokalen netzwerk durchlassen
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# tcp, udp und icmp durch das externe (internet-)interface rauslassen.
# halte den ,state' für udp und icmp und ,modulate state' für tcp.
pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state

# erlaube eingehende ssh-verbindungen auf dem externen interface, so
# lange sie NICHT für die firewall bestimmt sind (z.B. wenn sie an eine
# maschine im lokalen netzwerk gerichtet sind). zeichne das erste
# paket auf, so dass wir später sagen können, wer versucht, zu verbinden.
# verwende den tcp-syn-proxy um einen proxy für diese verbindung
# aufzubauen.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh flags S/SA synproxy state

</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Zurück: Tabellen</a>]
[<a href="index.html">Inhalt</a>]
[<a href="nat.html">Weiter: Network Address Translation</a>]

<p>
<hr>
<a href="../../de/index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: filter.html,v 1.25 ]<br>
$Translation: filter.html,v 1.3 2004/12/07 16:56:32 paldium Exp $<br>
$OpenBSD: filter.html,v 1.3 2004/12/08 05:22:43 saad Exp $
</small>

</body>
</html> 
