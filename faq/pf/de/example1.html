<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Beispiel: Firewall für zuhause oder ein kleines Büro</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, 2004 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="carp.html">Zurück: Firewall-Redundanz mit CARP und pfsync</a>]
[<a href="index.html">Inhalt</a>]

<p>
<h1><font color="#e00000">PF: Beispiel: Firewall für zuhause oder ein kleines Büro</font></h1>
<hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#scenario">Das Szenario</a>
	<ul>
	<li><a href="#network">Das Netzwerk</a>
	<li><a href="#objective">Das Ziel</a>
	<li><a href="#prep">Vorbereitung</a>
	</ul>
<li><a href="#ruleset">Der Regelsatz</a>
	<ul>
	<li><a href="#macros">Makros</a>
	<li><a href="#options">Optionen</a>
	<li><a href="#rules">Firewall-Regeln</a>
	</ul>
<li><a href="#allrules">Der komplette Regelsatz</a>
</ul>

<hr>

<a name="scenario"></a>
<h2>Das Szenario</h2>
In diesem Beispiel läuft PF auf einer OpenBSD-Maschine, deren Aufgabe
es ist, als Firewall und NAT-Gateway für ein kleines Netzwerk zuhause
oder in einem Büro zu agieren. Das Gesamtziel ist, dem Netzwerk
Internetzugriff und begrenzten Zugriff zur Firewallmaschine
vom Internet aus zu gewähren. Des Weiteren soll ein interner Webserver
vom Internet aus erreichbar gemacht werden. Dieses Dokument wird einen
kompletten Regelsatz durchgehen, der genau das macht.

<a name="network"></a>
<h3>Das Netzwerk</h3>
Das Netzwerk ist wie folgt aufgebaut:

<pre>

  [ COMP1 ]    [ COMP3 ]
      |            |
   ---+------+-----+------- xl0 [ OpenBSD ] fxp0 -------- ( Internet )
             |
         [ COMP2 ]

</pre>

<p>
In diesem internen Netzwerk befinden sich einige Computer. Das Diagramm
zeigt drei, aber die tatsächliche Anzahl ist unbedeutend. Diese Computer
sind reguläre Arbeitsplätze, die fürs Websurfen, E-Mail, Chatten etc.
verwendet werden. COMP3 ist eine Ausnahme, da er als kleiner Webserver
läuft. Das interne Netzwerk verwendet den Netzwerkblock
192.168.0.0/255.255.255.0.

<p>
Die OpenBSD-Firewall ist ein Celeron 300 mit zwei Netzwerkkarten: eine
3com 3c509B (<tt>xl0</tt>) und eine Intel EtherExpress Pro/100
(<tt>fxp0</tt>). Die Firewall hat eine Kabelverbindung zum Internet und
verwendet NAT, um diese Verbindung mit dem internen Netzwerk zu teilen.
Die IP-Adresse des externen Interfaces wird vom Internetprovider
dynamisch zugewiesen.

<a name="objective"></a>
<h3>Das Ziel</h3>
Die Ziele sind:
<ul>
<li>Biete jedem internen Computer unbegrenzten Internetzugriff an.
<li>Verwende einen »standardmäßig blocken«-Filterregelsatz.
<li>Lasse folgenden eingehenden Verkehr für die Firewall vom Internet
aus zu:
	<ul>
	<li>SSH (TCP-Port 22): wird für externe Wartung der
	Firewallmaschine benötigt.
	<li>Auth/Ident (TCP-Port 113): wird von einigen Diensten wie
	zum Beispiel SMTP und IRC verwendet.
	<li>ICMP-Echo-Anfragen: der ICMP-Pakettyp, der von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&amp;sektion=8"
>ping(8)</a>
	verwendet wird.
	</ul>
<li>Leite TCP-Port-80-Verbindungsanfragen (die versuchen, auf den
Webserver zuzugreifen) zum Computer COMP3 weiter.
Lasse ebenfalls TCP-Port-80-Verkehr durch die Firewall zu, der für
COMP3 bestimmt ist.
<li>Zeichne Filterstatistiken auf dem externen Interface auf.
<li>Antworte standardmäßig mit TCP RST oder ICMP Unreachable auf
geblockte Pakete.
<li>Mache die Regelsätze so simpel und einfach zu verwaltend wie
möglich.
</ul>

<a name="prep"></a>
<h3>Vorbereitung</h3>
Dieses Dokument nimmt an, dass der OpenBSD-Host ordentlich
konfiguriert wurde, sodass er als Router funktioniert - einschließlich
der Überprüfung der IP-Netzwerkeinstellungen, Internetverbindung
und dass die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3"
>sysctl(3)</a>-Variablen <tt>net.inet.ip.forwarding</tt> und/oder
<tt>net.inet6.ip6.forwarding</tt> auf »<tt>1</tt>« eingestellt
wurde. Du musst ebenfalls PF mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+5.4"
>pfctl(8)</a> starten oder die entsprechende Variable in
<tt>/etc/rc.conf.local</tt> aktivieren.
PF ist seit dem Release OpenBSD 4.6 standarmäßig aktiviert.

<a name="ruleset"></a>
<h2>Der Regelsatz</h2>
Das nächste Kapitel wird Schritt für Schritt durch einen Regelsatz
gehen, der die zuvor genannten Ziele realisiert.

<a name="macros"></a>
<h3>Makros</h3>
Die folgenden Makros wurden definiert, um die Wartung und das Lesen
des Regelsatzes einfacher zu machen:
<blockquote><pre>
int_if="xl0"

tcp_services="{ 22, 113 }"
icmp_types="echoreq"

comp3="192.168.0.3"
</pre></blockquote>

<p>
Die erste Zeile definiert eine interne Netzwerkschnittstelle, auf der das
Filtern stattfinden wird.
Da wir sie hier definieren, können wir den Regelsatz bei
einer Hardwareumstellung so belassen wie er ist und müssen lediglich
diese eine Zeile ändern.
(Für dieses Beispiel wird die externe Schnittstelle von der <tt>egress</tt>
Schnittstellengruppe gehandhabt.
In dieser finden sich alle Schnittstellen, für die eine Standard-Route gesetzt
ist, in diesem Fall fxp0.)
Die zweite und dritte Zeile listen die TCP-Portnummern der Dienste auf, die dem
Internet gegenüber offengelegt
werden (SSH und ident/auth) und den ICMP-Pakettyp, dem erlaubt wird,
die Firewallmaschine zu erreichen. Zum Schluss definiert die letzte
Zeile die IP-Adresse von COMP3.

<p>
<b>Hinweis</b>: Wenn die Internetverbindung
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4"
>PPPoE</a> benötigt, werden Filter und NAT auf der Schnittstelle
<tt>pppoe0</tt> stattfinden und <i>nicht</i> auf der egress-Schnittstelle
(<tt>fxp0</tt>).

<a name="options"></a>
<h3>Optionen</h3>
Die folgenden beiden Optionen werden die standardmäßige Antwort für
<tt>block</tt>-Filterregeln setzen und Statistikaufzeichnungen für
das externe Interface anstellen:
<blockquote><pre>
set block-policy return
set loginterface egress
</pre></blockquote>

<p>
Jedes Unix-System hat ein sogenanntes Loopbackinterface. Hierbei
handelt es sich um ein virtuelles Netzwerkinterface, das von
Applikationen genutzt wird, um mit anderen auf dem gleichen System zu
kommunizieren. Unter OpenBSD ist das Loopbackinterface
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4"
>lo(4)</a>.
Es ist allgemein gute Praxis, jegliches Filtern auf den
Loopbackinterfaces zu unterbinden. Die Verwendung von
<a href="options.html#skip">set skip</a> bewerkstelligt dies.
<blockquote><pre>
set skip on lo
</pre></blockquote>
<!-- XXX this should be interface groups, but PF (at least up to
4.8) just does a substring match on the interface name -->
Beachte, dass wir alle <tt>lo</tt>-Schnittstellen überspringen.
Auf diese Weise können wir später noch Loopbackinterfaces hinzufügen,
ohne dass wir uns Gedanken darüber machen müssten, diesen Teil unseres
Regelsatzes anzupassen.

<a name="rules"></a>
<h3>Firewall-Regeln</h3>

Wir starten mit Regeln zur Unterstützung des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+5.4"
>ftp-proxy(8)</a>, sodass sich FTP-Clients des lokalen Netzwerks mit
FTP-Servern im Internet verbinden können.
Dies funktioniert durch dynamisches Einfügen von Regeln, wenn eine
FTP-Verbindung aufgebaut wird.
Dies wird mit Hilfe von <a href="anchors.html">Ankern</a> bewerkstelligt:
<blockquote><pre>
anchor "ftp-proxy/*"
</pre></blockquote>

<p>
Nun fügen wir die Regel hinzu, die benötigt wird, um FTP-Verbindungen
dergestalt umzuleiten, dass sie vin ftp-proxy(8) gesehen werden:
<blockquote><pre>
pass in quick on $int_if inet proto tcp to any port ftp \
    divert-to 127.0.0.1 port 8021
</pre></blockquote>

<p>
Diese Regel fängt jegliche FTP-Verbindung zu Port 21 ab, leitet sie zu der
ftp-proxy(8)-Instanz auf Port 8021 um, und vermeidet, durch Nutzung des
Schlüsselworts <tt>quick</tt>, eine Abarbeitung von entsprechenden Paketen
durch den Rest des Regelsatzes.
Verbinden sich Benutzer regulär auf anderen Ports mit FTP-Servern, so sollte
eine Liste mit Zielports spezifiziert werden, zum Beispiel:
<tt>to any port { 21, 2121 }</tt>.

<p>
Beachte, dass sich sowohl der <a href="anchors.html">Anker</a>, als auch die
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+5.4"
>ftp-proxy(8)</a> Umleitungsregel vor jeglicher <tt>match</tt>-Regel für NAT
befinden müssen, oder andernfalls wird der ftp-proxy(8) nicht wie erwartet
funktionieren.

<p>
Machen wir weiter mit einigen <tt>match</tt>-Regeln.
Für sich selbst kann eine <tt>match</tt>-Regel nicht festzustellen, ob es einem
Paket erlaubt ist, zu passieren.
Stattdessen werden die Parameter der Regel erinnert, denen ein Paket entsprach;
diese werden dann für jegliche, die Pakete weiterverarbeitenden
<tt>pass</tt>-Regeln benutzt.

<p>
Dies ist leistungsfähig: Parameter wie <a href="nat.html">NAT</a> oder
<a href="queueing.html">Warteschlangen</a> können auf bestimmte Klassen von
Paketen angewendet werden, und so können Zugriffsrechte separat definiert
werden.

<p>
Um NAT für das gesamtes internes Netzwerk auszuführen, wird die folgende
<tt>match</tt>-Regel genutzt:
<blockquote><pre>
match out on egress inet from !(egress:network) to any nat-to (egress:0)
</pre></blockquote>

<p>
In diesem Fall könnte das »<tt>!(egress:network)</tt>« einfach durch ein
»<tt>$int_if:network</tt>« ersetzt werden, aber wenn du mehrere interne
Schnittstellen hinzufügen würdest, so müsstest du zusätzliche NAT-Regeln
hinzufügen, währenddessen mit dieser Struktur NAT auf allen geschützten
Schnittstellen ausgeführt wird.

<p>
Da die IP-Adressen der externen Schnittstelle dynamisch zugewiesen werden,
werden Klammern um die Übersetzungsschnittstelle gesetzt, sodass PF bemerkt,
wenn sich eine Adresse ändert.
Die Nachsilbe :0 wird benutzt so dass, falls die externe Schnittstelle mehrere
Adressen besitzt, nur die erste Adresse für die Übersetzung benutzt wird.

<p>
Zuletzt wird die Protokollfamilie <tt>inet</tt> (IPv4) spezifiziert.
Dies verhindert die Übersetzung aller <tt>inet6</tt> (IPv6)-Pakete, welche
eventuell empfangen werden.

<p>
Nun die Regeln zur Kontrolle von Zugriffsrechten.
Beginne mit der standardmäßigen Verweigerung.
<blockquote><pre>
block in log
</pre></blockquote>

<p>
An diesem Punkt wird jeglicher Datenverkehr, der versucht, in eine
Schnittstelle zu gelangen, blockiert, selbst solcher aus dem internen Netzwerk.
Alle diese Pakete werden protokolliert.
Spätere Regeln werden die Firewall für obige Objektiven öffnen, und ebenfalls
alle notwendigen virtuellen Schnittstellen öffnen.

<p>
Denke daran, PF kann sowohl in eine Schnittstelle eingehenden, als auch aus
einer Schnittstelle ausgehenden Verkehr blocken.
Es kann dein Leben vereinfachen, wenn du dich dafür entscheidest, den Verkehr
einer Richtung zu filtern, anstatt zu versuchen die Dinge einfach zu halten,
wenn man einige Sachen in der einen, und andere in der anderen Richtung
filtert.
In unserem Fall entscheiden wir uns dafür, den eingehenden Verkehr zu filtern,
aber sobald der Datenverkehr einmal für die Schnittstelle zugelassen ist,
werden wir nicht mehr versuchen, sie am Verlassen zu hindern,
sodass wir bei folgendem Konstrukt enden:

<blockquote><pre>
pass out quick
</pre></blockquote>

Durch Nutzung von <tt>quick</tt> wird die Überprüfung ausgehender Pakete durch
folgende Regeln vermieden, was die Leistung erhöht.

<p>
Die <a href="filter.html#antispoof">Blockade gefälschter Adressen</a> ist gut:
<blockquote><pre>
antispoof quick for { lo $int_if }
</pre></blockquote>

<p>
Nun öffne die Ports, die von den Netzwerkdiensten genutzt werden, die über das
Internet erreichbar sein sollen.
Zuerst, der Verkehr, der für die Firewall selbst bestimmt ist:

<blockquote><pre>
pass in on egress inet proto tcp from any to (egress) \
    port $tcp_services
</pre></blockquote>

<p>
Die Spezifikation der Netwerk-Ports durch das Makro <tt>$tcp_services</tt>
macht das Öffnen weiterer Dienste für das Internet einfach, da einzig das Makro
geändert, und der Regelsatz neu geladen werden muss.
UDP-Dienste können ebenfalls, durch die Erzeugung eines Makros
<tt>$udp_services</tt> und dem Hinzufügen einer Filterregel ähnlich der obigen,
die jedoch <tt>proto udp</tt> spezifizieren muss, geöffnet werden.

<p>
Die nächste Regel fängt alle Versuche ab, aus dem Internet zu dem TCP-Port 80
der Firewall eine Verbindung aufzubauen.
Legitime Versuche, auf diesen Port zuzugreifen, kommen von Benutzern, die auf
den Webserver des Netzwerks zugreifen möchten.
Diese Verbindungsversuche müssen zu COMP3 umgeleitet werden:

<blockquote><pre>
pass in on egress inet proto tcp to (egress) port 80 rdr-to $comp3
</pre></blockquote>

<p>
ICMP-Datenverkehr muss durchgelassen werden:
<blockquote><pre>
pass in inet proto icmp all icmp-type $icmp_types
</pre></blockquote>

<p>
Ähnlich dem Makro <tt>$tcp_services</tt> kann ein Makro <tt>$icmp_types</tt>
einfach editiert werden, um die Arten von ICMP-Paketen, denen es erlaubt
werden soll, die Firewall zu erreichen, zu ändern.
Beachte, dass diese Regel für alle Netzwerkschnittstellen gilt.

<p>
Nun muss der Datenverkehr zu und von dem internen Netzwerk durchgelassen
werden.
Wir nehmen an, dass die Benutzer des internen Netzwerks wissen was sie tun, und
keinerlei Ärger verursachen.
Dies ist nicht notwendigerweise eine richtige Annahme; ein viel restriktiverer
Regelsatz wäre in vielen Umgebungen angemessen.
<blockquote><pre>
pass in on $int_if
</pre></blockquote>

<p>
TCP-, UDP- und ICMP-Datenverkehr ist es durch die frühere Zeile
»<tt>pass out</tt>« erlaubt, die Firewall in Richtung Internet zu verlassen.
Zustandsinformationen werden aufbewahrt, sodass zurückkommende Pakete ihren
Weg zurück durch die Firewall nehmen können.

<a name="allrules"></a>
<h2>Der komplette Regelsatz</h2>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# macros

int_if="xl0"

tcp_services="{ 22, 113 }"
icmp_types="echoreq"

comp3="192.168.0.3"

# options

set block-policy return
set loginterface egress
set skip on lo

# FTP Proxy rules

anchor "ftp-proxy/*"

pass in quick on $int_if inet proto tcp to any port ftp \
    divert-to 127.0.0.1 port 8021

# match rules

match out on egress inet from !(egress:network) to any nat-to (egress:0)

# filter rules

block in log
pass out quick

antispoof quick for { lo $int_if }

pass in on egress inet proto tcp from any to (egress) \
    port $tcp_services

pass in on egress inet proto tcp to (egress) port 80 rdr-to $comp3

pass in inet proto icmp all icmp-type $icmp_types

pass in on $int_if
</pre>
</td></tr>
</table>

<p>
[<a href="carp.html">Zurück: Firewall-Redundanz mit CARP und pfsync</a>]
[<a href="index.html">Inhalt</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: example1.html,v 1.54 ]<br>
$Translation: example1.html,v 1.37 2013/11/01 16:59:45 steffen Exp $<br>
-->
$OpenBSD: example1.html,v 1.35 2013/11/01 18:04:05 ajacoutot Exp $
</small>

</body>
</html>
