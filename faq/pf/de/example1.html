<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Beispiel: Firewall für zuhause oder ein kleines Büro</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="Die OpenBSD-FAQ-Seite">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, 2004 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="carp.html">Zurück: Firewal-Redundanz mit CARP und pfsync</a>]
[<a href="index.html">Inhalt</a>]

<p>
<h1><font color="#e00000">PF: Beispiel: Firewall für zuhause oder ein kleines Büro</font></h1>
<hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#scenario">Das Szenario</a>
	<ul>
	<li><a href="#network">Das Netzwerk</a>
	<li><a href="#objective">Das Ziel</a>
	<li><a href="#prep">Vorbereitung</a>
	</ul>
<li><a href="#ruleset">Der Regelsatz</a>
	<ul>
	<li><a href="#macros">Makros</a>
	<li><a href="#options">Optionen</a>
	<li><a href="#scrub">Scrub</a>
	<li><a href="#nat">Network Address Translation</a>
	<li><a href="#rdr">Redirection</a>
	<li><a href="#filter">Filter-Regeln</a>
	</ul>
<li><a href="#allrules">Der komplette Regelsatz</a>
</ul>

<hr>

<a name="scenario"></a>
<h2>Das Szenario</h2>
In diesem Beispiel läuft PF auf einer OpenBSD-Maschine, derren Aufgabe
es ist, als Firewall und NAT-Gateway für ein kleines Netzwerk zuhause
oder in einem Büro zu agieren. Das gesamte Ziel ist, dem Netzwerk
Internetzugriff und begrenzten Zugriff zur Firewall-Maschine
vom Internet aus zu gewähren. Dieses Dokument wird einen kompletten
Regelsatz durchgehen, der genau das macht.

<a name="network"></a>
<h3>Das Netzwerk</h3>
Das Netzwerk ist wie folgt aufgebaut:

<pre>
    
  [ COMP1 ]    [ COMP3 ]
      |            |                               ADSL
   ---+------+-----+------- fxp0 [ OpenBSD ] ep0 -------- ( Internet )
             |
         [ COMP2 ]

</pre>

<p>
In diesem internen Netzwerk befinden sich einige Computer; das Diagramm
zeigt drei, aber die tatsächliche Anzahl ist unbedeutend. Diese Computer
sind reguläre Arbeitsplätze, die für Web-Surfen, E-Mail, Chatten, etc.
verwendet werden, außer COMP3, welcher als kleiner Webserver läuft.
Das interne Netzwerk verwendet den 192.168.0.0 / 255.255.255.0-Netzwerkblock.

<p>
Der OpenBSD-Router ist ein Pentium 100 mit zwei Netzwerkkarten: eine
3com 3c509B (<tt>ep0</tt>) und eine Intel EtherExpress Pro/100
(<tt>fxp0</tt>).
Der Router hat eine ADSL-Verbindung zum Internet und verwendet NAT, um
diese Verbindung mit dem internen Netzwerk zu teilen. Die IP-Adresse
des externen Interfaces wird vom Internet-Provider dynamisch
zugewiesen.

<a name="objective"></a>
<h3>Das Ziel</h3>
Die Ziele sind:
<ul>
<li>Biete jedem internen Computer unbegrenzten Internetzugriff an.
<li>Verwende einen ,standardmäßiges Blocken'-Filter-Regelsatz.
<li>Lasse folgenden eingehenden Verkehr für die Firewall vom Internet
aus zu:
	<ul>
	<li>SSH (TCP-Port 22): Dies wird für externe Wartung der
	Firewall-Maschine benötigt.
	<li>Auth/Ident (TCP-Port 113): wird von einigen Diensten wie
	zum Beispiel SMTP und IRC verwendet.
	<li>ICMP-Echo-Anfragen: der ICMP-Pakettyp, der von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&amp;sektion=8&amp;manpath=OpenBSD+3.7"
>ping(8)</a>
	verwendet wird.
	</ul>
<li>Leite TCP-Port-80-Verbindungsanfragen (die versuchen, auf den
Webserver zuzugreifen) auf Computer COMP3 weiter.
Lasse ebenfalls TCP-Port-80-Verkehr durch die Firewall zu, der für
COMP3 bestimmt ist.
<li>Zeichne Filter-Statistiken auf dem externen Interface auf.
<li>Antworte standardmäßig mit TCP RST oder ICMP Unreachable auf
geblockte Pakete.
<li>Mache die Regelsätze so simpel und einfach zu verwaltend wie
möglich.
</ul>

<a name="prep"></a>
<h3>Vorbereitung</h3>
Dieses Dokument nimmt an, dass der OpenBSD-Host ordentlich
konfiguriert wurde, so dass er als Router funktioniert, einschließlich
der Überprüfung der IP-Netzwerk-Einstellungen, Internetverbindung
und dass <tt>net.inet.ip.forwarding</tt> auf ,<tt>1</tt>' eingestellt
wurde.

<a name="ruleset"></a>
<h2>Der Regelsatz</h2>
Das nächste Kapitel wird Schritt für Schritt durch einen Regelsatz
gehen, der die zuvor genannten Ziele erreichen wird.

<a name="macros"></a>
<h3>Makros</h3>
Die folgenden Makros wurden definiert, um die Wartung und das Lesen
des Regelsatzes einfacher zu machen:
<blockquote>
<tt>
int_if = "fxp0"<br>
ext_if = "ep0"<br>
<br>
tcp_services = "{ 22, 113 }"<br>
icmp_types = "echoreq"<br>
<br>
priv_nets = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
<br>
<br>
comp3 = "192.168.0.3"
</tt>
</blockquote>

<p>
Die ersten beiden Zeilen definieren das Netzwerk-Interface, auf dem
das Filtern stattfinden wird. Die dritte und vierte Zeile listen die
TCP-Portnummern der Dienste auf, die dem Internet gegenüber offengelegt
werden (SSH und ident/auth) und den ICMP-Pakettyp, dem erlaubt wird,
die Firewall-Maschine zu erreichen.
Die fünfte Zeile definiert das Loopback und die
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>-Adressblöcke.
Und zum Schluss definiert die letzte Zeile die IP-Adresse von COMP3.

<p>
<b>Hinweis</b>: Wenn die ADSL-Internetverbindung 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8&amp;manpath=OpenBSD+3.7"
>PPPoE</a> benötigt, dann werden Filter und NAT auf dem
<tt>tun0</tt>-Interface stattfinden und <i>nicht</i> auf <tt>ep0</tt>.

<a name="options"></a>
<h3>Optionen</h3>
Die folgenden beiden Optionen werden die standardmäßige Antwort für
<tt>block</tt>-Filterregeln setzen und Statistik-Aufzeichnungen für
das externe Interface anstellen:
<blockquote>
<tt>
set block-policy return<br>
set loginterface $ext_if
</tt>
</blockquote>

<a name="scrub"></a>
<h3>Scrub</h3>
Es gibt keinen Grund, das empfohlene ,scrubbing', das auf den gesamten
eingehenden Verkehr angewandt wird, nicht zu verwenden, so dass dies ein
einfacher Einzeiler ist:
<blockquote>
<tt>
scrub in all
</tt>
</blockquote>

<a name="nat"></a>
<h3>Network Address Translation</h3>
Um NAT auf das gesamte interne Netzwerk durchzuführen, wird folgende
<tt>nat</tt>-Regel verwendet:
<blockquote>
<tt>
nat on $ext_if from $int_if:network to any -&gt; ($ext_if)
</tt>
</blockquote>

<p>
Da die IP-Adresse des externen Interfaces dynamisch zugewiesen wird,
werden Klammern um das Übersetzungs-Interface herum gesetzt, so dass PF
bemerken wird, wenn die Adresse sich ändert.

<a name="rdr"></a>
<h3>Umleitung</h3>
Die erste benötigte Umleitungs-Regel ist für
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.7"
>ftp-proxy(8)</a>, so dass sich FTP-Clients vom lokalen Netzwerk aus
auf FTP-Server im Internet verbinden können.
<blockquote>
<tt>
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</tt>
</blockquote>

<p>
Bedenke, dass diese Regel nur FTP-Verbindungen auf Port 21 erfasst wird. Wenn
sich Benutzer auf regulärer Basis auf FTP-Server auf anderen Ports verbinden,
sollte eine Liste verwendet werden, die die Ziel-Ports angibt, zum
Beispiel: <tt>from any to any port { 21, 2121 }</tt>.

<p>
Die zweite Umleitungs-Regel erfasst alle Versuche von Personen im
Internet, die auf den TCP-Port 80 der Firewall verbinden wollen.
Berechtigte Versuche, diesen Port zu erreichen, werden von Benutzern
sein, die versuchen, den Webserver vom Netzwerk zu erreichen.
Dieser Verbindungsversuch muss auf COMP3 weitergeleitet werden:

<blockquote>
<tt>
rdr on $ext_if proto tcp from any to any port 80 -&gt; $comp3
</tt>
</blockquote>

<a name="filter"></a>
<h3>Filter-Regeln</h3>
Nun die Filterregeln. Fange mit standardmäßigem Blocken an:
<blockquote>
<tt>
block all<br>
</tt>
</blockquote>

<p>
Zu diesem Zeitpunkt wird nichts durch die Firewall gelassen, nicht
einmal vom internen Netzwerk. Die folgenden Regeln werden die Firewall,
den oben genannten Zielen entsprechend, öffnen, so wie alle benötigten
virtuellen Interfaces.

<p>
Jedes Unix-System hat ein ,loopback'-Interface. Es ist ein virtuelles
Netzwerk-Interface, das von Applikationen verwendet wird, um auf dem
gleichen System untereinander zu kommunizieren. Generell gilt, dass
der gesamte Verkehr auf dem Loopback-Interface durchgelassen werden
sollte. Unter OpenBSD ist 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4&amp;manpath=OpenBSD+3.7"
>lo(4)</a> das Loopback-Interface.
<blockquote>
<tt>
pass quick on lo0 all
</tt>
</blockquote>

<p>
Als nächstes werden die
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>-Adressen
geblockt, wenn sie vom externen Interface herkommen. Diese
Adressen sollten niemals im öffentlichen Internet auftauchen, und
das Herausfiltern stellt sicher, dass der Router diese nicht aus
dem internen Netzwerk aus "auslaufen" (,leak') lässt und blockt ebenfalls
jegliche eingehenden Pakete mit einer Quell-Adresse, die aus einem dieser
Netzwerke kommt.
<blockquote>
<tt>
block drop in &nbsp;quick on $ext_if from $priv_nets to any<br>
block drop out quick on $ext_if from any to $priv_nets
</tt>
</blockquote>

<p>
Bedenke, dass <tt>blockdrop</tt> verwendet wird, um PF zu sagen, dass
nicht mit einem TCP-RST- oder ICMP-Unreachable-Paket geantwortet soll.
Da die RFC-1918-Adressen im Internet nicht existieren, werden jegliche
Pakete, die dorthin gesendet werden, niemals ankommen. Die
<tt>quick</tt>-Option wird benutzt, um PF zu sagen, dass der Rest der
Filterregeln nicht berücksichtigt werden soll, wenn eine der
vorherigen Regeln zutrifft; Pakete zu oder von den
<tt>$priv_nets</tt>-Netzwerken unverzüglich fallen lassen.

<p>
Nun öffne die Ports, die von den Netzwerkdiensten genutzt werden, die
für das Internet verfügbar sein sollen:
<blockquote>
<tt>
pass in on $ext_if inet proto tcp from any to ($ext_if) \<br>
&nbsp;&nbsp;&nbsp;port $tcp_services flags S/SA keep state
</tt>
</blockquote>

<p>
Die Netzwerk-Ports in dem Makro <tt>$tcp_services</tt> anzugeben, macht
es simpel, zusätzliche Dienste dem Internet anzubieten, indem diese
in dem Makro eingetragen werden und der Regelsatz neugeladen wird.
UDP-Dienste können ebenfalls geöffnet werden, indem ein
<tt>$udp_services</tt>-Makro erstellt wird und eine Filterregel so wie
oben angegeben hinzugefügt wird, die <tt>proto udp</tt> angibt.

<p>
Zusätzlich zur <tt>rdr</tt>-Regel, die den Webserver-Verkehr zu COMP3
weiterleitet, MÜSSEN wir ebenfalls diesen Verkehr durch die Firewall
leiten:
<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $comp3 port 80 \<br>
&nbsp;&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Für ein bisschen mehr Sicherheit werden wir den
<a href="filter.html#synproxy">TCP-SYN-Proxy</a> verwenden, um den
Webserver noch besser zu beschützen.

<p>
Damit wir in der Lage sind, aktive FTP-Verbindungen vom LAN aus
nutzen zu können, muss folgende Regel vorhanden sein, die die
ftp-data-Verbindung, die vom FTP Server eingeleitet wurde, zurück
zum Client lässt.
Da FTP-Verbindungen wegen ftp-proxy durch einen Proxy laufen, wird
die ftp-data-Verbindung tatsächlich angenommen, so dass die Daten zum
Client im LAN weitergeleitet werden.
<blockquote>
<tt>
pass in on $ext_if inet proto tcp from port 20 to ($ext_if) \<br>
&nbsp;&nbsp;&nbsp;&nbsp;user proxy flags S/SA keep state
</tt>
</blockquote>

<p>
ICMP-Verkehr muss nun durchgelassen werden:
<blockquote>
<tt>
pass in inet proto icmp all icmp-type $icmp_types keep state
</tt>
</blockquote>

<p>
Dem <tt>$tcp_services</tt>-Makro ähnlich, kann der <tt>$icmp_types</tt>-Makro
einfach editiert werden, um die Typen der ICMP-Pakete zu
ändern, denen erlaubt wird, die Firewall zu erreichen. Bedenke, dass
diese Regel auf alle Netzwerk-Interfaces zutrifft.

<p>
Nun muss der Verkehr zu und vom internen Netzwerk zugelassen werden.
Wir nehmen an, dass die Benutzer im internen Netzwerk wissen, was
sie tun und keinen Ärger verursachen werden. Dies ist
nicht notwendigerweise eine gültige Annahme; ein sehr viel
restriktiverer Regelsatz wäre für bestimmte Umgebungen angebrachter.
<blockquote>
<tt>
pass in on $int_if from $int_if:network to any keep state
</tt>
</blockquote>

<p>
Die gerade genannte Regel wird jeglichen internen Maschinen erlauben,
Pakete durch die Firewall zu senden; jedoch wird sie der Firewall
<i>nicht</i> erlauben, eine Verbindung zu internen Maschinen
aufzubauen. Ist das eine gute Idee? Das kommt auf die genaueren
Details des Netzwerkaufbaus an. Wenn die Firewall ebenfalls ein
DHCP-Server ist, muss sie eventuell erst eine Adresse ,anpingen', um
ihre Verfügbarkeit sicherzustellen, bevor sie zugewiesen wird. Der
Firewall zu erlauben, eine Verbindung in das interne Netzwerk aufbauen
zu können, ermöglicht es jemanden, der mit ssh auf die Firewall vom
Internet aus zugegriffen hat, auf Maschinen im internen Netzwerk
zuzugreifen. 
Behalte aber im Hinterkopf, dass es kein großer Sicherheitsvorteil ist,
wenn man der Firewall <i>nicht</i> die Möglichkeit gibt, direkt mit dem
Netzwerk zu kommunizieren; wenn jemand Zugriff auf die Firewall erhält,
könnte es eventuell sein, dass dieser die Filterregeln sowieso ändert.
Durch das Hinzufügen dieser Regel wird die Firewall in der Lage sein,
Verbindungen ins interne Netzwerk aufzubauen:
<blockquote>
<tt>
pass out on $int_if from any to $int_if:network keep state
</tt>
</blockquote>

<p>
Bedenke, dass, wenn beide Zeilen vorhanden sind, die
<tt>keep state</tt>-Option nicht benötigt wird; alle Pakete werden in
der Lage sein, das interne Interface zu passieren, da hier eine Regel
ist, die Pakete in beide Richtungen durchlässt. Trotz allem, wenn die
<tt>pass out</tt>-Zeile <i>nicht</i> mit eingebunden ist, <i>muss</i>
die <tt>pass in</tt>-Zeile <tt>keep state</tt> mit einbinden. Es gibt
sogar einen Leistungsbonus, wenn man ,keep state' verwendet:
,State'-Tabellen werden verarbeitet, bevor die Regeln überprüft werden,
und wenn eine ,state'-Übereintreffung gefunden wird, wird das Paket
durch die Firewall gelassen, ohne dass die Regelsatzüberprüfung
durchlaufen werden muss, obwohl solch ein einfaches System wahrscheinlich
nicht genug Last aufbringen wird, als dass es einen Unterschied machen
könnte.

<p>
Schlussendlich muss der Verkehr aus dem externen Interface gelassen
werden:
<blockquote>
<tt>
pass out on $ext_if proto tcp all modulate state flags S/SA<br>
pass out on $ext_if proto { udp, icmp } all keep state
</tt>
</blockquote>

<p>
TCP-, UDP- und ICMP-Verkehr darf die Firewall in Richtung Internet
verlassen. ,State'-Informationen werden aufbewahrt, so dass die
wiederkommenden Pakete durch die Firewall gelassen werden.

<a name="allrules"></a>
<h2>Der komplette Regelsatz</h2>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# makros
int_if = "fxp0"
ext_if = "ep0"

tcp_services = "{ 22, 113 }"
icmp_types = "echoreq"

priv_nets = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
	  
comp3 = "192.168.0.3"

# optionen
set block-policy return
set loginterface $ext_if

# scrub
scrub in all

# nat/rdr
nat on $ext_if from $int_if:network to any -&gt; ($ext_if)
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 \
   port 8021
rdr on $ext_if proto tcp from any to any port 80 -&gt; $comp3

# filterregeln
block all

pass quick on lo0 all

block drop in  quick on $ext_if from $priv_nets to any
block drop out quick on $ext_if from any to $priv_nets

pass in on $ext_if inet proto tcp from any to ($ext_if) \
   port $tcp_services flags S/SA keep state

pass in on $ext_if proto tcp from any to $comp3 port 80 \
   flags S/SA synproxy state

pass in on $ext_if inet proto tcp from port 20 to ($ext_if) \
   user proxy flags S/SA keep state

pass in inet proto icmp all icmp-type $icmp_types keep state

pass in  on $int_if from $int_if:network to any keep state
pass out on $int_if from any to $int_if:network keep state

pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state
</pre>
</td></tr>
</table>

<p>
[<a href="carp.html">Zurück: Firewal-Redundanz mit CARP und pfsync</a>]
[<a href="index.html">Inhalt</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: example1.html,v 1.20 ]
$Translation: example1.html,v 1.10 2005/09/14 16:16:38 paldium Exp $
-->
$OpenBSD: example1.html,v 1.9 2005/09/20 07:30:02 saad Exp $
</small>

</body>
</html> 
