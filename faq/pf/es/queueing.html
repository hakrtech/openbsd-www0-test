<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Gestión del ancho de banda</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2005 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../es/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="anchors.html">Anterior: Anclajes</a>]
[<a href="index.html">Contenido</a>]
[<a href="pools.html">Siguiente: Reserva de direcciones y balanceo
de carga</a>]

<p>
<h1><font color="#e00000">PF: Gestión del ancho de banda</font></h1>


<hr>

<h3>Índice de contenidos</h3>
<ul>
<li><a href="#queueing">Colas de procesamiento</a>
<li><a href="#sched">Planificadores</a>
	<ul>
	<li><a href="#cbq">Colas basadas en clases</a>
	<li><a href="#priq">Colas basadas en prioridades</a>
	<li><a href="#red">Detección aleatoria anticipada</a>
	<li><a href="#ecn">Notificación explícita de
	congestión</a>
	</ul>
<li><a href="#altq">Configuración de la formación de
colas</a>
<li><a href="#assign">Asignación de tráfico a una cola</a>
<li><a href="#example1">Ejemplo #1: Red doméstica</a>
<li><a href="#example2">Ejemplo #2: Red corporativa</a>
</ul>

<hr>

<a name="queueing"></a>
<h2>Colas de procesamiento</h2>
<p>
Poner algo en cola es almacenarlo en orden, a la espera de ser
procesado.  En una red de ordenadores, cuando se envían paquetes
desde un anfitrión, estos entran en un sistema de colas en
el que permanecen hasta ser procesados por el sistema operativo.
Entonces el sistema operativo decide qué cola debe procesar y
qué paquete o paquetes de dicha cola.  El orden en el que el
sistema operativo selecciona los paquetes que va a procesar puede
afectar al rendimiento de la red.  Pongamos por ejemplo un usuario que
estuviera ejecutando dos aplicaciones de red:  SSH y FTP.  Lo ideal
sería procesar los paquetes de SSH antes que los de FTP, por la
propia naturaleza de SSH;  cuando se pulsa una tecla en el cliente SSH
se espera obtener una respuesta inmediata, mientras que un retraso de
unos pocos segundos en una transferencia por FTP pasa casi inadvertido.
Pero, &iquest;qué ocurriría si el enrutador que maneja
estas conexiones procesara una gran parte de paquetes de la
conexión de FTP antes de procesar la conexión de SSH?  Los
paquetes de la conexión de SSH se quedarían en la cola (o
incluso serían rechazados por el enrutador si la cola no fuera lo
suficientemente grande como para mantener todos los paquetes) y
podría parecer que hay retrasos en la sesión de SSH, o que
va muy lenta.  Al modificar la estrategia de la cola en uso, las
diversas aplicaciones, usuarios y ordenadores pueden compartir bastante
bien el ancho de banda de la red.

<p>
Nótese que el uso de colas sólo es de utilidad para
paquetes con dirección de salida, <i>desde dentro</i>.  Una vez
que un paquete ha llegado a una interfaz <i>desde fuera</i>, es
demasiado tarde para ponerlo en una cola debido a que ya habrá
consumido el ancho de banda necesario para llegar a la interfaz que
acaba de recibirlo.  En estos casos la única solución es
activar el sistema de colas en el enrutador adyacente o, si el
anfitrión que ha recibido el paquete actúa como enrutador,
activar el sistema de colas en la interfaz interna desde la que los
paquetes salen del enrutador.

<a name="sched"></a>
<h2>Planificadores</h2>
<p>
El planificador (<i>scheduler</i>) es lo que decide qué colas hay que 
procesar y en qué orden deben ser procesadas.  De forma predeterminada
OpenBSD usa un planificador tipo FIFO (<i>First In First Out</i>, 
&laquo;lo primero en entrar es lo primero en salir&raquo;).  
Una cola FIFO funciona como la cola de un
supermercado, en donde el primer producto de la cola es
también el primero que se procesa.  Según van llegando
nuevos paquetes, estos se van añadiendo al final de la
cola.  Si la cola se llena &ndash;y aquí la analogía con el
supermercado acaba&ndash; los nuevos paquetes que vayan llegando van
siendo bloqueados.  Esto se conoce como <i>tail-drop</i>.

<p>
OpenBSD tiene soporte para dos planificadores adicionales:
<ul>
<li>Colas basadas en clases
<li>Colas basadas en prioridades
</ul>

<a name="cbq"></a>
<h3>Colas basadas en clases</h3>
CBQ (<i>Class Based Queueing</i>) es un algoritmo de formación de
colas que divide el ancho de banda de una conexión de red entre
varias colas o clases.  A cada cola se le asigna un tráfico
basándose en la dirección de origen o de destino, el
número de puerto, protocolo, etcétera.  De forma opcional,
se puede configurar una cola para que tome prestado ancho de banda de la
cola matriz de la cual origina, si ésta está siendo
infrautilizada.  A las colas también se les da una prioridad de
modo que aquellas que contengan tráfico interactivo, como SSH,
puedan tener sus paquetes procesados antes que las colas que contengan
tráfico masivo, como FTP.

<p>
Las colas CBQ se ordenan de un modo jerárquico.  En la parte
superior de la jerarquía se encuentra la cola matriz, que define
la cantidad total de ancho de banda disponible.  Las colas derivadas de
ésta se crean bajo la cola matriz, y a cada una de ellas se les
puede asignar alguna porción del ancho de banda de la cola
matriz.  Por ejemplo, se pueden definir las colas como sigue:
<dl>
<dd>Cola Matriz (2Mbps)
	<dl>
	<dd>Cola A (1Mbps)
	<dd>Cola B (500Kbps)
	<dd>Cola C (500Kbps)
	</dl>
</dl>

<p>
En este caso, el ancho de banda total disponible se ha configurado a 2
megabits por segundo (Mbps), que luego se divide entre las tres colas
derivadas.

<p>
La jerarquía se puede expandir aún más definiendo
colas dentro de otras colas.  Para dividir el ancho de banda en partes
iguales entre varios usuarios y clasificar también el
tráfico de éstas con el fin de evitar que ciertos
protocolos agoten el ancho de banda de otros, se puede definir una
estructura de formación de colas como la siguiente:
<dl>
<dd>Cola Matriz (2Mbps)
	<dl>
	<dd>UsuarioA (1Mbps)
		<dl>
		<dd>ssh (50Kbps)
		<dd>tráf. masivo (950Kbps)
		</dl>
	<dd>UsuarioB (1Mbps)
		<dl>
		<dd>audio (250Kbps)
		<dd>tráf. masivo (750Kbps)
			<dl>
			<dd>http (100Kbps)
			<dd>otro tráfico (650Kbps)
			</dl>
		</dl>
	</dl>
</dl>

<p>
Nótese que, en cada nivel, la suma del ancho de banda asignado a
cada una de las colas no es superior al ancho de banda asignado a la
cola matriz.

<p>
Se puede configurar una cola para que tome prestado ancho de banda de la
cola de la que origina, si le sobra ancho de banda debido a que no
está siendo utilizado por otras colas derivadas.  Tomemos como
ejemplo una configuración de formación de colas como la
siguiente:
<dl>
<dd>Cola Matriz (2Mbps)
	<dl>
	<dd>UsuarioA (1Mbps)
		<dl>
		<dd>ssh (100Kbps)
		<dd>ftp (900Kbps, préstamo)
		</dl>
	<dd>UsuarioB (1Mbps)
	</dl>
</dl>

<p>
Si el tráfico en la cola de <tt>ftp</tt> excede los 900Kbps y el
tráfico en la cola del <tt>UsuarioA</tt> es menor de 1Mbps
(debido a que la cola de <tt>ssh</tt> está usando menos tráfico que
los 100Kbps asignados), la cola de <tt>ftp</tt> tomará prestado
el ancho de banda sobrante del <tt>UsuarioA</tt>.  De este modo, la cola
de <tt>ftp</tt> podrá usar más ancho de banda del que
tiene asignado cuando sufra una sobrecarga.  Cuando la cola de
<tt>ssh</tt> incremente su carga, se devolverá el ancho de banda
que se ha tomado prestado.

<p>
CBQ asigna a cada cola un nivel de prioridad.  Las colas con una
prioridad más alta tendrán preferencia sobre las colas de
prioridad más baja durante una congestión, ya que ambas
colas comparten la misma matriz de origen (o sea, siempre que ambas
colas se encuentren en la misma rama dentro de la jerarquía).
Las colas con una misma prioridad se procesan del modo
<i>round-robin</i>.  Por ejemplo:
<dl>
<dd>Cola Matriz (2Mbps)
	<dl>
	<dd>UsuarioA (1Mbps, prioridad 1)
		<dl>
		<dd>ssh (100Kbps, prioridad 5)
		<dd>ftp (900Kbps, prioridad 3)
		</dl>
	<dd>UsuarioB (1Mbps, prioridad 1)
	</dl>
</dl>

<p>
CBQ procesará las colas del <tt>UsuarioA</tt> y del
<tt>UsuarioB</tt> del modo <i>round-robin</i>;  ninguna de las dos colas
tendrá preferencia sobre la otra.  Al mismo tiempo que
esté procesando la cola del <tt>UsuarioA</tt>, CBQ también
procesará las colas que deriven de ésta.  En este caso, la
cola de <tt>ssh</tt> tiene una prioridad más alta y
obtendrá un trato preferente sobre la cola de <tt>ftp</tt> si hay
congestión en la red.  Nótese que no se comparan las
prioridades de las colas de <tt>ssh</tt> y <tt>ftp</tt> con las colas
del <tt>UsuarioA</tt> y <tt>UsuarioB</tt>, ya que no están en la
misma rama dentro de la jerarquía.

<p>
Para una explicación más detallada de la teoría
detrás de CBQ, véanse estas
<a href="http://www.icir.org/floyd/cbq.html">Referencias sobre CBQ</a>.

<a name="priq"></a>
<h3>Colas basadas en prioridades</h3>
<p>
Las colas basadas en prioridades (PRIQ) asignan colas múltiples 
a una interfaz de red, y dan a cada cola un nivel de prioridad. 
Una cola con un nivel de prioridad más alto se procesa 
<i>siempre</i> antes que una cola con un nivel de prioridad más bajo.
Si a dos o más colas se les asigna la misma prioridad, 
son procesadas en modo <i>round-robin</i>.

<p>
La estructura de formación de colas en PRIQ es estricta, y no se
pueden definir colas dentro de otras colas.  Se define sólo la
cola matriz, en la que se decide la cantidad total de ancho de banda
disponible y, a partir de ahí, las &laquo;sub-colas&raquo; se
definen bajo la cola matriz.  Consideremos el siguiente ejemplo:
<dl>
<dd>Cola Matriz (2Mbps)
	<dl>
	<dd>Cola A (prioridad 1)
	<dd>Cola B (prioridad 2)
	<dd>Cola C (prioridad 3)
	</dl>
</dl>

<p>
La cola matriz está definida con un ancho de banda de 2Mbps
disponible para sí misma, y se han definido tres subcolas.  La
cola con la prioridad más alta (el número de prioridad
más alto) es la que se procesa primero.  Una vez que se han
procesado todos los paquetes en esa cola, o si la cola estuviera
vacía, PRIQ pasa a la cola que tenga el siguiente nivel de
prioridad más alto.  Dentro de una cola cualquiera, los paquetes
se procesan del modo FIFO.

<p>
Es importante tener en cuenta que cuando se usa PRIQ hay que planificar
las colas con mucho cuidado.  Debido a que PRIQ <i>siempre</i> procesa
una cola de prioridad más alta antes que otra de prioridad
más baja, es posible que una cola de alta prioridad sea la causa
de que se retrasen, o incluso se lleguen a bloquear, paquetes en una
cola de prioridad más baja si la cola de alta prioridad
está recibiendo un flujo constante de paquetes.

<a name="red"></a>
<h3>Detección aleatoria anticipada</h3>
<p>
La detección aleatoria anticipada (RED, <i>Random Early 
Detection</i>) es un algoritmo que se utiliza para evitar la 
congestión.  Su trabajo es evitar la congestión en la red, 
asegurándose de que la cola no se llene.  Para ello calcula 
constantemente la longitud media (el tamaño) de la cola y
la compara con dos umbrales o límites, un umbral mínimo y
otro máximo.  Si el tamaño medio de la cola se encuentra
por debajo del umbral mínimo, entonces no se bloqueará
ningún paquete.  Si el tamaño medio se encuentra por
encima del umbral máximo, entonces <i>todos</i> los paquetes
nuevos que lleguen serán bloqueados.  Si el tamaño medio
se encuentra entre los valores de los dos umbrales, entonces se
bloquearán los paquetes de acuerdo con un cálculo de
probabilidad obtenido a raíz del tamaño medio de la cola.
En otras palabras,  según se va aproximando el tamaño
medio de la cola al umbral máximo, se va bloqueando un
número cada vez mayor de paquetes.  Cuando bloquea los paquetes,
RED escoge de qué conexiones bloqueará los paquetes de una
forma aleatoria.  Las conexiones que usen mayores cantidades de ancho de
banda serán las que tengan una probabilidad más alta de
que se bloqueen sus paquetes.

<p>
RED es muy útil por que evita una situación conocida como
sincronización global, explosiones repentinas de tráfico
(desbordamientos).  La sincronización global se refiere a una
pérdida total de caudal debida al bloqueo de paquetes desde
varias conexiones al mismo tiempo.  Por ejemplo, si la congestión
tiene lugar en un enrutador que lleva tráfico para 10 conexiones
de FTP y se están bloqueando los paquetes de todas estas
conexiones (o de la mayoría de ellas), como ocurre con la
formación de colas tipo FIFO, el caudal total caerá de
forma significativa.  Esta situación no es deseable por que
provoca que todas las conexiones de FTP reduzcan su caudal, y
también implica que la red ya no puede ser utilizada en su
potencia máxima.  RED evita esta situación escogiendo de
forma aleatoria las conexiones cuyos paquetes bloqueará, en lugar
de escogerlas todas.  Las conexiones que usen grandes cantidades de
ancho de banda tienen una mayor probabilidad de que sus paquetes sean
bloqueados.  De esta forma se moderará el ritmo de las conexiones
que usen un mayor ancho de banda, se evitará la
congestión, y no habrán pérdidas significativas en
el caudal total.  Además de esto, RED también puede
manejar explosiones repentinas de tráfico, ya que empieza a
bloquear paquetes <i>antes</i> de que se llene la cola.  Cuando llega
una explosión de tráfico no hay espacio suficiente en la
cola para contener los nuevos paquetes.

<p>
RED sólo se debería usar cuando el protocolo de transporte
fuera capaz de responder a los indicadores de congestión de la
red.  En la mayoría de casos esto significa que RED se
debería usar para poner en cola el tráfico TCP, y no el
tráfico UDP o ICMP.

<p>
Para una explicación más detallada de la teoría
detrás de RED, véanse estas
<a href="http://www.icir.org/floyd/red.html">Referencias sobre RED</a>.

<a name="ecn"></a>
<h3>Notificación explícita de congestión</h3>
<p>
ECN (<i>Explicit Congestion Notification</i>) funciona en
conjunción con RED para notificar a dos anfitriones que se
comuniquen a través de la red sobre cualquier congestión
existente en el camino de la comunicación.  Para ello permite que
RED active un indicador en la cabecera del paquete, en lugar de bloquear
el paquete.  Si el anfitrión remitente tiene soporte para ECN,
entonces puede leer este indicador y moderar el ritmo del tráfico
de su red en consecuencia.

<p>
Para más información sobre ECN, véase el
<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">RFC 3168</a>.

<a name="altq"></a>
<h2>Configuración de la formación de colas</h2>
<p>
Desde la versión 3.0 de OpenBSD, la implementación
<a href="http://www.csl.sony.co.jp/person/kjc/kjc/software.html#ALTQ">
ALTQ (<i>Alternate Queueing</i>)</a> de formación de colas ha
sido parte del sistema base.  Desde OpenBSD 3.3, ALTQ se ha integrado
en PF.  La implementación de ALTQ de OpenBSD tiene soporte para
planificadores de Colas Basadas en Clase (CBQ) y Colas Basadas en
Prioridades (PRIQ).  También tiene soporte para 
Detección Aleatoria Anticipada (RED) y Notificación Explícita
de Congestión (ECN).

<p>
Debido a que ALTQ ha sido fusionado con PF, es necesario activar PF para
que funcione la formación de colas.  Las instrucciones para la
activación de PF se pueden encontrar en la sección de
<a href="config.html#activate">Primeros pasos</a>.

<p>
La formación de colas se configura en <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.8"
>pf.conf</a></tt>.
Existen dos tipos de directivas usadas para configurar la
formación de colas:
<ul>
<li><tt>altq on</tt> - activa la formación de colas en un
interfaz, define el <i>scheduler</i> que se usará, y crea la cola
matriz
<li><tt>queue</tt> - define las propiedades de una cola derivada
</ul>

<p>
La sintaxis para la directiva <tt>altq on</tt> es:
<blockquote>
<tt>
altq on <i>interface scheduler</i> bandwidth <i>bw</i> qlimit 
<i>qlim</i> \<br>
&nbsp;&nbsp;&nbsp;tbrsize <i>size</i> queue { <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>interface</i></tt> - la interfaz de red en la que se vaya a
activar la formación de colas.
<li><tt><i>scheduler</i></tt> - el planificador que se usará
para la formación de colas.  Los valores que acepta son
<tt>cbq</tt> y <tt>priq</tt>.  Sólo se puede activar un
<i>scheduler</i> en una interfaz al mismo tiempo.
<li><tt><i>bw</i></tt> - la cantidad total de ancho de banda disponible
para el planificador.  Se puede especificar como un valor absoluto
usando los sufijos <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt> y <tt>Gb</tt>
para representar bits, kilobits, megabits, y gigabits por segundo
respectivamente, o como porcentaje del ancho de banda de
<tt><i>interface</i></tt>.
<li><tt><i>qlim</i></tt> - el número máximo de paquetes
que puede contener la cola.  Este parámetro es opcional, y la
configuración predeterminada es de 50.
<li><tt><i>size</i></tt> - el tamaño del regulador de prueba
en bytes.  Si no se especifica, el tamaño se configurará 
basándose en el ancho de banda de <tt><i>interface</i></tt>.
<li><tt><i>queue_list</i></tt> - una lista de las colas derivadas que se
crearán bajo la cola matriz.
</ul>

<p>
Por ejemplo:
<blockquote>
<tt>
altq on fxp0 cbq bandwidth 2Mb queue { std, ssh, ftp }
</tt>
</blockquote>
Esto activa CBQ en la interfaz <tt>fxp0</tt>.  El ancho de banda total
disponible está configurado en 2Mbps.  Se han definido tres colas
derivadas: <tt>std</tt>, <tt>ssh</tt> y <tt>ftp</tt>.

<p>
La sintaxis para la directiva <tt>queue</tt> es:
<blockquote>
<tt>
queue <i>name</i> [on <i>interface</i>] bandwidth <i>bw</i> [priority 
<i>pri</i>] [qlimit <i>qlim</i>] \<br>
&nbsp;&nbsp;&nbsp;<i>scheduler</i> ( <i>sched_options</i> )
{ <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>name</i></tt> - el nombre de la cola.  Debe coincidir con el
nombre de una de las colas definidas por <tt><i>queue_list</i></tt> en
la directiva <tt>altq on</tt>.  Para <tt>cbq</tt>, también puede
coincidir con el nombre de una cola definida por
<tt><i>queue_list</i></tt> en la directiva <tt>queue</tt> anterior.  Los
nombres de las colas no deben exceder los 15 caracteres.
<li><tt><i>interface</i></tt> - la interfaz de red en la que la cola es
válida.  Este valor es opcional, y cuando no se especifique la
cola será válida en todas las interfaces.
<li><tt><i>bw</i></tt> - la cantidad total de ancho de banda disponible
para la cola.  Se puede especificar como un valor absoluto usando los
sufijos <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt>, y <tt>Gb</tt> para
representar bits, kilobits, megabits, y gigabits por segundo
respectivamente, o como porcentaje del ancho de banda de la cola
principal.
Este parámetro sólo es aplicable cuando se usa el
planificador <tt>cbq</tt>.  Si no se especifica, el valor predeterminado
es el 100% del ancho de banda de la cola principal.
<li><tt><i>pri</i></tt> - la prioridad de la cola.  Para <tt>cbq</tt>
el rango de prioridad va de 0 a 7, y para <tt>priq</tt> el rango va de 0
a 15.  La prioridad 0 es la más baja.  Si no se especifica, se
usará un valor predeterminado de 1.
<li><tt><i>qlim</i></tt> - el número máximo de paquetes
que puede contener la cola.  Si no se especifica, se usará un
valor predeterminado de 50.
<li><tt><i>scheduler</i></tt> - el <i>scheduler</i> que se utilice, ya
sea <tt>cbq</tt> o <tt>priq</tt>.  Debe ser el mismo que para la cola
matriz.
<li><tt><i>sched_options</i></tt> - opciones adicionales que se pueden
pasar al <i>scheduler</i> para controlar su comportamiento:
	<ul>
	<li><tt>default</tt> - define una cola predeterminada a la que
	irán todos los paquetes que no coincidan con ninguna otra
	cola.  Es necesaria la definición de al menos una cola
	predeterminada.
	<li><tt>red</tt> - activa RED en esta cola.
	<li><tt>rio</tt> - activa RED con IN/OUT.  En este modo, RED
	mantendrá tamaños medios de cola múltiples y
	valores de umbrales múltiples, uno por cada nivel de Calidad
	de Servicio de IP (<i>IP Quality of Service</i>).
	<li><tt>ecn</tt> - activa ECN en esta cola.  <tt>ecn</tt> implica
	<tt>red</tt>.
	<li><tt>borrow</tt> - la cola puede tomar ancho de banda prestado de
	su cola matriz.  Esto sólo se puede especificar cuando se usa
	el <i>scheduler</i> <tt>cbq</tt>.
	</ul>
<li><tt><i>queue_list</i></tt> - una lista de colas derivadas que se
crearán bajo esta cola.  Una <tt><i>queue_list</i></tt>
sólo se puede definir cuando se usa el <i>scheduler</i>
<tt>cbq</tt>.
</ul>

Continuando con el ejemplo anterior:
<blockquote>
<tt>
queue std bandwidth 50% cbq(default)<br>
queue ssh bandwidth 25% { ssh_login, ssh_bulk }<br>
&nbsp;&nbsp;queue ssh_login bandwidth 25% priority 4 cbq(ecn)<br>
&nbsp;&nbsp;queue ssh_bulk  bandwidth 75% cbq(ecn)<br>
queue ftp bandwidth 500Kb priority 3 cbq(borrow red)<br>
</tt>
</blockquote>

<p>
Aquí se encuentran activados los parámetros de las colas
derivadas anteriormente definidas.  A la cola <tt>std</tt> se le ha
asignado un ancho de banda del 50% del ancho de banda de la cola matriz
(o 1Mbps), y está configurada como la cola predeterminada.
A la cola <tt>ssh</tt> se le ha asignado el 25% del ancho de banda de 
la cola matriz (500kb) y también contiene dos colas derivadas:  
<tt>ssh_login</tt> y <tt>ssh_bulk</tt>.  A <tt>ssh_login</tt> se 
le ha dado una prioridad más alta que a <tt>ssh_bulk</tt>, 
y ambas tienen ECN activado.  A la cola de <tt>ftp</tt> se le ha 
asignado un ancho de banda de 500Kbps y se le ha dado una prioridad de 3.  
También puede tomar prestado ancho de banda cuando haya disponible 
ancho de banda adicional.  Tiene RED activado.

<p>
<b>NOTA:</b> Cada definición de cola derivada tiene su ancho de 
banda especificado.  Sin especificar el ancho de banda, PF dará 
a la cola el 100% del ancho de banda de la cola principal. 
Esta situación podría causar un error al cargar las 
reglas, pues si ya existe una cola con el 100% del ancho de banda, 
no puede definirse otra cola en ese nivel, ya que no hay ancho 
de banda libre para asignarse.

<a name="assign"></a>
<h3>Asignación de tráfico a una cola</h3>
<p>
Para asignar tráfico a una cola se usa la palabra-clave <tt>queue</tt>
junto con las <a href="filter.html">reglas de filtrado</a> de PF.  Por
ejemplo, en un conjunto de reglas de filtrado que contengan una
línea como:
<blockquote>
<tt>pass out on fxp0 proto tcp to port 22</tt>
</blockquote>

<p>
Los paquetes que coincidan con esa regla pueden ser asignados a 
una cola específica usando la clave <tt>queue</tt>:
<blockquote>
<tt>pass out on fxp0 proto tcp to port 22 queue ssh</tt>
</blockquote>

<p>
Cuando se crea una entrada en la tabla de estado por medio de 
esta regla, PF registra la cola en la entrada de la tabla de 
estado; esta se utilizará por otros paquetes permitidos para 
esta entrada:
<blockquote>
<tt>pass in on fxp0 proto tcp to port 80 queue http</tt>
</blockquote>
Con esta regla, los paquetes que vuelvan a <tt>fxp0</tt> y
que coincidan con la conexión activa acaban en la cola 
<tt>http</tt>. Tenga en cuenta que, aunque se esté usando la 
palabra-clave <tt>queue</tt> en una regla que filtra el tráfico 
entrante, el objetivo es especificar una cola para el tráfico 
saliente correspondiente; la regla anterior no pone en cola los 
paquetes entrantes.

<p>
Cuando se usa la clave <tt>queue</tt> con directivas de bloqueo
<tt>block</tt>, cualquier paquete TCP RST o ICMP resultante que no se
pueda alcanzar será asignado a la cola específica.

<p>
Nótese que la clasificación de la cola puede tener lugar
en una interfaz que no sea la definida por la directiva
<tt>altq on</tt>:
<blockquote>
<tt> 
altq on fxp0 cbq bandwidth 2Mb queue { std, ftp }<br>
queue std bandwidth 500Kb cbq(default)<br>
queue ftp bandwidth 1.5Mb<br>
<br>
pass in on dc0 proto tcp to port 21 queue ftp<br>
</tt>
</blockquote>

<p>
La formación de cola está activada en la interfaz
<tt>fxp0</tt>, pero la clasificación tiene lugar en la interfaz
<tt>dc0</tt>.  Si los paquetes que coinciden con la regla <tt>pass</tt>
(o el estado creado por esta regla) salen de la interfaz 
<tt>fxp0</tt>, pasarán a la cola <tt>ftp</tt>.  Este tipo de 
formación de colas puede ser muy útil para enrutadores.

<p>
Normalmente sólo se da un nombre de cola con la clave
<tt>queue</tt>, pero si se especifica un segundo nombre esa cola se
usará para paquetes con un Tipo de Servicio
(<a href="http://www.rfc-editor.org/rfc/rfc791.txt">ToS, <i>Type of
Service</i></a>) de retraso bajo y para paquetes TCP ACK sin carga
útil de datos.  Un buen ejemplo de esto se encuentra cuando se
usa SSH.  Las sesiones de ingreso de SSH configuran el ToS para retrasos
bajos, mientras que las sesiones de SCP y SFTP no.  PF puede usar esta
información para poner en la cola paquetes que pertenezcan a una
conexión de ingreso en una cola diferente a la de las conexiones
que no sean de ingreso.  Esto es útil para dar prioridad a los
paquetes de conexiones de ingreso sobre los paquetes de transferencia de
archivos.
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue(ssh_bulk, ssh_login)</tt>
</blockquote>

<p>
Esto asigna los paquetes que pertenecen a las conexiones de ingreso de
SSH a la cola <tt>ssh_login</tt>, y los paquetes que pertenecen a las
conexiones de transferencia de archivos de SCP y SFTP a la cola
<tt>ssh_bulk</tt>.  En consecuencia, los paquetes de las conexiones de
ingreso de SSH serán procesados antes que los de las conexiones
de SCP y SFTP, ya que la cola <tt>ssh_login</tt> tiene una prioridad
más alta.

<p>
La asignación de paquetes TCP ACK a una cola de prioridad
más alta es útil en conexiones asimétricas, o sea
aquellas conexiones que tienen anchos de banda de subida y bajada
diferentes, como las líneas ADSL.  Con una línea ADSL, si
se está uilizando al máximo el canal de subida y se inicia
una bajada, la descarga sufrirá porque los paquetes TCP ACK
que necesita enviar entrarán en congestión cuando intenten
pasar a través del canal de subida.  Las pruebas realizadas
demuestran que para obtener los mejores resultados, el ancho de banda en
la cola de subida debe estar configurado con un valor inferior al de la
capacidad de la conexión.  Por ejemplo, si una línea ADSL
tiene un máximo de subida de 640Kbps, al configurar el ancho de
banda de la cola matriz, se obtendrán mejores resultados con un
valor de 600Kb.  La forma para obtener la mejor configuración del
ancho de banda es probando varias configuraciones.

<a name="example1"></a>
<h2>Ejemplo #1: Red doméstica</h2>
<pre>
  
    [ Alice ]    [ Charlie ]
        |             |                              ADSL
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Internet )
              |
           [ Bob ]

</pre>

<p>
En este ejemplo se está usando OpenBSD como pasarela de Internet
para una red pequeña casera con tres estaciones de trabajo.  La
pasarela está realizando filtrado de paquetes y tareas de NAT.
La conexión a Internet es a través de una línea
ADSL con una velocidad de 2Mbps de bajada y 640Kbps de subida.

<p>
La política de formación de colas para esta red es:
<ul>
<li>Reservar 80Kbps de ancho de banda de bajada para Bob, para que
pueda jugar con su juegos en Internet sin retrasos ocasionados por las
descargas de Alice o Charlie.  Permitir que Bob use más de 80Kbps
cuando se encuentren disponibles.
<li>El tráfico de SSH y de mensajería instantánea
tendrá una prioridad más alta que el tráfico
regular.
<li>Los requerimientos y respuestas de DNS tendrán la segunda
prioridad más alta.
<li>Los paquetes salientes de TCP ACK tendrán una prioridad
más alta que el resto del tráfico saliente.
</ul>

<p>
A continuación puede verse un conjunto de reglas que cumple esta
política de red.  Nótese que sólo están
presentes aquellas directivas de <tt>pf.conf</tt> que se aplican
directamente a la política anterior.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# activar la formación de colas en la interfaz externa para controlar
# el tráfico que sale hacia Internet;  usar el <i>scheduler</i> priq para
# controlar sólo las prioridades; configurar el ancho de banda con
# un valor de 610Kbps para obtener el mejor rendimiento de la cola TCP ACK.

altq on fxp0 priq bandwidth 610Kb queue { std_out, ssh_im_out, dns_out, \
	tcp_ack_out }

# definir los parámetros para las colas derivadas.
# std_out      - la cola estándar; el tráfico de cualquier regla de
#		 filtrado que no especifique de forma explícita una
#		 cola será añadido a esta cola.
# ssh_im_out   - tráfico interactivo de SSH y varios mensajes instantáneos.
# dns_out      - requerimientos de DNS.
# tcp_ack_out  - paquetes TCP ACK sin carga útil de datos.

queue std_out     priq(default)
queue ssh_im_out  priority 4 priq(red)
queue dns_out     priority 5
queue tcp_ack_out priority 6

# activar la formación de colas en la interfaz interna para controlar
# el tráfico entrante procedente de Internet;  usar el <i>scheduler</i>
# cbq para controlar el ancho de banda;  el ancho de banda máximo
# es de 2Mbps.

altq on dc0 cbq bandwidth 2Mb queue { std_in, ssh_im_in, dns_in, bob_in }

# definir los parámetros para las colas derivadas.
# std_in      - la cola estándar; el tráfico de cualquier regla de
#		filtrado por debajo que no especifique de forma explícita
#		una cola será añadido a esta cola.
# ssh_im_in   - tráfico interactivo de SSH y varios mensajes instantáneos.
# dns_in      - respuestas de DNS.
# bob_in      - ancho de banda reservado para la estación de Bob;
#		permitirle que tome prestado.

queue std_in    bandwidth 1.6Mb cbq(default)
queue ssh_im_in bandwidth 200Kb priority 4
queue dns_in    bandwidth 120Kb priority 5
queue bob_in    bandwidth 80Kb cbq(borrow)


# ... en la sección de filtrado de pf.conf ...

alice         = "192.168.0.2"
bob           = "192.168.0.3"
charlie       = "192.168.0.4"
local_net     = "192.168.0.0/24"
ssh_ports     = "{ 22 2022 }"
im_ports      = "{ 1863 5190 5222 }"

# reglas de filtrado para fxp0 entrante
block in on fxp0 all

# reglas de filtrado para fxp0 saliente
block out on fxp0 all
pass  out on fxp0 inet proto tcp from (fxp0) queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0)
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to port domain \
	queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to port $ssh_ports \
	queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to port $im_ports \
	queue(ssh_im_out, tcp_ack_out)

# reglas de filtrado para dc0 entrante
block in on dc0 all
pass  in on dc0 from $local_net

# reglas de filtrado para dc0 saliente
block out on dc0 all
pass  out on dc0 to $local_net
pass  out on dc0 proto { tcp udp } from port domain to $local_net \
	queue dns_in
pass  out on dc0 proto tcp from port $ssh_ports to $local_net \
	queue(std_in, ssh_im_in)
pass  out on dc0 proto tcp from port $im_ports to $local_net \
	queue ssh_im_in
pass  out on dc0 to $bob queue bob_in
</pre>
</td></tr>
</table>

<a name="example2"></a>
<h2>Ejemplo #2: Red corporativa</h2>
<pre>

  ( Dept IT )  [ PC del jefe ]
       |             |                                T1
     --+----+--------+------- dc0 [ OpenBSD ] fxp0 -------- ( Internet )
            |                         fxp1
         [ COMP1 ]    [ WWW ]         /
                         |           / 
                       --+----------' 

</pre>

<p>
En este ejemplo, el anfitrión de OpenBSD actúa como
cortafuegos para la red de una compañía.  La
compañía tiene un servidor de WWW en la &laquo;zona
desmilitarizada&raquo; (DMZ) de su red, en el que los clientes cargan
sus sitios web mediante FTP.  El departamento de
Informática, IT, tiene su propia subred conectada a la red
principal, y el jefe tiene un PC en su escritorio que usa para correo
electrónico y para navear por Internet.  La conexión a
Internet es a través de una línea T1 a 1.5Mbps en ambas
direcciones.  El resto de los segmentos de la red usan Fast Ethernet
(100Mbps).

<p>
El administrador de la red ha decidido aplicar la siguiente
política:
<ul>
<li>Limitar todo el tráfico entre el servidor de WWW e Internet a
500Kbps en cada dirección.
	<ul>
	<li>Reservar 250Kbps para el tráfico HTTP.
	<li>Reservar 250Kbps para el resto de tráfico (por ejemplo tráfico no-HTTP)
	<li>Permitir a cualquier cola tomar prestados los 500Kbps completos.
	<li>Dar una mayor prioridad al tráfico de HTTP entre el servidor
	de WWW e Internet que al resto del tráfico entre el servidor de
	WWW e Internet (como a las subidas por FTP).
	</ul>
<li>El tráfico entre el servidor de WWW y la red interna puede usar
los 100Mbps totales que ofrece la red.
<li>Reservar 500Kbps para el Departamento de IT para que puedan descargar 
las últimas actualizaciones de software a tiempo.  Pueden usar
más de 500Kbps cuando haya ancho de banda adicional disponible.
<li>Dar una prioridad más alta al tráfico entre el PC del
jefe e Internet que al resto de tráfico hacia/desde Internet.
</ul>

<p>
A continuación puede verse el conjunto de reglas que cumple esta
política de red.  Nótese que sólo están
presentes aquellas directivas de <tt>pf.conf</tt> que se aplican
directamente a la política anterior;  no se muestran las reglas
de <a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, las
<a href="options.html">opciones</a>, etc.

<p>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# activar la formación de colas en la interfaz externa para poner
# en cola a los paquetes salientes hacia Internet; usar el
# <i>scheduler</i> cbq para que se pueda controlar la utilización
# de ancho de banda de cada cola; el ancho de banda saliente
# máximo es de 1.5Mbps.

altq on fxp0 cbq bandwidth 1.5Mb queue { std_ext, www_ext, boss_ext }

# definir los parámetros para las colas derivadas.
# std_ext         - la cola estándar;  también la cola predeterminada
#		    para el tráfico saliente en fxp0.
# www_ext         - cola contenedora para colas del servidor de WWW;
#		    limitada a 500Kbps.
#   www_ext_http  - tráfico http desde el servidor de WWW; mayor prioridad
#   www_ext_misc  - todo el tráfico no http desde el servidor
#		    de WWW.
# boss_ext        - tráfico entrante desde el PC del jefe.

queue std_ext        bandwidth 500Kb cbq(default borrow)
queue www_ext        bandwidth 500Kb { www_ext_http, www_ext_misc }
  queue www_ext_http bandwidth 50% priority 3 cbq(red borrow)
  queue www_ext_misc bandwidth 50% priority 1 cbq(borrow)
queue boss_ext       bandwidth 500Kb priority 3 cbq(borrow)

# activar la formación de colas en la interfaz interna para
# controlar el tráfico entrante desde Internet o desde la DMZ;
# usar el planificador cbq para controlar el ancho de banda de cada
# cola;  el ancho de banda en esta interfaz está configurado al
# máximo; el tráfico entrante desde la DMZ podrá usar todo este
# ancho de banda, mientras que el tráfico entrante desde Internet
# tendrá un límite de 1.0Mbps (por que se han ubicado 0.5Mbps
# (500Kbps) para fxp1).

altq on dc0 cbq bandwidth 100% queue { net_int, www_int }

# definir los parámetros para las colas derivadas.
# net_int    - cola contenedora para el tráfico desde Internet;
	       el ancho de banda es de 1.0Mbps.
#   std_int  - la cola estándar;  también la cola predeterminada
#	       para el tráfico saliente en dc0.
#   it_int   - tráfico hacia la red del Dept IT; les reserva 500kbps.
#   boss_int - tráfico hacia el PC del jefe; asigna una mayor prioridad.
# www_int    - tráfico desde el servidor de WWW en la DMZ; máxima velocidad.

queue net_int    bandwidth 1.0Mb { std_int, it_int, boss_int }
  queue std_int  bandwidth 250Kb cbq(default borrow)
  queue it_int   bandwidth 500Kb cbq(borrow)
  queue boss_int bandwidth 250Kb priority 3 cbq(borrow)
queue www_int    bandwidth 99Mb cbq(red borrow)

# activar la formación de colas en la interfaz de DMZ para
# controlar el tráfico destinado al servidor de WWW;
# se usará cbq en esta interfaz ya que es necesario un control
# detallado del ancho de banda; el ancho de banda en esta interfaz
# está configurado al máximo; el tráfico desde la red interna
# podrá usar todo este ancho de banda, mientras que el
# tráfico desde Internet estará limitado a 500Kbps.

altq on fxp1 cbq bandwidth 100% queue { internal_dmz, net_dmz }

# definir los parámetros para las colas derivadas.
# internal_dmz   - tráfico desde la red interna.
# net_dmz        - cola contenedora para tráfico desde Internet.
#   net_dmz_http - tráfico http; mayor prioridad
#   net_dmz_misc - todo el tráfico no-http; es la cola predeterminada.

queue internal_dmz   bandwidth 99Mb cbq(borrow)
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http bandwidth 50% priority 3 cbq(red borrow)
  queue net_dmz_misc bandwidth 50% priority 1 cbq(default borrow)


# ... en la sección de filtrado de pf.conf ...

main_net  = "192.168.0.0/24"
it_net    = "192.168.1.0/24"
int_nets  = "{ 192.168.0.0/24, 192.168.1.0/24 }"
dmz_net   = "10.0.0.0/24"

boss      = "192.168.0.200"
wwwserv   = "10.0.0.100"

# denegación predeterminada
block on { fxp0, fxp1, dc0 } all

# reglas de filtrado para fxp0 entrante
pass in on fxp0 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 queue www_ext_http

# reglas de filtrado para fxp0 saliente
pass out on fxp0 from $int_nets
pass out on fxp0 from $boss queue boss_ext

# reglas de filtrado para dc0 entrante
pass in on dc0 from $int_nets
pass in on dc0 from $it_net queue it_int
pass in on dc0 from $boss queue boss_int
pass in on dc0 proto tcp from $int_nets to $wwwserv port { 21, 80, \
	&gt; 49151 } queue www_int

# reglas de filtrado para dc0 saliente
pass out on dc0 from dc0 to $int_nets

# reglas de filtrado para fxp1 entrante
pass in on fxp1 proto { tcp, udp } from $wwwserv to port 53

# reglas de filtrado para fxp1 saliente
pass out on fxp1 proto tcp to $wwwserv port { 21, \
	&gt; 49151 } queue net_dmz_misc
pass out on fxp1 proto tcp to $wwwserv port 80 queue net_dmz_http
pass out on fxp1 proto tcp from $int_nets to $wwwserv port { 80, \
	21, &gt; 49151 } queue internal_dmz
</pre>
</td></tr>
</table>

<p>
[<a href="anchors.html">Anterior: Anclajes</a>]
[<a href="index.html">Contenido</a>]
[<a href="pools.html">Siguiente: Reserva de direcciones y balanceo
de carga</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: queueing.html,v 1.40 ]<br>
$Translation: queueing.html,v 1.12 2011/03/05 03:23:55 mvidal Exp $<br>
-->
$OpenBSD: queueing.html,v 1.11 2011/03/13 07:16:15 ajacoutot Exp $
</small>

</body>
</html> 
