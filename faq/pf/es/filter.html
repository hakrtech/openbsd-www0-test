<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtrado de paquetes</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../es/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Anterior: Tablas</a>]
[<a href="index.html">Contenido</a>]
[<a href="nat.html">Siguiente: Traducción de Direcciones de
Red</a>]

<h1><font color="#e00000">PF: Filtrado de paquetes</font></h1>

<hr>

<h3>Índice de contenidos</h3>
<ul>
<li><a href="#intro">Introducción</a>
<li><a href="#syntax">Sintaxis de las reglas</a>
<li><a href="#defdeny">Denegación predeterminada</a>
<li><a href="#pass">Paso de tráfico</a>
<li><a href="#quick">La palabra-clave <tt>quick</tt></a>
<li><a href="#state">Mantenimiento del estado</a>
<li><a href="#udpstate">Mantenimiento del estado para UDP</a>
<li><a href="#stateopts">Opciones de seguimiento de estado</a>
<li><a href="#tcpflags">Indicadores de TCP</a>
<li><a href="#synproxy">Proxy de paquetes TCP SYN</a>
<li><a href="#antispoof">Bloqueo de paquetes falsificados</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Detección pasiva del Sistema Operativo</a>
<li><a href="#ipopts">Opciones de IP</a>
<li><a href="#example">Ejemplo de grupo de reglas de filtrado</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Introducción</h2>
<p>
La acción de filtrar paquetes es bloquear o permitir el paso a
los paquetes de datos de forma selectiva, según van llegando a
una interfaz de red.  Los criterios que usa
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.8"
>pf(4)</a>
para inspeccionar los paquetes los toma de la información
existente en la capa 'Layer 3'
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> and 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>)
y en la capa 'Layer 4'
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>) de las cabeceras de los paquetes.  Los criterios que más se
utilizan son los de la dirección de origen y de destino, el
puerto de origen y de destino, y el protocolo.

<p>
Las reglas de filtrado especifican los criterios con los que debe
concordar un paquete y la acción a seguir, bien sea bloquearlo o
permitir que pase, que se toma cuando se encuentra una concordancia.
Las reglas de filtrado se evalúan por orden de secuencia, de la
primera a la última.  A menos que el paquete concuerde con una
regla que contenga la clave <tt>quick</tt>, se evaluará el
paquete comparándolo con <i>todas</i> las reglas de filtrado
antes de decidir una acción final.  La última regla que
concuerde será la &laquo;ganadora&raquo; y la que dictamine
qué acción se tomará con el paquete.  Al principio del
grupo de reglas de filtrado hay un <tt>pass all</tt> implícito
que indica que si algún paquete no concuerda con ninguna de las
reglas de filtrado, la acción a seguir será <tt>pass</tt>,
o sea permitirle el paso.

<a name="syntax"></a>
<h2>Sintaxis de las reglas</h2>
<p>
La sintaxis general, <i>muy simplificada</i>, para las reglas de
filtrado es:
<blockquote>
<tt>
<i>action</i> [<i>direction</i>] [log] [quick] [on <i>interface</i>] 
[<i>af</i>] [proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to 
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>La acción a seguir para los paquetes que concuerden, ya sea
<tt>pass</tt> o <tt>block</tt>.  La acción <tt>pass</tt>
permitirá el paso al paquete de vuelta hasta el núcleo del
sistema, para que éste lo procese, mientras que la acción
<tt>block</tt> actuará según se indique en la
configuración de la opción de la política de
bloqueo, <a href="options.html#block-policy"><tt>block-policy</tt></a>.
La acción por omisión se puede anular especificando <tt>block
drop</tt> (bloquear y eliminar el paquete) o <tt>block return</tt>
(bloquear y devolver el paquete).

<dt><tt><i>direction</i></tt>
<dd>La dirección en la que se mueve el paquete en una interfaz,
que será <tt>in</tt> (entrante) o <tt>out</tt> (saliente).

<dt><tt>log</tt>
<dd>Indica que se debe registrar el paquete por medio de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.8"
>pflogd(8)</a>.
Si la regla crea un estado, entonces sólo
se registrará el paquete que establezca el estado.  Para
registrar todos los paquetes hay que usar la opción
<tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Si un paquete concuerda con una regla que especifique la
opción <tt>quick</tt>, entonces esa regla se considera como la
regla final de concordancia para el paquete, y se tomará la
acción que esté especificada en <tt><i>action</i></tt>
sin más dilación.

<dt><tt><i>interface</i></tt>
<dd>El nombre o el grupo de la interfaz de red a través del cual se mueve
el paquete.
Los interfaces pueden añadirse a grupos arbitrarios por medio de
la orden <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>
Varios grupos también son creados automáticamente por el kernel:
<ul>
<li>El grupo <tt>egress</tt>, que contiene la(s) interfaces(s) 
relativa(s) a la ruta por omisión.
<li>El grupo de la familia de interfaces clonadas: 
Por ejemplo: <tt>ppp</tt> o <tt>carp</tt>.
</ul>
Esto causaría la concordancia de la regla para todo paquete que
atraviesa cualquier interfaz
<tt>ppp</tt> o <tt>carp</tt>, respectivamente.

<dt><tt><i>af</i></tt>
<dd>La familia de direcciones del paquete, que será <tt>inet</tt>
para IPv4 ó <tt>inet6</tt> para IPv6.  Generalmente, PF es capaz
de determinar este parámetro basándose en la
dirección, o direcciones, de origen y/o de destino.

<dt><tt><i>protocol</i></tt>
<dd>El protocolo de la capa 'Layer 4' del paquete:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Un nombre de protocolo válido del fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
><tt>/etc/protocols</tt></a>
<li>Un número de protocolo entre 0 y 255
<li>Un grupo de protocolos que usen una
<a href="macros.html#lists">lista</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>La dirección de origen y/o de destino en la cabecera IP.  Las
direcciones se pueden especificar como:
<ul>
<li>Una sola dirección IPv4 o IPv6.
<li>Un bloque de red
<a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<li>Un &laquo;Nombre de Dominio Totalmente Cualificado&raquo; (FQDN) que
se resolverá por el &laquo;Servicio de Nombres de Dominio&raquo;
cuando se carguen las reglas.  Todas las direcciones IP resultantes se
sustituirán dentro de la regla.
<li>El nombre de una interfaz de red o grupo.  Cualquier dirección IP
asignada a la interfaz se sustituirá dentro de la regla.
<li>El nombre de una interfaz de red seguido de la máscara de red
como sigue: <tt>/<i>netmask</i></tt> (o sea, <tt>/24</tt>).  Cada
dirección IP en la interfaz se combina con la máscara de
red para formar un bloque de red CIDR, que se sustituye dentro de la
regla.
<li>El nombre de una interfaz de red o grupo entre paréntesis <tt>( )</tt>.  
De este modo se instruye a PF para que actualice la reglas si la
dirección, o direcciones, IP en dicha interfaz cambia.  Es de
gran utilidad cuando la interfaz obtiene su dirección IP por
medio de DHCP o de una conexión tipo <i>dial-up</i> (por
conexión telefónica), ya que no hay que volver a cargar
las reglas cada vez que cambie la dirección.
<li>El nombre de la interfaz de red seguido por cualquiera de los siguientes
modificadores:
  <ul>
  <li><tt>:network</tt> - expande al bloque de red CIDR (por ejemplo:
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - expande a la dirección de difusión
  (<i>broadcast</i>) de la red. (por ejemplo: 192.168.0.255)
  <li><tt>:peer</tt> - expande a la dirección IP del otro extremo en un
  enlace punto a punto.
  </ul>
  <dl>
  <dd>Además, el modificador <tt>:0</tt> puede ser añadido tanto a un nombre
  de interfaz o a cualquiera de los modificadores mencionados arriba para
  indicar que PF no debe incluir la dirección IP de alias en la expansión.
  Estos modificadores también puede ser usados cuando la interfaz está
  entre paréntesis.
  Ejemplo: <tt>fxp0:network:0</tt>
  </dl>
<li>Una <a href="tables.html">tabla</a>.
<li>La palabra-clave <tt>urpf-failed</tt> puede usarse en las direcciones 
origen para indicar que debe continuar a través de una
<a href="#urpf">comprobación uRPF</a>.
<li>Cualquiera de las anteriores en negación, usando el
modificador <tt>!</tt> ("not").
<li>Un grupo de direcciones que usen una
<a href="macros.html#lists">lista</a>.
<li>La clave <tt>any</tt> para indicar todas las direcciones.
<li>La clave <tt>all</tt>, que es una abreviación de
<tt>from any to any</tt>.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>El puerto de origen y/o de destino en la capa 'Layer 4' de la
cabecera IP.  Los puertos se pueden especificar como:
<ul>
<li>Un número entre el 1 y el 65535
<li>Un nombre de servicio válido del fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
><tt>/etc/services</tt></a>
<li>Un grupo de puertos que usen una
<a href="macros.html#lists">lista</a>
<li>Un intervalo:
	<ul>
	<li><tt>!=</tt> (distinto de)
	<li><tt>&lt;</tt> (menor que)
	<li><tt>&gt;</tt> (mayor que)
	<li><tt>&lt;=</tt> (menor o igual que)
	<li><tt>&gt;=</tt> (mayor o igual que)
	<li><tt>&gt;&lt;</tt> (intervalo)
	<li><tt>&lt;&gt;</tt> (intervalo inverso)
	<dl>
	<dd>Los dos últimos son operadores binarios (toman dos
	argumentos) y no incluyen los argumentos en el intervalo.
	</dl>
	<li><tt>:</tt> (intervalo inclusivo)
	<dl>
	<dd>El operador de intervalo inclusivo también es un operador binario
	e incluye el argumento en el intervalo.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Especifica los indicadores que deben existir en la cabecera TCP
cuando se usa <tt>proto tcp</tt>.  Los indicadores se especifican como
<tt>flags <i>check</i>/<i>mask</i></tt>.  Por ejemplo, <tt>flags
S/SA</tt> instruye a PF para que sólo mire los indicadores S y A
(SYN y ACK), y que acepte la concordancia si el indicador SYN
está activo (y esto se aplica a todas las reglas TCP 
predeterminadas).
<tt>flags any</tt> instruye a PF para que no verifique los 
indicadores (<i>flags</i>).

<dt><tt><i>state</i></tt>
<dd>Especifica si se guarda la información sobre el estado en
paquetes que concuerden con esta regla.
<ul>
<li><tt>no state</tt> - funciona con TCP, UDP e ICMP.
PF no trazará esta conexión con estado. Para conexiones 
TCP, <tt>flags any</tt> suele ser necesario.
<li><tt>keep state</tt> - funciona con TCP, UDP e ICMP.
Esta es la opción predeterminada en todas las reglas de filtrado.
<li><tt>modulate state</tt> - sólo funciona con TCP.  PF
generará &laquo;Números de Secuencia Inicial&raquo; (ISNs,
<i>Initial Sequence Numbers</i>) seguros para los paquetes que
concuerden con esta regla.
<li><tt>synproxy state</tt> - hace de proxy para las conexiones TCP
entrantes con el fin de ayudar a proteger a los servidores de
desbordamientos TCP SYN falsificados.  Esta opción incluye las
funcionalidades <tt>keep state</tt> y <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Denegación predeterminada</h2>
<p>
La práctica recomendada para configurar un cortafuegos es la de
tomar una aproximación de &laquo;denegación
predeterminada&raquo;; o sea, denegar el paso a <i>todo</i> y a partir
de ahí ir permitiendo el paso a través del cortafuegos de
forma selectiva a cierto tráfico.  Esta aproximación es la
recomendada ya que los posibles fallos se cometerían a favor de
la seguridad, y también porque hace más fácil la
creación de grupos de reglas.

<p>
Para crear una política de filtrado de denegación
predeterminada, las primeras dos reglas deben ser:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Con esto se bloquea todo el tráfico en todas las interfaces en
cualquier dirección, y desde cualquier origen, hasta cualquier
destino.

<a name="pass"></a>
<h2>Paso de tráfico</h2>
<p>
Ahora hay que permitir de forma explícita y selectiva el paso del
tráfico a través del cortafuegos, o de lo contrario
será bloqueado por la política de denegación
predeterminada.  Aquí es donde entran en juego los criterios del
paquete, como son el puerto de origen/destino, la dirección de
origen/destino, y el protocolo.  Siempre que se permita el paso de
cierto tráfico a través del cortafuegos hay que escribir
las reglas de un modo tan restrictivo como sea posible.  Esto es para
asegurarse de que sólo pasará el tráfico que se
permita, y ningún otro.

<p>
Algunos ejemplos:
<blockquote>
<tt>
# Permitir el paso al tráfico entrante en la interfaz dc0 de la red local,<br>
# 192.168.0.0/24, hacia la dirección IP 192.168.0.1 de la máquina de OpenBSD.<br>
# También permitir el paso al tráfico saliente que es enviado de vuelta en dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Permitir el paso al tráfico entrante TCP en la interfaz fxp0 del servidor<br>
# de <i>web</i> que se encuentra en la máquina de OpenBSD.  El nombre de la<br>
# interfaz, fxp0, se usa como la dirección de destino para que los paquetes<br>
# sólo concuerden con esta regla si tienen como destino la máquina de OpenBSD.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>La palabra-clave <tt>quick</tt></h2>
<p>
Como se ha indicado anteriormente, cada paquete se evalúa con el
grupo de reglas de filtrado, desde la primera hasta la última.
El resultado predeterminado es el de marcar el paquete para que se le
permita el paso;  esto puede cambiar con cualquiera de las reglas por
las que pasa, y podría cambiar varias veces antes de llegar al
final de las reglas de filtrado.  <b>La última regla con la que
concuerde marcará el resultado.</b>  Existe una excepción
para esto:  la opción <tt>quick</tt> en una regla de filtrado
tiene el efecto de cancelar el procesamiento de cualquier regla
consiguiente, y provoca que se ejecute la acción especificada sin
más dilación.  Veamos un par de ejemplos:

<p>
Mal:
<blockquote>
<tt>
block in on fxp0 proto tcp to port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
En este caso, la línea <tt>block</tt> puede ser evaluada, pero
nunca tendrá ningún efecto, ya que va seguida por una
línea que permite el paso de todo.

<p>
Mejor:
<blockquote>
<tt>
block in quick on fxp0 proto tcp to port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Estas reglas se evalúan de una forma algo diferente.  Si un
paquete concuerda con la línea <tt>block</tt>, debido a la
naturaleza de la opción <tt>quick</tt>, se bloqueará el
paso a dicho paquete y se ignorará el resto del grupo de reglas.

<a name="state"></a>
<h2>Mantenimiento del estado</h2>
<p>
Una de las funcionalidades importantes de PF es la del
&laquo;mantenimiento del estado&raquo; (<i>keeping state</i>) o
&laquo;inspección completa del estado&raquo; (<i>stateful
inspection</i>).  La inspección del estado se refiere a la
capacidad de PF de llevar un seguimiento del estado, o del progreso, de
una conexión de red.  Almacenando información sobre cada
conexión en una tabla de estado, PF puede determinar
rápidamente si un paquete que está pasando a través
del cortafuegos pertenece a una conexión ya establecida.  Si es
así, se le permite pasar a través del cortafuegos sin
tener que pasar a través de la evaluación del grupo de
reglas.

<p>
El mantenimiento del estado tiene muchas ventajas, entre otras que los
grupos de reglas son más simples y se obtiene un rendimiento
más alto del filtrado de paquetes.  PF puede puede hacer que los
paquetes que vayan en <i>cualquier</i> dirección concuerden con
entradas en la tabla de estado, lo que quiere decir que no es necesario
escribir reglas de filtrado que permitan el paso del tráfico de
vuelta.  Y, como los paquetes que concuerdan con conexiones
<i>stateful</i> no pasan a través de la evaluación del
grupo de reglas, el tiempo que tarda PF en procesarlos puede reducirse
considerablemente.

<p>
Cuando una regla crea el estado, el primer paquete que 
concuerda con ella crea un <b>estado</b> entre el remitente
y el destinatario.  A partir de ahí, los paquetes que vayan desde
el remitente hacia el destinatario no serán los únicos que
concuerden con la entrada de estado y que circunvalen la
evaluación de las reglas, sino que también lo harán
los paquetes de respuesta desde el destinatario hacia el remitente. 

<p>
Todas las reglas <i>pass</i> crean automáticamente una entrada en la 
tabla de estado cuando un paquete concuerda con la regla.
Esto puede deshabilitarse de manera explícita mediante la opción
<tt>no state</tt>

<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Esto permite el paso de cualquier tráfico TCP saliente en
la interfaz <tt>fxp0</tt>, y también permite que el
tráfico de respuesta pase de vuelta a través del
cortafuegos.  El mantenimiento del estado 
mejora de forma significativa el rendimiento del
cortafuegos, ya que las búsquedas de estados son mucho más
rápidas que la evaluación de un paquete a través de
todas las reglas de filtrado.

<p>
La opción de &laquo;modulación del estado&raquo;
(<tt>modulate state</tt>), funciona como <tt>keep state</tt>, con la
diferencia que solo es válida para paquetes TCP.  Con
<tt>modulate state</tt>, el ISN de las conexiones salientes es
aleatorio.  Esta opción es útil para proteger conexiones
que hayan sido iniciadas por ciertos sistemas operativos que realizan un
pobre trabajo al escoger ISNs.
Para simplificar las reglas, la opción <tt>modulate state</tt> 
puede usarse en reglas que especifican protocolos 
diferentes de TCP; en estos casos es tratada como <tt>keep state</tt>.

<p>
Mantenimiento del estado en paquetes TCP, UDP e ICMP salientes y ISN TCP
modulados:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Otra ventaja del mantenimiento del estado es que el tráfico ICMP
correspondiente también pasará por el cortafuegos.  Por
ejemplo, si una conexión TCP pasa a través del cortafuegos,
como se mantiene el estado, y llega una señal de congestión 
(<i>source quench</i>) ICMP, se buscará su concordancia con la entrada 
apropiada de la tabla de estado y pasará a través del cortafuegos.

<p>
El ámbito de una entrada en la tabla de estados es controlado 
globalmente por la opción en tiempo de ejecución 
<a href="options.html#state-policy"><tt>state-policy</tt></a>
y al nivel de cada regla por las palabras-clave de opciones de estado 
<tt>if-bound</tt> y <tt>floating</tt>.  Estas palabras-clave usadas 
en las reglas tienen el mismo efecto que cuando se usan con la opción 
<tt>state-policy</tt>.  Ejemplo:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Esta regla dictaminaría que para que los paquetes concuerden con la 
entrada de estado deben transitar por la interfaz <tt>fxp0</tt>.

<a name="udpstate"></a>
<h2>Mantenimiento del estado para UDP</h2>
<p>
Algunos dicen que &laquo;no se puede crear estado con UDP, ya que UDP es
un protocolo sin estado&raquo;.  Aunque es cierto que una sesión
de comunicación de UDP no tiene ningún concepto de estado
(un comienzo y un final de las comunicaciones explícito), esto no
tiene ningún impacto en la capacidad de PF para crear estado para
una sesión de UDP.  En el caso de protocolos sin paquetes de
&laquo;inicio&raquo; ni &laquo;final&raquo;, PF se limita a mantener un
seguimiento del tiempo transcurrido desde que ha pasado un paquete que
concuerde.  Los valores del tiempo agotado (<i>timeout</i>) se pueden
configurar en la sección de <a href="options.html">opciones</a>
del fichero <tt>pf.conf</tt>.

<a name="stateopts"></a>
<h2>Opciones de seguimiento de estado</h2>
Las reglas de filtrado que crean una entrada en la tabla de estados 
pueden especificar varias opciones para controlar el comportamiento 
de la entrada de estado resultante. 
Están disponibles las siguientes opciones:

<dl>
<dt><tt>max <i>número</i></tt>
<dd>Limita el número máximo de entradas de estado que la regla
puede crear para <i>número</i>.
Si se alcanza el máximo, los paquetes que normalmente crearían 
un estado son rechazados hasta que el número de estados existentes 
decrece por debajo del límite.

<dt><tt>no state</tt>
<dd>Impide que la regla cree automáticamente una entrada en la tabla
de estados.

<dt><tt>source-track</tt>
<dd>Esta opción habilita el seguimiento del número de estados creados
por dirección IP de origen.
Esta opción tiene dos formatos:
	<ul>
	<li><tt>source-track rule</tt> - El número máximo de estados 
	creados por esta regla está limitado por las opciones
	<tt>max-src-nodes</tt> y <tt>max-src-states</tt> de la regla.
	Solamente las entradas de estado creadas por esta regla en 
	particular cuenta para los límites de la regla.
	<li><tt>source-track global</tt> - El número de estados creados
	por todas las reglas que usan esta opción se limita. Cada regla
	puede especificar diferentes opciones <tt>max-src-nodes</tt> y 
	<tt>max-src-states</tt>, sin embargo las entradas de estado creadas
	por cualquier regla participante cuenta para los límites individuales 
	de la regla.
	</ul>
El número total de direcciones IP de origen rastreados globalmente puede
controlarse por medio de la 
<a href="options.html#limit">opción en tiempo de ejecución 
<a href="options.html#limit"><tt>src-nodes</tt></a>.

<dt><tt>max-src-nodes <i>número</i></tt>
<dd>Cuando se usa la opción <tt>source-track</tt>,
<tt>max-src-nodes</tt> limitará el número de direcciones IP de origen
que pueden crear estado de forma simultánea.
Esta opción solo puede usarse con <tt>source-track rule</tt>.

<dt><tt>max-src-states <i>número</i></tt>
<dd>Cuando se usa la opción <tt>source-track</tt>,
<tt>max-src-states</tt> limitará el número de entradas de estado
simultáneas que pueden crearse por dirección IP de origen.
El alcance de este límite (o sea, estados creados solamente por esta
regla o estados creados por todas las reglas que usan 
<tt>source-track</tt>) es dependiente de la opción <tt>source-track</tt> 
especificada.
</dl>

<p>
Las opciones se especifican entre paréntesis e inmediatamente 
después de una de las palabras-clave de estado (<tt>keep state</tt>,
<tt>modulate state</tt>, or <tt>synproxy state</tt>). Si hay múltiples 
opciones, deben ir separadas por comas. 
En OpenBSD 4.1 y versiones más recientes, la opción <tt>keep state</tt> 
se utiliza de forma predeterminada implícitamente para 
todas las reglas de filtrado. A pesar de ello, cuando se especifican 
opciones de mantener estado, debe especificarse todavía una de las 
palabras-clave por delante de las opciones.

<p>
Una regla de ejemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
La regla anterior define el siguiente comportamiento:

<ul>
<li>Limita a 200 el número máximo de estados que esta regla puede crear 
<li>Habilita el seguimiento del origen; limita la creación de estados basados
en estados creados solo por esta regla
<li>Limita a 100 el número máximo de nodos que pueden crear estados 
simultáneamente 
<li>Limita a 3 el número máximo de estados simultáneos por IP de origen. 
</ul>

<p>
Puede ponerse un conjunto separado de restricciones en conexiones 
TCP con estado que han completado la negociación en tres pasos 
(<i>3-way handshake</i>).

<dl>
<dt><tt>max-src-conn <i>número</i></tt>
<dd>Limita el número máximo de conexiones TCP simultáneas que
hayan completado la negociación en tres pasos y que una única máquina 
puede realizar.
<dt><tt>max-src-conn-rate <i>número</i> / <i>intervalo</i></tt>
<dd>Limita la tasa de nuevas conexiones a una cierta cantidad
por intervalo de tiempo 
</dl>

<p>
Ambas opciones invocan automáticamente la opción 
<tt>source-track rule</tt> y son incompatibles con 
<tt>source-track global</tt>

<p>
Dado que estos límites solo son colocados en conexiones 
TCP que han completado la negociación en tres pasos, se pueden adoptar
acciones más agresivas en direcciones IP ofensivas. 

<dl>
<dt><tt>overload &lt;<i>tabla</i>&gt;</tt>
<dd>Coloca una dirección IP de una máquina ofensiva en la tabla
nombrada.
<dt><tt>flush [global]</tt>
<dd>
Cesa cualquier otro estado que concuerde con esta regla y que
fuese creado por esta IP de origen.
Cuando <tt>global</tt> es especificado, cesa todos los estados
coincidentes con esta IP de origen, sin discernir qué regla
creó el estado.
</dl>

<p>
Un ejemplo:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Esto hace lo siguiente:

<ul>
<li>Limita a 100 el número máximo de conexiones por origen 
<li>Limita la tasa del número de conexiones a 15 en un lapso de 5 segundos
<li>Pone la dirección IP de cualquier máquina que quiebre estos límites en 
la tabla <tt>&lt;abusive_hosts&gt;</tt> 
<li>Para cualquier dirección IP ofensiva, suprime los estados creados 
por esta regla.
</ul>

<a name="tcpflags"></a>
<h2>Indicadores de TCP</h2>
<p>
La concordancia de paquetes TCP basada en indicadores es algo que se
suele usar para filtrar paquetes TCP que estén intentando abrir
una nueva conexión.  Aquí se puede ver una lista de
indicadores TCP y sus significados:
<ul>
<li><b>F</b> : FIN  - <i>Finish</i>; final de la sesión
<li><b>S</b> : SYN  - <i>Synchronize</i>; indica una petición para
iniciar la sesión
<li><b>R</b> : RST  - <i>Reset</i>; abandona una conexión
<li><b>P</b> : PUSH - <i>Push</i>; el paquete es enviado inmediatamente
<li><b>A</b> : ACK  - <i>Acknowledgement</i> (&laquo;acuse de recibo&raquo;)
<li><b>U</b> : URG  - <i>Urgent</i> (&laquo;urgente&raquo;)
<li><b>E</b> : ECE  - <i>Explicit Congestion Notification Echo</i> (&laquo;mensaje de congestión explícita&raquo;)
<li><b>W</b> : CWR  - <i>Congestion Window Reduced</i> (&laquo;ventana de congestión reducida&raquo;)
</ul>

<p>
Para que PF inspeccione los indicadores TCP durante la evaluación
de una regla se usa la clave <tt>flags</tt> con la sintaxis siguiente:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
La parte <tt><i>mask</i></tt> indica a PF que sólo inspeccione
los indicadores especificados, y la parte <tt><i>check</i></tt>
especifica qué indicadores deben estar activos ("on")
en la cabecera para que ocurra una concordancia.
EL uso de la palabra-clave <tt>any</tt> permite que cualquier
combinación de indicadores (<i>flags</i>) sea definido en la cabecera.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
pass in on fxp0 proto tcp from any to any port ssh
</tt>
</blockquote>

<p>
Como los <tt>indicadores S/SA</tt> se definen de forma prederminada,
las reglas anteriores son equivalentes. Cada una de estas reglas 
permite el paso de tráfico TCP con el indicador SYN activo, 
y sólo mira a los indicadores SYN y ACK.  
Un paquete con los indicadores SYN y ECE concordaría con la regla 
anterior, mientras que un paquete con SYN y ACK, o sólo con ACK, no
concordaría.

<p>
Los indicadores predeterminados pueden sobreescribirse
mediante la opción <tt>flags</tt> tal como se ha descrito
anteriormente.

<p>
Hay que tener cuidado con el uso de indicadores;  hay que entender
qué es lo que se está haciendo y por qué, y tener
cuidado con los consejos recibidos de otros ya que muchos suelen ser
erróneos.  Algunas personas han sugerido la creación de
estado &laquo;solo si está activado el indicador SYN, y no
otros&raquo;.  Una regla de este tipo terminaría así
<pre>
     . . . flags S/FSRPAUEW  <i>mala idea!!</i>
</pre>

<p>
La teoría es crear estado solo en el inicio de la
sesión TCP, y la sesión debería iniciarse con un
indicador SYN, y ningún otro.  El problema es que algunos sitios
están empezando a usar el indicador ECN, y cualquier sitio que
use ECN e intentara conectar con nosotros sería rechazado por una
regla de ese tipo.  Un enfoque mucho mejor sería no especificar
indicador alguno y dejar a PF que aplique los indicadores
predeterminados a las reglas de usted.
Si realmente necesita usted especificar indicadores, 
entonces esta combinación debería ser segura: 
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
<!--XXX scrub changes may have invalidated this-->
Aunque esto es práctico y seguro, también es necesario
comprobar los indicadores FIN y RST si se está normalizando 
(<i>scrub</i>) el tráfico.  El proceso de normalización de paquetes
hará que PF descarte cualquier paquete entrante que lleve una
combinación ilegal del indicador TCP (como SYN y
RST) y normalice combinaciones potencialmente 
ambiguas (como SYN y FIN).


<a name="synproxy"></a>
<h2>Proxy de paquetes TCP SYN</h2>
<p>
Normalmente, cuando un cliente inicia una conexión TCP a un
servidor, PF pasa los paquetes del saludo inicial
(<i><a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"> 
handshake</a></i>) entre los dos extremos según llegan.
Sin embargo, PF también puede hacer de proxy para el saludo
inicial.  Con el modo proxy, PF completará el saludo inicial con
el cliente, iniciará un saludo inicial con el servidor, y
pasará los paquetes entre los dos.  La ventaja de este proceso es
que no se enviará ningún paquete al servidor antes de que
el cliente complete el saludo inicial.  Esto elimina la amenaza de que
desbordamientos TCP SYN falseados puedan afectar al servidor, debido a
que una conexión de un cliente falseado no podrá completar
el saludo inicial.

<p>
El proxy TCP SYN se activa usando la clave <tt>synproxy state</tt> en
las reglas de filtrado.  Ejemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server port www synproxy state
</tt>
</blockquote>

<p>
En este ejemplo, PF hará de proxy TCP para las conexiones del
servidor web.

<p>
Debido al modo en que funciona <tt>synproxy state</tt>, también
incluye la misma funcionalidad que <tt>keep state</tt> y <tt>modulate
state</tt>.

<p>
El proxy SYN no funcionará si PF está funcionando sobre un
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>.

<a name="antispoof"></a>
<h2>Bloqueo de paquetes falsificados</h2>
<p>
La falsificación de direcciones (<i>spoofing</i>) es cuando un
usuario con malas intenciones falsifica la dirección IP de origen
en los paquetes que se transmiten, con el objetivo de esconder su
dirección real o de suplantar otro nodo en la red.  Una vez que
el usuario ha falsificado su dirección, puede lanzar un ataque a
nivel de red sin revelar la dirección real de origen del ataque,
o intentar obtener acceso a servicios de la red que estén
restringidos para ciertas direcciones IP.

<p>
PF ofrece cierto nivel de protección contra la
falsificación de direcciones mediante la clave
<tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Indica que los paquetes que concuerden se deben registrar en un
fichero a través de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.8"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Si un paquete concuerda con esta regla, entonces se
considerará que es la regla &laquo;ganadora&raquo; y
finalizará la evaluación del grupo de reglas.

<dt><tt><i>interface</i></tt>
<dd>La interfaz de red en la que se va a activar la protección
contra las falsificaciones.  También puede ser una
<a href="macros.html#lists">lista</a> de interfaces.

<dt><tt><i>af</i></tt>
<dd>La familia de direcciones para la que se va a activar la
protección contra las falsificaciones, y que puede ser
<tt>inet</tt> para IPv4 ó <tt>inet6</tt> para IPv6.
</dl>

<p>
Ejemplo:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Cuando se carga un grupo de reglas, cualquier suceso de la clave
<tt>antispoof</tt> se expandirá en dos reglas de filtrado.
Asumiendo que la interfaz <tt>fxp0</tt> tuviera una dirección IP
10.0.0.1 y una máscara de subred de 255.255.255.0 (o sea, un
/24), la regla <tt>antispoof</tt> anterior se expandiría
así:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Estas reglas realizan dos funciones:

<ul>
<li>Bloquean todo el tráfico que viene desde la red 10.0.0.0/24
que <i>no</i> pase a través de <tt>fxp0</tt>.  Como la red
10.0.0.0/24 está en la interfaz <tt>fxp0</tt>, los paquetes que
tengan una dirección de origen en ese bloque de red nunca
entrarán por ninguna otra interfaz.
<li>Bloquean todo el tráfico entrante desde 10.0.0.1, la
dirección IP en <tt>fxp0</tt>.  La máquina anfitriona no
debería enviar nunca paquetes a sí misma a través
de una interfaz externa;  por lo tanto, se puede considerar que
cualquier paquete entrante con una dirección de origen que
pertenezca a la máquina es malicioso.
</ul>

<p>
<b>NOTA</b>:  Las reglas de filtrado resultantes de la expansión
de la regla <tt>antispoof</tt> también bloquearán los
paquetes que se envíen por la interfaz de <i>loopback</i> hacia
direcciones locales.  
Es recomendable desactivar el filtrado en las interfaces 
de <i>loopback</i>, pero esto se convierte en necesidad 
cuando se utilizan reglas contra falsificaciones:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
El uso de <tt>antispoof</tt> se debe restringir a las interfaces a las
que se les haya asignado una dirección IP.  El uso de
<tt>antispoof</tt> en una interfaz sin una dirección IP
resultará en reglas de filtrado como:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Con estas reglas existe el riesgo de bloquear <i>todo</i> el
tráfico entrante en <i>todas</i> las interfaces.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
PF ofrece la funcionalidad <i>Unicast Reverse Path Forwarding</i> (uRPF). 
Cuando un paquete se somete a la comprobación uRPF, 
se busca la dirección IP de origen del paquete en la tabla de 
enrutamiento. 
Si la interfaz de salida hallada en la la tabla de enrutamiento 
es la misma por la que el paquete acaba de entrar, 
entonces la comprobación uRPF permite el paso del paquete. 
Si las interfaces no coinciden, entonces es posible que el paquete 
tenga su dirección de origen falsificada.

<p>
La comprobación uRPF puede realizarse en los paquetes utilizando
la palabra-clave <tt>urpf-failed</tt> en las reglas de filtrado:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Nótese que la comprobación uRPF solo tiene sentido en un entorno
donde el enrutado es simétrico.

<p>
uRPF proporciona la misma funcionalidad que las reglas
<a href="#antispoof">antifalsificación</a>

<a name="osfp"></a>
<h2>Detección pasiva del Sistema Operativo</h2>

<p>
La identificación pasiva del sistema operativo (<i>OS Fingerprinting</i> 
u OSFP por sus siglas en inglés) es un método para detectar pasivamente 
el sistema operativo de una máquina remota basado en ciertas características 
contenidas en sus paquetes SYN TCP.
Esta información puede usarse después como criterio en las reglas de filtrado.

<p>
PF determina el sistema operativo remoto comparando las características de un
paquete SYN TCP con el
<a href="options.html#fingerprints">archivo de huellas digitales</a> (<i>fingerprints</i>),
que por omisión es
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.8"
><tt>/etc/pf.os</tt></a>. 
Una vez que PF está habilitado, la lista actual de huellas digitales 
puede verse con la siguiente instrucción:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Dentro de una regla de filtrado, una huella digital puede especificarse
mediante una clase de sistema operativo, versión o nivel de subtipo/parche.
Cada uno de estos elementos se lista en la salida de la instrucción
<tt>pfctl</tt> de arriba. Para especificar una huella digital en una regla
de filtrado se usa la palabra clave <tt>os</tt>:

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
La clase especial de sistema operativo <tt>unknown</tt> hace que los paquetes
concuerden con la regla si las huellas digitales del sistema operativo son
desconocidas.

<p>
<font color="#ff0000">TOME NOTA</font> de lo siguiente:
<ul>
   <li>Las huellas digitales de los sistemas operativos de vez en cuando
   son incorrectas debido a paquetes falsificados y/o fabricados que
   son hechos para parecer como si provinieran de un sistema operativo
   específico.
   <li>Ciertas revisiones o niveles de parcheo de un sistema operativo
   pueden cambiar el comportamiento de la pila y hacer que ya no concuerde
   con el archivo de huellas digitales o que concuerde con algún otro
   sistema operativo. 
   <li>El OSFP sólo funciona con los paquetes SYN TCP; no funcionará con
   otro protocolos o con conexiones ya establecidas.
</ul>

<a name="ipopts"></a>
<h2>Opciones de IP</h2>
<p>
Por definición, PF bloquea los paquetes con las opciones IP
activadas.  Esto puede hacer las cosas más difíciles para
utilidades de detección de sistemas operativos (<i>OS
fingerprinting</i>) como nmap.  Si se tiene una aplicación que
requiere el paso de estos paquetes, como multidifusión o IGMP, se
puede usar la directiva <tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Ejemplo de reglas de filtrado</h2>
<p>
A continuación tenemos un ejemplo de un grupo de reglas de
filtrado.  La máquina en la que está funcionando PF
actúa como cortafuegos entre una red interna pequeña e
Internet.  Sólo se muestran las reglas de filtrado;  las reglas
de <a href="queueing.html">queueing</a>,
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>,
etc.. se han omitido en este ejemplo.
<br>
<br>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# tabla que contiene todas las direcciones IP asignadas al cortafuegos
table &lt;firewall&gt; const { self }

# no filtrar en el interfaz loopback
set skip on lo0

# normalizar los paquetes entrantes
match in all scrub (no-df)

# configurar una política de denegación predeterminada
block all

# activar la protección contra la falsificación de direcciones
# para todas las interfaces
block in quick from urpf-failed

# permitir sólo conexiones por ssh si provienen
# desde la máquina de confianza, 192.168.0.15;
# usar "block return" para que se envíe un TCP RST
# para cerrar inmediatamente las conexiones bloqueadas;
# usar "quick" para que las reglas "pass" que
# vienen a continuación no anulen esta regla.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# permitir el paso del tráfico hacia y desde la red local
# estas reglas crearán entradas de estado debido a la opción
# por omisión "keep state" que se aplica automáticamente
pass in  on $int_if from $lan_net
pass out on $int_if to $lan_net

# permitir el paso de paquetes tcp, udp e icmp
# salientes en la interfaz externa (Internet);
# modular el estado en conexiones tcp y mantener el estado en udp/icmp.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# permitir el paso de las conexiones entrantes de ssh
# en la interfaz externa siempre que su destino NO sea
# el cortafuegos (o sea, aquellas cuyo destino sea
# una máquina en la red local);  registrar el paquete inicial
# para que podamos ver más tarde quién intenta conectar.
# Usar el proxy tcp syn para la conexión.
# PF aplicará automáticamente los indicadores por omisión "S/SA" 
# a la regla.
pass in log on $ext_if proto tcp to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Anterior: Tablas</a>]
[<a href="index.html">Contenido</a>]
[<a href="nat.html">Siguiente: Traducción de Direcciones de
Red</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.55 ]<br>
$Translation: filter.html,v 1.15 2011/03/12 23:17:40 mvidal Exp $<br>
-->
$OpenBSD: filter.html,v 1.14 2011/03/13 07:16:15 ajacoutot Exp $
</small>

</body>
</html>
