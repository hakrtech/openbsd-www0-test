<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Redireccionamiento del tráfico (reenvío de
puertos)</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, Nick Holland <nick@openbsd.org>
Copyright (c) 2003-2005, Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../es/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="nat.html">Anterior: <i>NAT:</i> Traducción de
Direcciones de Red</a>]
[<a href="index.html">Contenido</a>]
[<a href="shortcuts.html">Siguiente: atajos para crear conjuntos de
reglas</a>]

<h1><font color="#e00000">PF: Redireccionamiento (reenvío de
puertos)</font></h1>

<hr>

<h3>Índice de contenidos</h3>
<ul>
<li><a href="#intro">Introducción</a>
<li><a href="#filter">Redireccionamiento y filtrado de paquetes</a>
<li><a href="#security">Implicaciones de seguridad</a>
<li><a href="#reflect">Redireccionamiento y reflexión</a>
       <ul>
	   <li><a href="#splitdns">DNS en "Split-Horizon"</a>
	   <li><a href="#sepnet">Traslado del servidor a una red local
	   separada</a>
       <li><a href="#tcpproxy">Proxy TCP</a>
       <li><a href="#rdrnat">Combinación de RDR-TO y NAT-TO</a>
       </ul>
</ul>

<hr>

<a name="intro"></a>
<a name="filter"></a>
<h2>Introducción</h2>
<p>
Cuando hay un servidor de NAT en la red de una oficina, todas
las máquinas de la red tienen acceso a Internet.  Pero,
&iquest;qué ocurre si se necesita acceder desde el exterior a una
de las máquinas que hay detrás de la pasarela de NAT?
Aquí es donde entra en escena el redireccionamiento.  El
redireccionamiento permite enviar el tráfico entrante a una
máquina que se encuentre detrás de una pasarela de NAT.

<p>
Veamos un ejemplo:
<blockquote>
<tt>
pass in on tl0 proto tcp from any to any port 80 rdr-to 192.168.1.20
</tt>
</blockquote>

<p>
Esta regla redirecciona el tráfico TCP del puerto 80 (un servidor
web) a una máquina que se encuentra dentro de la red en
192.168.1.20.  Así, aunque 192.168.1.20 esté detrás
de la pasarela y dentro de la red, es accesible desde fuera de ella.

<p>
La parte <tt>from any to any</tt> de la regla <tt>rdr</tt> anterior
puede ser bastante útil;  si sabemos qué direcciones o
subredes se supone que deben acceder al servidor web por el
puerto 80, podemos restringirlo con esa parte:
<blockquote>
<tt>
pass in on tl0 proto tcp from 27.146.49.0/24 to any port 80 \<br>
&nbsp;&nbsp;&nbsp;rdr-to 192.168.1.20
</tt>
</blockquote>

<p>
Con esto se redireccionaría sólo la subred especificada.
Nótese que esto implica que podemos redireccionar diversos
anfitriones entrantes hacia diversas máquinas que se encuentren
detrás de la pasarela.  Esto puede ser bastante útil.  Por
ejemplo, podríamos permitir que usuarios que se encontraran en
sitios remotos accedieran a sus propias máquinas de escritorio
usando el mismo puerto y dirección IP en la pasarela, siempre y
cuando supiéramos la dirección IP desde la que se
conectarían:
<blockquote>
<tt>
pass in on tl0 proto tcp from 27.146.49.14 to any port 80 \<br>
&nbsp;&nbsp;&nbsp;rdr-to 192.168.1.20<br>
pass in on tl0 proto tcp from 16.114.4.89 to any port 80 \<br>
&nbsp;&nbsp;&nbsp;rdr-to 192.168.1.22<br>
pass in on tl0 proto tcp from 24.2.74.178 to any port 80 \<br>
&nbsp;&nbsp;&nbsp;rdr-to 192.168.1.23
</tt>
</blockquote>

<p>
También se puede redireccionar un rango de puertos en la misma regla:
<blockquote>
<tt>
pass in on tl0 proto tcp from any to any port 5000:5500 \<br>
&nbsp;&nbsp;&nbsp;rdr-to 192.168.1.20<br>
pass in on tl0 proto tcp from any to any port 5000:5500 \<br>
&nbsp;&nbsp;&nbsp;rdr-to 192.168.1.20 port 6000<br>
pass in on tl0 proto tcp from any to any port 5000:5500 \<br>
&nbsp;&nbsp;&nbsp;rdr-to 192.168.1.20 port 7000:*<br>
</tt>
</blockquote>

<p>
Los ejemplos precedentes muestran los puertos 5000 a 5500 
inclusive redireccionados hacia 192.168.1.20.
En la primera regla, el puerto 5000 es redireccionado a 5000, 5001 a 5001, etc.
En la segunda regla, el rango entero es redireccionado al puerto 6000.
Y en la tercara regla, el puerto 5000 es redireccionado a 7000, 5001 a 7001, etc.

<a name="security"></a>
<h2>Implicaciones de seguridad</h2>
<p>
El redireccionamiento tiene algunas implicaciones de seguridad.  Pinchar
un agujero en el cortafuegos para permitir el paso de tráfico a
la red interna protegida deja abierta la máquina interna a merced
de un potencial compromiso de seguridad.  Si, por ejemplo, se
redireccionara el tráfico a un servidor de <i>web</i> interno y
se descubriera una vulnerabilidad en el d&aelig;mon del servidor de
<i>web</i> interno, o en un <i>script</i> de CGI que se ejecutara en el
servidor de <i>web</i>, entonces esa máquina podría ser
comprometida por un intruso desde Internet.  El intruso tendría
desde ahí un pasadizo a la red interna, una vez que se le ha
permitido pasar a través del cortafuegos.

<p>
Estos riesgos se pueden minimizar manteniendo el sistema al que hay que
acceder desde el exterior confinado firmemente en una red separada.
Esta red separada es la que se suele denominar como una &laquo;Zona
Desmilitarizada&raquo; (DMZ) o una Red de Servicio Privado (PSN).  De
este modo, si se comprometiera el servidor de <i>web</i>, los efectos se
podrían limitar la red DMZ/PSN, filtrando con cuidado el
tráfico con permiso para pasar desde y hacia la DMZ/PSN.

<a name="reflect"></a>
<h2>Redireccionamiento y reflexión</h2>
<p>
A menudo se utilizan reglas de redireccionamiento para reenviar
conexiones entrantes desde Internet a un servidor local con una
dirección privada en la red interna o LAN, como en:
<blockquote>
<tt>
server = 192.168.1.40<br>
<br>
pass in on $ext_if proto tcp from any to $ext_if port 80 \<br>
&nbsp;&nbsp;&nbsp;rdr-to $server port 80
</tt>
</blockquote>

<p>
Pero cuando se comprueba la regla de redireccionamiento desde un cliente
en la LAN, aquélla no funciona.  El motivo es que las reglas de
redireccionamiento sólo son válidas para los paquetes que
pasan a través de la interfaz especificada (<tt>$ext_if</tt>, la
interfaz externa en el ejemplo).  Sin embargo, conectar la
dirección externa del cortafuegos desde un anfitrión en la
LAN no implica que los paquetes vayan a pasar a través de su
interfaz externa.  La pila TCP/IP del cortafuegos compara las
direcciones de destino de los paquetes entrantes con sus propias
direcciones y alias, y detecta las conexiones a sí misma en
cuanto pasan la interfaz interna.  Estos paquetes no pasan físicamente a
través de la interfaz externa, y la pila no simula un pase de ese
tipo en modo alguno.  Así que PF nunca ve estos paquetes en la
interfaz externa y, por lo tanto, la regla de redireccionamiento que
especifica la interfaz externa no es válida.

<p>
Si añadiéramos una segunda regla de redireccionamiento
para la interfaz interna tampoco obtendríamos el efecto deseado.
Cuando el cliente local se conecta a la dirección externa del
cortafuegos, el paquete inicial del &laquo;saludo&raquo; de TCP llega al
cortafuegos a través de la interfaz interna.  La regla de
redireccionamiento es válida y la dirección de destino se
sustituye con la del servidor interno.  El paquete se reenvía de
vuelta a través de la interfaz interna y llega al servidor
interno.  Pero no se ha traducido la dirección de origen y
todavía contiene la dirección local del cliente, por lo
que el servidor envía sus respuestas directamente al cliente.  El
cortafuegos nunca llega a ver la respuesta y no tiene la oportunidad de
invertir correctamente la traducción.  El cliente recibe una
respuesta desde un punto de origen que no esperaba, y por lo tanto la
bloquea.  En consecuencia, falla el saludo inicial de TCP y no se puede
establecer una conexión.

<p>
A pesar de esto, a menudo es deseable que los clientes internos de la
LAN se conecten al mismo servidor interno que los clientes externos, y
que lo hagan de forma transparente.  Existen varias soluciones para este
problema.

<a name="splitdns"></a>
<h3>DNS en "Split-Horizon"</h3>

<p>
Se pueden configurar los servidores de DNS para que respondan a los
requerimientos de los anfitriones locales de forma diferente a los
requerimientos externos, de modo que los clientes locales reciban la
dirección del servidor interno durante la resolución del
nombre.  Así se conectarán directamente al servidor local
y el cortafuegos no estará en medio de este proceso.  Esto reduce
el tráfico local, ya que no hay que enviar los paquetes a
través del cortafuegos.

<a name="sepnet"></a>
<h3>Traslado del servidor a una red local separada</h3>

<p>
Añadir una interfaz de red adicional al cortafuegos y trasladar
el servidor local desde la red del cliente a una red dedicada (DMZ)
permite redireccionar las conexiones de los clientes locales de la misma
forma que se redireccionan las conexiones externas.  El uso de redes
separadas ofrece varias ventajas, incluida la mejora de la seguridad al
aislar al servidor del resto de los anfitriones locales.  Si el servidor
(al que en nuestro caso se puede llegar desde Internet) llegara a ser
comprometido, no podría acceder directamente a otros anfitriones,
ya que todas los conexiones deben pasar a través del cortafuegos.

<a name="tcpproxy"></a>
<h3>Proxy TCP</h3>

<p>
Se puede configurar un <i>proxy</i> [<i>N. del T.</i>: un servidor 
intermedio de almacenamiento que actúa de intermediario entre el cliente 
y el servidor al que se quiere acceder, y que aligera la conexión
ofreciendo datos del servidor final que tenga almacenados]
genérico de TCP en el cortafuegos, bien a la escucha en el puerto
de reenvío o bien redireccionando las conexiones de la interfaz
interna al puerto por el que está a la escucha.  Cuando un
cliente local se conecta al cortafuegos, el <i>proxy</i> acepta la
conexión, establece una segunda conexión al servidor
interno, y reenvía los datos entre esas dos conexiones.

<p>
Se pueden crear <i>proxies</i> simples usando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1"
>nc(1)</a>.
La siguiente entrada de <tt>/etc/inetd.conf</tt> crea un conector
(<i>socket</i>) que estará a la escucha, vinculado a la
dirección de <i>loopback</i> (127.0.0.1) y al puerto 5000.  Las
conexiones se reenvían al puerto 80 del servidor 192.168.1.10.
El reenvío lo realiza el usuario "proxy".
<blockquote>
<tt>
127.0.0.1:5000 stream tcp nowait proxy /usr/bin/nc nc -w \<br>
&nbsp;&nbsp;&nbsp;20 192.168.1.10 80
</tt>
</blockquote>

<p>
La siguiente regla de redireccionamiento reenvía el puerto 80 de
la interfaz interna al <i>proxy</i>:
<blockquote>
<tt>
pass in on $int_if proto tcp from $int_net to $ext_if port 80 \<br>
&nbsp;&nbsp;&nbsp;rdr-to 127.0.0.1 port 5000
</tt>
</blockquote>

Pueden crearse también <i>proxies</i> de alto rendimiento con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=relayd&amp;sektion=8"
>relayd(8)</a>.

<a name="rdrnat"></a>
<h3>Combinación de RDR-TO y NAT-TO</h3>

<p>
Con una regla adicional de NAT en la interfaz interna se puede obtener
la traducción de la dirección de origen que falta y que se
ha descrito antes.
<blockquote>
<tt>
pass in on $int_if proto tcp from $int_net to $ext_if port 80 \<br>
&nbsp;&nbsp;&nbsp;rdr-to $server<br>
pass out on $int_if proto tcp to $server port 80 \<br>
&nbsp;&nbsp;&nbsp;received-on $int_if nat-to $int_if
</tt>
</blockquote>

<p>
Con esto se consigue que el paquete inicial del cliente sea traducido de
nuevo cuando se reenvíe de vuelta a través de la interfaz
interna, sustituyendo la dirección de origen del cliente con la
dirección interna del cortafuegos.  El servidor interno
enviará una respuesta al cortafuegos, que puede invertir las
traducciones de NAT y RDR cuando esté reenviando al cliente
local.  Esta construcción es bastante compleja, ya que crea dos
estados separados para cada una de las conexiones reflejadas.  Hay que
tener cuidado para que la regla de NAT no sea válida para otro
tráfico, por ejemplo para conexiones que se originen en
anfitriones externos (a través de otros redireccionamientos) o en
el mismo cortafuegos.  Nótese que la regla <tt>rdr-to</tt> anterior
hará que la pila de TCP/IP vea los paquetes que llegan a la
interfaz interna con una dirección de destino dentro de la red
interna. 

<p>
En general, se deberían usar las soluciones mencionadas
anteriormente en lugar de esta.

<p>
[<a href="nat.html">Anterior: <i>NAT:</i> Traducción de
Direcciones de Red</a>]
[<a href="index.html">Contenido</a>]
[<a href="shortcuts.html">Siguiente: Atajos para crear conjuntos de
reglas</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: rdr.html,v 1.30 ]<br>
$Translation: rdr.html,v 1.13 2011/02/28 20:32:04 mvidal Exp $<br>
-->
$OpenBSD: rdr.html,v 1.12 2011/03/04 16:16:15 ajacoutot Exp $
</small>

</body>
</html> 
