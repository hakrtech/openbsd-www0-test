<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Example #1: Firewall for Home or Small Office</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-2022-JP">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="authpf.html">前に戻る: authpf: 認証ゲートウェイ用
ユーザシェル</a>]
[<a href="index.html">目次</a>]

<p>
<h1><font color="#e00000">PF: 例 #1: 自宅や小規模事務所用ファイアウォール</font></h1>
<hr>

<h3>目次</h3>
<ul>
<li><a href="#scenario">シナリオ</a>
	<ul>
	<li><a href="#network">ネットワーク</a>
	<li><a href="#objective">目標</a>
	<li><a href="#prep">準備</a>
	</ul>
<li><a href="#ruleset">ルールセット</a>
	<ul>
	<li><a href="#macros">マクロ</a>
	<li><a href="#options">オプション</a>
	<li><a href="#scrub">スクラブ (scrub)</a>
	<li><a href="#nat">ネットワークアドレス変換 (NAT)</a>
	<li><a href="#rdr">リダイレクション</a>
	<li><a href="#filter">フィルタルール</a>
	</ul>
<li><a href="#allrules">完全なルールセット</a>
</ul>

<hr>

<a name="scenario"></a>
<h2>シナリオ</h2>
この例では、PF は自宅か事務所の小規模ネットワーク用のファイアウォール兼
NAT ゲートウェイとして稼働中の OpenBSD マシン上で実行されています。
全体としての目的は、インターネットへのアクセスおよびインターネットから
ファイアウォールへの限定されたアクセスを提供することです。このドキュメントでは、
これを可能にする完全なルールセットについて検討を加えます。

<a name="network"></a>
<h3>ネットワーク</h3>
ネットワークは以下のような構成となっています。

<pre>
    
  [ COMP1 ]    [ COMP3 ]
      |            |                               ADSL
   ---+------+-----+------- fxp0 [ OpenBSD ] ep0 -------- ( インターネット )
             |
         [ COMP2 ]

</pre>

<p>
内部ネットワークには多数のコンピュータが接続されています。上図では
3 台になっていますが、これは実際の台数とは無関係です。これらのコンピュータは、
web サーフィン、電子メール、チャットなどの用途で使用されるワークステーションです。
内部ネットワークは 192.168.0.0 を使用しており、ネットワークブロックは 255.255.255.0 となっています。

<p>
この OpenBSD ルータは 2 枚のネットワークカード 3Com 3c509B (ep0) ならびに
Intel EtherExpress Pro/100 (fxp0) を持つ Pentium 100 のマシンです。この
ルータはインターネットへの ADSL 接続を持っており、この接続を内部ネットワークで
共有するために NAT を使用しています。外部インターフェイスの IP アドレスは、
インターネットサービスプロバイダ (ISP) から動的に割り当てられています。

<a name="objective"></a>
<h3>目標</h3>
目標は以下のとおりです。
<ul>
<li>それぞれの内部コンピュータからの制限されないインターネットアクセスの提供。
<li>「デフォルトで拒否」のフィルタルールセットの使用。
<li>インターネットからファイアウォールへの、以下の着信トラフィックの
許可。
	<ul>
	<li>SSH (TCP ポート 22): これはファイアウォールマシンの外部からの
	メンテナンスのために使用されます。
	<li>Auth/Ident (TCP ポート 113): SMTP や IRC のような、ある種の
	サービスのために使用されます。
	<li>ICMP Echo Requests:
	<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&amp;sektion=8&amp;manpath=OpenBSD+3.3"
	>ping(8)</a> で使用される ICMP パケットタイプです。
	</ul>
<li>外部インターフェイスのフィルタの統計情報のログを取得します。
<li>デフォルトで、ブロックしたパケットに対して TCP RST や ICMP Unreachable
応答を返します。
<li>可能な限り単純でメンテナンスが簡単になるようなルールセットとします。
</ul>

<a name="prep"></a>
<h3>準備</h3>
このドキュメントでは、OpenBSD のホストは、<tt>net.inet.ip.forwarding</tt> が "<tt>1</tt>"
に設定されていて、また、IP ネットワークの設定やインターネットへの接続性の検査を含めて
ルータとして動作できるよう、適切に設定されているものと仮定しています。

<a name="ruleset"></a>
<h2>ルールセット</h2>
以下は、上記の目的を達成することのできるルールセットの
各部分の解説です。

<a name="macros"></a>
<h3>マクロ</h3>
以下のマクロは、メンテナンスとルールセットの解読がより簡単になるよう、
定義されているものです。
<blockquote>
<tt>
int_if = "fxp0"<br>
ext_if = "ep0"<br>
<br>
tcp_services = "{ 22, 113 }"<br>
icmp_types = "echoreq"<br>
<br>
priv_nets = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
</tt>
</blockquote>

<p>
最初の 2 行は、実際にフィルタリングが行われるネットワークインターフェイスを
定義しています。3 行目と 4 行目とは、インターネットに対して開かれた TCP
ポート番号 (SSH と ident/auth) および、ファイアウォールに届くことが許される
ICMP のパケットタイプを定義しています。
最後の行はループバックと
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>
のプライベートアドレスのブロックを定義しています。

<p>
<b>注</b>: もし、ADSL によるインターネット接続が
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8&amp;manpath=OpenBSD+3.3"
>PPPoE</a> を必要とする場合、フィルタリングや NAT は <tt>ep0</tt> に対してでは
<i>なく</i>、<tt>tun0</tt> インターフェイスに対して定義する必要があります。

<a name="options"></a>
<h3>オプション</h3>
以下のふたつのオプションは、<tt>block</tt> フィルタルールに対する
デフォルトの反応を設定し、そして、外部インターフェイスに対する
統計情報のログを取得するように設定しています。
<blockquote>
<tt>
set block-policy return<br>
set loginterface $ext_if
</tt>
</blockquote>

<a name="scrub"></a>
<h3>スクラブ (scrub)</h3>
すべての着信トラフィックに対する、推奨されるパケット再構成を行わない理由はなく、
以下は単純な一行の定義です。
<blockquote>
<tt>
scrub in all
</tt>
</blockquote>

<a name="nat"></a>
<h3>ネットワークアドレス変換 (NAT)</h3>
内部ネットワーク全体に対する NAT を実行するためには、
以下のような <tt>nat</tt> ルールを使用します。
<blockquote>
<tt>
nat on $ext_if from $int_if:network to any -&gt; ($ext_if)
</tt>
</blockquote>

<p>
外部インターフェイスの IP アドレスは動的に割り当てられますので、
アドレスが変化した場合に PF がこれに注意を払うことができるよう、
変換するインターフェイスに対して括弧を付与しておきます。

<a name="rdr"></a>
<h3>リダイレクション</h3>
リダイレクションは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.3"
>ftp-proxy(8)</a> のためだけに必要とされていて、ローカルネットワーク上の FTP
クライアントがインターネット上の FTP サーバに接続できるようにするためのものです。
<blockquote>
<tt>
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</tt>
</blockquote>

<p>
このルールは、ポート 21 番への FTP 接続だけを捕えることができます。もし、
ユーザが FTP サーバの他のポートに対して、いつも接続しているのでしたら、
たとえば <tt>from any to any port { 21, 2121 }</tt> のように、
リストは送信先ポートを指定するために使用されるべきです。

<a name="filter"></a>
<h3>フィルタルール</h3>
ここからはフィルタルールについてです。このデフォルトは拒否で始まります。
<blockquote>
<tt>
block all<br>
</tt>
</blockquote>

<p>
この時点では、内部ネットワークからのものも含めて、ファイアウォールを
通過するパケットは何もありません。以下のルールによって、上記の目的ごとに
ファイアウォールを開いていき、同様に、すべての必要な仮想インターフェイス
も開いていきます。

<p>
どの Unix システムも、「ループバック」インターフェイスを持ちます。これは、システム内の
アプリケーションが互いに他と通信するのに使用される仮想的なネットワークインターフェイスです。
一般的に、すべてのトラフィックは、このループバックインターフェイスにわたされるべきです。
OpenBSD では、ループバックインターフェイスは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4&amp;manpath=OpenBSD+3.3"
>lo(4)</a> です。
<blockquote>
<tt>
pass quick on lo0 all
</tt>
</blockquote>

<p>
次に、
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>
のプライベートアドレスは、公のインターネットに出現してはいけないので、
外部インターフェイスに入って来たり、出て行ったりするのをブロックします。
これらをフィルタリングすることは、ルータがこれらのアドレスが内部ネットワークから
「漏れて」出て行かないことと、同じくこれらのネットワークのひとつを
送信元アドレスとする着信パケットを阻止することを確実にします。
<blockquote>
<tt>
block drop in &nbsp;quick on $ext_if from $priv_nets to any<br>
block drop out quick on $ext_if from any to $priv_nets
</tt>
</blockquote>

<p>
<tt>block drop</tt> は、TCP RST や ICMP Unreachable パケットに応答する必要がないことを PF
に指示するために使用されるということに注意してください。RFC 1918 のプライベートアドレスは
インターネットに存在しないので、これらのアドレスに送信先されるパケットはすべて、何があろうと
何もしてはいけません。また、<tt>quick</tt> オプションは、そこから上のルールにパケットが
マッチした場合に、PF に残りのフィルタルールを評価する手間をかける必要がないことを指示するために
使用されます。<tt>$priv_nets</tt> ネットワークへの、あるいは、そこからのパケットは、
直ちに廃棄されます。

<p>
ここで、インターネットに対して公開しているネットワークサービスが使用する
ポートを開きます。
<blockquote>
<tt>
pass in on $ext_if inet proto tcp from any to ($ext_if) \<br>
&nbsp;&nbsp;&nbsp;port $tcp_services flags S/SA keep state
</tt>
</blockquote>

<p>
<tt>$tcp_services</tt> マクロの中にネットワークポートを指定することにより、
単にマクロを編集し、ルールセットを再ロードすることで、インターネットに対して
付加的なサービスを開くことが簡単にできるようになります。同様に、UDP のサービスも
<tt>$udp_services</tt> マクロを生成し、上記のように、<tt>proto udp</tt>
を指定したフィルタルールを追加しておくことで、開くことができるようになります。

<p>
この時点で、ICMP のトラフィックは以下のように通過させておくべきでしょう。
<blockquote>
<tt>
pass in inet proto icmp all icmp-type $icmp_types keep state
</tt>
</blockquote>

<p>
<tt>$tcp_services</tt> マクロと同じように、<tt>$icmp_types</tt> マクロも、
ファイアウォールに到達することができる ICMP パケットのタイプの変更するため、
簡単に編集することができます。このルールはすべてのネットワークインターフェイスに
適用されるということに注意してください。

<p>
この時点で、内部ネットワークからのトラフィックは通過できるようにすべきです。ここで、
私たちは、内部ネットワークのユーザは、自分たちが何をしようとしているのかを知っていて、
トラブルを引き起こすつもりなどはないものと仮定しましょう。
これは必ずしも正当な仮定ではなく、いくつかの環境では、より限定的なルールセットが
適切であるかも知れません。
<blockquote>
<tt>
pass in on $int_if from $int_if:network to any keep state
</tt>
</blockquote>

<p>
上記のルールは、すべての内部のマシンに、ファイアウォールを通過するパケットの送信を
許可していますが、ファイアウォールから内部のマシンに対して接続しようとすることは
許可して<i>いません</i>。しかし、本当にこれで良いのでしょうか ? &nbsp;もちろん、その答は
ネットワーク構成のより詳細な部分に依存することです。たとえば、ファイアウォールが DHCP
サーバを兼ねている場合には、IP の割り当て前にクライアントが生きているかどうかを確認するのに
"ping" を行う必要があるかも知れません。ファイアウォールが内部ネットワークに接続するのを
許可することはまた、インターネットからファイアウォールに SSH で接続してきた誰かに
内部ネットワークへのアクセスを許可することでもあります。
ファイアウォールが直接内部ネットワークに通信を行うことを許可<i>しない</i>ことが
セキュリティ上の大きな利点になるわけではないということに留意しておいてください。
もし、誰かがファイアウォールへのアクセスを手に入れたとすると、どのみちフィルタルールも
たいていは変更されてしまうかも知れないからです。以下のフィルタルールを追加することによって、
ファイアウォールから内部ネットワークに接続しようとすることができるようになります。
<blockquote>
<tt>
pass out on $int_if from any to $int_if:network keep state
</tt>
</blockquote>

<p>
もし、これらの両方の行が記述されている場合には、<tt>keep state</tt> オプションは
不要であることに注意してください。つまり、双方向にパケットを通過させるための
ルールが記述されているのですから、すべてのパケットは内部インターフェイスを
通過することができるわけです。しかし、<tt>pass out</tt> の行が含まれて<i>いない</i>場合には、
<tt>pass in</tt> の行には <tt>keep state</tt> オプションが含まれている<i>必要があります</i>。
また、この状態の保持 (keep state) には、いくつかの性能上の利点もあります。
たとえば、状態テーブルはルールの評価前にチェックされ、
状態のマッチがあった場合には、パケットはルールセットの評価を受けることなく
ファイアウォールを通過します。これによって、負荷の重いファイアウォールに対して
性能上の利点を提供することができますが、この単純なことによって、
システム内部で非常に大きな負荷を発生してしまうようなことは考えにくいでしょう。

<p>
最終的に、外部インターフェイスから出て行くトラフィックを通過させます。
<blockquote>
<tt>
pass out on $ext_if proto tcp all modulate state flags S/SA<br>
pass out on $ext_if proto { udp, icmp } all keep state
</tt>
</blockquote>

<p>
これで TCP、UDP および ICMP のトラフィックはファイアウォールからインターネットに向かって
出て行くことができます。また、応答パケットがファイアウォールを通過して内部ネットワークに
入れるよう、状態情報が保持されます。

<a name="allrules"></a>
<h2>完全なルールセット</h2>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# macros
int_if = "fxp0"
ext_if = "ep0"

tcp_services = "{ 22, 113 }"
icmp_types = "echoreq"

priv_nets = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
	  
# options
set block-policy return
set loginterface $ext_if

# scrub
scrub in all

# nat/rdr
nat on $ext_if from $int_if:network to any -&gt; ($ext_if)
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 \
   port 8021

# filter rules
block all

pass quick on lo0 all

block drop in  quick on $ext_if from $priv_nets to any
block drop out quick on $ext_if from any to $priv_nets

pass in on $ext_if inet proto tcp from any to ($ext_if) \
   port $tcp_services flags S/SA keep state

pass in inet proto icmp all icmp-type $icmp_types keep state

pass in  on $int_if from $int_if:network to any keep state
pass out on $int_if from any to $int_if:network keep state

pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state
</pre>
</td></tr>
</table>

<p>
[<a href="authpf.html">前に戻る: authpf: 認証ゲートウェイ用
ユーザシェル</a>]
[<a href="index.html">目次</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: example1.html,v 1.7 ]
<br>
$Translation: example1.html,v 1.7 2003/07/10 15:18:32 toshi Exp $
<br>
$OpenBSD: example1.html,v 1.5 2003/07/11 20:33:06 jufi Exp $
</small>

</body>
</html> 
