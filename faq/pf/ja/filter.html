<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Packet Filtering</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-2022-jp">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 2002-2004 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="tables.html">前に戻る: テーブル</a>]
[<a href="index.html">目次</a>]
[<a href="nat.html">次に進む: ネットワークアドレス変換 (NAT)</a>]

<h1><font color="#e00000">PF: パケットフィルタリング</font></h1>

<hr>

<h3>目次</h3>
<ul>
<li><a href="#intro">はじめに</a>
<li><a href="#syntax">ルールのシンタクス</a>
<li><a href="#defdeny">デフォルトで拒否</a>
<li><a href="#pass">通過トラフィック</a>
<li><a href="#quick"><tt>quick</tt> キーワード</a>
<li><a href="#state">状態の保持</a>
<li><a href="#udpstate">UDP の状態の保持</a>
<li><a href="#tcpflags">TCP のフラグ</a>
<li><a href="#synproxy">TCP SYN プロキシ</a>
<li><a href="#antispoof">詐称されたパケットのブロック</a>
<li><a href="#ipopts">IP オプション</a>
<li><a href="#example">フィルタリングルールセットの例</a>
</ul>

<hr>

<a name="intro"></a>
<h2>はじめに</h2>
パケットフィルタリングとは、ネットワークインターフェイスからわたされるデータパケットを
選択的に通過させたりブロックしたりすることです。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>pf(4)</a> がパケットを検査する場合に使用する判断基準は、レイヤ 3 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>IPv4</a> および 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>IPv6</a>) ならびにレイヤ 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>TCP</a>、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>UDP</a>、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>ICMP</a> および
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>ICMPv6</a>) のヘッダに基づきます。最も良く使用される判断基準は、送信元および送信先のアドレス、
送信元および送信先のポート、そしてプロトコルでしょう。

<p>
フィルタルールには、パケットがマッチすべき判断基準、およびパケットがマッチした場合に
その結果として取るべき、通過かブロックかのいずれかの動作が指定されます。
フィルタルールは、先頭から末尾の方に向けて、指定されている順序で評価されます。
パケットが、<tt>quick</tt> キーワードの指定されたルールにマッチしない限りは、
最終的な動作が行われるまでに、パケットは<i>すべての</i>フィルタルールに対して
評価されることになります。最後にマッチしたルールが「勝者」であり、パケットに対して
どのような動作を取るべきかが指示されることになります。フィルタリングルールセット
の先頭に、暗黙のうちに <tt>pass all</tt> が指定されていると見なされるため、
パケットがどのフィルタルールにもマッチしなかった場合には、その結果として取られる
動作は<i>通過</i>となります。

<a name="syntax"></a>
<h2>ルールのシンタクス</h2>
一般的に、フィルタルールを<i>高度に単純化</i>したシンタクスは以下のとおりです。
<blockquote>
<tt>
<i>action</i> <i>direction</i> [log] [quick] on <i>interface</i> [<i>af</i>] 
[proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;from <i>src_addr</i> [port <i>src_port</i>] to 
<i>dst_addr</i> [port <i>dst_port</i>] \<br>
&nbsp;&nbsp;&nbsp;[<i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>マッチしたパケットに対して取るべき動作は、<tt>pass</tt> か <tt>block</tt>
のいずれかです。<tt>pass</tt> がその先の処理のためにパケットを通過させて
カーネルに戻す動作であるのに対して、<tt>block</tt> は
<a href="options.html#block-policy"><tt>block-policy</tt></a> オプションの
設定に基づいて反応する動作となります。
デフォルトの反応は、<tt>block drop</tt> か <tt>block return</tt> の
いずれかを指定することで、こちらの方が優先されるようになります。

<dt><tt><i>direction</i></tt>
<dd>インターフェイス上のパケットの移動する方向を <tt>in</tt> か <tt>out</tt>
のいずれかで指定します。

<dt><tt>log</tt>
<dd><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.4"
>pflogd(8)</a> 経由でパケットのログを取得すべきであることを指定します。
ここで、ルールに <tt>keep state</tt>、<tt>modulate state</tt> か <tt>synproxy state</tt>
オプションが指定されている場合には、確立された状態のパケットのログのみ記録されます。
ですので、そのような状態とは無関係にすべてのパケットのログを取得したい場合は
<tt>log-all</tt> を指定してください。

<dt><tt>quick</tt>
<dd>パケットが <tt>quick</tt> の指定されたルールにマッチした場合には、そのルールは
最終的にマッチすべきルールと見なされるので、ここに指定された<tt><i>動作</i></tt>が
実行されます。

<dt><tt><i>interface</i></tt>
<dd>パケットが移動するネットワークインターフェイス名を記述します。

<dt><tt><i>af</i></tt>
<dd>パケットのアドレスファミリを指定するためのもので、IPv4 用の <tt>inet</tt> か
IPv6 用の <tt>inet6</tt> のいずれかを指定します。PF は通常は、送信元 および/または
送信先のアドレスに基づいて、このパラメータを決定することができます。

<dt><tt><i>protocol</i></tt>
<dd>パケットのレイヤ 4 のプロトコルを指定します。
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.4"
><tt>/etc/protocols</tt></a>
に記述された正しいプロトコル名
<li>0 から 255 までのプロトコル番号
<li><a href="macros.html#lists">リスト</a>を使用したプロトコルの集合
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>IP ヘッダ中の送信元/送信先アドレスです。
以下のアドレスを指定することができます。
<ul>
<li>単一の IPv4 か IPv6 アドレス
<li><a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a> 
ネットワークブロック
<li>ルールセットがロードされる際に DNS
を参照して解決される FQDN。すべての結果の IP アドレスが
ルールに代入されます。
<li>ネットワークインターフェイス名。インターフェイスに割り当てられた
すべての IP アドレスがルールに代入されます。
<li><tt>/<i>netmask</i></tt> (たとえば <tt>/24</tt>) のような
ネットマスクの指定されたネットワークインターフェイス名。インターフェイスの
それぞれの IP アドレスは、ルールに代入される CIDR ネットワークブロックの形で
ネットマスクに結合されます。
<li>括弧 <tt>( )</tt> 内に指定されたネットワークインターフェイス名。これは、
PF はこの名前のインターフェイス上の IP アドレスが変更された場合に、ルールを
更新すべきことを指示します。これは、IP アドレスが DHCP 経由やダイアルアップ
経由でインターフェイスに割り当てられている場合に、アドレスが変更された時に
毎回ルールセットを再ロードする必要がないので便利です。
<li><tt>:network</tt> か <tt>:broadcast</tt> キーワードの指定された
ネットワークインターフェイス名。ルールセットのロードの際に、その結果の
CIDR ネットワーク (たとえば 192.168.0.0/24) やブロードキャストアドレス
(たとえば 192.168.0.255) がルールに代入されます。
<li><a href="tables.html">テーブル</a>
<li><tt>!</tt> ("否定") 修飾子を使用して意味を反転させた上記のいずれか
<li><a href="macros.html#lists">リスト</a>を使用したアドレスの集合
<li>キーワード <tt>any</tt> はすべてのアドレスを意味します。
<li>キーワード <tt>all</tt> は <tt>from any to any</tt>
の短縮形です。
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>レイヤ 4 のパケットヘッダ中の送信元/送信先ポートです。
以下のポートを指定することができます。
<ul>
<li>1 から 65535 までの番号
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.4"
><tt>/etc/services</tt></a>
に記述された正しいサービス名
<li><a href="macros.html#lists">リスト</a>を使用したポートの集合
<li>範囲には以下の演算子が使用できます。
	<ul>
	<li><tt>!=</tt> (not equal)
	<li><tt>&lt;</tt> (less than)
	<li><tt>&gt;</tt> (greater than)
	<li><tt>&lt;=</tt> (less than or equal)
	<li><tt>&gt;=</tt> (greater than or equal)
	<li><tt>&gt;&lt;</tt> (range)
	<li><tt>&lt;&gt;</tt> (inverse range)
	</ul>
	<dl>
	<dd>最後のふたつはバイナリの演算子 (ふたつの引数を取ります) で、
	range 中には引数は含まれません。
	</dl>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd><tt>proto tcp</tt> を使用する場合に、TCP ヘッダにセットされているべき
フラグを指定します。このフラグは、<tt>flags <i>check</i>/<i>mask</i></tt>
として指定されます。たとえば、<tt>flags S/SA</tt> の場合、PF は
S と A (SYN と ACK) フラグだけに注目し、SYN フラグが "on" の場合に
マッチするよう指示します。

<dt><tt><i>state</i></tt>
<dd>パケットがこのルールにマッチした場合に、状態の情報を保持するかどうかを
指定します。
<ul>
<li><tt>keep state</tt> - TCP、UDP および ICMP に対して有効です。
<li><tt>modulate state</tt> - TCP に対してのみ有効です。パケットが
ルールにマッチするために PF は強力な初期シーケンス番号 (ISN) を生成します。
<li><tt>synproxy state</tt> - 詐称された TCP SYN flood からサーバを防護するため、
着信する TCP 接続のプロキシを行います。
このオプションは、<tt>keep state</tt> および <tt>modulate state</tt>
の機能を含んでいます。
</ul>
</dl>

<a name="defdeny"></a>
<h2>デフォルトで拒否</h2>
ファイアウォールを設定する際のお勧めの方法は、「デフォルトで拒否」という
アプローチを取ることです。それは、<i>すべてのもの</i>を拒否することであり、
確かなトラフィックだけファイアウォールの通過を選択的に許可するというものです。
たとい間違いでも警戒するに越したことはないわけですし、またルールセットの記述が
より簡単にもなりますので、このアプローチを推奨します。

<p>
デフォルトで拒否するフィルタのポリシーを作成するには、
最初のふたつのフィルタルールは以下のものでなければなりません。
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
これはすべてのインターフェイス上の、どこからどこへ行くものであっても、
すべてのトラフィックを双方向ともブロックするというものです。

<a name="pass"></a>
<h2>通過トラフィック</h2>
これで、トラフィックは明示的にファイアウォールを通過させるか、デフォルトで拒否する
ポリシーによって廃棄されるかのどちらかになりました。これは、送信元/送信先のポートや
送信元/送信先のアドレス、そしてプロトコルといったパケットの判断基準が、ここで
関係してくることを意味します。トラフィックにファイアウォールの通過を許可するときは、
常に可能な限り限定的なルールを記述すべきです。
これは、意図したトラフィック、そう、本当に意図したトラフィックだけが通過を許される
ということを確実にするためなのです。

<p>
いくつかの例を以下に示します。
<blockquote>
<tt>
# dc0 上に、ローカルネットワーク 192.168.0.0/24 から OpenBSD マシンの<br>
# IP アドレス 192.168.0.1 に着信するパケットだけを通過させます。また、<br>
# dc0 から戻って行くトラフィックも同様に通過させます。<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# OpenBSD マシン上で実行される web サーバへの、fxp0 上の TCP の<br>
# 着信トラフィックを通過させます。パケットが OpenBSD マシン宛の<br>
# ものである場合のみこのルールにマッチするよう、インターフェイス名<br>
# fxp0 を送信先アドレスとして使用しています。<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2><tt>quick</tt> キーワード</h2>
上記に示したとおり、それぞれのパケットは、フィルタルールセットの先頭から末尾へと
評価が行われます。デフォルトでは、パケットは通過するよう設定されていますが、
これはフィルタルールの最後までなら、各種ルールによって変更することもできますし、
何度でも変更することができます。そして、<b>最後にマッチしたルールが採用されます</b>。
しかし、これには例外があり、フィルタリングルール上に <tt>quick</tt> 
オプションが指定されている場合、それ以降のルールの処理を無効化する効果を持ち、
指定されたとおりの動作が取られることになります。
以下のひと組の例を見てみましょう。

<p>
良くない例:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
この例では、この <tt>block</tt> 行は評価されるかも知れませんが、
その次に、何でも通過させてしまう行があるため、
何の効果も持ちません。

<p>
良い例:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
これらのルールの場合、少し異なる評価が行われます。<tt>block</tt>
行にマッチすると、<tt>quick</tt> オプションが指定されているため、
パケットはブロックされ、残りのルールセットは無視されます。

<a name="state"></a>
<h2>状態の保持</h2>
パケットフィルタの重要な機能のひとつに「状態の保持」あるいは
「状態を持つ検査」があります。状態を持つ検査は、ネットワーク接続の状態や
進行状況を追跡するための PF の能力に属するものです。それぞれの接続についての
情報を状態テーブルに保存することによって、PF は迅速にファイアウォールを
通過しようとしているパケットが既に確立された接続に属するものかどうかを
決定することができます。もしそうなら、ルールセットの評価が行われることなしに
ファイアウォールを通過することができます。

<p>
状態の保持は、より簡単なルールセットやより良いフィルタリング性能など、
多くの優位性を持っています。PF は状態テーブルのエントリと移動するパケットとを
<i>双方向</i>ともマッチさせることができますが、これは帰りのトラフィックを
通過させるためのフィルタルールを記述する必要がないことを意味しています。
そして、状態を持つ接続にパケットがマッチするとルールセットを評価する
必要がないので、PF がこれらのパケットの処理に要する時間を大幅に
減少させることができます。

<p>
ルールが <tt>keep state</tt> オプションを持つ場合、ルールにマッチする
最初のパケットは、送信者と受信者との間の「状態」を生成することになります。
今、送信者から受信者に送出されるパケットは状態エントリにマッチし、ルールセット
の評価をバイパスするだけでなく、受信者側から送信者側に送り返される
応答パケットも同様のことが行われます。これはたとえば、以下の例のような行です。
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
これは、<tt>fxp0</tt> インターフェイスから送出されるすべての TCP トラフィックを
通過させ、応答のトラフィックがファイアウォールを通過するのを許可しています。
状態の保持はすばらしい機能であり、状態テーブルの参照は、
パケットとフィルタルールを評価していくのに比べて劇的に高速ですので、
この機能を使用することで、ファイアウォールの性能を著しく改善します。

<p>
<tt>modulate state</tt> オプションは、それが TCP にのみ適用可能であることを除いて、
<tt>keep state</tt> と同様に機能します。
<tt>modulate state</tt> の場合、送出される接続の初期シーケンス番号
(ISN: Initial Sequence Number) がランダム化されます。これは、ISN を選択する際に、
単純に決定してしまうようなある種のオペレーティングシステムから開始した接続を
保護する上で役に立つ機能です。

<p>
送出される TCP、UDP および ICMP パケットの状態の保持、ならびに変調された TCP の ISN を指定するには、以下の例のようにします。
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any modulate state<br>
pass out on fxp0 proto { udp, icmp } from any to any keep state
</tt>
</blockquote>

<p>
状態を保持することのもうひとつの優位性は、関連する ICMP トラフィックが
ファイアウォールを通過することができるということです。たとえば、TCP 接続に
<tt>keep state</tt> が指定されている場合、ICMP 始点抑制メッセージが
この TCP 接続の到着を参照しますが、これは適切な状態エントリにマッチするので
ファイアウォールを通過することができます。

<p>
状態を持つ接続は、その接続が生成されたインターフェイス上に制限されるということは、
注意すべき重要事項です。このことは、PF を実行するルータやファイアウォールでは
特に重要なことであり、特に「デフォルトで拒否」のポリシーが上記の概要のとおり
実装されている場合にはなおさらです。もし、ファイアウォールが外部インターフェイス上の
すべての送出接続の状態を保持している場合、これらのパケットはやはり明示的に
内部インターフェイスにわたすべきでしょう。

<p>
<a href="nat.html"><tt>nat</tt></a>、
<a href="nat.html#binat"><tt>binat</tt></a>、および
<a href="rdr.html"><tt>rdr</tt></a> ルールは、マッチした接続が
フィルタのルールセットにわたされる限り、暗黙のうちにその接続の
状態を生成するということに注意してください。

<a name="udpstate"></a>
<h2>UDP の状態の保持</h2>
「UDP は状態を持たないプロトコルだから、UDP の状態を生成することはできない」
ということをときどき耳にすることがあるのではないでしょうか。確かに、UDP 接続の
セッションは、(明示的な通信の開始や終了などの) 状態ということについて、
いかなるコンセプトも持ち合わせてはいませんが、このことは PF の UDP セッションに
対する状態の生成能力には何ら影響はありません。「開始」や「終了」パケットのない
プロトコルの場合、PF はマッチしたパケットが通過してから、どれくらいの時間の
経過があったかということの追跡結果を単純に保持しています。もし、それが
タイムアウトすれば状態は消去されます。このタイムアウト値は、
<tt>pf.conf</tt> ファイルの <a href="options.html">オプション</a>
の部分で設定することができます。

<a name="tcpflags"></a>
<h2>TCP のフラグ</h2>
TCP パケットのフラグに基づくマッチングは、新しい接続を開始しようとする
TCP パケットのフィルタリングを行うためにかなり頻繁に使用されます。
TCP のフラグとその意味を以下にリストします。
<ul>
<li><b>F</b> : FIN  - 終了 (Finish): セッション終了
<li><b>S</b> : SYN  - 同期 (Synchronize): セッション開始要求を示す
<li><b>R</b> : RST  - リセット (Reset): 接続を切断する
<li><b>P</b> : PUSH - プッシュ (Push): パケットを直ちに送出する要求を示す
<li><b>A</b> : ACK  - 肯定応答 (Acknowledgement)
<li><b>U</b> : URG  - 緊急 (Urgent)
<li><b>E</b> : ECE  - 明示的輻輳通知のエコー (Explicit Congestion Notification Echo)
<li><b>W</b> : CWR  - 輻輳ウィンドウの減少通知 (Congestion Window Reduced)
</ul>

<p>
ルールの評価中に TCP のフラグを PF に検査させるためには、
<tt>flags</tt> キーワードを以下のシンタクスで使用します。
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i>
</tt>
</blockquote>

<p>
<tt><i>mask</i></tt> 部は指定されたフラグのみ検査することを PF に指示し、
<tt><i>check</i></tt> 部に指定されたフラグは、マッチしたパケットの
ヘッダ中のフラグが "on" に違いないことをチェックするよう指示します。
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
上記のルールは、SYN ならびに ACK フラグだけに注目しているので、
SYN フラグのセットされた TCP トラフィックを通過させます。また、
SYN と ECE フラグのセットされたパケットは、やはり上記のルールに
マッチしますが、SYN と ACK か ACK だけのパケットはマッチしません。

<p>
注: 以前のバージョンの OpenBSD では、
以下のシンタクスがサポートされていました。
<blockquote>
<tt>
. . . flags S
</tt>
</blockquote>

<p>
現在ではもはやこれは有効ではありません。マスクは<i>常に</i>指定されている必要があります。

<p>
状態エントリの生成の制御を行いやすくするために、フラグは
<tt>keep state</tt> ルールと関連してしばしば使用されます。
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
これは、SYN、ACK フラグのうちの SYN フラグだけがセットされた
すべての送出 TCP パケットのための状態の生成を許可します。

<p>
フラグの使用には注意が必要です。なぜ、何をしようとしているのか理解すべきですし、
それは間違っているなどの、人びとのアドバイスにも耳を傾けるべきです。ある人たちは、
「他のものは除いて SYN フラグがセットされたものだけ」の状態を生成するよう
示唆しています。そのようなルールは以下のような最後になっていたりします。
<pre>
     . . . flags S/FSRPAUEW          <i>あまり良くない考えです !!</i>
</pre>

<p>
その理屈は、TCP セッションの開始時点のみ状態を生成すべきであり、
セッションは他のフラグのない、SYN フラグで始まるべきである、
ということなのです。問題は、ECN フラグを使用し始めたいくつかのサイトで、
接続を試みてくる ECN の使用サイトはすべてこのようなルールによって
拒絶されるでしょう。より良い指針は以下のようなものです。
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
これは実戦的で安全なものではありますが、このトラフィックが
<a href="scrub.html">スクラブ (scrub) 済</a>のものであった場合には、
不要なチェックでもあります。スクラブの処理では、(SYN と  FIN や SYN と RST
のような) 正しくない TCP フラグの組み合わせを持つすべての着信パケットを
PF は廃棄します。これは、以下のような <tt>scrub</tt> による着信パケットの場合、
常に強く推奨されるものです。
<blockquote>
<tt>
scrub in on fxp0<br>
.<br>
.<br>
.<br>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state
</tt>
</blockquote>

<a name="synproxy"></a>
<h2>TCP SYN プロキシ</h2>
<p>
通常、クライアントがサーバに対して TCP 接続を行おうとする場合、
PF はこれら 2 点間の
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/connections.html"
>ハンドシェイク</a>パケットが到着するよう、通過させます。
しかし、PF には、このハンドシェイクのプロキシを行う能力があります。
このハンドシェイクのプロキシが行われると、PF 自身がクライアントと完全な
ハンドシェイクを行い、PF がサーバに対してハンドシェイクを行おうとします。
その上で、これら 2 点間のパケットを通過させます。
このプロセスの利点は、クライアントがハンドシェイクを完了させるまで、
サーバに対して一切のパケットを送信しないことです。
詐称されたクライアントの接続はハンドシェイクを完了することができないので、
これによって、サーバに影響を及ぼす、詐称された TCP SYN flood の脅威を
取り除くことができます。

<p>
TCP SYN プロキシは、以下の例のように、フィルタルール中で <tt>synproxy state</tt>
キーワードを使用することによって有効化することができます。

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
これで、web サーバへの接続は、PF により TCP のプロキシが行われるようになります。

<p>
<tt>synproxy state</tt> は、その動作原理から <tt>keep state</tt> および
<tt>modulate state</tt> の機能も含んでいます。

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>bridge(4)</a>
上で PF が動作している場合には SYN プロキシは動作しません。

<a name="antispoof"></a>
<h2>詐称されたパケットのブロック</h2>
アドレスの「詐称」とは、悪意のあるユーザが、自身の本当のアドレスを隠すためか、
あるいはネットワーク上の他のノードになりすますため、送信されるパケットの中の
発信元の IP アドレスを偽装することです。そのユーザが、いったんアドレスを詐称
できてしまうと、攻撃の際に本当のアドレスを曝すことなくネットワーク攻撃を仕掛けたり、
ある IP アドレスだけに限定しているネットワークサービスへのアクセス権を手に入れる
ための試みを行えたりします。

<p>
PF は、以下のような <tt>antispoof</tt> キーワードを使用した、
いくつかのアドレス詐称に対する防御機能を提供しています。

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>マッチしたパケットのログを
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.4"
>pflogd(8)</a> を通じて取得するよう指定します。

<dt><tt>quick</tt>
<dd>パケットがこのルールにマッチした場合には、それを「勝者」のルールと見なし、
ルールセットの評価をここまでで終了します。

<dt><tt><i>interface</i></tt>
<dd>詐称防御機能を有効にするネットワークインターフェイスを指定します。これはまた、
インターフェイスの<a href="macros.html#lists">リスト</a>でも構いません。

<dt><tt><i>af</i></tt>
<dd>詐称防御機能を有効にするアドレスファミリとして、IPv4 用の <tt>inet</tt>
か、IPv6 用の <tt>inet6</tt> のいずれかを指定します。
</dl>

<p>
例:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
ルールセットがロードされると、指定されている <tt>antispoof</tt> キーワードはすべて、
ふたつのフィルタルールに展開されます。インターフェイス <tt>fxp0</tt> が IP
アドレスとして 10.0.0.1 を持ち、サブネットマスクとして 255.255.255.0 (つまり /24)
を持つものとすると、上記の <tt>antispoof</tt> ルールは以下のように展開されます。

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
これらのルールにより、以下のようなふたつのことができるようになります。
<ul>
<li><tt>fxp0</tt> を経由<i>せずに</i> 10.0.0.0/24 のネットワークから来た
すべてのトラフィックをブロックします。これは、10.0.0.0/24 のネットワークは、
<tt>fxp0</tt> に接続されているので、このネットワークブロックの送信元アドレスを持つ
パケットが、他のネットワークインターフェイスに出現することはあり得ないからです。
<li><tt>fxp0</tt> の IP アドレスである 10.0.0.1 からのすべての着信トラフィックを
ブロックします。
これは、ホストマシンは、外部インターフェイス経由で、自分自身には決して
パケットを送信すべきではありませんので、このマシンに属する発信元アドレスを持つ
すべての着信パケットは、悪意のあるものと見なすことができるからなのです。
</ul>

<p>
<b>注</b>: <tt>antispoof</tt> ルールを展開した後のフィルタルールは、
ループバックインターフェイスからローカルアドレスに送信しようとしたパケットも
ブロックします。これらのアドレスは、以下の例のように、明示的にわたすべきです。
<blockquote>
<tt>
pass in quick on lo0 all<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
<tt>antispoof</tt> の使用法は、IP アドレスが割り当てられているインターフェイスに限定
すべきものです。IP アドレスが割り当てられていないインターフェイスに <tt>antispoof</tt>
を使用することは、以下のようなフィルタルールに展開される結果となってしまいます。
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
これらのルールには、<i>すべての</i>インターフェイスで、<i>すべての</i>
内向きトラフィックをブロックしてしまう危険性があります。

<a name="ipopts"></a>
<h2>IP オプション</h2>
デフォルトでは、PF は IP オプションのセットされたパケットをブロックします。これによって、
nmap のような「OS の指紋を取る」ユーティリティの仕事をより困難なものにすることができます。
もし、マルチキャストや IGMP のようなパケットを通過させる必要のあるアプリケーションを
使用する場合には、以下のように <tt>allow-opts</tt> ディレクティブを使用することができます。
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>フィルタリングルールセットの例</h2>
以下はフィルタリングルールセットの一例です。PF を実行するマシンは、
小さな内部ネットワークとインターネットとの間のファイアウォールとして
動作しています。フィルタルールは以下のものだけであり、
<a href="queueing.html">queueing</a>、 
<a href="nat.html"><tt>nat</tt></a>、
<a href="rdr.html"><tt>rdr</tt></a>
などは、この例の対象外としています。
<br>
<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# scrub incoming packets
scrub in all

# setup a default deny policy
block in  all
block out all

# pass traffic on the loopback interface in either direction
pass quick on lo0 all

# activate spoofing protection for the internal interface.
antispoof quick for $int_if inet

# only allow ssh connections from the local network if it's from the
# trusted computer, 192.168.0.15. use "block return" so that a TCP RST is
# sent to close blocked connections right away. use "quick" so that this
# rule is not overridden by the "pass" rules below.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh flags S/SA

# pass all traffic to and from the local network
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# pass tcp, udp, and icmp out on the external (Internet) interface. 
# keep state on udp and icmp and modulate state on tcp.
pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state

# allow ssh connections in on the external interface as long as they're
# NOT destined for the firewall (i.e., they're destined for a machine on
# the local network). log the initial packet so that we can later tell
# who is trying to connect. use the tcp syn proxy to proxy the connection.
pass in log on $ext_if proto tcp from any to { !$ext_if, !$int_if } \
   port ssh flags S/SA synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">前に戻る: テーブル</a>]
[<a href="index.html">目次</a>]
[<a href="nat.html">次に進む: ネットワークアドレス変換 (NAT)</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: filter.html,v 1.17 ]
<br>
$Translation: filter.html,v 1.16 2004/02/01 12:35:38 toshi Exp $
<br>
$OpenBSD: filter.html,v 1.16 2004/05/09 09:58:22 saad Exp $
</small>

</body>
</html> 
