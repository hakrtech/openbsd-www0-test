<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Traffic Redirection</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-2022-JP">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 2002-2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="nat.html">前に戻る: ネットワークアドレス変換 (NAT)</a>]
[<a href="index.html">目次</a>]
[<a href="filter.html">次に進む: パケットフィルタリング</a>]

<h1><font color="#e00000">PF: リダイレクション (<tt>rdr</tt>)</font></h1>

<hr>

<h3>目次</h3>
<ul>
<li><a href="#intro">はじめに</a>
<li><a href="#filter">リダイレクションとパケットフィルタリング</a>
<li><a href="#security">セキュリティの意味</a>
<li><a href="#reflect">リダイレクションと反射 (リフレクション)</a>
	<ul>
	<li><a href="#splitdns">水平分割 DNS</a>
	<li><a href="#sepnet">サーバの分離された
	ローカルネットワークへの移動</a>
	<li><a href="#tcpproxy">TCP プロキシ</a>
	<li><a href="#rdrnat">RDR および NAT の組み合わせ</a>
	</ul>
</ul>

<hr>

<a name="intro"></a>
<h2>はじめに</h2>
もし、事務所で NAT を実行しているのなら、すべてのマシンがインターネットへの
接続を持つことができているはずです。外部からアクセスさせる必要のある、NAT
ゲートウェイの背後のマシンには何があるのでしょうか ?  ここでリダイレクション
の登場です。リダイレクションは着信トラフィックを NAT ゲートウェイの背後の
マシンへと転送します。

<p>
ここで例を見てみましょう。
<blockquote>
<tt>
rdr on tl0 proto tcp from any to any port 80 -&gt; 192.168.1.20
</tt>
</blockquote>

<p>
この行は、ポート 80 (web サーバ) へのトラフィックをネットワークの内側の 192.168.1.20
のマシンにリダイレクトしています。ですので、192.168.1.20 はゲートウェイの背後で
ネットワークの内部であるにも関わらず、このマシンに対して外部からアクセス可能です。

<p>
上記 <tt>rdr</tt> 行の <tt>from any to any</tt> の部分は実に役に立ちます。
たとえば、もし、どこかのアドレスかサブネットから、ポート 80 の web サーバに
アクセスをさせなければならないことがわかっている場合には、以下のようにして
それらを限定することができます。
<blockquote>
<tt>
rdr on tl0 proto tcp from 27.146.49.0/24 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20
</tt>
</blockquote>

<p>
これは指定されたサブネットだけをリダイレクトします。これは、異なるアクセス元の
ホストから、ゲートウェイの背後の異なるマシンへのリダイレクトが可能であることを
意味します。これは実に役に立ちます。たとえば、リモートサイトのユーザに、彼ら自身の
デスクトップコンピュータへアクセスさせるのに、彼らのアクセス元の IP アドレスさえ
わかっていれば、以下のように、ゲートウェイの IP アドレスと同じポート番号を使用して
アクセスさせることもできるのです。
<blockquote>
<tt>
rdr on tl0 proto tcp from 27.146.49.14 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20<br>
rdr on tl0 proto tcp from 16.114.4.89 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.22<br>
rdr on tl0 proto tcp from 24.2.74.178 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.23
</tt>
</blockquote>

<a name="filter"></a>
<h2>リダイレクションとパケットフィルタリング</h2>
<tt>rdr</tt> ルールにマッチするパケットは、なおもフィルタリングエンジンにわたすべきであり、
また、このパケットは、定義されているフィルタルールに基づいて、ブロックか通過が決定される
ということを知っておいてください。また、<tt>rdr</tt> ルールにマッチするパケットの送信先 IP
アドレス、あるいは/および送信先ポートは、<tt>rdr</tt> ルールに指定されているリダイレクション
アドレス/ポートにマッチさせるため、変更されるということも知っておいてください。
このシナリオで考えると、以下のようになります。
<ul>
<li>192.0.2.1 - インターネット上のホスト
<li>24.65.1.13 - OpenBSD ルータの外部 IP アドレス
<li>192.168.1.5 - web サーバの内部 IP アドレス
</ul>

<p>
リダイレクションルールは以下のとおりです。
<blockquote>
<tt>
rdr on tl0 proto tcp from 192.0.2.1 to 24.65.1.13 port 80 \<br>
&nbsp;&nbsp;&nbsp;-&gt; 192.168.1.5 8000
</tt>
</blockquote>

<p>
ここで、<tt>rdr</tt> の処理前のパケットは以下のとおりです。
<ul>
<li>送信元アドレス: 192.0.2.1
<li>送信元ポート: 4028 (オペレーティングシステムが任意に選択)
<li>送信先アドレス: 24.65.1.13
<li>送信先ポート: 80
</ul>

<p>
次に、<tt>rdr</tt> の処理後のパケットは以下のようになります。
<ul>
<li>送信元アドレス: 192.0.2.1
<li>送信元ポート: 4028
<li>送信先アドレス: 192.168.1.5
<li>送信先ポート: 8000
</ul>

<p>
フィルタリングエンジンは、<tt>rdr</tt> ルールの処理後の
IP パケットを見ることになります。

<a name="security"></a>
<h2>セキュリティの意味</h2>
リダイレクションはセキュリティと関係があります。ファイアウォールのセキュリティホールを
突くことで、内部へのトラフィックを許可してしまいますし、また、内部のマシンの不正利用のために
保護されたネットワークを潜在的にアクセス可能にしてしまいます。たとえば、もし、
内部の web サーバへのトラフィックが転送されてしまうと、web サーバのデーモンに脆弱性が
発見されてしまうかも知れませんし、CGI スクリプトを web サーバ上で実行されてしまうかも
知れません。このようにこのマシンは、インターネットの侵入者から不正利用されてしまうかも
知れないのです。そしてここから、侵入者は内部ネットワークへの裏口を作成してしまいますし、
このことはファイアウォールを通過するための正当な許可を得ることでもあるのです。

<p>
外部からアクセスされるシステムを、分離されたネットワーク上に厳重に制限することで、
このような危険性を最小化することができます。このようなネットワークは、しばしば
非武装地帯 (DMZ) やプライベートサービスネットワーク (PSN) と呼ばれます。この方法なら、
DMZ/PSM とやり取りされるトラフィックを注意深くフィルタリングすることにより、
もし web サーバが不正侵入された場合でも、その影響を DMZ/PSM
ネットワーク内に限定することができます。

<a name="reflect"></a>
<h2>リダイレクションと反射 (リフレクション)</h2>
しばしば、リダイレクションルールは、内部ネットワークや LAN などの
プライベートアドレスを持つローカルサーバへのインターネットからの
着信接続を転送するため、以下のように使用されることがあります。
<blockquote>
<tt>
server = 192.168.1.40<br>
<br>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server \<br>
&nbsp;&nbsp;&nbsp;port 80
</tt>
</blockquote>

<p>
しかし、リダイレクションルールが LAN 上のクライアントから試験された場合は
正しく動作しません。その理由は、リダイレクションルールが、指定された
インターフェイス (例の中の外部インターフェイス、$ext_if) を通過する
パケットに対してのみ適用されるものだからです。つまり、LAN 上のホストから、
ファイアウォールの外部アドレスに接続する場合、外部インターフェイスに対して
パケットが実際にわたされることを意味しないからです。ファイアウォール上の
TCP/IP プロトコルスタックは、着信パケットの送信先アドレスを、自身のアドレスや
エイリアスと比較し、そして自身への接続が可及的速やかに内部インターフェイスに
わたさなければならないものであることを検出します。そのようなパケットは、物理的に
外部インターフェイスにわたされるわけではありませんし、スタックはこのような転送を
決してシミュレートすることはありません。ですので、PF は外部インターフェイス上の
これらのパケットを決して見ることはありませんし、外部インターフェイス上に
指定されているリダイレクションルールが適用されることもありません。

<p>
内部インターフェイス用にふたつ目のリダイレクションルールを追加することは、
何ら意図した効果を持ちません。ローカルのクライアントがファイアウォール上の
外部アドレスに接続する場合、TCP のハンドシェイクの最初のパケットは、
ファイアウォールを通過して内部インターフェイスに届けられます。
リダイレクションルールが適用され、送信先アドレスが内部サーバのそれと置換
されます。パケットは、内部インターフェイスを通過して内部に転送され、そして
内部サーバに届けられますが、このパケットの送信元アドレスは変換されているわけでは
ありませんので、ローカルのクライアントのアドレスを保持し続けていることになり、
サーバはその応答を直接クライアントに対して返送してしまいます。その結果として、
ファイアウォールは決してその応答パケットを見ることはなく、適正に逆変換を行う
機会も奪われてしまうことになります。一方で、クライアントは、決して期待していない
送信元からの応答を受け取ることとなるので、それを廃棄してしまいます。このように
TCP のハンドシェイクが失敗してしまいますので、接続が確立されることはないのです。

<p>
しかし、しばしば、LAN 上のクライアントが外部のクライアントとして
同じ内部のサーバに透過的に接続したい場合があると思います。
この問題に対しては、以下のようにいくつかの解決策があります。

<a name="splitdns"></a>
<h3>水平分割 DNS</h3>

<p>
ローカルのクライアントは、その名前解決中に、内部サーバのアドレスを受け取らなければ
ならないので、ローカルのホストからの問い合わせに対する回答は、外部からの問い合わせに
対するものと異なるものを返すよう、DNS サーバを設定することが可能です。ローカルの
クライアントはローカルのサーバに直接接続するため、ファイアウォールが関与することは
ありません。これによって、パケットはファイアウォールを通して送信される必要がないので、
ローカルのトラフィックを軽減することができます。

<a name="sepnet"></a>
<h3>サーバの分離されたローカルネットワークへの移動</h3>

<p>
ファイアウォールに付加的なネットワークインターフェイスを追加し、ローカルのサーバを
クライアントのネットワークから専用のネットワーク (DMZ) に移動することで、ローカルの
クライアントからの接続を、外部接続のリダイレクションと同じ方法でリダイレクトする
ことができるようになります。この分離されたネットワークを使用することは、サーバを
残りのローカルのホストから隔離することにより、セキュリティを改善することができるなど、
いくつかの優位性を持ちます。(私たちの例では、インターネットからアクセス可能な)
サーバは、やはり不正侵入される危険性がありますが、すべての接続はファイアウォールを
通過しなければならないので、このサーバが他のローカルのホストに直接アクセスすることは
できません。

<a name="tcpproxy"></a>
<h3>TCP プロキシ</h3>

<p>
転送すべきポートをリスンし、あるいはリスン中のポートにリダイレクトされる
内部インターフェイス上の接続を得るための、一般的な TCP のプロキシを
ファイアウォール上に設定することができます。ローカルのクライアントが
ファイアウォールに接続する際、プロキシが接続を受け付け、内部サーバに対して
ふたつ目の接続を確立します。そして、これらのふたつの接続の間で、データの
転送を行います。

<p>
単純なプロキシは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8&amp;manpath=OpenBSD+3.3"
>inetd(8)</a> と
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1&amp;manpath=OpenBSD+3.3"
>nc(1)</a> とを使用して生成することができます。以下の <tt>/etc/inetd.conf</tt> のエントリは、
ループバックアドレス (127.0.0.1) のポート 5000 に結合した、リスンするためのソケットを生成します。
この接続は、サーバ 192.168.1.10 のポート 80 に転送されます。
<blockquote>
<tt>
127.0.0.1:5000 stream tcp nowait nobody /usr/bin/nc nc -w \<br>
&nbsp;&nbsp;&nbsp;20 192.168.1.10 80
</tt>
</blockquote>

<p>
以下のリダイレクションルールは、内部インターフェイスのポート 80 を
プロキシに転送します。
<blockquote>
<tt>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;127.0.0.1 port 5000
</tt>
</blockquote>

<a name="rdrnat"></a>
<h3>RDR と NAT の組み合わせ</h3>

<p>
内部インターフェイス上の付加的な NAT ルールによって、上記の
不足している送信元アドレスの変換が行われるようになります。
<blockquote>
<tt>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;$server
<br>
no nat on $int_if proto tcp from $int_if to $int_net<br>
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;$int_if
</tt>
</blockquote>

<p>
これは、クライアントからの最初のパケットが内部ネットワークを通して転送される際に、
クライアントの送信元アドレスがファイアウォールの内部アドレスで置換されるという
再変換の原因となってしまうでしょう。内部サーバがファイアウォールに応答を返しますが、
ファイアウォールはローカルのクライアントに転送する際に、NAT と RDR の両方の変換の
逆が行われることになります。この構図は、これがそれぞれの反射された接続に対応した、
分離されたふたつの状態を生成してしまいますので、やや複雑なものとなります。
たとえば、外部のホストが (他のリダイレクションを経由して) 開始した接続や
ファイアウォール自身などの、NAT ルールが他のトラフィックに対して
適用されてしまわないよう、注意しなければなりません。
上記の <tt>rdr</tt> ルールは、TCP/IP プロトコルスタックが、
内部ネットワークの内側の送信先アドレスを持って内部インターフェイスに到着した
パケットを見るようになります。
(クライアントに相手が直接到達可能であることを通知し、反射を行わせないようにするための)
ICMP redirect メッセージをスタックが発行するのを防止するため、
以下のようにしてゲートウェイのリダイレクションを無効化してください。
<blockquote>
<tt>
# sysctl -w net.inet.ip.redirect=0<br>
# sysctl -w net.inet6.ip6.redirect=0 <i>(if using IPv6)</i>
</tt>
</blockquote>

<p>
しかし、一般的には、その前に言及した解決法を、この方法の代わりに使用すべきでしょう。

<p>
[<a href="nat.html">前に戻る: ネットワークアドレス変換 (NAT)</a>]
[<a href="index.html">目次</a>]
[<a href="filter.html">次に進む: パケットフィルタリング</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: rdr.html,v 1.9 ]
<br>
$Translation: rdr.html,v 1.6 2003/09/24 04:31:39 toshi Exp $
<br>
$OpenBSD: rdr.html,v 1.6 2003/09/26 13:21:47 horacio Exp $
</small>

</body>
</html> 
