<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF : Filtrage de Paquets</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../fr/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Section précédente&nbsp;: Tables</a>]
[<a href="index.html">Index</a>]
[<a href="nat.html">Section suivante&nbsp;: Traduction des Adresses IP (&quot;NAT&quot;)</a>]

<h1><font color="#e00000">PF&nbsp;: Le Filtrage de Paquets</font></h1>

<hr>

<h3>Table des Matières</h3>

<ul>
<li><a href="#intro">Introduction</a>
<li><a href="#syntax">Syntaxe</a>
<li><a href="#defdeny">Blocage par défaut</a>
<li><a href="#pass">Laisser passer le trafic</a>
<li><a href="#quick">L'option <tt>quick</tt></a>
<li><a href="#state">Conserver l'état</a>
<li><a href="#udpstate">Conserver l'état avec UDP</a>
<li><a href="#stateopts">Options de Suivis Stateful</a>
<li><a href="#tcpflags">Les drapeaux TCP</a>
<li><a href="#synproxy">Service mandataire TCP SYN</a>
<li><a href="#antispoof">Bloquer les paquets usurpés</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Reconnaissance passive d'OS par leurs empreintes</a>
<li><a href="#ipopts">Les options IP</a>
<li><a href="#example">Un exemple de règles de filtrage</a>
</ul>

<hr>

<a name="intro"></a>

<h2>Introduction</h2>
Le filtrage de paquets à l'aide de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+5.3">pf(4)</a>
consiste à autoriser ou bloquer le trafic réseau en fonction des
propriétés des protocoles des couches 3
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) et 4 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a> et 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>).
Les adresses et ports source et destination ainsi que les protocoles
utilisés sont des critères fréquemment employés.

<p>
Les règles de filtrage énumèrent les critères auxquels doivent se
conformer les paquets et spécifient les actions qui y sont associées&nbsp;:
bloquer ou laisser passer. Ces règles sont évaluées de façon
séquentielle de la première à la dernière (du haut vers le bas dans les
fichiers de règles utilisés).

Sauf utilisation du mot-clé <tt>quick</tt> dans l'une d'entre elles,
chaque paquet est évalué à l'aide de <i>toutes</i> les règles avant
qu'une décision finale ne soit prise. 

L'action (block ou pass) associée à la dernière règle dont les critères
se rapportent au paquet traité est appliquée. La première règle est un
<tt>tout laisser passer</tt> implicite de sorte que si aucune règle
n'est applicable à un paquet, celui-ci est accepté (<tt>pass</tt>).

<a name="syntax"></a>
<h2>Syntaxe</h2>

L'écriture des règles obéit à la syntaxe <i>très simplifiée</i> suivante
:
<blockquote>
<tt>
<i>action</i> [<i>direction</i>] [log] [quick] [on <i>interface</i>] 
[<i>af</i>] [proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to 
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>Ce mot-clé indique le type d'action associé à tout paquet
correspondant aux critères contenus dans la règle. Les deux valeurs
possibles sont <tt>pass</tt> et <tt>block</tt>. <tt>pass</tt> signifie
que le paquet sera transféré au noyau pour être traité. Le blocage du
paquet (<tt>block</tt>) sera fonction de la politique définie par les
options
<a href="options.html#block-policy"><tt>block-policy</tt></a>. L'action
associée par défaut peut être modifiée en spécifiant <tt>block drop</tt>
ou <tt>block return</tt>.

<dt><tt><i>direction</i></tt>
<dd>Ce mot-clé spécifie le sens du trafic vu depuis l'interface réseau
: celui-ci peut être entrant (<tt>in</tt>) ou sortant (<tt>out</tt>).

<dt><tt>log</tt>
<dd>La présence de ce mot-clé dans une règle déclenche la
journalisation des paquets correspondants à la règle grâce à
l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+5.3">pflogd(8)</a>.
Si la règle crée un état, seul le paquet correspondant à l'ouverture de
la session est conservé. Pour conserver tous les paquets d'une session,
il faut utiliser le mot-clé <tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Si le mot-clé <tt>quick</tt> est utilisé dans une règle, celle-ci
est considérée comme étant la dernière à prendre en compte et
l'<tt><i>action</i></tt> spécifiée est prise.

<dt><tt><i>interface</i></tt>
<dd>Le nom ou le groupe de l'interface sur laquelle le paquet
transite. Les interfaces peuvent être ajoutées à des groupes arbitraires
en utilisant la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
Plusieurs groupes sont également automatiquement créés par le noyau&nbsp;:
<ul>
<li>Le groupe <tt>egress</tt>, qui contient la/les interface(s)
relative(s) à la route par défaut.
<li>Les groupes par famille pour les interfaces clonables.
Par exemple&nbsp;: <tt>ppp</tt> ou <tt>carp</tt>.
</ul>
Ceci causerait la correspondance de la règle pour tout paquet traversant
respectivement une interface <tt>ppp</tt> ou <tt>carp</tt>.

<dt><tt><i>af</i></tt>
<dd>Il est possible de spécifier la famille d'adresses IP à laquelle
appliquer une règle à l'aide de ce mot-clé. Les deux valeurs possibles
sont <tt>inet</tt> pour les adresses IPv4 et <tt>inet6</tt> pour
IPv6. PF peut généralement déterminer à quelle famille appartient un
paquet à partir de ses adresses source et destination.

<dt><tt><i>protocol</i></tt>
<dd>Ce mot-clé identifie les protocoles de couche 4 utilisés. Il peut
prendre les valeurs suivantes&nbsp;:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>tout protocole spécifié dans le fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
><tt>/etc/protocols</tt></a>
<li>le numéro d'un protocole compris entre 0 et 255
<li>un ensemble de protocoles passé dans une
        <a href="macros.html#lists">liste</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 

<dd>Ces mots-clefs identifient respectivement les adresses source et
destination du paquet telles que contenues dans son en-tête IP. Ces
adresses peuvent être spécifiées&nbsp;:
<ul>
<li>sous la forme d'adresse IPv4 ou IPv6.
<li>sous la forme d'un bloc d'adresses
<a href="http://public.swbell.net/dedicated/cidr.html">CIDR</a>.
<li>sous la forme d'un domaine. Ce dernier fera l'objet d'une résolution
    DNS lors du chargement des règles par PF. La règle s'appliquera
    alors à toutes les adresses du domaine.
<li>par l'intermédiaire du nom d'une interface réseau. Toute adresse IP
    affectée à cette interface sera valide pour la règle.
<li>par l'intermédiaire du nom d'une interface réseau suivi d'un <tt>/<i>netmask
    </i></tt> (par exemple <tt>/24</tt>). Toutes les adresses IP
    correspondant au bloc CIDR formé par l'adresse IP de l'interface et le
    masque de sous réseau seront valides pour cette règle.
<li>sous la forme du nom d'une interface réseau mis entre parenthèses
    <tt>( )</tt>. Cette mise en forme indique à PF qu'il doit mettre ses
    règles à jour en cas de changement de l'adresse IP affectée à
    l'interface en question. Cette technique est très utile dans le cas
    de liaisons PPP ou d'utilisation du protocole DHCP pour
    l'attribution d'adresses IP. Elle évite d'avoir à recharger les
    règles à chaque nouvelle affectation.
<li>grâce au nom d'une interface suivi d'un des paramètres suivants&nbsp;:
  <ul>
  <li><tt>:network</tt> - identifie un bloc CIDR (par exemple&nbsp;:
      192.168.0.0/24)
  <li><tt>:broadcast</tt> - identifie une adresse de multi-diffusion
      (par exemple&nbsp;: 192.168.0.255)
  <li><tt>:peer</tt> - identifie l'adresse d'un pair sur un lien point à
      point.
  </ul>
  <dl>
  <dd>De plus, le paramètre <tt>:0</tt> peut être ajouté aussi bien au
      nom d'une interface qu'à chacun des paramètres présentés
      ci-dessus. PF ne prend alors pas en compte les éventuels alias
      d'adresses IP affectés à l'interface. Ces paramètres peuvent
      aussi être utilisés dans le cas d'une interface entre parenthèses.
      Par exemple: <tt>fxp0:network:0</tt>
  </dl>
<li>à l'aide d'une <a href="tables.html">table</a>.
<li>Le mot-clé <tt>urpf-failed</tt> peut être utilisé au niveau de
    l'adresse source pour indiquer si elle doit ou non subir une <a
    href="#urpf">vérification uRPF</a>.
<li>sous toutes les formes décrites ci-dessus précédées du paramètre
    d'inversion <tt>!</tt> (&quot;not&quot;).
<li>à l'aide d'une <a href="macros.html#lists">liste</a> d'adresses.
<li>grâce au mot-clé <tt>any</tt> qui identifie n'importe quelle
    adresse.
<li>grâce au mot-clé <tt>all</tt> qui est un raccourci pour
    l'expression <tt>from any to any</tt> (n'importe quelle source vers
    n'importe quelle destination).
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>Ces mots-clefs identifient respectivement les ports source et
    destination qui apparaissent dans les en-têtes des protocoles de
    couche 4. Ces ports peuvent être spécifiés&nbsp;:
<ul>
<li>sous forme numérique par un nombre compris entre 1 et 65535.
<li>par le nom d'un service tel qu'identifié dans le fichier 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
><tt>/etc/services</tt></a>.
<li>sous la forme d'une <a href="macros.html#lists">liste</a>.
<li>sous la forme d'un intervalle de ports construit à l'aide des
    opérateurs suivants&nbsp;:
        <ul>
        <li><tt>!=</tt> (différent)
        <li><tt>&lt;</tt> (inférieur à)
        <li><tt>&gt;</tt> (supérieur à)
        <li><tt>&lt;=</tt> (inférieur ou égal à)
        <li><tt>&gt;=</tt> (supérieur ou égal à)
        <li><tt>&gt;&lt;</tt> (intervalle)
        <li><tt>&lt;&gt;</tt> (intervalle inverse)
        <dl>
        <dd>Les deux derniers opérateurs demandent deux arguments pour
            former un intervalle qui n'inclut pas ces arguments.
        </dl>
        <li><tt>:</tt> (intervalle complet)
        <dl>
        <dd>L'opérateur d'intervalle complet est également un opérateur binaire
        incluant les arguments dans l'intervalle.
        </dl>
        </ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Spécifie les drapeaux qui doivent être activés dans l'en-tête TCP lors de
    l'utilisation de <tt>proto tcp</tt>. Cette valeur est spécifiée ainsi&nbsp;:
    <tt>flags <i>check</i>/<i>mask</i></tt>. Par exemple&nbsp;: <tt>flags S/SA</tt>.
    Dans ce cas, PF teste uniquement la valeur des drapeaux S et A (SYN et ACK) 
    pour savoir si le drapeau SYN est positionné (et est appliqué à toutes
    les règles TCP par défaut).
    <tt>flags any</tt> indique à PF de ne pas vérifier les drapeaux.

<dt><tt><i>state</i></tt>
<dd>Ce mot-clé indique dans quel état doit être le paquet pour
    satisfaire à une règle.
<ul>
<li><tt>no state</tt> - fonctionne avec TCP, UDP et ICMP.
    PF ne suivra pas cette connexion avec état.
    Pour les connexions TCP, <tt>flags any</tt> est aussi généralement
    nécessaire.
<li><tt>keep state</tt> - s'applique aux protocoles TCP, UDP et ICMP.
    Cette option est appliquée par défaut à toutes les règles de filtrage.
<li><tt>modulate state</tt> - ne s'applique qu'au protocole TCP. PF
    renforcera le caractère aléatoire des numéros de séquence initiaux
    (ISN) générés pour ces paquets.
<li><tt>synproxy state</tt> - PF agit comme mandataire pour les
    connexions TCP entrantes. Cela renforce la protection contre les
    attaques par inondation de paquets SYN en provenance d'adresses
    usurpées. Cette option active implicitement les fonctionnalités
    <tt>keep state</tt> et <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Blocage par défaut</h2>
Il est recommandé d'adopter une approche de blocage par défaut lors de
la configuration d'un pare-feu. Cela signifie que <i>tout</i> est
interdit et que l'on autorise le trafic au cas par cas. Cette approche
est assimilable à l'application d'un principe de précaution et simplifie
l'écriture des règles.

<p>
Cette politique de blocage par défaut repose sur deux règles&nbsp;:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Cela suffit à interdire tout trafic dans un sens comme dans l'autre et
ce sur toutes les interfaces de la machine.

<a name="pass"></a>
<h2>Laisser passer le trafic</h2>

Une fois notre politique restrictive mise en place, il faut spécifier
quelles sont les connexions autorisées. C'est là qu'entrent en jeu les
critères décrits précédemment&nbsp;: adresse et port source et destination,
protocole, etc... Chaque fois qu'un paquet est autorisé à franchir les
murs du pare-feu, les règles correspondantes devront être les plus
restrictives possibles&nbsp;: il s'agit de n'autoriser que le trafic voulu et
lui seul.

<p>
Quelques exemples:
<blockquote>
<tt>
# Autoriser le trafic entrant sur l'interface dc0<br>
# en provenance du réseau local 192.168.0.0/24,<br>
# à destination de la machine dont l'adresse IP est 192.168.0.1.<br>
# Dans le même temps, autoriser le trafic sortant par l'interface dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Autoriser le trafic TCP entrant sur l'interface fxp0<br>
# à destination d'un serveur HTTP.<br>
# Le nom de l'interface - fxp0 - est utilisé comme adresse de destination<br>
# pour les paquets autorisés.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>L'option <tt>quick</tt></h2>
Comme nous l'avons vu, chaque paquet est testé au regard de toutes les
règles de filtrage, de la première à la dernière. Par défaut, un paquet
est marqué à chaque test. Le résultat final peut ainsi changer d'une
règle à l'autre jusqu'à ce que toutes aient été parcourues. Rappelons
que c'est <b>la dernière règle à laquelle correspond un paquet qui
l'emporte</b> sur les autres. Il y a cependant une exception&nbsp;: si l'option
<tt>quick</tt> est présente dans une règle et qu'un paquet correspond
aux critères de cette règle, il n'y a plus de tests&nbsp;: la règle en
question est alors considérée par PF comme étant la dernière. Les
exemples suivants illustrent ce cas de figure&nbsp;:

<p>
Mauvais&nbsp;:
<blockquote>
<tt>
block in on fxp0 proto tcp port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
La ligne <tt>block</tt> n'aura aucun effet. Les paquets seront bien
évalués suivant ses critères, mais la ligne suivante annulera tout effet
de cette première règle.

<p>
Mieux&nbsp;:
<blockquote>
<tt>
block in quick on fxp0 proto tcp port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
A première vue c'est la même chose. Si la ligne <tt>block</tt> correspond,
l'option <tt>quick</tt> provoque l'arrêt des tests pour chaque paquet qui
correspond aux critères de la première règle. Les paquets qui n'y
satisfont pas seront quant à eux testés au regard des critères de la
règle suivante.

<a name="state"></a>
<h2>Conserver l'état</h2>

Une des fonctionnalités les plus importantes de PF est sa capacité à
conserver l'état des connexions. PF est capable d'évaluer un paquet non
plus unitairement mais dans le contexte de la connexion à laquelle il
appartient. PF utilise pour cela une table d'état grâce à laquelle PF
peut rapidement déterminer si un paquet fait partie d'une connexion déjà
établie et autorisée. Si tel est le cas, le paquet est transféré sans
test complémentaire.

<p>
Conserver l'état des connexions a pour avantage de simplifier les règles
de filtrage et d'améliorer les performances. PF évalue les paquets
<i>quel que soit leur sens</i>&nbsp;: il n'est alors plus nécessaire d'écrire
les règles pour les paquets des flux retour. PF consacre ainsi beaucoup
moins de temps à inspecter les paquets.

<p>
Quand une règle crée un état, le premier paquet qui déclenche
l'activation de celle-ci provoque la création d'un enregistrement dans
la table d'état des connexions en cours. Par la suite, non seulement les
paquets allant de l'expéditeur au destinataire sont rattachés à cette
table et donc autorisés à passer, mais également les paquets qui
appartiennent aux réponses du destinataire.

<p>
Toutes les règles <i>pass</i> créent de manière automatique une entrée
dans la table d'état dès qu'un paquet les active.
Cela peut être désactivé de manière explicite en utilisant l'option
<tt>no state</tt>.

<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Cette règle autorise les connexions TCP sortantes sur l'interface
<tt>fxp0</tt> mais aussi les paquets retour. L'option keep state permet donc
d'augmenter les performances du pare-feu car la recherche dans la table d'état
est beaucoup plus rapide que l'opération consistant à évaluer un paquet au
regard de toutes les règles de filtrage.

<p>
L'option <tt>modulate state</tt> fonctionne de la même façon que
l'option <tt>keep state</tt> à ceci près qu'elle ne s'applique qu'aux
paquets TCP sortants. L'option <tt>modulate state</tt> renforce le
caractère aléatoire de leurs numéros de séquence initiaux (ISN). Cette
option permet de renforcer la sécurité de certains systèmes
d'exploitation ne sachant pas générer d'ISN suffisamment aléatoires. Pour
simplifier les règles, l'option <tt>modulate state</tt> peut être utilisée 
pour les autres protocoles que TCP, dans les autres cas elle est traitée
comme <tt>keep state</tt>.

<p>
Pour conserver l'état des connexions TCP, UDP et ICMP tout en renforçant
la sécurité des ISN&nbsp;:
<blockquote>
<tt>

pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Un des avantages de conserver l'état des connexions tient à ce que les
messages ICMP relatifs à celles-ci seront traités comme faisant partie
de la connexion. Si des messages ICMP sont émis par une machine pour
signaler une congestion par exemple, et que le suivi d'état est utilisé,
les messages seront pris en compte et acceptés par le pare-feu. Sans
cela, ils auraient été bloqués ou ignorés.

<p>
La portée d'une entrée dans la table d'état dépend des options
<a href="options.html#state-policy"><tt>state-policy</tt></a> d'une manière
globale ou bien des options <tt>if-bound</tt>, <tt>group-bound</tt> et
<tt>floating-state</tt>. Les valeurs appliquées règle par règle ont la même
signification que lorsqu'elles sont utilisées avec l'option
<tt>state-policy</tt>. Par exemple&nbsp;:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Selon cette règle, les paquets ne trouveront une correspondance dans la
table d'état que s'ils transitent par l'interface <tt>fxp0</tt>.



<a name="udpstate"></a>
<h2>Conserver l'état des connexions UDP</h2>

On entend souvent dire qu'il est impossible d'utiliser la table d'état
avec UDP car c'est un protocole sans état. S'il est vrai qu'une
connexion UDP n'utilise pas stricto sensu le concept d'état tel que le
fait une connexion TCP (à savoir une ouverture et une terminaison
explicites de la connexion), cela n'a aucune conséquence sur la capacité
qu'a PF de créer et gérer des états pour les connexions UDP. Pour ce
type de protocole sans début/fin de connexion explicite, PF
conserve simplement une trace de la durée d'une session. S'il s'écoule
un certain laps de temps sans échange de paquets entre les deux parties,
l'entrée associée à la session dans la table d'état est supprimée.
Ce laps de temps peut être configuré dans la section
<a href="options.html">options</a> du fichier <tt>pf.conf</tt>.

<a name="stateopts"></a>
<h2>Options de Suivi Stateful</h2>
Les règles de filtrage qui créent une entrée dans la table d'états
peuvent spécifier plusieurs options afin de contrôler le comportement de
ces créations d'états.
Les options suivantes sont disponibles&nbsp;:

<dl>
<dt><tt>max <i>number</i></tt>
<dd>Limite le nombre maximum d'entrées d'états que la règle peut créer à
<i>number</i>.
Si le maximum est atteint, les paquets qui devraient normalement créer
un état sont rejetés jusqu'à ce que le nombre d'états existants soit en
dessous de la limite.

<dt><tt>no state</tt>
<dd>Empêche la règle de créer automatiquement une entrée dans la table
d'état.

<dt><tt>source-track</tt>
<dd>Cette option active le suivi du nombre d'états créés par adresse IP
source.
Cette option a deux formats&nbsp;:
       <ul>
       <li><tt>source-track rule</tt> - Le nombre maximum d'états créés
           par cette règle est limité par les options <tt>max-src-nodes
           </tt> et <tt>max-src-states</tt> de la règle. Seules les
           entrées d'états créées par cette règle particulière comptent
           pour la limite des règles.
       <li><tt>source-track global</tt> - Le nombre d'états créés par
           toutes les règles qui utilisent cette option est limité.
           Chaque règle peut spécifier différentes options <tt>max-src-nodes
           </tt> et <tt>max-src-states</tt>, cependant, les entrées
           d'états créées par toute règle participante comptent en vue
           d'une limite individuelle éventuelle.
       </ul>
Le nombre total d'adresses IP source suivies globalement peut être
contrôlé via l'option
<a href="options.html#limit"><tt>src-nodes</tt> runtime</a>.

<dt><tt>max-src-nodes <i>nombre</i></tt>
<dd>Lorsque l'option <tt>source-track</tt> est utilisée,
<tt>max-src-nodes</tt> limitera le nombre d'adresses IP source pouvant
créer simultanément une entrée.
Cette option peut seulement être utilisée avec une option <tt>source-track</tt>.

<dt><tt>max-src-states <i>nombre</i></tt>
<dd>Lorsque l'option <tt>source-track</tt> est utilisée,
<tt>max-src-states</tt> limitera le nombre d'entrées d'états
simultanées pouvant être crées par adresse IP source.
La portée de cette limite (les états créés par cette règle uniquement ou
les états créés par toutes les règles utilisant <tt>source-track</tt>)
est dépendante de l'option <tt>source-track</tt> spécifiée.
</dl>

<p>
Les options sont spécifiées entre parenthèses et tout de suite après
l'un des mots-clés de gestion d'état ((<tt>keep state</tt>,
<tt>modulate state</tt>, ou <tt>synproxy state</tt>).
S'il y a plusieurs options, vous devez les séparer par des virgules.
A partir d'OpenBSD 4.1, le mot-clé <tt>keep state</tt> est utilisé par
défaut par toutes les règles de filtrage lorsqu'aucun mot-clé de gestion
d'état n'est spécifié.
Malgré cela, un de ces mots-clés doit tout de même être spécifié lors de
l'utilisation d'options de gestion d'état.

<p>
Une règle d'exemple&nbsp;:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
La règle ci-dessus définit le comportement suivant&nbsp;:

<ul>
<li>Limiter le nombre maximum absolu d'états pouvant être créés par
cette règle à 200
<li>Activer le suivi de la source; limiter la création d'états pour
cette règle uniquement
<li>Limiter le nombre maximum de n&#156;uds pouvant simultanément créer des
états à 100
<li>Limiter le nombre maximum d'états simultanés par adresse IP source à
3
</ul>

<p>
Un jeu séparé de restrictions peut être placé sur les connexions TCP
stateful qui ont une poignée de main "3-way handshake" complète.

<dl>
<dt><tt>max-src-conn <i>nombre</i></tt>
<dd>Limiter le nombre maximum de connexions TCP simultanées ayant
réalisé la poignée de main qu'un hôte peut initier.
<dt><tt>max-src-conn-rate <i>nombre</i> / <i>intervalle</i></tt>
<dd>Limiter le taux de nouvelles connexions à un certaine fréquence.
</dl>

<p>
Ces deux options font appel à l'option <tt>source-track rule</tt> et
sont incompatibles avec <tt>source-track global</tt>.

<p>
Ces limites étant placées sur les connexions TCP ayant réalisé la
poignée de main TCP, des connexions plus agressives pourront toujours
avoir lieu depuis les adresses IP concernées.

<dl>
<dt><tt>overload &lt;<i>table</i>&gt;</tt>
<dd>Mettre l'adresse d'un hôte concerné dans la table désignée.
<dt><tt>flush [global]</tt>
<dd>Tue toutes les autres connexions qui correspondent à cette règle et
qui ont été créées par cette adresse IP source.
Quand <tt>global</tt> est spécifié, cela tue tous les états
correspondant à cette adresse IP source, sans discernement de la règle
qui a créé cet état.
</dl>

<p>
Un exemple&nbsp;:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Ceci permet de&nbsp;:

<ul>
<li>Limiter le nombre maximum de connexions par source à 100
<li>Limiter le taux du nombre de connexions à 15 dans une durée de 5
secondes
<li>Mettre l'adresse IP de tout hôte qui dépasse ces limites dans la
table <tt>&lt;abusive_hosts&gt;</tt>
<li>Pour des adresses IP concernées, supprimer tous les états créés par
cette règle.
</ul>

<a name="tcpflags"></a>
<h2>Les drapeaux TCP</h2>

On utilise souvent les drapeaux TCP dans des règles pour traiter les
ouvertures de sessions. Ces drapeaux et leur signification sont
présentés dans la liste suivante&nbsp;:
<ul>
<li><b>F</b>&nbsp;: FIN  - Fin de session
<li><b>S</b>&nbsp;: SYN  - Synchronize ; correspond à une ouverture de session
<li><b>R</b>&nbsp;: RST  - Reset ; met fin à une session
<li><b>P</b>&nbsp;: PUSH - Push ; le paquet est envoyé immédiatement
<li><b>A</b>&nbsp;: ACK - Acknowledgement ; atteste de l'acquittement d'une
    des parties
<li><b>U</b>&nbsp;: URG  - Urgent
<li><b>E</b>&nbsp;: ECE  - Explicit Congestion Notification Echo ; avis de congestion
<li><b>W</b>&nbsp;: CWR - Congestion Window Reduced ; avis de réduction de la
    fenêtre TCP
</ul>

<p>
Le mot-clé <tt>flags</tt> doit apparaître dans une règle si l'on
souhaite que PF prenne en compte la valeur des drapeaux TCP d'un paquet.
La syntaxe est la suivante&nbsp;:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
La partie <tt><i>mask</i></tt> de la règle indique la liste des drapeaux
que PF doit inspecter. La partie <tt><i>check</i></tt> quant à elle
spécifie les drapeaux qui doivent être positionnés pour que la règle
s'applique au paquet traité.
L'utilisation du mot-clé <tt>any</tt> permet de positionner n'importe quelle
combinaison de drapeaux au niveau de l'en-tête.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA<br>
pass in on fxp0 proto tcp from any to any port ssh
</tt>
</blockquote>

<p>
Comme les <tt>drapeaux S/SA</tt> sont définis par défaut, les règles
précédentes sont équivalentes, chacune de ces règles s'applique au trafic
TCP avec le drapeau SYN positionné en regardant uniquement les drapeaux SYN
et ACK.
Un paquet avec les drapeaux SYN et ECE s'appliquera aux règles précédentes,
mais pas à un paquet dont les drapeaux SYN et ACK ou dont seul le 
drapeau ACK sont positionnés.

<p>
Les drapeaux par défaut peuvent être contournés en utilisant l'option
<tt>flags</tt> tel que spécifié plus haut.

<p>
Il faut manipuler les drapeaux avec prudence et se méfier des mauvais
conseils. Certaines personnes suggèrent de ne créer des entrées que pour
les paquets dont le drapeau SYN est positionné. Ce qui peut aboutir à
cette règle&nbsp;:
<pre>
     . . . flags S/FSRPAUEW  <i>mauvaise pioche !!</i>
</pre>

<p>
En théorie, une session TCP commence par un paquet dont le drapeau SYN
est positionné. Toujours en théorie, il ne faut créer une entrée dans la
table d'état que pour ce genre de paquets. Mais certains systèmes
utilisent le drapeau ECN en début de session. Ces paquets sont rejetés
par la règle précédente.
Une meilleure solution consiste à ne pas spécifier de drapeau et de
laisser PF appliquer les drapeaux par défaut à vos règles.
Si vous avez réellement besoin de spécifier des drapeaux vous-même alors
cette combinaison devrait être sûre&nbsp;:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
<!--XXX scrub changes may have invalidated this-->
Si le trafic est normalisé, il peut être
pratique et sûr de ne pas tester la valeur des drapeaux FIN et RST. Dans
ce cas, PF rejette tout paquet entrant dont les drapeaux TCP sont
positionnés de manière illicite (par exemple SYN et RST) et les
combinaisons potentiellement ambiguës (telles que SYN et FIN) seront
normalisées.


<a name="synproxy"></a>
<h2>Mandataire TCP SYN</h2>

<p>
Normalement, quand un client ouvre une connexion TCP vers un serveur, PF
relaie les paquets d'ouverture
(<a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>handshake</a>) au fur et à mesure qu'ils arrivent. 
PF peut agir en tant que mandataire (proxy). Dans ce cas, PF va traiter
la demande en lieu et place du serveur et ne transfèrera qu'ensuite les
paquets à ce dernier. Aucun paquet n'est transmis au serveur avant que
le client n'ait terminé l'échange initial (handshake).

Dans le cas d'attaques par inondation de paquets SYN, les paquets de
l'attaquant n'atteignent jamais le serveur protégé, mais les clients
légitimes termineront la liaison et passeront.

Cela minimise l'impact d'inondations TCP SYN spoofées sur le service
protégé, en les gérant directement dans PF. Cependant, l'utilisation
systématique de cette option n'est pas recommandée, étant donné qu'elle
rompt le comportement prévu du protocole TCP lorsque le serveur ne peut
traiter la requête et lorsque les équilibreurs de charges sont actifs.

<p>
Le mandataire TCP SYN est activé à l'aide de l'option <tt>synproxy
state</tt>&nbsp;:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server port www synproxy state
</tt>
</blockquote>

<p>
Toutes les connexions à destination du serveur HTTP seront mandatées par
PF.

<p>
L'option <tt>synproxy state</tt> apporte les mêmes avantages que les
options <tt>keep state</tt> et <tt>modulate state</tt>.

<p>
Par contre, l'option synproxy ne fonctionne pas quand PF est installé en
passerelle transparente
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>).


<a name="antispoof"></a>
<h2>Bloquer les paquets usurpés</h2>

On parle d'usurpation quand un utilisateur mal intentionné maquille son
adresse IP dans le but d'anonymiser ou de cacher son identité afin de
lancer des attaques sans que leur origine soit détectable. Il peut
également essayer et parfois réussir à avoir accès à des services
réservés à certaines adresses.

<p>
PF permet de se prémunir de ce type d'attaques grâce à l'option
<tt>antispoof</tt>&nbsp;:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]

</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Journalise les paquets via 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+5.3">pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Si un paquet correspond à la règle, celle-ci est appliquée
    immédiatement.

<dt><tt><i>interface</i></tt>
<dd>Désigne l'interface sur laquelle s'applique la protection. Il est
    possible de passer une <a href="macros.html#lists">liste</a>
    d'interfaces en paramètre.


<dt><tt><i>af</i></tt>
<dd>Spécifie le type d'adresse&nbsp;: <tt>inet</tt> pour IPv4 ou
    <tt>inet6</tt> pour IPv6.
</dl>

<p>
Exemple:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>

</blockquote>

<p>
Quand les règles sont chargées, toutes les occurrences du mot
<tt>antispoof</tt> sont décodées dans deux filtres. Si l'interface
<tt>fxp0</tt> dont l'adresse IP est 10.0.0.1 pour un masque de sous-
réseau de 255.255.255.0 (soit /24) est protégée, l'option
<tt>antispoof</tt> sera décodée ainsi&nbsp;:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>

block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Cette règle déclenche deux actions&nbsp;:
<ul>
<li>elle bloque tout le trafic en provenance du réseau 10.0.0.0/24 s'il
    ne passe <i>pas</i> par l'interface <tt>fxp0</tt>. Puisque le réseau
    10.0.0.0/24 est branché sur l'interface <tt>fxp0</tt>, aucun paquet en
    provenance de celui-ci ne devrait arriver ailleurs.

<li>elle bloque tout le trafic entrant dont l'adresse source est
    10.0.0.1, à savoir celle de l'interface <tt>fxp0</tt>. Cette machine
    ne devrait en effet jamais émettre de paquets à travers une
    interface externe et par conséquent ne doit pas recevoir de paquets
    ayant son adresse IP comme adresse source.
</ul>

<p>
<b>REMARQUE</b>&nbsp;: le filtrage activé par l'option <tt>antispoof</tt>
   d'une règle s'applique également aux paquets envoyés sur l'adresse de
   bouclage interne (loopback).
   Le filtrage est communément désactivé sur ces interfaces, et cela
   devient primordial lors de l'utilisation de règles antispoof&nbsp;:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>

</blockquote>

<p>
L'utilisation de l'option <tt>antispoof</tt> est réservée aux interfaces
qui possèdent une adresse IP. Utiliser <tt>antispoof</tt> sur une interface sans
adresse IP aboutit au filtrage suivant&nbsp;:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Avec ce genre de règles, le risque est réel de bloquer <i>tout</i> le
trafic entrant sur <i>toutes</i> les interfaces.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
PF offre la fonctionnalité Unicast Reverse Path Forwarding (uRPF).
Lorsqu'un paquet est soumis à la vérification uRPF, l'adresse IP source
de celui-ci est recherchée dans la table de routage. Si l'interface de
sortie trouvée dans la table de routage afin de joindre la source est la
même que celle par laquelle le paquet vient d'entrer, le test uRPF
réussit. Si les interfaces ne correspondent pas, il est alors possible
que le paquet ait une adresse source spoofée.

<p>
La vérification uRPF peut être réalisée sur les paquets en utilisant
dans les règles de filtrage le mot-clé <tt>urpf-failed</tt>&nbsp;:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Notez que la vérification uRPF n'a de sens que dans un environnement de
routage symétrique.

<p>
uRPF propose la même fonctionnalité que les règles
<a href="#antispoof">antispoof</a>.


<a name="osfp"></a>
<h2>Reconnaissance passive d'OS par leurs empreintes</h2>

<p>
La reconnaissance passive d'OS par leurs empreintes (&quot;OS
Fingerprinting&quot; ou OSFP) est une méthode qui permet de reconnaître
à distance quel système d'exploitation tourne sur une machine. Cette
reconnaissance se base sur les caractéristiques des paquets TCP SYN
renvoyés par une machine. Ces informations peuvent être utilisées comme
critères dans des règles de filtrage.

<p>
PF utilise le fichier
<a href="options.html#fingerprints">d'empreintes</a>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+5.3"><tt>/etc/pf.os</tt></a>
pour reconnaître les systèmes d'exploitation auxquels il a affaire.
Lorsque PF s'exécute, la liste des empreintes reconnues peut être
consultée grâce à la commande suivante&nbsp;:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Dans une règle, une empreinte peut être désignée sous la forme d'une
classe, d'une version ou d'un sous-type d'OS. La liste de ces éléments
est affichée à l'aide de la commande <tt>pfctl</tt>. Pour désigner une
empreinte dans une règle, il faut utiliser le mot-clé <tt>os</tt>&nbsp;:

<blockquote>
<tt>
pass &nbsp;in on $ext_if proto tcp from any os OpenBSD keep state<br>
block in on $ext_if proto tcp from any os "Windows 2000"<br>
block in on $ext_if proto tcp from any os "Linux 2.4 ts"<br>
block in on $ext_if proto tcp from any os unknown
</tt>
</blockquote>

<p>
<tt>unknown</tt> est une classe spéciale désignant les systèmes
d'exploitation dont l'empreinte n'est pas connue.

<p>
<font color="#ff0000">Notez bien que </font>:
<ul>
  <li>La reconnaissance peut échouer face à des paquets spécifiquement
      construits pour tromper la détection d'empreintes.
  <li>L'application de correctifs peut modifier le comportement de la
      pile TCP/IP d'un système d'exploitation et faire également échouer
      ou tromper la reconnaissance de l'OS.
  <li>L'option OSFP n'est applicable qu'aux paquets TCP SYN. Elle est
      inefficace avec d'autres protocoles et pour les sessions déjà
      établies.
</ul>

<a name="ipopts"></a>
<h2>Les options IP</h2>

PF bloque par défaut tous les paquets qui utilisent les options IP. Cela
rend moins aisé le travail des outils de reconnaissance d'empreintes
tels que nmap. Si une application utilise ces options (par exemple IGMP
ou les diffusions multicast) il est possible d'utiliser l'option
<tt>allow-opts</tt>&nbsp;:

<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Exemple de règles de filtrage</h2>

Vous trouverez ci-dessous un exemple de règles de filtrage pour un
pare-feu PF destiné à protéger un petit réseau connecté à Internet. Seules
les règles de filtrage sont mentionnées ;
<a href="queueing.html"><tt>queueing</tt></a>,
<a href="nat.html"><tt>nat</tt></a>, 
<a href="rdr.html"><tt>rdr</tt></a>, etc... 
ont été volontairement laissées de côté.
<br>

<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# Déclaration du tableau référençant toutes les adresses IP affectées au
# pare-feu.
table &lt;firewall&gt; const { self }

# Ne pas filtrer sur l'interface de bouclage
set skip on lo0

# Normalisation de tous les paquets entrants.
match in all scrub (no-df)

# Mise en place d'une politique d'interdiction par défaut.
block all

# Activation de la protection contre l'usurpation sur toutes les
# interfaces.
block in quick from urpf-failed

# Les connexions ssh ne sont autorisées qu'en provenance du réseau local
# et de la machine 192.168.0.15. "block return" provoque l'émission d'un
# paquet TCP RST pour mettre fin aux connexions illicites. "quick"
# assure que cette règle n'est pas contredite par les règles "pass".
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# Autoriser le trafic sortant et entrant sur le réseau local.
# ces règles créeront des entrées au niveau de la table d'état étant
# donné que le mot-clé "keep state" est automatiquement appliqué.
pass in  on $int_if from $lan_net
pass out on $int_if to $lan_net

# Autoriser les connexions sortantes tcp, udp et icmp sur l'interface
# externe.
# les connexions tcp seront modulées, et udp/icmp auront un suivi
# d'état.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# Autoriser les connexions ssh sur l'interface externe du moment
# qu'elles ne sont pas destinées au pare-feu lui-même. Journaliser le
# paquet qui initie la session afin de pouvoir déterminer, plus tard,
# qui a essayé de se connecter.
# Décommentez la dernière partie pour utiliser le proxy tcp syn.
pass in log on $ext_if proto tcp to ! &lt;firewall&gt; \
   port ssh # synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Section précédente&nbsp;: Tables</a>]
[<a href="index.html">Index</a>]
[<a href="nat.html">Section suivante&nbsp;: Traduction des Adresses IP (&quot;NAT&quot;)</a>]


<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.67 ]<br>
$Translation: filter.html,v 1.62 2013/07/23 03:19:57 rustybsd Exp $<br>
-->
$OpenBSD: filter.html,v 1.56 2013/07/23 06:21:49 ajacoutot Exp $
</small>

</body>
</html>
