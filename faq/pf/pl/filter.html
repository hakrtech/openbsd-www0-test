<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtrowanie pakietów</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 2002-2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="rdr.html">Wstecz: Przekierowania ruchu</a>]
[<a href="index.html">Spis tre¶ci</a>]
[<a href="logging.html">Dalej: Logowanie</a>]

<h1><font color="#e00000">PF: Filtrowanie pakietów</font></h1>

<hr>

<h3>Spis tre¶ci</h3>
<ul>
<li><a href="#intro">Wstêp</a>
<li><a href="#syntax">Sk³adnia regu³</a>
<li><a href="#defdeny">Domy¶lne blokowanie</a>
<li><a href="#pass">Przepuszczanie ruchu</a>
<li><a href="#state">¦ledzenie stanów</a>
<li><a href="#udpstate">¦ledzenie stanów dla UDP</a>
<li><a href="#tcpflags">Flagi TCP</a>
<li><a href="#quick">S³owo kluczowe <tt>quick</tt></a>
<li><a href="#antispoof">Blokowanie zfa³szowanych pakietów</a>
<li><a href="#ipopts">Opcje IP</a>
<li><a href="#example">Przyk³ad zestawu regu³ filtruj±cych</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Wstêp</h2>
Filtrowanie pakietów to selektywne przepuszczanie lub blokowanie pakietów
przechodz±cych przez interfejs sieciowy. Kryteria, którymi kieruje siê 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>pf(4)</a> podczas sprawdzania pakietów, s± oparte o Warstwê 3
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>IPv4</a> i 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>IPv6</a>) oraz Warstwê 4 nag³ówków
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>ICMP</a>, i
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.4"
>ICMPv6</a>). Najczêstrzym kryterium jest ¼ród³owy i docelowy adres,
¼ród³owy i docelowy port, oraz protokó³.

<p>
Regu³y filtruj±ce okre¶laj± kryteria wed³ug których podejmowana jest
konkretna akcja wobec pakietu: przepu¶æ (ang. pass) lub blokuj
(ang. block). Regu³y filtruj±ce s± porównywane sekwencyjnie, od
pierwszej do ostatniej. Z wyj±tkiem sytuacji, gdy pakiet pasuje
do regu³y ze s³owem kluczowym <tt>quick</tt>, pakiety s± porównywane
z <i>wszystkimi</i> regu³ami filtruj±cymi zanim ostateczna akcja
zostanie podjêta. Ostatnia pasuj±ca regu³a jest "zwyciêzc±" i decyduje
o podjêtej akcji. Je¶li na koñcu zestawu regu³ znajduje siê bezwarunkowe
<tt>pass all</tt>, wówczas wszystkie pakiety, które nie pasowa³y do
¿adnej z regu³, bêd± przepuszczane.

<a name="syntax"></a>
<h2>Sk³adnia regu³</h2>
Ogólna, <i>bardzo uproszczona</i> sk³adnia regu³ filtruj±cych
wygl±da nastêpuj±co:
<blockquote>
<tt>
<i>action</i> <i>direction</i> [log] [quick] on <i>int</i> [<i>af</i>] 
[proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;from <i>src_addr</i> [port <i>src_port</i>] to 
<i>dst_addr</i> [port <i>dst_port</i>] \<br>
&nbsp;&nbsp;&nbsp;[<i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>Akcja, która ma byæ podejmowana wobec pasuj±cych pakietów, albo
<tt>pass</tt> albo <tt>block</tt>. Akcja <tt>pass</tt> przepuszcza
pakiety z powrotem do j±dra systemu do dalszego przetwarzania,
podczas gdy akcja <tt>block</tt> podejmuje dzia³anie zgodne z
ustawieniem opcji domy¶lnej polityki blokowania 
<a href="options.html#block-policy"><tt>block-policy</tt></a>. 
Domy¶lna akcja mo¿e byæ jawnie zmieniona poprzez podanie s³ów
kluczowych <tt>block drop</tt> lub <tt>block return</tt>.

<dt><tt><i>direction</i></tt>
<dd>Kierunek, w którym dany pakiet zmierza na interfejsie sieciowym, albo
<tt>in</tt> (pol. wchodzi) albo <tt>out</tt> (pol. wychodzi).

<dt><tt>log</tt>
<dd>Okre¶la, ¿e dany pakiet powinien byæ zapisany w logach przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.4"
>pflogd(8)</a>. Je¶li regu³a zawiera opcjê <tt>keep state</tt> lub
<tt>modulate state</tt>, wówczas jedynie pakiet, który rozpoczyna
po³±czenie stanowe jest odnotowywany w logach. Aby bezwzglêdnie zapisywaæ
w logach wszystkie pakiety, nale¿y zastosowaæ opcjê <tt>log-all</tt>.

<dt><tt>quick</tt>
<dd>Je¶li pakiet pasuje do regu³y ze s³owem kluczowym <tt>quick</tt>,
wówczas regu³a ta jest uznawana za ostatni± pasuj±c± i podejmowana jest
odpowiednia akcja.

<dt><tt><i>int</i></tt>
<dd>Nazwa interfejsu sieciowego, przez który pakiet przechodzi.

<dt><tt><i>af</i></tt>
<dd>Rodzina adresów: <tt>inet</tt> dla IPv4 lub <tt>inet6</tt>
dla IPv6. PF jest zwykle w stanie zidentyfikowaæ ten parametr na podstawie
adresu(ów) ¼ród³owych/przeznaczenia.

<dt><tt><i>protocol</i></tt>
<dd>Protokó³ Warstwy 4 pakietu:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Poprawna nazwa protoko³u z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.4"
><tt>/etc/protocols</tt></a>
<li>Numer protoko³u z przedzia³u od 0 do 255
<li>Zbiór protoko³ów zapisany w postaci <a href="macros.html#lists">listy</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>Adres ¼ród³owy/docelowy w nag³ówku IP. Adres mo¿e byæ podany jako:
<ul>
<li>Pojedynczy adres IPv4 lub IPv6.
<li>Blok sieci <a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<li>W pe³ni okre¶lona domena, która bêdzie rozwijana przez DNS w czasie
³adowania zestawu regu³. Wszystkie zwrócone adresy IP bêd± wstawione do regu³y.
<li>Nazwa interfejsu sieciowego. Wszystkie adresy IP przypisane do urz±dzenia
bêd± wprowadzone podczas ³adowania zestawu regu³.
<li>Nazwa interfejsu sieciowego wraz z mask± sieciow±
(np <tt>/24</tt>). Ka¿dy adres IP danego interfejsu jest ³±czony
z ka¿d± mask± sieciow± aby utworzyæ odpowiedni blok sieci CIDR,
który bêdzie wprowadzony podczas ³adowania zestawu regu³.
<li>Nazwa interfejsu sieciowego w nawiasach <tt>( )</tt>. Mówi to PF,
aby od¶wie¿aæ regu³ê, je¶li adres(y) IP tego interfejsu ulegnie zmianie.
Jest to bardzo przydatne gdy zewnêtrzne urz±dzenie otrzymuje swój
adres IP przez DHCP lub dial-up, poniewa¿ zestaw regu³
nie musi byæ prze³adowywany za ka¿dym razem, gdy zmienia siê IP.
<li>Nazwa interfejsu sieciowego z dopisanym na koñcu s³owem kluczowym
<tt>:network</tt> lub <tt>:broadcast</tt>. Odpowiedni blok sieci CIDR
(np 192.168.0.0/24) lub adres rozg³oszeniowy (np 192.168.0.255) bêdzie
wprowadzony podczas ³adowania zestawu regu³.
<li><a href="tables.html">Tabela</a>.
<li>Którykolwiek z powy¿szych, lecz zanegowany przy pomocy modyfikatora
<tt>!</tt> ("not").
<li>Zestaw adresów w postaci <a href="macros.html#lists">listy</a>.
<li>S³owo kluczowe <tt>any</tt> oznaczaj±ce wszystkie adresy.
<li>S³owo kluczowe <tt>all</tt> stanowi±ce skrót <tt>from any to
any</tt>.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>Port ¼ród³owy/docelowy w Warstwie 4 nag³ówka pakietu. Porty mog±
byæ podawane jako:
<ul>
<li>Liczba z zakresu od 1 do 65535
<li>Poprawna nazwa us³ugi, zdefiniowana w
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.4"
><tt>/etc/services</tt></a>
<li>Zestaw portów w postaci <a href="macros.html#lists">listy</a>
<li>Przedzia³:
	<ul>
	<li><tt>!=</tt> (ró¿ny)
	<li><tt>&lt;</tt> (mniejszy ni¿)
	<li><tt>&gt;</tt> (wiêkszy ni¿)
	<li><tt>&lt;=</tt> (mniejszy lub równy)
	<li><tt>&gt;=</tt> (wiêkszy lub równy)
	<li><tt>&gt;&lt;</tt> (przedzia³)
	<li><tt>&lt;&gt;</tt> (poza przedzia³em)
	</ul>
	<dl>
	<dd>Ostatnie dwa s± operatorami binarnymi (wymagaj± dwóch argumentów)
	oraz nie mog± mieæ parametrów w postaci przedzia³ów.
	</dl>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Okre¶la flagi, które musz± byæ ustawione w nag³ówku TCP gdy u¿ywamy
<tt>proto tcp</tt>. S± one podawane w postaci: 
<tt>flags <i>check</i>/<i>mask</i></tt>. Na przyk³ad: <tt>flags
S/SA</tt> - PF bierze pod uwagê jedynie flagi S i A (SYN i ACK),
a regu³a jest dopasowana je¶li tylko flaga SYN jest ustawiona.
<dt><tt><i>state</i></tt>
<dd>Okre¶la, czy informacje o stanie po³±czenia s± przechowywane, gdy
pakiety s± dopasowywane do tej regu³y.
<ul>
<li><tt>keep state</tt> - dzia³a z TCP, UDP, i ICMP.
<li><tt>modulate state</tt> - dzia³a jedynie z TCP. PF wygeneruje
trudny do przewidzenia Inicjuj±cy Numer Sekwencyjny (ang. Initial Sequence
Number - ISN) dla pakietów pasuj±cych do tej regu³y.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Domy¶lne blokowanie</h2>
Zaleca siê przyjmowaæ domy¶ln± politykê blokowania wszystkiego, a
jedynie selektywne przepuszczanie konkretnego ruchu. Takie podej¶cie
zalecane jest nie tylko ze wzglêdów bezpieczeñstwa, ale sprawia, ¿e
pisanie zestawu regu³ jest znacznie prostsze.

<p>
Aby wprowadziæ domy¶ln± politykê blokowania pierwsze dwie regu³y
powinny wygl±daæ tak:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Spowoduje to blokowanie ca³ego ruchu na wszystkich interfejsach w
obu kierunkach.

<a name="pass"></a>
<h2>Przepuszczanie ruchu</h2>
Ruch musi byæ precyzyjnie przepuszczany przez firewall albo bêdzie
zatrzymany przez domy¶ln± politykê blokowania. W tym miejscu do akcji
wchodz± kryteria takie jak port ¼ród³owy/docelowy, adres ¼ród³owy/docelowy
oraz protokó³. Je¶li jaki¶ ruch ma byæ przepuszczany przez firewall,
to regu³y powinny byæ napisane tak restrykcyjnie jak to tylko
mo¿liwe. Ma to zapewniæ przepuszczanie po¿±danego i tylko po¿±danego ruchu.

<p>
Kilka przyk³adów:
<blockquote>
<tt>
# Przepu¶æ ruch na dc0 z sieci lokalnej, 192.168.0.0/24,<br>
# zmierzaj±cy do 192.168.0.1. Przepu¶æ tak¿e ca³y powracaj±cy<br>
# do tej sieci ruch na dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Przepu¶æ ruch TCP z zewn±trz na fxp0 zmierzaj±cy do serwera www.<br>
# Nazwa interfejsu, fxp0, jest u¿yta jako adres docelowy, wiêc<br>
# pakiety bêd± pasowaæ do tej regu³y jedynie je¶li s± przeznaczone<br>
# dla tej maszyny OpenBSD.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="state"></a>
<h2>¦ledzenie stanów</h2>
Jedn± z wa¿nych mo¿liwo¶ci Packet Filter jest ¶ledzenie stanów
(ang. keeping state) lub kontrolowanie stanów (ang. stateful
inspection). Kontrolowanie stanów odnosi siê do zdolno¶ci PF do
¶ledzenia stanu, lub przebiegu, po³±czenia sieciowego. Poprzez
przechowywanie informacji o ka¿dym po³±czeniu w tabeli stanów,
PF jest w stanie szybko okre¶liæ, czy pakiet przechodz±cy przez
firewall nale¿y do ju¿ nawi±zanego po³±czenia. Je¶li tak jest,
pakiet jest przepuszczany bez przechodzenia zestawu regu³.

<p>
¦ledzenie stanów ma wiele zalet, w³±czaj±c uproszczenie zestawu
regu³ i lepsz± wydajno¶æ filtrowania pakietów. PF jest w stanie
dopasowywaæ pakiety poruszaj±ce siê w <i>obu</i> kierunkach danego
po³±czenia, co oznacza, ¿e regu³y przepuszczaj±ce powracaj±cy ruch
nie s± potrzebne. A poniewa¿ pakiety pasuj±ce do po³±czenia stanowego
nie przechodz± zestawu regu³, czas zu¿ywany na przetwarzanie tych
pakietów mo¿e byæ bardzo znacz±co zmniejszony.

<p>
Gdy regu³a posiada opcje <tt>keep state</tt>, pierwszy pakiet
pasuj±cy do niej tworzy "po³±czenie stanowe" pomiêdzy nadawc± i
odbiorc±. Wówczas, nie tylko pakiety pochodz±ce od nadawcy,
zmierzaj±ce do odbiorcy, ale i pakiety odbiorcy, skierowane do
nadawcy pasuj± do regu³y i nie s± sprawdzane przez zestaw regu³
filtruj±cych. Na przyk³ad:

<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Zezwala to na wychodzenie ruchu TCP na interfejsie <tt>fxp0</tt>
i przepuszcza ruch powrotny pakietów stanowi±cych odpowied¼.
¦ledzenie stanów poza swoj± funkcjonalno¶ci±, zapewnia tak¿e
znacz±cy wzrost wydajno¶ci firewalla, poniewa¿ wyszukania
stanów s± du¿o szybsze ni¿ porównywanie pakietu z zestawem regu³
filtruj±cych.

<p>
Opcja <tt>modulate state</tt> dzia³a podobnie do <tt>keep state</tt>
z t± ró¿nic±, ¿e odnosi siê jedynie do pakietów TCP. Przy u¿yciu 
<tt>modulate state</tt>, Inicjuj±cy Numer Sekwencyjny (ISN)
wychodz±cego po³±czenia jest losowy. Jest to przydatne do ochrony
po³±czeñ nawi±zanych przez ró¿ne systemy operacyjne, które nie najlepiej
radz± sobie z generowaniem numeru ISN.

<p>
¦led¼ stan wychodz±cych pakietów TCP, UDP i ICMP oraz generuj ISN dla TCP:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any modulate state<br>
pass out on fxp0 proto { udp, icmp } from any to any keep state
</tt>
</blockquote>

<p>
Inn± zalet± ¶ledzenia stanów jest to, i¿ odpowiedni ruch ICMP bêdzie
przepuszczany przez firewall. Na przyk³ad, je¶li <tt>keep state</tt>
jest zdefiniowane dla po³±czenia TCP i nadejdzie komunikat ICMP
"gasz±cy ¼ród³o" (ang. source-quench) odwo³uj±cy siê do tego po³±czenia,
bêdzie on dopasowany do odpowiedniego wpisu stanowego i przepuszczony
przez firewall.

<p>
Warto zwróciæ uwagê, ¿e po³±czenia stanowe s± ograniczone do interfejsu
na którym s± tworzone. Jest to istotne w przypadku ruterów i firewalli
korzystaj±cymi z PF, zw³aszcza przy polityce "domy¶lnego blokowania"
zaimplementowanej tak, jak wcze¶niej zosta³o to opisane. Je¶li firewall
realizuje ¶ledzenie stanów dla wszystkich wychodz±cych po³±czeñ na zewnêtrznym
urz±dzeniu, pakiety te wci±¿ musza byæ formalnie przepuszczone na
wewnêtrznym interfejsie.

<p>
Proszê zwróciæ uwagê, ¿e regu³y <a href="nat.html"><tt>nat</tt></a>, 
<a href="nat.html#binat"><tt>binat</tt></a>, i
<a href="rdr.html"><tt>rdr</tt></a> bezwarunkowo tworz± stan dla
pasuj±cych po³±czeñ tak d³ugo, jak dane po³±czenie jest
przekierowywane przez dan± regu³ê. 

<a name="udpstate"></a>
<h2>¦ledzenie stanów dla UDP</h2>
Ka¿dy od czasu do czasu s³yszy opinie, ¿e "nie mo¿na utworzyæ stanu
z UDP, poniewa¿ UDP jest bezstanowym protoko³em!". Mimo i¿ jest
prawd±, ¿e sesje komunikacyjne UDP nie maj± ¿adnej formy stanu
(formalnego rozpoczêcia i zakoñczenia komunikacji), nie ma to
¿adnego wp³ywu na zdolno¶æ PF do tworzenia stanowych sesji UDP.
W tym przypadku protoko³ów bez pakietów "inicjuj±cych" i "koñcz±cych"
po³±czenie, PF po prostu ¶ledzi ile czasu up³ynê³o odk±d pasuj±cy
pakiet zosta³ przepuszczony. Je¶li czas przekroczy ustalon± warto¶æ,
wpis stanu jest usuwany. Czas "przeterminowania" mo¿e byæ dostrojony
w sekcji <a href="options.html">opcje</a> pliku <tt>/etc/pf.conf</tt>.

<a name="tcpflags"></a>
<h2>Flagi TCP</h2>
Dopasowanie pakietów TCP na podstawie flag jest najczê¶ciej
wykorzystywane przy filtrowaniu pakietów, które otwieraj±
nowe po³±czenie. Flagi TCP i ich nazwy s± podane poni¿ej:

<ul>
<li><b>F</b> : FIN  - Finish; zakoñczenie sesji
<li><b>S</b> : SYN  - Synchronize; sygnalizuje pro¶bê o rozpoczêcie sesji
<li><b>R</b> : RST  - Reset; porzuæ po³±czenie
<li><b>P</b> : PUSH - Push; pakiet jest wysy³any bezzw³ocznie
<li><b>A</b> : ACK  - Acknowledgement; potwierdzenie 
<li><b>U</b> : URG  - Urgent; ponaglenie
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo
<li><b>W</b> : CWR  - Congestion Window Reduced
</ul>

<p>
Aby PF sprawdza³ flagi TCP podczas przetwarzania regu³ filtruj±cych
wykorzystywane jest s³owo kluczowe <tt>flags</tt>. Jego sk³adnia jest
nastêpuj±ca:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i>
</tt>
</blockquote>

<p>
Czê¶æ <tt><i>mask</i></tt> mówi PF aby sprawdzaæ jedynie podane flagi, a
czê¶æ <tt><i>check</i></tt> okre¶la która flaga(i) powinny byæ "ustawione"
w nag³ówku, aby dopasowanie mia³o miejsce.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
Powy¿sza regu³a przepuszcza ruch TCP z ustawion± jedynie flag± SYN,
bior±c pod uwagê tylko flagi SYN i ACK. Pakiet z flagami SYN i ECE
bêdzie pasowa³ do powy¿szej regu³y, jednak pakiet z SYN i ACK lub
tylko ACK ju¿ nie.

<p>
Uwaga: we wcze¶niejszych wersjach OpenBSD, nastêpuj±ca zapis by³
poprawny:
<blockquote>
<tt>
. . . flags S
</tt>
</blockquote>

<p>
Nie jest to ju¿ prawdziwe. Maska <i>zawsze</i> musi byæ podana.

<p>
Flagi czêsto s± stosowane w po³±czeniu z regu³ami <tt>keep state</tt>,
aby wspomóc kontrolê tworzenia stanów: 
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Regu³a ta zezwala na tworzenie stanu dla wychodz±cych pakietów TCP
z ustawion± jedynie flag± SYN i przy braniu pod uwagê SYN oraz ACK.

<p>
Przy korzystaniu z flag trzeba byæ bardzo ostro¿nym - nale¿y rozumieæ
co siê robi i dlaczego, no i nale¿y uwa¿aæ na rady innych,
poniewa¿ czêsto s± one b³êdne. Niektórzy np. sugeruj± tworzenie stanu
"jedynie gdy flaga SYN jest ustawiona, i ¿adna inna". Taka regu³
wygl±da³a by tak:
<pre>
     . . . flags S/FSRPAUEW  <i>to z³y pomys³!!</i>
</pre>

<p>
W teorii, tworzy siê po³±czenie stanowe na pocz±tku sesji TCP, a sesja
powinna rozpocz±æ siê od flagi SYN, i ¿adnej innej. Problem polega
na tym, ¿e niektórzy u¿ytkownicy rozpoczynaj± po³±czenia wraz z flag±
ECN, i bêd± odrzuceni przez tak± regu³ê. Du¿o lepsz± praktyk± jest:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Jest to praktyczne i bezpieczne. Je¶li ruch podlega normalizacji
<a href="scrub.html">scrub</a>, wówczas mo¿na nie sprawdzaæ tak¿e
flag FIN i RST. Normalizacja powoduje, ¿e PF porzuca nadchodz±ce
pakiety z nieprawid³ow± kombinacja flag (tak± jak SYN i FIN lub
SYN i RST). Zaleca siê zawsze normalizowaæ przychodz±cy ruch
przy pomocy <tt>scrub</tt>:
<blockquote>
<tt>
scrub in on fxp0<br>
.<br>
.<br>
.<br>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state
</tt>
</blockquote>

<a name="quick"></a>
<h2>S³owo kluczowe <tt>quick</tt></h2>
Jak ju¿ zosta³o to wcze¶niej napisane, ka¿dy pakiet jest porównywany
z ca³ym zestawem regu³ od góry do do³u. Domy¶lnie, pakiet
po porównaniu jest przekazywany do kolejnej regu³y, i dlatego
mo¿e byæ wielokrotnie zmieniany jego status, zanim osi±gnie
koniec zestawu regu³. <b>"Ostatnia pasuj±ca regu³a wygrywa".</b>
Jest od tego wyj±tek: opcja <tt>quick</tt> w regule filtruj±cej
skutkuje przerwaniem dalszego porównania i powoduje
podjêcie akcji z obecnej regu³y. Oto kilka przyk³adów:

<p>
¬le:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
W tym przypadku, linia <tt>block</tt> mo¿e byæ porównywana, ale nigdy
nie bêdzie mia³a ¿adnego efektu, poniewa¿ po niej znajduje siê linia,
która wszystko przepuszcza.

<p>
Lepiej:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Te regu³y s± porównywane nieco inaczej. Je¶li linia <tt>block</tt>
pasuje, dziêki opcji <tt>quick</tt>, pakiet bêdzie zablokowany,
a reszta regu³ tego zestawu bêdzie zignorowana.

<a name="antispoof"></a>
<h2>Blokowanie zfa³szowanych pakietów</h2>
Fa³szowaniem (ang. spoof) okre¶la siê zmianê adresu ¼ród³owego pakietu maj±ce
na celu albo ukrycie prawdziwego pochodzenia datagramu, albo podszycie siê
pod inny segment sieci. Gdy u¿ytkownik pomy¶lnie podszyje siê pod inny adres,
mo¿e rozpocz±æ sieciowy atak bez ujawniania jego prawdziwego ¼ród³a lub
spróbowaæ uzyskaæ kontrolê nad us³ugami, które s± dostêpne dla w±skiej grupy
konkretnych adresów IP. 

<p>
PF oferuje pewn± ochronê przed podszywaniem siê pod inne adresy
poprzez s³owo kluczowe <tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Okre¶la, ¿e pasuj±ce pakiety powinny byæ logowane przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.4"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Je¶li pakiet pasuje do tej regu³y, wówczas jest jest ona uznawana za
regu³ê "zwyciêsk±" i nie nastêpuje dalsze porównywanie regu³ z zestawu.

<dt><tt><i>interface</i></tt>
<dd>Nazwa interfejsu sieciowego na którym ma byæ aktywowana ochrona przed
spoofing-iem. Mo¿e to byæ tak¿e <a href="macros.html#lists">lista</a>
interfejsów sieciowych.

<dt><tt><i>af</i></tt>
<dd>Rodzina adresów dla której ma byæ aktywowana ochrona przed
spoofing-iem. <tt>inet</tt> dla IPv4 lub <tt>inet6</tt> dla IPv6.
</dl>

<p>
Przyk³ad:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Gdy zestaw regu³ jest ³adowany, ka¿de wyst±pienie <tt>antispoof</tt>
jest rozszerzane do dwóch regu³ filtruj±cych. Zak³adaj±c, ¿e interfejs
fxp0 ma adres IP 10.0.0.1 i maskê podsieci 255.255.255.0 (np, /24),
powy¿sza regu³a <tt>antispoof</tt> by³aby przekszta³cona w:
<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Regu³y te realizuj± dwa zadania:
<ul>
<li>Blokuj± ca³y ruch przychodz±cy z sieci 10.0.0.0/24, który
<i>nie</i> przechodzi przez fxp0. Poniewa¿ sieæ 10.0.0.0/24 jest na
interfejsie fxp0, pakiety z adresem ¼ród³owym z tego bloku sieci
nie powinny nigdy nadchodziæ z ¿adnego innego interfejsu sieciowego.
<li>Blokuj± ca³y ruch przychodz±cy z 10.0.0.1, adresu IP interfejsu
fxp0. Host nigdy nie powinien wysy³aæ pakietów do samego siebie
przez zewnêtrzny interfejs, dlatego nadchodz±ce pakiety z adresem
¼ród³owym nale¿±cym do tej maszyny mog± byæ uznane za podejrzane.
</ul>

<p>
<b>UWAGA</b>: Regu³y filtruj±ce, w które <tt>antispoof</tt> siê
przekszta³ca bêd± blokowaæ tak¿e pakiety wysy³ane przez interfejs
zwrotny (ang. loopback) na lokalny adres. Te adresy powinny byæ
formalnie przepuszczane. Przyk³ad:
<blockquote>
<tt>
pass in quick on lo0 all<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Korzystanie z <tt>antispoof</tt> powinno byæ ograniczone do interfejsów,
które maj± przypisany adres IP. U¿ycie <tt>antispoof</tt> na interfejsie
bez adresu IP spowoduje powstanie nastêpuj±cych regu³ filtruj±cych:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Przy takich regu³ach istnieje ryzyko blokowania <i>ca³ego</i> nadchodz±cego
ruchu na <i>wszystkich</i> interfejsach.

<a name="ipopts"></a>
<h2>Opcje IP</h2>
Domy¶lnie PF blokuje wszystkie pakiety IP z ustawionymi opcjami.
Mo¿e to utrudniæ rozpoznanie systemu operacyjnego przez takie
narzêdzia jak nmap. Je¶li zachodzi konieczno¶æ uruchomienia aplikacji, która
wymaga przepuszczania tych pakietów, jak np. wysy³anych do grupy odbiorców
(ang. multicast) lub IGMP, mo¿na skorzystaæ z dyrektywy <tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Przyk³ad zestawu regu³ filtruj±cych</h2>
Poni¿ej znajduje siê przyk³ad zestawu regu³ filtruj±cych.
Maszyna z PF pe³ni rolê firewalla oddzielaj±cego ma³± sieæ
wewnêtrzn± od Internetu. Poni¿ej przedstawiona jest tylko
konfiguracj odpowiadaj±ca za filtrowanie, regu³ki
<a href="queueing.html">kolejkowanie</a>,
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>
itp zosta³y pominiête.
<br>
<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# normalizacja przychodz±cych pakietów
scrub in all

# ustawienie polityki domy¶lnego blokowania
block in  all
block out all

# przepu¶æ ruch na interfejsie zwrotnym w obu kierunkach
pass quick on lo0 all

# aktywuj ochronê przed spoofing-iem dla interfejsu wewnêtrznego.
antispoof quick for $int_if inet

# zezwalaj na po³±czenia ssh z sieci lokalnej jedynie z zaufanego
# hosta - 192.168.0.15. korzystaj z "block return", aby TCP RST
# od razu by³o wysy³ane w odpowiedzi na blokowane po³±czenia
# korzystaj z "quick", aby regu³a nie by³a nadpisana przez
# znajduj±ce siê poni¿ej regu³y "pass"
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh flags S/SA

# przepuszczaj ca³y ruch z i do lokalnej sieci przeznaczony dla 
# maszyny bêd±cej firewall-em
pass in  on $int_if from $lan_net to $int_if 
pass out on $int_if from $int_if to $lan_net

# wypuszczaj tcp, udp i icmp na interfejsie zewnêtrznym (Internet). 
# ¶led¼ stan dla udp i icmp oraz moduluj stan dla tcp.
pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state

# zezwalaj na po³±czenia ssh na interfejsie zewnêtrznym pod warunkiem,
# ¿e NIE s± one skierowane do firewall-a (np, nie s± skierowane
# do maszyny z sieci lokalnej). twórz logi dla pakietów inicjuj±cych
# po³±czenia, aby mo¿na by³o potem stwierdziæ, kto próbowa³ siê
# po³±czyæ.
pass in log on $ext_if proto tcp from any to { !$ext_if, !$int_if } \
   port ssh flags S/SA keep state
</pre>
</td></tr>
</table>

<p>
[<a href="rdr.html">Wstecz: Przekierowania ruchu</a>]
[<a href="index.html">Spis tre¶ci</a>]
[<a href="logging.html">Dalej: Logowanie</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[wstecz]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: filter.html,v 1.14 ]<br>
$Translation: filter.html,v 1.3 2003/11/13 12:02:20 pl-team Exp $<br>
$OpenBSD: filter.html,v 1.3 2003/11/14 23:10:31 horacio Exp $
</small>
</body>
</html> 
