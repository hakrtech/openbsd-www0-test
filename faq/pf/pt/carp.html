<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Redundância de Firewall com CARP e pfsync</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf,carp,pfsync">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2005-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="authpf.html">Anterior: Shell de Usuário para Autenticação
em Gateways</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="example1.html">Próximo: Firewall para Casa ou Pequeno Escritório</a>]

<p>
<h1><font color="#e00000">PF: Redundância de Firewall com CARP
e pfsync</font></h1>

<hr>

<h3>Conteúdo</h3>
<ul>
<li><a href="#carpintro">Introdução ao CARP</a>
<li><a href="#carpop">Funcionamento do CARP</a>
<li><a href="#carpconfig">Configurando o CARP</a>
<li><a href="#carpex">Exemplo de configuração CARP</a>
<li><a href="#pfsyncintro">Introdução ao pfsync</a>
<li><a href="#pfsyncop">Funcionamento do pfsync</a>
<li><a href="#pfsyncconfig">Configurando o pfsync</a>
<li><a href="#pfsyncex">Exemplo de configuração pfsync</a>
<li><a href="#failover">Combinando CARP e pfsync para "Failover" e
    Redundância</a>
<li><a href="#ops">Problemas Operacionais</a>
	<ul>
	<li><a href="#bootconfig">Configurando o CARP e pfsync Durante
            o Boot</a>
	<li><a href="#forcefail">Forçando "Failover" do Master</a>
	<li><a href="#RulesetTips">Dicas de Regras</a>
	</ul>
<li><a href="#ref">Outras Referências</a>
</ul>

<hr>

<a name="carpintro"></a>
<h2>Introdução ao CARP</h2>
CARP é o Protocolo de Redundância de Endereço Comum (Common Address
Redundancy Protocol).
Seu objetivo principal é permitir que múltiplos hosts no mesmo
segmento de rede compartilhem um endereço IP.
CARP é uma alternativa livre e segura ao
<a href="http://www.ietf.org/rfc/rfc3768.txt">Virtual Router Redundancy
Protocol</a> (VRRP) e ao
<a href="http://www.ietf.org/rfc/rfc2281.txt">Hot Standby Router
Protocol</a> (HSRP).

<p>
CARP funciona permitindo a um grupo de hosts no mesmo segmento de rede
compartilhar um endereço IP.
Esse grupo de hosts é referido como um "grupo de redundância".
Ao grupo de redundância é atribuído um endereço IP que é compartilhado
entre os membros do grupo.
Dentro do grupo, um host é designado o "master" e o resto como
"backups".
O host "master" é o que atualmente "segura" o IP compartilhado; ele
responde a qualquer tráfego ou requisições ARP direcionadas a ele.
Cada host pode pertencer a mais que um grupo de redundância por vez.

<p>
Um uso comum para o CARP é criar um grupo de firewalls redundantes.
O IP virtual que é atribuído ao grupo de redundância é configurado nas
máquinas clientes como o gateway padrão (default).
Caso o firewall master sofra uma falha ou seja desligado, o IP se moverá
para um dos firewalls backup e o serviço vai continuar sem ser afetado.

<p>
CARP suporta IPv4 e IPv6.


<a name="carpop"></a>
<h2>Funcionamento do CARP</h2>
O host master no grupo envia regularmente anúncios à rede local,
assim os hosts backup sabem que ele ainda está ativo.
Se os hosts backup não ouvirem um anúncio do master por um período de
tempo, então um deles tomará conta dos deveres do master (qualquer host
backup que tenha configurado os valores para <tt>advbase</tt> e
<tt>advskew</tt> baixos).

<p>
É possível que múltiplos grupos CARP existam no mesmo segmento de rede.
Anúncios CARP contém o Virtual Host ID que permite aos membros do grupo
identificar que grupo de redundância pertencem.

<p>
Para prevenir que um usuário malicioso no segmento de rede falsifique
(spoofing) anúncios CARP, cada grupo pode ser configurado com uma senha.
Cada pacote CARP enviado ao grupo é então protegido por um HMAC SHA1.

<p>
Como o CARP é seu próprio protocolo, ele deve ter uma regra de permissão
explícita no conjunto de regras de filtragem:

<blockquote>
<tt>
pass out on $carp_dev proto carp keep state
</tt>
</blockquote>

<p>
<tt>$carp_dev</tt> deve ser a interface física que o CARP está se
comunicando.


<a name="carpconfig"></a>
<h2>Configurando o CARP</h2>
Cada grupo de redundância é representado por uma interface
de rede virtual
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4&amp;manpath=OpenBSD+4.4"
>carp(4)</a>. Assim, o CARP é configurado usando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.

<blockquote>
<tt>
ifconfig <i>carpN</i> create<br>
<br>
ifconfig <i>carpN</i> vhid <i>vhid</i> [pass <i>senha</i>]
[carpdev <i>carpdev</i>] \<br>
&nbsp;&nbsp;&nbsp;[advbase <i>advbase</i>] [advskew <i>advskew</i>]
[state <i>estado</i>] <i>endereço-ip</i> \<br>
&nbsp;&nbsp;&nbsp;netmask <i>máscara</i>
</tt>
</blockquote>

<dl>
<dt><tt><i>carpN</i></tt>
<dd>O nome da interface virtual carp(4) onde <i>N</i> é um
inteiro que representa o número da interface (ex., carp10).

<dt><tt><i>vhid</i></tt>
<dd>O Virtual Host ID. Esse é um número único que é usado para
identificar o grupo de redundância de outros nós na rede.
Valores aceitos são de 1 a 255.

<dt><tt><i>senha</i></tt>
<dd>A senha de autenticação para usar quando estiver conversando com
outros hosts CARP nesse grupo de redundância.
Deve ser a mesma para todos os membros do grupo.

<dt><tt><i>carpdev</i></tt>
<dd>Esse parâmetro opcional especifica a interface de rede física
que pertence a esse grupo de redundância.
Por padrão, o CARP tentará determinar qual interface usar procurando
pela interface física que está na mesma subrede da combinação
<i>endereço-ip</i> e <i>máscara</i> dada à interface carp(4).

<dt><tt><i>advbase</i></tt>
<dd>Esse parâmetro opcional especifica com que frequência, em segundos,
anunciar que somos um membro do grupo de redundância.
O padrão é 1 segundo.
Valores aceitos são de 1 a 255.

<dt><tt><i>advskew</i></tt>
<dd>Esse parâmetro opcional especifica quanto desviar o
<tt><i>advbase</i></tt> quando estiver enviando anúncios CARP.
Manipulando o <tt><i>advskew</i></tt>, o host CARP master pode ser
escolhido. Quanto mais alto o número, <i>menos</i> preferido
será o host quando estiver escolhendo um master.
O padrão é 0.
Valores aceitos são de 0 a 254.

<dt><tt><i>estado</i></tt>
<dd>Força uma interface carp(4) em um certo estado. Estados válidos são
<tt>init</tt>, <tt>backup</tt> e <tt>master</tt>.

<dt><tt><i>endereço-ip</i></tt>
<dd>Esse é o endereço IP atribuído ao grupo de redundância.
Esse endereço não tem que estar na mesma subrede que o endereço IP na
interface física (se presente).
Esse endereço, contudo, precisa ser o mesmo em todos os hosts no grupo.

<dt><tt><i>máscara</i></tt>
<dd>A máscara de subrede do IP compartilhado.
</dl>

<p>
Além disso, comportamentos CARP podem ser controlados via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a>.

<dl>
<dt><tt>net.inet.carp.allow</tt>
<dd>Aceita entrada de pacotes CARP ou não. Padrão é 1 (sim).

<dt><tt>net.inet.carp.preempt</tt>
<dd>Permite a hosts dentro de um grupo de redundância que tenham um
melhor <tt>advbase</tt> e <tt>advskew</tt> tomar o lugar (preempt)
do master.
Adicionalmente, essa opção habilita "failing over" em todas as
interfaces caso uma interface caia (down).
Se uma interface física CARP cair, o CARP trocará o <tt>advskew</tt>
para 240 em todas as outras interfaces CARP, em essência o "failing"
termina por si mesmo.
Essa opção é 0 (desabilitada) por padrão.

<dt><tt>net.inet.carp.log</tt>
<dd>Loga pacotes CARP. O padrão é 0 (desabilitado).

<dt><tt>net.inet.carp.arpbalance</tt>
<dd>Carrega balanceamento de tráfego entre múltiplos hosts no
grupo de redundância.
O padrão é 0 (desabilitado).
Veja
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4&amp;manpath=OpenBSD+4.4"
>carp(4)</a> para mais informações.
</dl>


<a name="carpex"></a>
<h2>Exemplo de configuração CARP</h2>
Aqui tem um exemplo de configuração do CARP.

<blockquote>
<tt>
# sysctl -w net.inet.carp.allow=1<br>
# ifconfig carp1 create<br>
# ifconfig carp1 vhid 1 pass mekmitasdigoat carpdev em0 \<br>
&nbsp;&nbsp;&nbsp;&nbsp;advskew 100 10.0.0.1 netmask 255.255.255.0<br>
</tt>
</blockquote>

<p>
Isso configura o seguinte:
<ul>
<li>Habilita o recebimento de pacotes CARP (isto é, a configuração
    padrão).
<li>Cria uma interface carp(4), <tt>carp1</tt>.
<li>Configura <tt>carp1</tt> para o virtual host #1, habilita uma senha,
    configura <tt>em0</tt> como a interface pertencente ao grupo, e faz
    desse host um backup devido ao <tt>advskew</tt> de <tt>100</tt>
    (assumindo, é claro, que o master seja configurado com um
    <tt>advskew</tt> menor do que 100).
    O IP compartilhado atribuído a esse grupo é 10.0.0.1/255.255.255.0.
</ul>

<p>
Rodar o <tt>ifconfig</tt> na <tt>carp1</tt> mostra o status da
interface.

<blockquote>
<tt>
# ifconfig carp1<br>
carp1: flags=8802&lt;UP,BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carp: BACKUP carpdev em0 vhid 1 advbase 1
advskew 100<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups: carp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet 10.0.0.1 netmask 0xffffff00 broadcast
10.0.0.255
</tt>
</blockquote>


<a name="pfsyncintro"></a>
<h2>Introdução ao pfsync</h2>
A interface de rede
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4&amp;manpath=OpenBSD+4.4"
>pfsync(4)</a> expõe certas alterações feitas na tabela
de estados do
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.4"
>pf(4)</a>.
Monitorando esse dispositivo usando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8"
>tcpdump(8)</a>, alterações na tabela de estados podem ser observadas
em tempo real.
Além disso, a interface pfsync(4) pode enviar essas mensagens de
alterações de estado para a rede de modo que outros nós rodando PF
possam unir as alterações em suas próprias tabelas de estado.
Da mesma forma, o pfsync(4) também pode ouvir a rede por mensagens
que chegam.


<a name="pfsyncop"></a>
<h2>Funcionamento do pfsync</h2>
Por padrão, o pfsync(4) não envia ou recebe atualizações da tabela de
estados na rede; entretanto, atualizações ainda podem ser monitoradas
usando o tcpdump(8) ou outras ferramentas na máquina local.

<p>
Quando o pfsync(4) está configurado para enviar e receber
atualizações na rede, o comportamento padrão é enviar atualizações
multicast na rede local.
Todas as atualizações são enviadas sem autenticação.
Prática mais comum é:

<ol>
<li>Conectar os dois nós que estarão trocando atualizações usando um
    cabo crossover e usar a interface como <tt>syncdev</tt> (veja
    <a href="#pfsyncconfig">abaixo</a>).
<li>Usar a opção <tt>syncpeer</tt> do ifconfig(8) (veja
    <a href="#pfsyncconfig">abaixo</a>), assim atualizações são
    direcionadas com unicast para o nó, então configure o
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&amp;sektion=4"
    >ipsec(4)</a> entre os hosts para proteger o tráfego pfsync(4).
</ol>

<p>
Quando as atualizações estão sendo enviadas e recebidas na rede, os
pacotes pfsync devem ser aceitos nas regras de filtragem.

<blockquote>
<tt>
pass on $sync_if proto pfsync
</tt>
</blockquote>

<p>
<tt>$sync_if</tt> deve ser a interface física que o pfsync(4) está se
comunicando.


<a name="pfsyncconfig"></a>
<h2>Configurando o pfsync</h2>
Visto que o pfsync(4) é uma interface de rede virtual, é configurado
usando o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.

<blockquote>
<tt>
ifconfig <i>pfsyncN</i> syncdev <i>syncdev</i> [syncpeer
<i>syncpeer</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>pfsyncN</i></tt>
<dd>O nome da interface pfsync(4). A <tt>pfsync0</tt> existe
por padrão quando estiver usando o kernel <tt>GENERIC</tt>.

<dt><tt><i>syncdev</i></tt>
<dd>O nome da interface física usada para enviar atualizações pfsync.

<dt><tt><i>syncpeer</i></tt>
<dd>Esse parâmetro opcional especifica o endereço IP de um host para
trocar atualizações pfsync.
Por padrão as atualizações pfsync são multicast na rede local.
Essa opção cancela esse comportamento e em vez disso envia atualizações
unicasts para o <tt><i>syncpeer</i></tt> especificado.
</dl>


<a name="pfsyncex"></a>
<h2>Exemplo de configuração pfsync</h2>
Aqui tem um exemplo de configuração do pfsync.

<blockquote>
<tt>
# ifconfig pfsync0 syncdev em1<br>
</tt>
</blockquote>

Isso habilita o pfsync na interface <tt>em1</tt>.
As atualizações enviadas serão multicast na rede, permitindo que
qualquer outro host rodando pfsync possa recebê-las.


<a name="failover"></a>
<h2>Combinando CARP e pfsync Para Failover</h2>
Combinando as características do CARP e pfsync, um grupo de dois ou
mais firewalls pode ser usado para criar um cluster de firewalls
completamente redundante e com alta disponibilidade.

<dl>
<dt>CARP:
<dd>Trata o failover automático de um firewall para outro.

<dt>pfsync:
<dd>Sincroniza a tabela de estados entre todos os firewalls.
Caso aconteça um failover, o tráfego pode fluir ininterrupto
através do novo firewall master.
</dl>

<p>
Um cenário de exemplo.
Dois firewalls, <tt>fw1</tt> e <tt>fw2</tt>.

<pre>
         +----| WAN/Internet |----+
         |                        |
      em2|                        |em2
      +-----+                  +-----+
      | fw1 |-em1----------em1-| fw2 |
      +-----+                  +-----+
      em0|                        |em0
         |                        |
      ---+-------Shared LAN-------+---
</pre>

<p>
Os firewalls estão conectados diretamente usando um cabo crossover
em <tt>em1</tt>.
Ambos estão conectados a LAN em <tt>em0</tt> e a uma conexão
WAN/Internet em <tt>em2</tt>.
Os endereços IP são como seguem:

<ul>
<li>fw1 em0: 172.16.0.1
<li>fw1 em1: 10.10.10.1
<li>fw1 em2: 192.0.2.1
<li>fw2 em0: 172.16.0.2
<li>fw2 em1: 10.10.10.2
<li>fw2 em2: 192.0.2.2
<li>LAN shared IP: 172.16.0.100
<li>WAN/Internet shared IP: 192.0.2.100
</ul>

<p>
A política de rede é que <tt>fw1</tt> será o master preferido.

<p>
Configuração do fw1:

<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
! Habilita preemption e o grupo de interfaces failover
# sysctl -w net.inet.carp.preempt=1

! Configura pfsync
# ifconfig em1 10.10.10.1 netmask 255.255.255.0
# ifconfig pfsync0 syncdev em1
# ifconfig pfsync0 up

! Configura CARP no lado LAN
# ifconfig carp1 create
# ifconfig carp1 vhid 1 carpdev em0 pass lanpasswd \
     172.16.0.100 netmask 255.255.255.0

! Configura CARP no lado WAN/Internet
# ifconfig carp2 create
# ifconfig carp2 vhid 2 carpdev em2 pass netpasswd \
    192.0.2.100 netmask 255.255.255.0
</pre>
</td></tr>
</table>

<p>
Configuração do fw2:

<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
! Habilita preemption e o grupo de interfaces failover
# sysctl -w net.inet.carp.preempt=1

! Configura pfsync
# ifconfig em1 10.10.10.2 netmask 255.255.255.0
# ifconfig pfsync0 syncdev em1
# ifconfig pfsync0 up

! Configura CARP no lado LAN
# ifconfig carp1 create
# ifconfig carp1 vhid 1 carpdev em0 pass lanpasswd \
     advskew 128 172.16.0.100 netmask 255.255.255.0

! Configura CARP no lado WAN/Internet
# ifconfig carp2 create
# ifconfig carp2 vhid 2 carpdev em2 pass netpasswd \
    advskew 128 192.0.2.100 netmask 255.255.255.0
</pre>
</td></tr>
</table>


<a name="ops"></a>
<h2>Problemas Operacionais</h2>
Alguns problemas operacionais comuns encontrados com CARP/pfsync.

<a name="bootconfig"></a>
<h3>Configurando o CARP e pfsync Durante o Boot</h3>
Visto que carp(4) e pfsync(4) são ambos tipos de interfaces de rede,
eles podem ser configurados durante a inicialização criando-se um
arquivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a>.
O script de inicialização
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8"
>netstart</a> cuidará de criar as interfaces e configurá-las.

<p>
Exemplos:

<dl>
<dt>/etc/hostname.carp1</dt>
<dd>
inet 172.16.0.100 255.255.255.0 172.16.0.255 vhid 1 carpdev em0 \<br>
&nbsp;&nbsp;&nbsp;&nbsp;pass lanpasswd
</dd>
</dl>

<dl>
<dt>/etc/hostname.pfsync0</dt>
<dd>
up syncdev em1
</dd>
</dl>

<a name="forcefail"></a>
<h3>Forçando Failover do Master</h3>
De tempos em tempos, é necessário failover ou derrubar o nó master
de propósito.
Exemplos incluem derrubar o nó master para manutenção ou quando estiver
resolvendo um problema.
O objetivo aqui é elegantemente passar (fail over) o tráfego para um
dos hosts backups de modo que os usuários não observem nenhum impacto.

<p>
Para failover de um grupo CARP em particular, derrube a interface
carp(4) no nó master.
Isso fará o master anunciar a si mesmo com um
<tt>advbase</tt> e <tt>advskew</tt> "infinito".
O(s) host(s) backup verá(ão) isso e imediatamente tomará(ão) o
lugar do master.

<blockquote>
<tt>
# ifconfig carp1 down
</tt>
</blockquote>

<p>
Uma alternativa é aumentar o <tt>advskew</tt> para um valor mais alto
que o <tt>advskew</tt> no(s) host(s) backup.
Isso causará failover, mas ainda permite ao master participar
no grupo CARP.

<p>
Um outro método para failover é ajustar o contador CARP demotion.
O contador demotion é uma medida de como "pronto" um host
está para se tornar o master do grupo CARP.
Por exemplo, enquanto um host está no meio do processo de boot é
uma má idéia para ele se tornar um master CARP até que todas as
interfaces estejam configuradas, todos os serviços de rede estejam
iniciados, etc.
Hosts anunciando um valor demotion alto terão menos preferência como
master.

<p>
Um contador demotion é armazenado em cada grupo de interface que a
interface CARP pertence.
Por padrão, todas as interfaces CARP são membros do grupo de interface
"carp".
O valor atual de um contador demotion pode ser visto usando o
ifconfig(8):

<blockquote>
<tt>
# ifconfig -g carp<br>
carp: carp demote count 0
</tt>
</blockquote>

<p>
Nesse exemplo o contador associado com o grupo de interface "carp"
é mostrado.
Quando um host CARP anuncia a si mesmo na rede, ele pega a soma dos
contadores demotion para cada grupo de interface que a interface
carp(4) pertence e anuncia esse valor como seu valor demotion.

<p>
Agora assuma o seguinte exemplo.
Dois firewalls rodando CARP com as seguintes interfaces CARP:

<ul>
<li>carp1 -- Departamento de Contabilidade
<li>carp2 -- Empregados Regulares
<li>carp3 -- Internet
<li>carp4 -- DMZ
</ul>

<p>
O objetivo é apenas fazer failover dos grupos carp1 e carp2 para
o firewall secundário.

<p>
Primeiro, associe cada grupo a um novo grupo de interface, neste caso
chamado "internal":

<blockquote>
<tt>
# ifconfig carp1 group internal<br>
# ifconfig carp2 group internal<br>
# ifconfig internal<br>
carp1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carp: MASTER carpdev em0 vhid 1 advbase 1
advskew 100<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups: carp internal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet 10.0.0.1 netmask 0xffffff00 broadcast
10.0.0.255<br>
carp2: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carp: MASTER carpdev em1 vhid 2 advbase 1
advskew 100<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups: carp internal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet 10.0.1.1 netmask 0xffffff00 broadcast
10.0.1.255
</tt>
</blockquote>

<p>
Agora aumente o contador demotion para o grupo "internal" usando o
ifconfig(8):

<blockquote>
<tt>
# ifconfig -g internal<br>
internal: carp demote count 0<br>
# ifconfig -g internal carpdemote 50<br>
# ifconfig -g internal<br>
internal: carp demote count 50<br>
</tt>
</blockquote>

<p>
O firewall fará elegantemente o failover nos grupos carp1 e carp2
para o outro firewall no cluster, enquanto ainda se mantém como master
nos grupos carp3 e carp4.
Se o outro firewall começar a anunciar um valor demotion maior
do que 50 ou se parar de anunciar completamente, então esse
firewall fará novamente o takeover do master nos grupos carp1 e
carp2.

<p>
Para voltar (fail back) para o firewall primário, reverta
as mudanças:

<blockquote>
<tt>
# ifconfig -g internal -carpdemote 50<br>
# ifconfig -g internal<br>
internal: carp demote count 0<br>
</tt>
</blockquote>

<p>
Serviços de rede como
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bgpd&amp;sektion=8"
>OpenBGPD</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sasyncd&amp;sektion=8"
>sasyncd(8)</a>
fazem uso do contador demotion para garantir que o firewall não
se torne master até que as sessões BGP estejam estabelecidas e SAs
IPsec estejam sincronizados.

<a name="RulesetTips"></a>
<h3>Dicas de Regras</h3>
<b>Filtre a interface física.</b>
Até o ponto que o PF está preocupado, o tráfego da rede vem da
interface física, não da interface virtual CARP (i.e., <tt>carp0</tt>).
Assim, escreva seu conjunto de regras de acordo.
Não se esqueça de que um nome de uma interface em uma regra do PF pode
ser tanto o nome da interface física ou um endereço associado a
essa interface. Por exemplo, esta regra poderia estar correta:
<blockquote><tt>
pass in on fxp0 inet proto tcp from any to carp0 port 22
</tt></blockquote>
mas substituindo o <tt>fxp0</tt> por <tt>carp0</tt> não
funcionaria como você deseja.

<p>
<b>NÃO se esqueça</b> de uma regra pass para <tt>proto carp</tt>
e <tt>proto pfsync</tt>!

<p>

<a name="ref"></a>
<h2>Outras Referências</h2>
Por favor veja estas outras fontes para mais informação:

<ul>
<li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4&amp;manpath=OpenBSD+4.4"
    >carp(4)</a>
<li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4&amp;manpath=OpenBSD+4.4"
    >pfsync(4)</a>
<li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
    >ifconfig(8)</a>
<li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
    >hostname.if(5)</a>
<li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.4"
    >pf.conf(5)</a>
<li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated&amp;sektion=8"
    >ifstated(8)</a>
<li>
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated.conf&amp;sektion=5"
    >ifstated.conf(5)</a>
</ul>


<p>
[<a href="authpf.html">Anterior: Shell de Usuário para Autenticação
em Gateways</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="example1.html">Próximo: Firewall para Casa ou Pequeno Escritório</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[voltar]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: carp.html,v 1.22 ]<br>
$Translation: carp.html,v 1.11 2009/03/11 00:52:55 dsantos Exp $<br>
-->
$OpenBSD: carp.html,v 1.11 2009/03/16 20:24:23 tobias Exp $
</small>

</body>
</html>
