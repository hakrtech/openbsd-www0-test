<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtragem de Pacotes</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq,pf">
<meta name="distribution" content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->


<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conte&uacute;do</a>]
[<a href="nat.html">Pr&oacute;ximo: Tradu&ccedil;&atilde;o do Endere&ccedil;o de Rede (NAT)</a>]

<h1><font color="#e00000">PF: Filtragem de Pacotes</font></h1>

<hr>

<h3>Conte&uacute;do</h3>
<ul>
<li><a href="#intro">Introdu&ccedil;&atilde;o</a>
<li><a href="#syntax">Sintaxe das Regras</a>
<li><a href="#defdeny">Negar por Padr&atilde;o</a>
<li><a href="#pass">Passando Tr&aacute;fego</a>
<li><a href="#quick">A Palavra-Chave <tt>quick</tt></a>
<li><a href="#state">Mantendo o Estado</a>
<li><a href="#udpstate">Mantendo o Estado para UDP</a>
<li><a href="#stateopts">Op&ccedil;&otilde;es de Rastreamento de Estado</a>
<li><a href="#tcpflags">Flags TCP</a>
<li><a href="#synproxy">TCP SYN Proxy</a>
<li><a href="#antispoof">Bloqueando Pacotes Spoofados</a>
<li><a href="#urpf">Encaminhamento Unicast Reverso</a>
<li><a href="#osfp">Detec&ccedil;&atilde;o Passiva de Sistema Operacional</a>
<li><a href="#ipopts">Op&ccedil;&otilde;es IP</a>
<li><a href="#example">Exemplo de Arquivo de Regras</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Introdu&ccedil;&atilde;o</h2>
Filtragem de pacotes &eacute; o bloqueio ou libera&ccedil;&atilde;o da passagem 
de pacotes de dados de maneira seletiva, conforme eles atravessam 
a interface de rede. O crit&eacute;rio usado pelo 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.2"
>pf(4)</a> ao inspecionar pacotes s&atilde;o baseados nos cabe&ccedil;alhos da Camada 3 
(<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> e 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) e Camada 4
(<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a>, e
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>). Os crit&eacute;rios mais usados s&atilde;o endere&ccedil;o de origem e destino, 
porta de origem e destino e protocolo.

<p>
Regras de filtragem especificam o crit&eacute;rio em que o pacote deve se 
enquadrar e a a&ccedil;&atilde;o resultante, que pode ser bloqueio ou libera&ccedil;&atilde;o, 
tomada quando o pacote casa com a regra. As regras de filtragem 
s&atilde;o avaliadas em sequ&ecirc;ncia da primeira a &uacute;ltima.
A n&atilde;o ser que o pacote encontre um regra contendo a palavra-chave 
<tt>quick</tt>, o mesmo ser&aacute; avaliado contra <i>todas</i> as regras de
filtragem antes da a&ccedil;&atilde;o final ser tomada. A &uacute;ltima regra a casar &eacute; a 
"vencedora" e dita qual a&ccedil;&atilde;o tomar. Existe um 
<tt>pass all</tt> impl&iacute;cito no in&iacute;cio das regras de 
filtragem, que significa que caso o pacote n&atilde;o case com nenhuma regra 
a a&ccedil;&atilde;o resultante ser&aacute; <tt>pass</tt>.

<a name="syntax"></a>
<h2>Sintaxe das Regras</h2>
A forma geral <i>simplificada</i> da sintaxe para regras de filtragem &eacute;:
<blockquote>
<tt>
<i>a&ccedil;&atilde;o</i> [<i>dire&ccedil;&atilde;o</i>] [log] [quick] [on <i>interface</i>]
[<i>af</i>] [proto <i>protocolo</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to 
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>a&ccedil;&atilde;o</i></tt>
<dd>A a&ccedil;&atilde;o executada em pacotes que combinem com a regra, pode ser
<tt>pass</tt> ou <tt>block</tt>. A a&ccedil;&atilde;o <tt>pass</tt> libera a passagem do 
pacote para processamento posterior pelo kernel, enquanto que a a&ccedil;&atilde;o 
<tt>block</tt> reagir&aacute; com base na op&ccedil;&atilde;o
<a href="options.html#block-policy"><tt>block-policy</tt></a>. 
A rea&ccedil;&atilde;o padr&atilde;o pode ser sobrescrita especificando 
<tt>block drop</tt> ou <tt>block return</tt> na regra.

<dt><tt><i>dire&ccedil;&atilde;o</i></tt>
<dd>A dire&ccedil;&atilde;o em que o pacote est&aacute; se movendo na interface, pode ser 
<tt>in</tt> ou <tt>out</tt>.

<dt><tt>log</tt>
<dd>Especifica que o pacote deve ser logado via
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.2"
>pflogd(8)</a>. Caso a regra crie estados ent&atilde;o somente o pacote que estabelece 
a conex&atilde;o &eacute; logado.
Para logar todos pacotes, use <tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Se um pacote casar com uma regra que especifique a palavra <tt>quick</tt>,
esta regra &eacute; considerada final e a <tt><i>a&ccedil;&atilde;o</i></tt> especificada 
&eacute; executada.

<dt><tt><i>interface</i></tt>
<dd>O nome ou grupo da interface de rede onde o pacote passa.
Interfaces podem ser adicionadas aos grupos usando o comando
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
V&aacute;rios grupos tamb&eacute;m s&atilde;o criados automatiamente pelo
kernel:
<ul>
<li>O grupo <tt>egress</tt>, que cont&eacute;m a(s) interface(s) que
possui(em) a(s) rota(s) default.
<li>Grupo da fam&iacute;lia de interfaces clonadas.
Por exemplo: <tt>ppp</tt> ou <tt>carp</tt>.
</ul>
Far&aacute; com que a regra case com qualquer pacote atravessando qualquer 
interface <tt>ppp</tt> ou <tt>carp</tt> respectivamente. 

<dt><tt><i>af</i></tt>
<dd>A fam&iacute;lia de endere&ccedil;os a que o pacote pertence, <tt>inet</tt> 
para IPv4 ou <tt>inet6</tt> para IPv6. Geralmente o PF pode determinar essa 
informa&ccedil;&atilde;o com base no(s) endere&ccedil;o(os) de origem e/ou destino do pacote.

<dt><tt><i>protocolo</i></tt>
<dd>O protocolo de Camada 4 do pacote:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Um nome de protocolo v&aacute;lido em 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"><tt>/etc/protocols</tt></a>
<li>Um n&uacute;mero de protocolo entre 0 e 255
<li>Um grupo de protocolos utilizando uma <a href="macros.html#lists">lista</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>Os endere&ccedil;os de origem/destino no cabe&ccedil;alho do IP. Endere&ccedil;os podem ser 
especificados como:
<ul>
<li>Endere&ccedil;o IPv4 ou IPv6 simples.
<li>Um bloco de rede <a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<li>Nome de dom&iacute;nio totalmente qualificado, que ser&aacute; resolvido pelo DNS 
quando as regras forem carregadas. Todos endere&ccedil;os IP resultantes ser&atilde;o 
substitu&iacute;dos na regra.
<li>O nome de uma interface de rede ou grupo. 
Quaisquer endere&ccedil;os IP na interface substituir&atilde;o a regra.
<li>O nome de uma interface de rede seguido por uma 
<tt>/<i>m&aacute;scara</i></tt> (ex., <tt>/24</tt>). Cada endere&ccedil;o IP na interface 
&eacute; combinado com a m&aacute;scara para formar um bloco de rede CIDR que ser&aacute; 
substitu&iacute;do na regra.
<li>O nome de uma interface de rede ou grupo entre par&ecirc;nteses <tt>( )</tt>. 
Isto informa ao PF para atualizar a regra caso o endere&ccedil;o(os) da interface sofra 
altera&ccedil;&atilde;o. &Uacute;til em interfaces que obt&eacute;m seu endere&ccedil;o IP 
via DHCP ou dial-up, pois as outras regras n&atilde;o precisar&atilde;o ser recarregadas toda 
vez que o endere&ccedil;o mudar.
<li>O nome de uma interface de rede seguido por algum dos modificadores:
  <ul>
  <li><tt>:network</tt> - substitui o bloco de rede CIDR (ex.,
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - substitui o endere&ccedil;o de broadcast
  (ex., 192.168.0.255)
  <li><tt>:peer</tt> - substitui o endere&ccedil;o da outra ponta num link 
  ponto-a-ponto 
  </ul>
  <dl>
  <dd>Al&eacute;m disso, o modificador <tt>:0</tt> pode ser adicionado a um nome 
  de interface ou qualquer um dos modificadores acima para indicar ao PF 
  para n&atilde;o incluir endere&ccedil;os IP de aliases na substitui&ccedil;&atilde;o.
  Estes modificadores tamb&eacute;m podem ser usados quando o nome da interface 
  est&aacute; entre par&ecirc;nteses.
  Exemplo: <tt>fxp0:network:0</tt>
  </dl>
<li>Uma <a href="tables.html">tabela</a>.
<li>A palavra-chave <tt>urpf-failed</tt> pode ser usada para endere&ccedil;os
de origem para indicar que devem passar pelo
<a href="#urpf">uRPF</a>.
<li>Qualquer dos apresentados acima, negado usando o modificador <tt>!</tt> ("not") .
<li>Um grupo de endere&ccedil;os usando-se uma <a href="macros.html#lists">lista</a>.
<li>A palavra-chave <tt>any</tt> indicando todos os endere&ccedil;os
<li>A palavra-chave <tt>all</tt> que &eacute; um atalho para <tt>from any to
any</tt>.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>A porta de origem/destino no cabe&ccedil;alho da Camada 4 do pacote. Portas 
podem ser especificadas da seguinte forma:
<ul>
<li>Um n&uacute;mero entre 1 e 65535
<li>Nome de servi&ccedil;o v&aacute;lido em 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"><tt>/etc/services</tt></a>
<li>Lista de portas usando uma <a href="macros.html#lists">lista</a>
<li>Uma faixa:
	<ul>
	<li><tt>!=</tt> (diferente)
	<li><tt>&lt;</tt> (menor que)
	<li><tt>&gt;</tt> (maior que)
	<li><tt>&lt;=</tt> (menor ou igual a)
	<li><tt>&gt;=</tt> (maior ou igual a)
	<li><tt>&gt;&lt;</tt> (faixa)
	<li><tt>&lt;&gt;</tt> (faixa inversa)
	<dl>
	<dd>Os dois &uacute;ltimo s&atilde;o operadores bin&aacute;rios (recebem dois argumentos) 
	e n&atilde;o incluem os argumentos na faixa.
	</dl>
	<li><tt>:</tt> (faixa inclusiva)
	<dl>
	<dd>O operador de faixa inclusiva tamb&eacute;m &eacute; um operador bin&aacute;rio
	e inclui os argumentos na faixa.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Especifica os flags que devem estar setados no cabe&ccedil;alho 
TCP quando for usado <tt>proto tcp</tt>. Flags s&atilde;o especificados na forma: 
<tt>flags <i>check</i>/<i>mask</i></tt>. Por exemplo: <tt>flags
S/SA</tt> - instrui o PF a verificar somente os flags S e A (SYN e ACK)
e casar, se apenas o flag SYN estiver "setado".
No OpenBSD 4.1 e posteriores, a flag padr&atilde;o <tt>S/SA</tt> &eacute;
aplicada a todas as regras de filtragem TCP.

<dt><tt><i>state</i></tt>
<dd>Especifica se a informa&ccedil;&atilde;o de estado deve ser mantida em pacotes 
que casem com a regra.
<ul>
<li><tt>keep state</tt> - funciona com TCP, UDP, e ICMP.
No OpenBSD 4.1 e posteriores, esta op&ccedil;&atilde;o &eacute; o padr&atilde;o
para todas as regras de filtragem.
<li><tt>modulate state</tt> - funciona apenas com TCP. PF ir&aacute; gerar 
N&uacute;meros de Sequ&ecirc;ncia Inicial (ISNs) seguros para pacotes que combinem 
com esta regra.
<li><tt>synproxy state</tt> - faz proxy de pedidos de conex&atilde;o TCP 
para ajudar a proteger servidores contra floods de pacotes SYN TCP 
spoofados.
Essa op&ccedil;&atilde;o inclui a funcionalidade <tt>keep state</tt> e
<tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Negar por Padr&atilde;o</h2>
A pr&aacute;tica recomendada ao configurar um firewall &eacute; usar uma pol&iacute;tica
"negar por padr&atilde;o". Isto &eacute;, bloquear <i>tudo</i>, e depois ir permitindo 
certos tipos de tr&aacute;fego atrav&eacute;s do firewall. Esta &eacute; a abordagem 
recomendada por ser mais cautelosa, al&eacute;m de facilitar a configura&ccedil;&atilde;o
das regras.

<p>
Para criar uma pol&iacute;tica de filtragem negar por padr&atilde;o, as primeiras duas regras de 
filtragem devem ser:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Isto ir&aacute; bloquear todo o tr&aacute;fego em todas interfaces em qualquer 
dire&ccedil;&atilde;o, de qualquer lugar para qualquer lugar.

<a name="pass"></a>
<h2>Passando Tr&aacute;fego</h2>
O tr&aacute;fego agora deve ser explicitamente permitido ou ser&aacute; barrado pela
pol&iacute;tica padr&atilde;o do firewall. &Eacute; aqui que os crit&eacute;rios de 
filtragem como porta de origem/destino, endere&ccedil;o de origem/destino e protocolo entram 
em cena. Sempre que o tr&aacute;fego tiver permiss&atilde;o de cruzar o firewall as 
regras devem ser escritas da maneira mais restritiva poss&iacute;vel. Isso &eacute; 
para nos certificarmos de que o tr&aacute;fego v&aacute;lido, e, somente tr&aacute;fego 
v&aacute;lido ter&aacute; permiss&atilde;o de passagem.

<p>
Alguns exemplos:
<blockquote>
<tt>
# Autoriza passagem de tr&aacute;fego chegando em dc0 vindo da rede local 192.168.0.0/24,<br>
# e indo para a m&aacute;quina OpenBSD com endere&ccedil;o IP 192.168.0.1. Tamb&eacute;m permite<br>
# tr&aacute;fego de retorno saindo via dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Permite tr&aacute;fego TCP chegando em fxp0 e indo para o servidor web<br>
# rodando na m&aacute;quina OpenBSD. O nome da interface, fxp0, &eacute; usado como<br>
# endere&ccedil;o de destino, para que apenas pacotes destinados &agrave;<br>
# m&aacute;quina OpenBSD casem com a regra.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>A palavra-chave <tt>quick</tt></h2>
Como dito anteriormente, cada pacote &eacute; avaliado contra as regras de 
filtragem de cima para baixo.  Por padr&atilde;o, o pacote &eacute; marcado para passagem, 
o que pode ser alterado por qualquer regra, e depois alterado novamente 
v&aacute;rias vezes antes do fim das regras de filtragem. <b>A &uacute;ltima regra que casa 
"vence".</b>  Mas, h&aacute; uma excess&atilde;o &agrave; regra: A op&ccedil;&atilde;o 
<tt>quick</tt> numa regra de filtragem tem o efeito de cancelar o processamento de qualquer 
outra regra que venha em seguida e executa imediatamente a a&ccedil;&atilde;o especificada. 
Vejamos alguns exemplos:

<p>
Errado:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Neste caso, a linha <tt>block</tt> ser&aacute; avaliada, mas jamais ter&aacute; efeito 
algum, pois &eacute; seguida de uma linha que permite a passagem de tudo.

<p>
Melhor:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Essas regras s&atilde;o avaliadas de maneira ligeiramente diferente. 
Caso a linha <tt>block</tt> case com a regra, devido o uso da op&ccedil;&atilde;o
<tt>quick</tt>, o pacote ser&aacute; bloqueado, e o restante das regras ser&atilde;o 
ignoradas.

<a name="state"></a>
<h2>Mantendo o Estado</h2>
Uma das caracter&iacute;sticas importantes do Packet Filter &eacute;  
"manter o estado das conex&otilde;es", ou "stateful inspection". Stateful
inspection &eacute; a habilidate do PF em registrar o estado, ou progresso de uma 
conex&atilde;o de rede. Armazenando informa&ccedil;&otilde;es sobre o estado de cada 
conex&atilde;o numa tabela, o PF pode rapidamente determinar se um pacote 
passando pelo firewall pertence a uma conex&atilde;o j&aacute; estabelecida. Caso 
afirmativo, ele passa direto pelo firewall sem ser avaliado pelas 
regras.

<p>
Manter informa&ccedil;&otilde;es de estado das conex&otilde;es traz muitas vantagens incluindo 
simplicidade na configura&ccedil;&atilde;o das regras e melhor performance na filtragem 
de pacotes. O PF pode criar entradas na tabela de estado para pacotes 
indo em <i>qualquer</i> dire&ccedil;&atilde;o, o que significa que regras de filtragem 
que autorizam o tr&aacute;fego de retorno n&atilde;o precisam ser escritas. E, como 
pacotes que possuem entradas na tabela de estado n&atilde;o s&atilde;o avaliados pelas 
regras, o tempo que o PF gasta no processamento destes pode ser drasticamente 
reduzido.

<p>
Quando uma regra cria estados, o primeiro pacote 
que casa com a regra cria um "estado" entre transmissor e receptor.
Agora, n&atilde;o somente os pacotes do transmissor para o receptor combinam 
com a entrada na tabela e passam direto pelas regras, como tamb&eacute;m as 
respostas do receptor.

<p>
A partir do OpenBSD 4.1, todas as regras de filtragem automaticamente
criam um estado quando um pacote combinar com a regra.
Nas vers&otilde;es anteriores do OpenBSD a regra de filtragem precisava
explicitamente usar a op&ccedil;&atilde;o
<tt>keep state</tt>.

<p>
Exemplo usando OpenBSD 4.1 e posteriores:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Exemplo ussando OpenBSD 4.0 e anteriores:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Estas regrais permitem qualquer tr&aacute;fego TCP saindo pela interface <tt>fxp0</tt>, 
bem como o tr&aacute;fego retornando em resposta ao firewall. Al&eacute;m do recurso 
de manuten&ccedil;&atilde;o de estado ser uma excelente caracter&iacute;stica, seu uso ainda
melhora a performance do firewall, pois pesquisas na tabela de estado 
s&atilde;o muito mais r&aacute;pidas do que comparar o pacote contra todas as regras
de filtragem.

<p>
A op&ccedil;&atilde;o <tt>modulate state</tt> funciona como a <tt>keep state</tt>
exceto que ela se aplica apenas a pacotes TCP. Com <tt>modulate state</tt>,
o N&uacute;mero de Sequ&ecirc;ncia Inicial (ISN) de conex&otilde;es saindo do 
firewall &eacute; aleat&oacute;rio. Isso &eacute; &uacute;til para proteger 
conex&otilde;es iniciadas por certos sistemas operacionais que n&atilde;o fazem 
um bom trabalho ao escolher ISNs.
Desde o OpenBSD 3.5, a op&ccedil;&atilde;o <tt>modulate state</tt> pode ser usada 
tamb&eacute;m em regras que especifiquem protocolos diferentes do TCP.

<p>
Mantendo estado em pacotes TCP, UDP e ICMP e modulanto ISNs TCP:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Outra vantagem de manter o estado &eacute; que o tr&aacute;fego ICMP correspondente 
tamb&eacute;m passa pelo firewall. 
Por exemplo, se uma conex&atilde;o TCP passando pelo firewall for rastreada
como stateful e chegar uma mensagem ICMP source-quench
referenciando esta conex&atilde;o, ela ser&aacute; identificada como pertencendo a 
uma entrada v&aacute;lida na tabela de estado e passar&aacute; direto pelo firewall.

<p>
O escopo de uma entrada na tabela de estado &eacute; controlado globalmente 
pela op&ccedil;&atilde;o <a href="options.html#state-policy"><tt>state-policy</tt></a>
em tempo de execu&ccedil;&atilde;o, e com base nas regras de estado pelas palavras-chave 
<tt>if-bound</tt>, <tt>group-bound</tt> e <tt>floating</tt>.
Essas palavras-chave usadas nas regras tem o mesmo efeito de  
quando s&atilde;o usadas na op&ccedil;&atilde;o <tt>state-policy</tt>. Exemplo:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Essa regra define que para um pacote casar com a entrada na tabela de 
estado, ele deve estar transitando na interface <tt>fxp0</tt>.


<p>
Perceba que para regras 
<a href="nat.html"><tt>nat</tt></a>, 
<a href="nat.html#binat"><tt>binat</tt></a> e
<a href="rdr.html"><tt>rdr</tt></a> &eacute; impl&iacute;cita 
a cria&ccedil;&atilde;o de estados para conex&otilde;es v&aacute;lidas desde que os 
pacotes passem pelas regras de filtragem.

<a name="udpstate"></a>
<h2>Mantendo Estado Para UDP</h2>
Algumas vezes voc&ecirc; pode ouvir que, "N&atilde;o se pode criar estados para 
conex&otilde;es UDP, pelo fato do UDP ser um protocolo que n&atilde;o mant&eacute;m o 
estado nas conex&otilde;es!". Enquanto &eacute; verdade que uma sess&atilde;o de 
comunica&ccedil;&atilde;o UDP n&atilde;o possui nenhum conceito de estado (um in&iacute;cio e fim 
expl&iacute;cito na comunica&ccedil;&atilde;o), isso n&atilde;o causa nenhum impacto na habilidade 
do PF em criar estados para sess&otilde;es UDP.  No caso de protocolos sem 
pacotes de "in&iacute;cio" e "fim", o PF simplesmente mant&eacute;m um registro do 
tempo desde a &uacute;ltima ocorr&ecirc;ncia de um pacote para dada conex&atilde;o.  Caso 
o tempo de espera seja atingido, o registro de estado &eacute; eliminado. 
Valores para esse intervalo podem ser definidos n&atilde;o se&ccedil;&atilde;o
<a href="options.html">op&ccedil;&otilde;es</a> do arquivo <tt>pf.conf</tt> .

<a name="stateopts"></a>
<h2>Op&ccedil;&otilde;es de Rastreamento de Estado</h2>
Regras de filtragem que criam estados podem especificar varias
op&ccedil;&otilde;es para controlar o comportamento da tabela de estados
resultante.
As seguintes op&ccedil;&otilde;es est&atilde;o dispon&iacute;veis:

<dl>
<dt><tt>max <i>n&uacute;mero</i></tt>
<dd>Limita o n&uacute;mero m&aacute;ximo de estados que a regra pode criar para
<i>n&uacute;mero</i>.
Se o m&aacute;ximo for alcan&ccedil;ado, pacotes que normalmente criariam
estados s&atilde;o descartados at&eacute; que o n&uacute;mero de estados
existentes diminua.

<dt><tt>no state</tt>
<dd>Evita que a regra crie estados automaticamente.
 
<dt><tt>source-track</tt>
<dd>Esta op&ccedil;&atilde;o habilita o rastreamento do n&uacute;mero 
de estados criados por endere&ccedil;o IP de origem.
Esta op&ccedil;&atilde;o tem dois formatos: 
       <ul>
       <li><tt>source-track rule</tt> - O n&uacute;mero m&aacute;ximo de
       estados criados por esta regra &eacute; limitado pelas 
       op&ccedil;&otilde;es <tt>max-src-nodes</tt> e <tt>max-src-states</tt> 
       da regra. Somente estados criados por esta regra em particular
       conta para o limite da regra. 
       <li><tt>source-track global</tt> - O n&uacute;mero de estados
       criados por todas as regras que usam esta op&ccedil;&atilde;o &eacute;
       limitado. Cada regra pode especificar diferentes op&ccedil;&otilde;es
       para <tt>max-src-nodes</tt> e <tt>max-src-states</tt>, contudo estados
       criados por qualquer regra participante conta cada limite de regra
       individualmente. 
       </ul>
O n&uacute;mero total de endere&ccedil;os IP de origem rastreados globalmente
podem ser controlados pela op&ccedil;&atilde;o 
<a href="options.html#limit"><tt>src-nodes</tt> em tempo de execu&ccedil;&atilde;o</a>.

<dt><tt>max-src-nodes <i>n&uacute;mero</i></tt>
<dd>Quando op&ccedil;&atilde;o <tt>source-track</tt> &eacute; usada,
<tt>max-src-nodes</tt> limitar&aacute; o n&uacute;mero de endere&ccedil;os 
IP de origem que podem criar estados simult&acirc;neamente.
Esta op&ccedil;&atilde;o s&oacute; pode ser usada com  
<tt>source-track rule</tt>.

<dt><tt>max-src-states <i>n&uacute;mero</i></tt>
<dd>Quanto a op&ccedil;&atilde;o <tt>source-track</tt> &eacute; usada,
<tt>max-src-states</tt> limitar&aacute; o n&uacute;mero de estados
simult&acirc;neos que podem ser criados por endere&ccedil;os IP de origem. 
O escopo deste limite (ex., somente estados criados por esta regra ou
estados criados por todas a regras que usam  <tt>source-track</tt>)
&eacute; dependente da op&ccedil;&atilde;o <tt>source-track</tt> especificada.
</dl>

<p>
Op&ccedil;&otilde;es s&atilde;o especificadas dentro de par&ecirc;nteses e
imediatemente depois de uma das palavras-chave
(<tt>keep state</tt>, <tt>modulate state</tt> ou <tt>synproxy state</tt>).
M&uacute;ltiplas op&ccedil;&otilde;es s&atilde;o separadas por virgulas.
No OpenBSD 4.1 e posterior, a opc&atilde;o <tt>keep state</tt> se tornou
padr&atilde;o para todas as regras de filtragem.
Apesar disso, quanto estiver especificando op&ccedil;&otilde;es stateful, uma
das palavras-chave ainda deve ser usada na frente das op&ccedil;&otilde;es

<p>
Uma regra de exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
A regra acima define o seguinte comportamento:

<ul>
<li>Limita o n&uacute;mero m&aacute;ximo de estados que esta regra pode criar para 200
<li>Habilita rastreamento por origem; limita a cria&ccedil;&atilde;o de estados baseada em estados criados apenas por esta regra
<li>Limita o n&uacute;mero m&aacute;ximo de n&oacute;s que podem criar
estados simult&acirc;neamente para 100
<li>Limita o n&uacute;mero m&aacute;ximo de estados simult&acirc;neos por
IP de origem para 3
</ul>

<p>
Um conjunto separado de restri&ccedil;&otilde;es pode ser colodado em
conex&otilde;es TCP stateful que completaram o 3-way handshake.

<dl>
<dt><tt>max-src-conn <i>n&uacute;mero</i></tt>
<dd>Limita o n&uacute;mero m&aacute;ximo de conex&otilde;es TCP simult&acirc;neas que completaram o 3-way handshake que um &uacute;nico host pode fazer.
<dt><tt>max-src-conn-rate <i>n&uacute;mero</i> / <i>intervalo</i></tt>
<dd>Limita a taxa de novas conex&otilde;es a uma certa quantidade por intervalo de tempo.
</dl>

<p>
Ambas as op&ccedil;&otilde;es invocam automaticamente a op&ccedil;&atilde;o
<tt>source-track rule</tt> e s&atilde;o incompat&iacute;veis com <tt>source-track global</tt>. 

<p>
Uma vez que estes limites s&atilde;o colocados em conex&otilde;es TCP que
completaram o 3-way handshake, a&ccedil;&otilde;es mais agressivas
podem ser tomadas em endere&ccedil;os IP ofensivos. 

<dl>
<dt><tt>overload &lt;<i>tabela</i>&gt;</tt>
<dd>Coloca um endere&ccedil;o IP de um host ofensivo em uma tabela.
<dt><tt>flush [global]</tt>
<dd>Mata qualquer outro estado que combine com esta regra e que foi criado
por este IP de origem.
Quando <tt>global</tt> &eacute; especificado, mata todos os estados combinando
este IP de origem, 
</dl>

<p>
Um exemplo:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Isto faz o seguinte:

<ul>
<li>Limita o n&uacute;mero m&aacute;ximo de conex&otilde;es por origem para 100
<li>Limita a taxa de n&uacute;mero de conex&otilde;es para 15 em medi&ccedil;&atilde;o de 5 segundos
<li>Coloca o endere&ccedil;o IP de qualquer host que quebre estes limites na tabela <tt>&lt;abusive_hosts&gt;</tt>
<li>Para qualquer endere&ccedil;o IP ofensivo, limpa qualquer estado criado por esta regra. 
</ul>

<a name="tcpflags"></a>
<h2>Flags TCP</h2>
Comparar pacotes TCP com base em seus flags &eacute; geralmente usado na 
filtragem de pacotes tentando abrir novas conex&otilde;es. Os flags TCP e 
seu significado s&atilde;o listados aqui:
<ul>
<li><b>F</b> : FIN  - Finish (Final); t&eacute;rmino da sess&atilde;o
<li><b>S</b> : SYN  - Synchronize; indica requisi&ccedil;&atilde;o de conex&atilde;o
<li><b>R</b> : RST  - Reset; derruba uma conex&atilde;o
<li><b>P</b> : PUSH - Push; o pacote &eacute; enviado imediatamente
<li><b>A</b> : ACK  - Acknowledgement (Reconhecimento)
<li><b>U</b> : URG  - Urgent (Urgente)
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo (Mensagem de Notifica&ccedil;&atilde;o 
de Congestionamento Expl&iacute;cita)
<li><b>W</b> : CWR  - Congestion Window Reduced (Janela de Congestionamento Reduzida)
</ul>

<p>
Para que o PF inspecione os flags TCP durante a avalia&ccedil;&atilde;o de uma regra, 
a palavra-chave <tt>flags</tt> &eacute; usada com a seguinte sintaxe:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
A parte <tt><i>mask</i></tt> diz ao PF para verificar apenas os flags indicados
e a parte <tt><i>check</i></tt> informa qual(is) flag(s) devem estar "setados" no 
cabe&ccedil;alho para que o pacote case com a regra.
Usando a palavra-chave <tt>any</tt> permite que qualquer combina&ccedil;&atilde;o
de flags seja configurada no cabe&ccedil;lho.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
A regra acima autoriza tr&aacute;fego TCP com a flag SYN setada, mas verifica 
somente os flags SYN e ACK. Um pacote com os flags SYN e ECE combinam 
com a regra acima, enquanto um pacote com SYN e ACK ou somente ACK n&atilde;o 
combina.

<p>
No OpenBSD 4.1 e posterior, a flag padr&atilde;o aplicada em regras TCP &eacute; 
<tt>flags S/SA</tt>.
Cobinado com o padr&atilde;o de regras de filtragem <tt>keep state</tt> do OpenBSD 4.1,
estas duas regras s&atilde;o equivalentes:
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state<br>
pass out on fxp0 proto tcp all
</tt>
</blockquote>

<p>
Cada regra ir&aacute; combinar com pacotes TCP com a flag SYN configurada e a
flag ACK limpa e criar&aacute; uma entrada na tabela de estados.
A flag padr&atilde;o pode ser substitu&iacute;da usado a op&ccedil;&atilde;o
<tt>flags</tt> como descrito acima.

<p>
No OpenBSD 4.0 e anteriores, n&atilde;o existia uma flag padr&atilde;o aplicada
em todas as regras de filtragem.
Cada regra tinha que especificar qual(ais) flag(s) e tamb&eacute;m tinham que
usar explicitamente a op&ccedil;&atilde;o <tt>keep state</tt>.
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Deve-se tomar cuidado ao usar flags -- entenda o que voc&ecirc; est&aacute; fazendo e o 
porqu&ecirc;, e tenha cuidado com conselhos dados pelos outros, pois grande 
parte deles &eacute; incorreto.  Algumas pessoas sugerem a cria&ccedil;&atilde;o de estado
"somente se o flag SYN estiver setado e nenhum outro". Esta regra deve 
ficar asssim:
<pre>     
     . . . flags S/FSRPAUEW  <i>m&aacute; id&eacute;ia!!</i>
</pre>

<p>
A  teoria &eacute;, crie estado apenas no in&iacute;cio da sess&atilde;o TCP, e a 
sess&atilde;o deve ser iniciada somente com um flag SYN, nada mais.  O problema &eacute; que 
alguns sites est&atilde;o come&ccedil;ando a usar o flag ECN e qualquer um que use 
ECN e tente se conectar ao seu servidor ter&aacute; os pacotes rejeitados por 
esta regra. 
Uma abordagem muito melhor seria n&atilde;o especificar uma flag e deixar que o
PF aplique a flag padr&atilde;o para suas regras.
Se voc&ecirc; realmente precisa especificar flags ent&atilde;o esta
combina&ccedil;&atilde;o deve ser segura:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Al&eacute;m de ser pr&aacute;tico e seguro, tamb&eacute;m n&atilde;o &eacute; necess&aacute;rio 
verificar os flags FIN e RST caso o tr&aacute;fego passe antes por regras 
<a href="scrub.html">scrub</a>. No processo de normaliza&ccedil;&atilde;o o PF 
descartar&aacute; quaisquer pacotes que cheguem com combina&ccedil;&otilde;es 
de flags TCP inv&aacute;lidas (como SYN e RST) e normalizar&aacute; 
combina&ccedil;&atilde;oes ambiguas em potencial (como SYN e FIN).


<a name="synproxy"></a>
<h2>TCP SYN Proxy</h2>
<p>
Normalmente quando um cliente inicia uma conex&atilde;o TCP com o servidor, 
o PF transfere os pacotes do 
<a href=<a
href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>handshake</a> da forma como eles vieram. O PF, por&eacute;m possui a
habilidade de fazer proxy no handshake. 
Com o uso de proxy no handshake, o pr&oacute;prio PF completar&aacute; o handshake 
com o cliente, iniciar&aacute; um handshake com o servidor, e ent&atilde;o 
transferir&aacute; pacotes entre os dois.
O benef&iacute;cio deste procedimento &eacute; que nenhum pacote &eacute; enviado ao servidor 
antes do cliente completar o handshake. 
Isso evita que ataques TCP SYN flood spoofados atinjam o servidor 
porque uma conex&atilde;o spoofada n&atilde;o conseguir&aacute; completar o handshake. 

<p>
O TCP SYN proxy &eacute; habilitado usando as palavras-chave 
<tt>synproxy state</tt> em regras de filtragem. Exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Aqui, as conex&otilde;es para o servidor web passar&atilde;o pelo proxy do PF.

<p>
Pela forma como o <tt>synproxy state</tt> funciona, ele tamb&eacute;m inclui as 
mesmas funcionalidades de <tt>keep state</tt> e <tt>modulate state</tt>.

<p>
O SYN proxy n&atilde;o funcionar&aacute; caso o PF esteja atuando numa 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>.

<a name="antispoof"></a>
<h2>Bloqueando Pacotes Spoofados</h2>
"Spoofing" &eacute; quando um usu&aacute;rio malicioso falsifica o endere&ccedil;o IP de origem 
nos pacotes transmitidos por ele para esconder seu endere&ccedil;o real ou
personificar outro n&oacute; na rede. Uma vez que o usu&aacute;rio tenha spoofado seu 
endere&ccedil;o ele pode lan&ccedil;ar um ataque na rede sem que sua verdadeira origem seja 
descoberta, ou ainda tentar ganhar acesso a servi&ccedil;os restritos a determinados
endere&ccedil;os IP.

<p>
O PF oferece alguma prote&ccedil;&atilde;o contra spoofing atrav&eacute;s do uso da palavra-chave
<tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Especifica que, pacotes combinando com a regra devem ser logados via
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.2"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Caso um pacote case com a regra ela ser&aacute; considerada a regra 
"vencedora" e a avalia&ccedil;&atilde;o das regras terminar&aacute;. 

<dt><tt><i>interface</i></tt>
<dd>A interface de rede onde ativar a prote&ccedil;&atilde;o antispoof. Pode ser
tamb&eacute;m uma <a href="macros.html#lists">lista</a> de interfaces.

<dt><tt><i>af</i></tt>
<dd>A fam&iacute;lia de endere&ccedil;amento onde se deve ativar a prote&ccedil;&atilde;o 
antispoof, <tt>inet</tt> para IPv4 ou <tt>inet6</tt> para IPv6.
</dl>

<p>
Exemplo:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Quando as regras s&atilde;o carregadas, quaisquer ocorr&ecirc;ncias da palavra 
<tt>antispoof</tt> s&atilde;o expandidas em duas regras de filtragem. Assumindo que 
a interface <tt>fxp0</tt> possui endere&ccedil;o IP 10.0.0.1 e m&aacute;scara de rede 
255.255.255.0 (ex. /24), a regra <tt>antispoof</tt> acima ser&aacute; expandida para:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Estas regras fazem duas coisas:
<ul>
<li>Bloqueia todo tr&aacute;fego vindo da rede 10.0.0.0/24 que <i>n&atilde;o</i> venha
por <tt>fxp0</tt>. Como a rede 10.0.0.0/24 est&aacute; na interface <tt>fxp0</tt>, 
pacotes com endere&ccedil;o de origem neste bloco de rede jamais devem ser vistos 
em qualquer outra interface.
<li>Bloqueia todo tr&aacute;fego vindo de 10.0.0.1, o endere&ccedil;o IP 
em <tt>fxp0</tt>.
A m&aacute;quina nunca deve enviar pacotes para ela mesma pela interface externa, 
portanto qualquer pacote chegando com endere&ccedil;o de origem da pr&oacute;pria 
m&aacute;quina deve ser considerado malicioso.
</ul>

<p>
<b>NOTA</b>: As regras de filtragem <tt>antispoof</tt> expandidas 
tamb&eacute;m ir&atilde;o bloquear pacotes enviados pela interface de 
loopback para 
o endere&ccedil;o local. 
Recomenda-se evitar qualquer tipo de filtragem na interface de 
loopback, mas isto se torna uma necessidade quando usamos regras 
antispoof:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
O uso de <tt>antispoof</tt> deve ser restrito a interfaces que possuam
endere&ccedil;o IP. Usar <tt>antispoof</tt> numa interface sem um 
endere&ccedil;o IP resultar&aacute; em regras como:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Nestas regras existe o risco de se bloquear <i>todo</i> tr&aacute;fego 
entrante em <i>todas</i> as interfaces.

<a name="urpf"></a>
<h2>Encaminhamento Unicast Reverso</h2>

<p>
A partir do <a href="../../../40.html">OpenBSD 4.0</a>, PF oferece
Encaminhamento Unicast Reverso (uRPF).
Quanto um pacote &eacute; verificado pelo uRPF, o endere&ccedil;o IP de origem
do pacote &eacute; procurado na tabela de roteamento.
Se a interface de sa&iacute;da encontrada na tabela de roteamento &eacute; a
mesma da interface que o pacote entrou, ent&atilde;o a
verifica&ccedil;&atilde;o uRPF passa.
Se a interface n&atilde;o combinar, ent&atilde;o &eacute; poss&iacute;vel que o
pacote tenha seu endere&ccedil;o de origem falsificado (spoofed).

<p>
A verifica&ccedil;&atilde;o uRPF pode ser aplicada aos pacotes usando a palavra-chave
<tt>urpf-failed</tt> nas regras de filtragem:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Note que a verifica&ccedil;&atilde;o uRPF s&oacute; faz sentido em um ambiente
onde o roteamento seja sim&eacute;trico.

<p>
uRPF oferece a mesma funcionalidade que as regras
<a href="#antispoof">antispoof</a>.


<a name="osfp"></a>
<h2>Detec&ccedil;&atilde;o Passiva de Sistema Operacional</h2>

<p>
Passive OS Fingerprinting (OSFP) &eacute; um m&eacute;todo para 
identificar de maneira passiva o sistema operacional de um host remoto 
com base em certas caracter&iacute;sticas dos pacotes TCP SYN gerados 
pelo host.
Esta informa&ccedil;&atilde;o pode ent&atilde;o ser usada como
crit&eacute;rio em regras de filtragem.

<p>
O PF determina o sistema operacional remoto comparando as caracter&iacute;sticas 
do pacote TCP SYN contra um 
<a href="options.html#fingerprints">arquivo de impress&otilde;es digitais</a>, que por 
padr&atilde;o &eacute; 
<a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.2"
><tt>/etc/pf.os</tt></a>. 
Quando o PF est&aacute; habilitado, a lista atual de impress&otilde;es digitais pode ser vista 
com o comando:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Numa regra de filtragem, a impress&atilde;o digital pode ser especificada 
pela classe do SO, vers&atilde;o ou subtipo/revis&atilde;o.
Cada um dos itens &eacute; listado como sa&iacute;da do comando <tt>pfctl</tt> 
mostrado acima. Para especificar uma impress&atilde;o digital numa regra 
de filtragem, a palavra-chave <tt>os</tt> deve ser usada.

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
A classe de sistema operacional <tt>unknown</tt> permite o enquadramento 
de pacotes quanto a impress&atilde;o digital do SO n&atilde;o &eacute;
conhecida.

<p>
<font color="#ff0000">TOME NOTA</font>:
<ul>
  <li>Impress&otilde;es digitais de sistemas operacionais ocasionalmente 
  podem estar erradas, devido a pacotes spoofados e/ou trabalhados 
  para que pare&ccedil;am originados de um sistema operacional em espec&iacute;fico.
  <li>Determinadas revis&otilde;es ou patches de um sistema operacional 
  podem alterar o comportamento da pilha, fazendo com que ela n&atilde;o 
  combine com a impress&atilde;o digital do arquivo ou at&eacute; mesmo fique igual 
  a de outro.
  <li>OSFP funciona apenas com pacotes TCP SYN; n&atilde;o funcionar&aacute; 
  com outros protocolos ou em conex&otilde;es j&aacute; estabelecidas.
</ul>

<a name="ipopts"></a>
<h2>Op&ccedil;&otilde;es IP</h2>
Por padr&atilde;o, o PF bloqueia pacotes com op&ccedil;&otilde;es IP setadas. Isso pode 
dificultar o trabalho de ferramentas de "detec&ccedil;&atilde;o de sistema operacional" 
como nmap. Caso possua alguma aplica&ccedil;&atilde;o que fa&ccedil;a uso destes pacotes, como 
multicast ou IGMP, voc&ecirc; pode usar a diretiva <tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Exemplo de Arquivo de Regras</h2>
Abaixo est&aacute; um arquivo de exemplo para regras de filtragem. A m&aacute;quina 
rodando PF funciona como firewall entre uma pequena rede interna e a Internet. 
S&atilde;o mostradas apenas as regras de filtragem;
<a href="queueing.html">queueing</a>, 
<a href="nat.html"><tt>nat</tt></a>, 
<a href="rdr.html"><tt>rdr</tt></a>, 
etc., foram deixadas fora deste exemplo.
<br>
<br>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# tabela contendo todos endere&ccedil;os IP atribu&iacute;dos ao firewall
table &lt;firewall&gt; const { self }

# n&atilde;o filtra na interface loopback
set skip on lo0

# faz scrub em pacotes que chegam
scrub in all

# define o pol&iacute;tica padr&atilde;o
block all

# ativa prote&ccedil;&atilde;o contra spoof para todas as interfaces
block in quick from urpf-failed

# permite conex&otilde;es ssh vindas apenas da rede interna, e se for 
# de um computador confi&aacute;vel, 192.168.0.15. usa "block return" de 
# forma que um TCP RST &eacute; enviado para derrubar conex&otilde;es bloqueadas.
# usa "quick" para que esta regra n&atilde;o seja invalidada por alguma 
# regra "pass" abaixo.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh 

# aceita tr&aacute;fego indo e vindo para a rede interna.
# estas regras criar&atilde;o estados devido a op&ccedil;&atilde;o
# padr&atilde;o "keep state" que ser&aacute; automaticamente aplicada.
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# aceita tcp, udp, e icmp saindo pela interface externa (Internet). 
# conex&otilde;es tcp configuradas com modulate, udp/icmp ser&atilde;o
# rastredos de forma stateful.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# permite conex&otilde;es ssh na interface externa contanto que N&Atilde;O sejam 
# destinadas ao firewall (ex., conex&otilde;es destinadas a m&aacute;quinas na rede
# local). loga os pacotes iniciais para que mais tarde possamos saber
# quem tentou se conectar. usa tcp syn proxy nas conex&otilde;es.
# A flag padr&atilde;o "S/SA" ser&aacute; automaticamente aplicada na regra
# pelo PF.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conte&uacute;do</a>]
[<a href="nat.html">Pr&oacute;ximo: Tradu&ccedil;&atilde;o do Endere&ccedil;o de Rede (NAT)</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[voltar]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.47 ]<br>
$Translation: filter.html,v 1.9 2007/11/29 02:01:46 dsantos Exp $<br>
-->
$OpenBSD: filter.html,v 1.9 2007/12/01 10:39:11 tobias Exp $ 
</small>

</body>
</html>
