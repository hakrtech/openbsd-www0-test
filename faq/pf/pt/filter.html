<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtragem de Pacotes</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="nat.html">Próximo: Tradução do Endereço de Rede ("NAT")</a>]

<h1><font color="#e00000">PF: Filtragem de Pacotes</font></h1>

<hr>

<h3>Conteúdo</h3>
<ul>
<li><a href="#intro">Introdução</a>
<li><a href="#syntax">Sintaxe das Regras</a>
<li><a href="#defdeny">Negar por Padrão</a>
<li><a href="#pass">Passando Tráfego</a>
<li><a href="#quick">A Palavra-Chave <tt>quick</tt></a>
<li><a href="#state">Mantendo o Estado</a>
<li><a href="#udpstate">Mantendo o Estado para UDP</a>
<li><a href="#stateopts">Opções de Rastreamento de Estado</a>
<li><a href="#tcpflags">Flags TCP</a>
<li><a href="#synproxy">TCP SYN Proxy</a>
<li><a href="#antispoof">Bloqueando Pacotes Spoofados</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Detecção Passiva de Sistema Operacional</a>
<li><a href="#ipopts">Opções IP</a>
<li><a href="#example">Exemplo de Arquivo de Regras</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Introdução</h2>
Filtragem de pacotes é o bloqueio ou liberação de maneira seletiva da
passagem de pacotes de dados, conforme eles atravessam a interface de
rede. O critério que o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.4"
>pf(4)</a> usa quando inspeciona pacotes é baseado na Camada 3
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) e Camada 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>). Os critérios mais usados são os endereços de origem e
destino, porta de origem e destino e protocolo.

<p>
Regras de filtragem especificam o critério em que o pacote deve se
enquadrar e a ação resultante, que pode ser bloqueio ou liberação,
tomada quando o pacote casa com a regra. As regras de filtragem
são avaliadas em seqüência, da primeira até a última.
A não ser que o pacote encontre um regra contendo a palavra-chave
<tt>quick</tt>, o mesmo será avaliado por <i>todas</i> as regras de
filtragem antes da ação final ser tomada. A última regra a casar é a
"vencedora" e dita qual ação tomar. Existe um <tt>pass all</tt>
implícito no início das regras de filtragem, que significa que caso o
pacote não case com nenhuma regra a ação resultante será <tt>pass</tt>.

<a name="syntax"></a>
<h2>Sintaxe das Regras</h2>
A forma geral <i>altamente simplificada</i> da sintaxe para regras de
filtragem é:
<blockquote>
<tt>
<i>ação</i> [<i>direção</i>] [log] [quick] [on <i>interface</i>]
[<i>af</i>] [proto <i>protocolo</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>ação</i></tt>
<dd>A ação executada em pacotes que casem com a regra, pode ser
<tt>pass</tt> ou <tt>block</tt>. A ação <tt>pass</tt> irá liberar a
passagem do pacote para posterior processamento pelo kernel, enquanto
que a ação <tt>block</tt> reagirá com base na opção
<a href="options.html#block-policy"><tt>block-policy</tt></a>.
A reação padrão pode ser sobrescrita especificando <tt>block drop</tt>
ou <tt>block return</tt> na regra.

<dt><tt><i>direção</i></tt>
<dd>A direção em que o pacote está se movendo na interface, pode ser
<tt>in</tt> ou <tt>out</tt>.

<dt><tt>log</tt>
<dd>Especifica que o pacote deve ser logado via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.4"
>pflogd(8)</a>. Se a regra cria um estado, somente o pacote que
estabeleceu o estado é logado.
Para logar todos pacotes, use <tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Se um pacote casar uma regra especificada com <tt>quick</tt>,
então essa regra é considerada final e a <tt><i>ação</i></tt>
especificada é executada.

<dt><tt><i>interface</i></tt>
<dd>O nome ou grupo da interface de rede onde o pacote está passando.
Interfaces podem ser adicionadas a um grupo usando o comando
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
Muitos grupos também são criados automaticamente pelo kernel:
<ul>
<li>O grupo <tt>egress</tt>, que contém a(s) interface(s) relativa(s)
    à rota padrão.
<li>O grupo da família de interfaces para as interfaces clonadas.
    Por exemplo: <tt>ppp</tt> ou <tt>carp</tt>.
</ul>
Fará com que a regra case com qualquer pacote atravessando qualquer
interface <tt>ppp</tt> ou <tt>carp</tt> respectivamente.

<dt><tt><i>af</i></tt>
<dd>A família de endereços do pacote, <tt>inet</tt> para IPv4 ou
<tt>inet6</tt> para IPv6. Geralmente o PF pode determinar essa
informação com base no(s) endereço(s) de origem e/ou destino do pacote.

<dt><tt><i>protocolo</i></tt>
<dd>O protocolo da Camada 4 do pacote:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Um nome de protocolo válido em
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
    ><tt>/etc/protocols</tt></a>
<li>Um número de protocolo entre 0 e 255
<li>Um grupo de protocolos utilizando uma
    <a href="macros.html#lists">lista</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt>
<dd>Os endereços de origem/destino no cabeçalho IP. Endereços podem
ser especificados como:
<ul>
<li>Um endereço IPv4 ou IPv6 simples.
<li>Um bloco de rede <a href="http://public.pacbell.net/dedicated/cidr.html"
    >CIDR</a>.
<li>Um nome de domínio totalmente qualificado, que será resolvido pelo
    DNS quando as regras forem carregadas. Todos os endereços IP
    resultantes serão substituídos na regra.
<li>O nome de uma interface de rede ou grupo. Quaisquer endereços IP na
    interface serão substituídos na regra.
<li>O nome de uma interface de rede seguido por uma
    <tt>/<i>máscara</i></tt> (i.e., <tt>/24</tt>). Cada endereço IP na
    interface é combinado com a máscara para formar um bloco de rede CIDR
    que será substituído na regra.
<li>O nome de uma interface de rede entre parênteses <tt>( )</tt>. Isso
    informa ao PF para atualizar a regra caso o(s) endereço(s) da
    interface em questão mude(m). Útil em interfaces que obtém seu
    endereço IP via DHCP ou dial-up, pois as outras regras não
    precisarão serem recarregadas toda vez que o endereço mudar.
<li>O nome de uma interface de rede seguido por algum destes
    modificadores:
    <ul>
    <li><tt>:network</tt> - substitui o bloco de rede CIDR (ex.,
        192.168.0.0/24)
    <li><tt>:broadcast</tt> - substitui o endereço de broadcast
        (ex., 192.168.0.255)
    <li><tt>:peer</tt> - substitui o endereço da outra ponta num
        link ponto-a-ponto
    </ul>
    <dl>
    <dd>Além disso, o modificador <tt>:0</tt> pode ser adicionado a um
    nome de interface ou qualquer um dos modificadores acima para dizer
    ao PF para não incluir aliases de endereços IP na substituição.
    Esses modificadores também podem ser usados quando a interface
    está entre parênteses.
    Exemplo: <tt>fxp0:network:0</tt>
    </dl>
<li>Uma <a href="tables.html">tabela</a>.
<li>A palavra-chave <tt>urpf-failed</tt> pode ser usada no
    endereço de origem para indicar que ele deve continuar
    através de uma <a href="#urpf">verificação uRPF</a>.
<li>Qualquer dos apresentados acima, mas negado usando o modificador
    <tt>!</tt> ("not") .
<li>Um grupo de endereços usando-se uma <a href="macros.html#lists">
    lista</a>.
<li>A palavra-chave <tt>any</tt> indicando todos os endereços
<li>A palavra-chave <tt>all</tt> que é um atalho para <tt>from any to
    any</tt>.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>A porta de origem/destino no cabeçalho da Camada 4 do pacote. Portas
podem ser especificadas da seguinte forma:
<ul>
<li>Um número entre 1 e 65535
<li>Nome de serviço válido em
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
    ><tt>/etc/services</tt></a>
<li>Um grupo de portas usando uma <a href="macros.html#lists">lista</a>
<li>Uma faixa:
	<ul>
	<li><tt>!=</tt> (diferente)
	<li><tt>&lt;</tt> (menor que)
	<li><tt>&gt;</tt> (maior que)
	<li><tt>&lt;=</tt> (menor ou igual a)
	<li><tt>&gt;=</tt> (maior ou igual a)
	<li><tt>&gt;&lt;</tt> (faixa)
	<li><tt>&lt;&gt;</tt> (faixa inversa)
	<dl>
	<dd>Os dois últimos são operadores binários (recebem dois
	argumentos) e não incluem os argumentos na faixa.
	</dl>
	<li><tt>:</tt> (faixa inclusiva)
	<dl>
	<dd>O operador de faixa inclusiva também é um operador binário
	e inclui os argumentos na faixa.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Especifica as flags que precisam estar definidas no cabeçalho TCP
quando for usado <tt>proto tcp</tt>. Flags são especificadas na forma:
<tt>flags <i>check</i>/<i>mask</i></tt>. Por exemplo: <tt>flags
S/SA</tt> - instrui o PF a verificar somente as flags S e A (SYN e ACK)
e casar somente se apenas a flag SYN estiver "ligada".
No OpenBSD 4.1 e versões recentes, as flags padrão <tt>S/SA</tt> são
aplicadas em todas as regras de filtragem TCP.

<dt><tt><i>state</i></tt>
<dd>Especifica se a informação de estado deve ser mantida em pacotes
que casem com a regra.
<ul>
<li><tt>keep state</tt> - funciona com TCP, UDP e ICMP.
    No OpenBSD 4.1 e versões recentes, essa opção é o padrão para todas
    as regras de filtragem.
<li><tt>modulate state</tt> - funciona apenas com TCP. O PF irá gerar
    Números de Seqüência Inicial (ISNs) seguros para pacotes que casem
    com essa regra.
<li><tt>synproxy state</tt> - faz proxy de pedidos de conexão TCP para
    ajudar a proteger servidores contra floods de pacotes SYN TCP
    spoofados. Essa opção inclui a funcionalidade <tt>keep state</tt> e
    <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Negar por Padrão</h2>
A prática recomendada ao configurar um firewall é usar uma política
"negar por padrão". Isto é, bloquear <i>tudo</i> e depois ir
permitindo certos tipos de tráfego através do firewall. Essa é a
abordagem recomendada por ser mais cautelosa, além de facilitar a
configuração das regras.

<p>
Para criar uma política de filtragem negar por padrão, as primeiras
duas regras de filtragem devem ser:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Isso irá bloquear todo o tráfego em todas interfaces em qualquer
direção, de qualquer lugar para qualquer lugar.

<a name="pass"></a>
<h2>Passando Tráfego</h2>
O tráfego agora deve ser explicitamente permitido ou será barrado pela
política padrão do firewall. É aqui que os critérios de filtragem
como porta de origem/destino, endereço de origem/destino e protocolo
entram em cena. Sempre que o tráfego tiver permissão de cruzar o
firewall, as regras devem ser escritas da maneira mais restritiva
possível. Isso é para nos certificarmos de que o tráfego válido e
somente tráfego válido, terá permissão para passar.

<p>
Alguns exemplos:
<blockquote>
<tt>
# Autoriza o tráfego entrando na interface dc0<br>
# vindo da rede local 192.168.0.0/24,<br>
# e indo para a máquina OpenBSD com endereço IP 192.168.0.1.<br>
# Também permite o tráfego de retorno saindo da interface dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Autoriza o tráfego TCP chegando em fxp0 e indo para o servidor web<br>
# rodando na máquina OpenBSD. O nome da interface, fxp0, é usado como<br>
# endereço de destino, para que apenas pacotes destinados à<br>
# máquina OpenBSD casem com a regra.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>A palavra-chave <tt>quick</tt></h2>
Como dito anteriormente, cada pacote é avaliado pelas regras de
filtragem de cima para baixo. Por padrão, o pacote é marcado para
passagem, o que pode ser alterado por qualquer regra e depois alterado
novamente várias vezes antes do fim das regras de filtragem. <b>A última
regra que casa "vence".</b>  Mas, há uma exceção à regra: A opção
<tt>quick</tt> numa regra de filtragem tem o efeito de cancelar o
processamento de qualquer outra regra que venha em seguida e executa
imediatamente a ação especificada.
Vejamos alguns exemplos:

<p>
Errado:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Nesse caso, a linha <tt>block</tt> será avaliada, mas jamais terá efeito
algum, pois é seguida de uma linha que permite a passagem de tudo.

<p>
Melhor:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Essas regras são avaliadas de maneira ligeiramente diferente.
Caso a linha <tt>block</tt> case com a regra, devido ao uso da opção
<tt>quick</tt>, o pacote será bloqueado e o restante das regras serão
ignoradas.

<a name="state"></a>
<h2>Mantendo o Estado</h2>
Uma das características importantes do Packet Filter é
"manter o estado das conexões" ou "stateful inspection". Stateful
inspection é a habilidade do PF em registrar o estado, ou progresso de
uma conexão de rede. Armazenando informações sobre o estado de cada
conexão numa tabela de estados, o PF pode rapidamente determinar se um
pacote passando pelo firewall pertence a uma conexão já estabelecida.
Caso afirmativo, ele passa direto pelo firewall sem ser avaliado pelas
regras.

<p>
Manter informações do estado das conexões traz muitas vantagens,
incluindo simplicidade na configuração das regras e melhor desempenho
na filtragem de pacotes. O PF pode criar entradas na tabela de estado
para pacotes indo em <i>qualquer</i> direção, o que significa que
regras de filtragem que autorizam o tráfego de retorno não precisam ser
escritas. E, como pacotes que possuem entradas na tabela de estado não
são avaliadas pelas regras, o tempo que o PF gasta no processamento
destes pode ser drasticamente reduzido.

<p>
Quando uma regra cria estado, o primeiro pacote
que casa com a regra cria um "estado" entre o transmissor e o receptor.
Agora, não somente os pacotes do transmissor para o receptor combinam
com a entrada na tabela e passam direto pelas regras, como também as
respostas do receptor.

<p>
A partir do OpenBSD 4.1, todas as regras de filtragem criam
automaticamente uma entrada de estado quando um pacote casa com a regra.
Em versões antigas do OpenBSD, a regra de filtragem tinha que
explicitamente usar a opção <tt>keep state</tt>.

<p>
Exemplo usando OpenBSD 4.1 e versões recentes:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Exemplo usando OpenBSD 4.0 e versões anteriores:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Isso permite qualquer tráfego TCP saindo pela interface <tt>fxp0</tt>,
bem como o tráfego retornando em resposta ao firewall. Além do recurso
de manutenção de estado ser uma excelente característica, seu uso ainda
melhora o desempenho do firewall, pois pesquisas na tabela de estado
são muito mais rápidas do que comparar o pacote contra todas as regras
de filtragem.

<p>
A opção <tt>modulate state</tt> funciona como a <tt>keep state</tt>,
exceto que ela se aplica apenas a pacotes TCP. Com
<tt>modulate state</tt>, o Número de Seqüência Inicial (ISN) de
conexões saindo do firewall é aleatório. Isso é útil para proteger
conexões iniciadas por certos sistemas operacionais que não fazem
um bom trabalho ao escolher ISNs.
Desde o OpenBSD 3.5, a opção <tt>modulate state</tt> pode ser usada
também em regras que especifiquem protocolos diferentes do TCP.

<p>
Mantendo estado em pacotes TCP, UDP, ICMP e modulando ISNs TCP:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Outra vantagem de manter o estado é que o tráfego ICMP correspondente
também passa pelo firewall. Por exemplo, se existe uma conexão TCP
passando através do firewall como "statefully" e chegar uma mensagem
ICMP "source-quench" referenciando essa conexão TCP, ela será
identificada como pertencendo a uma entrada válida na tabela de estado
e passará direto pelo firewall.

<p>
O escopo de uma entrada na tabela de estado é controlado globalmente
pela opção <a href="options.html#state-policy"><tt>state-policy</tt></a>
em tempo de execução, e com base nas regras de estado pelas
palavras-chave <tt>if-bound</tt>, <tt>group-bound</tt> e
<tt>floating</tt>.
Essas palavras-chave usadas nas regras têm o mesmo efeito de
quando são usadas na opção <tt>state-policy</tt>. Exemplo:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Essa regra define que para um pacote casar com a entrada na tabela de
estado, ele deve estar transitando na interface <tt>fxp0</tt>.


<p>
Perceba que para regras
<a href="nat.html"><tt>nat</tt></a>,
<a href="nat.html#binat"><tt>binat</tt></a> e
<a href="rdr.html"><tt>rdr</tt></a>, é implícita
a criação de estados para conexões válidas desde que os pacotes passem
pelas regras de filtragem.

<a name="udpstate"></a>
<h2>Mantendo Estado Para UDP</h2>
Algumas vezes você pode ouvir que, "Não se pode criar estados para
conexões UDP, pelo fato do UDP ser um protocolo que não mantém o
estado nas conexões!". Enquanto é verdade que uma sessão de
comunicação UDP não possui nenhum conceito de estado (um início e fim
explícito na comunicação), isso não causa nenhum impacto na habilidade
do PF em criar estados para sessões UDP. No caso de protocolos sem
pacotes de "início" e "fim", o PF simplesmente mantém um registro do
tempo desde a última ocorrência de um pacote para dada conexão. Caso
o tempo de espera seja atingido, o registro de estado é eliminado.
Valores para esse intervalo podem ser definidos na seção
<a href="options.html">opções</a> do arquivo <tt>pf.conf</tt>.

<a name="stateopts"></a>
<h2>Opções de Rastreamento de Estado</h2>
Regras de filtragem que criam entradas na tabela de estados podem
especificar várias opções para controlar o comportamento resultante
da criação de estados.
As seguintes opções estão disponíveis:

<dl>
<dt><tt>max <i>número</i></tt>
<dd>Limita o número máximo de estados que a regra pode criar para
<i>número</i>.
Se o máximo for alcançado, pacotes que normalmente criariam estados
decaem para casar com a regra até que o número de estados existentes
diminua até um número abaixo do limite.

<dt><tt>no state</tt>
<dd>Previne a regra de criar automaticamente uma entrada na tabela de
estados.

<dt><tt>source-track</tt>
<dd>Essa opção habilita o rastreamento do número de estados criados
por endereço IP de origem.
Essa opção tem dois formatos:
       <ul>
       <li><tt>source-track rule</tt> - O número máximo de estados
           criados por essa regra é limitado pelas opções
           <tt>max-src-nodes</tt> e <tt>max-src-states</tt>
           da regra. Somente estados criados por essa regra em
           particular conta para o limite da regra.
       <li><tt>source-track global</tt> - O número de estados criados
           por todas as regras que usam essa opção é limitado.
           Cada regra pode especificar diferentes opções
           para <tt>max-src-nodes</tt> e <tt>max-src-states</tt>,
           contudo estados criados por qualquer regra participante
           conta cada limite de regra individualmente.
       </ul>
O número total de endereços IP de origem rastreados globalmente pode
ser controlado pela opção
<a href="options.html#limit"><tt>src-nodes</tt> em tempo de execução</a>.

<dt><tt>max-src-nodes <i>número</i></tt>
<dd>Quando a opção <tt>source-track</tt> é usada,
<tt>max-src-nodes</tt> limitará o número de endereços IP de origem
que podem criar estados simultaneamente.
Essa opção só pode ser usada com uma regra <tt>source-track</tt>.

<dt><tt>max-src-states <i>número</i></tt>
<dd>Quando a opção <tt>source-track</tt> é usada,
<tt>max-src-states</tt> limitará o número de estados simultâneos
que podem ser criados por endereço IP de origem.
O escopo desse limite (i.e., estados criados por somente essa regra ou
estados criados por todas as regras que usam  <tt>source-track</tt>)
é dependente da opção <tt>source-track</tt> especificada.
</dl>

<p>
Opções são especificadas dentro de parênteses e imediatamente depois
de uma das palavras-chave de estado (<tt>keep state</tt>,
<tt>modulate state</tt>, ou <tt>synproxy state</tt>).
Múltiplas opções são separadas por vírgulas.
No OpenBSD 4.1 e versões recentes, a opção <tt>keep state</tt> se tornou
o padrão implícito para todas as regras de filtragem.
A despeito disso, quando especifica opções stateful, uma das
palavras-chave deve ainda ser usada antes das opções.


<p>
Uma regra de exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
A regra acima define o seguinte comportamento:

<ul>
<li>Limita o número máximo de estados que essa regra pode criar para 200
<li>Habilita rastreamento por origem; limita a criação de estados
    baseada em estados criados apenas por essa regra
<li>Limita o número máximo de nós que podem criar estados
    simultaneamente para 100
<li>Limita o número máximo de estados simultâneos por
    IP de origem para 3
</ul>

<p>
Um conjunto separado de restrições pode ser colocado em conexões
TCP stateful que completaram o "3-way handshake".

<dl>
<dt><tt>max-src-conn <i>número</i></tt>
<dd>Limita o número máximo de conexões TCP simultâneas que completaram
o "3-way handshake" que um único host pode fazer.
<dt><tt>max-src-conn-rate <i>número</i> / <i>intervalo</i></tt>
<dd>Limita a taxa de novas conexões a uma certa quantidade por
intervalo de tempo.
</dl>

<p>
Ambas as opções invocam automaticamente a opção
<tt>source-track rule</tt> e são incompatíveis com
<tt>source-track global</tt>.

<p>
Uma vez que esses limites são colocados em conexões TCP que
completaram o "3-way handshake", ações mais agressivas podem ser
tomadas em endereços IP ofensivos.

<dl>
<dt><tt>overload &lt;<i>tabela</i>&gt;</tt>
<dd>Coloca um endereço IP de um host ofensivo em uma tabela.
<dt><tt>flush [global]</tt>
<dd>Mata qualquer outro estado que case com essa regra e que foi
criado por esse IP de origem.
Quando <tt>global</tt> é especificado, mata todos os estados que casem
com esse IP de origem, sem levar em consideração qual regra criou o
estado.
</dl>

<p>
Um exemplo:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Isso faz o seguinte:

<ul>
<li>Limita o número máximo de conexões por origem para 100
<li>Limita a taxa de número de conexões para 15 em medição de 5 segundos
<li>Coloca o endereço IP de qualquer host que quebre esses limites na
    tabela <tt>&lt;abusive_hosts&gt;</tt>
<li>Para qualquer endereço IP ofensivo, limpa qualquer estado criado
    por essa regra.
</ul>

<a name="tcpflags"></a>
<h2>Flags TCP</h2>
Comparar pacotes TCP com base em suas flags é geralmente usado na
filtragem de pacotes tentando abrir novas conexões. As flags TCP e
seus significados são listados aqui:
<ul>
<li><b>F</b> : FIN  - Finish (Final); término da sessão
<li><b>S</b> : SYN  - Synchronize; indica requisição de conexão
<li><b>R</b> : RST  - Reset; derruba uma conexão
<li><b>P</b> : PUSH - Push; o pacote é enviado imediatamente
<li><b>A</b> : ACK  - Acknowledgement (Reconhecimento)
<li><b>U</b> : URG  - Urgent (Urgente)
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo (Mensagem de
    Notificação de Congestionamento Explícita)
<li><b>W</b> : CWR  - Congestion Window Reduced (Janela de
    Congestionamento Reduzida)
</ul>

<p>
Para que o PF inspecione as flags TCP durante a avaliação de uma regra,
a palavra-chave <tt>flags</tt> é usada com a seguinte sintaxe:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
A parte <tt><i>mask</i></tt> diz ao PF para verificar apenas as flags
indicadas e a parte <tt><i>check</i></tt> informa a(s) flag(s) que devem
estar "ligadas" no cabeçalho para que o pacote case com a regra.
O uso da palavra-chave <tt>any</tt> permite que qualquer combinação de
flags estejam definidas no cabeçalho.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
A regra acima autoriza tráfego TCP com a flag SYN definida, mas verifica
somente as flags SYN e ACK. Um pacote com as flags SYN e ECE casa
com a regra acima, enquanto um pacote com SYN e ACK ou somente ACK não
casa.

<p>
No OpenBSD 4.1 e versões recentes, as flags aplicadas por padrão nas
regras TCP é <tt>flags S/SA</tt>.
Combinando com o padrão do OpenBSD 4.1 de <tt>"manter o estado"</tt> nas
regras de filtragem, estas duas regras se tornaram equivalente:
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state<br>
pass out on fxp0 proto tcp all
</tt>
</blockquote>

<p>
Cada regra vai casar pacotes TCP com a flag SYN "definida" e a flag ACK
"limpa" e cada um criará uma entrada de estado para os pacotes que
casaram.
As flags por padrão podem ser sobrescritas usando a opção <tt>flags</tt>
conforme descrito acima.

<p>
No OpenBSD 4.0 e versões anteriores, não existiam flags por padrão
aplicadas a nenhuma regra de filtragem.
Cada regra tinha que especificar a(s) flag(s) para casar e também
tinha que explicitar o uso da opção <tt>keep state</tt>.
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Deve-se tomar cuidado ao usar flags -- entenda o que você está fazendo
e o porquê, e tenha cuidado com conselhos dados pelos outros, pois
grande parte deles são incorretos. Algumas pessoas sugerem a criação de
estado "somente se a flag SYN estiver definida e nenhuma outra". Essa
regra deve ficar assim:
<pre>
     . . . flags S/FSRPAUEW  <i>má idéia!!</i>
</pre>

<p>
A teoria é, crie estado apenas no início da sessão TCP, e a sessão
deve ser iniciada somente com uma flag SYN, nada mais. O problema é que
alguns sites estão começando a usar a flag ECN e qualquer um que use
ECN e tente se conectar ao seu servidor terá os pacotes rejeitados por
essa regra. Uma abordagem muito melhor seria não especificar nenhuma
regra como um todo e deixar o PF aplicar as flags por padrão nas
suas regras.
Se você realmente necessita especificar suas próprias flags, então esta
combinação será segura:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Além de ser prático e seguro, também não é necessário verificar as
flags FIN e RST caso o tráfego passe antes por regras
<a href="scrub.html">scrub</a>. No processo de normalização o PF
descartará quaisquer pacotes que cheguem com combinações
de flags TCP inválidas (como SYN e RST) e normalizará combinações
ambíguas em potencial (como SYN e FIN).


<a name="synproxy"></a>
<h2>TCP SYN Proxy</h2>
<p>
Normalmente quando um cliente inicia uma conexão TCP com o servidor,
o PF transfere os pacotes
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>handshake</a>
da forma como eles vieram. O PF, porém, possui a habilidade de fazer
proxy no handshake. Com o uso de proxy no handshake, o próprio PF
completará o handshake com o cliente, iniciará um handshake com o
servidor, e então transferirá pacotes entre os dois.
O benefício desse procedimento é que nenhum pacote é enviado ao servidor
antes do cliente completar o handshake.
Isso evita que ataques TCP SYN flood spoofados atinjam o servidor
porque uma conexão spoofada não conseguirá completar o handshake.

<p>
O TCP SYN proxy é habilitado usando as palavras-chave
<tt>synproxy state</tt> em regras de filtragem. Exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Aqui, as conexões para o servidor web passarão pelo proxy do PF.

<p>
Pela forma como o <tt>synproxy state</tt> funciona, ele também inclui as
mesmas funcionalidades de <tt>keep state</tt> e <tt>modulate state</tt>.

<p>
O SYN proxy não funcionará caso o PF esteja atuando numa
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>.

<a name="antispoof"></a>
<h2>Bloqueando Pacotes Spoofados</h2>
"Spoofing" é quando um usuário malicioso falsifica o endereço IP de
origem nos pacotes transmitidos por ele para esconder seu endereço real
ou personificar outro nó na rede. Uma vez que o usuário tenha spoofado
seu endereço, ele pode lançar um ataque na rede sem que sua verdadeira
origem seja descoberta, ou ainda tentar ganhar acesso a serviços
restritos a determinados endereços IP.

<p>
O PF oferece alguma proteção contra spoofing através do uso da
palavra-chave <tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Especifica que, pacotes que casem com a regra devem ser logados via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.4"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Caso um pacote case com a regra, ela será considerada a regra
"vencedora" e a avaliação das regras terminará.

<dt><tt><i>interface</i></tt>
<dd>A interface de rede onde ativar a proteção antispoof. Pode ser
também uma <a href="macros.html#lists">lista</a> de interfaces.

<dt><tt><i>af</i></tt>
<dd>A família de endereçamento onde se deve ativar a proteção
antispoof, <tt>inet</tt> para IPv4 ou <tt>inet6</tt> para IPv6.
</dl>

<p>
Exemplo:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Quando as regras são carregadas, quaisquer ocorrências da palavra
<tt>antispoof</tt> são expandidas em duas regras de filtragem.
Assumindo que a interface <tt>fxp0</tt> possui endereço IP 10.0.0.1 e
máscara de rede 255.255.255.0 (i.e. /24), a regra <tt>antispoof</tt>
acima será expandida para:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Essas regras fazem duas coisas:
<ul>
<li>Bloqueia todo tráfego vindo da rede 10.0.0.0/24 que <i>não</i> venha
    por <tt>fxp0</tt>. Como a rede 10.0.0.0/24 está na interface
    <tt>fxp0</tt>, pacotes com endereço de origem nesse bloco de rede
    jamais devem ser vistos em qualquer outra interface.
<li>Bloqueia todo tráfego vindo de 10.0.0.1, o endereço IP em
    <tt>fxp0</tt>. A máquina nunca deve enviar pacotes para ela mesma
    pela interface externa, portanto qualquer pacote chegando com
    endereço de origem da própria máquina deve ser considerado
    malicioso.
</ul>

<p>
<b>NOTA</b>: As regras de filtragem <tt>antispoof</tt> expandidas
também bloquearão pacotes enviados pela interface de loopback para
o endereço local.
Recomenda-se evitar qualquer tipo de filtragem na interface de
loopback, mas isso se torna uma necessidade quando usamos regras
antispoof:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
O uso de <tt>antispoof</tt> deve ser restrito à interfaces que possuam
endereço IP. Usar <tt>antispoof</tt> numa interface sem um endereço
IP resultará em regras como:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Nessas regras existe o risco de se bloquear <i>todo</i> tráfego
entrante em <i>todas</i> as interfaces.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
A partir do <a href="../../../40.html">OpenBSD 4.0</a>, o PF oferece a
característica de "Unicast Reverse Path Forwarding" (uRPF).
Quando um pacote passa por uma checagem uRPF, o endereço
de origem do pacote é procurado na tabela de rotas.
Se a interface de saída encontrada na entrada da tabela de rotas é a
mesma que a interface que o pacote está chegando, então a checagem
uRPF libera a passagem do pacote.
Se as interfaces não casam, então é possível que o pacote teve seu
endereço de origem spoofado.

<p>
A checagem uRPF pode ser feita nos pacotes usando a palavra-chave
<tt>urpf-failed</tt> nas regras de filtragem:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Note que a checagem uRPF somente faz sentido em um ambiente onde
as rotas são simétricas.

<p>
uRPF fornece a mesma funcionalidade das regras
<a href="#antispoof">antispoof</a>.

<a name="osfp"></a>
<h2>Detecção Passiva de Sistema Operacional</h2>

<p>
Passive OS Fingerprinting (OSFP) é um método para identificar de maneira
passiva o sistema operacional de um host remoto com base em certas
características dos pacotes TCP SYN gerados pelo host.
Essa informação pode então ser usada como critério em regras de
filtragem.

<p>
O PF determina o sistema operacional remoto comparando as
características do pacote TCP SYN contra um
<a href="options.html#fingerprints">arquivo de impressões digitais</a>,
que por padrão é
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.4"
><tt>/etc/pf.os</tt></a>.
Quando o PF está habilitado, a lista atual de impressões digitais pode
ser vista com o comando:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Numa regra de filtragem, a impressão digital pode ser especificada
pela classe do SO, versão ou subtipo/revisão.
Cada um dos itens é listado como saída do comando <tt>pfctl</tt>
mostrado acima. Para especificar uma impressão digital numa regra
de filtragem, a palavra-chave <tt>os</tt> é usada:

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
A classe de sistema operacional <tt>unknown</tt> permite o enquadramento
de pacotes quando a impressão digital do SO não é conhecida.

<p>
<font color="#ff0000">TOME NOTA</font>:
<ul>
  <li>Impressões digitais de sistemas operacionais ocasionalmente
      podem estar erradas, devido a pacotes spoofados e/ou trabalhados
      para que pareçam originados de um sistema operacional em
      específico.
  <li>Determinadas revisões ou patches de um sistema operacional podem
      alterar o comportamento da pilha, fazendo com que ela não
      case com a impressão digital do arquivo ou até mesmo fique
      igual a de outro.
  <li>OSFP funciona apenas com pacotes TCP SYN; não funcionará
      com outros protocolos ou em conexões já estabelecidas.
</ul>

<a name="ipopts"></a>
<h2>Opções IP</h2>
Por padrão, o PF bloqueia pacotes com opções IP definidas. Isso pode
dificultar o trabalho de ferramentas de "detecção de sistema
operacional", como o nmap. Caso possua alguma aplicação que faça uso
desses pacotes, como multicast ou IGMP, você pode usar a diretiva
<tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Exemplo de Arquivo de Regras</h2>
Abaixo está um arquivo de exemplo para regras de filtragem. A máquina
rodando PF funciona como firewall entre uma pequena rede interna e a
Internet. São mostradas apenas as regras de filtragem;
<a href="queueing.html">queueing</a>,
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>,
etc., foram deixadas fora deste exemplo.
<br>
<br>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# Tabela contendo todos endereços IP atribuídos ao firewall
table &lt;firewall&gt; const { self }

# Não filtra na interface loopback
set skip on lo0

# Faz scrub em pacotes que chegam
scrub in all

# Define a política negar por padrão
block all

# Ativa proteção contra spoof para todas as interfaces
block in quick from urpf-failed

# Permite conexões ssh vindas apenas da rede interna, e se for
# de um computador confiável, 192.168.0.15. "block return" faz com que
# um pacote TCP RST seja enviado para derrubar conexões bloqueadas.
# "quick" assegura que esta regra não seja invalidada por alguma
# regra "pass" abaixo.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# Aceita tráfego indo e vindo para a rede interna.
# Estas regras criarão entradas na tabela de estado devido à opção
# padrão "keep state" que será aplicada automaticamente.
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# Aceita tcp, udp, e icmp saindo pela interface externa (Internet).
# Conexões tcp serão moduladas, udp/icmp manterão o estado.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# Permite conexões ssh na interface externa contanto que NÃO sejam
# destinadas ao firewall (ex., conexões destinadas à máquinas na rede
# local). Loga os pacotes iniciais para que mais tarde possamos saber
# quem tentou se conectar. Usa o tcp syn proxy nas conexões.
# As flags "S/SA" padrão serão aplicadas automaticamente na regra
# pelo PF.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="nat.html">Próximo: Tradução do Endereço de Rede ("NAT")</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[voltar]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.50 ]<br>
$Translation: filter.html,v 1.10 2009/03/11 00:52:55 dsantos Exp $<br>
-->
$OpenBSD: filter.html,v 1.10 2009/03/16 20:24:23 tobias Exp $
</small>

</body>
</html>
