<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Fila de Pacotes e Priorização</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2005 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="anchors.html">Anterior: Âncoras</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="pools.html">Próximo: Grupos de Endereços e Balanceamento de Carga</a>]

<p>
<h1><font color="#e00000">PF: Fila de Pacotes e Priorização</font></h1>


<hr>

<h3>Conteúdo</h3>
<ul>
<li><a href="#queueing">Enfileiramento</a>
<li><a href="#sched">Organizadores</a>
	<ul>
	<li><a href="#cbq">Filas Baseadas em Classe</a>
	<li><a href="#priq">Fila de Prioridade</a>
	<li><a href="#red">Random Early Detection</a>
	<li><a href="#ecn">Explicit Congestion Notification</a>
	</ul>
<li><a href="#altq">Configurando Filas</a>
<li><a href="#assign">Atribuindo Tráfego a uma Fila</a>
<li><a href="#example1">Exemplo #1: Rede Pequena, doméstica</a>
<li><a href="#example2">Exemplo #2: Rede Empresarial</a>
</ul>

<hr>

<a name="queueing"></a>
<h2>Enfileiramento</h2>
<p>
Enfileirar algo é armazená-lo em algum lugar, de maneira organizada,
enquanto aguarda processamento. Numa rede de computadores, quando
pacotes de dados são enviados por um host, eles entram numa fila
onde aguardam processamento pelo sistema operacional. O sistema
operacional decide qual fila e quais pacotes nessa fila devem ser
processados. A ordem em que o sistema operacional escolhe os
pacotes a processar pode afetar o desempenho da rede. Por exemplo,
imagine um usuário executando duas aplicações de rede:
SSH e FTP. Em condições ideais, os pacotes SSH devem ser processados
antes dos pacotes FTP por causa da natureza sensível do tempo no SSH;
quando uma tecla é acionada num cliente SSH, uma resposta imediata é
esperada, mas uma transferência FTP sendo atrasada por alguns segundos
extra, muito dificilmente será percebida. Mas o que acontece se o
roteador manipulando essas conexões processar um grande número de
pacotes da conexão FTP antes de processar a conexão SSH? Pacotes
da conexão SSH permanecerão na fila (ou possivelmente serão
descartados pelo roteador caso a fila não seja grande o suficiente
para manter todos os pacotes) e a sessão SSH parecerá muito lenta
e com atrasos. Modificando a estratégia de enfileiramento utilizada,
a largura de banda pode ser compartilhada entre diferentes aplicações,
usuários e computadores.

<p>
Perceba que o enfileiramento é útil somente para pacotes <i>saindo</i>.
Quando o pacote chega entrando numa interface, já é tarde demais para
ser enfileirado -- ele já consumiu largura de banda ao chegar na
interface que o recebeu. A única solução é habilitar enfileiramento
no roteador adjacente ou, se o host que recebeu o pacote está
funcionando como roteador, habilitar enfileiramento na interface
interna onde os pacotes saem do mesmo.

<a name="sched"></a>
<h2>Organizadores</h2>
O organizador (scheduler) é que decide quais filas processar e em que
ordem. Por padrão o OpenBSD usa um organizador FIFO (First In First Out).
Uma fila FIFO funciona como um caixa de supermercado -- o primeiro item
na fila é o primeiro a ser processado. Conforme novos pacotes chegam,
vão sendo colocados no fim da fila. Caso a fila fique cheia, e aqui
a analogia com o supermercado termina, novos pacotes vão sendo
descartados. Isso é conhecido como tail-drop.

<p>
OpenBSD suporta mais dois organizadores:
<ul>
<li>Filas Baseadas em Classe
<li>Fila de Prioridade
</ul>

<a name="cbq"></a>
<h3>Filas Baseadas em Classe</h3>
Filas Baseadas em Classe ou "Class Based Queuing" (CBQ) é um algoritmo
de enfileiramento que divide a largura de banda entre múltiplas filas
ou classes. Cada fila tem seu tráfego atribuído com base em endereço
de origem ou destino, número de porta, protocolo, etc. Uma fila pode
opcionalmente ser configurada para emprestar banda de sua fila pai,
caso ela não esteja utilizando sua largura total. As filas também
recebem uma prioridade de forma que as que contém tráfego interativo
como SSH, podem ter seus pacotes processados antes de filas contendo
tráfego normal, como FTP.

<p>
Filas CBQ são organizadas de forma hierárquica. No topo da hierarquia
está a fila raiz que define a quantidade total de banda disponível.
As outras filas são criadas sob a fila raiz, cada uma delas pode
receber parte da largura de banda da fila raiz. Por exemplo, filas
podem ser definidas assim:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>Queue A (1Mbps)
	<dd>Queue B (500Kbps)
	<dd>Queue C (500Kbps)
	</dl>
</dl>

<p>
Nesse caso, a largura de banda total disponível está definida para
2 megabits por segundo (Mbps). Essa banda é então dividida entre
outras três filas.

<p>
A hierarquia pode ser expandida definindo-se filas dentro de filas.
Para dividir a banda igualmente entre diferentes usuários e ainda
classificar seu tráfego de forma que certos protocolos não ocupem
a banda de outros, uma estrutura parecida com esta pode ser definida:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps)
		<dl>
		<dd>ssh (50Kbps)
		<dd>bulk (950Kbps)
		</dl>
	<dd>UserB (1Mbps)
		<dl>
		<dd>audio (250Kbps)
		<dd>bulk (750Kbps)
			<dl>
			<dd>http (100Kbps)
			<dd>other (650Kbps)
			</dl>
		</dl>
	</dl>
</dl>

<p>
Perceba que a cada nível a soma do total de banda vinculado a cada fila
nunca é maior que o valor da banda da fila raiz.

<p>
Uma fila pode ser configurada para emprestar banda de sua fila pai
caso as outras filas dentro da fila pai não estejam usando sua porção
e a banda esteja disponível. Considere a configuração a seguir:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps)
		<dl>
		<dd>ssh (100Kbps)
		<dd>ftp (900Kbps, borrow)
		</dl>
	<dd>UserB (1Mbps)
	</dl>
</dl>

<p>
Se o tráfego na fila <tt>ftp</tt> exceder os 900Kbps e o tráfego na fila
<tt>UserA</tt> for menor que 1Mbps (porque a fila <tt>ssh</tt> está
usando menos que 100Kbps), a fila <tt>ftp</tt> irá emprestar banda de
<tt>UserA</tt>. Dessa forma a fila <tt>ftp</tt> pode usar mais banda do
que foi definido a princípio quando necessário. Quando o tráfego na fila
<tt>ssh</tt> aumenta, a banda emprestada é devolvida.

<p>
CBQ atribui a cada fila um nível de prioridade. Filas com prioridade
alta tem preferência sobre outras com menor prioridade em caso de
congestionamento, contanto que estejam contidas na mesma fila pai (em
outras palavras, contanto que estejam no mesmo nível na hierarquia).
Filas com a mesma prioridade são processadas em sequência (round-robin).
Por exemplo:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps, priority 1)
		<dl>
		<dd>ssh (100Kbps, priority 5)
		<dd>ftp (900Kbps, priority 3)
		</dl>
	<dd>UserB (1Mbps, priority 1)
	</dl>
</dl>

<p>
O CBQ irá processar as filas <tt>UserA</tt> e <tt>UserB</tt>
em sequência -- nenhuma fila será preferida sobre a outra. Enquanto a
fila <tt>UserA</tt> está sendo processada, o CBQ também irá processar
suas subfilas. Nesse caso, a fila <tt>ssh</tt> tem prioridade maior e
terá tratamento preferencial sobre a fila <tt>ftp</tt> caso a rede
fique congestionada. Perceba como as filas <tt>ssh</tt> e <tt>ftp</tt>
não têm suas prioridades comparadas às filas <tt>UserA</tt> e
<tt>UserB</tt> pelo fato de elas não estarem no mesmo nível na
hierarquia.

<p>
Para um estudo mais detalhado sobre a teoria por trás do CBQ, por
favor consulte
<a href="http://www.icir.org/floyd/cbq.html">Referências sobre CBQ</a>.

<a name="priq"></a>
<h3>Fila de Prioridade</h3>
Fila de Prioridade ou "Priority Queuing" (PRIQ) designa várias filas
numa interface de rede com cada uma tendo um único nível de prioridade.
Uma fila com alta prioridade é <i>sempre</i> processada na frente
de uma fila com prioridade menor. 
Se duas ou mais filas estiverem atribuídas à mesma prioridade, então 
essas filas serão processadas de modo round-robin. 

<p>
A estrutura de enfileiramento no PRIQ é simples -- você não pode
definir filas dentro de filas. A fila raiz é definida, onde é
configurado o total de banda disponível, então subfilas são
definidas sob a raiz. Considere o exemplo a seguir:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>Queue A (priority 1)
	<dd>Queue B (priority 2)
	<dd>Queue C (priority 3)
	</dl>
</dl>

<p>
A fila raiz é definida possuindo 2Mbps de largura de banda disponível
e três subfilas são definidas. A fila com maior prioridade (o maior
número na prioridade) é servida primeiro. Quando todos os pacotes nessa
fila são processados, ou caso a fila esteja vazia, PRIQ vai para a
próxima fila com prioridade mais alta. Dentro da fila, os pacotes são
processados num sistema FIFO (First In First Out).

<p>
É importante notar quando estiver usando PRIQ que você deve planejar
suas filas com muito cuidado. Como PRIQ <i>sempre</i> processa a fila
com prioridade mais alta primeiro, é possível que uma fila com alta
prioridade faça com que pacotes destinados a outra fila com prioridade
menor atrasem muito ou até mesmo sejam descartados caso a fila preferida
esteja recebendo pacotes constantemente.

<a name="red"></a>
<h3>Random Early Detection</h3>
"Random Early Detection" (RED) é um algoritmo para evitar
congestionamento. Seu trabalho é evitar congestionamento na rede
certificando-se de que a fila nunca fique cheia. Ele realiza a tarefa
calculando continuamente o tamanho médio da fila e comparando-a com
dois valores, um valor mínimo e um valor máximo. Se o tamanho médio
da fila estiver abaixo do valor mínimo, então nenhum pacote será
descartado. Se a média estiver acima do valor máximo, então <i>todos</i>
os pacotes que chegarem serão descartados. Se a média estiver entre os
dois valores então os pacotes são descartados baseando-se no cálculo da
probabilidade obtido do tamanho médio da fila. Em outras palavras,
conforme o tamanho médio da fila se aproxima do valor máximo, mais
pacotes são descartados. Ao descartar pacotes, RED escolhe
aleatoriamente de quais conexões ele irá descartá-los.
Conexões usando grandes porções da largura de banda têm maior
probabilidade de terem seus pacotes descartados.

<p>
O RED é útil porque evita uma situação conhecida como sincronização
global e pode acomodar aumentos repentinos no tráfego.
Sincronização global refere-se a uma queda na capacidade de
transferência devido aos pacotes descartados de várias conexões ao
mesmo tempo. Por exemplo, caso o congestionamento ocorra num roteador
transmitindo tráfego para 10 conexões FTP e pacotes de todas (ou quase
todas) as conexões são descartados (como é o caso com enfileiramento 
FIFO), a capacidade média de transferência cairá
severamente. Essa não é uma situação ideal porque faz com que todas
as conexões FTP reduzam sua taxa de transferência e também significa
que a rede não é mais utilizada em todo seu potencial.
RED evita esse cenário escolhendo aleatoriamente quais conexões terão
pacotes descartados ao invés de escolher todas elas.
Conexões usando muita largura de banda tem chances maiores de terem seus
pacotes descartados. Dessa forma, conexões que ocupam muita banda serão
evitadas, o congestionamento será evitado, e sérias perdas nas taxas de
transferência não ocorrerão. Além disso, RED pode responder a aumentos
repentinos no tráfego pelo fato de começar a descartar pacotes
<i>antes</i> da fila ficar cheia. Quando o tráfego inesperado chegar,
existirá espaço suficiente na fila para armazenar os novos pacotes.

<p>
RED deve ser usado apenas quando o protocolo de transporte for capaz
de responder a indicadores de congestionamento da rede. Na maioria
dos casos isso significa que RED deve ser usado para enfileirar
tráfego TCP e nunca tráfego UDP ou ICMP.

<p>
Para uma discussão mais detalhada sobre a teoria por trás do RED, por
favor consulte
<a href="http://www.icir.org/floyd/red.html">Referências sobre RED</a>.

<a name="ecn"></a>
<h3>Explicit Congestion Notification</h3>
"Explicit Congestion Notification" (ECN) trabalha em conjunto com RED
para notificar dois hosts comunicando-se pela rede de quaisquer
congestionamentos no caminho de comunicação. Para fazer isso, RED
insere um marcador (flag) no cabeçalho do pacote ao invés de
descartá-lo. Supondo que o host enviando dados tem suporte a ECN, ele
pode identificar essa marcação e reduzir seu tráfego de acordo.

<p>
Para mais informações sobre ECN, por favor consulte a
<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">RFC 3168</a>.

<a name="altq"></a>
<h2>Configurando Filas</h2>
Desde o OpenBSD 3.0, a implementação de filas
<a href="http://www.csl.sony.co.jp/person/kjc/kjc/software.html#ALTQ"
>Alternate Queueing (ALTQ)</a> se tornou parte do sistema base. Desde
o OpenBSD 3.3, ALTQ foi integrado ao PF.
A implementação ALTQ do OpenBSD suporta os organizadores
Class Based Queueing (CBQ) e Priority Queueing (PRIQ). Ele também
suporta Random Early Detection (RED) e Explicit Congestion
Notification (ECN).

<p>
Pelo fato de ALTQ ter sido integrado ao PF, o PF deve estar habilitado
para que o sistema funcione. Instruções de como habilitar o PF podem ser
encontradas em <a href="config.html#activate">Começando</a>.

<p>
Filas são configuradas no arquivo <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.4"
>pf.conf</a></tt>. Existem dois tipos de diretivas utilizadas
para configuração de filas:
<ul>
<li><tt>altq on</tt> - habilita enfileiramento na interface, define qual
    organizador (scheduler) usar e cria a fila raiz
<li><tt>queue</tt> - define as propriedades da subfila
</ul>

<p>
A sintaxe para a diretiva <tt>altq on</tt> é:
<blockquote>
<tt>
altq on <i>interface scheduler</i> bandwidth <i>bw</i> qlimit
<i>qlim</i> \<br>
&nbsp;&nbsp;&nbsp;tbrsize <i>size</i> queue { <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>interface</i></tt> - a interface de rede onde o
    enfileiramento deve ser ativado.
<li><tt><i>scheduler</i></tt> - o organizador a ser utilizado. Valores
    possíveis são <tt>cbq</tt> e <tt>priq</tt>. Somente um organizador
    por vez pode estar ativo na interface.
<li><tt><i>bw</i></tt> - o valor total de banda disponível para o
    organizador. Isso pode ser especificado como um valor absoluto
    utilizando os sufixos <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt>, e
    <tt>Gb</tt> para representar bits, kilobits, megabits, e gigabits
    por segundo, respectivamente, ou como uma porcentagem da banda na
    <tt><i>interface</i></tt>.
<li><tt><i>qlim</i></tt> - o número máximo de pacotes que podem ser
    armazenados na fila. Esse parâmetro é opcional. O padrão é 50.
<li><tt><i>size</i></tt> - o tamanho do regulador token bucket em bytes.
    Caso não seja especificado, o tamanho é definido baseando-se na
    largura de banda da <tt><i>interface</i></tt>.
<li><tt><i>queue_list</i></tt> - uma lista de subfilas a serem criadas
    sob a fila raiz.
</ul>

<p>
Por exemplo:
<blockquote>
<tt>
altq on fxp0 cbq bandwidth 2Mb queue { std, ssh, ftp }
</tt>
</blockquote>
Isso habilitará o CBQ na interface <tt>fxp0</tt>. A largura de banda
total disponível é configurada para 2Mbps. Três subfilas são definidas:
<tt>std</tt>, <tt>ssh</tt> e <tt>ftp</tt>.

<p>
A sintaxe para a diretiva <tt>queue</tt> é:
<blockquote>
<tt>
queue <i>name</i> [on <i>interface</i>] bandwidth <i>bw</i> [priority
<i>pri</i>] [qlimit <i>qlim</i>] \<br>
&nbsp;&nbsp;&nbsp;<i>scheduler</i> ( <i>sched_options</i> )
{ <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>name</i></tt> - o nome da fila. Esse nome deve ser um dos
    nomes de filas definidos na diretiva <tt>altq on</tt>
<tt><i>queue_list</i></tt>. Para o <tt>cbq</tt>, também pode ser
    nome de fila definido numa diretiva <tt><i>queue_list</i></tt>,
    numa <tt>queue</tt> anterior. Nomes de filas não devem ser mais
    longos que 15 caracteres.
<li><tt><i>interface</i></tt> - a interface de rede onde a fila é
    válida. Esse valor é opcional, e quando não especificado,
    tornará a fila válida em todas as interfaces.
<li><tt><i>bw</i></tt> - a quantidade total de banda disponível
    para a fila. Pode ser especificado como um valor absoluto ou usando
    sufixos <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt>, e <tt>Gb</tt>,
    representando bits, kilobits, megabits, e gigabits por segundo,
    respectivamente, ou um valor em porcentagem da fila principal.
    Esse parâmetro só é aplicável quando usar o organizador
    <tt>cbq</tt>. Se não for especificado, o padrão é 100% da banda
    da fila pai.
<li><tt><i>pri</i></tt> - a prioridade da fila. Para o <tt>cbq</tt>,
    a faixa de prioridade varia de 0 a 7; e para <tt>priq</tt>,
    a faixa vai de 0 a 15. Prioridade 0 é a mais baixa. Quando não
    especificada, o valor padrão de 1 é usado.
<li><tt><i>qlim</i></tt> - o número máximo de pacotes que podem ser
    armazenados na fila. Quando não for especificado, o padrão 50 é
    usado.
<li><tt><i>scheduler</i></tt> - o organizador utilizado, <tt>cbq</tt>
    ou <tt>priq</tt>. Deve ser o mesmo da fila raiz.
<li><tt><i>sched_options</i></tt> - outras opções podem ser passadas
    para controlar o comportamento do organizador:
	<ul>
	<li><tt>default</tt> - define uma fila padrão onde os pacotes
	    que não casarem com nenhuma outra fila serão armazenados.
	    Exatamente uma fila padrão é necessária.
	<li><tt>red</tt> - habilita Random Early Detection (RED) na
            fila.
	<li><tt>rio</tt> - habilita RED com IN/OUT. Nesse modo, RED
	    manterá múltiplos valores médios da fila e múltiplos
	    valores de comparação, um para cada nível de
	    Qualidade de Serviço IP.
	<li><tt>ecn</tt> - habilita Explicit Congestion Notification
	    (ECN) na fila. <tt>Ecn</tt> implica <tt>red</tt>.
	<li><tt>borrow</tt> - a fila pode emprestar banda de sua fila
	    pai. Essa opção só pode ser utilizada com o organizador
            <tt>cbq</tt>.
	</ul>
<li><tt><i>queue_list</i></tt> - uma lista de subfilas a serem criadas
    dentro dessa fila. Uma <tt><i>queue_list</i></tt> pode ser definida
    apenas quando o organizador utilizado for <tt>cbq</tt>.
</ul>

<p>
Continuando o exemplo acima:
<blockquote>
<tt>
queue std bandwidth 50% cbq(default)<br>
queue ssh bandwidth 25% { ssh_login, ssh_bulk }<br>
&nbsp;&nbsp;queue ssh_login bandwidth 25% priority 4 cbq(ecn)<br>
&nbsp;&nbsp;queue ssh_bulk  bandwidth 75% cbq(ecn)<br>
queue ftp bandwidth 500Kb priority 3 cbq(borrow red)<br>
</tt>
</blockquote>

<p>
Aqui os parâmetros das subfilas, previamente definidas, são
configurados.
A fila <tt>std</tt> possui largura de banda de 50% da fila raiz
(ou 1Mbps) e está configurada como a fila padrão. A fila <tt>ssh</tt>
possui 25% da banda da fila raiz (500kb) e também contém duas filas
<tt>ssh_login</tt> e <tt>ssh_bulk</tt>. A fila <tt>ssh_login</tt>
tem prioridade maior que <tt>ssh_bulk</tt> e ambas tem ECN habilitado.
A banda atribuída à fila <tt>ftp</tt> é de 500Kbps com prioridade 3. Ela
também pode tomar banda emprestada quando estiver disponível e também
tem RED habilitado.

<p>
<b>NOTA:</b> Cada definição de fila tem sua banda especificada.
Sem especificar a banda, o PF dará à fila 100% da banda da fila pai.
Nessa situação, que causará um erro quando as regras são carregadas,
já que existe uma fila com 100% da banda, nenhuma outra fila pode
ser definida nesse nível, já que não existe banda livre para
alocar.

<a name="assign"></a>
<h3>Atribuindo Tráfego a uma Fila</h3>
<p>
Para atribuir tráfego a uma fila, a palavra-chave <tt>queue</tt> é usada
em conjunto com as <a href="filter.html">regras de filtragem</a> do PF.
Por exemplo, considere um conjunto de regras de filtragem contendo uma
linha como:
<blockquote>
<tt>pass out on fxp0 from any to any port 22</tt>
</blockquote>

<p>
Pacotes que casarem com essa regra podem ser enviados para uma fila
específica através do uso da palavra-chave <tt>queue</tt>:
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue ssh</tt>
</blockquote>

<p>
Ao usar a palavra <tt>queue</tt> com diretivas <tt>block</tt>, quaisquer
pacotes TCP RST ou ICMP Unreachable resultantes serão enviados à fila
especificada.

<p>
Note que as designações de filas podem ocorrer numa interface diferente
da definida na diretiva <tt>altq on</tt>:
<blockquote>
<tt>
altq on fxp0 cbq bandwidth 2Mb queue { std, ftp }<br>
queue std bandwidth 500Kb cbq(default)<br>
queue ftp bandwidth 1.5Mb<br>
<br>
pass in on dc0 from any to any port 21 queue ftp<br>
</tt>
</blockquote>

<p>
Enfileiramento está habilitado em <tt>fxp0</tt>, mas a designação
acontece em <tt>dc0</tt>.
Se os pacotes que casam com a regra <tt>pass</tt> sairem pela
interface <tt>fxp0</tt>, serão enfileirados na fila <tt>ftp</tt>.
Esse tipo de enfileiramento pode ser muito útil em roteadores.

<p>
Normalmente, apenas um nome de fila é informado com a palavra-chave
<tt>queue</tt>, mas caso um segundo nome seja especificado, a fila será
usada para pacotes com um
<a href="http://www.rfc-editor.org/rfc/rfc791.txt">Type of Service
(ToS)</a> com pouco atraso e para pacotes TCP ACK sem payload de dados.
Um bom exemplo disso pode ser obtido utilizando SSH. Sessões de login
SSH irão definir o ToS para low-delay enquanto que sessões SCP e SFTP
não.
O PF pode usar essas informações para enfileirar pacotes pertencentes a
uma conexão de login numa fila diferente dos pacotes que não forem de
conexões de login. Isso pode ser útil para priorizar os pacotes das
conexões de login sobre pacotes de transferênca de arquivos.
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue(ssh_bulk, ssh_login)</tt>
</blockquote>

<p>
Isso envia pacotes pertencentes à conexões de login SSH para a fila
<tt>ssh_login</tt> e pacotes pertencentes à conexões SCP e SFTP
para a fila <tt>ssh_bulk</tt>. Conexões de login SSH terão seus pacotes
processados antes dos pacotes SCP e SFTP, porque a fila
<tt>ssh_login</tt> tem prioridade maior.

<p>
Atribuir pacotes TCP ACK a uma fila de alta prioridade é útil em
conexões assimétricas, isto é, conexões que possuem taxas de upload e
download diferentes, como conexões ADSL, por exemplo. Numa conexão ADSL,
se o canal de upload estiver sendo utilizado em sua capacidade máxima e
um download é iniciado, o download irá sofrer, porque os pacotes TCP ACK
que devem ser enviados entrarão num congestionamento quando tentarem
passar pelo canal de upload. Testes têm mostrado que para atingir os
melhores resultados, a largura de banda na fila de upload deve ser
configurada para um valor menor do que a conexão realmente é capaz.
Por exemplo, se uma conexão ADSL tem uma taxa máxima de upload de
640Kbps, configurar a <tt>bandwidth</tt> da fila raiz para um valor
como 600Kb deve resultar numa melhora de desempenho. Tentativas e
erros mostrarão a melhor configuração de <tt>bandwidth</tt>.

<p>
Ao utilizar a palavra-chave <tt>queue</tt> com regras que <tt>mantém o
estado (keep state)</tt>, como:
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port 22 flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state queue ssh
</tt>
</blockquote>

<p>
O PF gravará uma entrada para a fila na tabela de estado, de forma que
pacotes saindo pela <tt>fxp0</tt> que casam com a conexão stateful
serão enviados para a fila <tt>ssh</tt>. Perceba que apesar da
palavra-chave <tt>queue</tt> estar sendo utilizada numa regra filtrando
tráfego entrante, o objetivo é especificar uma fila para o tráfego que
sai; a regra acima não enfileira pacotes entrantes.

<a name="example1"></a>
<h2>Exemplo #1: Rede Pequena, doméstica</h2>
<pre>

    [ Alice ]    [ Charlie ]
        |             |                              ADSL
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Internet )
              |
           [ Bob ]

</pre>

<p>
Nesse exemplo, o OpenBSD está sendo usado num gateway de Internet para
uma pequena rede doméstica com três estações de trabalho. O gateway faz
filtragem de pacotes e NAT. A conexão com a Internet é via linha ADSL
rodando a 2Mbps de download e 640Kbps de upload.

<p>
A política de filas para essa rede:
<ul>
<li>Reservar 80Kbps de largura de banda de download para Bob, para
    que ele possa jogar online sem sofrer lag por causa dos downloads
    de Alice ou Charlie. Permitir a Bob usar mais de 80Kbps quando
    houver disponibilidade.
<li>Tráfego SSH interativo e mensagem instantânea terão maior prioridade
    do que o tráfego comum.
<li>Consultas e respostas DNS terão a segunda maior prioridade.
<li>Pacotes TCP ACK saindo terão maior prioridade que qualquer
    outro tráfego de saída.
</ul>

<p>
Abaixo segue o conjunto de regras adequado à política da rede. Perceba
que somente diretivas <tt>pf.conf</tt> que se aplicam diretamente à
política descrita acima estão presentes;
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">options</a>,
etc., não são mostradas.

<p>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# Habilita enfileiramento na interface externa para controlar o tráfego
# indo para Internet. Usa o organizador priq para controlar somente
# prioridades. Define largura de banda para 610Kbps para obter melhor
# desempenho na fila TCP ACK.

altq on fxp0 priq bandwidth 610Kb queue { std_out, ssh_im_out, dns_out, \
	tcp_ack_out }

# Define os parâmetros para as subfilas.
# std_out      - a fila padrão. Qualquer regra abaixo que não
#                especifique explicitamente uma fila, terá seu tráfego
#		 inserido nessa fila.
# ssh_im_out   - SSH interativo e tráfego de várias mensagens
#                instantâneas.
# dns_out      - pesquisas DNS.
# tcp_ack_out  - pacotes TCP ACK sem payload de dados.

queue std_out     priq(default)
queue ssh_im_out  priority 4 priq(red)
queue dns_out     priority 5
queue tcp_ack_out priority 6

# Habilita enfileiramento na interface interna para controlar tráfego
# vindo da Internet. Usa o organizador cbq para controlar a banda.
# Largura de banda máxima é 2Mbps.

altq on dc0 cbq bandwidth 2Mb queue { std_in, ssh_im_in, dns_in, bob_in }

# Define os parâmetros para as subfilas.
# std_in      - a fila padrão. Qualquer regra de filtragem abaixo que
#		não especifique explicitamente uma fila terá seu
#		tráfego inserido nessa fila.
# ssh_im_in   - SSH interativo e tráfego de várias mensagens
#               instantâneas.
# dns_in      - respostas DNS.
# bob_in      - banda reservada para a estação de trabalho de Bob.
#		Permitir a ele emprestar banda dos outros.

queue std_in    bandwidth 1.6Mb cbq(default)
queue ssh_im_in bandwidth 200Kb priority 4
queue dns_in    bandwidth 120Kb priority 5
queue bob_in    bandwidth 80Kb cbq(borrow)


# ... na seção de filtragem do pf.conf ...

alice         = "192.168.0.2"
bob           = "192.168.0.3"
charlie       = "192.168.0.4"
local_net     = "192.168.0.0/24"
ssh_ports     = "{ 22 2022 }"
im_ports      = "{ 1863 5190 5222 }"

# Regras de filtragem para entrada em fxp0
block in on fxp0 all

# Regras de filtragem para saída em fxp0
block out on fxp0 all
pass  out on fxp0 inet proto tcp from (fxp0) to any flags S/SA \
	keep state queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0) to any keep state
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to any port domain \
	keep state queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to any port $ssh_ports \
	flags S/SA keep state queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to any port $im_ports \
	flags S/SA keep state queue(ssh_im_out, tcp_ack_out)

# Regras de filtragem de entrada em dc0
block in on dc0 all
pass  in on dc0 from $local_net

# Regras de filtragem de saída em dc0
block out on dc0 all
pass  out on dc0 from any to $local_net
pass  out on dc0 proto { tcp udp } from any port domain to $local_net \
	queue dns_in
pass  out on dc0 proto tcp from any port $ssh_ports to $local_net \
	queue(std_in, ssh_im_in)
pass  out on dc0 proto tcp from any port $im_ports to $local_net \
	queue ssh_im_in
pass  out on dc0 from any to $bob queue bob_in
</pre>
</td></tr>
</table>

<a name="example2"></a>
<h2>Exemplo #2: Rede Empresarial</h2>
<pre>

  ( IT Dept )  [ Boss's PC ]
       |          |                                   T1
     --+----+-----+---------- dc0 [ OpenBSD ] fxp0 -------- ( Internet )
            |                         fxp1
         [ COMP1 ]    [ WWW ]         /
                         |           /
                       --+----------'

</pre>

<p>
Nesse exemplo, a máquina OpenBSD funciona como firewall para a rede
de uma empresa. A empresa roda um servidor WWW na porção DMZ de sua
rede, onde os clientes fazem upload de seus websites via FTP. O
departamento de TI possui sua própria subrede conectada na rede
principal, e o chefe tem um PC em sua mesa que é usado para ler email
e navegar na Internet. A conexão com a Internet é via um linha T1
rodando a 1.5Mbps em ambas as direções. Todos os outros segmentos de
rede utilizam Fast Ethernet (100Mbps).

<p>
O administrador de rede decidiu pela seguinte política:
<ul>
<li>Limitar todo o tráfego entre o servidor WWW e a internet para
    500Kbps em ambas as direções.
       <ul>
       <li>Distribuir 250Kbps para tráfego HTTP.
       <li>Distribuir 250Kbps para "outro" tráfego (i.e.,
	   tráfego não-HTTP)
       <li>Permitir a qualquer fila emprestar totalmente os 500Kbps.
       <li>Dar alta prioridade ao tráfego entre o servidor WWW
	   e a Internet do que outro tráfego entre o servidor WWW
	   e a Internet (como uploads FTP).
       </ul>
<li>O tráfego entre o servidor WWW e a rede interna pode usar
    totalmente os 100Mbps que a rede oferece.
<li>Reservar 500Kbps para o Departamento de TI para que eles
    possam baixar as últimas atualizações de software em tempo hábil.
    Eles devem ser capazes de utilizar mais do que 500Kbps caso haja
    disponibilidade.
<li>Dar alta prioridade ao tráfego entre o PC do chefe e a
    Internet do que outro tráfego indo/vindo da Internet.
</ul>

<p>
Abaixo estão as regras que fazem a política dessa rede. Perceba
que somente diretivas <tt>pf.conf</tt> que se aplicam diretamente à
política descrita acima estão presentes;
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">options</a>,
etc., não são mostradas.

<p>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# Habilita enfileiramento na interface externa para pacotes saindo
# para a Internet. Usa cbq para que o uso da banda por cada fila possa
# ser controlado. A largura máxima para tráfego saindo é de 1.5Mbps.

altq on fxp0 cbq bandwidth 1.5Mb queue { std_ext, www_ext, boss_ext }

# Define os parâmetros para as subfilas.
# std_ext        - a fila padrão. Também para o tráfego saindo via fxp0.
# www_ext        - fila para tráfego WWW do servidor.
#                  Limitada a 500Kbps.
#   www_ext_http - fila para tráfego WWW do servidor; alta prioridade.
#   www_ext_misc - todo o tráfego diferente de http do servidor WWW.
# boss_ext       - tráfego vindo do computador do chefe.


queue std_ext        bandwidth 500Kb cbq(default borrow)
queue www_ext        bandwidth 500Kb { www_ext_http, www_ext_misc }
  queue www_ext_http bandwidth 50% priority 3 cbq(red borrow)
  queue www_ext_misc bandwidth 50% priority 1 cbq(borrow)
queue boss_ext       bandwidth 500Kb priority 3 cbq(borrow)

# Habilita enfileiramento na interface interna para controlar tráfego
# vindo da internet para DMZ. Usa cbq para controlar a banda em cada
# fila. Esta interface está configurada para largura máxima de banda.
# Tráfego vindo da DMZ poderá usar toda a banda enquanto tráfego vindo
# da Internet será limitado a 1.0Mbps (porque 0.5Mbps (500Kbps) está
# alocado para fxp1).

altq on dc0 cbq bandwidth 100% queue { net_int, www_int }

# Define os parâmetros para as subfilas.
# net_int    - fila para tráfego vindo da Internet. Banda de 1.0Mbps.
#   std_int  - a fila padrão. Padrão também para tráfego saindo via dc0.
#   it_int   - tráfego para a rede do TI; reservar 500Kbps.
#   boss_int - tráfego para o PC do chefe, designar alta prioridade.
# www_int    - tráfego do servidor WWW na DMZ; velocidade máxima.

queue net_int    bandwidth 1.0Mb { std_int, it_int, boss_int }
  queue std_int  bandwidth 250Kb cbq(default borrow)
  queue it_int   bandwidth 500Kb cbq(borrow)
  queue boss_int bandwidth 250Kb priority 3 cbq(borrow)
queue www_int    bandwidth 99Mb cbq(red borrow)

# Habilitar enfileiramento na interface da DMZ para controlar tráfego
# destinado ao servidor WWW. cbq será utilizado nesta interface já que
# o controle preciso se faz necessário. A banda nesta interface está
# configurada para sua capacidade máxima. O tráfego da rede interna
# poderá utilizar toda a banda, enquanto o tráfego da Internet será
# limitado a 500Kbps.

altq on fxp1 cbq bandwidth 100% queue { internal_dmz, net_dmz }

# Define os parâmetros para as subfilas.
# internal_dmz   - tráfego da rede interna.
# net_dmz        - tráfego da Internet.
#   net_dmz_http - tráfego http; alta prioridade.
#   net_dmz_misc - todo tráfego não-http. Essa também é a fila padrão.

queue internal_dmz   bandwidth 99Mb cbq(borrow)
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http bandwidth 50% priority 3 cbq(red borrow)
  queue net_dmz_misc bandwidth 50% priority 1 cbq(default borrow)


# ... na seção de filtragem do pf.conf ...

main_net  = "192.168.0.0/24"
it_net    = "192.168.1.0/24"
int_nets  = "{ 192.168.0.0/24, 192.168.1.0/24 }"
dmz_net   = "10.0.0.0/24"

boss      = "192.168.0.200"
wwwserv   = "10.0.0.100"

# Negar por padrão
block on { fxp0, fxp1, dc0 } all

# Regras de filtragem para entrada em fxp0
pass in on fxp0 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } flags S/SA keep state queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue www_ext_http

# Regras de filtragem para saída em fxp0
pass out on fxp0 from $int_nets to any keep state
pass out on fxp0 from $boss to any keep state queue boss_ext

# Regras de filtragem para entrada em dc0
pass in on dc0 from $int_nets to any keep state
pass in on dc0 from $it_net to any queue it_int
pass in on dc0 from $boss to any queue boss_int
pass in on dc0 proto tcp from $int_nets to $wwwserv port { 21, 80, \
	&gt; 49151 } flags S/SA keep state queue www_int

# Regras de filtragem para saída em dc0
pass out on dc0 from dc0 to $int_nets

# Regras de filtragem para entrada em fxp1
pass in on fxp1 proto { tcp, udp } from $wwwserv to any port 53 \
	keep state

# Regras de filtragem para saída em fxp1
pass out on fxp1 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } flags S/SA keep state queue net_dmz_misc
pass out on fxp1 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue net_dmz_http
pass out on fxp1 proto tcp from $int_nets to $wwwserv port { 80, \
	21, &gt; 49151 } flags S/SA keep state queue internal_dmz
</pre>
</td></tr>
</table>

<p>
[<a href="anchors.html">Anterior: Âncoras</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="pools.html">Próximo: Grupos de Endereços e Balanceamento de Carga</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[voltar]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: queueing.html,v 1.36 ]<br>
$Translation: queueing.html,v 1.11 2009/03/11 00:52:57 dsantos Exp $<br>
-->
$OpenBSD: queueing.html,v 1.11 2009/03/16 20:24:23 tobias Exp $
</small>

</body>
</html>
