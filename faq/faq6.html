<html>
<head>
<title>6.0 - Networking</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-1999 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<h2><font color=#e00000>6.0 - Networking</font><hr></h2>
</p>

<p>
<ul><h3>Table of Contents</h3>
<li><A href= "#6.0.1">6.0.1 - Before we go any further</a>
<li><a href= "#6.1">6.1 - Initial network setup</a>
<li><a href= "#6.2">6.2 - IP Filter</a>
<li><a href= "#6.3">6.3 - Network Address Translation</a>
<li><a href= "#6.4">6.4 - Dynamic Host Configuration Protocol</a>
<li><a href= "#6.5">6.5 - Point to Point Protocol</a>
<li><A href= "#6.6">6.6 - Tuning networking parameters</a>
<li><a href= "#6.7">6.7 - Using NFS</a>
<li><a href= "#6.8">6.8 - Domain Name Service  - DNS, BIND, and named</a>
<li><a href= "#6.9">6.9 - Setting up a PPTP connection in OpenBSD</a>
</ul>
</p>
<hr>

<br>
<P>
<A name="6.0.1"></a>
<H2>6.0.1 - Before we go any further</h2>
<P>
For the bulk of this document, it helps if you have read and
at least partially understand the <A href="faq5.html">Kernel
Configuration and Setup</a> section of the FAQ, and the
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&apropos=0&sektion=8&format=html">
ifconfig(8)</a> and
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">
netstat(1)</a> man pages.
<P>
If you are a network administrator, and you are setting up routing
protocols, if you are using your OpenBSD box as a router, if you need to
go in depth into IP networking, you really need to read
<A HREF="http://www.3com.com/solutions/en_US/ncs/501302.html">Understanding IP addressing</a>.
This is an excellent document.  Understanding IP addressing contains
fundamental knowledge to build upon when working with IP networks,
especially when you deal with or are responsible for more then one network.
<P>
If you are working with applications such as web servers, ftp servers, and
mail servers, you may benefit greatly by <A HREF="http://the.rfceditor.org/rfc.html">reading the RFCs</a>.
Most likely, you can't read all of them.  
Pick some topics that you are interested in, or that you use in
your network environment.  Look them up, find out how they are intended to
work.
The RFCs define many (thousands) of standards for protocols on the
internet and how they are supposed to work.

<a name="6.1"></a>
<h2>6.1 - Initial Network Setup</h2>

<p>
<a name="6.1.1"></a>
<h3>6.1.1 - Identifying and Setting Up Your Network Interfaces</h3>
</p>

<p>
To start off, you must first identify your network interface. In OpenBSD, interfaces are named for the type
of card, not for the type of connection. You can see your network card get initialized during boot, or after
boot using the <strong>dmesg(8)</strong> command. You also have the ability of seeing your network interface
using the <strong>ifconfig(8)</strong> command. For example, Here is the output in dmesg for a ne2k network
card, which uses the device name ne.
</p>

<ul><pre>
ne3 at pcmcia1 function 0 "Linksys, EtherFast 10/100 PC Card (PCMPC100), " port 0x340/16 irq 9
ne3: address 00:e0:98:04:95:ba
</pre></ul>

<p>
If you don't know what your device name is, here is a list of common cards and their device names.
</p>

<ul>
<li>ne2000 Network Cards - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ne&sektion=4&format=html">ne</a>
<li>3Com EtherLink III and Fast EtherLink III Ethernet - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&sektion=4&format=html">ep</a>
<li>3Com EtherLink XL and Fast EtherLink XL Ethernet (3C9xx) - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xl&sektion=4&format=html">xl</a>
<li>Intel 82586 chip Ethernet device driver - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ie&sektion=4&format=html">ie</a>
<ul>Which Includes Cards Such As:
	<li>3Com 3C507
	<li>AT&T StarLAN 10
	<li>AT&T EN100
	<li>AT&T StarLan Fiber
	<li>Intel EtherExpress 16
</ul>
<li>DEC/Intel 21142/3 and clone 10/100 Ethernet driver - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dc&sektion=4&format=html">dc</a>
<ul><FONT SIZE="-1"> <b>Note:</b> Some drivers which were in OpenBSD 2.6, such as mx , ax , al and pn have been replaced by this driver.</font><BR>
Which Includes Cards Such As:
	<li>Intel 21142/21143 (formerly manufactured by DEC)
	<li>Macronix 98713, 98713A, 98715, 98715A and 98725
	<li>Davicom DM9100 and DM9102
	<li>ASIX Electronics AX88140A and AX88141
	<li>ADMtek AL981 Comet and AN985 Centaur
	<li>Lite-On 82c168 and 82c169 PNIC
	<li>Lite-On/Macronix 82c115 PNIC II
<P>
If you are upgrading to OpenBSD 2.7 from an older release of OpenBSD,
you need to pay attention here.
Any references in /etc/ifaliases, /etc/ipf.rules, /etc/ipnat.rules
to the old interface names mx, al, ax, or pn must be replaced with dc.  Also, any hostname.xxx
files with the old interface names must be renamed to hostname.dcX to
be recognized.  Replace the X with the interface number.
</ul>
<li>Lucent Technologies WaveLAN/IEEE 802.11DS - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&sektion=4">wi</a>
<li>Aironet Communications 4500/4800 IEEE 802.11DS - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&sektion=4">an</a>
</ul>

<p>
Again, you can check to see what interfaces have been identified by using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>
utility. Here is output which will show an ne2k device.
</p>

<ul><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8009&lt;UP,LOOPBACK,MULTICAST&gt;
        inet 127.0.0.1 netmask 0xff000000
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt;
ne3: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
tun0: flags=10&lt;POINTOPOINT&gt;
tun1: flags=10&lt;POINTOPOINT&gt;
enc0: flags=0&lt;&gt;
bridge0: flags=0&lt;&gt;
bridge1: flags=0&lt;&gt;
</pre></ul>

<p>
As you can see here, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a> 
gives us a lot more information than we are needing at this
point. But it still allows us to see our interface. In the above example, the interface card is already
configured. You can tell this by seeing that values are already set in &quot;inet 10.0.0.38 netmask
0xffffff00 broadcast 10.0.0.255&quot;, and that the <strong>UP</strong> and <strong>RUNNING</strong> flags
are turned on. Also, you will notice many other interfaces. Here is a list of interfaces that will be
expected to be there.
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&sektion-4&format=html">lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&sektion=4&format=html">sl</a> - SLIP Network Interface
<li>ppp - Point to Point Protocol
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&sektion=4&format=html">tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4&format=html">enc</a> - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4&format=html">bridge</a> - Ethernet bridge interface
</ul>

<p>
If you don't have your interface configured the first step is to create the <strong>/etc/hostname.${IF}</strong>
file. Where the name of your interface will take the place of ${IF}. From the information in the examples
above, the name would be <strong>/etc/hostname.ne3</strong>. The layout of this file is like so:
To read more about the format of this file, reference the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html">hostname.if(5)</a>
man page.
</p>

<ul><pre>
[address_family] [your_ip] [your_netmask] [media options]
</pre></ul>

<p>
So for the above example, a proper file would look like this:
</p>

<ul><pre>
$ <strong>cat /etc/hostname.ne3</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></ul>

<p>
Next step from here is to setup your gateway. To do this, simply put the IP of your gateway in the file
<strong>/etc/mygate</strong>. This will allow for your gateway to be set upon boot. From here you should
setup your nameservers, and your <strong>/etc/hosts</strong> file. To setup your nameservers, you will
create a file called <strong>/etc/resolv.conf</strong>. You can read more about the format of this file in
the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">resolv.conf(5)</a>
man page. But for a standard usage, here is an example. In this example your domain servers are 125.2.3.4
and 125.2.3.5. You also belong in the domain &quot;yourdomain.com&quot;.
</p>

<ul><pre>
$ <strong>cat /etc/resolv.conf</strong>
search yourdomain.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></ul>

<p>
From here, you can either reboot or run the <strong>/etc/netstart</strong> script. You can do this by simply
Typing (as root):
</p>

<ul><pre>
$ <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></ul>

<p>
Notice that a few errors were produced, but this is in regards to the loopback interface. So this can be
ignored. From here your system should be up and running. Again you can check to make sure that your
interface was setup correctly with <strong>ifconfig(8)</strong>. You can also check your routes via
<strong>netstat(1)</strong> or <strong>route(8)</strong>. Here is an example of viewing your routing tables
using both.
</p>

<ul><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  ne3
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  ne3
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  ne3
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)
$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></ul>

<p>
<a name="6.1.2"></a>
<h3>6.1.2 - Setting up your OpenBSD box as a Gateway</h3>
</p>

<p>
This is the basic information you need to set up your OpenBSD box as a gateway (also called a router). If
you are using OpenBSD as a router on the Internet, we suggest that you also read the IP Filter setup
instructions below to block potentially malicious traffic. Also, due to the low availability of IPv4
addresses from network service providers and regional registries, you may want to look at Network Address
Translation for information on conserving your IP address space. 
</p>

<p>
The GENERIC kernel already has the ability to allow IP Forwarding, but needs to be turned on. You should
do this using the <strong>sysctl(8)</strong> utility. To change this permanently you should edit the file 
<strong>/etc/sysctl.conf</strong> to allow for IP Forwarding. To do so add this line in that configuration
file.
</p>

<ul><pre>
net.inet.ip.forwarding=1
</pre></ul>

<p>
To make this change without rebooting you would use the <strong>sysctl(8)</strong> utility
directly. Remember though that this change will not still exist after a reboot, and needs to be run as root.
</p>

<ul><pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -> 1
</pre></ul>

<p>
Now modify the routes on the other hosts on both sides.  There are many possible uses of OpenBSD as a router, using software
such as <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&apropos=0&sektion=8&format=html">routed(8)</a>,
<A HREF="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>, and <A href="http://www.zebra.org">zebra</a>.
OpenBSD has support in the ports collection for both gated and mrtd.
OpenBSD supports several T1, HSSI, ATM, FDDI, Ethernet, and serial (PPP/SLIP) interfaces.
</p>

<p>
<a name="6.1.3"></a>
<h3>6.1.3 - Setting up aliases on an interface.</h3>
</p>

<strong>Starting with OpenBSD 2.8, <i>/etc/ifaliases</i> is no longer used!</strong>

<p>
OpenBSD has a simple mechanism for setting up ip aliases on an interface. To do this simply edit the file <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html"><i>/etc/hostname.&lt;if&gt;</i></a>. This file is read upon boot by the <i>/etc/rc</i> script, which is part of the <a href="faq10.html#10.3">rc startup hierarchy</a>. For the example, we assume that the user has an interface <b>dc0</b> and is on the network 192.168.0.0. Other important information:
</p>

<ul>
<li>IP for dc0 is 192.168.0.2
<li>NETMASK is 255.255.255.0
</ul>

<p>
A few notes about aliases, in OpenBSD you use the interface name only. There is no differences between the first alias and the second alias. Unlike some other operating systems, OpenBSD doesn't refer to them as dc0:0, dc0:1.  If you
are referring to a specific aliased IP address with ifconfig, or adding
an alias, be sure
to say "<tt>ifconfig int alias</tt>" instead of just "<tt>ifconfig int</tt>"
at the command line.   You can delete aliases with "<tt>ifconfig int delete</tt>".
<P>
Assuming you are using multiple IP addresses which are in the same IP subnet with
aliases, your netmask setting for each alias becomes 255.255.255.255.  
They do need to not follow the netmask of the first IP bound to the interface.
In this example <i>/etc/hostname.dc0</i>, two aliases are added to the device dc0,
which, by the way, was configured as 192.168.0.2 netmask 255.255.255.0.
</p>

<ul><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255 NONE
inet alias 192.168.0.4 255.255.255.255 NONE
</pre></ul>

<p>
Once you've made this file, it does take a reboot for it to take effect. You can, however, bring up the aliases by hand using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a> utility. To bring up the first alias you would use the command:
</p>

<ul><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></ul>

<p>
To view these aliases you must use the command:
</p>

<ul><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></ul>



<p>
<a name= "6.2"></a>
<h2>6.2 - IP Filter</h2>
</p>

<p>
The IP Filter package was created to handle two tasks, dealing with
packet level forwarding permissions <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=8&format=html">ipf(8)</a> and mapping hosts/subnets to a range of
external addresses <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&apropos=0&sektion=8&format=html">ipnat(8)</a>. The configuration files for these two services are /etc/ipf.rules and
/etc/ipnat.rules.
</p>

<p>
You need to edit /etc/rc.conf to activate them at boot time. You also need to have 
net.inet.ip.forwarding=1 in your /etc/sysctl.conf (or your kernel needs to have IPFORWARDING
or GATEWAY options turned on.) You also need a kernel compiled with option
IPFILTER and IPFILTER_LOG (the GENERIC kernels do have these options).
</p>

<P>
If you have IP Filter compiled into your kernel, but you don't have 
it turned on in your /etc/rc.conf file, you can still activate it easily. 

<ul><pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre></ul>

<P>
The <tt>-E</tt> flag on ipf 'enables' IP Filter.  <Tt>-Fa</tt> clears out any rules that you may have in there.  <tt>-f /etc/ipf.rules</tt> loads the rules from
/etc/ipf.rules.  
<p>
If you make changes to /etc/ipf.rules after ipf is loaded, you can reload your rules pretty easily!

<ul><pre>
# ipf -Fa -f /etc/ipf.rules
</pre></ul>
Same for ipnat...

<ul><pre>
# ipnat -CF -f /etc/ipnat.rules
</pre></ul>
You will also want to enable ipmon for debugging.
<ul><pre>
# ipmon -Ds
</pre></ul>
<p>
This document will cover some basic ipf and ipnat configurations below.
There are a lot of nice examples in /usr/share/ipf/ for ipnat and ipf. We recommend
you choose the one closest to what you want, and modify it to fit your needs.  You can find other IP Filter information
at the IP Filter <A HREF="http://false.net/ipfilter/">mailing list archive</a>, the <A HREF="http://coombs.anu.edu.au/~avalon/">IP Filter web site</a>, and finally the <A
HREF="http://www.obfuscation.org/ipf/">IP Filter HOWTO</a>. 
</p>

<p>
<h3>IPF</h3>
</p>

<p>
In order to enable ipf at boot, you will need to modify /etc/rc.conf so it reads IPFILTER=YES.
IP Filter (ipf) is controlled by /etc/ipf.rules, which is read at boot. For a more detailed explanation, see <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=5&format=html">ipf(5)</a>. In the examples that follow, 
fxp0 will represent the external interface to the internet. It will be different for you, based on the
ethernet adaptor present in your computer. These rules will assume full-time internet connectivity, such as you would see on a webserver.
</p>

<p>
IP Filter rules are processed sequentially from top to bottom, it helps to visualize each packet having to traverse every rule before it reaches it's destination.
</p>

<p>
For example, the default ruleset provided allows all packets to travel in, and all packets to travel out:

<ul><pre>
pass out from any to any 
pass in from any to any
</pre></ul>

Now lets say we don't want to allow any incoming connections to port 3306 (mysql) because the database should only be connected to from localhost. Our ruleset would look like this:

<ul><pre>
pass out from any to any
pass in from any to any
block in on fxp0 from any to any port = 3306
</pre></ul>

This says &quot;block in all incoming packets, from anywhere to anywhere whose destination is 3306.&quot;
Essentially a packet destined for port 3306 on interface fxp0 will pass the first &quot;pass in&quot; rule and then be dropped by the &quot;block in port = 3306&quot; rule. If you reversed the order of our incoming rules (remember, order is important):

<ul><pre>
pass out from any to any
block in on fxp0 from any to any port = 3306
pass in from any to any
</pre></ul>

Packets destined for port 3306 would pass because the last rule in the set allows all packets to pass. It is important to keep this in mind when writing packet filter rules:
 <b> The last matching rule wins</b>.
</p>

<p>
Of course, there are exceptions to every rule. the <em>quick</em> option drops the packet at the first rule that matches. Let's look at our above flawed example, if we add <em>quick</em> to the &quot;block in&quot; rule:

<ul><pre>
pass out from any to any
block in quick on fxp0 from any to any port = 3306
pass in from any to any
</pre></ul>

<p>
A packet destined for our host on port 3306 will hit the &quot;block in quick&quot; rule and be dropped immediately. All packets destined for other ports wont find a rule match until they reach our &quot;pass in&quot; rule that allows all packets to pass.
</p>

<b>Default Deny</b>
<p> The safest packet filtering policy is a default deny policy. All traffic not explicitly allowed is denied. This policy is far safer than explicitly denying each protected service, allows for smaller rulesets, and can protect from an accidentally misconfigured service that has been left exposed.
<p>
Let's now look at another real world example ruleset and explain things line by line. Here's an example for a webserver with a default deny policy that only allows ssh connections (for administration) and connections to http (port 80) and https (port 443).
<ul><pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from any to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
##############################
# end ruleset
##############################
</pre></ul>

<p>
This will allow incoming connections from anywhere to ports 22(ssh), 80(http), and 443(https). It will drop all other connection attempts, and allow all outgoing connections. This is a pretty tight ruleset.
But what if you only wanted to allow internal hosts on your 1.1.1.0 address block to connect to ssh, but allow outside connections to http and https?
</p>

<ul><pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
##############################
# end ruleset
##############################
</pre></ul>

Pretty good, but what if we only want to allow one machine (1.1.1.1) to administer the web server remotely?
In that case, we can change this:

<ul><pre>
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
</pre></ul>
to this:
<ul><pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
</pre></ul>
IP Filter supports both CIDR and dotted decimal forms of netmask address. You could also write the above as:
<ul><pre>
pass in quick on fxp0 from 1.1.1.1/255.255.255.255 to any port = 22
</pre></ul>
but why would you?
</p>
<b>Sample Rules</b>
<p>
Here are some good rules for everyone to use (assuming that fxp0 is the external internet-connected interface). First we will set up simple address spoofing protection.
<ul><pre>
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8
</pre></ul>
It's also a good idea to separate your loopback interface from your other rules. 
<ul><pre>
pass out quick on lo0
pass in quick on lo0
</pre></ul>
Our ruleset is starting to look pretty good, when we put it together, here's what it looks like:
<ul><pre>
###########################
# begin ruleset
###########################
# loopback rules

pass out quick on lo0
pass in quick on lo0

# don't allow anyone to spoof non-routeable addresses

block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# only allow our administration machine to connect via ssh

pass in quick on fxp0 from 1.1.1.1/32 to any port = 22

# allow others to use http and https

pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443

# finally lock the rest down with a default deny

block in quick on fxp0 from any to any

# and let out-going traffic out

pass out on fxp0 from any to any

#############################
# end ruleset
#############################
</pre></ul>
</p>

<b>Packet logging</b>
<p>
Now that's pretty good, but it could be better. What if we want to log any connection attempts to port 22(ssh) that get blocked by our firewall? Easy, IP Filter can handle this with the <em>log</em> keyword:
<ul><pre>
pass in quick on fxp0 from 1.1.1.1/32 to any port = 22
block in log quick on fxp0 from any to any port = 22
</pre></ul>
This rule will allow our remote administration machine to connect to port 22, but deny and log all other attempts to connect to port 22.
</p>
<b> Protocol based packet filtering</b>
<p>
IP Filter can filter any IP protocol based on its number or name from <a href=file://localhost/etc/protocols>/etc/protocols</a>. For the sake of clarity, we will only concern ourselves with tcp, udp, and icmp.  These are the
most commonly used protocols.  All basic internet applications
rely on the availability and correct operation of these protocols.</p>
<p>
In order for ipf to filter based on protocol, the keyword <em>proto</em> must be used. To examine our earlier ssh example rule, since ssh runs over tcp, we should only allow tcp packets to connect. by using the <em>proto</em> keyword to allow only tcp, we get a rule that looks like this:
<ul><pre>
pass in quick on fxp0 proto tcp from 1.1.1.1/32 to any port = 22
</pre></ul>
But what if we need to allow connections to a service running over both tcp and udp like bind? Well, in the case of tcp/udp, IP Filter allows you to group both protocols together. Note: this only applies to tcp/udp. Using the bind example, a rule allowing tcp and udp connections in a default deny environment would look like:
<ul><pre>
pass in quick on fxp0 proto tcp/udp from any to any port = 53
</pre></ul>
</p>
<b> Packet Filtering</b>
<p> 
In addition to filtering based on protocol, IP Filter is also capable of managing fragmented IP packets (a common method of defeating packet filters). There are two possible keywords that can be used when dealing with fragmented ip packets, <em>frag</em> for commonly fragmented IP packets, or <em>short</em> for IP packets with headers too small for comparison. Since fragmented packets can occur normally, depending on link conditions, it is best to only filter packets with headers too small for valid comparison. This can be accomplished with the following rule:
<ul><pre>
block in quick proto tcp all with short
</pre></ul>
What about IP Options? IP Filter can handle those packets too. Packets can either be dropped if they have IP options set, or they can be dropped based on the specific IP options that are set. For example, the following rule will drop and log all packets with ip options set.
<ul><pre>
block in log quick on fxp0 all with ipopts
</pre></ul>
This may however break some things such as <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=traceroute&sektion=8&format=html">traceroute(8)</a>. You can also specify which options not to allow. For instance a good rule is to block all packets with source routing options. This is accomplished with this rule:
<ul><pre>
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr
</pre></ul>
<b>TCP Flags, established connections and keeping state</b>
<p>
Now the filtering begins in earnest. IP Filter's greatest strengths are it's ability to filter packets based on TCP flags and to maintain established connections and connection state. It is recommend that all users who wish to filter packets based on TCP flags understand what role each flag plays. For instance, if you wanted to deny all packets with the FIN, URG, and PSH flags set (like for instance an nmap OS fingerprinting attempt) you could use a rule like this:
<ul><pre>
block in quick on fxp0 proto tcp from any to any flags FUP
</pre></ul>
(Thanks to <a href=mailto:halogen@nol.net>Kyle Hargraves</a> for that tip)
</p>
<p>
IP Filter's next cool trick is it's ability to maintain state. Maintaining state has been described as &quot;not speaking until spoken to&quot;, in other words, once a connection is established, packets no longer have to traverse rulesets. This is a very powerful feature allowing much simpler and more secure rule writing.</p>
<p>
For example, let's see how we can apply state to our previous example ruleset (confused yet?). To review, we are allowing management access from our Class C to port 22(ssh) and allowing all incoming web traffic on ports 80(http) and 443(https). We are blocking all other traffic. But what if I want to ssh out of the webserver? What if I need to use lynx to look up something in the FAQ? Well, I can't because I have blocked all incoming connections other than on the specified ports. While this is the safest route, it can be quite inconvenient. By adding the <em>keep state</em> keywords to our &quot;pass out&quot; rule, we can automagically allow incoming connections in response to connections we initiate, such as when web browsing.  Remember, we do need to specify what protocol we are keeping state for.
<ul><pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
##############################
# end ruleset
##############################
</pre></ul>
</p>
<p>
This little change will dramatically increase the flexibility and security of our ruleset because IP Filter is extremely flexible. For instance, in the above ruleset, we are allowing all tcp traffic into ports 80 &amp; 443. We can tighten this up even more. In order for a tcp connection to be established, we only need to allow the initial handshake to occur, once that occurs, we can block traffic to that port and allow our &quot;keep state&quot; rule to manage the connection. To allow the initial handshake to complete, we need only allow packets with the SYN and SYNACK flags set. By passing only packets with SYN and SYNACK set, we can prevent many forms of portscanning such as FIN scanning. The rules now look like this:
<ul><pre>
#############################
# begin ruleset
#############################
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
##############################
# end ruleset
##############################
</pre></ul>
</p>
<p>
Let's wrap this up by putting all of the rules we have so far into a ruleset. This ruleset will have a default deny policy, allow management connections from an internal network only (via ssh) and allow incoming traffic on ports 80(http) and 443(https). It will also protect against spoofed non-routeable ip addresses, and drop all packets that are too fragmented to inspect. A pretty comprehensive setup for a public webserver. Here's what /etc/ipf.rules should look like:
<ul><pre>
###########################
# begin ruleset
###########################
# loopback rules
pass out quick on lo0
pass in quick on lo0

# drop itsy bitsy frags
block in quick proto tcp all with short

# drop source routed packets
block in quick on fxp0 all with opt lsrr
block in quick on fxp0 all with opt ssrr

# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 from 127.0.0.0/8 to any
block in quick on fxp0 from 192.168.0.0/16 to any
block in quick on fxp0 from 172.16.0.0/12 to any
block in quick on fxp0 from 10.0.0.0/8 to any
block out quick on fxp0 from any to 127.0.0.1/8
block out quick on fxp0 from any to 192.168.0.0/16
block out quick on fxp0 from any to 172.16.0.0/12
block out quick on fxp0 from any to 10.0.0.0/8

# only allow our machines to connect via ssh
pass in quick on fxp0 from 1.1.1.0/24 to any port = 22

# allow others to use http and https
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA

# finally lock the rest down with a default deny
block in quick on fxp0 from any to any

# and let out-going traffic out and maintain state on established connections
# -- The flags S on the keep state is to ensure that state tracking starts
#    only on the first outbound packet in a tcp session. 
#    unnecessary consumption of state table entries.
# -- The flag s only works on the tcp protocol, so three entries are required to 
#    to cover all three protocols (tcp, udp, icmp).

pass out	quick on fxp0 proto tcp  from any to any flags S keep state
pass out 	quick on fxp0 proto udp  from any to any         keep state
pass out 	quick on fxp0 proto icmp from any to any         keep state

#############################
# end ruleset
#############################
</pre></ul>
</p>
<p>
If you experience problems, you may want to enable logging on individual rules to effectively troubleshoot. ie: pass in log quick on fxp0 from 1.1.1.0/24 to any port = 22<br> 
When you modify the configuration file to log packets, don't forget to ipf -Fa -f /etc/ipf.rules for the changes to take affect! 
<br>ipmon will write to ip log entries to /var/log/ipflog.<br>

For further information on ipf, the <a href=http://www.obfuscation.org/ipf/ipf-howto.txt>IPF how-to</a> is an excellent source, as are the resources available at the <a href=http://coombs.anu.edu.au/~avalon/ip-filter.html>IP Filter</a> homepage.
</p>

<p>
<a name="6.3"></a>
<h2>6.3 - IPNAT</h2>
</p>

<p>
Initial work done by Wayne Fergerstrom &lt;wayne@methadonia.net&gt;
</p>

<a name="nat1.0"></a>
<h3><u>6.3.1 NAT Introduction</u></h3>

<a name="nat1.1"></a>
<b>Section Introduction</b>
<p>
This section attempts to aid for those
installing and configuring Network Address Translation ("NAT")
on an OpenBSD machine. 

The user is assumed to have already set up
and configured an OpenBSD machine with two network cards (one
connected to the Internet and the other to the local network).
IP Network Address Translation will work on machines with only one NIC,
however since packets will be going in and out of the same interface,
ethernet collisions will slow down performance considerably.  
</p>

<p>
Based on <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, ipnat provides an easy way to
map internal networks to a single routeable ("real") internet address. This is very useful if you don't have
officially assigned addresses for every host on your internal network. When
you set up private/internal networks, you can take advantage of reserved
address blocks (assigned in <A HREF="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), such as:
<P>

10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>

</p>

<a name="nat1.2"></a>
<b>Terminology</b>

<p>
The conventions used in this document are fairly straightforward.
For documentation purposes I will review some of the terms and format
for which this document adheres to.
</p>

<ul>
<strong>"NAT"</strong>
<p>
This describes the function of "Network Address Translation."
The process of NAT is described later in this document.
</p>
</ul>

<ul>
<strong>"ipnat"</strong>

<p>
This is short for "IP Network Address Translation." In-and-of
itself, it can be used interchangeably with NAT. However, in
this document the term "ipnat" will be used solely for
command-line only use.
</p>
</ul>

<ul>
<strong>"IPF"</strong>

<p>
This is short for "IP Filter." IP Filter is a portable packet filtering
software that is included as part of OpenBSD.   IP Filter must be enabled
before you can turn on ipnat.  This is easy, just edit /etc/rc.conf
and change ipf=NO to ipf=YES.  That only changes it for the boot up sequence,
you also need to do 'ipf -E' to turn on ipf while you are booted.  Of course,
this is described further, below.
</p>
</ul>

<br>
<a name="nat1.3"></a>
<b>Configuration</b>

<p>
This is how the computers are setup concerning this document. Your setup will vary from this, but 
the purpose of the document is to give you an overview so you can conform this information to your setup.
</p>

<ul>
<b>Computer Operating System: </b>OpenBSD v2.7 i386<br>
<br>
<b>NICs: </b>
<ul>
	NetGear 10/100MB <b>dc0</b><br>
	Connected to the EXTERNAL LAN (or WAN)<br>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<br>
	NetGear 10/100MB <b>dc1</b><br>
	Connected to the INTERNAL LAN<br>
	<b>IP Address: </b>192.168.1.1<br>
	<b>Netmask: </b>255.255.255.0<br>	
</ul>
<br>
<b>External, Internet-routeable IP (provided by ISP, in this example, a cable modem provider)<br></b>
<ul>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<b>Gateway: </b>24.5.0.1<br>
</ul>
<br>
<b>Local Area Network</b><br>
<ul>
In this example,
machines on the LAN use the IP addressing scheme 192.168.1.xxx
(where xxx is a unique number). There are a variety of different
operating systems on the internal LAN including Windows 98,
Windows NT, OpenBSD and Linux. Each machine is connected to a hub
that is designated for internal use. For this document and its
examples the client on the LAN will assume IP address 192.168.1.40
</ul>
<br>
<b>Diagram of Configuration</b>
<ul><pre>
+-----+              +---------+         +----------+
| Hub |--------- dc1 |   NAT   | dc0 ----| Internet |
+-----+              +---------+         +----------+
  | |
  | +-- Client A
  +---- More clients 

                              +-------------------------+
                              |          LEGEND         |
                              +-------------------------+
                              |  NIC dc0 - 24.5.0.5     |
                              |  NIC dc1 - 192.168.1.1  |
                              | Client A - 192.168.1.40 |
                              +-------------------------+

</pre></ul>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Network Address Translation</u></h3>
<br>

<a name="nat2.1"></a>
<b>Introduction to NAT</b>

<p>
As more and more businesses and users get on the Internet, each one
must have an IP address. Public IP addresses are becoming harder and
harder to get. The solution for a lot of people has been Network
Address Translation (or "NAT"). NAT is a very simple, yet powerful way
to get your LAN connected to the Internet without having to purchase
or lease IP addresses for each machine. NAT is also known as "IP
Masquerading" if you're a Linux user.
</p>

<p>
When NAT is up and running correctly, it allows users on the internal
LAN to access the Internet through a different IP address (the one you
set up with your provider). Each machine on the LAN uses the one IP
address (transparently) of the one machine that is set up to use the
ISP assigned IP address.
</p>

<p>
The way NAT works is amazingly simple. When a client on the LAN
wants to connect to a machine on the Internet, it sends out a TCP
packet with a request to connect. Inside the TCP packet header is the
client's IP address (i.e. 192.168.1.40) and the requested host's IP
address (i.e. 123.45.67.89). The machine running NAT intercepts this
TCP packet and changes the client's IP address from 192.168.1.40 to
the IP address of the Internet-connected machine (i.e. 24.5.0.5). This
effectively tricks the host machine into thinking the actual connection
is from the NAT machine, not the actual client's machine. The host then
sends back responses to the NAT machine like it was the one connecting.
When the NAT machine receives the responses it quickly translates the
destination IP address back from itself to the client's machine and
sends the packet to the client. The client didn't have any idea of
what happened and spoofed Internet connectivity is totally transparent.
</p>

<p>
The example below shows NAT a little more clearly:
</p>

<ul><pre>
Client ----------------- dc1 [ NAT ] dc0 ---------- Internet Host
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

OUTGOING TCP Packet                     OUTGOING TCP Packet
From: 192.168.1.40  >>=== NAT ===>>     From: 24.5.0.5
To: 123.45.67.89                        To: 123.45.67.89

INCOMING TCP Packet                     INCOMING TCP Packet
From: 123.45.67.89 			From: 123.45.67.89
To:   192.168.1.40  <<=== NAT ===<<     To: 24.5.0.5
</pre></ul>

<br>
<a name="nat2.2"></a>
<b>Why to use NAT</b>

<p>
When presented with a cable modem in my new apartment I was also
presented with another minor problem. How to get Internet access to
my roommates, when the cable modem resides in my room? There were a
few options I could implement ranging from obtaining extra IP
addresses, to setting up a proxy server, to setting up NAT.
(Don't let the cable modem example fool you.  NAT is powerful enough
to masquerade a large network with hundreds or even thousands of computers!)
</p>

<p>
There are many reasons why I wanted to set up NAT. The number one
reason is for saving money. There
are two roommates in my house (each with their own PC) and myself with
3 computers. My ISP only allows for three IP addresses per household.
This means that there weren't enough IPs to allow every machine
internet access.
</p>

<p>
By using NAT each machine will have a unique (internal) IP address
but share the one IP address given to me by my ISP. The cost goes down.
</p>

<br>
<a name="nat2.3"></a>
<b>Setup</b>

<p>
In order to enable NAT on your OpenBSD machine you will need to turn on
IPF and NAT. This is easily accomplished by editing the files listed
below (make the changes to the file so it looks like the options below):
</p>

<p>
<b>/etc/rc.conf</b> (this file used to start services at boot time)
</p>

<ul>
	ipfilter=YES<br>
	ipnat=YES
</ul>

<p>
<b>/etc/sysctl.conf</b>
</p>

<ul>
	net.inet.ip.forwarding=1
</ul>

<p>
After these changes are made, the machine is now ready to for the
configuration of NAT.
</p>

<br>
<a name="nat2.4"></a>
<b>Configuration</b>

<p>
The first step is to configure the IPF rules file (<i>/etc/ipf.rules</i>).
For the purposes of this document we will allow traffic to pass
through this firewall option without any interference. The file
should look like this:
</p>

<ul><pre>
pass in from any to any
pass out from any to any
</pre></ul>

<p>
Again for more information you can read <a href="#6.2">FAQ 6.2</a>
</p>

<p>
The NAT configuration file (<i>/etc/ipnat.rules</i>) has a very simple syntax.
For the configuration set forth above, the file should contain the
following entry:
</p>

<ul><pre>
map dc0 192.168.1.0/24 -> 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -> 24.5.0.5/32
</pre></ul>

<p>
Here is an explanation for the above lines.
</p>

<ul>
<strong>"map"</strong>
<p>
This is the command you are giving ipnat. It is telling ipnat
that this entry is an entry to change IP addresses between the LAN
and the Internet.
</p>
</ul>

<ul>
<strong>"dc0"</strong>
<p>
This is the network interface that is connected to the Internet.
</p>
</ul>

<ul>
<b>"192.168.1.0/24"</b>
<p>
the IP address and netmask (the netmask is in
CIDR format). Combined they state "any IP address of value
192.168.1.1 through 192.168.1.254" should be mapped. If you would
prefer not to use CIDR notation you can substitute "/24" for
"/255.255.255.0".
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
This IP address and netmask state the IP address
that the LAN IP addresses will be mapped to.  /32 means one single
IP address.  You can also map to a /24, or 256 IP addresses (or a /27,
or whatever number of bits you'd like)!! This is
useful if you have several thousand client machines behind your NAT....
(Of course, this is only useful if that /24 is being routed to your OpenBSD
box!)
</p>
</ul>

<ul>
<b>"portmap tcp/udp 10000:60000"</b>
<p>
This maps all tcp/udp packets
to ports in the range of 10000 to 60000.
</p>
</ul>

<p>
The second line has almost the same entry except for the last portion.
This tells ipnat to map anything else (not tcp/udp, those packets are already
matched by the first line) to whatever port
it requests (used for ICMP, and other protocols). Once this
is in the file, all that's needed is to run the IPF daemon.
</p>

<br>

<a name="nat2.5"></a>
<b>Running</b>

<p>
Executing NAT is a very simple process also. Once the configuration is
complete, there are two ways to enable NAT. The first (and best way if
possible-to test the setup stage) is to reboot your OpenBSD machine.
This is accomplished with the command "<i>reboot</i>"
</p>

<p>
If you would like to run ipnat from the command line, use the following
commands:
</p>

<ul><pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre></ul>

<p>
The first line is to enable IPF (remember that NAT piggy-backs on IPF
therefore IPF must be initialized and running before NAT can be loaded).
The options on the command line "-Fa" clear out any existing entries
already in effect. "-f /etc/ipf.rules" tells ipf where the rules file
can be found. "-E" is the switch to enable the IPF daemon.
</p>

<p>
The second command line is to enable NAT. "-CF" clears and flushes all

existing entries in the NAT table. "-f /etc/ipnat.rules" tells NAT where

the NAT rules file is at. NAT is now running. It's as simple as that.
</p>


<p>
<b>Note:</b> in order to reload the NAT settings (in case you edit the file
but don't want to reboot) just execute the 2nd command over again. The
settings will be flushed and reloaded.
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 Nat Knowledge Base</u></h3>

<br>
<a name="nat3.1"></a>
<b>Checking NAT Status</b>

<p>
To find out how NAT is doing or make sure the settings have taken
effect, you use the "-l" option. This option will list all the
settings and current sessions that ipnat is running:
</p>

<ul><pre>
# <b>ipnat -l</b>
map dc0 192.168.1.0/24 -> 24.5.0.5/32 portmap tcp/udp 10000:60000
map dc0 192.168.1.0/24 -> 24.5.0.5/32

List of active sessions:
MAP 192.168.1.40  2473  <- -> 24.5.0.5  13463 [129.128.5.191 80]
</pre></ul>

<p>
The purpose of the first two lines is to confirm the settings that
were entered in /etc/ipnat.rules earlier. The line(s) below will show
you a list of the current NAT controlled connections.
</p>

<ul>
<b>"MAP 192.168.1.40  2473"</b>
<p>
This tells you the IP address of the
machine on the LAN that is using NAT. The port number used to make
the connection is displayed afterwards.
</p>
</ul>

<ul>
<b>"&lt;- -&gt;"</b>
<p>
This shows that NAT is handling the flow of traffic
in both directions.
</p>
</ul>

<ul>
<b>"24.5.0.5  13463"</b>
<p>
This denotes that the connection is going
to the Internet via IP address 24.5.0.5 and using port 13463.
</p>
</ul>

<ul>
<b>"129.128.5.191 80"</b>
<p>
The IP address and the port being connected
to are listed last.
</p>
</ul>

<a name="nat3.2"></a>
<b> Limitations of NAT (in FTP)</b>

<p>
There are a few limitations of NAT. One is with FTP. When a user connects
to a remote FTP server and requests information or file, the FTP server
will make a connection to the client and transfer the info. This is done
on a random free port. This is a problem for users attempting to gain
access to FTP servers from within the LAN. When the FTP server sends its
information it sends it to the external NIC at a random port. The NAT
machine will receive this, but because it has no mappings for the unknown
packet and doesn't have any mappings for that port, it will drop the
packet and won't deliver it.

<p>
The solution to this is to place yourself in "passive mode" in your
FTP client. This will tell the server that you want to connect to the
server, and not what you just read. Then when you make that connection out
NAT will correctly handle your connection.
<P>
IP Filter provides another solution for this situation,
that is, an ftp proxy which is built-in to the NAT code.
To activate it, put something like this before your other NAT mappings.
<PRE>
map dc0 192.168.1.0/24 -> 24.5.0.5/32 proxy port ftp ftp/tcp
</pre>
With this in place, the kernel will watch your FTP connections
for the "PORT" command coming from the ftp client, and it will
replace the IP address and port with it's own outside IP address, and a port
of its own choosing.  Then it will open up that port and tunnel the
data to the port your ftp client asked for.  Obviously, this is slightly
more resource intensive.  But, unless your NAT/IP Filter box is reaching
critical mass, you should be fine.
<P>


<br>
<a name="nat3.3"></a>
<b>Redirecting Traffic</b>

<p>
        At times you may need to redirect incoming or outgoing traffic for
        a certain protocol or port. A good example of this is if there were a
        server residing inside the LAN running a web server. Incoming connections
        to your valid Internet IP will find that unless your NAT box is running
        a web server, no connection can be made. For this purpose we use the
        NAT 'rdr' directive in the rules file to instruct where to redirect
        (or route) a particular connection to.
</p>

<p>

        For our example, lets say a web server resides on the LAN with IP address
        of 192.168.1.80. The NAT rules file needs a new directive to handle this.
        Add a line similar to the following one to your ipnat.conf:
</p>

<ul><pre>
rdr dc0 24.5.0.5/32 port 80 -> 192.168.1.80 port 80
</pre></ul>

<p>
The reason for each line is this:
</p>

<ul>
<b>"rdr"</b>
<p>
This is the command you are giving ipnat. It is telling ipnat
that this entry is an entry to redirect a connection. 
</p>
</ul>


<ul>
<b>"dc0"</b>
<p>
This is the network interface that is connected to the Internet.
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
This means an incoming connection to this IP address (only on dc0, as above)
</p>
</ul>

<ul>
<b>"port 80"</b>
<p>
This is the port (80) that should be redirected. The number
"80" didn't have to be used. You can use "port www" also to specify
a redirection of port 80. If you would like to use a name instead of
a number, the service name and corresponding port, must exist in the
file /etc/services.
</p>
</ul>

<ul>
<b>"192.168.1.80"</b>
<p>
The IP address and netmask of the LAN machine
which the packets are redirected to. The netmask is always "/32"
(and therefore not needed to be specified) so
the packets can be redirected to a particular machine.
</p>
</ul>

<p>
When the addition is complete reload the NAT rules, and the redirection
will start immediately.
</p>

<br>
<a name="nat3.4"></a>
<b>NAT versus Proxy</b>

<p>
The difference between NAT and an application-based proxy is that the proxy
software acts as a middle-man between the Internet and the machines connected
on the LAN. This is fine, however each application you want to run on
your machine and connect to the Internet through the proxy server MUST
be proxy-aware (be able to use a proxy server). Not all applications are
able to do this (especially games). Furthermore, there simply are not
proxy server applications for all of the Internet services out there.
NAT transparently maps
your internal network so that it may connect to the Internet.  The only
security advantage to using a proxy software over NAT is that the proxy
software may have been made security aware, and can filter based on content,
to keep your Windows machine from getting a macro virus, it can protect
against buffer overflows to your client software, and more.  To maintain
these filters is often a high-maintenance job.
</p>

<a name="nat4.0"></a>
<b>6.3.4 Links and X-References</b>

<p>
OpenBSD files:
<ul>
<li>/etc/ipnat.rules - NAT rules file
<li>/etc/rc.conf - need to edit to start up ipnat and ipf at boot time
<li>/etc/sysctl.conf - need to edit to enable IP forwarding
<li>/usr/share/ipf/nat.1 - samples of ipnat.rules
</ul>
</p>

<p>
NAT Internet Links:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8">http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=5&format=html">Man page showing correct ipnat.rules syntax</a>
<li><a href="http://coombs.anu.edu.au/~avalon/">http://coombs.anu.edu.au/~avalon/</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>

<p> 
<a name= "6.4"></a> <h2>6.4 - DHCP</h2> </p>

<h3>6.4.1 DHCP Client</h3>
<p>To use the DHCP client <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&apropos=0&sektion=8&format=html">dhclient(8)</a>
included with OpenBSD, edit /etc/hostname.xl0
(this is assuming your main ethernet interface is xl0.  Yours might be ep0 or fxp0 or something else!)
All you need to put in this hostname file is 'dhcp'
<pre>
# <strong>echo dhcp >/etc/hostname.xl0</strong>
</pre>
This will cause OpenBSD to automatically start the DHCP client on boot.  OpenBSD will gather its IP address,
default gateway, and DNS servers from the DHCP server.  
<p>
If you want to start a dhcp client from the command line, make sure
/etc/dhclient.conf exists, then try:
<PRE>
# <strong>dhclient fxp0</strong>
</pre>
Where fxp0 is the interface that you want to receive dhcp on.
<P>No matter how you start the dhclient, you can edit
the /etc/dhclient.conf file to <b>not</b> update your DNS according to the dhcp
server's idea of DNS by first uncommenting the 'require' lines in it (they are
examples of the default settings, but you need to uncomment them to override
dhclient's defaults.)
<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>
and then <b>remove</b> domain-name-servers.  Of course, you may want to remove
hostname, or other settings too.
<P>
<h3>6.4.2 DHCP Server</h3>

If you want to use OpenBSD as a DHCP server <A href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&apropos=0&sektion=8&format=html">dhcpd(8)</a>,
edit /etc/rc.conf.  Set it up so that dhcpd_flags="-q" instead of dhcpd_flags=NO.
Put the interfaces that you want dhcpd to <b>listen</b> on in /etc/dhcpd.interfaces.
<pre>
# <strong>echo xl1 xl2 xl3 >/etc/dhcpd.interfaces</strong>
</pre>
Then, edit /etc/dhcpd.conf.
The options are pretty self explanatory.
<pre>
        option  domain-name "xyz.mil";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>
<p>
This will tell your dhcp clients that the domain to append to DNS requests is xyz.mil (so, if the user types in 'telnet joe' then it will
send them to joe.xyz.mil).  It will point them to DNS servers 192.168.1.3 and 192.168.1.5.  For hosts that are on the same network as
an ethernet interface on the OpenBSD machine, which is in the 192.168.1.0/24 range, it will assign them an IP address between
192.168.1.32 and 192.168.1.127.  It will set their default gateway as 192.168.1.1.
<p>
If you want to start dhcpd from the command line, after editing /etc/dhcpd.conf,
try:
<PRE>
# <strong>dhcpd -q fxp0</strong>
</PRE>
Where fxp0 is an interface that you want to start serving dhcp on.
The -q flag makes dhcpd quiet, otherwise it is very noisy.
<P>
If you are serving DHCP to a Windows box, you may want to
dhcpd to give the client a 'WINS' server address.
To make this happen, just the following line to your /etc/dhcpd.conf:
<pre>
option	netbios-name-servers	192.168.92.55;
</pre>
(where 192.168.92.55 is the IP of your Windows or Samba server.)
See <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&apropos=0&sektion=5&format=html">dhcp-options(5)</a> for more options that your DHCP
clients may want.
<p>
<a name= "6.5"></a>
<h2>6.5 - PPP </h2>
</p>

Point-to-Protocol is generally what is used to create a connection to your ISP via your modem. OpenBSD has 2 ways of doing this. 

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8&format=html">pppd(8)</a> - Which is
the kernel ppp daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> - Which is
the userland ppp daemon. 
</ul>

<p>
The first one we will cover will be the userland PPP daemon. To start off you will need some simple
information about your isp. Here is a list of helpful information that you will need.
</p>

<ul>
<li>Your ISP's dialup number
<li>Your nameserver 
<li>Your username and password.
<li>Your gateway
</ul>

<p>
Some of these you can do without, but would be helpful in setting up your ppp. The userland PPP daemon uses
the file <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> as
its configuration file. There are many helpful files in <b>/etc/ppp</b> that can have different setups for
many different situations. You should take a browse though that directory.
</p>

<p>
Also, make sure, that if your not using a GENERIC kernel, that you have this line in your configuration file:
</p>

<ul><pre><strong>
pseudo-device   tun             2
</strong></pre></ul>


<h3>Initial Setup - for PPP(8)</h3>

<p>
Initial Setup for the userland PPP daemon consists of editing your <b>/etc/ppp/ppp.conf</b> file. This file
doesn't exist by default, but there is a file <b>/etc/ppp/ppp.conf.sample</b> in which you can simply edit to
create your own <b>ppp.conf</b> file. Here I will start with the simplist setup and probably most used setup.
Here is a quick <b>ppp.conf</b> file that will simply connect to your ISP and set your default routes and
nameserver. With this file all the information you need is your ISP's phone number and your username and
password.
</p>

<ul>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</ul>

<p>
<b>NOTICE</b> - On OpenBSD 2.6, the system shipped with a <i>/etc/ppp/ppp.conf.example</i> that had an incorrect setting for device. The device was <i>"set device /dev/cuaa0"</i>. This should be <i>/dev/cua00</i> which would correspond to serial device 1. (COM1). Your device might not be on COM1, however the naming scheme was wrong.
</p>

<p>
The section under the <b>default:</b> tag will get executed each time. Here we setup all our critical
information. Here with &quot;set log&quot; we set our logging levels. This can be changed, refer to 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> for more info on
setting up logging levels. Our device gets set with &quot;set device&quot;. This is the device that the modem
is on. In this example the modem is on com port 2. Therefore com port 1 would be /dev/cua00. With &quot;set
speed&quot; we set the speed of our dialup connection and with &quot;set dial&quot; we set our dialup
parameters. With this we can change our timeout time, etc. This line should stay pretty much as it is though.
</p>

<p>
Now we can move on and setup our information specific to our ISP. We do this by adding another tag under our
<b>default:</b> section. This tag can be called anything you want, easiest to just use the name of your ISP.
Here I will use <b>myisp:</b> as our tag referring to our ISP. Here is a simple setup incorporating all we need
to get ourselves connected.
<p>

<ul>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</ul>

<p>
Here we have setup essential info for that specific ISP. The first option &quot;set phone&quot; sets your
ISP's dialup number. The &quot;set login&quot; sets our login options. Here we have the timeout set to 5, this
means that we will abort our login attempt after 5 seconds if no carrier. Otherwise it will wait for
&quot;login:&quot; to be sent and send in your username and password. In this example our Username = ppp and
Password = ppp. These values will need to be changed. The line &quot;set timeout&quot; sets the idle timeout for
the entire connection duration to 120 seconds. The &quot;set ifaddr&quot; line is a little tricky. Here is a more
extensive explanation.
</p>

<ul><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></ul>

<p>
In the above line, we have it set in the format of &quot;<b>set ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask
[triggeraddr]]]]</b>&quot;. So the first IP specified is what we want as our IP. If you have a static IP address, you set it here. In our example we use /0
which says that no bits of this ip address need to match and the whole thing can be replaced. The second IP
specified is what we expect as their IP. If you know this you can specify it. Again in our line we don't know
what will be assigned, so we let them tell us. The third option is our netmask, here set to 255.255.255.0.If
triggeraddr is specified, it is used in place of myaddr in the initial IPCP negotiation.  However, only an
address in the myaddr range will be accepted.  This is useful when negotiating with some PPP implementations
that will not assign an IP number unless their peer requests ``0.0.0.0''.
</p>

<p>
The next option used &quot;add default HISADDR&quot; sets our default route to their IP. This is 'sticky',
meaning that if their IP should change, our route will automatically be updated. With &quot;enable dns&quot;
we are telling our ISP to authenticate our nameserver addresses. Do NOT do this if you are running an local
DNS, as ppp will simply circumvent its use by entering some nameserver lines in /etc/resolv.conf.
</p>

<h3>Using PPP(8)</h3>

<p>
Now that we have our <b>ppp.conf</b> file setup we can start trying to make a connection to our ISP. I will
detail some commonly used arguments with ppp.
</p>

<ul>
<li><b>ppp -auto myisp</b> - This will run ppp, configure your interfaces and connect to your isp and then go
into the background.
<li><b>ppp -ddial myisp</b> - This is similar to -auto, but if your connection is dropped it will try and
reconnect.
</ul>

<p>
By using <b>/usr/sbin/ppp</b> with no options will put you into interactive mode. From here you can interact
directly with the modem, it is great for debugging problems in your <b>ppp.conf</b> file.
</p>

<h3>ppp(8) extra's</h3>

<p>
In some situations you might want commands executed as your connection is
made or dropped. There are two files you can create for just these
situations. <b>/etc/ppp/ppp.linkup</b> and <b>/etc/ppp/ppp.linkdown</b>.
Sample configurations can be viewed here:
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Extended information can be found at <a href="http://www.freebsd.org/handbook/userppp.html">http://www.freebsd.org/handbook/userppp.html</a> or <a href="http://www.freebsd.org/faq/userppp.html">http://www.freebsd.org/faq/userppp.html</a>.
</p>

<p>
<a name= "6.6"></a>
<h2>6.6 - Tuning networking parameters</h2>

<H3>6.6.1 - How can I tweak the kernel so that there are a higher number of retries and longer timeouts for TCP sessions?</h3>
You would normally use this to allow for routing or connection problems.
Of course, for it to be most effective, both sides of the connection
need to use similar values.
<P>
To tweak this, use <tt>sysctl</tt> and increase the values of:
<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>
Using sysctl -a, you can see the current values of these (and many other)
parameters.  To change one, use <tt>sysctl -w</tt>, as in <tt>sysctl -w
net.inet.tcp.keepidle=28800</tt>.  
<h3>6.6.2 - How can I turn on directed broadcasts?</h3>
Normally, you don't want to do this.  This allows someone to send
traffic to the broadcast address(es) of your connected network(s) if you
are using your OpenBSD box as a router.<P>
There are some instances, in closed networks, where this may be useful,
particularly when using older implementations of the NetBIOS protocol.
This is another sysctl.  <Tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> 
turns this on.  Read about <A HREF="http://www.netscan.org">smurf attacks</a>
if you want to know why it is off by default.
<H3>6.6.3 - I don't want the kernel to dynamically allocate a certain port</h3>
There is a sysctl for this also.  From <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:
<PRE>
Set the list of reserved TCP ports that should not be allocated by the
kernel dynamically.  This can be used to keep daemons from stealing a
specific port that another program needs to function.  List elements may
be separated by commas and/or whitespace.

   sysctl -w net.inet.tcp.baddynamic=749,750,751,760,761,871

It is also possible to add or remove ports from the current list.

   sysctl -w net.inet.tcp.baddynamic=+748
   sysctl -w net.inet.tcp.baddynamic=-871
</pre>

<a name="6.7"></a>
<h2>6.7 - Simple NFS usage</h2>

<p> NFS, or Network File System, is used to share a filesystem over the
network. A few choice man pages to read before trying to setup a NFS
server are:

<p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8&format=html">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8&format=html">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>
</ul>

<p>
This section will go through the steps for a simple setup of NFS. This example
details a server on a LAN, with clients accessing NFS on the LAN. It
does not talk about securing NFS. We presume you have already setup
packet filtering or other firewalling protection, to prevent outside access.
If you are allowing outside access to your NFS server, and you have
any kind of sensitive data stored on it, we strongly recommend that you employ 
<A HREF="faq13.html">IPSec</a>.  Otherwise, people can potentially see your NFS
traffic.  Someone could also pretend to be the IP address which you are 
allowing into your NFS server.  There are several attacks that can result.
When properly configured, IPSec protects against these types of attacks.
<P>
Another important security note.  Don't
just add a filesystem to /etc/exports without some kind of list of allowed
host(s). Without a list of hosts which can mount a particular directory,
anyone on who can reach your host will be able to mount your NFS
exports.
</p>

<p>
The setup consists of a server with the ip <b>10.0.0.1</b>. This server
will be serving NFS only to clients within that network. The first step to
setting up NFS is to setup your <i>/etc/exports</i> file. This file lists
which filesystems you wish to have accessible via NFS and defines who is
able to access them. There are many options that you can use in your
<i>/etc/exports</i> file, and it is best that you read the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>
man page. For this example we have an <i>/etc/exports</i> that looks like
this:
</p>

<ul><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></ul>

<p>
This means that the local filesystem <b>/work</b> will be made available
via NFS. <b>-alldirs</b> specifies that clients will be able to mount at
any point under the <b>/work</b> mount point. <b>-ro</b> specifies that it
will only be allowed to be mounted read-only. The last two arguments
specify that only clients within the 10.0.0.0 network using a netmask of
255.255.255.0 will be authorized to mount this filesystem. This is
important for some servers that are accessible by different networks.
</p>

<p> Once your <i>/etc/exports</i> file is setup, you can go ahead and
setup your NFS server. You should first make sure that options NFSSERVER
& NFSCLIENT are in your kernel configuration. (GENERIC kernel has these
options included.) Next, you should set <strong>nfs_server=YES</strong> in
<i>/etc/rc.conf</i>. This will bring up both nfsd(8) and mountd(8) when
you reboot. Now, you can go ahead and start the daemons yourself. These
daemons need to be started as root, and you need to make sure that
portmap(8) is running on your system. Here is an example of starting
nfsd(8) which serves on both TCP and UDP using 4 daemons.  You should set
an appropriate number of NFS server daemons to handle the maximum number of
concurrent client requests that you want to service.

<P>

<ul><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></ul>

<p>
Not only do you have to start the nfsd(8) server, but you need to start
mountd(8). This is the daemon that actually services the mount requests on
NFS. To start mountd(8), simply type:
<p>

<ul><pre>
# <strong>/sbin/mountd</strong>
</pre></ul>

<P>
If you make changes to /etc/exports while NFS is already running,
you need to make mountd aware of this!  Just HUP it:

<UL><PRE>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></ul>

<P>

<h3>Checking Stats on NFS</h3>

<p>
From here, you can check to make sure that all these daemons are up and
registered with RPC. To do this, use rpcinfo(8). 
<p>

<ul><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></ul>

<p> During normal usage, there are a few other utilities that allow you to
see what is happening with NFS. One is <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8&format=html">showmount(8)</a>
, which allows you to view what is currently mounted and who is mounting
it. There is also nfsstat(8) which shows much more verbose statistics. To
use showmount(8), try <b>/usr/bin/showmount -a host</b>. For
example:

<P>

<ul><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></ul>

<h3>Mounting NFS Filesystems</h3>

<p>
NFS filesystems should be mounted via mount(8), or more specifically,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8&format=html">mount_nfs(8)</a>.
To mount a filesystem /work on host 10.0.0.1 to local filesystem /mnt,
do this (note that you don't need to use an IP address, mount will resolve
host names):
<p>

<ul><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></ul>

<P>
To have your system mount upon boot,
add something like this to your <i>/etc/fstab</i>:
<P>

<UL><PRE>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></ul>

<P>
It is important that you use <tt>0 0</tt> at the end of this line so that
your computer does not try to fsck the NFS filesystem on boot!!!!
The other standard security options, such as noexec, nodev, and nosuid,
should also be used where applicable.  Such as:
<P>

<UL><PRE>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></ul>

<P>
This way, no devices or setuid programs on the NFS server can subvert security measures
on the NFS client.  If you are not mounting programs which you expect
to run on the NFS client, add noexec to this list.


<a name="6.8"></a>
<h2>6.8 - Domain Name Service  - DNS, BIND, and named</h2>

<h3>6.8.1 What is DNS?</h3>

<p>
Domain Name Service is a network facility allowing IP network domains to provide name-to-IP address resolution and IP address-to-name resolution in response to a query. Your OpenBSD installation is configured by default as a DNS client but not as a DNS server. That is, your OpenBSD installation can perform a DNS query against a domain name server for the address of a machine, but it cannot answer such DNS queries itself unless you specifically configure it to do so.</p>

<p>
My OpenBSD machine is currently connected to the Internet via my ISP, so I can use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a> utility to execute the DNS query:
</p>

<ul><pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre></ul>

<p>
<b>165.87.201.244</b> is the name server which answered, because it is the nameserver that my ISP told me to use with my account and whose number is entered in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a>. But the answer was not authoritative. For an authoritative answer, let's find which is the authoritative DNS server for the <i>openbsd.org</i> domain and ask it for the address of <i>www.openbsd.org</i>:
</p>

<ul><pre>
# Identify the name servers for openbsd.org
# with the help of my ISP's name server.
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet address = 199.185.137.3
gandalf.sigmasoft.com   internet address = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Use the info gained to query for an authoritative
# resolution: query the authoritative zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Address:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre></ul>

<p>
<i>zeus.theos.com</i> is, one would suppose, running OpenBSD and is properly configured to be a DNS server for the <i>openbsd.org</i> domain.
</p>

<a name="6.8.1.1"></a>
<h3>6.8.1.1 Where can I learn all about DNS and its implementation under OpenBSD?</h3>

<ul>
<li>See RFC's <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, <a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a>, and <a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> for more information on the Internet name-domain system.</li>
<li>Read the O'Reilly Associates book <i><a href="../books.html#dns&bind">DNS and BIND</a> </i>.</li>
<li>Read the <a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD Manual</a> especially the pages for</li>
	<ul>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&sektion=3&format=html">gethostbyname(3)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&sektion=8&format=html">named(8)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=3&format=html">resolver(3)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=5&format=html">resolver(5)</a>
	</ul>
</ul>

<p>
The <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> command is especially useful, because it can query a domain and return information in much the same record format as required in BIND configuration files. You can use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> to examine name servers you know to be operating properly as a way of comparing your setup to theirs.
</p>

<h3>6.8.2 Does my machine need to be a domain name server?</h3>

<p>
If you aren't sure that you need your machine to perform the role of DNS server, don't configure it as one. The OpenBSD installation does not, by default, activate your machine as a domain name server, though all necessary files are installed. For most workstations, just the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5&format=html">/etc/hosts</a> file naming local machines' IP addresses and the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a> file for indicating which DNS servers serve you out on the intranet or internet is sufficient.
</p>

<p>
On the other hand, you might need to set up a machine as a domain name server:
<ul>
<li>If you have an IP LAN on which you do not wish to replicate "hosts" files of local addresses machine by machine. In such a case, you may configure your OpenBSD machine as a DNS server and serve queries from the other machines on your LAN.</li>
<ul>
<li><b>Note:</b> There is no practical restriction on the number of DNS servers on a LAN. Any or all machines on the LAN may offer DNS service if they are so configured. Whether any such server is considered authoritative from outside your LAN (or is even known from outside your LAN) is a configuration factor which typically is controlled at the next level up from your LAN in the domain hierarchy.</li>
</ul>
<li>If you have an IP LAN on which reside machines you will wish to be findable via DNS query by machines on another IP LAN or WAN.</li>
<li>If you experience difficulties resolving the local hostname to an IP address, or resolving other local names to IP addresses even though you have correct <i>/etc/hosts</i> and <i>/etc/resolv.conf</i> (E.g., Netscape on OpenBSD sometimes exhibits this behavior because it implements its own resolver instead of just using <i>gethostbyname(3)</i> to look up addresses.)</li>
</ul>

<p>
One more consideration is speed of execution. Since name resolution is an iterative process, in which the name server makes repeated queries to other nameservers for addresses in remote domains, name resolution may take slightly longer if you have a modem connection to the Internet and are querying your own DNS server for remote addresses (which will then iteratively query remote name servers via the modem) than if you are querying your ISP's name server (which probably has a faster connection to remote name servers).
</p>

<h3>6.8.3 What are the software components of the DNS server?</h3>

<ul>
<li>named <i>("name daemon")</i></li>
<li>Configuration files in the directory hierarchy under <i>/var/named/</i></li>
</ul>

<h4>6.8.3.1 What level of BIND is supported?</h4>

<p>
BIND is the name of the behavioral specification of a domain name server. Domain name server components exist to collectively implement BIND. 
</p>

<p>
There are two distinct BIND specifications:
<ol>
<li>BIND 4</li>
<li>BIND 8</li>
</ol>

<p>
As installed, OpenBSD <b>named</b> supports BIND 4.x.

<h4>6.8.3.2 What are some of the alternatives to providing DNS via the default BIND 4.x implementation?</h4>

<ul>
<li>The BIND 8.x implementation in <i>/usr/ports/net/bind8</i>.(See <a href="../ports.html">ports</a>)
<li>D. J. Bernstein's <a href="http://cr.yp.to/dnscache.html">DNSCache</a>. DNSCache is also available in the ports tree at <i>/usr/ports/net/dnscache/</i>.
This program includes a minimalist DNS server which is perfect for sites who
do not have a large existing database of DNS entries.  DNSCache could easily
be script driven.  Its setup does not resemble anything below, but is well
documented at its web page.
<LI>Some people who were particularly unhappy with BIND decided to write Dents
their own DNS server from scratch, <A HREF="http://www.dents.org">Dents</a>.
It contains some interesting features.
</ul>

<h5>6.8.3.2.1 <u>Security</u> note</h5>

<p>
If you use these alternative implementations of domain name service, you are providing a critical network service using software which may not have been subject to quite the same level of scrutiny as the <a href="http://www.openbsd.org/security.html">security-audited</a> <b>named</b> name daemon in the base installation. This is a significant consideration, since if a domain name server is compromised, resolvers using that name server can be re-directed to impostor sites.
</p>

<h3>6.8.4 How much do I have to install?</h3>

<p>
If the default networking setup was installed properly at OpenBSD installation time, everything is already installed. You just have to configure the name daemon ("<tt>named</tt>").
</p>

<h3>6.8.5 How do I configure DNS?</h3>

<p>
You configure OpenBSD DNS by editing and/or creating files that control the name daemon <tt>named</tt>. These files reside by default in the directory <i>/var/named</i> and its subdirectories, especially the file <i>/var/named/named.boot</i> which is the initialization file for <b>named</b>. There are also a couple of other configuration steps to be taken in <i>/etc</i>.
</p>

<p>
In this document, we will configure the name daemon on <i>nemo.yewtopia.com</i> be the primary nameserver for the (very small!) domain <i>yewtopia.com</i>. The address of <i>nemo.yewtopia.com</i> is <i>192.168.1.9</i>. Two other machines are on that subnet, <i>crater.yewtopia.com </i>at 192.168.1.1 and <i>earhart.yewtopia.com</i> at 192.168.1.2.
</p>

<h4>6.8.5.1 Configuration in <i>/var/named</i></h4>

<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<ul><pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain                source host/file
backup file
cache
root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre></ul>

<p>
This tells the initialization process in what subdirectory and under which filenames to find the configuration files for <i>yewtopia.com</i>. 

<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<ul><pre>
; Reverse lookup for localhost interface
@       IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre></ul>

<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<ul><pre>
; yewtopia.com domain database
yewtopia.com.        IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre></ul>

<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<ul><pre>
; yewtopia domain reverse lookup database
1.168.192.in-addr.arpa. IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre></ul>

<h4>6.8.5.2 Configuration in <i>/etc</i></h4>

<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>
<p>
Make sure <i>/etc/resolv.conf</i> now points to the domain of local machine (instead of, for example, your ISP's name server) so that name resolution requests actually get sent to the <b>named</b> you have configured!
</p>

<ul><pre>
domain yewtopia.com
lookup file bind
</pre></ul>

<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>
If you previously had added the addresses of various machines to the <i>/etc/hosts</i> file, you might consider shortening your <i>/etc/hosts</i> file back to the default:
</p>

<ul><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></ul>

<p>
So that <b>named</b> isn't bypassed in favor of (possibly outdated) addresses in the <i>/etc/hosts</i> file. <u>Make sure you have at least the default <i>localhost</i> entry</u> or your network won't start properly! Note also <i>nemo</i> must appear in its own hosts file or you will see a (mostly harmless) error message at bootup when <i>/etc/netstart</i> invokes <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8&format=html">route(8)</a> in order to add <i>nemo</i> (whose name appears in <i>/etc/myname</i>).
</p>

<h4>6.8.5.3 Using <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> to examine the results.</h4>

<ul><pre>
$ <strong>dig @nemo.yewtopia yewtopia any any</strong>

; <<>> DiG 2.2 <<>> @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia, type = ANY, class = ANY

;; ANSWERS:
yewtopia.        3600   SOA     nemo.yewtopia.
your_id.nemo.yewtopia. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.        3600   NS      nemo.yewtopia.

;; ADDITIONAL RECORDS:
nemo.yewtopia.   3600   A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre></ul>

<h3>6.8.6 How and when do I start and stop DNS?</h3>

<h4>6.8.6.1 Starting DNS</h4>

<p>
The name daemon <b>named</b> is launched during system startup from <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8&format=html">/etc/rc</a> if the line installed by default in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8&format=html">/etc/rc.conf</a>.
</p>

<ul><pre>
named_flags=NO          # for normal use: ""
</pre></ul>

<p>
is changed to
</p>

<ul><pre>
named_flags=""          # for normal use: ""
</pre></ul>

<p>
Also, examine these lines in /etc/rc.conf:
</p>

<ul><pre>
named_user=named                # Named should not run as root unless necessary
named_chroot=/var/named         # Where to chroot named if not empty
</pre></ul>

<p>
These defaults will be correct for nearly all setups.
</p>

<p>
To start <b>named</b> by hand, use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> command. For example:
</p>

<ul><pre>
# <strong>ndc start</strong>
          or
# <strong>ndc restart</strong>
</pre></ul>

<h4>6.8.6.2 Stopping DNS</h4>

<p>
The best way to stop the name daemon is to use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> command. For example:
</p>

<ul><pre>
# <strong>ndc stop</strong>
</pre></ul>

<p>
If this fails to work, find the process id of named and use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&sektion=1&format=html">kill(1)</a> command to end that process. The PID for <b>named</b> while it is running is found as the first line in the file <i>/var/named/named.pid</i>
</p>

<ul><pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</pre></ul>

<h4>6.8.6.3 Restarting DNS with an altered configuration</h4>

<p>
To cause a running instance of the name daemon to restart itself reloading its configuration after you have made changes, send it a "hangup" signal:
</p>

<ul><pre>
# <strong>kill -HUP 4608</strong> 
</pre></ul>

<p>
or by using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> command. For example:
</p>

<ul><pre>
# <strong>ndc reload</strong>
</pre></ul>

<h3>6.8.7 How do I block AXFR queries? </h3>
<p>
example:
<ul><pre>
garden:/home/jeremy$<strong>  host -l openssh.com</strong>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></ul>
<p>
This information is useful for debugging DNS, but in some instances you may not want this output publically offered.
If you are using classless in-addr(rfc2317) for reverse, host -l may report every domain that your system hosts!
This can easily be remedied by the 'allow-transfer' clause in your zone file.
<br><br>
If you're using Bind8 you need to specify the hosts you want to allow to transfer zones in your individual zone file(s):
<ul><pre>
zone "foo.com" in {
        type master;
        file "directory/zonefile";
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></ul>
You can also block transfers for all domains by editing /var/named.conf and add the 'allow-transfer' parameter to the 'options' section of the configuration file:
<ul><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></ul>
The Bind8 method also works with Bind9.<br>
If you are using Bind 4 (default in OpenBSD) you can edit /var/named/named.boot and use the 'xfrnets' option.<br>
<ul><pre>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></ul><br>
Bind 4 allows transfers from entire classes so it is not as exact.
Typically, the only hosts that need to perform transfers are your DNS slaves and hosts you may want to debug from (127.0.0.1 is usually a good host to
allow transfers from!)
Blocking AXFR queries adds an extra level of privacy, but can hinder useful DNS debugging.
(Thanks to <a href=mailto:ntang@nachtwache.org>Nicholas Tang</a> for that tip)
</p>
<h3>6.8.8 What didn't you tell me about setting up DNS?</h3>
<p>
There's a lot we didn't tell you, for example, how to set up DNS so that queries for intranet domains that aren't visible from the root of the domain hierarchy get relayed to servers within your enterprise. Read the <a href="#6.8.1.1">documents we recommended</a> for more information on DNS. 
</p>

<a name="6.9"></a>
<h2>6.9 - Setting up a PPTP connection in OpenBSD</h2>

<p>
<strong>NOTE:</strong> This does not apply to <strong>ALL</strong> ADSL providers, but much information can be gleaned from the setup here. This is known to work for <a href="http://www.inode.at">Inode</a>, an ADSL provider in Austria.
</p>

<p>
To start off, you need to install pptp. A port was added to the OpenBSD ports tree AFTER the release of OpenBSD 2.8 and works fine with with the OpenBSD 2.8 ports tree. The port is located at <i>/ports/net/pptp</i>. Read <a href="faq8.html#8.6">FAQ 8.6</a> for more information on the OpenBSD ports tree.
</p>

<p>
Because of a conflict between the In-Kernel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html">gre(4)</a> support and pptp, you will need to re-compile your kernel, removing support for gre(4).
</p>

<ul>Patch to remove GRE(4) support.
<pre>
Index: sys/conf/GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.66
diff -u -r1.66 GENERIC
--- sys/conf/GENERIC    2000/10/13 04:21:14     1.66
+++ sys/conf/GENERIC    2000/12/26 19:55:31
@@ -97,6 +97,6 @@
 pseudo-device  ksyms   1	# kernel symbols device
 pseudo-device  bridge  2	# network bridging support
 #pseudo-device vlan    2	# IEEE 802.1Q VLAN
-pseudo-device  gre     1	# GRE encapsulation interface
+#pseudo-device gre     1	# GRE encapsulation interface

 option		BOOT_CONFIG     # add support for boot -c
</pre></ul>

<p>
To recompile your kernel, check out OpenBSD 2.8-stable via cvs (refer to <a href="../stable.html">OpenBSD Stable</a> web page for more information), apply the following patch, and rebuild your kernel as per <a href="faq5.html#5.3">FAQ 5.3</a>.
</p>

<p>
After you have the <b>pptp</b> package installed and a new kernel, you need to edit a few files to setup for your connection. This packages uses the in-house OpenBSD 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html">ppp(8)</a>, so if you are familiar with ppp(8), much of the setup is the same. Also, refer to <a href="#6.5">FAQ 6.5</a>.
</p>

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
For the <i>/etc/ppp/options</i> file, a setup like below will most likely
do all that you need:
</p>

<ul><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></ul>

<p>
<tt>LOGINNAME</tt> should be replaced with your User-ID.
</p>

<p>
The <i>/etc/ppp/pap-secrets</i> a line like:

<ul><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></ul>

<p>
Where LOGINNAME is your User-ID and PASSWORD is your password. 10.0.0.138 is the IP assigned to your MODEM in the case that you are using ADSL, etc. Make sure this file stays readonly by root (mode 600).
</p>

<h3>6.9.1 - Assigning an address to your Network Interface</h3>

<p>
In the above example, our modem came with a preconfigured interface of 10.0.0.138. We now need to assign an address to OUR interface, It's best to pick an IP close to the one given by your MODEM, or use the static IP assigned to you. Read more about setting up interfaces in <a href="#6.1">FAQ 6.1</a>.
</p>

<p>
Once your interface is setup, you should be able to create a pptp connection with the command.

<ul><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &</strong>
</pre></ul>

<p>
Since this uses the in-house OpenBSD ppp(8), two processes are started. You can kill pptp by killing both these processes:
</p>

<ul><pre>
# <strong>kill -9 [pid of pppd]</strong>
% <strong>kill -9 [pid of pptp]</strong>
</pre></ul>

It is recommended to open <tt>/var/log/messages</tt> in a extra terminal window, to recognize possible problems.

<ul>
<pre>
# <strong>tail -f /var/log/message</strong>
</pre></ul>
</p>

<p>
We also suggest that you put the startup command in <i>/etc/rc.local</i> so that you automatically connect on reboot.
</p>

<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq5.html">[To Section 5.0 - Kernel configuration and Disk Setup]</a>
<a href= "faq7.html">[To Section 7.0 - Keyboard controls]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq6.html,v 1.95 2001/05/05 02:50:04 ericj Exp $</small>
</p>
</body>
</html>
