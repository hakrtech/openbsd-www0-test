<html>
<head>
<title>6.0 - Networking</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-1999 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">

<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq5.html">[To Section 5.0 - Kernel configuration and Disk Setup]</a>
<a href= "faq7.html">[To Section 7.0 - Keyboard controls]</a>
</font>
</p>

<p>
<h1>6.0 - Networking</h1>
<hr>
</p>

<br>

<p>
<a name= "6.1"</a>
<h2>6.1 - Initial Network Setup</h2>
</p>

<p>
<h3>Interfaces</h3>
</p>

<p>
Here we assume you have all your network interfaces working, and a basic
TCP/IP knowledge. If not, go to the <a href= "./faq5.html">Kernel Configuration
and Setup</a> section, and/or read a good introduction to TCP/IP. Other recommended
reading is the 
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&apropos=0&sektion=8&format=html">
ifconfig(8)</a> and 
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">
netstat(1)</a> man pages.
</p>

<p>
All your interfaces should be listed with:
</p>

<ul>
<pre>
# <strong>ifconfig -a</strong>

lo0: flags=8009&lt;UP,LOOPBACK,MULTICAST&gt;
        inet 127.0.0.1 netmask 0xff000000
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt;
xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet 100baseTX half-duplex
        inet 10.1.1.1 netmask 0xffffff00 broadcast 10.1.1.255
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
        inet 10.1.1.1 netmask 0xffffff00 broadcast 10.1.1.255
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
tun0: flags=10&lt;POINTOPOINT&gt;
tun1: flags=10&lt;POINTOPOINT&gt;
enc0: flags=8&lt;LOOPBACK&gt;
</pre>
</ul>

<p>
First there is lo0 the loopback interface. It MUST have the assigned address
of 127.0.0.1 no matter what network setup you use. The next important one is
xl0 in this example (could be neX or epX depending on the brand), which is
a board itself. Look it has UP and RUNNING flags on, as lo0 but no other
interface has them. That means obviously they are working. Your interface
could be down if you never configured it, and look like the other interfaces.
The others are not part of this section, as sl and ppp are for serial line
comunication, tun is a pseudo-device for tunneling and enc a pseudo-device for
encryption. 
</p>

<p>
If xl0 was uninitialized, you can assign it an address by creating an ascii
file, /etc/hostname.xl0, containing a string like this:
</p>

<ul>
<pre>
inet 10.1.1.1 255.255.255.0 NONE
</pre>
</ul>

<p>
In the above example we show <i>inet 10.1.1.1</i>, where the second
argument is our IP address. <i>255.255.255.0</i> is our netmask and
<i>NONE</i> shows no media tags. (full-duplex, etc). This hostname 'mona'
needs to have record in /etc/hosts: 
</p>

<ul><pre>
10.1.1.1        mona    mona.openbsd.org.ar
</pre></ul>

<p>
What actually happens when you boot is that it looks up 'mona' in /etc/hosts, and then configures the interface to 10.1.1.1.
If you have multiple ethernet interfaces, this is probably a painful way to do things, and so you can also put the
number right in /etc/hostname.xl0:
<pre>
inet 10.1.1.1 255.255.255.0 NONE
</pre>

<p>
Now check that you have a file /etc/myname and a file /etc/mygate. If you
don't have them, you need to create them. If your gateway is a machine
named "wintermute" which is also in the /etc/hosts, use these commands:
</p>

<ul>
<pre>
# echo "mona" > /etc/myname
# echo "wintermute" > /etc/mygate
</pre>
</ul>

<p>
Ok, you are done for a standalone system, but to activate your
configuration now (without rebooting) do:
</p>

<ul>
<pre>
# sh /etc/netstart
</pre>
</ul>

<p>
This will give you a few errors, but don't worry as all them are
concerning 127.0.0.x (loopback)
</p>

<p>
Note: if you want to use the system as a gateway, later there's a
"Firewall Setup" section, but you need to read all this first.
</p>

<p>
Now check your routes are ok (here we use -n to make it simpler to
look at):
</p>

<ul>
<pre>
# <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu
Interface
default            10.1.1.254         UGS         0        0      -  xl0
10.1.1/24          link#1             UC          0        0      -  xl0
10.1.1.1           127.0.0.1          UGHS        0        0      -  lo0
10.1.1.254         link#1             UHL         1        0      -  xl0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          3       24      -  lo0
224/8              link#1             UCS         0        0      -  xl0

Encap:
Source address/netmask          Port  Destination address/netmask     Port Proto SA(Address/SPI/Proto)
</pre>
</ul>

<p>
(The <tt>default</tt> gateway here is 10.1.1.254)
</p>

<p>
<h3>IP Aliasing</h3>
</p>

<p>
If you want to map more than one IP address on a single network interface,
you need to assign an "alias" to it. The way to do it on OpenBSD is
simply assigning the interface another IP with the "alias" option like
this:
</p>

<p>
<pre>
# ifconfig xl0 alias 10.1.1.2 netmask 255.255.255.255
</pre>
</p>

<p>
Here ne2 is assigned another IP number (remember it already has 10.1.1.1).
Note the netmask used! Don't use 255.255.255.0 in this kind of case (both
numbers are on the same subnet), only ONE address should handle the subnet.
If you do such kind of misconfiguration, the following error appears:
</p>

<p>
<pre>
ifconfig:SIOCAIFADDR: File exists
</pre>
</p>

<p>
Now let's change the configuration file for this, /etc/ifaliases. Add to
it this line:
</p>

<p>
<pre>
xl0   10.1.1.2 255.255.255.255
</pre>
This means, simply, interface <tt>xl0</tt> should have an alias <tt>10.1.1.2</tt> with the netmask <tt>255.255.255.255</tt>.
</p>


<p>
<h3>DNS Client Setup</h3>
</p>

<p>
Let's assume your DNS servers are 125.2.3.4 and 125.2.3.5, and your
machine name belongs to the domain yourdomain.com.  You should have the following
lines to your /etc/resolv.conf file:
</p>

<ul>
<pre>
domain yourdomain.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre>
</ul>

<p>
<h3>Gateway Setup</h3>
</p>

<p>
This is the basic information you need to set up your OpenBSD box as a gateway (also called a router.)  If you are using OpenBSD as a router on the Internet, we suggest that you also read the IP Filter setup instructions below
to block potentially malicious traffic.  Also, due to the low availability of IPv4 addresses from network service providers
and regional registries, you may want to look at Network Address Translation (next section of this document)
for information on conserving your IP address space.
</p>

<p>
If you want your OpenBSD machine to act as a dedicated router, and you
are building a custom kernel configuration for it, you can either compile
your kernel with options IPFORWARDING or GATEWAY.  (See <A HREF="faq12.html">section 12</a> for
further information on tuning NMBCLUSTERS if you are doing this.)  For the rest of us,
OpenBSD now has a sysctl mechanism to turn on and off IP Forwarding at boot.
If you want it to "forward" any packets between your interfaces, modify the /etc/sysctl.conf line that toggles
the forwarding variable on bootup:
</p>

<ul>
<pre>
net.inet.ip.forwarding=1
</pre>
</ul>

<p>
To make the changes without booting:
</p>

<ul>
<pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -> 1
</pre>
</ul>

<p>
Now modify the routes on the other hosts on both sides.  There are many possible uses of OpenBSD as a router, using software
such as <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&apropos=0&sektion=8&format=html">routed(8)</a>,
<A HREF="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>, and <A href="http://www.zebra.org">zebra</a>.
OpenBSD has support in the ports collection for both gated and mrtd.
OpenBSD supports several T1, HSSI, ATM, FDDI, Ethernet, and serial (PPP/SLIP) interfaces.
</p>

<p>
<a name= "6.2"></a>
<h2>6.2 - IP Filter - ipf and ipnat setup</h2>
</p>
<p>
The IP Filter package was created to handle two tasks, dealing with
packet level forwarding permissions <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=8&format=html">ipf(8)</a> and mapping hosts/subnets to a range of
external addresses <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&apropos=0&sektion=8&format=html">ipnat(8)</a>. The configuration files for these two services are /etc/ipf.rules and
/etc/ipnat.rules.
</p>

<p>
You need to edit /etc/rc.conf to activate them at boot time. You also need to have 
net.inet.ip.forwarding=1 in your /etc/sysctl.conf (or your kernel needs to have IPFORWARDING
or GATEWAY options turned on.) You also need a kernel compiled with option
IPFILTER and IPFILTER_LOG (the GENERIC kernels do have these options).
</p>
<P>
If you have IP Filter compiled into your kernel, but you don't have 
it turned on in your /etc/rc.conf file, you can still activate it easily. 
<Pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre>
<P>
The <tt>-E</tt> flag on ipf 'enables' IP Filter.  <Tt>-Fa</tt> clears out any rules that you may have in there.  <tt>-f /etc/ipf.rules</tt> loads the rules from
/etc/ipf.rules.  
<p>
If you make changes to /etc/ipf.rules after ipf is loaded, you can reload your rules pretty easily!
<pre>
# ipf -Fa -f /etc/ipf.rules
</pre>
Same for ipnat...
<pre>
# ipnat -CF -f /etc/ipnat.rules
</pre>
This document will cover some basic ipf and ipnat configurations below.
There are a lot of nice examples in /usr/share/ipf/ for ipnat and ipf. We recommend
you choose the one closest to what you want, and modify it to fit your needs.  You can find other IP Filter information
at the IP Filter <A HREF="http://false.net/ipfilter/">mailing list archive</a>, the <A HREF="http://cheops.anu.edu.au/~avalon/ip-filter.html">IP Filter web site</a>, and finally the <A HREF="http://www.swcp.com/~synk/ipf-howto.txt">IP Filter HOWTO</a>.
</p>

<p>
<h3>IPF</h3>
</p>

<p>
Modify rc.conf so it has IPFILTER=YES. The file /etc/ipf.rules has a
simple yet powerful syntax. Here we deal with the most common ways of usage,
for a more strict definition see <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=5&format=html">ipf(5)</a>. Here is assumed xl0 as the
external interface to internet, on this one uses to have more rules than
internal interfaces.
</p>

<p>
Configurations usually start letting everything come and go, and then
apply the necessary rules to block offending packets. So this is first:
</p>

<p>
<pre>
pass out from any to any
pass in from any to any 
</pre>
</p>

<p>
Now let's block any incoming connection to port 82 tcp (eg. there's an
internal network report agent using http running on several hosts):
</p>

<p>
<pre>
block in on xl0 proto tcp from any to any port = 82
</pre>
</p>

<p>
This rule means:
</p>

<p>
"Block all incoming packets on xl0 interface whose protocol is TCP no
matter destination/origin using port 82"
</p>
<p>
If you want to log all rejected packets add "log" after "block in", or
"log quick" if you don't want it to send a message to every console root is
logged in.
</p>

<p>
Also, a typical rule is to block rpc portmap:
</p>

<p>
<pre>
block in log on xl0 proto udp from any to any port = sunrpc
</pre>
</p>

<p>
<h3>IPNAT</h3>
</p>

<p>
Based on <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, ipnat provides an easy way to
map internal networks to a single routeable ("real") internet address. This is very useful if you don't have
officially assigned addresses for every host on your internal network. When
you set up private/internal networks, you can take advantage of reserved
address blocks (assigned in <A HREF="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), such as:
<P>

10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>

</pre>
</p>
<p>
To use ipnat, ipf must be activated.
As outlined above, for changes to stay effective
through reboots, you should make changes to /etc/rc.conf (where it has IPNAT and IPFILTER.)
You can manually activate ipf with the command below.
<pre>
# ipf -E
</pre>

<p>
Example: You have an internal network using 192.168.5.0, with a netmask of 255.255.255 0, and you want to give
it access to internet using OpenBSD (of course!), and a ppp connection using address 200.1.2.3, use this rule:
</p>

<p>
<pre>
map tun0 192.168.5.0/24 -> 200.1.2.3/32
</pre>
</p>

<p>
This rule means:
</p>

<p>
"Any IP connections going out tun0 from an address matching the first
24 bits of 192.168.5.0 should be mapped to the address 200.1.2.3 (only one
address since /32 means every bit)"
</p>
<P>
If you don't like using CIDR notation, IP Filter also allows you to use netmasks.  A functional 
equivalent to the example above, using netmasks looks like this:
<P>
<PRE>
map tun0 192.168.5.0/255.255.255.0 -> 200.1.2.3/255.255.255.255
</pre>

<p>
But here arises a problem. You are assigning a lot of addresses to only
one address. But the port numbers aren't changing, and it is very likely that
your workstations on 192.168.5.0/24 will use the same port numbers to initiate connections
from.  (If this doesn't make sense, don't worry, but keep reading.)  The way to go around it is to map TCP and UDP ports to
a certain range with the option "portmap". Since ICMP doesn't even use ports, it is not covered by the
"portmap" rule.  (ICMP uses an ID field
usually based on a process number)
In our example, there are now two map rules to cover all of these protocols.  The end result looks like this:
</p>

<p>
<pre>
map tun0 192.168.5.0/24 -> 200.1.2.3/32 portmap tcp/udp 10000:65000
map tun0 192.168.5.0/24 -> 200.1.2.3/32
</pre>
</p>

<p>
If you have a dynamic address assignment (as in, you do not know what address they will give you when you connect), you can put
the interface name in place of the IP address.  Note that if you do this, you will have to run <tt>ipnat -CF -f /etc/ipnat.rules</tt> every time
your IP address changes (or, every time you dial up.)
</p>

<p>
<pre>
map tun0 192.168.5.0/24 -> tun0/32 portmap tcp/udp 10000:65000
map tun0 192.168.5.0/24 -> tun0/32<br>
</pre>

<p>
NAT is also able to help you in renumbering.  Say you were assigned a net block 35.8.9.0/22, and your internet provider can no longer
route these addresses to you, or say you are switching providers.  Your new address block is 192.9.4.0/22, but to switch all 500 devices
you have on this block would be very time consuming! ipnat provides a feature called bimap:
<P>
<PRE>
bimap xl0 35.8.9.0/22 -> 192.9.4.0/22
</pre>
<P>
This will literally map every computer in 35.8.9.0 to a new address in 192.9.4.0.  The drawback of this feature is that the translation is not
consistent.  A computer that initiates a connection from 35.8.9.0 will get a random IP address from 192.9.4.0.  A future version of IP Filter
will allow for one-to-one translation (where 35.8.9.99 will always get mapped to 192.9.4.99).
<p>
And of course, there are other potential uses of NAT that are probably beyond the scope of this document.  

<p>
<h3>Redirecting ports</h3>
</p>

<p>
This is another very handy feature of IPNAT. If you have a host on the
internal network (using private addresses), and you want to let incoming
connections to it, you just need a simple redirect rule. For example, if you
have a web server on internal network at 10.2.2.7 listening on port 80, and 
want it to be accessible from the outside simply redirecting external IP 
120.2.3.4 on xl0, just add this rule to <kbd>/etc/ipnat.rules:</kbd>
</p>

<p>
<pre>
rdr xl0 120.2.3.4 port 80 -> 10.2.2.7 port 80
</pre>
</p>

<p>
When you write rules, it may help to visualize the packet flow.
</p>

<p>
<pre>
Internet <--> (xl0 120.2.3.4) OpenBSD (xl1 10.2.2.1) <--> LAN <--> (10.2.2.7 XYZ Web server)
</pre>
</p>

<p>
One last reminder that you must have net.inet.ip.forwarding=1 or option IPFORWARDING to use
IP Filter (ipf, ipnat). Also, redirect only
works for packets that are being routed through the OpenBSD box.  If a web browser from inside the NAT
(say, from 10.2.2.5 from the example above) tries to connect to port 80 on 120.2.3.4, nothing will happen.
</p>

<br>

<p>
<a name= "6.3"></a>
<h2>6.3 - DHCP</h2>
</p>

<p>To use the DHCP client <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&apropos=0&sektion=8&format=html">dhclient(8)</a>
included with OpenBSD, edit /etc/hostname.xl0
(this is assuming your main ethernet interface is xl0.  Yours might be ep0 or fxp0 or something else!)
All you need to put in this hostname file is 'dhcp'
<pre>
# echo dhcp >/etc/hostname.xl0
</pre>
This will cause OpenBSD to automatically start the DHCP client on boot.  OpenBSD will gather its IP address,
default gateway, and DNS servers from the DHCP server.  
<p>
If you want to use OpenBSD as a DHCP server <A href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&apropos=0&sektion=8&format=html">dhcpd(8)</a>,
edit /etc/rc.conf.  Set it up so that dhcpd_flags="-q" instead of dhcpd_flags=NO.
Put the interfaces that you want dhcpd to *listen* on in /etc/dhcpd.interfaces.
<pre>
# <strong>echo xl1 xl2 xl3 >/etc/dhcpd.interfaces</strong>
</pre>
Then, edit /etc/dhcpd.conf.
The options are pretty self explanatory.
<pre>
        option  domain-name "xyz.mil";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>
<p>
This will tell your dhcp clients that the domain to append to DNS requests is xyz.mil (so, if the user types in 'telnet joe' then it will
send them to joe.xyz.mil).  It will point them to DNS servers 192.168.1.3 and 192.168.1.5.  For hosts that are on the same network as
an ethernet interface on the OpenBSD machine, which is in the 192.168.1.0/24 range, it will assign them an IP address between
192.168.1.32 and 192.168.1.127.  It will set their default gateway as 192.168.1.1.
</p>

<br>

<p>
<a name= "6.4"></a>
<h2>6.4 - PPP </h2>
</p>

Point-to-Protocol is generally what is used to create a connection to your ISP via your modem. OpenBSD has 2 ways of doing this. 

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8&format=html">pppd(8)</a> - Which is
the kernel ppp daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> - Which is
the userland ppp daemon. 
</ul>

<p>
The first one we will cover will be the userland PPP daemon. To start off you will need some simple
information about your isp. Here is a list of helpful information that you will need.
</p>

<ul>
<li>Your ISP's dialup number
<li>Your nameserver 
<li>Your username and password.
<li>Your gateway
</ul>

<p>
Some of these you can do without, but would be helpful in setting up your ppp. The userland PPP daemon uses
the file <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> as
its configuration file. There are many helpful files in <b>/etc/ppp</b> that can have different setups for
many different situations. You should take a browse though that directory.
</p>

<p>
Also, make sure, that if your not using a GENERIC kernel, that you have this line in your configuration file:
</p>

<ul><pre><strong>
pseudo-device   tun             2
</pre></ul></strong>


<h3>Initial Setup - for PPP(8)</h3>

<p>
Initial Setup for the userland PPP daemon consists of editing your <b>/etc/ppp/ppp.conf</b> file. This file
doesn't exist by default, but there is a file <b>/etc/ppp/ppp.conf.sample</b> in which you can simply edit to
create your own <b>ppp.conf</b> file. Here I will start with the simplist setup and probobly most used setup.
Here is a quick <b>ppp.conf</b> file that will simply connect to your ISP and set your default routes and
nameserver. With this file all the information you need is your ISP's phone number and your username and
password.
</p>

<ul>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</ul>

<p>
The section under the <b>default:</b> tag will get executed each time. Here we setup all our critical
information. Here with &quot;set log&quot; we set our logging levels. This can be changed, refer to 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> for more info on
setting up logging levels. Our device gets set with &quot;set device&quot;. This is the device that the modem
is on. In this example the modem is on com port 2. Therefore com port 1 would be /dev/cua00. With &quot;set
speed&quot; we set the speed of our dialup connection and with &quot;set dial&quot; we set our dialup
parameters. With this we can change our timeout time, etc. This line should stay pretty much as it is though.
</p>

<p>
Now we can move on and setup our information specific to our ISP. We do this by adding another tag under our
<b>default:</b> section. This tag can be called anything you want, easiest to just use the name of your ISP.
Here I will use <b>myisp:</b> as our tag refering to our ISP. Here is a simple setup incorporating all we need
to get ourselves connected.
<p>

<ul>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</ul>

<p>
Here we have setup essential info for that specific ISP. The first option &quot;set phone&quot; sets your
ISP's dialup number. The &quot;set login&quot; sets our login options. Here we have the timeout set to 5, this
means that we will abort our login attempt after 5 seconds if no carrier. Otherwise it will wait for
&quot;login:&quot; to be sent and send in your username and password. In this example our Username = ppp and
Password = ppp. These values will need to be changed. The line &quot;set timeout&quot; sets the timeout for
the entire login process to 120 seconds. The &quot;set ifaddr&quot; line is a little tricky. Here is a more
extensive explaination.
</p>

<ul><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</ul></pre>

<p>
In the above line, we have it set in the format of &quot;<b>set ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask
[triggeraddr]]]]</b>&quot;. So the first IP specified is what we want as our IP. If you have a static IP address, you set it here. In our example we use /0
which says that no bits of this ip address need to match and the whole thing can be replaced. The second IP
specified is what we expect as their IP. If you know this you can specify it. Again in our line we don't know
what will be assigned, so we let them tell us. The third option is our netmask, here set to 255.255.255.0.If
triggeraddr is specified, it is used in place of myaddr in the initial IPCP negotiation.  However, only an
address in the myaddr range will be accepted.  This is useful when negotiating with some PPP implementations
that will not assign an IP number unless their peer requests ``0.0.0.0''.
</p>

<p>
The next option used &quot;add default HISADDR&quot; sets our default route to their IP. This is 'sticky',
meaning that if their IP should change, our route will automatically be updated. With &quot;enable dns&quot;
we are telling our ISP to authenticate our nameserver addresses. Do NOT do this if you are running an local
DNS, as ppp will simply circumvent its use by entering some nameserver lines in /etc/resolv.conf.
</p>

<h3>Using PPP(8)</h3>

<p>
Now that we have our <b>ppp.conf</b> file setup we can start trying to make a connection to our ISP. I will
detail some commonly used arguments with ppp.
</p>

<ul>
<li><b>ppp -auto myisp</b> - This will run ppp, configure your interfaces and connect to your isp and then go
into the background.
<li><b>ppp -ddial myisp</b> - This is similar to -auto, but if your connection is dropped it will try and
reconnect.
</ul>

<p>
By using <b>/usr/sbin/ppp</b> with no options will put you into interactive mode. From here you can interact
directly with the modem, it is great for debugging problems in your <b>ppp.conf</b> file.
</p>

<h3>ppp(8) extra's</h3>

<p>
In some situations you might want commands executed as your connection is
made or dropped. There are two files you can create for just these
situations. <b>/etc/ppp/ppp.linkup</b> and <b>/etc/ppp/ppp.linkdown</b>.
Sample configurations can be viewed here:
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq5.html">[To Section 5.0 - Kernel configuration and Disk Setup]</a>
<a href= "faq7.html">[To Section 7.0 - Keyboard controls]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq6.html,v 1.26 1999/09/15 13:44:59 ericj Exp $</small>
</p>
</body>
</html>
