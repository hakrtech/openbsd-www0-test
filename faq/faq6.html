<html>
<head>
<title>6.0 - Networking</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2001 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<h2><font color=#e00000>6.0 - Networking</font><hr></h2>
</p>

<p>
<ul><h3>Table of Contents</h3>
<li><A href= "#6.0.1">6.0.1 - Before we go any further</a>
<li><a href= "#6.1">6.1 - Initial network setup</a>
<li><a href= "#6.2">6.2 - Packet Filter (PF)</a>
<li><a href= "#6.3">6.3 - Network Address Translation</a>
<li><a href= "#6.4">6.4 - Dynamic Host Configuration Protocol</a>
<li><a href= "#6.5">6.5 - Point to Point Protocol</a>
<li><A href= "#6.6">6.6 - Tuning networking parameters</a>
<li><a href= "#6.7">6.7 - Using NFS</a>
<li><a href= "#6.8">6.8 - Domain Name Service  - DNS, BIND, and named</a>
<li><a href= "#6.9">6.9 - Setting up a PPTP connection in OpenBSD</a>
</ul>
</p>
<hr>

<br>
<P>
<A name="6.0.1"></a>
<H2>6.0.1 - Before we go any further</h2>
<P>
For the bulk of this document, it helps if you have read and
at least partially understood the <a href="faq5.html">Kernel
Configuration and Setup</a> section of the FAQ, and the
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&apropos=0&sektion=8&format=html">
ifconfig(8)</a> and
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">
netstat(1)</a> man pages.
<P>
If you are a network administrator, and you are setting up routing
protocols, if you are using your OpenBSD box as a router, if you need to
go in depth into IP networking, you really need to read
<a href="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">Understanding IP addressing</a>.
This is an excellent document.  Understanding IP addressing contains
fundamental knowledge to build upon when working with IP networks,
especially when you deal with or are responsible for more than one network.
<p>
If you are working with applications such as web servers, ftp servers, and
mail servers, you may benefit greatly by <a href="http://the.rfceditor.org/rfc.html">reading the RFCs</a>.
Most likely, you can't read all of them.  
Pick some topics that you are interested in, or that you use in
your network environment.  Look them up, find out how they are intended to
work.
The RFCs define many (thousands of) standards for protocols on the
Internet and how they are supposed to work.

<a name="6.1"></a>
<h2>6.1 - Initial Network Setup</h2>

<p>
<a name="6.1.1"></a>
<h3>6.1.1 - Identifying and Setting Up Your Network Interfaces</h3>
</p>

<p>
To start off, you must first identify your network interface.
In OpenBSD, interfaces are named for the type of card, not for
the type of connection. You can see your network card get
initialized during the booting process, or after the
booting process using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&sektion=8">dmesg(8)</a> command.
You also have the chance of seeing your network interface
using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> command.
For example, Here is the output of dmesg for a ne2k network
card, which uses the device name
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ne&sektion=4">ne(4)</a>.
</p>

<ul><pre>
ne3 at pcmcia1 function 0 "Linksys, EtherFast 10/100 PC Card (PCMPC100), " port 0x340/16 irq 9
ne3: address 00:e0:98:04:95:ba
</pre></ul>

<p>
If you don't know what your device name is, here is a list of common cards and their device names.
</p>

<ul>
<li>ne2000 Network Cards - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ne&sektion=4">ne</a>
<li>3Com EtherLink III and Fast EtherLink III Ethernet - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&sektion=4">ep</a>
<li>3Com EtherLink XL and Fast EtherLink XL Ethernet (3C9xx) - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xl&sektion=4">xl</a>
<li>Intel 82586 chip Ethernet device driver - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ie&sektion=4&arch=i386">ie</a>
<ul>Which Includes Cards Such As:
	<li>3Com 3C507
	<li>AT&amp;T StarLAN 10
	<li>AT&amp;T EN100
	<li>AT&amp;T StarLan Fiber
	<li>Intel EtherExpress 16
</ul>
<li>DEC/Intel 21142/3 and clone 10/100 Ethernet driver - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dc&sektion=4">dc</a>
<ul><font size="-1"> <b>Note:</b> Some drivers which were in OpenBSD 2.6, such as <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mx&sektion=4&manpath=OpenBSD+2.6">mx</a>, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ax&sektion=4&manpath=OpenBSD+2.6">ax</a>, al and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pn&sektion=4&manpath=OpenBSD+2.6">pn</a> have been replaced by this driver.</font><br>
Which Includes Cards Such As:
	<li>Intel 21142/21143 (formerly manufactured by DEC)
	<li>Macronix 98713, 98713A, 98715, 98715A and 98725
	<li>Davicom DM9100 and DM9102
	<li>ASIX Electronics AX88140A and AX88141
	<li>ADMtek AL981 Comet and AN985 Centaur
	<li>Lite-On 82c168 and 82c169 PNIC
	<li>Lite-On/Macronix 82c115 PNIC II
<P>
If you are upgrading to OpenBSD 2.7 from an older release of OpenBSD,
you need to pay attention here.
Any references in <em>/etc/ifaliases</em>, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">/etc/pf.conf(5)</a>, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">/etc/nat.conf(5)</a>
to the old interface names mx, al, ax, or pn must be replaced with dc.  Also, any <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5">hostname.xxx</a>
files with the old interface names must be renamed to <em>hostname.dcX</em> to be recognized.  Replace the X with the interface number.
</ul>
<li>Lucent Technologies WaveLAN/IEEE 802.11DS - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&sektion=4">wi</a>
<li>Aironet Communications 4500/4800 IEEE 802.11DS - <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&sektion=4">an</a>
</ul>

<p>
Again, you can check to see what interfaces have been identified by using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a>
utility. Here is output which will show an ne2k device.
</p>

<ul><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8009&lt;UP,LOOPBACK,MULTICAST&gt;
        inet 127.0.0.1 netmask 0xff000000
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt;
ne3: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
tun0: flags=10&lt;POINTOPOINT&gt;
tun1: flags=10&lt;POINTOPOINT&gt;
enc0: flags=0&lt;&gt;
bridge0: flags=0&lt;&gt;
bridge1: flags=0&lt;&gt;
</pre></ul>

<p>
As you can see here, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a> 
gives us a lot more information than we are needing at this
point. But it still allows us to see our interface. In the above example, the interface card is already
configured. You can tell this by seeing that values are already set in &quot;inet 10.0.0.38 netmask
0xffffff00 broadcast 10.0.0.255&quot;, and that the <strong>UP</strong> and <strong>RUNNING</strong> flags
are turned on. Also, you will notice many other interfaces. Here is a list of interfaces that will be
expected to be there.
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&sektion-4&format=html">lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&sektion=4&format=html">sl</a> - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp</a> - Point to Point Protocol
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&sektion=4&format=html">tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4&format=html">enc</a> - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4&format=html">bridge</a> - Ethernet bridge interface
</ul>

<p>
If you don't have your interface configured, the first step is to create the <strong>/etc/hostname.${IF}</strong>
file. Where the name of your interface will take the place of ${IF}. From the information in the examples
above, the name would be <strong>/etc/hostname.ne3</strong>. The layout of this file is like so:<br>
(To read more about the format of this file, reference the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html">hostname.if(5)</a> man page.)
</p>

<ul><pre>
[address_family] [your_ip] [your_netmask] [media options]
</pre></ul>

<p>
So, for the above example, a proper file would look like this:
</p>

<ul><pre>
$ <strong>cat /etc/hostname.ne3</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></ul>

<p>
Next step from here is to setup your gateway. To do this, simply put the IP of your gateway in the file
<strong>/etc/mygate</strong>. This will allow for your gateway to be set upon boot. From here you should
setup your nameservers, and your <strong>/etc/hosts</strong> file (see the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5">hosts(5)</a> man page). To setup your nameservers, you will
create a file called <strong>/etc/resolv.conf</strong>. You can read more about the format of this file in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5">resolv.conf(5)</a>
man page. But for a standard usage, here is an example. In this example your domain servers are 125.2.3.4
and 125.2.3.5. You also belong in the domain &quot;yourdomain.com&quot;.
</p>

<ul><pre>
$ <strong>cat /etc/resolv.conf</strong>
search yourdomain.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></ul>

<p>
From here, you can either reboot or run the <strong>/etc/netstart</strong> script. You can do this by simply
typing (as root):
</p>

<ul><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></ul>

<p>
Notice that a few errors were produced, but they are concerned
with the loopback interface, so they can be ignored. From here
your system should be up and running. Again, you can check to
make sure that your interface was setup correctly with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>. You can also check your routes via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&sektion=1">netstat(1)</a> or <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8">route(8)</a>.
Here is an example of viewing your routing tables using both.
</p>

<ul><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  ne3
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  ne3
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  ne3
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></ul>

<p>
<a name="6.1.2"></a>
<h3>6.1.2 - Setting up your OpenBSD box as a Gateway</h3>
</p>

<p>
This is the basic information you need to set up your OpenBSD
box as a gateway (also called a router). If you are using
OpenBSD as a router on the Internet, we suggest that you also
read the Packet Filter setup instructions below to block
potentially malicious traffic. Also, due to the low
availability of <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&sektion=4">IPv4</a> addresses from network service providers
and regional registries, you may want to look at Network
Address Translation for information on conserving your IP
address space. 
</p>

<p>
The GENERIC kernel already has the ability to allow IP
Forwarding, but needs to be turned on. You should do this
using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a>
utility. To change this permanently you should edit the file 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5">/etc/sysctl.conf(5)</a>
to allow for IP Forwarding. To do so add this line in that
configuration file.
</p>

<ul><pre>
net.inet.ip.forwarding=1
</pre></ul>

<p>
To make this change without rebooting you would use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a>
utility directly. Remember though that this change will no
longer exist after a reboot, and needs to be run as root.
</p>

<ul><pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></ul>

<p>
Now modify the routes on the other hosts on both sides.  There are many possible uses of OpenBSD as a router, using software
such as <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&apropos=0&sektion=8&format=html">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>, and <a href="http://www.zebra.org">zebra</a>.
OpenBSD has support in the ports collection for both gated and mrtd.
OpenBSD supports several T1, HSSI, ATM, FDDI, Ethernet, and serial (PPP/SLIP) interfaces.
</p>

<p>
<a name="6.1.3"></a>
<h3>6.1.3 - Setting up aliases on an interface.</h3>
</p>

<strong>Starting with OpenBSD 2.8, <i>/etc/ifaliases</i> is no longer used!</strong>

<p>
OpenBSD has a simple mechanism for setting up ip aliases on an
interface. To do this simply edit the file
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5&format=html"><i>/etc/hostname.&lt;if&gt;</i></a>.
This file is read upon boot by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc(8)</a> script,
which is part of the <a href="faq10.html#10.3">rc startup
hierarchy</a>. For the example, we assume that the user has an
interface <b>dc0</b> and is on the network 192.168.0.0. Other
important information:
</p>

<ul>
<li>IP for dc0 is 192.168.0.2
<li>NETMASK is 255.255.255.0
</ul>

<p>
A few side notes about aliases. In OpenBSD you use the interface name only. There is no difference between the first alias and the second alias. Unlike some other operating systems, OpenBSD doesn't refer to them as dc0:0, dc0:1.  If you
are referring to a specific aliased IP address with ifconfig, or adding
an alias, be sure
to say "<tt>ifconfig int alias</tt>" instead of just "<tt>ifconfig int</tt>"
at the command line.   You can delete aliases with "<tt>ifconfig int delete</tt>".
<p>
Assuming you are using multiple IP addresses which are in the same IP subnet with
aliases, your netmask setting for each alias becomes 255.255.255.255.  
They do not need to follow the netmask of the first IP bound to the interface.
In this example, <i>/etc/hostname.dc0</i>, two aliases are added to the device dc0,
which, by the way, was configured as 192.168.0.2 netmask 255.255.255.0.
</p>

<ul><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255 NONE
inet alias 192.168.0.4 255.255.255.255 NONE
</pre></ul>

<p>
Once you've made this file, it just takes a reboot for it to take effect. You can, however, bring up the aliases by hand using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8&format=html">ifconfig(8)</a> utility. To bring up the first alias you would use the command:
</p>

<ul><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></ul>

<p>
To view these aliases you must use the command:
</p>

<ul><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></ul>



<p>
<a name= "6.2"></a>
<a name= "PacketFilter"></a>
<h2>6.2 - Packet Filter (PF)</h2>
</p>
<p>
<h5>Note: Packet Filter is the filtering system in OpenBSD 3.0 and 
later.  If you are looking for the IPF/IPNAT FAQ for OpenBSD 2.9 and 
before, click <a href="faqipf.html">here</a>.</h5>
</p>
<p>
The Packet Filter subsystem was created to handle two tasks, dealing 
with packet level forwarding permissions and mapping hosts/subnets to 
a range of external addresses.  The configuration files for these 
two services are 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">/etc/pf.conf(5)</a></i> 
and 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">/etc/nat.conf(5)</a></i>.
</p>
<p>
To start these services with your system, you need to edit
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i>
and set the line to:
</p>

<ul><pre>
pf=YES
</pre></ul>

<p>
If you are using NAT, you will most likely also need to set
the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a>
value <tt>net.inet.ip.forwarding</tt> to 1. You can do this by
uncommenting the relevant lines in 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5">/etc/sysctl.conf(5)</a></i>
and rebooting your computer.
</p>
<p>
If you have Packet Filter compiled into your kernel, but you
don't have it turned on in your
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i>
file, you can still activate it with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&sektion=8">pfctl(8)</a> command.
</p>
<ul><pre>
# <b>pfctl -R /etc/pf.conf</b>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre></ul>

<p>
The first line sets up filtering, using <i>/etc/pf.conf</i> and the 
second sets up NAT, using <i>/etc/nat.conf</i> (more on NAT later 
in <a href="#NAT">Section 6.3, NAT</a>), and finally, the last line 
activates PF.
</p>
This can also be combined into one command line:
<ul><pre>
# <strong>pfctl -R /etc/pf.conf -N /etc/nat.conf -e</strong>
</pre></ul>
<p>
If you make changes to <i>/etc/pf.conf</i> after 
PF is started, you can reload your rules by reloading the 
appropriate file:
</p>
<ul><pre>
# <b>pfctl -R /etc/pf.conf</b>
</pre></ul>

<p>
This document will cover some basic 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">pf.conf(5)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">nat.conf(5)</a> 
configurations below.  You can also look at the <a href="#sample_pf.conf">resulting 
ruleset</a> that includes all the tweaks explained below in more detail.
You can find other Packet Filter information
at the <a href="http://www.benzedrine.cx/pf.html">Packet Filter web site</a> 
and in the 
<a href="http://www.inebriated.demon.nl/pf-howto/">Packet Filter HOWTO</a>. 
</p>

<p>
<h3>Packet Filter</h3>
</p>

<p>
In order to enable Packet Filter at boot, you will need to 
modify <i>/etc/rc.conf</i> so that it reads <tt>pf=YES</tt>.  Packet Filter (pf)
is controlled by <i>/etc/pf.conf</i>, which is read at boot. For a 
more detailed explanation, see 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">pf.conf(5)</a>. 
In the examples that follow, <tt>fxp0</tt> will represent the external 
interface to the internet. It will be different for you, 
based on the ethernet adapter present in your computer. These 
rules will assume full-time internet connectivity, such as 
you would see on a webserver.
</p>

<p>
Packet Filter rules are processed sequentially from top to bottom; 
it helps to visualize each packet having to traverse every 
rule before it reaches its destination.
</p>

<p>
For example, the default ruleset provided allows all packets 
to travel in, and all packets to travel out:

<ul><pre>
pass out all 
pass in all
</pre></ul>

This is shorthand, for:
<ul><pre>
pass in from any to any
pass out from any to any
</pre></ul>

which can be read as &quot;pass incoming packets from any source to 
any destination&quot;, with an implied &quot;on any interface (which is 
always implied if a specific interface isn't specified) of any
address family, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&sektion=4">inet (v4)</a> or <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&sektion=4">inet6 (v6)</a>&quot;.
</p>
<p>
Obviously, this isn't much of a filter.  More useful filtering
will be based on the address family (IPv4 or IPv6), protocol(s) 
and port(s) used by the services
you wish to filter.  Any of the protocols listed in
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&sektion=5">/etc/protocols(5)</a></i>
can be specified, by either name or number, but we will
concern ourselves with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&sektion=4">tcp(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&sektion=4">udp(4)</a> and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&sektion=4">icmp(4)</a>.
</p>

<p>
Now let's say we don't want to allow any incoming IPv4 connections to 
TCP port 3306 (MySQL) because the database should only be connected 
to from localhost. Our ruleset would look like this:

<ul><pre>
pass out all
pass in all
block in on fxp0 inet proto tcp from any to any port = 3306
</pre></ul>

This says &quot;block in all IPv4 (inet) incoming packets, from 
any source to 
any destination bound for tcp port 3306.&quot;  Note that 
it is required that you specify a protocol with any port-based
filter, and recommended that you specify the address family.  
For services defined in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&sektion=5">/etc/services(5)</a>
file, you can also use the service names, such as <em>www</em>
or <em>mysql</em>.
A packet destined for tcp port 3306 on interface 
<tt>fxp0</tt> will pass the first &quot;pass in&quot; rule and then 
be dropped by the &quot;block 
in port = 3306&quot; rule. If you reversed the order of our 
incoming rules (remember, order is important):

<ul><pre>
pass out all
block in on fxp0 inet proto tcp from any to any port = 3306
pass in all
</pre></ul>

Packets destined for tcp port 3306 would pass because the last rule 
in the set allows all packets to pass. It is important to keep 
this in mind when writing packet filter rules:
<b>The last matching rule wins</b>.
</p>

<p>
Of course, there are exceptions to every rule. The <em>quick</em> 
option drops the packet at the first rule that matches. Let's 
look at our above flawed example, if we add <em>quick</em> to 
the &quot;block in&quot; rule:

<ul><pre>
pass out all
block in quick on fxp0 inet proto tcp from any to any port = 3306
pass in all
</pre></ul>

<p>
A packet destined for our host on tcp port 3306 will hit the 
&quot;block in quick&quot; rule and be dropped immediately. All 
packets destined for other ports or protocols won't find a rule match until 
they reach our &quot;pass in&quot; rule that allows all packets 
to pass.
</p>

<b>Default Deny</b>
<p> The safest packet filtering policy is a default deny policy. 
All traffic not explicitly allowed is denied. This policy is far 
safer than explicitly denying each protected service, allows for 
smaller rulesets, and can protect from an accidentally 
misconfigured service that has been left exposed.
</p>
<p>
Let's now look at another example ruleset and explain 
things line by line. Here's an example for a webserver with a 
default deny policy that only allows ssh connections (for 
administration) and connections to http (port 80) and https 
(port 443).
</p>
<ul><pre>
pass in quick on fxp0 inet proto tcp from any to any port = 22
pass in quick on fxp0 inet proto tcp from any to any port = 80
pass in quick on fxp0 inet proto tcp from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre></ul>

<p>
This will allow incoming connections from anywhere to tcp ports 
22(ssh), 80(http), and 443(https). It will drop all other 
connection attempts, and allow all outgoing connections. This 
is a pretty tight ruleset.  But what if you only wanted to 
allow internal hosts on your 1.1.1.0 address block to connect 
to ssh, but allow outside connections to http and https?

<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 inet proto tcp from any to any port = 80
pass in quick on fxp0 inet proto tcp from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre></ul>

Pretty good, but what if we only want to allow one machine 
(1.1.1.1) to administer the web server remotely?
In that case, we can change this:

<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port = 22
</pre></ul>
to this:
<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port = 22
</pre></ul>
</p>

<b>Sample Rules</b>
<p>
Here are some good rules for everyone to use (assuming that 
fxp0 is the external internet-connected interface). First we 
will set up a simple address spoofing protection.  These addresses
shouldn't (normally) be floating around the Internet, 
and if they are, it is rarely good, so we block them:
<ul><pre>
block in quick on fxp0 inet from 127.0.0.0/8 to any
block in quick on fxp0 inet from 192.168.0.0/16 to any
block in quick on fxp0 inet from 172.16.0.0/12 to any
block in quick on fxp0 inet from 10.0.0.0/8 to any
block out quick on fxp0 inet from any to 127.0.0.1/8
block out quick on fxp0 inet from any to 192.168.0.0/16
block out quick on fxp0 inet from any to 172.16.0.0/12
block out quick on fxp0 inet from any to 10.0.0.0/8
</pre></ul>

Our ruleset is starting to look pretty good; when we put 
it together, here is what it looks like:

<ul><pre>
# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from 127.0.0.0/8 to any
block in quick on fxp0 inet from 192.168.0.0/16 to any
block in quick on fxp0 inet from 172.16.0.0/12 to any
block in quick on fxp0 inet from 10.0.0.0/8 to any
block out quick on fxp0 inet from any to 127.0.0.1/8
block out quick on fxp0 inet from any to 192.168.0.0/16
block out quick on fxp0 inet from any to 172.16.0.0/12
block out quick on fxp0 inet from any to 10.0.0.0/8

# only allow our administration machine to connect via ssh
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port = 22

# allow others to use http and https
pass in quick on fxp0 inet proto tcp from any to any port = 80
pass in quick on fxp0 inet proto tcp from any to any port = 443

# finally lock the rest down with a default deny
block in quick on fxp0 from any to any

# and let out-going traffic out
pass out on fxp0 from any to any
</pre></ul>
</p>

<b>Packet Logging</b>
<p>
Now that's pretty good, but it could be better. What if we want to 
log any connection attempts to port 22(ssh) that get blocked by 
our firewall? Easy, Packet Filter can handle this with the <em>log</em> keyword:
<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port = 22
block in log quick on fxp0 inet proto tcp from any to any port = 22
</pre></ul>
This rule will allow our remote administration machine to connect 
to port 22, but deny and log all other attempts to connect to 
port 22.
</p>
<p>
Logged packets are sent to the pflog0 interface, which is monitored
by 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&sektion=8">pflogd(8)</a>,
which typically dumps the packets to <i>/var/log/pflog</i> in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a>
binary format.  pflogd(8) is started by default by
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc(8)</a></i>
if pf is enabled in
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i>.
You can read these log files using the following command:
<ul><pre>
# <b>tcpdump -n -e -ttt -r /var/log/pflog</b>
</pre></ul>
</p>
<p>
One should be aware that using tcpdump to watch the pflog file does 
NOT give a real-time display.  If you wish a real-time display, you 
can use this command:
<ul><pre>
# <b>tcpdump -i pflog0</b>
</pre></ul>
One could also use tcpdump to narrow down the focus to facilitate
debugging:
<ul><pre>
# <b>tcpdump -e -i pflog0 port 80</b>
</pre></ul>
Doing this does NOT impact the data that is put to the file 
<i>/var/log/pflog</i>.  
</p>
<p>
When examining one's logs, especial care should be taken
with tcpdump's verbose protocol decoding (activated via the -v command
line option).  Tcpdump's protocol decoders do not have a perfect
security history.  At least in theory, a delayed attack could be
possible via the partial packet payloads recorded by the logging
device.
</p>
<p>
Additional care should be taken about access to the logs.  Pflogd
will capture 96 bytes of the packet and log it.  Access to the logs
could provide partial access to sensitive packet payloads (like
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&sektion=1">telnet(1)</a> or
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&sektion=1">ftp(1)</a> logins).
</p>

<p>
<b>Multiple Protocols</b>
</p>
<p>
What if we need to allow connections to a service running 
over multiple protocols, such as bind, which uses TCP and UDP? 
Packet filter lets you lump options together into sets  
(more on this later): 
<ul><pre>
# Pass DNS traffic for BIND
pass in quick on fxp0 inet proto { tcp, udp } from any to any port = 53
</pre></ul>
Notice the spaces on both sides of the '{ }' characters.  This is 
neater than the alternative you might otherwise have to use:
<ul><pre>
pass in quick on fxp0 inet proto tcp from any to any port = 53
pass in quick on fxp0 inet proto udp from any to any port = 53
</pre></ul>
</p>

<p>
<a name="normalization"></a>
<b> Packet Normalization</b>
</p>
<p> 
As some OSs and applications have trouble with abnormal or 
fragmented packets, it is sometimes beneficial to normalize the 
packets before they are passed on to their ultimate destination.
This is done with the <b>scrub</b> directive, used as here:
<ul><pre>
scrub in all
</pre></ul>
As this does put additional load on the system, there is no reason
to use this command unless this system is protecting a computer 
with a poor TCP/IP implementation
</p>

<p>
<b>IP Options</b>
</p>
<p>
By default, PF blocks packets with IP options set.  This can make
the job more difficult for &quot;OS fingerprinting&quot; utilities
like nmap.  If you have an application that requires the passing of 
these packets, such as multicast or IGMP, you can use the 
<b>allow-opts</b>
directive:
<ul><pre>
pass in quick on fxp0 allow-opts
</pre></ul>
</p>

<p>
<b>TCP Flags, established connections and keeping state</b>
</p>
<p>
Packet Filter can also filter packets based on TCP flags and 
maintain established connections and connection state. It is 
recommend that all users who wish to filter packets based on 
TCP flags understand what role each flag plays. For instance, 
if you wanted to deny all packets with the FIN, URG, and PSH 
flags set (like for instance an nmap OS fingerprinting attempt) 
you could use a rule like this:
<ul><pre>
block in quick on fxp0 inet proto tcp from any to any flags FUP/FUP
</pre></ul>
(Thanks to <a href=mailto:halogen@nol.net>Kyle Hargraves</a> for that tip)
</p>
<p>
Packet Filter's next cool trick is its ability to maintain state. 
Maintaining state has been described as &quot;not speaking until 
spoken to&quot;; in other words, once a connection is established, 
packets no longer have to traverse rulesets. This is a very 
powerful feature allowing much simpler and more secure rule 
writing.
</p>
<p>
For example, let's see how we can apply state to our previous 
example ruleset (confused yet?). To review, we are allowing 
management access from our Class C to port 22(ssh) and allowing 
all incoming web traffic on ports 80(http) and 443(https). We 
are blocking all other traffic. But, what if I want to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&sektion=1">ssh(1)</a>
out of the webserver? What if I need to use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&sektion=1">lynx(1)</a> to look up 
something in the FAQ? Well, I can't because I have blocked all 
incoming connections other than those on the specified ports. While 
this is the safest route, it can be quite inconvenient. By 
adding the <em>keep state</em> keywords to our &quot;pass 
out&quot; rule, we can automagically allow incoming 
connections in response to connections we initiate, such as 
when web browsing.  Remember, we do need to specify what 
protocol we are keeping state for.
</p>
<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 from any to any port = 80
pass in quick on fxp0 from any to any port = 443
block in quick on fxp0 from any to any
pass out on fxp0 inet proto tcp from any to any keep state
</pre></ul>
<p>
This little change will dramatically increase the flexibility and
security of our ruleset: for instance, in the above ruleset, we are
allowing all tcp traffic into ports 80 &amp; 443. We can tighten this up
even more. In order for a tcp connection to be established, we only need
to allow the initial handshake to occur; once that occurs, we can block
traffic to that port and allow our &quot;keep state&quot; rule to manage
the connection. To allow the initial handshake to complete, we need only
allow packets with the SYN and SYNACK flags set. By passing only packets
with SYN and SYNACK set, we can prevent many forms of portscanning such
as FIN scanning. The rules now look like this:
<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port = 22
pass in quick on fxp0 inet proto tcp from any to any port = 80 flags S/SA
pass in quick on fxp0 inet proto tcp from any to any port = 443 flags S/SA
block in quick on fxp0 from any to any
pass out on fxp0 proto tcp from any to any keep state
</pre></ul>
</p>
<p>
Let's start to tie things together by putting all of the rules we 
have so far into a ruleset. This ruleset will support IPv4, have 
a default deny policy, allow management connections from an 
internal network only (via ssh) and allow incoming traffic on 
ports 80(http) and 443(https). It will also protect against 
spoofed non-routeable ip addresses, and drop all packets that are 
too fragmented to inspect. A pretty comprehensive setup for a public 
webserver. Here's what <i>/etc/pf.conf</i> could look like:
<ul><pre>
# Clean up fragmented and abnormal packets
scrub in all

# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from 127.0.0.0/8 to any
block in quick on fxp0 inet from 192.168.0.0/16 to any
block in quick on fxp0 inet from 172.16.0.0/12 to any
block in quick on fxp0 inet from 10.0.0.0/8 to any
block out quick on fxp0 inet from any to 127.0.0.1/8
block out quick on fxp0 inet from any to 192.168.0.0/16
block out quick on fxp0 inet from any to 172.16.0.0/12
block out quick on fxp0 inet from any to 10.0.0.0/8

# only allow our machines to connect via ssh
pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port = 22

# allow others to use http and https
pass in quick on fxp0 inet proto tcp from any to any port = 80 flags S/SA
pass in quick on fxp0 inet proto tcp from any to any port = 443 flags S/SA

# finally lock the rest down with a default deny
block in quick on fxp0 from any to any

# and let out-going traffic out and maintain state on established connections
pass out on fxp0 from any to any keep state
</pre></ul>
</p>
<p>
While this may look good, there are some things Packet Filter 
will let you do to make your <i>pf.conf</i> file look neater and easier
to maintain.
</p>

<p>
<b>Sets</b>
</p>
<p>
Sets are useful "shortcuts" for writing simple and clear 
rules in PF.  For example, what if we need to allow 
connections to a service running
over multiple protocols, such as BIND, which uses TCP and UDP?
Normally, you would have to do something like this:
<ul><pre>
pass in quick on fxp0 inet proto tcp from any to any port = 53
pass in quick on fxp0 inet proto udp from any to any port = 53
</pre></ul>
but instead, you could use PF's set notation to simplify this:
<ul><pre>
pass in quick on fxp0 inet proto { tcp, udp } from any to any port = 53
</pre></ul>
Note the spaces on both sides of the '{ }' characters. 
</p>
<p>
Groups of related IPs can be clustered together into sets, which 
can be used anywhere a single IP could be used.  For example, 
looking at our anti-spoofing rules above:
<ul><pre>
# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from 127.0.0.0/8 to any
block in quick on fxp0 inet from 192.168.0.0/16 to any
block in quick on fxp0 inet from 172.16.0.0/12 to any
block in quick on fxp0 inet from 10.0.0.0/8 to any
block out quick on fxp0 inet from any to 127.0.0.1/8
block out quick on fxp0 inet from any to 192.168.0.0/16
block out quick on fxp0 inet from any to 172.16.0.0/12
block out quick on fxp0 inet from any to 10.0.0.0/8
</pre></ul>

they could be consolidated into two lines:
<ul><pre>
block in quick on fxp0 inet from { 127.0.0.1/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.1/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></ul>
</p>

<p>
<b>Variable Expansion</b>
</p>
<p>
One problem with the above sample <i>pf.conf</i> file is that should
you need to change your NIC, or change an IP address, you would
need to change a number of lines.  This can be lessened by using
variable expansion:
</p>
<ul><pre>
NoRouteIPs="{ 127.0.0.1/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
ExtIF="fxp0"
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
</pre></ul>
</p>

<p>
<a name="sample_pf.conf"></a>
<b>Putting it all together</b>
</p>
<p>
Now, let's put it all together, and look at the elegance of the file:
<ul><pre>
# Define useful variables
ExtIF="fxp0"              # External Interface
IntNet="1.1.1.0/24"       # Our internal network
NoRouteIPs="{ 127.0.0.1/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
Services="{ www, https }"

# Clean up fragmented and abnormal packets
scrub in all

# don't allow anyone to spoof non-routeable addresses
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs

# only allow our machines to connect via ssh
pass in quick on $ExtIF inet proto tcp from $IntNet to any port = 22

# allow others to use http and https
pass in quick on $ExtIF inet proto tcp from any to any port = $Services flags S/SA

# finally lock the rest down with a default deny
block in quick on $ExtIF from any to any

# and let out-going traffic out and maintain state on established connections
pass out on $ExtIf from any to any keep state
</pre></ul>
</p>

<p>
If you experience problems, you may want to enable logging on 
individual rules to effectively troubleshoot. ie: 
<ul><pre>
pass in log quick on fxp0 from 1.1.1.0/24 to any port = 22
</pre></ul>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&sektion=8">pflogd(8)</a> will write to ip log entries to <i>/var/log/pflog</i>.
Remember that <i>/var/log/pflog</i> is a binary file, intended to be
read by <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a>, NOT directly by humans.
</p>
<p>
When you modify the configuration file to log packets, don't 
forget to <b>pfctl -R /etc/pf.conf</b> for the changes to take affect! 
</p>

<p>
<h3>Differences between PF and IPF</h3>
</p>
<p>
Packet Filter (PF) was designed to be very compatible with IPF's 
<i>ipf.rules</i> file.  However, PF is not, nor was it intended to be,
a drop-in replacement for IPF.  This section details some of the
differences between these systems.
</p>
<ul>
<li><b>group and head:</b>  These options are no longer used,
as the filter rules are optimized on the fly.  If you are 
migrating your old rulesets from IPF, you should delete any <em>group</em>
or <em>head</em> definitions and manually reorder your rules, making sure
their semantics haven't changed.</li>
<li><b>level:</b> When logging, PF does not accept a <em>level</em> option to the log
keyword, as logging is not performed by <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&sektion=8">syslogd(8)</a>, but by a separate 
logging daemon.  To examine a particular kind of traffic, as might have been
done with <em>level</em> option, use any of the available options of 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a>.</li>
<li><b>keep frags:</b>  This has been replaced by the normalization 
the <a href="#normalization">scrub</a> option performs.</li>
<li><b>@n Rules:</b>  PF does not support prepending rules with <em>@n</em>
to insert them into particular points in the rule list as IPF does.  To
view the rule numbers PF has assigned, use the command <tt>pfctl -sr</tt></li>
</ul>

<p>
<a name="6.3"></a>
<a name="NAT"></a>
<h2>6.3 - NAT</h2>
</p>
<p>
<h5>Note: Packet Filter is the filtering system in OpenBSD 3.0 and
later.  If you are looking for the IPF/IPNAT FAQ for OpenBSD 2.9 and
before, click <a href="faqipf.html">here</a>.</h5>
</p>
<a name="nat1.0"></a>
<h3><u>6.3.1 NAT Introduction</u></h3>

<a name="nat1.1"></a>

<p>
Based on 
<a href="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, 
NAT provides an easy way to map internal networks to a single 
routeable ("real") internet address. This is very useful if you 
don't have officially assigned addresses for every host on your 
internal network. When you set up private/internal networks, you 
can take advantage of reserved address blocks (assigned in 
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), 
such as:
</p>

<p>
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>
</p>

<p>
The user is assumed to have already set up
and configured an OpenBSD machine with two network cards (one
connected to the Internet and the other to the local network).
</p>


<br>
<a name="nat1.3"></a>
<b>Configuration</b>

<p>
For the purpose of example, we will use the system described
below. Your setup will almost certainly vary from this, so be 
very careful in typing anything you see here literally into
your system and expecting it to work as you desire.  
</p>

<ul>
<b>Computer Operating System: </b>OpenBSD v3.0 i386<br>
<br>
<b>NICs: </b>
<ul>
Intel EtherExpress Pro/100 <b>fxp0</b><br>
Connected to the EXTERNAL LAN (or WAN)<br>
<b>IP Address: </b>24.5.0.5<br>
<b>Netmask: </b>255.255.255.0<br>
<br>
Compaq Netelligent 10/100Mb <b>tl0</b><br>
Connected to the INTERNAL LAN<br>
<b>IP Address: </b>192.168.1.1<br>
<b>Netmask: </b>255.255.255.0<br>	
</ul>
<br>
<b>External, Internet-routeable IP (provided by ISP, in this example, a cable modem provider)<br></b>
<ul>
<b>IP Address: </b>24.5.0.5<br>
<b>Netmask: </b>255.255.255.0<br>
<b>Gateway: </b>24.5.0.1<br>
</ul>
<br>
<b>Local Area Network</b><br>
<ul>
In this example environment,
machines on the internal network use the IP addressing scheme 192.168.1.xxx
(where xxx is a unique number). There could be a variety of different
operating systems on the internal network, such as Windows 98,
Windows NT, OpenBSD and Linux, but the client OS is not an issue for NAT. 
For the examples, the client we will look at on the internal
network will be assumed to have an IP address of 192.168.1.40.
</ul>
<br>
<b>Diagram of Configuration</b>
<ul><pre>
+-----+              +---------+          +----------+
| Hub |--------- tl0 |   NAT   | fxp0 ----| Internet |
+-----+              +---------+          +----------+
| |
| +-- Client A
+---- More clients 

		      +--------------------------+
		      |          LEGEND          |
		      +--------------------------+
		      |  NIC fxp0 - 24.5.0.5     |
		      |  NIC tl0  - 192.168.1.1  |
		      | Client A  - 192.168.1.35 |
		      +--------------------------+

</pre></ul>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Network Address Translation</u></h3>
<br>

<a name="nat2.1"></a>
<b>Introduction to NAT</b>

<p>
Each node on the Internet requires a unique IP address.  At least
with IPv4, there is a very finite number of distinct IP addresses 
available, and as a result, they are not free.  Most "low-cost" ISPs
will limit a site to anywhere from 1 to 30 addresses, and while 
larger budget organizations may be able to afford a larger block, 
in most cases, there are relatively few benefits and considerable 
risks to having each computer individually addressable on the 
Internet.
</p>
<p>
Network Address Translation, or NAT, (also known as &quot;IP Masquerading&quot;
if you are coming from a Linux background) allows multiple computers
to be located &quot;behind&quot; one (or a small number of) IP address.  Each 
&quot;internal&quot; computer has a locally assigned, unregistered
IP address (per <a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), 
and all utilize the same external IP address, simultaneously.  
</p>
<p>
The way NAT works is rather simple. When a client on the LAN
wants to connect to a machine on the Internet, it sends out a TCP
packet with a request to connect. Inside the TCP packet header is the
client's IP address (e.g. 192.168.1.40) and the requested host's IP
address (e.g. 123.45.67.89). The machine running NAT intercepts this
TCP packet and changes the client's IP address from 192.168.1.40 to
the IP address of the Internet-connected machine (e.g. 24.5.0.5). This
effectively tricks the host machine into thinking the actual connection
is from the NAT machine, not the actual client's machine. The host then
sends back responses to the NAT machine like it was the one connecting.
When the NAT machine receives the responses it quickly translates the
destination IP address back from itself to the client's machine and
sends the packet to the client. The client normally does not have any 
idea what happened and the apparent Internet connectivity is 
transparent to the user and user's applications.
</p>

<p>
The example below shows NAT a little more clearly:
</p>

<ul><pre>
Client ----------------- tl0 [ NAT ] fxp0 ---------- Internet Host
192.168.1.35 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

OUTGOING TCP Packet                     OUTGOING TCP Packet
From: 192.168.1.35  &gt;&gt;=== NAT ===&gt;&gt;     From: 24.5.0.5
To: 123.45.67.89                        To: 123.45.67.89

INCOMING TCP Packet                     INCOMING TCP Packet
From: 123.45.67.89 			From: 123.45.67.89
To:   192.168.1.40  &lt;&lt;=== NAT ===&lt;&lt;     To: 24.5.0.5
</pre></ul>

<br>
<a name="nat2.2"></a>
<b>Why use NAT?</b>

<p>
When presented with a cable modem in my new apartment I was also
presented with another minor problem. How to get Internet access for
my roommates, when the cable modem resides in my room? There were a
few options I could implement, ranging from obtaining extra IP
addresses, to setting up a proxy server, to setting up NAT.
(Don't let the home cable modem example fool you.  NAT is powerful enough
to masquerade a large network with hundreds or even thousands of computers!)
</p>

<p>
There are many reasons why I wanted to set up NAT. The number one
reason is to save money. There
are two roommates in my house, splitting the cost is certainly attractive.
Further, as each roommate has their own PC and I have three, we
had five computers to connect, but my ISP only allows for three IP 
addresses per household.  This means that there weren't enough IP 
addresses to allow every machine simultaneous direct Internet access.
</p>

<p>
By using NAT each machine will have a unique internal IP address
but share the one IP address given to me by my ISP. The cost goes down.
</p>

<br>
<a name="nat2.4"></a>
<b>Setup</b>

<p>
In order to enable NAT on your OpenBSD machine you will need to turn on
PF. This is easily accomplished by editing the files listed
below (make the changes to the file so it looks like the options below):
</p>

<p>
<b>/etc/rc.conf</b> (this file used to start services at boot time)
</p>

<ul><pre>
pf=YES<br>
</pre></ul>

<p>
<b>/etc/sysctl.conf</b>
</p>

<ul><pre>
net.inet.ip.forwarding=1
</pre></ul>

<p>
After these changes are made, the machine is now ready for the
configuration of NAT.
</p>

<br>
<a name="nat2.5"></a>
<b>Configuration</b>

<p>
The first step is to configure the PF configuration file
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">/etc/pf.conf</a></i>).
For the purposes of this document we will allow traffic to pass
through this firewall without any interference. The file
should look like this:
</p>

<ul><pre>
pass in all
pass out all
</pre></ul>

<p>
Again, for more information you can read <a href="#6.2">FAQ 6.2</a>
</p>

<p>
The NAT configuration file
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">/etc/nat.conf</a></i>).
has a very simple syntax.
For the configuration set forth above, the file should contain the
following entry:
</p>

<ul><pre>
nat on fxp0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
</pre></ul>

<p>
Here is an explanation for the above lines.
</p>

<ul>
<strong>"nat"</strong>
<p>
This indicates the command you are giving is a NAT rule.
</p>
</ul>

<ul>
<strong>"fxp0"</strong>
<p>
This is the network interface that is connected to the Internet.
</p>
</ul>

<ul>
<b>"192.168.1.0/24"</b>
<p>
the IP address and netmask (the netmask is in
CIDR format). Combined they state "any IP address of value
192.168.1.1 through 192.168.1.254" should be mapped. 
</p>
</ul>

<ul>
<b>"24.5.0.5"</b>
<p>
This is the external IP address the internal IP addresses will be mapped to.
</p>
</ul>

<a name="nat2.6"></a>
<b>Running</b>

<p>
Once the configuration is
complete, there are two ways to enable NAT. The first (and best way if
possible) is to reboot your OpenBSD machine.
This is accomplished with the command "<i>reboot</i>". 
</p>

<p>
If you would like to configure NAT from the command line, use the following
commands:
</p>

<ul><pre>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre></ul>

<p>
The first line is to load a set of NAT rules into PF (and flushing any
old rules), the second line enables PF.  Again, though, rebooting is 
the best way to ensure that everything will startup from a reboot as 
you expect.
</p>


<p>
<b>Note:</b> in order to reload the NAT settings (in case you edit the file
but don't want to reboot) just execute the first command over again. The
settings will be flushed and reloaded.
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 Nat Knowledge Base</u></h3>

<br>
<a name="nat3.1"></a>
<b>Checking NAT Status</b>

<p>
To find out how NAT is doing or make sure the settings have taken
effect, you use the "-ss" option. This option will list all the
current sessions that NAT is running:
</p>

<ul><pre>
# pfctl -ss
TCP  192.168.1.35:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.35:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.35:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
</pre></ul>

<p>
Explanations (first line, others are similar):
</p>
<ul>
<b>"192.168.1.35:2132"</b>
<p>
This tells you the IP address of the
machine on the LAN that is using NAT (192.168.1.35). The port number used to make
the connection (2132) is displayed afterwards.
</p>
</ul>
<ul>
<b>"24.5.0.5:53136"</b>
<p>
This denotes that the connection is going
to the Internet via IP address 24.5.0.5 and using port 53136.
</p>
</ul>
<ul>
<b>"65.42.33.245:22"</b>
<p>
The IP address and the port being connected to.
</p>
</ul>
<ul>
<b>"TIME_WAIT:TIME_WAIT"</b>
<p>
This indicates what state PF believes the TCP connection to be in.
</p>
</ul>

<a name="nat3.2"></a>
<b> Issues with FTP and NAT</b>

<p>
There are a few limitations of NAT, the most commonly encountered is
with FTP. You can use FTP in two ways: passive and active. Of these,
passive FTP is generally considered more secure.
</p>
<p>
With active FTP, when a user connects to a remote FTP server and
requests information or file, the FTP client sends the server a random
port number that the the FTP server will make a connection to on the
client and transfer the info. This is a problem for users attempting
to gain access to FTP servers from within the LAN. When the FTP server
sends its information it sends it to the external NIC at a random port.
The NAT machine will receive this, but because it has no mappings for
the unknown packet and doesn't have any mappings for that port, it will
drop the packet and won't deliver it.
</p>
<p>
With passive mode FTP (the default with OpenBSD <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&sektion=1">ftp(1)</a>
client), the client requests that the server picks up a random port
that it will listen on for the data connection. The server informs the
client of the port it has chosen, and the client connects to this port
to transfer the data. Unfortunately, this is not always possible or
desirable. ftp(1) uses this mode by default; to force active mode FTP,
use the -A flag to ftp, or set the passive mode to off by issuing
the command
<dl><dt>
<pre>passive off
</pre>
</dt></dl>
at the ftp&gt; prompt.
</p>
<P>
Packet Filter provides another solution for this situation, redirecting 
FTP traffic through an FTP proxy server, a process which acts to "guide" your 
FTP traffic through the filters.  The FTP proxy used by OpenBSD and PF is 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&sektion=8">ftp-proxy(8)</a>.
To activate it, put something like this in your <i>/etc/nat.conf</i> file:
<ul><pre>
rdr on tl0 from any to any port 21 -&gt; 127.0.0.1 port 8081
</pre></ul>
Short explanation of this line is, "Traffic on the internal interface is 
redirected to the proxy server running on this machine which is listening at
port 8081".
</p>
<P>
Hopefully, it is apparent the proxy server has to be started and running on 
the OpenBSD box, this is done by inserting the following line in 
<i>/etc/inetd.conf</i>:
<ul><pre>
8081 stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
</pre></ul>
and either rebooting the system or sending a 'HUP' signal to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&sektion=8">inetd(8)</a>.
One way to send the 'HUP' signal is with the command:
<ul><pre>
kill -HUP `cat /var/run/inetd.pid`
</pre></ul>
You will note that ftp-proxy is listening on port 8081, the same port the above 
rdr statement was sending FTP traffic to.  The choice of port 8081 is arbitrary,
though 8081 is a good choice, as it is not defined for any other application.
</p>
<br>
<a name="nat3.3"></a>
<b>Redirecting Traffic</b>

<p>
For some applications, you may need to redirect incoming or outgoing 
traffic for a certain protocol and/or port to a particular machine behind
the filtering system. An example of this would be a computer residing inside 
the local network running a web server which was to be accessed by the outside world, 
(or of course, the already discussed ftp-proxy(8)). Incoming connections to 
your valid Internet IP will find that unless your NAT box is also running
a web server, no connection can be made. For this purpose we use the
NAT 'rdr' directive in the rules file to instruct where to redirect
a particular connection to.
</p>

<p>
For our example, lets say a web server resides on the LAN with IP address
of 192.168.1.80. The NAT rules file needs a new directive to handle this.
Add a line similar to the following one to your <i>/etc/nat.conf</i>:
</p>

<ul><pre>
rdr on fxp0 from any to any port 80 -&gt; 192.168.1.80 port 80
</pre></ul>

<p>
The explanation for each part of this line:
</p>
<ul>
<b>"rdr"</b>
<p>
This is the command you are giving NAT. It is telling NAT 
that this entry is an entry to redirect a connection. 
</p>
</ul>

<ul>
<b>"on fxp0"</b>
<p>
This is the network interface that is connected to the Internet.
</p>
</ul>

<ul>
<b>"from any to any"</b>
<p>
This indicates which IP addresses to redirect (from any coming in 
on fxp0, as indicated above, to any destination IP) 
</p>
</ul>

<ul>
<b>"port 80"</b>
<p>
This is the incoming port (80) that should be redirected. The number
"80" didn't have to be used. You can use "port www" also to specify
a redirection of port 80. If you would like to use a name instead of
a number, the service name and corresponding port, must exist in the
file <i>/etc/services</i>.
</p>
</ul>
<ul>
<b>"192.168.1.80 port 80"</b>
<p>
The IP address of the LAN machine which the packets are redirected to. 
Note that the destination port does NOT need to match the incoming port. 
For example, the following is valid, and even potentially useful:
<pre>
rdr on fxp0 from any to any port 8080 -&gt; 192.168.1.35 port 80
</pre>
This line would redirect incoming traffic on port 8080 to a webserver
running on a machine in the internal network, at the "standard" port 80.
</p>
</ul>
<p>
When the addition is complete reload the NAT rules, and the redirection
will start immediately.
</p>
<p>
<b>Negation</b>
</p>
<p>
Sometimes, you need to make exceptions to a NAT or redirection rule.
Here's an example.  AOL Instant Messenger is noted for sneaking out 
firewalls through any available port.  You may find that the 
ftp-proxy is interfering with AIM when it chooses to go out to 
remote port 21.  In the event you consider this bad (many people 
spend considerable time trying to block AIM!), you might wish to 
exclude the IP addresses used by the AIM servers from the traffic
redirected by our above ftp-proxy line.  You can do this with the
following line:
<ul><pre>
rdr on tl0 from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8081
</pre></ul>
Interpretation: Redirect traffic coming in on tl0 going to port 21 
but NOT to 64.12.163.199 (the AIM server users were having trouble
with) to localhost port 8081 (where
hopefully ftp-proxy is waiting).  Now, be advised that there are many
AIM servers, if this application interests you, you will probably 
have to play with these IP addresses (64.12.0.0/16 might be more 
productive, though probably also interferes with some non-AOL sites)
</p>

<br>
<a name="nat3.4"></a>
<b>NAT versus Proxy</b>

<p>
The difference between NAT and an application-based proxy is that the proxy
software acts as a middle-man between the Internet and the machines connected
on the LAN. This is fine, however each application you want to run on
your machine and connect to the Internet through the proxy server MUST
be proxy-aware (be able to use a proxy server). Not all applications are
able to do this (especially games). Furthermore, there simply are not
proxy server applications for all of the Internet services out there.
NAT transparently maps
your internal network so that it may connect to the Internet.  The only
security advantage to using a proxy software over NAT is that the proxy
software may have been made security aware, and can filter based on content,
to keep your Windows machine from getting a macro virus, it can protect
against buffer overflows to your client software, and more.  To maintain
these filters is often a high-maintenance job.
</p>

<a name="nat4.0"></a>
<b>6.3.4 Links and Cross-References</b>

<p>
OpenBSD files:
<ul>
<li>/etc/nat.conf - NAT rules file
<li>/etc/rc.conf - need to edit to start up NAT and PF at boot time
<li>/etc/sysctl.conf - need to edit to enable IP forwarding
</ul>
</p>

<p>
NAT Internet Links:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">nat.conf man page</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&sektion=8">pfctl man page</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>

<p> 
<a name= "6.4"></a> <h2>6.4 - DHCP</h2> </p>

<h3>6.4.1 DHCP Client</h3>
<p>To use the DHCP client <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&apropos=0&sektion=8&format=html">dhclient(8)</a>
included with OpenBSD, edit /etc/hostname.xl0
(this is assuming your main ethernet interface is xl0.  Yours might be ep0 or fxp0 or something else!)
All you need to put in this hostname file is 'dhcp'
<pre>
# <strong>echo dhcp &gt;/etc/hostname.xl0</strong>
</pre>
This will cause OpenBSD to automatically start the DHCP client on boot.  OpenBSD will gather its IP address,
default gateway, and DNS servers from the DHCP server.  
<p>
If you want to start a dhcp client from the command line, make sure
/etc/dhclient.conf exists, then try:
<PRE>
# <strong>dhclient fxp0</strong>
</pre>
Where fxp0 is the interface that you want to receive dhcp on.
<P>No matter how you start the dhclient, you can edit
the /etc/dhclient.conf file to <b>not</b> update your DNS according to the dhcp
server's idea of DNS by first uncommenting the 'require' lines in it (they are
examples of the default settings, but you need to uncomment them to override
dhclient's defaults.)
<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>
and then <b>remove</b> domain-name-servers.  Of course, you may want to remove
hostname, or other settings too.
<P>
<h3>6.4.2 DHCP Server</h3>

If you want to use OpenBSD as a DHCP server <A href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&apropos=0&sektion=8&format=html">dhcpd(8)</a>,
edit /etc/rc.conf.  Set it up so that dhcpd_flags="-q" instead of dhcpd_flags=NO.
Put the interfaces that you want dhcpd to <b>listen</b> on in /etc/dhcpd.interfaces.
<pre>
# <strong>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</strong>
</pre>
Then, edit /etc/dhcpd.conf.
The options are pretty self explanatory.
<pre>
        option  domain-name "xyz.mil";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>
<p>
This will tell your dhcp clients that the domain to append to DNS requests is xyz.mil (so, if the user types in 'telnet joe' then it will
send them to joe.xyz.mil).  It will point them to DNS servers 192.168.1.3 and 192.168.1.5.  For hosts that are on the same network as
an ethernet interface on the OpenBSD machine, which is in the 192.168.1.0/24 range, it will assign them an IP address between
192.168.1.32 and 192.168.1.127.  It will set their default gateway as 192.168.1.1.
<p>
If you want to start dhcpd from the command line, after editing /etc/dhcpd.conf,
try:
<PRE>
# <strong>dhcpd -q fxp0</strong>
</PRE>
Where fxp0 is an interface that you want to start serving dhcp on.
The -q flag makes dhcpd quiet, otherwise it is very noisy.
<P>
If you are serving DHCP to a Windows box, you may want to
dhcpd to give the client a 'WINS' server address.
To make this happen, just the following line to your /etc/dhcpd.conf:
<pre>
option	netbios-name-servers	192.168.92.55;
</pre>
(where 192.168.92.55 is the IP of your Windows or Samba server.)
See <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&apropos=0&sektion=5&format=html">dhcp-options(5)</a> for more options that your DHCP
clients may want.
<p>
<a name= "6.5"></a>
<h2>6.5 - PPP </h2>
</p>

Point-to-Protocol is generally what is used to create a connection to your ISP via your modem. OpenBSD has 2 ways of doing this. 

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8&format=html">pppd(8)</a> - Which is
the kernel ppp daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> - Which is
the userland ppp daemon. 
</ul>

<p>
The first one we will cover will be the userland PPP daemon. To start off you will need some simple
information about your isp. Here is a list of helpful information that you will need.
</p>

<ul>
<li>Your ISP's dialup number
<li>Your nameserver 
<li>Your username and password.
<li>Your gateway
</ul>

<p>
Some of these you can do without, but would be helpful in setting up your ppp. The userland PPP daemon uses
the file <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> as
its configuration file. There are many helpful files in <b>/etc/ppp</b> that can have different setups for
many different situations. You should take a browse though that directory.
</p>

<p>
Also, make sure, that if your not using a GENERIC kernel, that you have this line in your configuration file:
</p>

<ul><pre><strong>
pseudo-device   tun             2
</strong></pre></ul>


<h3>Initial Setup - for PPP(8)</h3>

<p>
Initial Setup for the userland PPP daemon consists of editing your <b>/etc/ppp/ppp.conf</b> file. This file
doesn't exist by default, but there is a file <b>/etc/ppp/ppp.conf.sample</b> in which you can simply edit to
create your own <b>ppp.conf</b> file. Here I will start with the simplist setup and probably most used setup.
Here is a quick <b>ppp.conf</b> file that will simply connect to your ISP and set your default routes and
nameserver. With this file all the information you need is your ISP's phone number and your username and
password.
</p>

<ul>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</ul>

<p>
<b>NOTICE</b> - On OpenBSD 2.6, the system shipped with a <i>/etc/ppp/ppp.conf.example</i> that had an incorrect setting for device. The device was <i>"set device /dev/cuaa0"</i>. This should be <i>/dev/cua00</i> which would correspond to serial device 1. (COM1). Your device might not be on COM1, however the naming scheme was wrong.
</p>

<p>
The section under the <b>default:</b> tag will get executed each time. Here we setup all our critical
information. Here with &quot;set log&quot; we set our logging levels. This can be changed, refer to 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> for more info on
setting up logging levels. Our device gets set with &quot;set device&quot;. This is the device that the modem
is on. In this example the modem is on com port 2. Therefore com port 1 would be /dev/cua00. With &quot;set
speed&quot; we set the speed of our dialup connection and with &quot;set dial&quot; we set our dialup
parameters. With this we can change our timeout time, etc. This line should stay pretty much as it is though.
</p>

<p>
Now we can move on and setup our information specific to our ISP. We do this by adding another tag under our
<b>default:</b> section. This tag can be called anything you want, easiest to just use the name of your ISP.
Here I will use <b>myisp:</b> as our tag referring to our ISP. Here is a simple setup incorporating all we need
to get ourselves connected.
<p>

<ul>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</ul>

<p>
Here we have setup essential info for that specific ISP. The first option &quot;set phone&quot; sets your
ISP's dialup number. The &quot;set login&quot; sets our login options. Here we have the timeout set to 5, this
means that we will abort our login attempt after 5 seconds if no carrier. Otherwise it will wait for
&quot;login:&quot; to be sent and send in your username and password. In this example our Username = ppp and
Password = ppp. These values will need to be changed. The line &quot;set timeout&quot; sets the idle timeout for
the entire connection duration to 120 seconds. The &quot;set ifaddr&quot; line is a little tricky. Here is a more
extensive explanation.
</p>

<ul><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></ul>

<p>
In the above line, we have it set in the format of &quot;<b>set ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask
[triggeraddr]]]]</b>&quot;. So the first IP specified is what we want as our IP. If you have a static IP address, you set it here. In our example we use /0
which says that no bits of this ip address need to match and the whole thing can be replaced. The second IP
specified is what we expect as their IP. If you know this you can specify it. Again in our line we don't know
what will be assigned, so we let them tell us. The third option is our netmask, here set to 255.255.255.0.If
triggeraddr is specified, it is used in place of myaddr in the initial IPCP negotiation.  However, only an
address in the myaddr range will be accepted.  This is useful when negotiating with some PPP implementations
that will not assign an IP number unless their peer requests ``0.0.0.0''.
</p>

<p>
The next option used &quot;add default HISADDR&quot; sets our default route to their IP. This is 'sticky',
meaning that if their IP should change, our route will automatically be updated. With &quot;enable dns&quot;
we are telling our ISP to authenticate our nameserver addresses. Do NOT do this if you are running an local
DNS, as ppp will simply circumvent its use by entering some nameserver lines in /etc/resolv.conf.
</p>

<h3>Using PPP(8)</h3>

<p>
Now that we have our <b>ppp.conf</b> file setup we can start trying to make a connection to our ISP. I will
detail some commonly used arguments with ppp.
</p>

<ul>
<li><b>ppp -auto myisp</b> - This will run ppp, configure your interfaces and connect to your isp and then go
into the background.
<li><b>ppp -ddial myisp</b> - This is similar to -auto, but if your connection is dropped it will try and
reconnect.
</ul>

<p>
By using <b>/usr/sbin/ppp</b> with no options will put you into interactive mode. From here you can interact
directly with the modem, it is great for debugging problems in your <b>ppp.conf</b> file.
</p>

<h3>ppp(8) extras</h3>

<p>
In some situations you might want commands executed as your connection is
made or dropped. There are two files you can create for just these
situations. <b>/etc/ppp/ppp.linkup</b> and <b>/etc/ppp/ppp.linkdown</b>.
Sample configurations can be viewed here:
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Extended information can be found at <a href="http://www.freebsd.org/handbook/userppp.html">http://www.freebsd.org/handbook/userppp.html</a> or <a href="http://www.freebsd.org/faq/userppp.html">http://www.freebsd.org/faq/userppp.html</a>.
</p>

<p>
<a name= "6.6"></a>
<h2>6.6 - Tuning networking parameters</h2>

<H3>6.6.1 - How can I tweak the kernel so that there are a higher number of retries and longer timeouts for TCP sessions?</h3>
You would normally use this to allow for routing or connection problems.
Of course, for it to be most effective, both sides of the connection
need to use similar values.
<P>
To tweak this, use <tt>sysctl</tt> and increase the values of:
<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>
Using sysctl -a, you can see the current values of these (and many other)
parameters.  To change one, use <tt>sysctl -w</tt>, as in <tt>sysctl -w
net.inet.tcp.keepidle=28800</tt>.  
<h3>6.6.2 - How can I turn on directed broadcasts?</h3>
Normally, you don't want to do this.  This allows someone to send
traffic to the broadcast address(es) of your connected network(s) if you
are using your OpenBSD box as a router.<P>
There are some instances, in closed networks, where this may be useful,
particularly when using older implementations of the NetBIOS protocol.
This is another sysctl.  <Tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> 
turns this on.  Read about <A HREF="http://www.netscan.org">smurf attacks</a>
if you want to know why it is off by default.
<H3>6.6.3 - I don't want the kernel to dynamically allocate a certain port</h3>
There is a sysctl for this also.  From <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:
<PRE>
Set the list of reserved TCP ports that should not be allocated by the
kernel dynamically.  This can be used to keep daemons from stealing a
specific port that another program needs to function.  List elements may
be separated by commas and/or whitespace.

   sysctl -w net.inet.tcp.baddynamic=749,750,751,760,761,871

It is also possible to add or remove ports from the current list.

   sysctl -w net.inet.tcp.baddynamic=+748
   sysctl -w net.inet.tcp.baddynamic=-871
</pre>

<a name="6.7"></a>
<h2>6.7 - Simple NFS usage</h2>

<p> NFS, or Network File System, is used to share a filesystem over the
network. A few choice man pages to read before trying to setup a NFS
server are:

<p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8&format=html">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8&format=html">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>
</ul>

<p>
This section will go through the steps for a simple setup of NFS. This example
details a server on a LAN, with clients accessing NFS on the LAN. It
does not talk about securing NFS. We presume you have already setup
packet filtering or other firewalling protection, to prevent outside access.
If you are allowing outside access to your NFS server, and you have
any kind of sensitive data stored on it, we strongly recommend that you employ 
<a href="faq13.html">IPSec</a>.  Otherwise, people can potentially see your NFS
traffic.  Someone could also pretend to be the IP address which you are 
allowing into your NFS server.  There are several attacks that can result.
When properly configured, IPSec protects against these types of attacks.
<P>
Another important security note.  Don't
just add a filesystem to /etc/exports without some kind of list of allowed
host(s). Without a list of hosts which can mount a particular directory,
anyone on who can reach your host will be able to mount your NFS
exports.
</p>

<p>
The setup consists of a server with the ip <b>10.0.0.1</b>. This server
will be serving NFS only to clients within that network. The first step to
setting up NFS is to setup your <i>/etc/exports</i> file. This file lists
which filesystems you wish to have accessible via NFS and defines who is
able to access them. There are many options that you can use in your
<i>/etc/exports</i> file, and it is best that you read the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5&format=html">exports(5)</a>
man page. For this example we have an <i>/etc/exports</i> that looks like
this:
</p>

<ul><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></ul>

<p>
This means that the local filesystem <b>/work</b> will be made available
via NFS. <b>-alldirs</b> specifies that clients will be able to mount at
any point under the <b>/work</b> mount point. <b>-ro</b> specifies that it
will only be allowed to be mounted read-only. The last two arguments
specify that only clients within the 10.0.0.0 network using a netmask of
255.255.255.0 will be authorized to mount this filesystem. This is
important for some servers that are accessible by different networks.
</p>

<p> Once your <i>/etc/exports</i> file is setup, you can go ahead and
setup your NFS server. You should first make sure that options NFSSERVER
&amp; NFSCLIENT are in your kernel configuration. (GENERIC kernel has these
options included.) Next, you should set <strong>nfs_server=YES</strong> in
<i>/etc/rc.conf</i>. This will bring up both nfsd(8) and mountd(8) when
you reboot. Now, you can go ahead and start the daemons yourself. These
daemons need to be started as root, and you need to make sure that
portmap(8) is running on your system. Here is an example of starting
nfsd(8) which serves on both TCP and UDP using 4 daemons.  You should set
an appropriate number of NFS server daemons to handle the maximum number of
concurrent client requests that you want to service.

<P>

<ul><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></ul>

<p>
Not only do you have to start the nfsd(8) server, but you need to start
mountd(8). This is the daemon that actually services the mount requests on
NFS. To start mountd(8), simply type:
<p>

<ul><pre>
# <strong>/sbin/mountd</strong>
</pre></ul>

<P>
If you make changes to /etc/exports while NFS is already running,
you need to make mountd aware of this!  Just HUP it:

<UL><PRE>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></ul>

<P>

<h3>Checking Stats on NFS</h3>

<p>
From here, you can check to make sure that all these daemons are up and
registered with RPC. To do this, use rpcinfo(8). 
<p>

<ul><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></ul>

<p> During normal usage, there are a few other utilities that allow you to
see what is happening with NFS. One is <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8&format=html">showmount(8)</a>
, which allows you to view what is currently mounted and who is mounting
it. There is also nfsstat(8) which shows much more verbose statistics. To
use showmount(8), try <b>/usr/bin/showmount -a host</b>. For
example:

<P>

<ul><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></ul>

<h3>Mounting NFS Filesystems</h3>

<p>
NFS filesystems should be mounted via mount(8), or more specifically,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8&format=html">mount_nfs(8)</a>.
To mount a filesystem /work on host 10.0.0.1 to local filesystem /mnt,
do this (note that you don't need to use an IP address, mount will resolve
host names):
<p>

<ul><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></ul>

<p>
To have your system mount upon boot,
add something like this to your <i>/etc/fstab</i>:
<p>

<ul><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></ul>

<p>
It is important that you use <tt>0 0</tt> at the end of this line so that
your computer does not try to fsck the NFS filesystem on boot!!!!
The other standard security options, such as noexec, nodev, and nosuid,
should also be used where applicable.  Such as:
<p>

<ul><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></ul>

<p>
This way, no devices or setuid programs on the NFS server can subvert security measures
on the NFS client.  If you are not mounting programs which you expect
to run on the NFS client, add noexec to this list.


<a name="6.8"></a>
<h2>6.8 - Domain Name Service  - DNS, BIND, and named</h2>

<h3>6.8.1 What is DNS?</h3>

<p>
Domain Name Service is a network facility allowing IP network domains to provide name-to-IP address resolution and IP address-to-name resolution in response to a query. Your OpenBSD installation is configured by default as a DNS client but not as a DNS server. That is, your OpenBSD installation can perform a DNS query against a domain name server for the address of a machine, but it cannot answer such DNS queries itself unless you specifically configure it to do so.</p>

<p>
My OpenBSD machine is currently connected to the Internet via my ISP, so I can use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a> utility to execute the DNS query:
</p>

<ul><pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre></ul>

<p>
<b>165.87.201.244</b> is the name server which answered, because it is the nameserver that my ISP told me to use with my account and whose number is entered in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a>. But the answer was not authoritative. For an authoritative answer, let's find which is the authoritative DNS server for the <i>openbsd.org</i> domain and ask it for the address of <i>www.openbsd.org</i>:
</p>

<ul><pre>
# Identify the name servers for openbsd.org
# with the help of my ISP's name server.
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet address = 199.185.137.3
gandalf.sigmasoft.com   internet address = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Use the info gained to query for an authoritative
# resolution: query the authoritative zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Address:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre></ul>

<p>
<i>zeus.theos.com</i> is, one would suppose, running OpenBSD and is properly configured to be a DNS server for the <i>openbsd.org</i> domain.
</p>

<a name="6.8.1.1"></a>
<h3>6.8.1.1 Where can I learn all about DNS and its implementation under OpenBSD?</h3>

<ul>
<li>See RFCs <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, <a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a>, and <a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> for more information on the Internet name-domain system.</li>
<li>Read the O'Reilly Associates book <i><a href="../books.html#dns&bind">DNS and BIND</a> </i>.</li>
<li>Read the <a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD Manual</a> especially the pages for</li>
	<ul>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8&format=html">nslookup(8)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&sektion=3&format=html">gethostbyname(3)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&sektion=8&format=html">named(8)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=3&format=html">resolver(3)</a>
	<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=5&format=html">resolver(5)</a>
	</ul>
</ul>

<p>
The <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> command is especially useful, because it can query a domain and return information in much the same record format as required in BIND configuration files. You can use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> to examine name servers you know to be operating properly as a way of comparing your setup to theirs.
</p>

<h3>6.8.2 Does my machine need to be a domain name server?</h3>

<p>
If you aren't sure that you need your machine to perform the role of DNS server, don't configure it as one. The OpenBSD installation does not, by default, activate your machine as a domain name server, though all necessary files are installed. For most workstations, just the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5&format=html">/etc/hosts</a> file naming local machines' IP addresses and the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5&format=html">/etc/resolv.conf</a> file for indicating which DNS servers serve you out on the intranet or internet is sufficient.
</p>

<p>
On the other hand, you might need to set up a machine as a domain name server:
<ul>
<li>If you have an IP LAN on which you do not wish to replicate "hosts" files of local addresses machine by machine. In such a case, you may configure your OpenBSD machine as a DNS server and serve queries from the other machines on your LAN.</li>
<ul>
<li><b>Note:</b> There is no practical restriction on the number of DNS servers on a LAN. Any or all machines on the LAN may offer DNS service if they are so configured. Whether any such server is considered authoritative from outside your LAN (or is even known from outside your LAN) is a configuration factor which typically is controlled at the next level up from your LAN in the domain hierarchy.</li>
</ul>
<li>If you have an IP LAN on which reside machines you will wish to be findable via DNS query by machines on another IP LAN or WAN.</li>
<li>If you experience difficulties resolving the local hostname to an IP address, or resolving other local names to IP addresses even though you have correct <i>/etc/hosts</i> and <i>/etc/resolv.conf</i> (E.g., Netscape on OpenBSD sometimes exhibits this behavior because it implements its own resolver instead of just using <i>gethostbyname(3)</i> to look up addresses.)</li>
</ul>

<p>
One more consideration is speed of execution. Since name resolution is an iterative process, in which the name server makes repeated queries to other nameservers for addresses in remote domains, name resolution may take slightly longer if you have a modem connection to the Internet and are querying your own DNS server for remote addresses (which will then iteratively query remote name servers via the modem) than if you are querying your ISP's name server (which probably has a faster connection to remote name servers).
</p>

<h3>6.8.3 What are the software components of the DNS server?</h3>

<ul>
<li>named <i>("name daemon")</i></li>
<li>Configuration files in the directory hierarchy under <i>/var/named/</i></li>
</ul>

<h4>6.8.3.1 What level of BIND is supported?</h4>

<p>
BIND is the name of the behavioral specification of a domain name server. Domain name server components exist to collectively implement BIND. 
</p>

<p>
There are two distinct BIND specifications:
<ol>
<li>BIND 4</li>
<li>BIND 8</li>
</ol>

<p>
As installed, OpenBSD <b>named</b> supports BIND 4.x.

<h4>6.8.3.2 What are some of the alternatives to providing DNS via the default BIND 4.x implementation?</h4>

<ul>
<li>The BIND 9.x implementation in <i>/usr/ports/net/bind9</i>.(See <a href="../ports.html">ports</a>)
</ul>

<h5>6.8.3.2.1 <u>Security</u> note</h5>

<p>
If you use these alternative implementations of domain name service, you are providing a critical network service using software which may not have been subject to quite the same level of scrutiny as the <a href="http://www.openbsd.org/security.html">security-audited</a> <b>named</b> name daemon in the base installation. This is a significant consideration, since if a domain name server is compromised, resolvers using that name server can be re-directed to impostor sites.
</p>

<h3>6.8.4 How much do I have to install?</h3>

<p>
If the default networking setup was installed properly at OpenBSD installation time, everything is already installed. You just have to configure the name daemon ("<tt>named</tt>").
</p>

<h3>6.8.5 How do I configure DNS?</h3>

<p>
You configure OpenBSD DNS by editing and/or creating files that control the name daemon <tt>named</tt>. These files reside by default in the directory <i>/var/named</i> and its subdirectories, especially the file <i>/var/named/named.boot</i> which is the initialization file for <b>named</b>. There are also a couple of other configuration steps to be taken in <i>/etc</i>.
</p>

<p>
In this document, we will configure the name daemon on <i>nemo.yewtopia.com</i> be the primary nameserver for the (very small!) domain <i>yewtopia.com</i>. The address of <i>nemo.yewtopia.com</i> is <i>192.168.1.9</i>. Two other machines are on that subnet, <i>crater.yewtopia.com </i>at 192.168.1.1 and <i>earhart.yewtopia.com</i> at 192.168.1.2.
</p>

<h4>6.8.5.1 Configuration in <i>/var/named</i></h4>

<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<ul><pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain   source host/file backup file
cache     .	   root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre></ul>

<p>
This tells the initialization process in what subdirectory and under which filenames to find the configuration files for <i>yewtopia.com</i>. 

<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<ul><pre>
; Reverse lookup for localhost interface
@       IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre></ul>

<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<ul><pre>
; yewtopia.com domain database
yewtopia.com.        IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre></ul>

<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<ul><pre>
; yewtopia domain reverse lookup database
1.168.192.in-addr.arpa. IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre></ul>

<h4>6.8.5.2 Configuration in <i>/etc</i></h4>

<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>
<p>
Make sure <i>/etc/resolv.conf</i> now points to the domain of local machine (instead of, for example, your ISP's name server) so that name resolution requests actually get sent to the <b>named</b> you have configured!
</p>

<ul><pre>
domain yewtopia.com
lookup file bind
</pre></ul>

<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>
If you previously had added the addresses of various machines to the <i>/etc/hosts</i> file, you might consider shortening your <i>/etc/hosts</i> file back to the default:
</p>

<ul><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></ul>

<p>
So that <b>named</b> isn't bypassed in favor of (possibly outdated) addresses in the <i>/etc/hosts</i> file. <u>Make sure you have at least the default <i>localhost</i> entry</u> or your network won't start properly! Note also <i>nemo</i> must appear in its own hosts file or you will see a (mostly harmless) error message at bootup when <i>/etc/netstart</i> invokes <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8&format=html">route(8)</a> in order to add <i>nemo</i> (whose name appears in <i>/etc/myname</i>).
</p>

<h4>6.8.5.3 Using <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1&format=html">dig(1)</a> to examine the results.</h4>

<ul><pre>
$ <strong>dig @nemo.yewtopia yewtopia any any</strong>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia, type = ANY, class = ANY

;; ANSWERS:
yewtopia.        3600   SOA     nemo.yewtopia.
your_id.nemo.yewtopia. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.        3600   NS      nemo.yewtopia.

;; ADDITIONAL RECORDS:
nemo.yewtopia.   3600   A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre></ul>

<h3>6.8.6 How and when do I start and stop DNS?</h3>

<h4>6.8.6.1 Starting DNS</h4>

<p>
The name daemon <b>named</b> is launched during system startup from <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8&format=html">/etc/rc</a> if the line installed by default in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8&format=html">/etc/rc.conf</a>.
</p>

<ul><pre>
named_flags=NO          # for normal use: ""
</pre></ul>

<p>
is changed to
</p>

<ul><pre>
named_flags=""          # for normal use: ""
</pre></ul>

<p>
Also, examine these lines in /etc/rc.conf:
</p>

<ul><pre>
named_user=named                # Named should not run as root unless necessary
named_chroot=/var/named         # Where to chroot named if not empty
</pre></ul>

<p>
These defaults will be correct for nearly all setups.
</p>

<p>
To start <b>named</b> by hand, use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> command. For example:
</p>

<ul><pre>
# <strong>ndc start</strong>
          or
# <strong>ndc restart</strong>
</pre></ul>

<h4>6.8.6.2 Stopping DNS</h4>

<p>
The best way to stop the name daemon is to use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> command. For example:
</p>

<ul><pre>
# <strong>ndc stop</strong>
</pre></ul>

<p>
If this fails to work, find the process id of named and use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&sektion=1&format=html">kill(1)</a> command to end that process. The PID for <b>named</b> while it is running is found as the first line in the file <i>/var/named/named.pid</i>
</p>

<ul><pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</pre></ul>

<h4>6.8.6.3 Restarting DNS with an altered configuration</h4>

<p>
To cause a running instance of the name daemon to restart itself reloading its configuration after you have made changes, send it a "hangup" signal:
</p>

<ul><pre>
# <strong>kill -HUP 4608</strong> 
</pre></ul>

<p>
or by using the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8&format=html">ndc(8)</a> command. For example:
</p>

<ul><pre>
# <strong>ndc reload</strong>
</pre></ul>

<h3>6.8.7 How do I block AXFR queries? </h3>
<p>
example:
<ul><pre>
garden:/home/jeremy$<strong>  host -l openssh.com</strong>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></ul>
<p>
This information is useful for debugging DNS, but in some instances you may not want this output publicly offered.
If you are using classless in-addr(rfc2317) for reverse, host -l may report every domain that your system hosts!
This can easily be remedied by the 'allow-transfer' clause in your zone file.
<br><br>
If you're using Bind8 you need to specify the hosts you want to allow to transfer zones in your individual zone file(s):
<ul><pre>
zone "foo.com" in {
        type master;
        file "directory/zonefile";
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></ul>
You can also block transfers for all domains by editing /var/named.conf and add the 'allow-transfer' parameter to the 'options' section of the configuration file:
<ul><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></ul>
The Bind8 method also works with Bind9.<br>
If you are using Bind 4 (default in OpenBSD) you can edit /var/named/named.boot and use the 'xfrnets' option.<br>
<ul><pre>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></ul><br>
Bind 4 allows transfers from entire classes so it is not as exact.
Typically, the only hosts that need to perform transfers are your DNS slaves and hosts you may want to debug from (127.0.0.1 is usually a good host to
allow transfers from!)
Blocking AXFR queries adds an extra level of privacy, but can hinder useful DNS debugging.
(Thanks to <a href=mailto:ntang@nachtwache.org>Nicholas Tang</a> for that tip)
</p>
<h3>6.8.8 What didn't you tell me about setting up DNS?</h3>
<p>
There's a lot we didn't tell you, for example, how to set up DNS so that queries for intranet domains that aren't visible from the root of the domain hierarchy get relayed to servers within your enterprise. Read the <a href="#6.8.1.1">documents we recommended</a> for more information on DNS. 
</p>

<a name="6.9"></a>
<h2>6.9 - Setting up a PPTP connection in OpenBSD</h2>

<p>
<strong>NOTE:</strong> This does not apply to <strong>ALL</strong> ADSL providers, but much information can be gleaned from the setup here. This is known to work for <a href="http://www.inode.at">Inode</a>, an ADSL provider in Austria.
</p>

<p>
To start off, you need to install pptp. A port was added to the OpenBSD ports tree AFTER the release of OpenBSD 2.8 and works fine with with the OpenBSD 2.8 ports tree. The port is located at <i>/ports/net/pptp</i>. Read <a href="faq8.html#8.6">FAQ 8.6</a> for more information on the OpenBSD ports tree.
</p>

<p>
Because of a conflict between the In-Kernel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html">gre(4)</a> support and pptp, you will need to re-compile your kernel, removing support for gre(4).
</p>

<ul>Patch to remove GRE(4) support.
<pre>
Index: sys/conf/GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.66
diff -u -r1.66 GENERIC
--- sys/conf/GENERIC    2000/10/13 04:21:14     1.66
+++ sys/conf/GENERIC    2000/12/26 19:55:31
@@ -97,6 +97,6 @@
 pseudo-device  ksyms   1	# kernel symbols device
 pseudo-device  bridge  2	# network bridging support
 #pseudo-device vlan    2	# IEEE 802.1Q VLAN
-pseudo-device  gre     1	# GRE encapsulation interface
+#pseudo-device gre     1	# GRE encapsulation interface

 option		BOOT_CONFIG     # add support for boot -c
</pre></ul>

<p>
To recompile your kernel, check out OpenBSD 2.8-stable via cvs (refer to <a href="../stable.html">OpenBSD Stable</a> web page for more information), apply the following patch, and rebuild your kernel as per <a href="faq5.html#5.3">FAQ 5.3</a>.
</p>

<p>
After you have the <b>pptp</b> package installed and a new kernel, you need to edit a few files to setup for your connection. This packages uses the in-house OpenBSD 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html">ppp(8)</a>, so if you are familiar with ppp(8), much of the setup is the same. Also, refer to <a href="#6.5">FAQ 6.5</a>.
</p>

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
For the <i>/etc/ppp/options</i> file, a setup like below will most likely
do all that you need:
</p>

<ul><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></ul>

<p>
<tt>LOGINNAME</tt> should be replaced with your User-ID.
</p>

<p>
The <i>/etc/ppp/pap-secrets</i> a line like:

<ul><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></ul>

<p>
Where LOGINNAME is your User-ID and PASSWORD is your password. 10.0.0.138 is the IP assigned to your MODEM in the case that you are using ADSL, etc. Make sure this file stays readonly by root (mode 600).
</p>

<h3>6.9.1 - Assigning an address to your Network Interface</h3>

<p>
In the above example, our modem came with a preconfigured interface of 10.0.0.138. We now need to assign an address to OUR interface, It's best to pick an IP close to the one given by your MODEM, or use the static IP assigned to you. Read more about setting up interfaces in <a href="#6.1">FAQ 6.1</a>.
</p>

<p>
Once your interface is setup, you should be able to create a pptp connection with the command.

<ul><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &</strong>
</pre></ul>

<p>
Since this uses the in-house OpenBSD ppp(8), two processes are started. You can kill pptp by killing both these processes:
</p>

<ul><pre>
# <strong>kill -9 [pid of pppd]</strong>
% <strong>kill -9 [pid of pptp]</strong>
</pre></ul>

It is recommended to open <tt>/var/log/messages</tt> in a extra terminal window, to recognize possible problems.

<ul>
<pre>
# <strong>tail -f /var/log/message</strong>
</pre></ul>
</p>

<p>
We also suggest that you put the startup command in <i>/etc/rc.local</i> so that you automatically connect on reboot.
</p>

<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq5.html">[To Section 5.0 - Kernel configuration and Disk Setup]</a>
<a href= "faq7.html">[To Section 7.0 - Keyboard controls]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq6.html,v 1.112 2001/12/01 07:03:59 jcs Exp $</small>
</p>
</body>
</html>
