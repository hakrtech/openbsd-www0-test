<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Networking</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[To Section 5 - Building the System from Source</a>
<a href="faq7.html">[To Section 7 - Keyboard and Display Controls]</a>
</font>

<h1><font color="#e00000">6 - Networking</font></h1>
<hr>

<p>
<h3>Table of Contents</h3>
<ul>
<li><a href= "#Intro" >6.1 - Before we go any further</a>
<li><a href= "#Setup" >6.2 - Initial network setup</a>
<li><a href= "#PF"    >6.3 - How do I filter and firewall with OpenBSD?</a>
<li><a href= "#DHCP"  >6.4 - Dynamic Host Configuration Protocol</a>
<li><a href= "#PPP"   >6.5 - Point to Point Protocol</a>
<li><a href= "#Tuning">6.6 - Tuning networking parameters</a>
<li><a href= "#NFS"   >6.7 - Using NFS</a>
<li><a href= "#PPTP"  >6.8 - Setting up a PPTP connection in OpenBSD</a>
<li><a href= "#Bridge">6.9 - Setting up a bridge with OpenBSD</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Before we go any further</h2>

<p>
For the bulk of this document, it helps if you have read and
at least partially understood the <a href="faq5.html">Kernel
Configuration and Setup</a> section of the FAQ, and the
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> and
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> man pages.

<p>
If you are a network administrator, and you are setting up routing
protocols, if you are using your OpenBSD box as a router, if you need to
go in depth into IP networking, you really need to read
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">Understanding
IP Addressing</a>.
This is an excellent document.  "Understanding IP Addressing" contains
fundamental knowledge to build upon when working with IP networks,
especially when you deal with or are responsible for more than one
network.

<p>
If you are working with applications such as web servers, ftp servers,
and mail servers, you may benefit greatly by
<a href="http://www.rfc-editor.org/rfc.html">reading the RFCs</a>.
Most likely, you can't read all of them.  Pick some topics that you are
interested in, or that you use in your network environment.  Look them
up, find out how they are intended to work.  The RFCs define many
(thousands of) standards for protocols on the Internet and how they are
supposed to work.

<p>
<a name="Setup"></a>
<h2>6.2 - Initial Network Setup</h2>

<p>
<a name="Setup.1"></a>
<h3>6.2.1 - Identifying and Setting Up Your Network Interfaces</h3>

<p>
To start off, you must first identify your network interface.  In
OpenBSD, interfaces are named for the type of card, not for the type of
connection. You can see your network card get initialized during the
booting process, or after the booting process using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
command.  You also have the chance of seeing your network interface
using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> command.
For example, here is the output of dmesg for a Intel Fast Ethernet
network card, which uses the device name fxp.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
If you don't know what your device name is, please look at the
<a href="../plat.html">supported hardware list</a> for your platform.
You will find a list of many common card names and their OpenBSD device
names here.  Combine the short alphabetical device name (such as fxp)
with a number assigned by the kernel and you have an interface name
(such as fxp0).

<p>
You can find out what network interfaces have been identified by using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
utility. The following command will show all network interfaces on a
system.  This sample output shows us only one physical ethernet interface,
an <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.

<blockquote><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
As you can see here, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
gives us a lot more information than we need at this point. But, it
still allows us to see our interface. In the above example, the
interface card is already configured. This is obvious because an IP
network is already configured on fxp0, hence the values &quot;inet
10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;.  Also, the
<strong>UP</strong> and <strong>RUNNING</strong> flags are set.

<p>
Finally, you will notice several other interfaces come enabled by
default.  These are virtual interfaces that serve various functions.
The following manual pages describe them:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4&amp;manpath=OpenBSD+3.4">pflog</a>
 - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Point to Point Protocol
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
 - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Generic IPv4/IPv6 Tunnel Interface
</ul>

<p>
If you don't have your interface configured, the first step is to create
the <i>/etc/hostname.xxx</i> file, where the name of your interface will
take the place of xxx. From the information in the examples above, the
name would be <i>/etc/hostname.fxp0</i>. The layout of this file is
simple:<br>

<blockquote><pre>
address_family address netmask broadcast [other options]
</pre></blockquote>

(Much more detail about the format of this file can be found in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
man page.)

<p>
A typical interface configuration file, configured for an IPv4 address,
would look like this:

<blockquote><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
You could also specify media types for Ethernet, say, if you wanted to
force 100baseTX full-duplex mode.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Of course, you should never force full duplex mode unless both sides of
the connection are set to do this! In the absence of special needs,
media settings should be excluded.)

<p>
Or, you may want to use special flags specific to a certain interface.
The format of the hostname file doesn't change much!

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
The next step from here is to setup your default gateway. To do this,
simply put the IP of your gateway in the file <i>/etc/mygate</i>. This
will allow for your gateway to be set upon boot. From here you should
setup your nameservers, and your <i>/etc/hosts</i> file (see the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)</a>
man page). To setup your nameservers, you will create a file called
<i>/etc/resolv.conf</i>. You can read more about the format of this file
in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>
man page. But for a standard usage, here is an example. In this example
your domain servers are 125.2.3.4 and 125.2.3.5. You also belong in the
domain &quot;example.com&quot;.

<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
From here, you can either reboot or run the
<strong>/etc/netstart</strong> script. You can do this by simply typing
(as root):

<blockquote><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Notice that a few errors were produced.  By running this script, you are
reconfiguring things which are already configured.  As such, some routes
already exist in the kernel routing table.  From here your system should
be up and running. Again, you can check to make sure that your interface
was setup correctly with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
You can also check your routes via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>
or <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>.
If you are having routing problems, you may want to use the -n flag to
route(8) which prints the IP addresses rather than doing a DNS lookup
and displaying the hostname.  Here is an example of viewing your routing
tables using both programs.

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.2"></a>
<h3>6.2.2 - Setting up your OpenBSD box as a Gateway</h3>

<p>
This is the basic information you need to set up your OpenBSD box as a
gateway (also called a router). If you are using OpenBSD as a router on
the Internet, we suggest that you also read the Packet Filter setup
instructions below to block potentially malicious traffic. Also, due to
the low availability of
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a>
addresses from network service providers and regional registries, you
may want to look at Network Address Translation for information on
conserving your IP address space.

<p>
The GENERIC kernel already has the ability to allow IP Forwarding, but
needs to be turned on. You should do this using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
utility. To change this permanently you should edit the file 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>
to allow for IP Forwarding. To do so add this line in that configuration
file.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
To make this change without rebooting you would use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
utility directly. Remember though that this change will no longer exist
after a reboot, and needs to be run as root.

<blockquote><pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
Now modify the routes on the other hosts on both sides.  There are many
possible uses of OpenBSD as a router, using software such as
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>,
and <a href="http://www.zebra.org">zebra</a>.  OpenBSD has support in
the ports collection for zebra, gated and mrtd.  OpenBSD supports
several T1, HSSI, ATM, FDDI, Ethernet, and serial (PPP/SLIP) interfaces.

<p>
<a name="Setup.3"></a>
<h3>6.2.3 - Setting up aliases on an interface</h3>

<p>
OpenBSD has a simple mechanism for setting up ip aliases on an
interface. To do this simply edit the file
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>.
This file is read upon boot by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a>
script, which is part of the <a href="faq10.html#rc">rc startup
hierarchy</a>.  For the example, we assume that the user has an
interface <b>dc0</b> and is on the network 192.168.0.0. Other important
information:

<ul>
<li>IP for dc0 is 192.168.0.2
<li>NETMASK is 255.255.255.0
</ul>

<p>
A few side notes about aliases. In OpenBSD you use the interface name
only. There is no difference between the first alias and the second
alias. Unlike some other operating systems, OpenBSD doesn't refer to
them as dc0:0, dc0:1.  If you are referring to a specific aliased IP
address with ifconfig, or adding an alias, be sure to say "<tt>ifconfig
int alias</tt>" instead of just "<tt>ifconfig int</tt>" at the command
line.  You can delete aliases with "<tt>ifconfig int delete</tt>".

<p>
Assuming you are using multiple IP addresses which are in the same IP
subnet with aliases, your netmask setting for each alias becomes
255.255.255.255.  They do not need to follow the netmask of the first IP
bound to the interface.  In this example, <i>/etc/hostname.dc0</i>, two
aliases are added to the device dc0, which, by the way, was configured
as 192.168.0.2 netmask 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Once you've made this file, it just takes a reboot for it to take
effect. You can, however, bring up the aliases by hand using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
utility. To bring up the first alias you would use the command:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
To view these aliases you must use the command:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="NAT"></a>
<a name="PF"></a>
<h2>6.3 - How do I filter and firewall with OpenBSD?</h2>
Packet Filter (from here on referred to as PF) is OpenBSD's system for
filtering TCP/IP traffic and doing Network Address Translation. PF is
also capable of normalizing and conditioning TCP/IP traffic and
providing bandwidth control and packet prioritization, and can be used
to create powerful and flexible firewalls.
It is described in the <a href="pf/index.html"><b>PF User's
Guide</b></a>.


<p> 
<a name= "DHCP"></a>
<h2>6.4 - DHCP</h2> 

<p>
<h3>6.4.1 DHCP Client</h3>

<p>
To use the DHCP client
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
included with OpenBSD, edit <tt>/etc/hostname.xl0</tt> (this is assuming your
main ethernet interface is xl0.  Yours might be ep0 or fxp0 or something
else!) All you need to put in this hostname file is '<tt>dhcp</tt>'

<pre>
# <strong>echo dhcp &gt;/etc/hostname.xl0</strong>
</pre>

<p>
This will cause OpenBSD to automatically start the DHCP client on boot.
OpenBSD will gather its IP address, default gateway, and DNS servers
from the DHCP server.

<p>
If you want to start a dhcp client from the command line, make sure
/etc/dhclient.conf exists, then try:

<pre>
# <strong>dhclient fxp0</strong>
</pre>

<p>
Where fxp0 is the interface that you want to receive dhcp on.

<p>
No matter how you start the dhclient, you can edit the
/etc/dhclient.conf file to <b>not</b> update your DNS according to the
dhcp server's idea of DNS by first uncommenting the 'request' lines in
it (they are examples of the default settings, but you need to uncomment
them to override dhclient's defaults.)

<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>

<p>
and then <b>remove</b> domain-name-servers.  Of course, you may want to
remove hostname, or other settings too.

<p>
<h3>6.4.2 DHCP Server</h3>

<p>
If you want to use OpenBSD as a DHCP server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>,
edit <tt>/etc/rc.conf</tt>.  Set it up so that <tt>dhcpd_flags="-q"</tt>
instead of <tt>dhcpd_flags=NO</tt>.  Put the interfaces that you want
dhcpd to <b>listen</b> on in <tt>/etc/dhcpd.interfaces</tt>.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
Then, edit <tt>/etc/dhcpd.conf</tt>.
The options are pretty self-explanatory.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
This will tell your DHCP clients that the domain to append to DNS
requests is example.com (so, if the user types in 'telnet joe' then it
will send them to joe.example.com).  It will point them to DNS servers
192.168.1.3 and 192.168.1.5.  For hosts that are on the same network as
an ethernet interface on the OpenBSD machine, which is in the
192.168.1.0/24 range, it will assign them an IP address between
192.168.1.32 and 192.168.1.127.  It will set their default gateway as
192.168.1.1.

<p>
If you want to start dhcpd(8) from the command line, after editing
/etc/dhcpd.conf, try:

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd -q fxp0</b>
</pre>

<p>
The <tt>touch</tt> line is needed to create an empty
<tt>dhcpd.leases</tt> file before dhcpd(8) can start.
The OpenBSD <a href="faq10.html#rc">startup scripts</a> will create this
file if needed on boot, but if you are starting dhcpd(8) manually,
you must create it first.
<tt>fxp0</tt> is an interface that you want to start serving DHCP on.
The <tt>-q</tt> flag makes dhcpd(8) quiet; otherwise it is very noisy.

<p>
If you are serving DHCP to a Windows box, you may want dhcpd(8) to give
the client a 'WINS' server address.  To make this happen, just the
following line to your <tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(where <tt>192.168.92.55</tt> is the IP of your Windows or Samba
server.) See
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a>
for more options that your DHCP clients may want.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP </h2>

<p>
Point-to-Protocol is generally what is used to create a connection to
your ISP via your modem. OpenBSD has 2 ways of doing this.

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
 - Which is the kernel ppp daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - Which is the userland ppp daemon. 
</ul>

<p>
The first one we will cover will be the userland PPP daemon. To start
off you will need some simple information about your ISP. Here is a list
of helpful information that you will need.

<ul>
<li>Your ISP's dialup number
<li>Your nameserver 
<li>Your username and password
<li>Your gateway
</ul>

<p>
Some of these you can do without, but would be helpful in setting up
your ppp. The userland PPP daemon uses the file 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
as its configuration file. There are many helpful files in
<i>/etc/ppp</i> that can have different setups for many different
situations. You should take a browse though that directory.

<p>
Also, make sure, that if you're not using a GENERIC kernel, that you
have this line in your configuration file:

<blockquote><pre><strong>
pseudo-device   tun             2
</strong></pre></blockquote>

<p>
<h3>Initial Setup - for PPP(8)</h3>

<p>
Initial Setup for the userland PPP daemon consists of editing your
<i>/etc/ppp/ppp.conf</i> file. This file doesn't exist by default, but
there is a file <i>/etc/ppp/ppp.conf.sample</i> in which you can simply
edit to create your own <i>ppp.conf</i> file. Here I will start with the
simplist setup and probably most used setup.  Here is a quick
<i>ppp.conf</i> file that will simply connect to your ISP and set your
default routes and nameserver. With this file all the information you
need is your ISP's phone number and your username and password.

<blockquote>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</blockquote>

<p>
The section under the <tt>default:</tt> tag will get executed each time.
Here we setup all our critical information. Here with &quot;set
log&quot; we set our logging levels. This can be changed; refer to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
for more info on setting up logging levels. Our device gets set with
&quot;set device&quot;. This is the device that the modem is on. In this
example the modem is on com port 2. Therefore com port 1 would be
<i>/dev/cua00</i>. With &quot;set speed&quot; we set the speed of our
dialup connection and with &quot;set dial&quot; we set our dialup
parameters. With this we can change our timeout time, etc. This line
should stay pretty much as it is though.

<p>
Now we can move on and setup our information specific to our ISP. We do
this by adding another tag under our <b>default:</b> section. This tag
can be called anything you want, easiest to just use the name of your
ISP.  Here I will use <b>myisp:</b> as our tag referring to our ISP.
Here is a simple setup incorporating all we need to get ourselves
connected.

<blockquote>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
Here we have setup essential info for that specific ISP. The first
option &quot;set phone&quot; sets your ISP's dialup number. The
&quot;set login&quot; sets our login options. Here we have the timeout
set to 5; this means that we will abort our login attempt after 5
seconds if no carrier. Otherwise it will wait for &quot;login:&quot; to
be sent and send in your username and password. In this example our
Username = ppp and Password = ppp. These values will need to be changed.
The line &quot;set timeout&quot; sets the idle timeout for the entire
connection duration to 120 seconds. The &quot;set ifaddr&quot; line is a
little tricky. Here is a more extensive explanation.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
In the above line, we have it set in the format of &quot;<b>set ifaddr
[myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;. So the
first IP specified is what we want as our IP. If you have a static IP
address, you set it here. In our example we use /0 which says that no
bits of this ip address need to match and the whole thing can be
replaced. The second IP specified is what we expect as their IP. If you
know this you can specify it. Again in our line we don't know what will
be assigned, so we let them tell us. The third option is our netmask,
here set to 255.255.255.0.  If triggeraddr is specified, it is used in
place of myaddr in the initial IPCP negotiation.  However, only an
address in the myaddr range will be accepted.  This is useful when
negotiating with some PPP implementations that will not assign an IP
number unless their peer requests ``0.0.0.0''.

<p>
The next option used &quot;add default HISADDR&quot; sets our default
route to their IP. This is 'sticky', meaning that if their IP should
change, our route will automatically be updated. With &quot;enable
dns&quot; we are telling our ISP to authenticate our nameserver
addresses. Do NOT do this if you are running a local DNS, as ppp will
simply circumvent its use by entering some nameserver lines in
<i>/etc/resolv.conf</i>.

<p>
<h3>Using PPP(8)</h3>

<p>
Now that we have our <i>ppp.conf</i> file setup we can start trying to
make a connection to our ISP. I will detail some commonly used arguments
with ppp.

<ul>
<li><tt>ppp -auto myisp</tt> - This will run ppp, configure your
interfaces and connect to your ISP and then go into the background.
<li><tt>ppp -ddial myisp</tt> - This is similar to -auto, but if your
connection is dropped it will try and reconnect.
</ul>

<p>
By using <i>/usr/sbin/ppp</i> with no options will put you into
interactive mode. From here you can interact directly with the modem, it
is great for debugging problems in your <i>ppp.conf</i> file.

<p>
<h3>ppp(8) extras</h3>

<p>
In some situations you might want commands executed as your connection
is made or dropped. There are two files you can create for just these
situations. <i>/etc/ppp/ppp.linkup</i> and <i>/etc/ppp/ppp.linkdown</i>.
Sample configurations can be viewed here:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Extended information can be found at
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">FreeBSD 
Handbook entry on User PPP</a>. 


<p>
<a name="Tuning"></a>
<h2>6.6 - Tuning networking parameters</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - How can I tweak the kernel so that there are a higher number
of retries and longer timeouts for TCP sessions?</h3>

<p>
You would normally use this to allow for routing or connection problems.
Of course, for it to be most effective, both sides of the connection
need to use similar values.

<p>
To tweak this, use <tt>sysctl</tt> and increase the values of:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Using sysctl -a, you can see the current values of these (and many
other) parameters.  To change one, use <tt>sysctl -w</tt>, as in
<tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - How can I turn on directed broadcasts?</h3>

<p>
Normally, you don't want to do this.  This allows someone to send
traffic to the broadcast address(es) of your connected network(s) if you
are using your OpenBSD box as a router.

<p>
There are some instances, in closed networks, where this may be useful,
particularly when using older implementations of the NetBIOS protocol.
This is another sysctl.
<tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> turns this on.  Read
about <a href="http://www.netscan.org">smurf attacks</a> if you want to
know why it is off by default.

<p>
<h3>6.6.3 - I don't want the kernel to dynamically allocate a certain
port</h3>

<p>
There is a sysctl for this also.  From
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>:

<pre>
Set the list of reserved TCP ports that should not be allocated by the
kernel dynamically.  This can be used to keep daemons from stealing a
specific port that another program needs to function.  List elements may
be separated by commas and/or whitespace.

 #  <strong>sysctl -w  net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

It is also possible to add or remove ports from the current list.

 #  <strong>sysctl -w net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl -w net.inet.tcp.baddynamic=-871</strong>
</pre>


<p>
<a name="NFS"></a>
<h2>6.7 - Simple NFS usage</h2>

<p>
NFS, or Network File System, is used to share a filesystem over the
network. A few choice man pages to read before trying to setup a NFS
server are:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
</ul>

<p>
This section will go through the steps for a simple setup of NFS. This
example details a server on a LAN, with clients accessing NFS on the
LAN. It does not talk about securing NFS. We presume you have already
setup packet filtering or other firewalling protection, to prevent
outside access.  If you are allowing outside access to your NFS server,
and you have any kind of sensitive data stored on it, we strongly
recommend that you employ IPsec.  Otherwise, people can potentially see
your NFS traffic.  Someone could also pretend to be the IP address which
you are allowing into your NFS server.  There are several attacks that
can result.  When properly configured, IPsec protects against these
types of attacks.

<p>
Another important security note.  Don't just add a filesystem to
<i>/etc/exports</i> without some kind of list of allowed host(s).
Without a list of hosts which can mount a particular directory, anyone
on who can reach your host will be able to mount your NFS exports.

<p>
NFS depends upon
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
to be running before it will operate.  Portmap(8) is now off by
default on OpenBSD 3.2 and later, so you must enable it in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
by changing the <tt>portmap</tt> line to read:

<blockquote><pre>
portmap=YES
</pre></blockquote>
and reboot to make it take effect. 

<p>
The setup consists of a server with the ip <b>10.0.0.1</b>. This server
will be serving NFS only to clients within that network. The first step
to setting up NFS is to setup your <i>/etc/exports</i> file. This file
lists which filesystems you wish to have accessible via NFS and defines
who is able to access them. There are many options that you can use in
your <i>/etc/exports</i> file, and it is best that you read the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
man page. For this example we have an <i>/etc/exports</i> that looks
like this:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
This means that the local filesystem <tt>/work</tt> will be made
available via NFS. <tt>-alldirs</tt> specifies that clients will be able
to mount at any point under the <tt>/work</tt> mount point. <tt>-ro</tt>
specifies that it will only be allowed to be mounted read-only. The last
two arguments specify that only clients within the 10.0.0.0 network
using a netmask of 255.255.255.0 will be authorized to mount this
filesystem. This is important for some servers that are accessible by
different networks.

<p>
Once your <i>/etc/exports</i> file is setup, you can go ahead and setup
your NFS server. You should first make sure that options NFSSERVER &amp;
NFSCLIENT are in your kernel configuration. (GENERIC kernel has these
options included.) Next, you should set <tt>nfs_server=YES</tt> in
<i>/etc/rc.conf</i>. This will bring up both nfsd(8) and mountd(8) when
you reboot. Now, you can go ahead and start the daemons yourself. These
daemons need to be started as root, and you need to make sure that
portmap(8) is running on your system. Here is an example of starting
nfsd(8) which serves on both TCP and UDP using 4 daemons.  You should
set an appropriate number of NFS server daemons to handle the maximum
number of concurrent client requests that you want to service.

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Not only do you have to start the nfsd(8) server, but you need to start
mountd(8). This is the daemon that actually services the mount requests
on NFS. To start mountd(8), make sure an empty mountdtab file exists,
and run the daemon:

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<p>
If you make changes to /etc/exports while NFS is already running, you
need to make mountd aware of this!  Just HUP it:

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<p>
<h3>Checking Stats on NFS</h3>

<p>
From here, you can check to make sure that all these daemons are up and
registered with RPC. To do this, use rpcinfo(8).

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
During normal usage, there are a few other utilities that allow you to
see what is happening with NFS. One is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">showmount(8)</a>, 
which allows you to view what is currently mounted and who is mounting
it. There is also nfsstat(8) which shows much more verbose statistics.
To use showmount(8), try <tt>/usr/bin/showmount -a host</tt>. For
example:

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>Mounting NFS Filesystems</h3>

<p>
NFS filesystems should be mounted via mount(8), or more specifically,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
To mount a filesystem <i>/work</i> on host 10.0.0.1 to local filesystem
<i>/mnt</i>, do this (note that you don't need to use an IP address;
mount will resolve host names):

<blockquote><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
To have your system mount upon boot,
add something like this to your <i>/etc/fstab</i>:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
It is important that you use <tt>0 0</tt> at the end of this line so
that your computer does not try to fsck the NFS filesystem on boot!!!!
The other standard security options, such as noexec, nodev, and nosuid,
should also be used where applicable.  Such as:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
This way, no devices or setuid programs on the NFS server can subvert
security measures on the NFS client.  If you are not mounting programs
which you expect to run on the NFS client, add noexec to this list.

<p>
<a name="PPTP"></a>
<h2>6.8 - Setting up a PPTP connection in OpenBSD</h2>

<p>
<strong>NOTE:</strong> This does not apply to <strong>ALL</strong> ADSL
providers, but much information can be gleaned from the setup here. This
is known to work for <a href="http://www.inode.at">Inode</a>, an ADSL
provider in Austria.

<p>
To start off, you need to install pptp. The port is located at 
<i>/usr/ports/net/pptp</i>. Read <a href="faq8.html#Ports">FAQ 8, 
Ports</a> for more information on the OpenBSD ports tree.

<p>
Because of a conflict between the In-Kernel 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre(4)</a>
support and pptp, you will need to re-compile your kernel, removing
support for gre(4).

<blockquote>Patch to remove GRE(4) support.
<pre>
Index: GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.86
diff -u -r1.86 GENERIC
--- GENERIC     14 Mar 2002 00:42:25 -0000      1.86
+++ GENERIC     17 May 2002 01:52:17 -0000
@@ -87,7 +87,7 @@
 pseudo-device  enc     1       # option IPSEC needs the encapsulation interface
 pseudo-device  bridge  2       # network bridging support
 pseudo-device  vlan    2       # IEEE 802.1Q VLAN
-pseudo-device  gre     1       # GRE encapsulation interface
+#pseudo-device gre     1       # GRE encapsulation interface
 #pseudo-device strip   1       # Starmode Radio IP interface

 pseudo-device  pty     64      # pseudo-terminals
</pre></blockquote>

<p>
To recompile your kernel, check out OpenBSD source via cvs (refer to <a
href="../anoncvs.html">AnonCVS</a> web page for more information), apply
the following patch, and rebuild your kernel as per <a
href="faq5.html#Building">FAQ 5, Building a kernel</a>.

<p>
After you have the <b>pptp</b> package installed and a new kernel, you
need to edit a few files to setup for your connection. This packages
uses the in-house OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>,
so if you are familiar with ppp(8), much of the setup is the same. Also,
refer to <a href="#PPP">FAQ 6, PPP</a>.

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
For the <i>/etc/ppp/options</i> file, a setup like below will most likely
do all that you need:

<blockquote><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></blockquote>

<p>
<tt>LOGINNAME</tt> should be replaced with your User-ID.

<p>
The <i>/etc/ppp/pap-secrets</i> a line like:

<blockquote><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></blockquote>

<p>
Where LOGINNAME is your User-ID and PASSWORD is your password.
10.0.0.138 is the IP assigned to your MODEM in the case that you are
using ADSL, etc. Make sure this file stays readonly by root (mode 600).

<p>
<h3>6.8.1 - Assigning an address to your Network Interface</h3>

<p>
In the above example, our modem came with a preconfigured interface of
10.0.0.138. We now need to assign an address to OUR interface. It's best
to pick an IP close to the one given by your MODEM, or use the static IP
assigned to you. Read more about setting up interfaces in 
<a href="#Setup">FAQ 6, Setup</a>.

<p>
Once your interface is setup, you should be able to create a pptp
connection with the command:

<blockquote><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &amp;</strong>
</pre></blockquote>

<p>
Since this uses the in-house OpenBSD ppp(8), two processes are started.
You can kill pptp by killing both these processes:

<blockquote><pre>
# <strong>kill -9 [pid of pppd]</strong>
$ <strong>kill -9 [pid of pptp]</strong>
</pre></blockquote>

<p>
It is recommended to open <tt>/var/log/messages</tt> in a extra terminal
window, to recognize possible problems.

<blockquote>
<pre>
# <strong>tail -f /var/log/messages</strong>
</pre></blockquote>

<p>
We also suggest that you put the startup command in <i>/etc/rc.local</i>
so that you automatically connect on reboot.


<a name="Bridge"></a>
<h2>6.9 - Setting up a network bridge in OpenBSD</h2>

<p>
A <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
is a link between two or more separate networks.  Unlike a router, 
packets transfer through the bridge "invisibly" -- logically, the two
network segments appear to be one segment to nodes on either side of the
bridge.  The bridge will only forward packets that have to pass from one
segment to the other, so among other things, they provide an easy way to
reduce traffic in a complex network and yet allow any node to access any
other node when needed.

<p>
Note that because of this "invisible" nature, an interface in a  bridge
may or may not have an IP address of its own.  If it does, the interface
has effectively two modes of operation, one as part of a bridge, the
other as a normal, stand-alone NIC.  If neither interface has an IP
address, the bridge will pass network data, but will not be externally
maintainable (which can be a feature).

<p>
<h3>An example of a bridge application</h3>

<p>
One of my computer racks has a number of older systems, none of which
have a built-in 10BASE-TX NIC.  While they all have an AUI or AAUI
connector, my supply of transceivers is limited to coax.  One of the
machines on this rack is an OpenBSD-based terminal server which always
on and connected to the high-speed network.  Adding a second NIC with a
coax port will allow me to use this machine as a bridge to the coax
network.

<p>
This system has two NICs in it now, an Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
and a 3c590-Combo card 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
for the coax port.  <tt>fxp0</tt> is the link to the
rest of my network and will thus have an IP address, <tt>ep0</tt> is
going to be for bridging only and will have no IP address.
Machines attached to the coax segment will communicate as if they
were on the rest of my network.  So, how do we make this happen?

<p>
The file <tt>hostname.fxp0</tt> contains the configuration info for
the <tt>fxp0</tt> card.  This machine is set up using DHCP, so its file
looks like this:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

<p>
No surprises here.

<p>
The <tt>ep0</tt> card is a bit different, as you might guess:

<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

<p>
Here, we are instructing the system to activate this interface using 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
and set it to 10BASE-2 (coax).  No IP address or similar information
needs to be specified for this interface.  The options the <tt>ep</tt>
card accepts are detailed in its
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">man page</a>.

<p>
Now, we need to set up the bridge.  Bridges are initialized by the
existence of a file named something like 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
Here is an example for my situation here:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

<p>
This is saying set up a bridge consisting of the two NICs, fxp0 and ep0,
and activate it.  Does it matter which order the cards are listed?  No,
remember a bridge is very symmetrical -- packets flow in and out in both
directions.

<p>
That's it!  Reboot, and you now have a functioning bridge.

<p>
<h3>Filtering on a bridge</h3>

While there are certainly uses for a simple bridge like this, it is
likely you might want to DO something with the packets as they go
through your bridge.  As you might expect, <a href="#PF">Packet
Filter</a> can be used to restrict what traffic goes through your
bridge.

<p>
Keep in mind, by the nature of a bridge, the same data flows through
both interfaces, so you only need to filter on one interface.  Your
default "Pass all" statements would look something like this:

<blockquote>
<pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre>
</blockquote>

<p>
Now, let's say I wish to filter traffic hitting these old machines, I
want only Web and SSH traffic to reach them.  In this case, we are going
to let all traffic in and out of the ep0 interface, but filter on the
fxp0 interface, using keep state to handle the reply data:

<blockquote>
<pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

<p>
Note that this rule set will prevent anything but incoming HTTP and SSH
traffic  from reaching either the bridge machine or any of the other
nodes "behind" it.  Other results could be had by filtering the other
interface.

<p>
To monitor and control the bridge you have created, use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
command, which can also be used to create a bridge after boot.

<p>
<h3>Tips on bridging</h3>

<ul>
<li>It is HIGHLY recommended that you filter on only one interface.
While it is possible to filter on both, you really need to understand
this very well to do it right.

<li>By using the <i>blocknonip</i> option of 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
or in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">bridgename.bridge0</a>,
you can prevent non-IP traffic (such as IPX or NETBEUI) from slipping
around your filters.  This may be important in some situations, but you
should be aware that bridges work for all kinds of traffic, not just IP.

<li>Bridging requires that the NICs be in a "Promiscuous mode" -- they
listen to ALL network traffic, not just that directed at the interface.
This will put a higher load on the processor and bus than one might
expect.  Some NICs don't work properly in this mode, the TI ThunderLAN
chip
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
is an example of a chip that won't work as part of a bridge. 
</ul>


<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[To Section 5 - Building the System from Source]</a>
<a href="faq7.html">[To Section 7 - Keyboard and Display Controls]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../images/back.gif" border="0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq6.html,v 1.183 2004/01/15 23:54:26 nick Exp $</small>

</body>
</html>
