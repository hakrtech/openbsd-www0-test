<html>
<head>
<title>6.0 - Networking</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-1999 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<h2><font color=#e00000>6.0 - Networking</font><hr></h2>
</p>

<p>
<ul><h3>Table of Contents</h3>
<li><A href= "#6.0.1">6.0.1 - Before we go any further</a>
<li><a href= "#6.1">6.1 - Initial network setup</a>
<li><a href= "#6.2">6.2 - IP Filter</a>
<li><a href= "#6.3">6.3 - Network Address Translation</a>
<li><a href= "#6.4">6.4 - Dynamic Host Configuration Protocol</a>
<li><a href= "#6.5">6.5 - Point to Point Protocol</a>
<li><A href= "#6.6">6.6 - Tuning networking parameters</a>
</ul>
</p>
<hr>

<br>
<P>
<A name="6.0.1"></a>
<H2>6.0.1 - Before we go any further</h2>
<P>
For the bulk of this document, it helps if you have read and
at least partially understand the <A href="faq5.html">Kernel
Configuration and Setup</a> section of the FAQ, and the
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&apropos=0&sektion=8&format=html">
ifconfig(8)</a> and
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">
netstat(1)</a> man pages.
<P>
If you are a network administrator, and you are setting up routing
protocols, if you are using your OpenBSD box as a router, if you need to
go in depth into IP networking, you really need to read
<A HREF="http://www.3com.com/nsc/501302s.html">Understanding IP addressing</a>.
This is an excellent document.  Understanding IP addressing contains
fundamental knowledge to build upon when working with IP networks!
<P>
If you are working with applications such as web servers, ftp servers, and
mail servers, you may benefit greatly by <A HREF="http://www.nexor.com/info/rfc/index/rfc.htm?index/rfc.html">reading the RFCs</a>.
Of course, you can't all of them.  That's not easy to do (although
the IETF did it to evaluate the RFCs for year 2000 issues!)
Rather, pick some topics that you are interested in, or that you use in
your work.  Look them up, find out how they are intended to work.
The RFCs define many (thousands) of standards for protocols on the
internet and how they are supposed to work.


<p>
<a name= "6.1"></a>
<h2>6.1 - Initial Network Setup</h2>
</p>

<p>
<h3>Interfaces</h3>
</p>

<p>
Here we assume you have all your network interfaces working, and a basic
TCP/IP knowledge. 

<p>
All your interfaces should be listed with:

<ul>
<pre>
# <strong>ifconfig -a</strong>

lo0: flags=8009&lt;UP,LOOPBACK,MULTICAST&gt;
        inet 127.0.0.1 netmask 0xff000000
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt;
xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet 100baseTX half-duplex
        inet 10.1.1.1 netmask 0xffffff00 broadcast 10.1.1.255
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
        inet 10.1.1.1 netmask 0xffffff00 broadcast 10.1.1.255
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt;
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt;
tun0: flags=10&lt;POINTOPOINT&gt;
tun1: flags=10&lt;POINTOPOINT&gt;
enc0: flags=8&lt;LOOPBACK&gt;
</pre>
</ul>

<p>
First there is lo0 the loopback interface. It normally should be assigned address
of 127.0.0.1 no matter what the rest of your network looks like. The next important one is
xl0 in this example (could be ne<i>X</i>, ep<i>X</i>, or one of many other names,
depending on the chipset that your network card uses), which is
a board itself.
<P>In this example, xl0 it has UP and RUNNING flags on, along with le0.
That means that they are working (for the most part, anyways.) Your interface
could be down if you never configured it, and then it would look like the other interfaces.
Or, your interface could be up but incorrectly configured (wrong IP address
or wrong netmask) and thus won't work properly.
The other interfaces in this example are not part of this section, as sl and ppp are for serial line
comunication, tun is a pseudo-device for tunneling and enc a pseudo-device for
encryption.  They are covered later in this document.
</p>

<p>
If xl0 was uninitialized, you can assign it an address by creating an ascii
file, /etc/hostname.xl0, containing a string like this:
</p>

<ul>
<pre>
inet 10.1.1.1 255.255.255.0 NONE
</pre>
</ul>

<p>
In the above example we show <i>inet 10.1.1.1</i>, where the second
argument is our IP address. <i>255.255.255.0</i> is our netmask and
<i>NONE</i> shows no media tags. (full-duplex, etc).
</p>

<P>
In /etc/hosts we then put a hostname for ip address <i>10.1.1.1</i>:

<ul><pre>
10.1.1.1        mona    mona.openbsd.org.ar
</pre></ul>

<p>
Now check that you have a file /etc/myname and a file /etc/mygate. If you
don't have them, you need to create them. If your gateway is a machine
named "wintermute" which is also in the /etc/hosts, use these commands:
</p>

<ul>
<pre>
# echo "mona" > /etc/myname
# echo "wintermute" > /etc/mygate
</pre>
</ul>

<p>
Ok, you are done for a standalone system, but to activate your
configuration now (without rebooting) do:
</p>

<ul>
<pre>
# sh /etc/netstart
</pre>
</ul>

<p>
This will give you a few errors, but don't worry as all them are
concerning 127.0.0.x (loopback)
</p>

<p>
Note: if you want to use the system as a gateway, later there's a
"Firewall Setup" section, but you need to read all this first.
</p>

<p>
Now check your routes are ok (here we use -n to make it simpler to
look at):
</p>

<ul>
<pre>
# <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu
Interface
default            10.1.1.254         UGS         0        0      -  xl0
10.1.1/24          link#1             UC          0        0      -  xl0
10.1.1.1           127.0.0.1          UGHS        0        0      -  lo0
10.1.1.254         link#1             UHL         1        0      -  xl0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          3       24      -  lo0
224/8              link#1             UCS         0        0      -  xl0

Encap:
Source address/netmask          Port  Destination address/netmask     Port Proto SA(Address/SPI/Proto)
</pre>
</ul>

<p>
(The <tt>default</tt> gateway here is 10.1.1.254)
</p>

<p>
<h3>IP Aliasing</h3>
</p>

<p>
If you want to map more than one IP address on a single network interface,
you need to assign an "alias" to it. The way to do it on OpenBSD is
simply assigning the interface another IP with the "alias" option like
this:
</p>

<p>
<pre>
# ifconfig xl0 alias 10.1.1.2 netmask 255.255.255.255
</pre>
</p>

<p>
Here ne2 is assigned another IP number (remember it already has 10.1.1.1).
Note the netmask used! Don't use 255.255.255.0 in this kind of case (both
numbers are on the same subnet), only ONE address should handle the subnet.
If you do such kind of misconfiguration, the following error appears:
</p>

<p>
<pre>
ifconfig:SIOCAIFADDR: File exists
</pre>
</p>

<p>
Now let's change the configuration file for this, /etc/ifaliases. Add to
it this line:
</p>

<p>
<pre>
xl0   10.1.1.2 255.255.255.255
</pre>
This means, simply, interface <tt>xl0</tt> should have an alias <tt>10.1.1.2</tt> with the netmask <tt>255.255.255.255</tt>.
</p>


<p>
<h3>DNS Client Setup</h3>
</p>

<p>
Let's assume your DNS servers are 125.2.3.4 and 125.2.3.5, and your
machine name belongs to the domain yourdomain.com.  You should have the following
lines to your /etc/resolv.conf file:
</p>

<ul>
<pre>
domain yourdomain.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre>
</ul>

<p>
<h3>Gateway Setup</h3>
</p>

<p>
This is the basic information you need to set up your OpenBSD box as a gateway (also called a router.)  If you are using OpenBSD as a router on the Internet, we suggest that you also read the IP Filter setup instructions below
to block potentially malicious traffic.  Also, due to the low availability of IPv4 addresses from network service providers
and regional registries, you may want to look at Network Address Translation (next section of this document)
for information on conserving your IP address space.
</p>

<p>
If you want your OpenBSD machine to act as a dedicated router, and you
are building a custom kernel configuration for it, you can either compile
your kernel with options IPFORWARDING or GATEWAY.  (See <A HREF="faq11.html">section 11</a>
for further information on tuning NMBCLUSTERS if you are doing this.)  For the rest of us,
OpenBSD now has a sysctl mechanism to turn on and off IP Forwarding at boot.
If you want it to "forward" any packets between your interfaces, modify the /etc/sysctl.conf line that toggles
the forwarding variable on bootup:
</p>

<ul>
<pre>
net.inet.ip.forwarding=1
</pre>
</ul>

<p>
To make the changes without booting:
</p>

<ul>
<pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -> 1
</pre>
</ul>

<p>
Now modify the routes on the other hosts on both sides.  There are many possible uses of OpenBSD as a router, using software
such as <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&apropos=0&sektion=8&format=html">routed(8)</a>,
<A HREF="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>, and <A href="http://www.zebra.org">zebra</a>.
OpenBSD has support in the ports collection for both gated and mrtd.
OpenBSD supports several T1, HSSI, ATM, FDDI, Ethernet, and serial (PPP/SLIP) interfaces.
</p>

<p>
<a name= "6.2"></a>
<h2>6.2 - IP Filter</h2>
</p>
<p>
The IP Filter package was created to handle two tasks, dealing with
packet level forwarding permissions <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=8&format=html">ipf(8)</a> and mapping hosts/subnets to a range of
external addresses <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&apropos=0&sektion=8&format=html">ipnat(8)</a>. The configuration files for these two services are /etc/ipf.rules and
/etc/ipnat.rules.
</p>

<p>
You need to edit /etc/rc.conf to activate them at boot time. You also need to have 
net.inet.ip.forwarding=1 in your /etc/sysctl.conf (or your kernel needs to have IPFORWARDING
or GATEWAY options turned on.) You also need a kernel compiled with option
IPFILTER and IPFILTER_LOG (the GENERIC kernels do have these options).
</p>
<P>
If you have IP Filter compiled into your kernel, but you don't have 
it turned on in your /etc/rc.conf file, you can still activate it easily. 
<Pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</pre>
<P>
The <tt>-E</tt> flag on ipf 'enables' IP Filter.  <Tt>-Fa</tt> clears out any rules that you may have in there.  <tt>-f /etc/ipf.rules</tt> loads the rules from
/etc/ipf.rules.  
<p>
If you make changes to /etc/ipf.rules after ipf is loaded, you can reload your rules pretty easily!
<pre>
# ipf -Fa -f /etc/ipf.rules
</pre>
Same for ipnat...
<pre>
# ipnat -CF -f /etc/ipnat.rules
</pre>
This document will cover some basic ipf and ipnat configurations below.
There are a lot of nice examples in /usr/share/ipf/ for ipnat and ipf. We recommend
you choose the one closest to what you want, and modify it to fit your needs.  You can find other IP Filter information
at the IP Filter <A HREF="http://false.net/ipfilter/">mailing list archive</a>, the <A HREF="http://cheops.anu.edu.au/~avalon/ip-filter.html">IP Filter web site</a>, and finally the <A HREF="http://www.obfuscation.org/ipf/">IP Filter HOWTO</a>.
</p>

<p>
<h3>IPF</h3>
</p>

<p>
Modify rc.conf so it has IPFILTER=YES. The file /etc/ipf.rules has a
simple yet powerful syntax. Here we deal with the most common ways of usage,
for a more strict definition see <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ipf&apropos=0&sektion=5&format=html">ipf(5)</a>. Here is assumed xl0 as the
external interface to internet, on this one uses to have more rules than
internal interfaces.
</p>

<p>
Configurations usually start letting everything come and go, and then
apply the necessary rules to block offending packets. So this is first:
</p>

<p>
<pre>
pass out from any to any
pass in from any to any 
</pre>
</p>

<p>
Now let's block any incoming connection to port 82 tcp (eg. there's an
internal network report agent using http running on several hosts):
</p>

<p>
<pre>
block in on xl0 proto tcp from any to any port = 82
</pre>
</p>

<p>
This rule means:
</p>

<p>
"Block all incoming packets on xl0 interface whose protocol is TCP no
matter destination/origin using port 82"
</p>
<p>
If you want to log all rejected packets add "log" after "block in", or
"log quick" if you don't want it to send a message to every console root is
logged in.
</p>

<p>
Also, a typical rule is to block rpc portmap:
</p>

<p>
<pre>
block in log on xl0 proto udp from any to any port = sunrpc
</pre>
</p>

<p>
<a name="6.3"></a>
<h2>6.3 - IPNAT</h2>
</p>

<p>
Initial work done by Wayne Fergerstrom &lt;wayne@methadonia.net&gt;
</p>

<ul>
<li><a href="#nat1.0">6.3.1 Introduction</a>
	<ul>
	<li><a href="#nat1.1">6.3.1.1 Purpose</a>
	<li><a href="#nat1.2">6.3.1.2 Terminology</a>
	<li><a href="#nat1.3">6.3.1.3 Configuration</a>
	</ul>
<li><a href="#nat2.0">6.3.2 Network Address Translation</a>
	<ul>
	<li><a href="#nat2.1">6.3.2.1 Introduction to Network Address Translation</a>
	<li><a href="#nat2.2">6.3.2.2 Why to use Network Address Translation</a>
	<li><a href="#nat2.3">6.3.2.3 Setup</a>
	<li><a href="#nat2.4">6.3.2.4 Configuration</a>
	<li><a href="#nat2.5">6.3.2.5 Running</a>
	</ul>
<li><a href="#nat3.0">6.3.3 Network Address Translation Knowledge Base</a>
	<ul>
	<li><a href="#nat3.1">6.3.3.1 Checking NAT status</a>
	<li><a href="#nat3.2">6.3.3.2 Limitations of NAT (in FTP)</a>
	<li><a href="#nat3.3">6.3.3.3 Redirecting Traffic</a>
	<li><a href="#nat3.4">6.3.3.4 Network Address Translation versus Proxy</a>
	</ul>
<li><a href="#nat4.0">6.3.4 Links and X-References</a>
</ul>

<hr>

<a name="nat1.0"></a>
<h3><u>6.3.1 Introduction</u></h3>

<a name="nat1.1"></a>
<b>Purpose</b>
<p>
The purpose of this document is to explain and give and overview
of installing and configuring Network Address Translation ("NAT")
on an OpenBSD machine. This document is meant for users with a
beginning to intermediate level of knowledge in UNIX, TCP/IP, and
networking technologies. The user is assumed to have already set up
and configured an OpenBSD machine with two network cards (one
connected to the Internet and the other to the local network).
</p>

<p>
Based on <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, ipnat provides an easy way to
map internal networks to a single routeable ("real") internet address. This is very useful if you don't have
officially assigned addresses for every host on your internal network. When
you set up private/internal networks, you can take advantage of reserved
address blocks (assigned in <A HREF="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), such as:
<P>

10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>

</pre>
</p>

<a name="nat1.2"></a>
<b>Terminology</b>

<p>
The conventions used in this document are fairly straightforward.
For documentation purposes I will review some of the terms and format
for which this document adheres to.
</p>

<ul>
<strong>"NAT"</strong>
<p>
This describes the function of "Network Address Translation."
The process of NAT is described later in this document.
</p>
</ul>

<ul>
<strong>"ipnat"</strong>

<p>
This is short for "IP Network Address Translation." In-and-of
itself, it can be used interchangeably with NAT. However, in
this document the term "ipnat" will be used solely for
command-line only use.
</p>
</ul>

<ul>
<strong>"IPF"</strong>

<p>
This is short for "IP Filter." IP Filter is a portable packet filtering
software that is included as part of OpenBSD.   IP Filter must be enabled
before you can turn on ipnat.  This is easy, just edit /etc/rc.conf
and change ipf=NO to ipf=YES.  That only changes it for the boot up sequence,
you also need to do 'ipf -E' to turn on ipf while you are booted.  Of course,
this is described further, below.
</p>
</ul>

<br>
<a name="nat1.3"></a>
<b>Configuration</b>

<p>
This is how the computers are setup concerning this document. Your setup will vary from this, but 
the purpose of the document is to give you an overview so you can conform this information to your setup.
</p>

<ul>
<b>Computer Operating System: </b>OpenBSD v2.5 i386<br>
<br>
<b>NICs: </b>
<ul>
	NetGear 10/100MB <b>pn0</b><br>
	Connected to the EXTERNAL LAN (or WAN)<br>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<br>
	NetGear 10/100MB <b>pn1</b><br>
	Connected to the INTERNAL LAN<br>
	<b>IP Address: </b>192.168.1.1<br>
	<b>Netmask: </b>255.255.255.0<br>	
</ul>
<br>
<b>External, Internet-routeable IP (provided by ISP, in this example, a cable modem prodiver)<br></b>
<ul>
	<b>IP Address: </b>24.5.0.5<br>
	<b>Netmask: </b>255.255.255.0<br>
	<b>Gateway: </b>24.5.0.1<br>
</ul>
<br>
<b>Local Area Network</b><br>
<ul>
In this example,
machines on the LAN use the IP addressing scheme 192.168.1.xxx
(where xxx is a unique number). There are a variety of different
operating systems on the internal LAN including Windows 98,
Windows NT, OpenBSD and Linux. Each machine is connected to a hub
that is designated for internal use. For this document and its
examples the client on the LAN will assume IP address 192.168.1.40
</ul>
<br>
<b>Diagram of Configuration</b>
<ul><pre>
+-----+              +---------+         +----------+
| Hub |--------- pn1 |   NAT   | pn0 ----| Internet |
+-----+              +---------+         +----------+
  | |
  | +-- Client A
  +---- More clients 

                              +-------------------------+
                              |          LEGEND         |
                              +-------------------------+
                              |  NIC pn0 - 24.5.0.5     |
                              |  NIC pn1 - 192.168.1.1  |
                              | Client A - 192.168.1.40 |
                              +-------------------------+

</ul></pre>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Network Address Translation</u></h3>
<br>

<a name="nat2.1"></a>
<b>Introduction to NAT</b>

<p>
As more and more businesses and users get on the Internet, each one
must have an IP address. Public IP addresses are becoming harder and
harder to get. The solution for a lot of people has been Network
Address Translation (or "NAT"). NAT is a very simple, yet powerful way
to get your LAN connected to the Internet without having to purchase
or lease IP addresses for each machine. NAT is also known as "IP
Masquerading" if you're a Linux user.
</p>

<p>
When NAT is up and running correctly, it allows users on the internal
LAN to access the Internet through a different IP address (the one you
set up with your provider). Each machine on the LAN uses the one IP
address (transparently) of the one machine that is set up to use the
ISP assigned IP address.
</p>

<p>
The way NAT works is amazingly simple. When a client on the LAN
wants to connect to a machine on the Internet, it sends out a TCP
packet with a request to connect. Inside the TCP packet header is the
client's IP address (i.e. 192.168.1.40) and the requested host's IP
address (i.e. 123.45.67.89). The machine running NAT intercepts this
TCP packet and changes the client's IP address from 192.168.1.40 to
the IP address of the Internet-connected machine (i.e. 24.5.0.5). This
effectively tricks the host machine into thinking the actual connection
is from the NAT machine, not the actual client's machine. The host then
sends back responses to the NAT machine like it was the one connecting.
When the NAT machine receives the responses it quickly translates the
destination IP address back from itself to the client's machine and
sends the packet to the client. The client didn't have any idea of
what happened and spoofed Internet connectivity is totally transparent.
</p>

<p>
The example below shows NAT a little more clearly:
</p>

<ul><pre>
Client ----------------- pn1 [ NAT ] pn0 ---------- Internet Host
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.12.34.56 --- 123.45.67.89

OUTGOING TCP Packet                     OUTGOING TCP Packet
From: 192.168.1.40  >>=== NAT ===>>     From: 24.12.34.56
To: 123.45.67.89                        To: 123.45.67.89

INCOMING TCP Packet                     INCOMING TCP Packet
From: 123.45.67.89  <<=== NAT ===<<     From: 123.45.67.89
To:   192.168.1.40                      To: 24.12.34.56
</ul></pre>

<br>
<a name="nat2.2"></a>
<b>Why to use NAT</b>

<p>
When presented with a cable modem in my new apartment I was also
presented with another minor problem. How to get Internet access to
my roommates, when the cable modem resides in my room? There were a
few options I could implement ranging from obtaining extra IP
addresses, to setting up a proxy server, to setting up NAT.
(Don't let the cable modem example fool you.  NAT is powerful enough
to masquerade a large network with hundreds or even thousands of computers!)
</p>

<p>
There are many reasons why I wanted to set up NAT. The number one
reason is for saving money. There
are two roommates in my house (each with their own PC) and myself with
3 computers. My ISP only allows for three IP addresses per household.
This means that there weren't enough IPs to allow every machine
internet access.
</p>

<p>
By using NAT each machine will have a unique (internal) IP address
but share the one IP address given to me by my ISP. The cost goes down.
</p>

<br>
<a name="nat2.3"></a>
<b>Setup</b>

<p>
In order to enable NAT on your OpenBSD machine you will need to turn on
IPF and NAT. This is easily accomplished by editing the files listed
below (make the changes to the file so it looks like the options below):
</p>

<p>
<b>/etc/rc.conf</b> (this file used to start services at boot time)
</p>

<ul>
	ipfilter=YES<br>
	ipnat=YES
</ul>

<p>
<b>/etc/sysctl.conf</b>
</p>

<ul>
	net.inet.ip.forwarding=1
</ul>

<p>
After these changes are made, the machine is now ready to for the
configuration of NAT.
</p>

<br>
<a name="nat2.4"></a>
<b>Configuration</b>

<p>
The first step is to configure the IPF rules file (<i>/etc/ipf.rules</i>).
For the purposes of this document we will allow traffic to pass
through this firewall option without any interference. The file
should look like this:
</p>

<ul><pre>
pass in from any to any
pass out from any to any
</ul></pre>

<p>
Again for more information you can read <a href="#6.2">FAQ 6.2</a>
</p>

<p>
The NAT configuration file (<i>/etc/ipnat.rules</i>) has a very simple syntax.
For the configuration set forth above, the file should contain the
following entry:
</p>

<ul><pre>
map pn0 192.168.1.0/24 -> 24.5.0.5/32 portmap tcp/udp 10000:60000
map pn0 192.168.1.0/24 -> 24.5.0.5/32
</ul></pre>

<p>
Here is an explaination for the above lines.
</p>

<ul>
<strong>"map"</strong>
<p>
This is the command you are giving ipnat. It is telling ipnat
that this entry is an entry to change IP addresses between the LAN
and the Internet.
</p>
</ul>

<ul>
<strong>"pn0"</strong>
<p>
This is the network interface that is connected to the Internet.
</p>
</ul>

<ul>
<b>"192.168.1.0/24"</b>
<p>
the IP address and netmask (the netmask is in
CIDR format). Combined they state "any IP address of value
192.168.1.1 through 192.168.1.254" should be mapped. If you would
prefer not to use CIDR notation you can substitute "/24" for
"/255.255.255.0".
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
This IP address and netmask state the IP address
that the LAN IP addresses will be mapped to.  /32 means one single
IP address.  You can also map to a /24, or 256 IP addresses (or a /27,
or whatever number of bits you'd like)!! This is
useful if you have several thousand client machines behind your NAT....
(Of course, this is only useful if that /24 is being routed to your OpenBSD
box!)
</p>
</ul>

<ul>
<b>"portmap tcp/udp 10000:60000"</b>
<p>
This maps all tcp/udp packets
to ports in the range of 10000 to 60000.
</p>
</ul>

<p>
The second line has almost the same entry except for the last portion.
This tells ipnat to map anything else (not tcp/udp, those packets are already
matched by the first line) to whatever port
it requests (used for ICMP, and other protcols). Once this
is in the file, all that's needed is to run the IPF daemon.
</p>

<br>

<a name="nat2.5"></a>
<b>Running</b>

<p>
Executing NAT is a very simple process also. Once the configuration is
complete, there are two ways to enable NAT. The first (and best way if
possible-to test the setup stage) is to reboot your OpenBSD machine.
This is accomplished with the command "<i>reboot</i>"
</p>

<p>
If you would like to run ipnat from the command line, use the following
commands:
</p>

<ul><pre>
# ipf -Fa -f /etc/ipf.rules -E
# ipnat -CF -f /etc/ipnat.rules
</ul></pre>

<p>
The first line is to enable IPF (remember that NAT piggy-backs on IPF
therefore IPF must be initialized and running before NAT can be loaded).
The options on the command line "-Fa" clear out any existing entries
already in effect. "-f /etc/ipf.rules" tells ipf where the rules file
can be found. "-E" is the switch to enable the IPF daemon.
</p>

<p>
The second command line is to enable NAT. "-CF" clears and flushes all

existing entries in the NAT table. "-f /etc/ipnat.rules" tells NAT where

the NAT rules file is at. NAT is now running. It's as simple as that.
</p>


<p>
<b>Note:</b> in order to reload the NAT settings (in case you edit the file
but don't want to reboot) just execute the 2nd command over again. The
settings will be flushed and reloaded.
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 Nat Knowledge Base</u></h3>

<br>
<a name="nat3.1"></a>
<b>Checking NAT Status</b>

<p>
To find out how NAT is doing or make sure the settings have taken
effect, you use the "-l" option. This option will list all the
settings and current sessions that ipnat is running:
</p>

<ul><pre>
# <b>ipnat -l</b>
map pn0 192.168.1.0/24 -> 24.5.0.5/32 portmap tcp/udp 10000:60000
map pn0 192.168.1.0/24 -> 24.5.0.5/32

List of active sessions:
MAP 192.168.1.40  2473  <- -> 24.5.0.5  13463 [129.128.5.191 80]
</ul></pre>

<p>
The purpose of the first two lines is to confirm the settings that
were entered in /etc/ipnat.rules earlier. The line(s) below will show
you a list of the current NAT controlled connections.
</p>

<ul>
<b>"MAP 192.168.1.40  2473"</b>
<p>
This tells you the IP address of the
machine on the LAN that is using NAT. The port number used to make
the connection is displayed afterwards.
</p>
</ul>

<ul>
<b>"&lt;- -&gt;"</b>
<p>
This shows that NAT is handling the flow of traffic
in both directions.
</p>
</ul>

<ul>
<b>"24.5.0.5  13463"</b>
<p>
This denotes that the connection is going
to the Internet via IP address 24.5.0.5 and using port 13463.
</p>
</ul>

<ul>
<b>"129.128.5.191 80"</b>
<p>
The IP address and the port being connected
to are listed last.
</p>
</ul>

<a name="nat3.2"></a>
<b> Limitations of NAT (in FTP)</b>

<p>
There are a few limitations of NAT. One is with FTP. When a user connects
to a remote FTP server and requests information or file, the FTP server
will make a connection to the client and transfer the info. This is done
on a random free port. This is a problem for users attempting to gain
access to FTP servers from within the LAN. When the FTP server sends its
information it sends it to the external NIC at a random port. The NAT
machine will receive this, but because it has no mappings for the unknown
packet and doesn't have any mappings for that port, it will drop the
packet and won't deliver it.

<p>
The solution to this is to place yourself in "passive mode" in your
FTP client. This will tell the server that you want to connect to the
server, and not what you just read. Then when you make that connection out
NAT will correctly handle your connection.
<P>
IP Filter provides another solution for this situation,
that is, an ftp proxy which is built-in to the NAT code.
To activate it, put something like this before your other NAT mappings.
<PRE>
map pn0 192.168.1.0/24 -> 24.5.0.5/32 proxy port ftp ftp/tcp
</pre>
With this in place, the kernel will watch your FTP connections
for the "PORT" command coming from the ftp client, and it will
replace the IP address and port with it's own outside IP address, and a port
of its own choosing.  Then it will open up that port and tunnel the
data to the port your ftp client asked for.  Obviously, this is slightly
more resource intensive.  But, unless your NAT/IP Filter box is reaching
critical mass, you should be fine.
<P>


<br>
<a name="nat3.3"></a>
<b>Redirecting Traffic</b>

<p>
        At times you may need to redirect incoming or outgoing traffic for
        a certain protocol or port. A good example of this is if there were a
        server residing inside the LAN running a web server. Incoming connections
        to your valid Internet IP will find that unless your NAT box is running
        a web server, no connection can be made. For this purpose we use the
        NAT 'rdr' directive in the rules file to instruct where to redirect
        (or route) a particular connection to.
</p>

<p>

        For our example, lets say a web server resides on the LAN with IP address
        of 192.168.1.80. The NAT rules file needs a new directive to handle this.
        Add a line similar to the following one to your ipnat.conf:
</p>

<ul><pre>
rdr pn0 24.5.0.5/32 port 80 -> 192.168.1.80 port 80
</ul></pre>

<p>
The reason for each line is this:
</p>

<ul>
<b>"rdr"</b>
<p>
This is the command you are giving ipnat. It is telling ipnat
that this entry is an entry to redirect a connection. 
</p>
</ul>


<ul>
<b>"pn0"</b>
<p>
This is the network interface that is connected to the Internet.
</p>
</ul>

<ul>
<b>"24.5.0.5/32"</b>
<p>
This means an incoming connection to this IP address (only on pn0, as above)
</p>
</ul>

<ul>
<b>"port 80"</b>
<p>
This is the port (80) that should be redirected. The number
"80" didn't have to be used. You can use "port www" also to specify
a redirection of port 80. If you would like to use a name instead of
a number, the service name and corresponding port, must exist in the
file /etc/services.
</p>
</ul>

<ul>
<b>"192.168.1.80"</b>
<p>
The IP address and netmask of the LAN machine
which the packets are redirected to. The netmask is always "/32"
(and therefore not needed to be specified) so
the packets can be redirected to a particular machine.
</p>
</ul>

<p>
When the addition is complete reload the NAT rules, and the redirection
will start immediately.
</p>

<br>
<a name="nat3.4"></a>
<b>NAT versus Proxy</b>

<p>
The difference between NAT and an application-based proxy is that the proxy
software acts as a middle-man between the Internet and the machines connected
on the LAN. This is fine, however each application you want to run on
your machine and connect to the Internet through the proxy server MUST
be proxy-aware (be able to use a proxy server). Not all applications are
able to do this (especially games). Furthermore, there simply are not
proxy server applications for all of the Internet services out there.
NAT transparently maps
your internal network so that it may connect to the Internet.  The only
security advantage to using a proxy software over NAT is that the proxy
software may have been made security aware, and can filter based on content,
to keep your Windows machine from getting a macro virus, it can protect
against buffer overflows to your client software, and more.  To maintain
these filters is often a high-maintenance job.
</p>

<a name="nat4.0"></a>
<b>6.3.4 Links and X-References</b>

<p>
OpenBSD files:
<ul>
<li>/etc/ipnat.rules - NAT rules file
<li>/etc/rc.conf - need to edit to start up ipnat and ipf at boot time
<li>/etc/sysctl.conf - need to edit to enable IP forwarding
<li>/usr/share/ipf/nat.1 - samples of ipnat.rules
</ul>
</p>

<p>
NAT Internet Links:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8">http://www.openbsd.org/cgi-bin/man.cgi?query=ipnat&sektion=8</a>
<li><a href="http://coombs.anu.edu.au/ipfilter/">http://coombs.anu.edu.au/ipfilter/</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>

<p> 
<a name= "6.4"></a> <h2>6.4 - DHCP</h2> </p>


<p>To use the DHCP client <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&apropos=0&sektion=8&format=html">dhclient(8)</a>
included with OpenBSD, edit /etc/hostname.xl0
(this is assuming your main ethernet interface is xl0.  Yours might be ep0 or fxp0 or something else!)
All you need to put in this hostname file is 'dhcp'
<pre>
# echo dhcp >/etc/hostname.xl0
</pre>
This will cause OpenBSD to automatically start the DHCP client on boot.  OpenBSD will gather its IP address,
default gateway, and DNS servers from the DHCP server.  
<p>
If you want to use OpenBSD as a DHCP server <A href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&apropos=0&sektion=8&format=html">dhcpd(8)</a>,
edit /etc/rc.conf.  Set it up so that dhcpd_flags="-q" instead of dhcpd_flags=NO.
Put the interfaces that you want dhcpd to *listen* on in /etc/dhcpd.interfaces.
<pre>
# <strong>echo xl1 xl2 xl3 >/etc/dhcpd.interfaces</strong>
</pre>
Then, edit /etc/dhcpd.conf.
The options are pretty self explanatory.
<pre>
        option  domain-name "xyz.mil";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>
<p>
This will tell your dhcp clients that the domain to append to DNS requests is xyz.mil (so, if the user types in 'telnet joe' then it will
send them to joe.xyz.mil).  It will point them to DNS servers 192.168.1.3 and 192.168.1.5.  For hosts that are on the same network as
an ethernet interface on the OpenBSD machine, which is in the 192.168.1.0/24 range, it will assign them an IP address between
192.168.1.32 and 192.168.1.127.  It will set their default gateway as 192.168.1.1.
<p>
If you want to start dhcpd from the command line, after editing /etc/dhcpd.conf,
try:
<PRE>
# dhcpd -q fxp0
</PRE>
Where fxp0 is an interface that you want to start serving dhcp on.
The -q flag makes dhcp quiet, otherwise it is very noisy.
<P>
If you want to start a dhcp client from the command line, make sure
/etc/dhclient.conf exists, then try:
<PRE>
# dhclient fxp0
</pre>
Where fxp0 is an interface that you want to receive dhcp on.  You can edit
the /etc/dhclient.conf file to not update your DNS according to the dhcp
server's idea of DNS by uncommenting the 'requre' lines in it
<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>
and then remove domain-name-servers.  Of course, you may want to remove
hostname, or other settings too.
<P>
The DHCP client can be turned on at boot time by editing /etc/hostname.fxp0
(again, where fxp0 is the interface you want dhcp to listen on) and make
it say 'dhcp' (with nothing else!!)
<pre>
# echo dhcp >/etc/hostname.fxp0
</pre>
<br>

<p>
<a name= "6.5"></a>
<h2>6.5 - PPP </h2>
</p>

Point-to-Protocol is generally what is used to create a connection to your ISP via your modem. OpenBSD has 2 ways of doing this. 

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8&format=html">pppd(8)</a> - Which is
the kernel ppp daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> - Which is
the userland ppp daemon. 
</ul>

<p>
The first one we will cover will be the userland PPP daemon. To start off you will need some simple
information about your isp. Here is a list of helpful information that you will need.
</p>

<ul>
<li>Your ISP's dialup number
<li>Your nameserver 
<li>Your username and password.
<li>Your gateway
</ul>

<p>
Some of these you can do without, but would be helpful in setting up your ppp. The userland PPP daemon uses
the file <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> as
its configuration file. There are many helpful files in <b>/etc/ppp</b> that can have different setups for
many different situations. You should take a browse though that directory.
</p>

<p>
Also, make sure, that if your not using a GENERIC kernel, that you have this line in your configuration file:
</p>

<ul><pre><strong>
pseudo-device   tun             2
</pre></ul></strong>


<h3>Initial Setup - for PPP(8)</h3>

<p>
Initial Setup for the userland PPP daemon consists of editing your <b>/etc/ppp/ppp.conf</b> file. This file
doesn't exist by default, but there is a file <b>/etc/ppp/ppp.conf.sample</b> in which you can simply edit to
create your own <b>ppp.conf</b> file. Here I will start with the simplist setup and probobly most used setup.
Here is a quick <b>ppp.conf</b> file that will simply connect to your ISP and set your default routes and
nameserver. With this file all the information you need is your ISP's phone number and your username and
password.
</p>

<ul>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</ul>

<p>
The section under the <b>default:</b> tag will get executed each time. Here we setup all our critical
information. Here with &quot;set log&quot; we set our logging levels. This can be changed, refer to 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8&format=html">ppp(8)</a> for more info on
setting up logging levels. Our device gets set with &quot;set device&quot;. This is the device that the modem
is on. In this example the modem is on com port 2. Therefore com port 1 would be /dev/cua00. With &quot;set
speed&quot; we set the speed of our dialup connection and with &quot;set dial&quot; we set our dialup
parameters. With this we can change our timeout time, etc. This line should stay pretty much as it is though.
</p>

<p>
Now we can move on and setup our information specific to our ISP. We do this by adding another tag under our
<b>default:</b> section. This tag can be called anything you want, easiest to just use the name of your ISP.
Here I will use <b>myisp:</b> as our tag refering to our ISP. Here is a simple setup incorporating all we need
to get ourselves connected.
<p>

<ul>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</ul>

<p>
Here we have setup essential info for that specific ISP. The first option &quot;set phone&quot; sets your
ISP's dialup number. The &quot;set login&quot; sets our login options. Here we have the timeout set to 5, this
means that we will abort our login attempt after 5 seconds if no carrier. Otherwise it will wait for
&quot;login:&quot; to be sent and send in your username and password. In this example our Username = ppp and
Password = ppp. These values will need to be changed. The line &quot;set timeout&quot; sets the timeout for
the entire login process to 120 seconds. The &quot;set ifaddr&quot; line is a little tricky. Here is a more
extensive explaination.
</p>

<ul><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</ul></pre>

<p>
In the above line, we have it set in the format of &quot;<b>set ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask
[triggeraddr]]]]</b>&quot;. So the first IP specified is what we want as our IP. If you have a static IP address, you set it here. In our example we use /0
which says that no bits of this ip address need to match and the whole thing can be replaced. The second IP
specified is what we expect as their IP. If you know this you can specify it. Again in our line we don't know
what will be assigned, so we let them tell us. The third option is our netmask, here set to 255.255.255.0.If
triggeraddr is specified, it is used in place of myaddr in the initial IPCP negotiation.  However, only an
address in the myaddr range will be accepted.  This is useful when negotiating with some PPP implementations
that will not assign an IP number unless their peer requests ``0.0.0.0''.
</p>

<p>
The next option used &quot;add default HISADDR&quot; sets our default route to their IP. This is 'sticky',
meaning that if their IP should change, our route will automatically be updated. With &quot;enable dns&quot;
we are telling our ISP to authenticate our nameserver addresses. Do NOT do this if you are running an local
DNS, as ppp will simply circumvent its use by entering some nameserver lines in /etc/resolv.conf.
</p>

<h3>Using PPP(8)</h3>

<p>
Now that we have our <b>ppp.conf</b> file setup we can start trying to make a connection to our ISP. I will
detail some commonly used arguments with ppp.
</p>

<ul>
<li><b>ppp -auto myisp</b> - This will run ppp, configure your interfaces and connect to your isp and then go
into the background.
<li><b>ppp -ddial myisp</b> - This is similar to -auto, but if your connection is dropped it will try and
reconnect.
</ul>

<p>
By using <b>/usr/sbin/ppp</b> with no options will put you into interactive mode. From here you can interact
directly with the modem, it is great for debugging problems in your <b>ppp.conf</b> file.
</p>

<h3>ppp(8) extra's</h3>

<p>
In some situations you might want commands executed as your connection is
made or dropped. There are two files you can create for just these
situations. <b>/etc/ppp/ppp.linkup</b> and <b>/etc/ppp/ppp.linkdown</b>.
Sample configurations can be viewed here:
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
<a name= "6.6"></a>
<h2>6.6 - Tuning networking parameters</h2>

<H3>6.6.1 - How can I tweak the kernel so that there are a higher number of retries and longer timeouts for TCP sessions?</h3>
You would normally use this to allow for routing or connection problems.
Of course, for it to be most effective, both sides of the connection
need to use similar values.
<P>
To tweak this, use <tt>sysctl</tt> and increase the values of:
<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>
Using sysctl -a, you can see the current values of these (and many other)
parameters.  To change one, use <tt>sysctl -w</tt>, as in <tt>sysctl -w
net.inet.tcp.keepidle=28800</tt>.  
<h3>6.6.2 - How can I turn on directed broadcasts?</h3>
Normally, you don't want to do this.  This allows someone to send
traffic to the broadcast address(es) of your connected network(s) if you
are using your OpenBSD box as a router.<P>
There are some instances, in closed networks, where this may be useful,
particularly when using older implementations of the NetBIOS protocol.
This is another sysctl.  <Tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> 
turns this on.  Read about <A HREF="http://www.netscan.org">smurf attacks</a>
if you want to know why it is off by default.
<H3>6.6.3 - I don't want to the kernel to dynamically allocate a certain port</h3>
There is a sysctl for this also.  From <A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:
<PRE>
Set the list of reserved TCP ports that should not be allocated by the
kernel dynamically.  This can be used to keep daemons from stealing a
specific port that another program needs to function.  List elements may
be separated by commas and/or whitespace.

   sysctl -w net.inet.tcp.baddynamic=749,750,751,760,761,871

It is also possible to add or remove ports from the current list.

   sysctl -w net.inet.tcp.baddynamic=+748
   sysctl -w net.inet.tcp.baddynamic=-871
</pre>

<P>
<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "faq5.html">[To Section 5.0 - Kernel configuration and Disk Setup]</a>
<a href= "faq7.html">[To Section 7.0 - Keyboard controls]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq6.html,v 1.35 1999/10/07 16:39:41 chris Exp $</small>
</p>
</body>
</html>
