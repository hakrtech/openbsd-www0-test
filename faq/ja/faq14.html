<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Disk Setup</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "faq12.html">[12 章 - プラットフォーム固有の質問]</a>
</font>

<h1><font color="#e00000">14 - ディスクの設定</font></h1><hr>

<h3>目次</h3>
<ul>
<li><a href="#disklabel"  >14.1 - OpenBSD の disklabel(8) を使用する</a>
<li><a href="#fdisk"      >14.2 - OpenBSD の fdisk(8) を使用する</a>
<li><a href="#NewDisk"    >14.3 - OpenBSD でディスクを追加する</a>
<li><a href="#SwapFile"   >14.4 - ファイルへのスワップ</a>
<li><a href="#SoftUpdates">14.5 - Soft updates</a>
<li><a href="#Boot386"    >14.6 - OpenBSD/i386 はどのようにブートするの ?</a>
<li><a href="#LargeDrive" >14.7 - OpenBSD での大容量ドライブは
    どうなってるのでしょう ?</a>
<li><a href="#InstBoot"   >14.8 - Bootblock のインストール - i386 のみ</a>
<li><a href="#Backup"     >14.9 - トラブルに備えよう: テープへの
    バックアップと復元</a>
<li><a href="#MountImage" >14.10 - OpenBSD でディスクイメージをマウント</a>
<li><a href="#pciideErr"  >14.11 - 助けて!  PCIIDE でエラーになってしまいます !</a>
<li><a href="#RAID"       >14.13 - OpenBSD の RAID オプション</a>
</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - OpenBSD の disklabel(8) を使用する</h2>
<h3>目次</h3>

<ul>
<li><a href="#disklabel.1">disklabel(8) とは ?</a></li>
<li><a href="#disklabel.2">OpenBSD インストール時の disklabel(8)</a></li>
<li><a href="#disklabel.3">よくある disklabel(8) の使い方</a></li>
</ul>


<a name="disklabel.1"></a>
<h3>disklabel(8) とは ?</h3>
  
<p>
まず、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
にあるマニュアルをお読みください。

<p>
Disklabel は、ディスクとカーネル内のディスクドライバの間に、
効率よいインターフェースを提供するために作成されたものです。
ラベルには、ドライブのジオメトリとか、ファイルシステム情報とか、
ディスク関係の情報が含まれています。そしてこれをブートストラップ・プログラムが
使用して、ドライブをロードしたり、ドライブ上のどこにファイルシステムが
あるのかを調べたりします。ラベルはまた、ファイルシステムといっしょに
使用されて、効率よい環境が作られます。disklabel についてのより
詳しいことは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>
を参照してください。

<p>
さらなるメリットとして、disklabel を使うことでディスクパーティションの
アーキテクチャ的な制約を乗り越えられるのです。たとえば i386 では
プライマリパーティション (つまり Windows NT や DOS など他の OS に見える
パーティション) は 4 つまでしか持てません。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
では、この「プライマリパーティション」をひとつ使用するだけで、OpenBSD パーティション
を全部 (たとえば 'swap', '/', '/usr', '/var') をそこに納められます。
それでも他の OS で使えるパーティションが 3 つも残っているのです !

<a name="disklabel.2"></a>
<h3>OpenBSD インストール時の disklabel(8)</h3>

<p>
OpenBSD インストールでの大きな山場のひとつが、ラベルを最初に作成する
ところでしょう。これは (i386 ユーザなら) <a href="#fdisk">fdisk(1)</a>
の直後に出てきます。インストール中に、disklabel を使って、
マウントポイントごとに別々のラベルを作成します。
インストール中に、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
の中からマウントポイントを指定することもできますが、これはどうしても
必要というわけではありません。というのは、後ほどプロンプトで、
これでいいかどうかの確認を求められますからです。しかし、
これは実行しておいた方がインストールが少しはスムーズになることでしょう。

<p>
インストール中なら、まだラベルはぜんぜんないはずですので、
どうしても作成する必要があります。最初に作成するラベルはラベル
'a' です。このラベルは絶対に / をマウントするところにすべきです。
作成しておいた方が良い、お勧めパーティションとそのサイズについては、
<a href="../faq4.html#SpaceNeeded">FAQ 4, 必要なスペース</a>
を参照してください。サーバの場合、少なくともここに書いてあるラベルは
別々にしておくのが望ましいでしょう。デスクトップのユーザなら、
/ のマウントポイントだけを作成しておけば十分でしょう。最初に
root パーティション ('a' ラベル) を作るとき、スワップラベル用に
多少の空きを残しておくのをお忘れなく。これまでに基本は
説明しましたから、以下にインストール中に disklabel を使う例を挙げてみましょう。
最初の例では、このマシン上には OpenBSD しか
なく、フルインストールをするものとします。

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
これで、64MB の root パーティションが / にマウントされて、64MB の
スワップパーティションが作られました。オフセットがセクター 63 から
始まるのに注目してください。しかし、これで良いのです。
サイズの話という点で、disklabel はセクター単位で表示を行いますが、
入力は特にセクターで入力しなくても構いません。上記の例でもそうですが、
<i>64MB なら 64M</i> とか、<i>2GBなら 2G</i> とすれば良いのです。
すると Disklabel はそれをいちばん近いシリンダに丸めてくれます。
また上記の例では、disklabel は「b」がスワップであると自動的に
想定していることにも注目してください。これは正しい想定で、GENERIC
カーネルはラベル「b」にスワップを探しにいくよう設定されているのです。
ですから、このガイドラインに従って、スワップは 'b' にしておきましょう。

<p>
次の例では、もうふたつラベルを作成しています。これはつまり、完全な
インストールではないということです。これらのサイズは、OpenBSD を
完全にインストールするには不十分だからです。繰り返しになるだけですので、
パーティションをすべて作成する作業を見せるのは省略します。

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
上記の例では、ふたつほど気付く点があります。まず、オフセットが
自動的に計算され、次のところでデフォルトになって待っているということです。
このようなインストールをするなら、オフセットをあれこれと変更する
必要はまったくありません。別の違いとしては、ラベル 'c' はスキップ
されています。これには理由があり、ラベル 'c' はディスク全体を
表わすラベルだからなのです。ですから、ラベル 'c' だけは絶対に
変更してはいけません。

<p>
ラベルが全部できたら、後はそれをディスクに書き込んでインストールを
先に進めましょう。全部書いて disklabel を終了するには
(そしてインストールを続けるには)、次のようにします。


<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>>

<p>

<a name="disklabel.3"></a>
<h3>よくある disklabel(8) の使い方</h3>

<p>
いったんシステムのインストールが終わったら、もうあまり disklabel を
使うこともないでしょう。しかし、ディスクを追加、削除、再構成するときなど、
disklabel を使う場合が出てきます。まず最初にやるべきことは、現状の
disklabel を見ることです。これには以下のようにします。

<pre>
# <b>disklabel wd0</b> &gt;----- Or whatever disk device you'd like to view

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
上記のコマンドは、単に既存の disklabel を許すためのものであり、
間違って変更してしまったりしないよう保証してくれるものです
(これは私たちは、ときどき必要なことでしょう)。しかし、もし変更を
加えたいなら、disklabel で -E オプションを使用しなければなりません。

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
これでプロンプトが出てきますが、これは OpenBSD のインストール時に
目にするものと同じものです。このプロンプトで何より大切なコマンドは
'?' でしょう。これは disklabel で使用可能なオプションの
一覧を表示してくれるものです。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man ページ全部を見るには、 'M' コマンドを使います。
このプロンプトから、パーティションの追加、削除、
変更すべてを行うことができます。より詳しくは 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man ページを参照してください。

<a name="fdisk"></a>
<h2>14.2 - OpenBSD の fdisk(8) を使用する</h2>

まず、必ず
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
の man ページを参照してください。

<p>
Fdisk は、パーティションのメンテナンスを助けてくれるソフトです。この
プログラムはインストール時に使われて、OpenBSD のパーティションを設定します (この
パーティションの中に複数のラベルが設定されて、それぞれがファイルシステムやスワップ等になります)。
ドライブのスペースを区切って、ひとつをアクティブにできます。このプログラムは
通常、シングルユーザモード (つまり boot -s) で使われます。Fdisk はまた、
各種ハードディスクの MBR も設定します。

<p>
インストールするには、ほとんどの場合は OpenBSD パーティションが <b>ひとつ</b>あれば良いでしょう。
それをさらに区切って、スワップやファイルシステムを作成するには disklabel を使います。

<p>
fdisk でパーティションテーブルを見るだけでしたら、次のように

<pre># <b>fdisk sd0</b><br>
</pre>

<p>
と入力すると、次のように出力されます。

<pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD     
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
</pre>

<p>
この例では、最初の SCSI ディスクドライブの fdisk 出力を見ています。
OpenBSD パーティション (A6) と
そのサイズも見られます。* がついているので、起動パーティションが
OpenBSD パーティションだとわかります。

<p>
前の例では、情報を見ただけですが、では、パーティションテーブルを編集したい場合は
どのようにすれば良いのでしょう ?　そのときには <b>-e</b> フラグを使います。
これによって、コマンドラインプロンプトが出力されて、fdisk が操作可能になります。

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p> 
fdisk に入っていろいろ試すのは、まったく危険はありません。ただし、
変更を保存するかどうか聞かれた場合には、絶対に <b>N</b> と答え、
<b>write</b> コマンドは使わないようにしてください。

<p><b>-e</b> フラグで使用可能なコマンドの一覧を
以下に挙げておきます。

<ul>
<li><b>help</b>    対話型編集モードで fdisk のわかる
コマンド一覧を表示します。
<li><b>reinit</b>  現在選択中のメモリに入っている
ブートブロックのコピーを初期化します。
<li><b>disk</b>    fdisk がプローブした現在のドライブジオメトリを
表示します。必要なら編集も可能です。
<li><b>setpid</b>  パーティションテーブルの指定エントリの
パーティション ID を変更します。このコマンドは、既存のパーティションを
OpenBSD に再割り当てしたりする場合には特に便利です。
<li><b>edit</b>    現在のブートブロックのメモリ内コピーの、
指定テーブルエントリを編集。BIOS ジオメトリモードで編集することも、
セクターオフセットやサイズで編集することも可能です。
<li><b>flag</b>    パーティションテーブルの指定エントリを起動可能に設定します。
ただし、起動可能に設定できるエントリはひとつだけです。
もし、拡張パーティションから起動したい場合には、その拡張パーティションの
エントリを起動可能にする必要があります。
<li><b>update</b>  現在のブートブロックのメモリ内コピーの
機械コードを更新します。
<li><b>select</b>  現在のブートブロックにある、拡張パーティションテーブルエントリで
示されたブートブロックを、メモリに読み込みます。
<li><b>print</b>   現在選択中のメモリ内のブートブロックのコピーと
その MBR テーブルをターミナルに表示します。
<li><b>write</b>   現在メモリ内にあるブートブロックのコピーをディスクに出力します。
本当に実行してよいかどうか、操作確認が出力されます。
<li><b>exit</b>    現在の fdisk のレベルを終了し、
前に選んだメモリ内のブートブロックのコピーに戻るか、
それがなければプログラムを終了します。
<li><b>quit</b>    現在の fdisk のレベルを終了し、
前に選んだメモリ内のブートブロックのコピーに戻るか、
それがなければプログラムを終了します。exit と異なるのは、
変更したブロックはディスクに出力される点です。
<li><b>abort</b>   現在の変更を保存しないでプログラムを終了します。
</ul>

<a name="NewDisk"></a>
<h2>14.3 - OpenBSD でディスクを追加する</h2>

<p>
そう、ディスクさえ<b>きちんと</b>インストールされれば、あとは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>i386 のみ</i>) と
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
を使用して OpenBSD 用にディスクを設定するだけなのです。

<p>
i386 の人たちは、fdisk から始めてください。他のアーキテクチャの人は、ここをスキップすることができます。
以下の例では、3 個目の SCSI ドライブをシステムに追加しています。
<pre>
# <b>fdisk -i sd2</b>
</pre>
これはディスクの「ほんものの」パーティションを初期化して、
OpenBSD 専用に変える作業です。
続いてここに disklabel を作成します。これは少し面倒かも知れません。
<pre>
# <b>disklabel -e sd2</b>

<i>(画面が消えて、$EDITOR で指定のエディタが起動します)</i>
type: SCSI
<i>うだうだ……</i>
sectors/track: 63
total sectors: 6185088
<i>うだうだ……</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

まず、'c' パーティションは無視します。必ず存在していて、disklabel のような
プログラムが機能するために必要なものですから !
OpenBSD の fstype は 4.2BSD です。
Total sectors は、ディスクの総容量です。たとえば、これが 3 GB のディスクとします。
ディスクメーカの言い方では、3 GB は 3000 MB です。そこで 6185088/3000 の割り算をします
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1))</a>
を使います。答は 2061 です。そこで a, d, e, f, g, ... のパーティションサイズを
計算するには、それぞれ X MB の容量が必要ならば、単に X*2061 のかけ算をすれば
良いのです。最初の新しいパーティションのオフセットは、さっき disklabel
の出力に出てきた「sectors/track」と同じになります。ここでは 63 です。
その後の各パーティションのオフセットは、各パーティションサイズと、
そのパーティションのオフセットを組み合わせたものになります
(ただし 'c' パーティションだけは、現在の式にあてはまるところもないし、
無視しましょう)。

<p>
あるいは、ディスク上にパーティションがひとつだけしか必要ない場合もあります。たとえば、
ディスク全体を Web 保存に使うとか、ホームディレクトリにしたいとかなどです。
この場合には、ディスクの総容量から、トラックあたりのセクター数をひくことで求められます。
6185088-63 = 6185025 ですから、あなたのパーティションは次のようになります。

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>これが必要以上に面倒だと思うのでしたら、単に disklabel -E を使うことで、
インストール時と同じパーティション切りモードに入れます !</b>
そこで、96 メガバイト必要なら "96M" と指定すれば良いのです (ディスクが巨大なら、
96GB で 96 ギガバイトということです !) 残念なことに、
-E モードは本当のディスクジオメトリではなく、BIOS ディスクジオメトリを使用していて、
この両者が必ずしも一致しないということでしょう。この制約を回避するには、
'geometry disk'の略で 'g d' とタイプします (その他のオプションとしては、'geometry bios' なら 'g b' で、
'g u' とすれば geometry user、つまり disklabel が変更前に
どのような内容になっていたかを表示します)。

<p>
以上、非常に多くの内容でした。しかし、まだ話は終ってはいないのです。
最後に、そのディスク上にファイルシステムを作成しなくてはならないのです。これには、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a> を使用します。

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
wd1a のところは、OpenBSD のディスク番号方式で、あなたのディスクの番号に該当するものに置き換えます
(OpenBSD のディスク名称を見たい場合は、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
の出力を見ます)。

<p>
さて、この作成されたばかりのパーティションをどこにマウントするのかを考えます。たとえば /u にマウントしたいとします。
その場合、まず、/u ディレクトリを作成します。それからそれをマウントするのです。

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
最後にそれを
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a> に追加します。

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
では、/usr/local などの既存のディレクトリを移動させたい場合にはどのようにすれば良いのでしょう。
このような場合には、新しいドライブを /mnt にマウントして、<tt>cpio -pdum</tt> を使って /usr/local を
/mnt ディレクトリにコピーします。そして、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
ファイルを編集して、/usr/local パーティションが新しい /dev/sd2a
(さきほど新規にフォーマットしたパーティション) になるように変更します。たとえば、

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
<strong>boot -s</strong> で、シングルユーザモードで再起動します。既存の /usr/local を /usr/local-backup
に移動します (あるいは、ツキが上向いてる気分ならバッサリ削除しても良いでしょう)。そして、
空のディレクトリ /usr/local を作成してください。そしてシステムを再起動すると、ファイルが
/usr/local に元どおりになっているのがわかります !


<a name="SwapFile"></a>
<h2>14.4 - ファイルへのスワップ</h2>

<p>
(注: もし、
&quot;virtual memory exhausted&quot; エラーが多数出力されているため、スワップをしようとしているのでしたら、
まずはプロセスごとのリミットを上げてみましょう。csh でしたら
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>
ですし、sh でしたら
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a> です。)

<p>
ファイルへのスワップは、カスタムのカーネルは必要ありませんが、
ビルドし直しても構いません。
この FAQ では、どちらの方法でもスワップスペースを追加する方法を示します。

<h3>ファイルへのスワップ</h3>

<p>
追加のスワップ領域を設定するのに、最も簡単かつ迅速な方法は、ファイルへのスワップを追加することです。
この方法は、Soft Updates が有効になっているファイルシステム上では使用できません
(これはデフォルトでは有効になってはいません)。最初に、まず、今どのくらいのスワップ領域があって、
どれくらいスワップを使用しているのかを調べます。これには
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
ユーティリティを、次のように使用します。

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
これは、今、スワップに使用されているデバイスとその現在の統計を示しています。
上記の例では &quot;swap_device&quot; というデバイスがひとつしかありません。
これはディスク上の事前に定義されたスワップ領域です
(disklabel を見るときにはパーティション b として表示されます)。
上記の例でもわかりますが、このデバイスは現状ではあまり使用されてはいません。
しかし、この文章では仮に、
さらに 32MB が必要だということにしましょう。

<p>
ファイルをスワップデバイスとして設定する第一歩は、
そのファイルを作成することです。これは 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
ユーティリティで作成するのが最も良いでしょう。
以下は、大きさ 32MB の <i>/var/swap</i> ファイルを作成しています。

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
これができたら、そのデバイスへのスワップを有効にします。以下のコマンドを使用して、
このデバイスへのスワップを有効にします。

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
ここで、作成されたものがスワップデバイスの一覧に追加されたかどうかを
チェックしましょう。

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
これでファイルが設定されてスワップが行われているので、
<i>/etc/fstab</i> ファイルに記入して、次の起動時にも
このファイルが使用されるようにします。
この一行がないと、スワップデバイスとして設定されません。

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>vnode デバイス経由でスワップ</h3>

<p>
これはスワップ領域を追加するさらに恒久的な解決方法です。ファイルを恒久的にスワップするには、
まず vnd0c をスワップにしたカーネルを作成します。カーネルが wd0a を root ファイルシステムに
しているなら、これまでのスワップは wd0b ですから、カーネル設定ファイルで以下のような行を
使用します (疑問があれば、新しいカーネルのコンパイルを参照してください)。 

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
これが終れば、スワップに使用するファイルを
作成しなければなりません。
これは、上記の例と同じコマンドを使えば良いでしょう。

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
さて、ファイルができたましたので、そのファイルを
<i>/etc/fstab</i> に追加します。このデバイスが起動時に
スワップデバイスになるための一行は、以下のようになります。

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
この時点でコンピュータを再起動させて、カーネルの変更が反映されるようにします。
これを実行したら、デバイスをスワップとして設定することになります。これには
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
を使用します。

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
そして、最後になりますが、そのデバイスでスワップを有効にします。これは、上記の例とまったく
同じように swapctl(8) を使用しましょう。最後に、それがスワップの一覧にきちんと追加されたかどうかを
確認してください。

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name="SoftUpdates"></a>
<h2>14.5 - Soft Update</h2>


<p>
Soft Updates は、
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
と Yale Patt</a> が提案したアイディアに基づいて、
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a>
が FreeBSD 用に開発したものです。SoftUpdates は、バッファキャッシュ操作を
部分的に整理することで、ディレクトリのエントリの同期書き込みという要求事項が、
FFS のコードから除去可能になります。これによって、
ディスクへの書き込み性能に大幅な向上が見られます。

<p>
Soft Updates を使用して fsck(8) をバックグラウンドで実行する可能性については、
まだ OpenBSD では実現されていませんので、
正しく shutdown せずに終了したときには、やはり
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
を必要としますが、これは将来のバージョンでは変更されるかも知れません。

<p>
Soft Update を使用するには、

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
をつけたカーネルをコンパイルしなければなりませんが、これは既に GENERIC には入っています。

<p>
Soft Update を有効にするにはマウント時のオプションで行う必要があります。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
ユーティリティでパーティションをマウントする際、このパーティションでは
Soft Update を有効にしたいということを指定することができます。
以下は、Soft Update を使用してマウントしようとしているひとつの
パーティション <i>sd0a</i> を持つ、サンプルの
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
エントリです。

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
sparc ユーザへの注意: sun4 や sun4c のマシンでは Soft Update を有効にしてはいけません。
これらのアーキテクチャでは、ごく限られた量のカーネルメモリしかサポートしませんので、
Soft Update を使用することができないのです。
しかし、sun4m マシンなら大丈夫です。

<a name="Boot386"></a>
<h2>14.6 - OpenBSD/i386 はどのようにブートするの ?</h2>
OpenBSD/i386 のブートプロセスは単純なものではなく、それがどのように動作するのかを
理解することは、これが動作しない場合に問題を解決するのに役に立つことでしょう。
ブートプロセスには以下のような 4 つの鍵となる部分があります。
<ol>
<li><b><i>マスタブートレコード (MBR: Master Boot Record):</i></b> MBR
はディスクの最初の物理セクタ (512 バイト) のことです。
これには、プライマリパーティションテーブルおよびパーティションブートレコード
(PBR: Partition Boot Record) をロードするための小さなプログラムが含まれます。
ある種の環境では、"MBR" という用語は、(パーティションテーブルを含む)
最初のブロック全体のことではなく、ディスクの最初のブロックのコードの部分だけを
指して使用されることがあるということに注意してください。
OpenBSD の用語として、"MBR を初期化する" ということの意味を理解することは
大変重要なことであり、ある種のシステムがそうであるように、
それはコードだけではなく MBR セクタ全体への再書き込みを伴ないます。
もし、あなたがそのようにしたくない場合には、
代わりに fdisk(8) の "-u" コマンドラインオプションを使用してください
("<tt>fdisk -u wd0</tt>")。

<p>
仮想的にどのような MBR でも OpenBSD をブートすることができるので、OpenBSD
が MBR を含んでいるにも関わらず、その使用を余儀なくされることはありません。
MBR は、fdisk(8) プログラムによって操作されますが、このプログラムは、
パーティションテーブルの編集と MBR コードのディスクへのインストールの
両方を行うものです。 

<p>
OpenBSD の MBR は、自身を以下のようなメッセージでアナウンスします。
<pre>
    Using Drive: 0 Partition: 3
</pre>
これは、PBR をどのディスクのどのパーティションからロードするのかを示しています。

<li><b><i>パーティションブートレコード (PBR: Partition Boot Record):</i></b>
パーティションブートレコードは、PBR または
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(コードを保持するファイルの名前の後) とも呼ばれ、ディスク上の
OpenBSD パーティションの最初の物理セクタのことです。
PBR は OpenBSD 用の「第一段階ブートローダ」です。
この PBR は MBR コードからロードされ、OpenBSD の第二段階ブートローダ
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
をロードする役割を有しています。
MBR と同様、PBR はコードとデータ全体でわずか 512 バイトという
非常に小さな部分から構成されます。
これは、完全にファイルシステムのことを知るアプリケーションには十分ではありませんので、
PBR はディスク上の <tt>/boot</tt> の位置を持つのではなく、
BIOS がアクセス可能な <tt>/boot</tt> 位置が、インストール時に PBR
のコードに物理的に組み込まれます。

<p>
PBR は、
<a href="faq14.html#InstBoot">このドキュメントで後ほど記述</a>する
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>
によってインストールされます。
PBR は、自身を以下のようなメッセージでアナウンスします。
<pre>
    reading boot....
</pre>
これは、ディスクから読み出しているセクタ数をドットで示します。

<li><b><i>第二段階ブートローダ <tt>/boot</tt>:</i></b> <tt>/boot</tt> は、
は PBR によってロードされ、マシンの BIOS を通じて OpenBSD のファイルシステムに
アクセスし、実際のカーネルの位置を特定してロードする役割を有しています。
boot(8) はまた、各種のオプションや情報をカーネルにわたします。
<p>
boot(8) は会話的なプログラムです。ロードされた後、このプログラムは <tt>/etc/boot.conf</tt>
の位置の特定とその読み込みを試み、もし、このファイルが存在していれば (因みに、このファイルは
デフォルトではインストールされません)、その中に指定されたコマンドを処理します。<tt>/etc/boot.conf</tt>
による他の指示がない限り、このプログラムは以下のようなプロンプトをユーザに出力します。

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.02
     boot>
</pre>
このプロンプトは、ユーザが別の指示を与えられるよう (デフォルトで) 5 秒待ちますが、
このタイムアウトまでに何の指示も与えられなければ、デフォルトの挙動である、
最初のハードディスクの root パーティションからの、カーネル <tt>bsd</tt>
のロードを開始します。
この第二段階ブートローダは、(OpenBSD のカーネルがまだロードされていないので)
BIOS を通じて、あなたのシステムのハードウェアのプローブ (検出テスト) を行います。
上記では、検出を試みて見つかった少しばかりのものを見ることができます。
<ul>
<li><b>pc0</b> - i386 システムの標準キーボードおよび
ビデオディスプレイです。
<li><b>com0、com1</b> - ふたつのシリアルポートです。
<li><b>apm</b> - APM (Advanced Power Management) BIOS 機能です。
<li><b>636k 190M</b> - 検出されたコンベンショナル (1M 以下) および
拡張 (1M 以上) メモリの量です。
<li><b>fd0 hd0+</b> - 検出された BIOS ディスクデバイスで、この場合なら、
一台のフロッピーディスクと一台のハードディスクです。
</ul>

"hd0" の後の '+' の文字は、<tt>/boot</tt> が BIOS 経由でこのディスクに
LBA でアクセスできることを示しています。
初回インストール時、ハードディスクの後に '*' が表示されているのを
見かけることがあるかも知れませんが、これは、このディスク上には正常な
OpenBSD のディスクラベルがないように見えることを示しています。


<li><b><i>カーネル: <tt>/bsd</tt></i>:</b>  これは、OpenBSD のカーネルを RAM
上にロードし、正しく実行するための、ブートプロセスの最終段階です。
カーネルがいったんロードされると、OpenBSD はもはや BIOS を経由することなく、
ハードウェアに直接アクセスするようになります。

</ol>

以上のことから、ブートプロセスのごく最初の部分は以下のようになります。
<blockquote><pre>
Using Drive: 0 Partition: 3                      <b><i>&lt;- MBR</i></b>
reading boot....                                 <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.02
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- カーネル</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.4 (GENERIC) #18: Wed Sep 17 03:34:47 MDT 2003
   ...
</pre></blockquote>


<h3>うまく動作しない場合には</h3>
<ul>
<li><b>不良/不正な/互換性のない MBR:</b>
通常、使用されているハードディスクは何らかの MBR を保持していますが、
新しいディスクや異なるハードウェアプラットフォームからのディスク、そして
<a href="../faq4.html#Disks">インストール時</a>の "Use entire disk" という質問に "Yes"
と応答しなかった場合には、正当な MBR を持たないディスクになることがあります。このため、
このディスクでは、正しいパーティションテーブルが存在していてもブートすることはできません。

<p>
OpenBSD の MBR は、fdisk プログラムを使用してハードディスクにインストールすることもできます。
インストールメディアからブートし、"Shell" を選択して
以下のコマンドプロンプトを表示させます。

<pre>
    # <b>fdisk -u wd0</b>
</pre>

また、fdisk を使用して、以下のように、指定の MBR をインストールすることもできます。
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre> 

この場合、<tt>/usr/mdec/mbr</tt> ファイルがシステムの
MBR としてインストールされることになります。
標準的なインストールの行われた OpenBSD に附属のこの特別なファイルは、
たまたま fdisk にも組み込まれる標準的な MBR でもありますが、他の
いかなる MBR でも、ここに指定することができます。

<li><b>PBR にインストールされた <tt>/boot</tt> の位置情報が不正:</b>
installboot(8) が PBR をインストールする際に、<tt>/boot</tt>
のディスクセクタの物理的な位置を PBR に書き込みます。
このため、<a href="faq14.html#InstBoot">installboot(8)</a>
を再実行せずに <tt>/boot</tt> を消去して置換すると、PBR は
たまたまそこに指定されているブロックが何であってもそれをロードしますが、
それはほぼ確実に第二段階ブートローダには意味のないものでしょうから、
システムはブート不可能な状態に陥ってしまいます。
<tt>/boot</tt> は BIOS 呼び出しを使用して読み込みを行いますので、もし、
ドライブのジオメトリを変更した場合 (たとえば、CHS 変換を使用する、あるコンピュータから
ドライブを取り出して LBA 変換を使用する別のコンピュータに移動したり、あるいは BIOS
で変換オプションを変更したりした場合) には、<i>BIOS にとっては</i>異なる位置情報に
見えてしまいます (つまり、ディスクから同じデータを読み出すには、異なるブロック番号で
アクセスしなければならないのです)。ですので、このような場合にも、
システムをリブートする前に installboot(8) を実行する必要があります。
PBR は非常に小さいので、そのエラーメッセージの範囲は以下のようにかなり限られています。

<ul>
<li><b>Read Error</b> -- ディスクからブロックを読み込もうとした際に BIOS
がエラーを返しました。
ディスクに物理的な問題が発生したか、(たとえば、ジオメトリ問題などで)
不正なセクタを読み込もうとした可能性が考えられます。
<li><b>Bad magic</b> -- 不正な
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>
ナンバを持つ第二段階ブートローダのヘッダが読み込まれました。
これは一般的に、読み込まれたものが <tt>/boot</tt>
ではないことを意味しています。
通常、これはドライブジオメトリ問題が原因であり、ディスク上の
<tt>/boot</tt> が置換されたか、あるいは、あなたのシステムの
<a href="faq14.html#LargeDrive">8GB あるいは BIOS の限界</a>
を無視して、PBR がアクセスできない場所に <tt>/boot</tt>
が置かれてしまったことによるものです。
</ul>
</ul>

i386 のブートプロセスについてのより詳しい情報については、以下のドキュメントを参照してください。
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
  Hale Landis のドキュメント "How it Works"
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - OpenBSD での大容量ドライブに関する問題は ?</h2>
<!-- XXXversion i386 changes for 3.5 -->

<p>
OpenBSD は現在や近い将来入手できるどのようなハードディスクよりも
はるかに大きなサイズのファイルシステムをサポートしていますが、
いくつかのインターフェースでは OpenBSD
の理論的な最大値よりも小さな限界があります。

<p>
もちろん、すべてのハードウェアの組み合わせが可能なわけではありません。
新しい 250GB の IDE ハードディスクは、古い目の (137GB 以上の標準以前の)
インターフェイスでは動かないでしょうし、いくつかの非常に古い SCSI アダプタは
より現代的なドライブとの組み合わせでは問題があることがわかっています。
もちろん、あなたは、あなたのハードウェアの能力に期待すべきではあります。

<h3>パーティションサイズと位置の限界</h3>
不幸にも、OS がメモリにロードされるまでは OS のすべての能力は使用できませんので、
起動のプロセスそれ自体に限界があります。
起動プロセスはシステムのブート ROM を使用します (また、だからこそそれに制限されるのです)。
OpenBSD/i386 の第一段階ブートローダ
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>)
にも、古い BIOS の限界から来る、それ自身の内部的な 8GB の限界が存在しています。

<p>
このような理由で、/bsd ファイル (カーネル) 全体がブート ROM で使用できる
領域内か、ディスクの先頭の 8GB 以内のどちらか小さい方に置かれなて
いなければなりません。これは、いくつかのさらに古い i386 システムでは
root パーティションは、完全に先頭の 504MB 以内になければなりませんが、
ほとんどの新しいコンピュータでは root パーティションは先頭の 8GB 以内の
どこかにあれば良い、という意味です。

<p>
古い 486 に 40GB のドライブを入れてひとつの巨大なパーティションとして
OpenBSD をロードすることもできることに注意しましょう。うまく上記の
規則を破ることができたと思うかも知れません。しかしながら、その規則は
もっとも嫌な具合につきまとってくるかも知れません。

<ul>
  <li>40GB の / パーティションにインストールすると、これはうまく動きます。
      なぜなら OS と (/bsd を含む) すべてのファイルは先頭の 504MB 以内にあるからです。
  <li>システムを使い込んでいくに従って、504MB 以上のファイルが存在するようになります。
  <li>アップグレードの際に自分のカーネルを作成するなどして、新しい
      /bsd を古いものに上書きコピーします。
  <li>再起動します。
  <li>"bad magic" というようなメッセージが出ることになります。
</ul>
<p>
これはどうしてでしょう ?  なぜなら新しい /bsd ファイルを「上書き」コピーしたとき、
古いものを上書きしたのではなく、BIOS がサポートする
504MB の範囲の外にあるであろう新しい領域に再配置されてしまったからなのです。
ブートローダは /bsd ファイルをロードできなくなって、
システムはハングしてしまうのです。

<p>
OpenBSD が起動するようにするには、ブートローダ (i386 の場合なら biosboot(8)
と <tt>/boot</tt>) およびカーネル (<tt>/bsd</tt>) がブート ROM
のサポートする範囲内、ならびにブートローダ自体の能力の範囲になければなりません。
安全に実行するための規則は単純です。

<p>
<b>root パーティション全体はコンピュータの BIOS (もしくはブート ROM) で使用可能な
領域内か、ディスクの先頭の 8GB 以内のどちらか小さい方に置かれていなければなりません。</b>
<br><i>注: OpenBSD/i386 の 8G の制限は -current では除去されています。
それでもなお、システムの BIOS の制限は尊重しなければなりません。</i>

<p>
これは、単一の巨大なパーティションを使用するより、<a href="../faq4.html#SpaceNeeded">
ハードディスクのパーティションを分割する</a>ことに対するもうひとつの良い理由となっています。

<h3>fsck(8) の時間と必要なメモリの量</h3>
巨大なファイルシステムについてのもうひとつの考察は、
電源断やクラッシュ後のファイルシステムに対する
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
に要する時間や必要なメモリの量についてです。
32MB の RAM しか搭載されていないシステムでは、120GB のファイルシステムを置こうとしたり、
それがクラッシュした後の fsck(1) が成功するなどと考えたりすべきではありません。
大まかなガイドラインとしては、ディスクの fsck が成功するためには、ディスク
1GB あたり、少なくとも 1MB ずつ利用可能なメモリをシステムは搭載すべきです。
また、ディスクの fsck に要する時間は、ファイルシステムが巨大になればなるほど
問題になってくる可能性があります。


<a name="InstBoot"></a>
<h2>14.8 - Bootblock のインストール - i386 のみ</h2>

<p>
古いバージョンの MS-DOS は、1024 シリンダ以下のディスクジオメトリにしか対応
していません。最近のディスクはほとんどすべて 1024 シリンダ以上
ありますので、ほとんどの SCSI BIOS チップ (SCSI コントローラボード上にある) と
IDE BIOS (その他 PC BIOS の一部) は、真のディスクジオメトリを MS-DOS が扱える
ようなものに「翻訳」するオプション (ときにはこれがデフォルト) があります。
しかし、BIOS チップの「翻訳」のしかたは必ずしも一致するわけではありません。
もし、BIOS を変えて (マザーボードを交換したとか、SCSI コントローラを交換したとか)、
そして新しい方が使用している「翻訳」ディスクジオメトリが異なっていたら、
第二段階ブートローダが読み込めない (つまりカーネルも読み込めない) ことになります。
(なぜかというと、第一段階ブートローダは /boot の入ったブロック一覧を
持っていますが、これが以前の「翻訳」ジオメトリで記述されているからなのです)。
IDE ディスクを使用していて BIOS 設定を変更した場合にも、翻訳を (うっかり)
変更してしまう場合があります (ほとんどの IDE BIOS は翻訳の仕方を 3 通り持っています)。
ブートブロックを直して普通にブートできるようにするためには、
ドライブに起動フロッピーを入れて (あるいはブート可能な CD-ROM を使用して)、
boot プロンプトで「b hd0a:/bsd」とタイプして、最初のハードディスク
(フロッピーではなく) から起動してください。これで普通にマシンが起動するはずです。
そうしたら、第一段階ブートローダを更新して、
新しいジオメトリが見えるようにしてください
(そしてそれに応じたブートブロックに書き換えてください)。 <br>
ここでの例では、あなたの起動ディスクが sd0 だと想定しています
(もし IDE なら wd0 等々..)。

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
もし、installboot が BIOS のジオメトリが読めなくてエラーメッセージを出力するようなら、
boot&gt; プロンプトで &quot;machine diskinfo&quot; コマンド (または短く
&quot;ma di&quot;) コマンドを入力して、必要な情報を表示させてください。
&quot;heads&quot; と &quot;secs&quot; の値をそれぞれ installboot の -h
と -s フラグ付きで入力しましょう。このような形で変更した installboot コマンドは
次のようになります。

<pre>
#<b> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</b>
</pre>

<p>
もし、ブートブロックのバージョン更新が必要なら、
それは自分でコンパイルするしかありませんが、その方法は簡単です。

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (ディスクのデバイスは自分のにあわせて変更してください)
</pre>

<a name="Backup"></a>
<h2>14.9 - トラブルにそなえよう: テープへのバックアップと復元</h2>

<h3>はじめに</h3>

<p>
たとえば、もし業務用サーバを走らせようとしているのでしたら、
固定ディスクのどれかがクラッシュした場合のために、
何らかのバックアップは取っておくようにしてください。

<p>
ここにある情報は、OpenBSD 附属の通常の
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
ユーティリティの使い方を説明しています。
複数のサーバを一本のテープドライブでバックアップするために、
<a href="faq8.html#Ports">ports</a> にある、
より高度な「Amanda」というソフトもあります。
普通の環境では
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
で十分でしょうが、複数のマシンを一台のテープにバックアップしたい場合には、
Amanda を検討してみてください。

<p>
この文書のデバイス例は、SCSI ディスクとテープを使うような構成のシステムを想定しています。
業務用環境では、不良ブロックの処理の方法から、IDE よりも SCSI が推奨されています。
しかし、IDE や別種のテープドライブを使用している人に
この情報が役に立たないわけではありません。
デバイス名を読み換えることで話は同じになります。
たとえば、SCSI の sd0a は IDE のシステムなら wd0a になります。

<h3>テープにバックアップ</h3>

<p>
テープへのバックアップは、ファイルシステムがどこにマウントされているかという知識が必須になります。
ファイルシステムがどうマウントされているのかについては、シェルプロンプトから
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
コマンドを使用します。これによって、たとえば、以下のような出力が得られるはずです。

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
この例では、root (/) ファイルシステムは物理的には sd0a 上にあります。
これは SCSI 固定ディスク 0 のパーティション a です。
/usr ファイルシステムは sd0h 上で、これは SCSI 固定ディスク 0 のパーティション h になります。

<p>
以下は、さらに高度なマウントテーブルの例です。

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
この、さらに高度な例では、root (/) ファイルシステムは物理的には sd0a 上にあります。
/var ファイルシステムは sd0d、/home ファイルシステムは sd0e で、
/usr は sd0h にあります。

<p>
マシンのバックアップには、それぞれの固定ディスクパーティション名を
dump に指定する必要があります。さきほどの簡単な方のマウントテーブルを
バックアップするコマンドは次のようになります。

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
さらに複雑な方のマウントテーブルの例なら
次のようになります。

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind</b>
</pre>

<p>
それぞれのコマンドラインのスイッチが何を意味するのかについては、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
man ページを見るのが最も良いでしょう。
上記の例で使用したパラメータの概要を以下に説明します。

<ul>
<li><b>0</b> - レベル 0 でダンプします。つまり全ファイルをダンプします。
<li><b>a</b> - 自動的にテープメディアの長さを決めようとします。
<li><b>u</b> - /etc/dumpdates を更新して、最後にバックアップをした日時を記録します。
<li><b>f</b> - どのテープデバイスを使うかを指定します (ここでは /dev/nrst0)。
</ul>

<p>
そして最後に、バックアップするパーティションが記述されています (/dev/rsd0a, etc)。

<p>
最後に
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
コマンドを使用して、ドライブを巻き戻しています。
他のオプション (たとえば eject) については、mt の man ページを参照してください。

<p>
テープデバイス名がよくわからない場合には、dmesg を使用して調べます。
たとえば、dmesg を使った例は次のようになります。

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
バックアップをする場合に、デバイス名が dmesg に出てくる「st0」ではなく
「nrst0」になっているのにお気付きでしょうか ?
st0 に nrst0 としてアクセスした場合は、
同じ物理デバイスにアクセスしていることには違いないのですが、
ジョブの終了後に巻き戻さないことと、デバイスを raw mode でアクセスすることが異なります。
複数のファイルシステムを一本のテープにバックアップするには、
必ず巻き戻さないデバイスを使用してください。
もし巻き戻すデバイス (rst0) を使用した場合には、
バックアップごとにテープが巻き戻されて、前のファイルシステムが上書きされてしまいます。
各種テープドライブについてのより詳しい説明は dump の man ページを参照してください。

<p>
以下は、"backup" を
簡単なスクリプトにした例です。

<pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre>

<p>
もし、毎晩定期的にバックアップしたい場合には、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
を使用して自動的にバックアップ用スクリプトを起動させます。

<p>
あと、それぞれのファイルシステムがどのくらいのサイズになるかを (紙切れに)
書いておくと役立ちます。それぞれのパーティションがどのくらいの容量を使用しているかを調べるには
df -h を使用します。これを行っておくと、ドライブが壊れてパーティションテーブルを
新しいドライブに再現するときに便利です。

<p>
データをリストアすることで、ファイルの断片化解消にもなります。
ファイル全部を確実にバックアップするには、まず再起動してシングルユーザモードで起動することです。
ファイルシステムは、バックアップするときにマウントしていなくても構いません。
シングルユーザモードで起動したら、root (/) r/w をマウントするのは忘れないようにしてください。
そうしないと、ダンプの日付を書き出そうとするときに dump は失敗します。
シングルユーザモードで起動するには、boot&gt; プロンプトで bsd -s を入力してください。

<h3>dump テープの中身を見る</h3>


<p>
初めてファイルシステムをバックアップしたら、
テープをちょっとテストしてみて、
そこのデータが思い通りのところにあるか確認するようにしてください。

<p>
以下に dump テープ上のファイルの
カタログを見る例を示します。

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
これで、dump テープの最初のパーティション上にある
ファイルのリストが一覧表示されます。上記の例について
さらに述べるなら、1 というのは root (/) ファイルシステムのことです。

<p>
2番目のテープパーティションに何があるのかを見て、
その出力をファイルに書き込むには次の例のようにしてください。

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
さきほどの単純な方のようなマウントテーブルを持っている場合には 2 は /usr で、
もし高度な方のマウントテーブルならば 2 は /var などの
他のファイルシステムになります。また、シーケンス番号は、
ファイルシステムがテープに書き出された順番と一致します。


<h3>テープからの復元</h3>

<p>
以下に挙げた例題シナリオは、固定ディスクが完全に壊れた場合に便利です。
テープからファイルをひとつだけを復元したい場合には、
restore の man ページを参照して、
対話型モードの指示をよく読んでください。

<p>
もし、きちんと準備をしてあれば、ディスクを交換してテープからデータを復元するのは
とても手早くできます。標準の OpenBSD インストール/起動フロッピーは、
すでに必要な復元ユーティリティも附属していますし、
パーティションを切って新しいドライブを起動可能にするためのバイナリも入っています。
ほとんどの場合、このフロッピーと最新の dump テープがあれば、
それだけでシステムを立て直せます。

<p>
壊れたディスクドライブを物理的に交換したら、
データの復元の基本的なステップは以下の通りです。

<ul>
<li>
<p>
まず、OpenBSD インストール/起動フロッピーから起動し、メニュー選択で
Shell を選択します。そして、最新のバックアップテープを、
書き込み禁止にした上でテープドライブに入れてください。
<br>
<li>
<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>r
コマンドを使用して、新品のドライブにプライマリ
OpenBSD パーティションを作成します。
以下に例を示します。

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
詳しくは <a href="#fdisk">fdisk FAQ</a> を参照してください。

<li>
<p>
disklabel コマンドを使用して、今、fdisk で作成したプライマリ
OpenBSD パーティションの中に、OpenBSD パーティションを作成します。
その例を以下に示します。

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(スワップを忘れないようにしてください。詳しくは <a href="#disklabel">disklabel FAQ</a>
を参照してください。)

<li>
<p>
newfs コマンドで、上記ステップで作成したパーティションに新しいファイルシステムを作成します。
以下にその例を示します。

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
新品の root (/) ファイルシステムを /mnt にマウントします。以下に例を示します。

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
マウントされた root ファイルシステムに移動して、復元プロセスを開始します。
以下に例を示します。

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
この新しいディスクを起動可能にする場合には、以下のコマンドでドライブに新しい MBR を書き込みます。
以下に例を示します。

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
<p>
ドライブに新品の MBR を書くと同時に、起動できるようにブートブロックをインストールしなければなりません。
以下に簡単な例を示します。

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
ハードディスクの新しい root ファイルシステムはこれで用意できましたので、
そこから起動して他のファイルシステムのリストアを続けることができます。
OS はまだ完全ではありませんので、必ずシングルユーザモードで
起動するようにしてください。シェルのプロンプトで、
以下のコマンドを使用してアンマウントしてシステムを停止します。

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
インストール/起動フロッピーをドライブから抜いて、システムを再起動します。
OpenBSD boot&gt; プロンプトで次のコマンドを入力します。

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
bsd -s で、カーネルをシングルユーザモードで起動します。
これには root (/) ファイルシステムだけが必要となります。

<li>
<p>
以上のステップをきちんと実行して、途中で何らかのトラブルがなければ、
プロンプトが出力され、シェルのパスを入力するかリターンを押すことが求められます。
リターンを押した場合は、sh が使用可能になります。次に、root を読み出し専用ではなく
r/w モードでマウントし直すため、以下のコマンドを実行します。

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
r/w モードで再マウントしましたら、残りのファイルシステムの再現を続けてください。
以下にその例を示します。

<pre>
(単純なマウントテーブル)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(さらに高度なマウントテーブル)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
ダンプセットから復元されるオブジェクト名をその都度見たい場合には、
単に rsf とするのではなく "<b>restore rvsf</b>" を使用します。

<li>
<p>
最後に、他のファイルシステムを全部ディスクに回復し終えましたら、
マルチユーザモードに移行します。すべてが意図した通りに進んでいたら、
システムは最新のバックアップ時と同じ状態に戻っていて、
また使用可能になっているはずです。
</ul>

<a name="MountImage"></a>
<h2>14.10 - OpenBSD でディスクイメージをマウントする</h2>

<p>
ディスクイメージ (ISO イメージ、dd で作ったディスクイメージなど)
を OpenBSD でマウントするには、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>
デバイスを設定する必要があります。たとえば、ISO イメージが
<i>/tmp/ISO.image</i> にあるとしたら、
マウントするには以下のようにしてください。

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
ポイントとしては、このイメージは CD イメージですので、マウントする場合にはその種類を
<i>cd9660</i> で指定するということです。これはどのような種類のイメージでもそうなのですが、
たとえばディスクイメージをマウントするのでしたら ffs を使用しなければなりません。

<p>
イメージのアンマウントには以下のコマンドを使用します。

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
詳しくは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
man page を参照のこと。


<a name="pciideErr"></a>
<h2>14.11 - 助けて!  PCIIDE でエラーになってしまう !</h2>

<p>
PCI IDE DMA は多くのハードウェアの組み合わせにおいて信頼性が低いものです。
ですので、最近までは、IDE ドライブとの DMA 転送のサポートを謳っている、
ほとんどの「主流」のオペレーティングシステムでも、デフォルトでは
この機能を有効にしていない状態で出荷されていました。

<p>
OpenBSD は積極的で、設定できる最上位の DMA モードを使おうとします。
このようにすることで、ある設定ではバグのあるマザーボードのチップセットや
バグのあるドライブ、ケーブル上のノイズなどの理由によって
データ転送の悪化を引き起こすかも知れません。幸運にも、Ultra-DMA モードは
悪化を検出する CRC によってデータ転送を保護してくれます。Ultra-DMA CRC
が失敗した場合には、OpenBSD はエラーメッセージを出力して、もう一度転送を試みます。

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
何度か失敗すると、OpenBSD はもっと遅い (そして願わくばもっと信頼できる)
Ultra-DMA モードへと下げます。Ultra-DMA モード 0 まで行ってしまったら、
ドライブは PIO モードへと下げます。

<p>
もし OpenBSD がうまくモードを下げられなかったり、
途中でマシンが固まったりするようでしたら、
<a href="../../ja/report.html">バグの報告</a>を行ってください。

<a name="RAID"></a>
<h2>14.13 - OpenBSD の RAID オプション</h2>
RAID (Redundant Array of Inexpensive Disks) は、一台のディスクだけのときより、
より良い性能や、容量、そして冗長性を得るために、複数台のディスクを使うための
仕組みです。
RAID の特質についての詳細な議論は、この文章の範囲外ですが、ふたつの重要な点だけは
ここで明確にしておきましょう。

<ul>
<li>RAID はバックアップについては何もしない。
<li>RAID 自身はダウンタイムを短縮してくれるわけではない。
</ul>

もし、これがあなたにとって新しい情報だったりしたら、これはあなたにとって、
RAID の冒険のための良い出発点ではありません。

<h3>ソフトウェアオプション</h3>
OpenBSD は、ソフトウェア RAID である RAIDframe を含んでいます。
これについてのドキュメントは以下の場所にあります。

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe ホームページ</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)
     man ページ</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)
     man ページ</a>
</ul>

<p>
root パーティションは
直接ミラーリングすることが可能になりました。

<h3>ハードウェアオプション</h3>
<p>
多くの OpenBSD の <a href="../../ja/plat.html">プラットフォーム</a> は、
いろんな種類のハードウェア RAID 製品をサポートしています。
これはプラットフォームによって変わりますので、ハードウェアサポート
ページ (<a href="../../ja/plat.html">ここ</a> にリストがあります) を見てください。

<p>
もうひとつ、複数のドライブを一台の IDE や SCSI のドライブとして見せて、
これを標準の IDE や SCSI アダプタに接続して使うタイプの多くの製品が、
多くのプラットフォームで利用可能です。
これらのデバイスは、SCSI や IDE をサポートしている
どのようなハードウェアプラットフォームでも仮想的に動作できます。

<p>
これらの製品のいくつかの製造業者は次のとおり。
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(注: これらは OpenBSD のユーザが使えることをレポートしてくれた
製品というだけですので、その使用を推奨しているわけではありませんし、
徹底したリストというわけでもありません。)


<h3>Non-Options</h3>
<p>
<a href="../../ja/mail.html">メーリングリスト</a>上で、ときどき繰り返される質問として、
「Promise や HighPoint の IDE RAID コントローラはサポートしているのか ?」というのがあります。
しかし、その答は "No" です。これらのカードやチップはほんとうのハードウェア RAID コントローラ
ではなく、むしろ、これは、BIOS の助けを借りてブートするソフトウェア RAID だからななのです。
既に OpenBSD は、ハードウェアに依存しない方法でソフトウェア RAID をサポートしているのですから、
OpenBSD の開発者の間では、これらのカードの特別なサポートを実装しようという気には
ならないのです。

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "faq12.html">[12 章 - プラットフォーム固有の質問]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq14.html,v 1.103 ]
<br>
$Translation: faq14.html,v 1.43 2004/04/14 03:51:58 toshi Exp $
<br>
$OpenBSD: faq14.html,v 1.39 2004/05/09 09:58:22 saad Exp $
</small>

</body>
</html>
