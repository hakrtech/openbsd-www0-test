<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>7 - Keyboard and Display Controls</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-2022-JP">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2003 by OpenBSD.">
</head>

<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "../faq6.html">[6 章 - ネットワーキング]</a>
<a href= "faq8.html">[8 章 - 一般的な質問]</a>
</font>

<h1><font color="#e00000">7 - キーボードならびにディスプレイの制御</font></h1>
<hr>
<p>
<h3>Table of Contents</h3>
<ul>
<li><a href= "#Keyboard"     >7.1 - どうすればキーボードの配列を変更できますか ? (wscons)</a>
<li><a href= "#ConsoleMouse" >7.2 - OpenBSD には gpm か、それに類するものはありますか ?</a>
<li><a href= "#ConsoleClear" >7.3 - どうすればユーザがログアウトするたびに
    コンソールをクリアできますか ?</a>
<li><a href= "#Scrollback"   >7.4 - コンソールスクロールバックバッファへのアクセス
    (alpha/macppc/i386)</a>
<li><a href= "#SwitchConsole">7.5 - コンソールの切り替えはどのようにするのでしょう ? (i386)</a>
<li><a href= "#80x50"        >7.6 - コンソールの解像度として 80x25 を使用するには
    どのようにすれば良いのでしょう ? (i386)</a>
<li><a href= "#SerCon"       >7.7 - シリアルコンソールを使用するにはどのようにすれば良いのでしょう ?</a>
<li><a href= "#Blanker"      >7.8 - コンソールを消すにはどのようにすれば良いのでしょう ? (wscons)</a>
</ul>
<hr>

<br>
<p>
<a name= "Keyboard"></a>
<h2>7.1 - どうすればキーボードの配列を変更できますか ? <i>(wscons)</i></h2>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&sektion=4">wscons(4)</a>
コンソールドライバを使用している port は、
<a href="../../alpha.html">alpha</a>、
<a href="../../hppa.html">hppa</a>、
<a href="../../i386.html">i386</a>、
<a href="../../macppc.html">macppc</a>、
<a href="../../sparc.html">sparc</a>、
および <a href="../../sparc64.html">sparc64</a> です。

<p>
wscons(4) のコンソールでは、ほとんどのオプションが
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&sektion=8">wsconsctl(8)</a> を使用して制御できます。
たとえば、<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&sektion=8">wsconsctl(8)</a>
を使用してキー配列を変更するには、
次のコマンドを実行します。

<blockquote><pre>
# <strong>wsconsctl -w keyboard.encoding=uk</strong>
</pre></blockquote>

<p>
他の例として、&quot;Caps Lock&quot; を &quot;Control L&quot; に割り当て直すには、
以下のようにします。

<blockquote><pre>
# <strong>wsconsctl -w keyboard.map+="keysym Caps_Lock = Control_L"</strong>
</pre></blockquote>


<a name= "ConsoleMouse"></a>
<h2>7.2 - Is there gpm or the like in OpenBSD?</h2>

<p>
<a href="../../alpha.html">alpha</a> および <a href="../../i386.html">i386</a> 
プラットフォームでは、OpenBSD は FreeBSD の moused(8) である
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsmoused&amp;sektion=8&amp;arch=i386">wsmoused(8)</a>
を用意しています。これは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
の適正な行を編集して起動させることで、自動的に有効にすることも可能です。

<p>
<a name= "ConsoleClear"></a>
<h2>7.3 - どうすればユーザがログアウトするたびにコンソールをクリアできますか ?</h2>

<p>
これを行うためには、
<kbd><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gettytab&sektion=5">/etc/gettytab(5)</a></kbd>
に行を追加しなければなりません。現在、以下のようになっているところがあります。

<blockquote><pre>
P|Pc|Pc console:\
        :np:sp#9600:
</pre></blockquote>

<p>
これの最後に&quot;<tt>:cl=\E[H\E[2J:</tt>&quot;という行を加えます。
つまり、次のようになります。

<blockquote><pre>
P|Pc|Pc console:\
        :np:sp#9600:\
	:cl=\E[H\E[2J:
</pre></blockquote>

<p>
<a name= "Scrollback"></a>
<h2>7.4 - コンソールスクロールバックバッファへのアクセス
  <i>(i386、いくつかの Alpha)</i></h2>

<p>
いくつかのプラットフォームでは、
OpenBSD はコンソールスクロールバッファを用意しています。これによって、
既に画面からスクロールして消えてしまった情報を見ることができます。
このバッファの中を上下するには、単に、次のキーの組み合わせ
<tt>[SHIFT]+[PGUP]</tt> や <tt>[SHIFT]+[PGDN]</tt> を使えばよいのです。

<p>
デフォルトスクロールバッファ、つまり、上に戻ってみることのできるページ数は、
8 です。
この機能は、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>
ドライバの機能ですので、いかなるプラットフォームであっても VGA カードがなければ
動作しません (多くの Alpha システムは TGA ビデオを持ちます)。


<p>
<a name= "SwitchConsole"></a>
<h2>7.5 - コンソールの切り替えはどのようにするのでしょう ? <i>(i386、いくつかの Alpha)</i></h2>

i386 と
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>
カードを持つ Alpha システムでは、OpenBSD はデフォルトで /dev/ttyC0
から /dev/ttyC5 までの 6 個の仮想ターミナルを持っています。
ttyC4 は X Window system が使用するために予約されているので、
残り 5 個のテキストコンソールが残ることになります。
これらは、
<tt>[CTRL]+[ALT]+[F1]</tt>、 <tt>[CTRL]+[ALT]+[F2]</tt>、
<tt>[CTRL]+[ALT]+[F3]</tt>、 <tt>[CTRL]+[ALT]+[F4]</tt> および
<tt>[CTRL]+[ALT]+[F6]</tt> というキーの組み合わせで切り替えて使用することが可能です。

<p>
ttyC4 を使用する X 環境へは <tt>[CTRL]+[ALT]+[F5]</tt> で切り替えます。
X を使用している場合、
<tt>[CTRL]+[ALT]+[F</tt><i>n</i><tt>]</tt> で
テキストスクリーンに切り替えることができ、
<tt>[CTRL]+[ALT]+[F5]</tt>
で元のグラフィッカルな環境に戻ることができます。

<p>
もし、デフォルトの数以上の仮想コンソールが必要な場合には、
ttyC6、ttyC7 やそれ以上のスクリーンを生成するのに
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg(8)</a>
コマンドを使用してください。
たとえば、

<blockquote>
<pre>
wsconscfg -t 80x25 6
</pre>
</blockquote>

とすることで、<tt>[CTRL]+[ALT]+[F7]</tt> でアクセス可能な
ttyC6 用の仮想ターミナルが生成されます。
この増設スクリーンを次回の起動時にも使用したい場合には、このコマンドを
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local(8)</tt></a>
ファイルに追加しておいてください。

<p>
新しく追加した仮想コンソールは、そのコンソールを
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><tt>/etc/ttys(5)</tt></a>,
の中で "on" に設定して、リブートするか
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
に
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">kill(1)</a>
で HUP シグナルを送るかしない限りは、"<tt>login:</tt>" プロンプトは出力されないことに注意してください。

<a name="80x50"></a>
<h2>7.6 - コンソールの解像度として 80x50 を使用するにはどのようにすれば良いのでしょう ? <i>(i386)</i></h2>

i386 のユーザは、通常は 80 文字 25 行のコンソールスクリーンが使用可能です。
しかしながら、多くの VGA ビデオカードでは、これよりも高い文字解像度である
80 文字 50 行の表示を行う能力を有しています。

<p>
まず、
目的の解像度をサポートするフォントが
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsfontload&amp;sektion=8">wsfontload(8)</a>
コマンドによってロードされなければなりません。標準の 80x25 文字スクリーンは 8x16 ピクセルのフォントを
使用していますが、縦解像度を倍にするためには、8x8 ピクセルのフォントを使用する必要があります。

<p>
その後、
<a href="#SwitchConsole">virtual console</a> を消去して、
目的の解像度のものを
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg(8)</a>
コマンドを使用して再生成します。

<p>
これは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local(8)</tt></a>
ファイルに次の行を追加することで、
ブート時に自動的に実行させることができます。
<blockquote>
<pre>
wsfontload -h 8 -e ibm /usr/share/misc/pcvtfonts/vt220l.808
wsconscfg -dF 5
wsconscfg -t 80x50 5
</pre>
</blockquote>

いかなるシステム構成の変更においても、これらのコマンドが
何を行おうとしているのかを理解するために、man ページを
読むことをお勧めします。

<p>
最初の行は、8x8 のフォントをロードしています。次の行は、
(<tt>[CTRL]+[ALT]+[F6]</tt> でアクセスされる) スクリーン 5 を消去しています。
3 行目は、80 文字 50 行の新しいスクリーン 5 を生成しています。これを実行した
場合、最初のスクリーンおよび他の 3 つのデフォルト仮想コンソールは、標準的な
80x25 のモードで起動しますが、<tt>[CTRL]+[ALT]+[F6]</tt> を押下することで、
新しいスクリーン 5 が 80x50 でアクセス可能になっていることがわかるでしょう。

<p>
ここで、<tt>[CTRL]+[ALT]+[F1]</tt> がスクリーン 0 となることを思い出してください。
もし、他のスクリーンも切り替えたければ、
80x50 の解像度で使用したいスクリーンで、
単にスクリーンを消去して追加する作業を繰り返してください。

<p>
スクリーン 4 (ttyC4、<tt>[CTRL]+[ALT]+[F5]</tt>) を切り替えるのは避けるべきです。
このスクリーンは、X がグラフィックスクリーンとして使用しています。(たとえば
ttyC0 などの) 最初のコンソールデバイスの解像度を切り替えることもできません。

<p>
もし、その必要がある場合には、これらのすべてのコマンドは、root ユーザとして、あるいは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>
(こちらの方がより良い) を使用して、コマンドプロンプトから入力することも可能です。

<p>
<b>注意: これは、すべてのビデオカードで使えるわけではありません。</b>  不幸にも、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a>
が 80x50 文字モードを使用するのに必要なフォントのアップロードを、
すべてのビデオカードがサポートしているわけではないからです。
これらのカードでは、X の使用を考慮した方が良いかも知れません。


<a name="SerCon"></a>
<h2>7.7 - シリアルコンソールを使用するにはどのようにすれば良いのでしょう ?</h2>

OpenBSD システム上で、さまざまな理由からシリアルコンソールを使用したい場合が
あります。
<ul>
<li>(ドキュメンテーションのための) コンソール出力の記録。 
<li>リモート管理。
<li>多数のマシンのより簡単なメンテナンス。
<li>他の方法では取得が困難なマシンから、役に立つ dmesg を
   用意するため。
<li>システムクラッシュの際に、開発者が問題を修正できるようにするための、
   正確な "trace" や "ps" の出力を用意するため。
</ul>
OpenBSD には、ほとんどのプラットフォームでシリアルコンソールが用意されていますが、
その詳細は、プラットフォーム間で大きく異なっています。

<p>
シリアルのインターフェイスを取るということが取るに足りないこと<strong>ではない</strong>
ということに注意してください。たとえば、しばしば普通のものではないケーブルが必要になったり、
マシン間で ports が標準化されていなかったり、いくつかのケースでは、ひとつのマシンの中でさえ
一貫性がなかったりすることがあるのです。ここでは、コンピュータとシリアル端末として使用する
デバイスの間のケーブルとして、適正なものをどのようにして選定するのかを知っているものと
仮定します。シリアルでインターフェイスを取ることの完全な解説は、このドキュメントの範囲外ですが、
ヒントをひとつ。コネクタを接続したからと言って、それで動くとは限らない、ということです。

<a name="SerContty"></a>
<h3><i>/etc/ttys</i> の変更</h3>
OpenBSD システム上で、機能するシリアルコンソールを設定するには、ふたつの要素があります。
まず、OpenBSD がシングルユーザモードでステータス用の端末としてシリアルポートを使用する
ようにしなければなりません。この部分は非常にプラットフォームに依存する部分です。次に、
マルチユーザモードで運転されている場合に、ユーザの login を可能にするため、会話型端末
として使用できるよう、シリアルポートを有効化しなければなりません。
この部分は、ここに詳しく記述しますが、プラットフォーム間での差異があまりありません。

<p>
端末のセッションは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><i>/etc/ttys</i></a>
ファイルによって制御されます。OpenBSD がデバイスに "<tt>login:</tt>" プロンプトを出力する前に、
その端末は <i>/etc/ttys</i> の中で有効化されている必要がありますが、
これはつまり、端末として以外にシリアルポートを使用する他のものがある、ということです。
コンソールとして、キーボードとスクリーンが割り当てられている典型的なプラットフォームでは、
シリアル端末は典型的にはデフォルトで無効化されています。
ここでは、例として i386 プラットフォームを使用します。
この場合、次のようなラインを、

<pre>
     tty00   "/usr/libexec/getty std.9600"   unknown off
</pre>
下記のように編集しなければなりません。
<pre>
     tty00   "/usr/libexec/getty std.9600"   vt100   on secure
</pre>

ここで、<tt>tty00</tt> はコンソールとして使用するシリアルポートです。
"<tt>on</tt>" は、このシリアルポートが "<tt>login:</tt>" プロンプトを出力できるよう、これ用の
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8"><i>getty</i></a>
を有効にするためのものです。また、"<tt>secure</tt>" は、このコンソールからの
root (uid 0) としての login を許可するための設定 (このような設定を望むかも知れないし
望まないかも知れませんね) で、そして、"<tt>9600</tt>" は端末のボーレートです。
システムがシングルユーザモードで実行されていて、login に <i>getty</i> を使用しない場合には、
このようなステップを実行しなくても、インストール用にシリアルコンソールを使用することが
可能であるということに注意してください。

<p>
いくつかのプラットフォームにおいて、その設定によっては、シリアルコンソールを
すべて有効化するかどうかの変更を行うためには、シングルユーザモードで起動する
必要があります。

<h3>i386</h3>
コンソールとしてシリアルポートを使用するよう、
ブートプロセスを導くため、以下の行を含むよう、
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386">/etc/boot.conf</a></i>
ファイルを生成/編集してください。
<pre>
     set tty com0
</pre>

これは、コンソールとして最初のシリアルポートを使用するための設定です。
デフォルトのボーレートは 9600bps ですが、これは <i>/etc/boot.conf</i> の stty
オプション行で変更することもできます。
このファイルは、インストールフロッピーを含むブートドライブに置かれるものですが、
一時的な (あるいは最初の) シリアルコンソールの使用のため、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">OpenBSD
第二ステージブートローダ</a> の出力する <tt>boot&gt;</tt> プロンプトで入力されるコマンド
とすることもできます。


<p>
<h4>i386 の注意事項</h4>
<ul>
<li>OpenBSD ではシリアルポートは <i>tty00</i> から始まりますが、
DOS/Windows ではこれらは <i>COM1</i> から始まります。ですので、たとえば、
<i>tty02</i> は <i>COM3</i> であり、<i>COM2</i> ではないことに注意してください。

<li>いくつかのシステムでは、マシンにビデオカードがなくても運用可能かも知れませんが、
すべてのマシンがそうではありません。多くのシステムでは、これはエラーになると
考えられます。また、いくつかのマシンでは、キーボードが接続されていない場合でさえ、
簡単に動作を中止するでしょう。

<li>いくつかの i386 システムでは、シリアルポートをコンソールデバイスとして使用できるようになっています。
その結果は多岐にわたるはずですが、それは、オペレーティングシステムがいったんブートしてしまったら、
このポートが有効ではないかも知れず、その場合には、ふたつのシリアルポートでモニタリングすることを
要求されるからです。

<li>PC 互換機は、いくつかの他のプラットフォームのように、
シリアルコンソールで運転できるようには設計されていません。
BIOS の設定オプションとして、通常ならシリアルコンソールを
サポートしているようなシステムでさえ、設定情報が壊れているかも知れないので、
システムが標準的なモニタとキーボードを探そうとしているのを見ることになるかも
知れません。そのため、i386 システムでは非常用にモニタとキーボードとを
一般的には用意すべきでしょう。

<li><i>/etc/ttys</i> を 
<a href="#SerContty">上記</a>のように編集する必要があります。

<li>i386 では最初のシリアルポート (com0) だけがコンソールとしてサポートされます。

</ul>


<h3>SPARC および UltraSPARC</h3>
これらのマシンは、シリアルコンソールで完璧にメンテナンスできるよう
設計されています。マシンから単純にキーボードを除去しても、システムは
シリアルで動作し続けます。

<h4>SPARC および UltraSPARC の注意事項</h4>
<ul>
<li>SPARC のシリアルポートは、<i>ttya</i>、<i>ttyb</i>
などと名付けられます。

<li>他のいくつかのプラットフォームとは異なり、シリアルコンソールを使用するのに、
<i>/etc/ttys</i> に対するいかなる変更も不要です。

<li>SPARC/UltraSPARC システムは、コンソールポート上の BREAK シグナルを
STOP-A コマンドと同様のものとして解釈し、システムを Forth のプロンプトに
戻し、その時点ですべてのアプリケーションとオペレーティングシステムを停止させます。
そのように意図している限りは、これは便利ではありますが、不運にもいくつかの
シリアル端末は、電源断の際、および、いくつかの RS-232 のスイッチングデバイスが
コンピュータに何かを送信するのを、BREAK シグナルと解釈してしまうので、マシンが
halt してしまうことになります。製品を採用する前にテストしましょう。

<li><tt>ok</tt> プロンプトで以下のコマンドを入力することで、
キーボードとモニタを接続している場合でさえ、これらに代えて
強制的にシリアルコンソールを使用することが可能です。
 <pre>
     ok <b>setenv input-device ttya</b>
     ok <b>setenv output-device ttya</b>
     ok <b>reset</b>
 </pre>
もし、キーボードとモニタ (ttyC0) が <i>/etc/ttys</i> で有効化されている場合
(<a href="#SerContty">上記</a>) には、キーボードと X のモニタを使用する
こともできます。
</ul>

<h3>MacPPC</h3>
MacPPC マシンの場合、OpenFirmware を通じてシリアルコンソールが使用可能です。
以下のようなコマンドを使用してください。
 <pre>
     ok <b>setenv output-device scca</b>
     ok <b>setenv input-device scca</b>
     ok <b>reset-all</b>
 </pre>
シリアルコンソールは 57600bps、8N1 に設定します。

<h4>MacPPC の注意事項</h4>
<ul>
<li>不運にも、ほとんどの MacPPC では、シリアルコンソールは直接的に可能なわけでは
ありません。これらのマシンのほとんどがシリアルハードウェアを持っているにも関わらず、
マシンの外部へのアクセスができないのです。しかし、幸運にも、2 〜 3 の会社が
マッキントッシュのいくつかのモデルに対して、シリアルコンソール (または、他の用途)
に使用できるよう、このポートを有効にするための追加デバイスを出しています。お好きな
検索エンジンを使用して、"Macintosh internal serial port" を検索してみてください。

<li>マルチユーザモードでブートし、シリアルコンソールが機能する前に、
シングルユーザモードで、<a href="#SerContty">上記</a>に示したように、
<i>/etc/ttys</i> の中の <tt>tty00</tt> を <tt>on</tt> に変更し、
通信速度をデフォルトの 9600 から 57600 にセットしなければならないでしょう。</ul>


<h3>Mac68k</h3>
シリアルコンソールは、<i>Booter</i> プログラムの "<tt>Options</tt>" プルダウン
メニューの "<tt>Serial Ports</tt>" サブメニュー中で選択されます。"Serial Console"
ボタンをチェックし、モデムまたはプリンタポートを選択します。
マッキントッシュのシリアルポートに接続するためには、マック用のモデムまたはプリンタ
ケーブルが必要となります。これをデフォルトにしたい場合には、Booter プログラムに
対して、オプションを保存するよう指示します。


<h4>Mac68k の注意事項</h4>
<ul>
<li>モデムポートは <i>tty00</i> であり、プリンタポートは <i>tty01</i> です。

<li>Mac68k では、呼び出されるまでシリアルポートは使用可能にはなりませんので、
OpenBSD のブートプロセスが開始されるまでは、マックのシリアルポートのすべての
シグナルは、ブレークアウトボックスは一切のシグナルを見せないかも知れません。

<li>ポート (<i>tty00</i> または <i>tty01</i>) は、
<a href="#SerContty">上記</a>のように有効化する必要があります。 </ul>

<a name="Blanker"></a>
<h2>7.8 - コンソールを消すにはどのようにすれば良いのでしょう ? (wscons)</h2>
X を使用していない状態で、
一定期間使用していないコンソールを消したい場合には、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a>
に以下のような変数を指定して変更することができます。

<ul>
<li><b><tt>display.vblank</tt></b> を <tt>on</tt> にセットすることで、
垂直同期信号を無効化しますが、これによって、多くのモニタは
「省電力」モードに移行します。このモードは、スクリーンを元に戻すのに
より多くの時間を要しますが、電力消費量が減少し、より新しいモニタでは
熱の発生量も減少します。これを <tt>off</tt> にセットした場合には、
スクリーンは消えますが、モニタは通常の水平および垂直同期信号を
受け続けていますので、スクリーンはほとんどすぐに元に戻ります。

<li><b><tt>display.screen_off</tt></b> は、ディスプレイが消えるまでの
時間をミリ秒単位で指定します。たとえば、60000 を指定した場合には、
1 分を指定したことになります。

<li><b><tt>display.kbdact</tt></b> は、キーボードの操作でスクリーンを
元に戻すかどうかを指定します。通常は、このような動作が望まれます。

<li><b><tt>display.outact</tt></b> は、スクリーンへの出力によって
スクリーンを元に戻すかどうかを指定します。
</ul>

これらの変数は、コマンドラインで
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a> 
コマンドを使用して以下の例のように指定します。
<pre>
     # <b>wsconsctl -w display.screen_off=60000</b>
     display.screen_off -> 60000
</pre>

または、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl.conf&amp;sektion=5"><i>/etc/wsconsctl.conf</i></a>
ファイルを以下の例のように編集することによって、次回のブート以降、いつも効果が得られるようになります。

<pre>
     display.vblank=on               # enable vertical sync blank
     display.screen_off=600000       # set screen blank timeout to 10 minutes
     display.kbdact=on               # Restore screen on keyboard input
     display.outact=off              # Restore screen on display output
</pre>

このスクリーンセーバは、<tt>display.kbdact</tt> か <tt>display.outact</tt>
のいずれかに "<tt>on</tt>" を指定することによって有効になります。

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "../faq6.html">[6 章 - ネットワーキング]</a>
<a href= "faq8.html">[8 章 - 一般的な質問]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a> 
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq7.html,v 1.56 ]
<br>
$Translation: faq7.html,v 1.25 2003/11/24 14:24:07 toshi Exp $
<br>
$OpenBSD: faq7.html,v 1.24 2003/11/24 15:31:14 horacio Exp $
</small>
</body>
</html>
