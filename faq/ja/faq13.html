<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>13 - Using IPsec</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 2000-2003 by OpenBSD">
</head>

<body bgcolor= "#ffffff" text= "#000000">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "faq12.html">[12 章 - 高度なユーザ向け]</a>
<a href= "faq14.html">[14 章 - OpenBSD のハードディスク]</a>
</font>

<h1><font color="#e00000">13 - IPsec (IP Security Protocol) を使う</font></h1>
<hr>
 
<p>
<h3>目次</h3>
<ul>
<li><a href="#What"     >13.1 - IPsec とは何でしょう ?</a>
<li><a href="#Why"      >13.2 - それはすごい。しかし、なぜ IPsec を使う必要があるのでしょう ?</a>
<li><a href="#Protocols">13.3 - IPsec の裏にあるプロトコルは ?</a>
<li><a href="#Wire"     >13.4 - ネットワーク上のパケットフォーマット</a>
<li><a href="#Config"   >13.5 - IPsec の設定</a>
<li><a href="#ManKey"   >13.6 - IPsec を手動鍵設定で使うには ?</a>
<li><a href="#isakmpd"  >13.7 - isakmpd のセットアップは ?</a>
<li><a href="#x509"     >13.8 - isakmpd を X.509 証明書と使用するには ?</a>
<li><a href="#IKEcl"    >13.9 - IKE クライアントで isakmpd と互換性があるのは ?</a>
<li><a href="#Trouble"  >13.10 - IPsec/VPN のトラブルシューティング</a>
<li><a href="#SeeAlso"  >13.11 - 関連ドキュメンテーション</a>
</ul>

<p>
<font size="-1">
このドキュメントの一部は、以下のドキュメントから取ってきています。
</font>
<ul style="font-size: small">
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&sektion=4&format=html">ipsec(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vpn&sektion=8&format=html">vpn(8)</a>
<li><a href="http://www.freebsd.org/~julian/IPSEC_4_Dummies.html">IPsec for Dummies</a> by Julian Elischer
<li><a href="http://www.secureops.com/vpn/vpn.html">ISAKMP Howto</a> by Patrick Ethier
<li><a href="http://hem.passagen.se/hojg/isakmpd/">X.509v3 certificates with isakmpd</a> by J&ouml;rgen Granstam
</ul>

<hr>

<p>
<a name= "What"></a>
<a name= "13.1"></a>
<h2>13.1 - IPsec とは何でしょう ?</h2>

<p>
IPsec は、IP プロトコルファミリーに対する拡張であり、
暗号セキュリティサービスを提供するものです。このサービスで、認証、
完全性 (integrity)、アクセス制御、機密性が提供されます。IPsec は
SSL と似たサービスを、ネットワーク層で提供しており、しかもアプリケーションには
完全に透過的で、しかもずっと強力なものです。透過的とは、IPsec を使用する上で、
アプリケーションは IPsec のことを何ひとつ知らなくて良い、
ということです。
IPsec 上では<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/protocols?rev=1.13">あらゆる IP プロトコル</a>を使用可能です。暗号化トンネル (VPN) も作成可能ですし、コンピュータ間で単純な暗号化をすることもできます。
ただ、オプションが実にいろいろあるために、IPsec は少し複雑かも知れません (それも SSL よりずっと !)。

<p>
IPsec を使う前に、
FAQ <a href="../faq6.html">6 章</a>の推奨文献には
ぜひ目を通しておいてください。特に、もし IP アドレスの考え方がわかっていないのでしたら、
<a href="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">Understanding
IP Addressing</a> (または、
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">ここ</a>)
を特に推奨します。

<p>
論理的には、IPsec は以下のどのような形でも機能します。

<ul>
<li>Host-to-Host
<li>Host-to-Network
<li>Network-to-Network
</ul>

<p>
ネットワークの関係するすべてのシナリオで、私たちはルータを念頭に置いています。
つまりは Host-to-Router (そしてこのルータは、ある<i>Network</i>の
トラフィックを制御して暗号化します)。

<p>
これから見るように、IPsec は VPN 接続用にトラフィックをトンネルすることができます。
でも、その応用は VPN よりはるかに広いものです。中央インターネット鍵交換登録所があれば、
インターネット上の全マシンは、お互いにやり取りする際に
強力な暗号や認証が使用可能になるのです !

<p>
<a name= "Why"></a>
<a name= "13.2"></a>
<h2>13.2 - それはすごい。しかし、なぜ IPsec を使う必要があるのでしょう ?</h2>

<p>
インターネットのプロトコルである IP または IPv4 は、それ自体としては、転送しているデータに対して何の保護も提供しません。
送信元が、自分で名乗っているとおりの存在かどうかすら保証してくれないのです。
IPsec はこれを解決しようとします。以下のサービスはそれぞれ独立と考えられていますが、
IPsec はそれを統一的な形でサポートしています。

<p>
<h4>機密性</h4> 受信者以外の人には、どのようなデータが通信されたかを
理解しにくいようにしておきます。たとえば、インターネット経由で
リモートのマシンにログインする際に、パスワードのセキュリティを
保証します。

<p>
<h4>完全性 (Integrity)</h4> データが途中で改竄されないようにします。
請求書データをオンラインで送信する場合に、
数量や金額やアカウント番号が正確で、
途中で改竄されたりしていないかどうかを確認したいはずです。

<p>
<h4>Authenticity (正真性／確実性)</h4> データに署名して、それを送信したのが本当にあなただと他の人が
確認できるようにします。ドキュメントが改竄されていないことが確認できるのは、
明かに良いことでしょう。

<p>
<h4>再送保護 (Replay protection)</h4> やり取りは、何度受信されたかに関係ないもの以外、
データグラムの処理が確実に一回だけしか行われないようにする方法が必要です。
つまり、攻撃者が (銀行口座からの引き出しのような) トランザクションを記録し、
それをそのまま再送して、(引き出し要求の) 新しいメッセージを受信したと
相手に思わせるようなことができてしまうようではいけません。
<i>警告: 通常の仕様に関する限り、手動鍵の IPsec を使用している場合
(たとえば
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;sektion=8">ipsecadm(8)</a>)</i>
を使用している場合) には、再送からの保護は実行されません</i>。

<p>
<a name= "Protocols"></a>
<a name= "13.3"></a>
<h2>13.3 - IPsec の裏にあるプロトコルは ?</h2>

<p>
IPsec は、機密性、完全性、authenticity (正真性)、再送保護を提供するのに、
新しいプロトコルを 2 つ使用します。そのプロトコルとは、認証ヘッダ (AH:
Authentication Header) と暗号ペイロード (ESP: Encapsulating Security Payload) です。

<p>
AH は認証と完全性と再送保護を提供します (が、機密性は提供しません)。
認証機能についての AH と ESP との主な差は、AH はパケットの
IP ヘッダの一部 (たとえばパケットの送信元・送信先アドレス) も
認証するのに対して、ESP はパケットのペイロードのみを認証する
ということです。

<p>
ESP は認証、完全性、再送保護、データ機密性を
提供します (ヘッダに続くパケット内のすべてを保護します)。
再送保護には認証と完全性が必要です
(このふたつは必ず対となるものです)。機密性 (暗号化) は、
認証/完全性の有無に関わらず使用可能です。
同様に、認証/完全性は機密性なしでも使用できます。

<p>実際には、ほとんどのアプリケーションに対して ESP の使用が推奨されています。

<p>
<a name= "Wire"></a>
<a name= "13.4"></a>
<h2>13.4 - ネットワーク上のパケットフォーマット</h2>

<p>
<b>認証ヘッダ (Authentication Header)</b>
(AH) は基本的な IP ヘッダの後にきて、データの暗号ハッシュと
識別情報を持っています。ハッシュは 
IP ヘッダ自体の、伝送中に値が変化しない部分もカバーできます。
AH に使う実際のアルゴリズムについては、いくつかの個別の RFC があって選択可能になっていますが、
そのいずれについても、<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2402.html">RFC2402</a> に指定されたガイドラインには準拠していなくてはならない。

<p>
<b>暗号ペイロード (Encapsulating
Security Payload)</b> (ESP) ヘッダは、ペイロードを暗号化された形で書き換えることを可能にします。
ESP ヘッダは、それに先立つ IP
ヘッダは扱いませんので、ペイロード以外のものについてはまったく保証しません。
それぞれ各種の ESP は <a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2406.html">RFC2406</a> に従う必要があります。
ESP ヘッダは、ペイロードの認証も提供できます (が、ESP の外の
ヘッダについては認証できません)。

<p>
IPsec 機能の直交性の (ほとんどの) 部分は、IPsec カプセル化を
実行する終端がデータの元の発信源なのかゲートウェイなのかに
応じて適用されます。

<ul>
<li><b>Transport</b> モードは、パケットを生成しているホストが使用するものです。
Transport モードでは、セキュリティヘッダはトランスポート層 
(e.g . TCP, UDP) のヘッダの前に、IPヘッダがパケットの先頭に付与される前の段階で追加されます。
言い換えれば、パケットに追加された AH が
TCP ヘッダと、end-to-end IP ヘッダの一部フィールドのハッシングを担当するということなのです。
そして、TCP ヘッダとデータの暗号化は ESP ヘッダがカバーしますが、しかし、
それは end-to-end IP ヘッダまで暗号化してくれるわけではありません。

<li><b>トンネル</b>モードは、すでに end-to-end IP ヘッダが
パケットに追加されている場合に、さらにセキュア接続の片方の端が
単なるゲートウェイの場合に使用されます。このモードでは、AH と ESP ヘッダは、 end-to-end header を含め、
パケット全体をカバーするのに使用されます。そして、セキュア接続の向こうの端までのホップのみ
(ただし、これはもちろん複数の IP ホップをまたがっているかも知れません) をカバーする、
新しい IP ヘッダが付け直されます。
</ul>

<p>IPsec で保護されたリンクは、<b>Security Associations
</b>(SAs) によって定義づけられます。各 SA は単一の単方向のデータの流れについて定義されており、
普通は (マルチキャストは無視して) ひとつの点から別の点までについて、何らかの
<b>ユニークなセレクタ</b>によって識別できるトラフィックフローを指します。単一の SA 上を流れるトラフィックは
すべて同じ扱いを受けます。トラフィックの中には、複数の SA を経るものもあって、
そのそれぞれが何らかの変換を加えます。また、SA の集団を SA <b>Bundle</b> と呼びます。
入ってくるパケットは、3 つの定義フィールド (<b>宛先 IP アドレス、セキュリティパラメータインデックス
(Security Parameter Index)、セキュリティプロトコル</b>) に応じて指定の SA に割り当てることができます。
セキュリティパラメータインデックス (Security Parameter Index、略して SPI) は、
接続のパラメータのネゴシエーションが行われる際に、SA の受け手が手渡すクッキーだと思えば良いでしょう。
また、セキュリティプロトコルは、AH か ESP のどちらかでなくてはなりません。受け手の IP アドレスが
この 3 つ 1 組の中に含まれていますので、これはユニークな値になることが保証されています。
これは外側の IP ヘッダから見つけることもできますし、最初のセキュリティヘッダ
(これは SPI とセキュリティプロトコルを含む) から見つけることもできます。

<p>
以下にトンネルモードの AH パケットの例を挙げます。

<p>
<table border="1">
<tr>
<td><b>IPヘッダ</b></td>
<td><b>AH</b></td>
<td>IPヘッダ2</td>
<td>TCPヘッダ</td>
<td>データ</td>
</tr>
</table>

<p>
また、transport モード AH パケットの例を挙げます。

<p>
<table border="1">
<tr>
<td><b>IPヘッダ</b></td>
<td><b>AH</b></td>
<td>TCPヘッダ</td>
<td>データ</td>
</tr>
</table>

<p>
ESP ヘッダは外側の IP ヘッダを認証できませんので、
AH と ESP ヘッダを組み合わせて以下のようにすべきでしょう。

<p>
<table border="1">
<tr>
<td><b>IPヘッダ</b></td>
<td><b>AH</b></td>
<td><b>ESP</b></td>
<td><i>TCPヘッダ</i></td>
<td><i>データ</i></td>
</tr>
</table>

<p>これは <b>Transport Adjacency</b> と呼ばれるものです。
トンネル版の場合には、以下の例のようになります。

<p>
<table border="1">
<tr>
<td><b>IPヘッダ</b></td>
<td><b>AH</b></td>
<td><b>ESP</b></td>
<td><i>IPヘッダ2</i></td>
<td><i>TCPヘッダ</i></td>
<td><i>データ</i></td>
</tr>
</table>

<p>
しかし、これは RFC には明示的に記述されてはいません。Transport
adjacency と同様に、これはIP ヘッダの中のヘッダいくつかを除いて全パケットを認証した上で、
ペイロード (イタリックで表示) を暗号化します。
AH と ESP ヘッダがこのように直接同時に適用されている場合には、
ヘッダの順番は上記のようになっている必要があります。トンネルモードでは、
任意の再帰的なカプセル化を行うことで、この順番が指定されないようにすることも可能です。

<p>
<a name= "Config"></a>
<a name="13.5"></a>
<h2>13.5 - IPsec の設定</h2>

<p>
IPsec システムとゲートウェイがどのように設定されるかは、ある程度は設計者に任されて
いることではありますが、RFC にはそれがどのように実装されるべきかについての強い推奨があり、
混乱を最小限に抑えようとしています。

<p>
パケットに何が起こるかをコントロールするための管理エンティティが 2 つあます。
ひとつは <b>Security Association Database</b> (SAD、
OpenBSD の IPsec ソースコードの中では、TDB または TDB table と呼ばれるものです) で、
もう一つは<b>Security Policy Database</b> (SPD) です。

<p>
このふたつは、あるトラフィックを表現したセレクタをいくつか与えられると、
必要となる処理を記述したエントリを提供してくれるという点で似ています。
しかし、SPD は実際の処理からは二段階ほど遠いところにあります。
SPD は外へ出るパケットに使用されて、どの SAD エントリを使用すべきか決定するのに利用されます。
逆に SAD エントリは、実際のプロセスとそこで使用されるパラメータを記述します。
SPD のエントリは、既存の SAD エントリのうちのどれを使用するのか
(バンドルなら、SAD エントリは複数あり得ますので) を指定しますが、しかし、既に
適切なものがない場合には、そのエントリを使用して新しいものが作成されます。作成される SA のフィールドは、
SPD エントリから持ってくる場合もありますし、そのフィールド新設を
開始させたパケットから持ってくる場合もあります。

<p>
外行きのパケットは、SPD エントリから個別の SA に行ってエンコーディング用
パラメータを取得します。入ってくるパケットは、SPI/宛先IP/プロトコルの 3 点セットを使用して
直接正しい SA にたどりつき、そこから SPD エントリにたどりつきます。

<p>
SPD はまた、どのトラフィックが IPsec をバイパスすべきか、また、どのトラフィックを
破棄すべきかを指定できますので、入ってくる非 IPsec のトラフィックについても参照されなくてはなりません。
SPD エントリは、順番が明示的に示されている必要があります。あるパケットに複数のものがマッチする可能性がありますし、
処理には再現性がなくてはならないからなのです。

<p>
SPD というのは、パケットフィルタと似たようなものだと思えば良いかも知れません。そこで決定されるアクションは、
SA プロセスの起動になるのです。セレクタとして使用できるのは
送信元と宛先アドレス、関係ある場合にはポート番号、アプリケーションや、ある場合にはユーザ ID
(これは host based transport SA のみ)、ホスト名、セキュリティ
感度レベル、プロトコルなどです。

<p>
SAD エントリに含まれるのはたとえば、

<ul>
<li>宛先 IP アドレス
<li>IPsec プロトコル(AH か ESP)
<li>SPI (クッキー)
<li>シーケンスカウンタ
<li>Seq O/F フラグ
<li>Anti-replay window info
<li>AH の種類と情報
<li>ESP の種類と情報
<li>寿命情報
<li>Tunnel/transport モードフラグ
<li>Path MTU 情報
</ul>

<p>
SPD エントリに含まれるのは、

<ul>
<li>SA起動ポインタ
<li>セレクタフィールド
</ul>

<p>
各 SA は、ESP ヘッダひとつと AH ヘッダひとつとを定義できます。
IPsec セッションはこのどちらか、あるいは両方を持たなければなりません。どちらのヘッダもなしで定義されることは
できければなりません――さもないと、SA を参照するための SPI を指定するヘッダがないことになってしまいます。
RFC は、AH と ESP ヘッダが SPI の値について
別々の指定をしている場合のことは定義していません。
これはバンドル中の複数の SA を意味するものと判断されることが考えられます。

<p>
OpenBSD の SPD は、<tt>ipsecadm flow</tt> コマンドを使用して管理されます
(これに変更を加えるのは、手動鍵設定を使用する場合だけです)。
SAD エントリは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;sektion=8">ipsecadm(8)</a>
を使用すればマニュアルで設定できますが、IETF はセッションや
鍵交換の初期化などの自動メカニズムも定義しています。
OpenBSD は ISAKMP 自動鍵交換
(<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC2407</a>、
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC2408</a> ならびに
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC2409</a>)
を実装していて、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd&amp;sektion=8">isakmpd(8)</a>
デーモンで使用されています。

<p>
a name= "ManKey"></a>
<a name= "13.6"></a>
<h2>13.6 - IPsec を手動鍵設定で使うには ?</h2>

<p>
IPsec の手始めとして最も簡単なのが手動鍵設定です。
この手法でネットワーク間を暗号化して VPN を作れます。
この部分を読んだら、この設定を自動化するのに
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/rc.vpn?rev=1.3">/usr/share/ipsec/rc.vpn</a>
を使用する、ということも実行してみると良いかも知れません。

<p>
まず、OpenBSD カーネルの IP AH と IP ESP オプションが有効になっていることを
確認してください。これはデフォルトで有効化されていますが、以下のようにして
それを確認しておいてください。

<blockquote><tt>
# <b>sysctl net.inet.esp.enable</b><br>
net.inet.esp.enable = 1<br>
</tt></blockquote>

<p>同様に、もし AH が必要なら、以下のようにして有効化されていることを確認してください。
<blockquote><tt>
# <b>sysctl net.inet.ah.enable</b><br>
net.inet.ah.enable = 1
</tt></blockquote>


<p>
もし、必要でしたら、
これらのプロトコルは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
で <i>-w</i> オプションを使用して有効化することができるはずです。

<p>
起動時にこれを有効 (または無効) にするには <tt>/etc/sysctl.conf</tt> を編集します。
使用したいものに応じて、net.inet.esp.enable および/または
net.inet.ah.enable の前の # を外し、それが 1 にセットされている
ことを確かめてください。

<p>
ほとんどの場合、<i>rc.vpn</i> スクリプトや以下の例のように、
ESP だけが要求されることに注意してください。このような場合、
<i>AH を有効にする必要はありません</i>。事際には使用しないのに、AH
を有効にすることに関して、セキュリティ上の懸念があるかも知れません。

<p>
次に、手動鍵の生成も必要になります。
VPN のセキュリティは、この鍵を推定するのが不可能という点にかかっていますので、
この鍵を選ぶのには強力な乱数源を使用するということが大変重要なのです。
これを生成するのに実用性が高い方法のひとつとして、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=random&amp;sektion=4">random(4)</a>
デバイスを使用する方法があります。たとえば、160 ビット (20 バイト) 分の乱数性を作成するには、以下のようにします。

<blockquote><tt>
# <b>openssl rand 20 | hexdump -e '20/1 "%02x"'</b>
</tt></blockquote>

<p>
生成されるビット数は重要です。暗号の種類によって、必要な鍵のサイズは異なります。

<pre>
暗号方式    鍵長
DES       56 bits
3DES      168 bits
BLF       可変 (160 bits 推奨)
CAST      可変 (40-128 bits 推奨)
SKIPJACK  80 bits
</pre>

<p>
では、SA (Security Associations) の設定をしましょう。
Security Association とは、IP アドレス、SPI、
セキュリティプロトコル (AH および/または ESP) の組み合わせです。IP アドレスは、あなた自身のものと、
送信先のものとの両方です。SPI (Security Parameter
Index) は各種 SA の分類に OpenBSD が使う番号のことです。

<p>
<i>これらの例は、トラフィックの暗号化に ESP しか使用しません。ESP は
暗号化された中身のデータの認証は行いますが、AH とは異なり、
それを包む IP ヘッダまでは認証しません。この「限られた認証」でも、
ほとんどの場合にはまったく十分なものでしょう。特にトンネル環境での
ESP の場合にはそうです。</i>

<blockquote><tt>
# <b>ipsecadm new esp -spi SPI_OUT -src MY_EXTERNAL_IP -dst PEER_EXTERNAL_IP
-forcetunnel -enc blf -auth sha1 -key ENC_KEY -authkey AUTH_KEY</b>
</tt></blockquote>

<p>
これをふたつのルータ 192.168.5.1 と 192.168.25.9 に実際に設定してみましょう。

<p>
ホスト 192.168.5.1 上では:

<blockquote><tt>
# <b>ipsecadm new esp -spi 1000 -src 192.168.5.1 -dst 192.168.25.9 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -spi 1001 -dst 192.168.5.1 -src 192.168.25.9 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b>
</tt></blockquote>

<p>
ホスト 192.168.25.9 上では:

<blockquote><tt>
# <b>ipsecadm new esp -spi 1001 -src 192.168.25.9 -dst 192.168.5.1 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -spi 1000 -dst 192.168.25.9 -src 192.168.5.1 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b>
</tt></blockquote>

<p>
SPI が異なっていることに注意してください。SPI が何であり、それがどこで使用されるのかについての完全な説明は、<a href="#13.4">On the wire format</a> を参照してください。

<p>
これで Security Associations が作成されたので、
フローを設定します。

<p>
まずは 192.168.5.1 です。

<p>
さてここでいきなり、フローが<b>ふたつ</b>作成されます。ひとつはローカルのソースアドレスで、
ローカルホストから出て目的地に向かうすべてのパケットをカバーし、
もうひとつのフローは送信先からローカルホストに戻ってくる
フローです。

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 192.168.25.9 -spi 1000 -addr 192.168.5.1 255.255.255.255 192.168.25.9 255.255.255.255</b>
</tt></blockquote>

<p>
次は 192.168.25.9 側です。

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 192.168.5.1 -spi 1001 -addr 192.168.25.9 255.255.255.255 192.168.5.1 255.255.255.255</b>
</tt></blockquote>

<p>
もし、Host-to-Host VPN のオーバーヘッドを減らしたい場合には、SPI を作成するのに
<tt>-forcetunnel</tt> を外しておくと、transport モードが使用できます (<tt>-forcetunnel</tt>
を使用すると IP ヘッダまで含んだ IP パケットのすべてが必ず SPI にカプセル化
されます)。もし、
発信元か送信先のどちらかがネットワークの場合には、トンネルモードを使用するしかありません。
ネットワークから出入りするトラフィックに SA を使用すると、自動的に
トンネルモードの SPI が確実に作成されることになります。

<p>
これは IPsec を使い始める簡単な方法です。

<p>
IPsec を使えば、プライベート IP アドレス空間をインターネット経由で接続可能です。
良い例を挙げましょう……  208.1.1.1 の背後にある 192.168.99.0/24 と、
208.2.2.2 の背後にある 208.1.5.0/24 と 208.1.2.0/24 とをトンネルで接続するとします。
以下の例は <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/rc.vpn?rev=1.3">rc.vpn</a> スクリプトを使用して生成したものです。

<p>
ご覧のとおり、IPsec を手動鍵設定で使用していると、
実行して欲しいことを<b>すべて正確に</b>指定しなければなりません。
あなたのかわりに見当をつけてくれたりはしないのです。以下の例を見てください。


<h2>208.1.1.1 の側では:</h2>
まず、security associations (SA) を設定します。<br>
(これで SPI、暗号化の方法と鍵が設定されます)。

<blockquote><tt>
# <b>ipsecadm new esp -src 208.1.1.1 -dst 208.2.2.2 -forcetunnel -spi 1001 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -src 208.2.2.2 -dst 208.1.1.1 -forcetunnel -spi 1000 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
</tt></blockquote>

<p>
次に、208.1.1.1 から 208.2.2.2 へのフローを設定：

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.2.2.2 255.255.255.255</b><br>
</tt></blockquote>

<p>
次に  208.2.2.2 の背後にある 208.1.2.0/24 から 192.168.99.0/24 へのフローを設定：

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.1.2.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
次に 208.2.2.2の背後にある 208.1.5.0/24 から 192.168.99.0/24 へのフローを設定：

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.1.5.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
そして、208.2.2.2 の背後にある 208.1.2.0/24 からルータ 208.1.1.1 へのフローを設定：

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.1.2.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
そして、208.2.2.2の 背後の 208.1.5.0/24 からルータ 208.1.1.1 へのフローを設定:

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.1.5.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
最後に、ルータ 208.2.2.2 から 192.168.99.0/24 へのフローを設定します。

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.2.2.2 255.255.255.255</b><br>
</tt></blockquote>


<h2>208.2.2.2 側では:</h2>

<p>
前と同様に、まずは SA の設定からです。

<blockquote><tt>
# <b>ipsecadm new esp -src 208.2.2.2 -dst 208.1.1.1 -forcetunnel -spi 1000 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -src 208.1.1.1 -dst 208.2.2.2 -forcetunnel -spi 1001 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
</tt></blockquote>

<p>
さて、こちらは裏返しになるので、
ルータ 208.2.2.2 から 208.1.1.1 へのフローを設定：

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.2.2.2 255.255.255.255 208.1.1.1 255.255.255.255</b><br>
</tt></blockquote>

<p>
208.1.1.1 の背後にあるネットワーク 192.168.99.0/24 から 208.1.2.0/24 へのフローを設定：

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.2.0 255.255.255.0 192.168.99.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
208.1.1.1 の背後にあるネットワーク 192.168.99.0/24 から 208.1.5.0/24 へのフローを設定：

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.5.0 255.255.255.0 192.168.99.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
では 208.1.1.1 の背後の 192.169.99.0/24 からルータ 208.2.2.2 へのフローを設定：

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.2.2.2 255.255.255.255 192.168.99.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
これでほぼ終了です。後は、
208.1.2.0/24 と 208.1.5.0/24 をルータ 208.2.2.2 から 208.1.1.1 まで届けるのに、
残りのフローはふたつだけです。

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.2.0 255.255.255.0 208.2.2.2 255.255.255.255 -ingress</b><br>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.5.0 255.255.255.0 208.2.2.2 255.255.255.255 -ingress</b><br>
</tt></blockquote>

<p>
ipsecadm を使用していて、自分の行った作業をすべてご破算にして
一からやり直したければ、次のようにします。

<blockquote><tt>
# <b>ipsecadm flush</b>
</tt></blockquote>

<p>
これですべての IPsec 情報 (SPI、フロー、ルーティングのエントリ) がシステムから一掃されます。


<p>
<a name= "isakmpd"></a>
<h2>13.7 - isakmpd の設定は ?</h2>

<p>
VPNs をはじめ IPsec の各種伝統的なアプリケーションを考えているのでしたら、
おそらく ISAKMP を使用することになります。IPsec の一部の商業実装では、
手動鍵設定を使用することができませんので、
何らかの形の ISAKMP を使用するしかありません。


<p>
<h3>13.7.1 - isakmpd とは ?</h3>

<p>
ISAKMP とは Internet Security Association and Key Management Protocol のことです。
これは、IKE あるいはインターネット鍵交換 (Internet Key Exchange) と呼ばれることもあります。
これは、IPsec 用の標準鍵交換メカニズムです。これは、
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC 2407</a>、
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC 2408,</a>
ならびに
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC 2409</a>
に記述された手法を使用して、セキュリティの問題をクリアしています。
ISAKMP は、通常なら
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;sektion=8">ipsecadm(8)</a>
を使用しなくてはならないような暗号鍵のやり取りを管理してくれます。
これは、ふたつの IPsec ノード間で IPsec パラメータを確立するために、
二段階プロセスを採用しています。

<p>
<b>フェーズ 1</b> - ISAKMP ピアふたつは、保護され認証されたチャネルを確立し、
ふたつのデーモン間で通信ができるようにします。これは
両ホスト間で Security Association (SA) を確立します。このチャネルを確立するための手法には、
<b>Main Mode</b> と <b>Aggressive Mode</b> とがあります。
Main Mode は各種認証情報を
特定の順番で送り、アイデンティティの保護を提供します。また、Aggressive Mode は
アイデンティティ保護は提供しません。これは、認証情報を
すべて一気に送信するためですが、この Aggressive mode を使用するのは、
盗聴者に対して識別情報を暴露することになってしまうことがありますので、
ネットワークの帯域幅が狭いときだけにしたほうが良いでしょう。

<p>
<b>フェーズ 2</b> - IPsec のために Security Associations のネゴシエーションが行われます。
フェーズ 2 では、IPsec ホスト間にトンネルか endpoint SA を確立します。また、
フェーズ 2 では <b>Quick Mode</b> が使用されます。これは、フェーズ 1 で
既に SA が確立していますので、完全な認証をくり返さなくても良いからなのです。

<p>
手短にいえば、フェーズ 1 は保護されたチャネルを確保するのに使用され、そこで
(より素早い) フェーズ 2 の設定が行われるのです。同じフェーズ 1 チャネルの中で、
複数のフェーズ 2 設定をすることもあります。そして、このフェーズ 2 は、実際の
トンネルを設定するのに使用されます。
フェーズ 1 では IPsec ノード同士が接続を確立して認証を交換します (X.509 証明か、
事前に共有した秘密鍵のいずれか)。これで両端とも、相手が認証されたことを
確認できます。フェーズ 2 は鍵の交換で、両者の間のデータが
どのように暗号化されるかを決定します。

<h3>13.7.2 - isakmpd ことはじめ</h3>

<p>
デフォルトで OpenBSD には、ISAKMP と IPsec スタック用として必要となる
すべてのバイナリが附属しています。サンプルの設定ファイルは
<tt>/usr/share/ipsec/isakmpd</tt> にあります。
この例で使用するのに、<i>policy</i> を
<tt>/etc/isakmpd/isakmpd.policy</tt> をコピーし、<i>VPN-east.conf</i> を
<tt>/etc/isakmpd/isakmpd.conf</tt> にコピーしてください。
ここでは、VPN (トンネル) の設定の仕方を説明します。
isakmpd を個別ホスト間で使用する場合には、<i>samples</i> ディレクトリにそのためのサンプルが
入っています。man ページに詳しい情報がありますので、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a> と
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&amp;sektion=5">isakmpd.policy(5)</a>
も忘れずに参照してください。

<p>
デフォルトではカーネルで AH と ESP の両方が有効になっているのですが、
FAQ セクションの <a href="#ManKey">Manual Keying</a> の概要にある手続きによって、
必要とするプロトコルが有効化されていることを確認しておいてください。
次に、<tt>/etc/isakmpd/isakmpd.policy</tt> を編集してください。
このファイルは ISAKMP に、誰が IPsec にアクセスできるのかを教えるためのものです。このシナリオでは、
この policy ファイルは、Encapsulating Security Payload (ESP) を使用してデータを送信してきて、
<i>mekmitasdigoat</i> というパスワード (これはあなたが自由に決めてください) で認証された相手なら、
誰でも isakmpd と通信できることが記述されています。特定のデジタル証明書で署名されたデータだけを認めたり、
特定の暗号変換を使用したデータだけを認めたりすることを、ISAKMP に伝えるため、このファイルを変更することが
できます。また、誰もが IPsec を使用できるようにすることもできます。もちろん、これはテストのためだけに
すべきですが、もし、そのようにしたい場合には、policy ファイルを編集して以下の記述だけにします。

<blockquote><pre>
KeyNote-Version: 2
Authorizer: &quot;POLICY&quot;
</pre></blockquote>

<p>
同じ policy ファイルには $ のついた行が二行あります。使用する前に、
これらの二行は削除する必要があります。これらの行は、CVS が使用していたものです。

<p>
より便利な policy ファイルは以下の例のようなものでしょう。

<blockquote><pre>
KeyNote-Version: 2
Comment: この policy は正しいパスワードを使うリモートからの ESP SA を受け付ける
Authorizer: &quot;POLICY&quot;
Licensees: &quot;passphrase:mekmitasdigoat&quot;
Conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; -&gt; &quot;true&quot;; 
</pre></blockquote>

<p>
これを実装することにより、ESP だけを使用した基本的な VPN (トンネル) を作成することができます。
ホスト A では <tt>/etc/isakmpd/isakmpd.conf</tt> を編集します。見本に入っている 249.2.2.2 という IP アドレスは、
ホスト A の実際の外部 IP アドレスに書き換えてください。

<blockquote><pre>
[General] 
Retransmits=		5
Exchange-max-time=	120
Listen-on=		249.2.2.2
</pre></blockquote>

<p>
同様にして、ホスト B の isakmpd.conf にも設定します。ここで、249.3.3.3 は
ホスト B の外部 IP アドレスです。

<blockquote><pre>
[General]
Retransmits=		5
Exchange-max-time=	120
Listen-on=		249.3.3.3
</pre></blockquote>

<p>
ここで isakmpd の主な挙動を決定する変数を設定できる。ここでは
デフォルトを使用すれば良いでしょう。
<b>Listen-on</b>= value は、isakmpd がリスンすべき IP アドレス
を指定します。あなたのゲートウェイのインターネット IP だけが必要となります。
ゲートウェイに複数の外部インターフェイスがある場合には、
カンマで区切った一覧形式で入力して、どのインターフェイスをリスンすべきかを一覧にできます。

<p>
次にホスト A で、もう一度 isakmpd.conf を編集します。

<blockquote><pre>
[Phase 1]
249.3.3.3=		HostB
</pre></blockquote>

<p>
ホスト B では以下のようになります。

<blockquote><pre>
[Phase 1]
249.2.2.2=		HostA
</pre></blockquote>

<p>
この部分は、フェーズ 1 接続のネゴシエーションの際に受け付けるべき IP アドレスを記述します。
ここでの値は下の部分を指しています (フェーズ 1 は単にリモートのピアを認証して、
それが主張通りの相手だと確認するだけであることに注意してください)。また、
IP_Address=<i> &lt;PEER-NAME&gt;</i> という形式で複数のピアを記述することができます。

<p>
次にホスト A では:

<blockquote><pre>
[Phase 2]
Connections=		HostA-HostB
</pre></blockquote>

<p>
ホスト B では:

<blockquote><pre>
[Phase 2]
Connections=		HostB-HostA
</pre></blockquote>

<p>
これは接続のフェーズ 2 を記述しています。このフェーズは、通信に両
ピアが使うプロトコルを決定するためのものです。

<p>
<b>Connections</b>= タグは、その下のセクションを指します。
フェーズ 2 を設定するために受け入れられるメソッドや要件を開始します。これはまた、
いったん開始したらどの接続を開始すべきかについて ISAKMPD に示しています。
複数のピアホストに接続する場合には、
以下のように複数のセクションを記述可能であることに注意してください。

<p>
リモートホストの IP アドレスがわからない場合には、<b>Connections</b>= タグに
列挙されていない IP からの接続で参照される汎用エントリを、あるセクションに記述しておいて、
それを Default= で指定するようにします。

<p>
ホスト A では:

<blockquote><pre>
[HostB]
Phase=			1
Transport=		udp
Local-address=		249.2.2.2
Address=		249.3.3.3
Configuration=		Default-main-mode
Authentication=		mekmitasdigoat
#Flags=
</pre></blockquote>

<p>
ホスト B では:

<blockquote><pre>
[HostA]
Phase=			1
Transport=		udp
Local-address=		249.3.3.3
Address=		249.2.2.2
Configuration=		Default-main-mode
Authentication=		mekmitasdigoat
#Flags=
</pre></blockquote>

<p>
これらは上で説明したフェーズ 1 の部分で参照されているセクションです。それぞれ
フェーズ 2 に進むためにピアのゲートウェイが満足しなければならない要件を記述しています。他にもオプションは
多数ありますが、上記のものは最低限必要なものです。

<ul>
<li><b>Phase=1 </b>が必要なのは、ISAKMPD のコードがフェーズ 1 とフェーズ 2 を処理するのに
同じプロシージャを使うからで、これを <b>1</b> にしなければ、何ひとつ機能しなくなります。
<li><b>Transport= </b> は、ピアごとに異なる可能性があります。ここでは UDP を使用することになっていますので、
そのままにしておきます。一部のピアはファイアーウォールの背後にあり、UDP トラフィックを通さない場合が
あることに注意してください。当然ですが、これは設定前に確認しておく必要があります。
<li><b>Local-address </b>は入ってくるパケットが指す目的アドレスです。一部のケースでは、
フェーズ 1 の接続のためにリスンするインターフェイスが異なっているかも知れません。
この例では、インターフェイスはひとつしかありませんので、このピアでリスンする
インターフェイスの IP がそれになります。
<li><b>Address= </b>は、入ってくるパケットのソース IP です。これはピアゲートウェイを
指すのが一般的です。この部分はより詳しい説明が必要です。
これは、ピアの発信する IP アドレスは事前にはわからないことがあるからです。
<li><b>Configuration= </b> は、下のセクションを指します。ここに示したような形で
複数のセクションを指定できます。ここではサンプルファイルにあった
デフォルト値を使用します。
<li><b>Authentication=</b> は、このピアが使用するはずの事前に共有している秘密鍵です。
このパスワードが policy に渡され、このピアがこのホストと IPsec を使用して良いかどうかを確認します。
このパスワードを変える場合には、policy ファイルでの記述も変える必要があります。
これは、sample ファイルがこのパスワードに応じて提供されているからです。
最低限の policy ファイルを使用するつもりでしたら、ここでは好きなものを指定してください。
<li><b>Flags=</b> は現在では使用されていません。
RFC では、フェーズ 1 用の追加オプションを指定するための予備としてこれを残しています。
<p>他のオプションを指定するためのタグも多数あります。詳しくは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a>
を参照してください。
</ul>

<p>
ホスト A では:

<blockquote><pre>
[HostA-HostB]
Phase=			2
ISAKMP-peer=		HostB
Configuration=		Default-quick-mode
Local-ID=		Net-A
Remote-ID=		Net-B
</pre></blockquote>

<p>
ホスト B では:

<blockquote><pre>
[HostB-HostA]
Phase=			2
ISAKMP-peer=		HostA
Configuration=		Default-quick-mode
Local-ID=		Net-B
Remote-ID=		Net-A
</pre></blockquote>

<p>
これらは、上記のフェーズ 2 で参照されているセクションを表しています。これは
個別の接続のために、ふたつのゲートウェイ間で話をするのに ISAKMPD が使用すべき
個別設定なのです。

<ul>
<li><b>Phase=2</b> は必須です。ISAKMPD のコードは、フェーズ 1 と
フェーズ 2 の認証に同じ関数を使うからです。これがない場合には VPN は機能しません。
<li><b>ISAKMPD-Peer=</b> は、上でのホストのセクションの名前です。つまり、フェーズ 2 接続を確立するために、
ここで指定したピアと話している、という意味です。これがあるのは、isakmp ピアや接続を記述するのに
複数のセクションがある場合もあるからなのです。
<li><b>Configuration=</b> は、下のセクションで、このホストと接続における指定のピアとが
従うべき規格を記述した部分を指します。
<li><b>Local-ID=</b> は、ピアのゲートウェイへのこのプライベートネットワークを
記述した、以下の IPsec-ID セクションを指しています。この部分が送られることで、対向側のゲートウェイが VPN 経由で
こちらのネットワークにデータを転送するためのルーティングテーブルを正しく設定できるようになります。
<li><b>Remote-ID=</b> は、こちらのホストの対向のリモートのプライベートネットワークであるはずのものを記述した、
下の IPsec-ID セクションを参照しています。こちらのプライベートネットワークから VPN 経由でリモートのプライベート
ネットワークにデータを転送するためのルーティングテーブルを正しく設定するためにこの部分が解釈されます。
<p>ここでサポートされるもうひとつのタグが Flags= です。このタグが必要な場合には、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a> を参照してください。
</ul>

<p>
ここは IPsec-ID セクションです。以下のエントリは、ホスト A とホスト B の
両方の isakmpd.conf ファイルの中に存在していなければなりません。この例の場合、
ホスト A (これは上の Net-A に接続されているものです) では 192.168.1.0/255.255.255.0、
ホスト B (これは上の Net-B に接続されているののです) では 192.168.20.0/255.255.255.0 となります。

<blockquote><pre>
[Net-A]
ID-type=		IPV4_ADDR_SUBNET
Network=		192.168.1.0
Netmask=		255.255.255.0

[Net-B]
ID-type=		IPV4_ADDR_SUBNET
Network=		192.168.20.0
Netmask=		255.255.255.0
</pre></blockquote>

<p>
このふたつのセクションが各ホストの <b>conf</b> ファイルに含まれています。これが <b>Local-ID</b> と <b>Remote-ID</b>
の識別しで参照されるセクションです。ひとつのプライベートネットワークから、別のプライベートネットワークへの
トラフィックを可能にする際に設定されるべき経路が記述されています。<b>ID-type</b>= は <b>IPV4_ADDR_SUBNET</b> か
<b>IPV4_ADDR</b> を記述できます (RFC2708 には他にも有効な値が記述されています。OpenBSD の現状の実装では IPv4 しかサポートされていませんが、IPv6 は OpenBSD-current でサポートされているかも知れません)。
 
<p>
これで両方のホストで、sample ファイルは以下の例のようになったはずです。

<blockquote><pre>
[Default-main-mode]
DOI=			IPSEC
EXCHANGE_TYPE=		ID_PROT
Transforms=		3DES-SHA
</pre></blockquote>

<p>
このセクションは、フェーズ 1 接続で使用される暗号方式の要件を記述しています。名前は
<i>Configuration=</i> 変数のとる値を反映しています。ご覧のとおり、Domain of Interest (DOI) を
IPSEC として記述しています。<b>EXCHANGE_TYPE</b> 変数は、フェーズ 1 では <b>ID_PROT</b> に設定しており、
これはこの認証でカバーされるプロトコルを指定しているものです。
<b>Transforms=</b> はこのやり取りで必要とされる (または指定される) 暗号変換方式です。この例では、
これは設定ファイルの下のセクションを指していて、そこでは、われわれは 3DES で暗号化され、
SHA で確認できるチェックサムを持つパケットを受け取る、と記述されています。サンプルの <b>VPN-east.conf</b> には、
各種変換方式が多数記述されています。なぜなら、3DES や SHA は各種のプラットホームで必ずしもサポートされいる
とは限らないからです。OpenBSD の場合、これを基本的な設定で変えるべき理由は特にありません。このセクションを
コピーして変換方式を変えるのは、自由です。唯一、必要になるのは、Configuration= 変数も変えることだけです。

<blockquote><pre>
[Default-quick-mode]
DOI=			IPSEC
EXCHANGE_TYPE=		QUICK_MODE
Suites=			QM-ESP-3DES-SHA-PFS-SUITE,QM-ESP-DES-MD5-PFS-SUITE
</pre></blockquote>

<p>
このセクションは、VPN 経由で転送れるデータの暗号の要件を記述するところで、
上の <i>Configuration</i> で参照される部分です。このセクションと、
すぐ上のフェーズ 1 のこの部分に相当する部分との違いは、 <b>EXCHANGE_TYPE</b> が <b>QUICK_MODE</b>に
なっているということに注目してください。フェーズ 2 では必ずこのようになるのです。
また、<b>Suites=</b> は IPsec Suite セクションを指しています。
両ホスト間で提供されている各種の暗号方式を記述したものです。
ISAKMP と IPsec については、他にも説明すべきことが多数あります。ここまでの基本的な説明をもとに、
自立して設定しても、単純ながらも堅牢な VPN を構成できます。
しかし、これは、両ホストにとって<i>必要最低最小限の</i> 
<b>isakmpd.conf</b> でしかありません。
 
<h3>13.7.3 - isakmpdの起動</h3>

<p>
最初にこのデーモンを実行する場合には、以下のコマンドを使用します。

<blockquote><tt>
# <b>isakmpd -d -DA=90</b>
</tt></blockquote>

<p>
デーモンはデーモンモードでは実行されず、通常の (フォアグラウンド)
プロセスとして実行されます。そして、すべてをターミナルに出力します。
isakmpd を止めて経路を一掃するには、各ノードで isakmpd プロセスを
kill してから <b>ipsecadm flush</b>
を実行します。


<p>
<a name= "x509"></a>
<h2>13.8 - isakmpd を X.509 証明書と使用するには ?</h2>

<p>
事前に共有した鍵のかわりに証明書を使用するように isakmpd を設定するのは、
保護されていないピアが多く存在する巨大ネットワークの場合には、
小さなネットワークと比較してそれほど難しいことではありません。
むしろ、設定が簡単になるかも知れませんし、さらに重要なこととして、
鍵管理が非常に柔軟になります。


<h2>証明書の生成</h2>

<p>
鍵や証明書の生成の仕方について、isakmpd
ソースディレクトリの
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/README.PKI?rev=1.7">README.PKI</a>
ファイルに詳しく記述されています。
CA 鍵、対応する CA X.509
証明書、ネットワーク上の isakmpd を使うコンピュータそれぞれに秘密鍵ひとつと、その秘密鍵のそれぞれに対して X.509
証明書ひとつずつが必要となります。

<p>
isakmpd で使用できるものにするために、X.509 証明書は、証明書の持ち主を記述する
Subject Alternative Name (subjectAltName) 拡張が追加される必要があります。
この拡張は証明書の持ち主の身元を記述するものであり、
これは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=certpatch&amp;sektion=8">certpatch(8)</a>
か、または、
<tt>/etc/ssl/x509v3.cnf</tt>
のような、OpenSSL の特別な設定ファイルを使用して追加されるかも知れないものです。
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/README.PKI?rev=1.7">README.PKI</a>
の例は、subjectAltName 識別子として IP アドレスを使用するこの手順について説明しています。

<p>
IP アドレスは subjectAltName 拡張のデフォルトのメカニズムですが、
certpatch は、FQDN (Fully Qualified Domain Name) か、または
UFQDN (User FQDN) を使用する方法もサポートしています。
これは、モバイルユーザには大変便利なものでしょう。FQDN の例は、
<tt>www.openbsd.org</tt> です。また、UFQDN の例としては、
<tt>Jorgen.Granstam@abc.se</tt> のような電子メールアドレスかも知れません。
これは、IP ベースの識別子とは異なるものとして注意すべきものであり、
isakmpd は FQDN あるいは UFQDN ベースの識別方法によるデータの検証を
行わず、識別子は単なる文字列と見なされます。

<p>
以下の例では subjectAltNames として FQDN を使用しています。

<p>
FQDN subjectAltName を証明書に入れるには、
以下の例のように記述します。

<blockquote><tt>
$ <b>/usr/sbin/certpatch -t fqdn -i home.mysite.se -k ca.key originalcert.crt newcert.crt</b>
</tt></blockquote>

<p>
ここで、ca.key は CA の秘密鍵ですので、これを実行できるのは
CA 秘密鍵にアクセスできる人だけということになります。
home.mysite.se というのは (実在しませんが) 証明書に挿入されるべき FQDN です。
originalcert.crt と newcert.crt のファイル名は同じ名前にしても良いでしょう。
この場合、元のファイルは新しい変更済みの証明書に
上書きされることになります。

<p>
この鍵と証明書を、README.PKI の最後に説明に従ってディレクトリに置きます。
もし、本当に鍵を使用するつもりでしたら、CA 鍵 (ca.key) は、
どこか安全なところに保管するようにしてください。
 
<p>
<table>
<tr><td><tt>/etc/isakmpd/ca</tt></td>
<td>信頼された CA の公開鍵 (PEM フォーマット) 証明書</td></tr>
<tr><td><tt>/etc/isakmpd/certs</tt></td>
<td>信頼された公開鍵 (PEM フォーマット) 証明書 (subjectAltName 拡張あり)</td></tr>
<tr><td><tt>/etc/isakmpd/private</tt></td>
<td>秘密鍵。これらは上記の <tt>cert</tt> ディレクトリ中の
関係する公開鍵を持つべきです。</td></tr>
</table>

<p>
これらの位置は、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a>
の中の [X509-certificates] セクションの値によってオーバーライドされるかも知れません。

<p>
CA のインフラストラクチャーを信頼すべきものにするためには、CA の秘密鍵
(<tt>/etc/isakmpd/ca/ca.key</tt>) は安全な場所に保管されなければならず、
そして、(たとえば 2048 ビットのような) 適正なビット長であるべきであり、
協力なパスフレーズで暗号化されるべきである、ということに注意してください。


<h2>isakmpd の設定</h2>

<p>
<tt>/etc/isakmpd/isakmpd.conf</tt> 設定ファイルを見てみましょう。
これはもともと
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a>
のサンプルファイルから取ってきたものですが、かなり変更されています。
さらに、この設定の理解をより簡単にするために、man ページにある
ものよりもかなり短いファイルを使用しています。そして、コメントも追加して
 (一部のコメントは isakmpd.conf(5)にあったものです)、名前も少し変更しました。
ここで使用したドメイン名は、私たちの知る限りではひとつも実在していません。

<p>
実際には、ここを読む人は既に事前共有鍵について実際に動く設定を
持っているはずですので (前の節を参照)、このファイルには目新しいところは
あまりないことでしょう。ですので、すべてを詳細に説明するのは控えます。
説明しない部分については isakmpd.conf(5) を
参照してください。

<p>
全体の構成は以下のようなものを仮定します。

<p>
<center>
<pre>
one.mysite.se                                        one.worksite.se
 192.168.1.2--+    10.0.0.1====/======10.0.0.2     +--192.168.2.2 
              |  gw.mysite.se       gw.worksite.se |
              +--192.168.1.1         192.168.2.1---+
two.mysite.se |                                    | two.worksite.se
 192.168.1.3--+                                    +--192.168.2.3
</pre>
</center>

<p>
これはつまり、ふたつのネットワークが、保護されていないネットワーク上の IPsec トンネル
経由で接続されている、というものです。ここではプライベートインターネット用に予約された
IP アドレス (RFC1918) を使用していることは無視してください。これは単に、何かを使用する
必要があったというだけのことだったのです。isakmpd を NAT と組み合わせて使用するなどの
ことに関しては説明しないつもりです (私自身に経験がないからです)。

<p>
では、設定ファイルを見てみましょう。以下は、
セキュリティゲートウェイ gw.mysite.se 用のファイルです。

<blockquote><pre>

# *****************************************************************
# ************* Start of the gw.mysite.se isakmpd.conf ************
# *****************************************************************

# A configuration sample for the isakmpd ISAKMP/Oakley (aka IKE) daemon.
[General]
Policy-File=            /etc/isakmpd/policy
Retransmits=            5
Exchange-max-time=      120
Listen-on=              10.0.0.1


# The name work-gw here is used just as a section name and a tag for
# use in this configuration file below and need not actually be the 
# real hostname or domain name of the peer (but it could be). The IP 
# address however needs to be correct. Phase 1, as you might already
# know, is to negotiate an ISAKMP security association (SA). There 
# should of course be one IP and name for each peer we want to
# communicate with.
[Phase 1]
10.0.0.2=               work-gw


# Now phase 2 is negotiating IPsec SAs. As in phase 1, the name here
# is a section name to be used later. Actually, it can be a comma
# separated list of section names here. Thus if traffic from many
# networks (or individual hosts) should be forwarded through this
# tunnel, more section names would be added (and of course corresponding 
# new sections further down). 
[Phase 2]
Connections=            work-gw-my-gw


# Now, here are some parameters for the ISAKMP SA negotiations. Almost 
# self documenting. The section name is from [Phase 1] above. The most 
# interesting tag might be the ID tag. The ID tag is set to the name
# of the section where the identity information about this host that 
# will be presented to connecting peers, can be found. If the ID tag 
# is not available, isakmpd will assume that it will identify itself 
# using the IP address. You might also notice that there is no longer 
# any authentication tag here in this configuration. The authentication
# data is currently used only in the preshared key case. 
[work-gw]
Phase=                  1
Transport=              udp
Local-address=          10.0.0.1                # Local address
Address=                10.0.0.2                # Peer address
ID=                     my-ID
Configuration=          Default-main-mode


# This is the identity data. ID-type may also be IPV4_ADDR (the
# default), IPV4_ADDR_SUBNET or UFQDN. The Name tag is used for 
# FQDN and UFQDN, for IPV4_ADDR an Address tag would be used instead.
# For IPV4_ADDR_SUBNET a Network and a Netmask tag would be used.  
[my-ID]
ID-type=                FQDN
Name=                   gw.mysite.se


# This is the section for the IPsec connection. The section name is
# from the list in the [Phase 2] section above. The ISAKMP-peer is,
# of course, the tag of our peer from section [Phase 1] above. The 
# Local-ID and Remote-ID tags should be section names describing which
# packages should be forwarded over the IPsec tunnel to the remote 
# network.
[work-gw-my-gw]
Phase=                  2
ISAKMP-peer=            work-gw
Configuration=          Default-quick-mode
Local-ID=               Net-west
Remote-ID=              Net-east

# Any packet originating from a computer on the network described
# here... 
[Net-west]
ID-type=                IPV4_ADDR_SUBNET
Network=                192.168.1.0
Netmask=                255.255.255.0

# ... and with a destination matching the network described here, 
# will be encrypted and forwarded over the IPsec tunnel to the remote 
# system. 
[Net-east]
ID-type=                IPV4_ADDR_SUBNET
Network=                192.168.2.0
Netmask=                255.255.255.0

# Main mode descriptions


# Here are the data for main mode. Using DES here for real purposes
# is not very smart since DES is no longer considered a secure
# encryption algorithm. 3DES is generally considered to have much better
# security since it has enough bits in the key to be considered secure. 
# Transforms is a list of tags describing main mode transforms. In 
# this example we have only one.
[Default-main-mode]
DOI=                    IPSEC
EXCHANGE_TYPE=          ID_PROT
Transforms=             3DES-MD5


# Certificates stored in PEM format
# This is important when using certificates. The CA certificates should 
# be in the CA-directory (but not the CA private key of course).
# The Cert-directory should have at least the certificate for the
# local host but other certificates are also allowed. The private key 
# should be the private key of the local host. 
[X509-certificates]
CA-directory=           /etc/isakmpd/ca/
Cert-directory=         /etc/isakmpd/certs/
Private-key=            /etc/isakmpd/private/local.key

# Main mode transforms
######################

# Here is our main mode transform. The important thing here is to use
# RSA_SIG as authentication method when using certificates. It is the
# only method supported when using certificates so far. Commercial
# entities in the US will thus have to wait until September 2000 to
# use this due to the RSA patent. Luckily, I am not living in the US. 
# Also important is the GROUP_DESCRIPTION tag. It must match the
# GROUP_DESCRIPTION tag in the Quick mode transforms further down. 
# The Life tag here could possibly be modified. The LIFE_60_SECS might 
# be shorter than necessary for normal use. 

[3DES-MD5]
ENCRYPTION_ALGORITHM=   3DES_CBC
HASH_ALGORITHM=         MD5
AUTHENTICATION_METHOD=  RSA_SIG
GROUP_DESCRIPTION=      MODP_1024
Life=                   LIFE_60_SECS,LIFE_1000_KB

# Quick mode description
########################

[Default-quick-mode]
DOI=                    IPSEC
EXCHANGE_TYPE=          QUICK_MODE
Suites=                 QM-ESP-3DES-MD5-PFS-SUITE

# Quick mode protection suites
##############################
# 3DES

[QM-ESP-3DES-MD5-PFS-SUITE]
Protocols=              QM-ESP-3DES-MD5-PFS

# 3DES

[QM-ESP-3DES-MD5-PFS]
PROTOCOL_ID=            IPSEC_ESP
Transforms=             QM-ESP-3DES-MD5-PFS-XF

# Quick mode transforms

# Don't forget. The GROUP_DESCRIPTION must match the GROUP_DESCRIPTION 
# in main mode above. For forwarding packets between two networks (or
# from a host to a network) we use TUNNEL mode. Between two hosts we
# may also use TRANSPORT mode instead. 
[QM-ESP-3DES-MD5-PFS-XF]
TRANSFORM_ID=           3DES
ENCAPSULATION_MODE=     TUNNEL
AUTHENTICATION_ALGORITHM=       HMAC_MD5
GROUP_DESCRIPTION=      MODP_1024
Life=                   LIFE_60_SECS


# As we know from the isakmpd.config manpage the LIFE_DURATION here is 
# an offer value (60), a minimum acceptable value (45) and a maximum
# acceptable value. The isakmpd.conf example has this set to 
# 600,450/720 instead. That might be a better value for normal use.
[LIFE_60_SECS]
LIFE_TYPE=              SECONDS
LIFE_DURATION=          60,45:72

[LIFE_1000_KB]
LIFE_TYPE=              KILOBYTES
LIFE_DURATION=          1000,768:1536

# *****************************************************************
# ************* End of the gw.mysite.se isakmpd.conf **************
# *****************************************************************
</pre></blockquote>

<p>
ここまではローカルシステム用の設定になります。リモートシステムの設定も
まったく同じですが、この裏返しになります。ですから、異なるのは isakmpd.conf
ファイルの冒頭のところだけということになります。セキュリティゲートウェイ
gw.worksite.se の isakmpd.conf ファイルの冒頭のところだけ見てみましょう。

<blockquote><pre>
# *****************************************************************
# ************* Start of the gw.worksite.se isakmpd.conf **********
# *****************************************************************

[General]
Policy-File=            /etc/isakmpd/isakmpd.policy
Retransmits=            5
Exchange-max-time=      120
Listen-on=              10.0.0.2

[Phase 1]
10.0.0.1=               my-gw

[Phase 2]
Connections=            work-gw-my-gw

[my-gw]
Phase=                  1
Transport=              udp
Local-address=          10.0.0.2                # Local address
Address=                10.0.0.1                # Peer address
ID=                     work-ID
Configuration=          Default-main-mode

[work-ID]
ID-type=                FQDN
Name=                   gw.worksite.se

[work-gw-my-gw]
Phase=                  2
ISAKMP-peer=            my-gw
Configuration=          Default-quick-mode
Local-ID=               Net-east
Remote-ID=              Net-west

# *****************************************************************
# ********************** ... to be continued **********************
# *****************************************************************
</pre></blockquote>

<p>
あまり難しくはないと思います。ただし、読むのは少し退屈だったかも知れませんね。
次の部分は、もう少しおもしろくなるはずです。


<h2>policy ファイル</h2>

<p>
実のところ、policy ファイルは初めての人には少々難解なものかも知れません。
特に思いどおりに動かないときにはそうだと思います。man ページ
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&amp;sektion=5">isakmpd.policy(5)</a>
は、実はそれほど悪くはないと思います。ところどころ
はっきりしないところがあるにはあるのですが、全体としては良く記述されています。

<p>
最も簡単な、正常に機能する policy ファイルは
たった一行だけのものです。

<blockquote><pre>
authorizer: &quot;POLICY&quot;
</pre></blockquote>

<p>
これはつまり、誰が接続可能かということについてのポリシー上の制約が何もない、
ということなのです。ですから、決してセキュリティの高い設定ではありません。
この authorizer タグは、policy を決定する権限を持つユーザです。
特別 authorizer である &quot;POLICY&quot; は、policy についての
最終的かつ無限の権限を持ちます。それ以外の authorizer については、
ここで権限を持つためには、まず &quot;POLICY&quot; の認定を受ける必要があります。

<p>
さらに何が許されるかについて、条件群があるかも知れません。
ですから、以下の policy は本物の暗号を何か使用して ESP
プロトコルを使用したユーザだけが認定されるということなのです (本物とは言え、
これですと DES を使用するユーザも認められますが、DES は
現在ではほとんどダメなものと考えて良いくらいのものなので、DES を認めないよう、
この policy を変更するのは、読者の練習問題として残しておくことにしましょう)。
これですと ESP で暗号化するユーザなら、誰でも認められることに注意してください。

<blockquote><pre>
authorizer: &quot;POLICY&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;

</pre></blockquote>

<p>
さらに、権限を誰か他の存在 (複数でも構いません)
に「サブライセンス」することもできます。簡単なケースとしては、事前共有鍵の
場合でしょう。この場合、事前に共有されたパスワードを知る人はすべて
認められることになります。ですから、

<blockquote><pre>
authorizer: &quot;POLICY&quot;
licensees:  &quot;passphrase:something really secret&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
これはこのパスワードを知っていて条件にマッチした人すべてが
接続を認められます (ただし、このパスワードは isalmpd.conf の Authentication
タグでも設定しておくのを忘れないようにしてください)。

<p>
ここまでは何も難しくはないと思います。これからがおもしろいところなのです。まず、
ライセンスを受ける存在は多数あっても構いませんが、そのすべてが &quot;POLICY&quot;
に認定されなくてはなりません。さらに、認定されたライセンス保持者は、他のライセンス保持者に
サブライセンスを出せるます。ライセンス保持者は、policy ファイルにも記述されている場合には
単なるストリングでも構いません。

<blockquote><pre>
authorizer: &quot;POLICY&quot;
licensees:  &quot;subpolicyAH&quot; ||  &quot;subpolicyESP&quot;
conditions: app_domain == &quot;IPsec policy&quot; -&gt; &quot;true&quot;;

authorizer: &quot;subpolicyESP&quot; 
licensees:  &quot;passphrase:something more secret&quot;
conditions: esp_present == &quot;yes&quot; -&gt; &quot;true&quot;;

authorizer: &quot;subpolicyAH&quot; 
licensees:  &quot;passphrase:something really secret&quot;
conditions: ah_present == &quot;yes&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
さて、みなさんお待ちかねの部分です。Policy はまた、
鍵にサブライセンスしたり権限委譲したりできます。この場合の鍵は、通常は
X.509 証明書になります。証明書を簡単に使用するには、
それをパスワードがわりに使用することです。
policy ファイルに個別ユーザの証明書を加えるだけで良いでしょう。

<blockquote><pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA                この部分はユーザ証明書です               AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
さて、ユーザの数が多ければ、この方法に問題があることは既におわかりのことと思います。
isakmpd が CA- ディレクトリと Certificate
ディレクトリから読み込む証明書と、ピアから送信される証明書とは、
疑似資格証明 (credentials) に変換されます。こうした疑似資格証明に変換された証明書は、
以下のようなものです。

<blockquote><pre>

authorizer: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgI2\
    	CzA   この部分はユーザ証明書 (つまりCA証明書) に署名した    AQEB\
        BQA               ユーザの公開鍵/証明書です                 IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
licensees:  &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA          この部分は証明書を受ける側の鍵です　           AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
さて、これらは &quot;POLICY&quot; に認められたものではありませんので、
それを何らかの形で認知する policy がなければダメだということに注意してください。
さらに、これは内部で証明書がどのようになっているのかを説明しているのです。
上記の資格証明 (credential) は、policy ファイルの中には見られません。しかし、そのような
資格証明にもサブライセンスは出せるのです。上記のサブライセンス発行を思いだしてください。
それを使用し、CA 証明書をライセンスとして &quot;POLICY&quot; に記述すれば、
ある CA が署名した証明書すべてにライセンスが出せることになるのです。

<blockquote><pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA                 この部分が CA 証明書です                AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
つまり、上の policy は CA に権限委譲する policy の簡単な例なのです。
この証明書を持つ CA が署名した証明書を持ち、
policy と設定ファイルの設定した他の条件にも
従うユーザはすべて認められるのです。


<h2>ほとんど安全……は安全にあらず !</h2>

<p>
さて、本当に安全を期するなら、これでは残念ながら十分ではありません。
このような設定のセキュリティゲートウェイを攻撃する方法があるのです。
もし、そのような細々とした話が不要でしたら、次節まで読み飛ばしてください。
それ以外の人たちは、なぜこれが安全ではないのかを理解してみましょう。
むずかしいことではありません。

<p>
この段階で、isakmpds がどのような情報にアクセスできるのかを考えてください。
設定ファイルから、isakmpd はピアがどの IP アドレスから
送信してくるのかを知っています ([フェーズ 1] セクションで)。フェーズ 1 の
ネゴシエーションの際に得られる情報から、ピアがどのような ID を
出してくるのかもわかりますし、ピアからの証明書をもらうことでピアが本当に
その ID を持つことが証明されるのです。ここまでは問題なさそうですね ?

<p>
そうです、もし ID 情報が IP ならば (フェーズ 1 の ID セクションを使わなければ
これがデフォルトに状況になります) すべて問題ありません。CA
はその IP を cert に結びつけて、設定の中の IP
だけで必要情報はすべてそろいます。なりすまし犯が、ほかのコンピュータから
同じ IP を使用することも不可能ではありませんが
(たとえば、両方のコンピュータが同じ LAN 上にあって、
普段その IP を使用しているマシンが何らかの理由でダウンしているなど)、
なりすまし犯が証明書とそれに対応する秘密鍵を持っており、
その IP がなりすまし犯のものだと (不正に) 証明することは
不可能なはずです。

<p>
しかしもし、それが万一起きてしまったら、そのなりすまし犯はその IP の
所有者から秘密鍵を何らかの方法で盗んだか、あるいは CA を何らかの方法で騙して、
偽の情報を含む証明書を発行させたかのどちらかということになります。
もし、このいずれかが起きたなら、
秘密鍵の保護が不十分だったのか、CA が
なりすまし犯の身元 (あるいは cert の ID 情報) を十分にチェックできなかったのか、
あるいは CA 秘密鍵が十分に保護されていなかったのか、のいずれかなのです。
これらはすべて、そもそもセキュリティがまともに機能する前提ですので、
このような状況は絶対に起きてはいけないことです。

<p>
さて、私たちの例では状況が異なります。ここでは
証明書の中に、IP アドレスではなく FQDN が入っています。
[Phase 1] セクションにまだ IP アドレスがありますので、
これはセキュリティ問題となる可能性があるものです。この場合、ISAKMP
フェーズ 1 ネゴシエーションの間に何が起きるかというと、ピアが
期待どおりの IP から送られてきたことをチェックできるのです (しかし、さきほど説明したように、
これは一部の状況では偽ることができることです)。また、ピアが提示する ID を、
本当にそのピアが持っていることもチェックできます。
しかし、今、チェックできないのは、その ID が本当にそのピアが持っているものと期待可能な ID なのか、
ということです。isakmpd は、どのような ID を期待すればいいのかについては一度も教えられていないからです。

<p>
DNS システムがホストのために IP と FQDN とを結びつけてくれる、
という人もいることでしょう。確かにそうなのですが、現在の DNS システムはセキュリティがあまり高くはありませんし、
騙して偽の情報を出させることも、場合によっては
できてしまいます (あるいはサービス拒否 (DoS) 攻撃を
攻撃者に受けて、その攻撃者のマシンが DNS サーバの答を
偽造することもできてしまいます)。いずれ高セキュリティ DNS も登場する予定ですが、
まだ出回ってはいませんし (少なくともほとんどの DNS サーバはまだ高セキュリティではありません)、
ですから現在、cert の FQDN が期待される IP と対応しているかどうかを調べるのに
DNS を使用しても保証にはなりません。実は isakmpd はこれを DNS に聞いたりはしません。
DNS が安全でも、UFQDN を使用している場合には
これをチェックできないからです。

<p>
つまり、ID として FQDN を使用する場合、攻撃者は
自分の秘密鍵を用意して、それを私たちの使用するのと
同じ CA に署名させます (でももちろん攻撃者自身の FQDN を使用して)。
そして、ピアに DoS 攻撃をしかけてダウンさせます (実は
ISAKMP プロトコル自体に欠陥があるため、ピアに対して
リモート DoS を仕掛けてダウンさせてしまう可能性がありますが、
isakmpd がこのような攻撃に対してどのくらい敏感かは知りません)。
そして、攻撃者は自分のコンピュータを私たちのピアと同様に設定して、
ピアのネットワークに接続して
自分の ID と秘密鍵と証明書を使用できます。

<p>
私たちの側の isakmpd は、こちらのピアへの ID が何かを教えられていません (そしてそれは、攻撃者が
証明書と ID と秘密鍵以外はまったく同じ設定にしておいたからです)。さらに、私たちの
isakmpd は証明書が同じ CA のサインしたものだとチェックできます (しかし、
多くの CA は cert を多数のサインをしますので、cert を手に入れるのは困難ではないかも知れません)。
そして、そこで示された ID が証明書の中の ID と同じであることも確認できます。しかし、
これまで提示された設定では、その ID が期待していた ID かどうかはチェックできません。
ですから、攻撃者は接続を認められてしまうのです。


<h3>攻撃を防ぐ</h3>

<p>
つまり、問題は、どのようにすれば isakmpd に期待すべき ID のことを教えられるか、
ということになります。幸運にもこれは簡単なことで、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&amp;sektion=5">isakmpd.policy(5)</a>
にも説明されています。たとえば以下のように、
policy 内でチェックしなければならないのです。

<blockquote><pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA                 この部分が CA 証明書です                AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            remote_id == &quot;gw.worksite.se&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
これで、IPsec 接続が可能になるのは gw.worksite.se だけになったはずです。
他に remote_id のチェックを足せば、許可する ID を簡単に増やすことができます。
つまり以下の例のような ID を policy に足せば良いのです。

<blockquote><pre>
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            (remote_id == &quot;gw.worksite.se&quot;  ||
               remote_id == &quot;gw.whatsite.se&quot;) -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
この policy の場合、gw.worksite.se、gw.somesite.se、
gw.whatsite.se のいずれも接続できることになります。

<p>
policy に証明書をすべて含めなくてはならないのは残念だ、
と思う人もいることでしょう。証明書を policy に
入るような形式に変更するのは手間ですし、
policy も読みにくくなるからです。また、間違って、
複雑な policy の中で、CA 証明書と間違えて
ユーザ証明書を入れてしまったりしようものなら、権限のないユーザも
接続が認められてしまうかも知れませんし、さらに困ったことには、
policy ファイルを見てもそれをつきとめるのは難しいのです (これは、
X.509 証明書が人間に読める形ではないからです)。

<p>
さて、本当に最先端の人たちには、この問題の解決方法があるのです。
今では、policy 内で証明書そのもののかわりに、
証明書の Distinguished Name (DN) を使用することができるからです
(対応する証明書はもちろんディスク上の certs か ca ディレクトリにあり、
isakmpd が見つけられるようになっていることが必要です)。
この形式ですと、上記の policy は以下のようなものになるはずです。

<blockquote><pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;DN:/C=se/CN=IKELAB CA&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            (remote_id == &quot;gw.worksite.se&quot;  ||
             remote_id == &quot;gw.somesite.se&quot;  ||
             remote_id == &quot;gw.whatsite.se&quot;) -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
かなり読みやすくなりましたよね !?  ある証明書の正確な DN は、
openssl ユーティリティを使用して証明書を見ると、次のように
わかります。

<blockquote><tt>
$ <b>openssl x509 -text &lt; ca.crt</b>
</tt></blockquote>

<p>
さらに複雑な policy ももちろん作成できますが、
これはとりあえず入門ですし、次の節で別の例を見て
作成することになります。

<p>
これで ca.crt の中の証明書について必要な情報が
提供されるはずですね。policy が小さいか、そこそこくらい大きさでしたら、
これでも良いでしょう。しかし、巨大なサイトで接続ユーザが非常に多数いる場合には
これでもまだまだでしょう。


<h2>マルチユーザ設定と、中央管理型認証</h2>

<p>
それでは、isakmpd の本当にクールな機能をいくつか見てみましょう。これまでは、
接続してくるはずのピアはよく知られていて、IP アドレスも静的に固定されているものとしました。
しかし、そのような場合ばかりではありません。動的に割り当てられた IP を使用していたり、
コンピュータを何台も使用していたりする人は多いのです。あるいは (サーバ
等のように) 接続したいのが誰であるのか、はっきりとはわからない場合もあります。

<p>
そこで isakmpd の素晴しい機能のひとつは、
[Phase 1] セクションで IP ではなく、デフォルトのタグを使用できるというものです。
それにより、isakmpd はどの IP からでもネゴシエーションを受け付けられるようになります。
この例を以下に示します。

<blockquote><pre>
[phase 1]
Default=        work-gw
</pre></blockquote>

<p>
まず言っておかなければならないことは、この設定は DoS 攻撃に対しては
安全ではないかも知れないということです。前述したように、
ISAKMP/IKE プロトコルには欠陥があるからです。いずれにせよ、デフォルトの
[phase 1] セクションを使用すれば、一種の「認証証明書」が代わりに使用可能になります。

<p>
たとえば、権限を持つユーザが多数いるものの、誰でも彼でも受け付ける、
というわけではない場合を考えてみましょう。たとえば、会社の場合です。
会社の従業員は接続させたいが、それ以外の人には接続してほしくない場合です。
さて、大企業で社員が何千人もいるとします。彼らがどのコンピュータからでも
(社内 LAN 上のものに限らず) 接続できるようにしたいが、
全員が何でもできるようにはしたくはありません。このような場合、
以下のような policy が書けるはずです。

<blockquote><pre>
keynote-version: 2
authorizer: &quot;POLICY&quot;
licensees: &quot;telnet@work&quot; || &quot;telnet@lab&quot; || &quot;pop3@work&quot; 
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            remote_id_type == &quot;UFQDN&quot; &amp;&amp;
            (remote_id == &quot;telnet@worksite.se&quot;  ||
             remote_id == &quot;pop3@worksite.se&quot;  ||
             remote_id == &quot;telnet@lab.worksite.se&quot;) -&gt; &quot;true&quot;;

authorizer: &quot;telnet@work&quot;
licensees: &quot;DN:/C=se/CN=IKELAB CA&quot;
conditions: remote_id == &quot;telnet@worksite.se&quot; &amp;&amp;
            local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;23&quot; &amp;&amp;
            local_filter == &quot;192.168.002.003&quot;

authorizer: &quot;telnet@lab&quot;
licensees: &quot;DN:/C=se/CN=IKELAB CA&quot;
conditions: remote_id == &quot;telnet@lab.worksite.se&quot; &amp;&amp;
            local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;23&quot; &amp;&amp;
            local_filter == &quot;192.168.002.002&quot; -&gt; &quot;true&quot;;

authorizer: &quot;pop3@work&quot;
licensees: &quot;DN:/C=se/CN=IKELAB CA&quot;
conditions: local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;110&quot; &amp;&amp;
            local_filter == &quot;192.168.002.003&quot; &amp;&amp;
            remote_id == &quot;telnet@worksite.se&quot; -&gt; &quot;true&quot;;

</pre></blockquote>

<p> 
これが厳密に正しいかどうかはわかりません。私が知る限り、
これはまったくテストされていないからです (ですから、このフィルタ条件は、私の思いどおりには
ぜんぜん動かないかも知れません)。また、このような policy (換言すれば、デフォルトをピアの
IP としているものすべてです) は、isakmpd.conf ファイルも合わせて書き換えなければ
なりませんだ。これには、セキュリティ上の問題もついてまわります。さらに、
誰でも接続できるようになっているこの種の接続では、
たぶん接続した人の DN はすべてロギングしておくほうが望ましいでしょう。
isakmpd は私の知る限りでは、これをまだサポートしていません。さらには、
この可能性には別のセキュリティ上の問題がある可能性もあります。すべては
自己責任にて実施してください。しかし、基本的な考え方はもうはっきりしているはずです。

<p> 
これが持つ、実におもしろい可能性に思い当たらない人がいるかも知れませんので、念のために説明しておきましょう。
もし、このような形で ISAKMP/IKE を使用しているコンピュータがすべて、
リモートからユーザが使用したいと思うサービスのそれぞれについて、標準的な条件を持つものとします。
すると CA は、ユーザの証明書にしかるべき subjectAltName 拡張を
入れておくだけでそのユーザの認証ができるようになります。さらに、そのような証明書の有効期限を
比較的短いものにしておいて、ユーザは
証明書が古くなってきたら証明書を再発行してダウンロードできるように
しておくのです。もしも、ユーザが権限を悪用するなら、
証明書を再発行しないようにすれば、有効期限後は入ってくることができなくなります。
これで、社員がひとりやめたくらいで、
すべてのコンピュータ上の policy ファイルを変更する必要はなくなりました。
同じ方式は ISAKMP/IPsec 以外の目的にも使えるはずです (オフラインシステムの認証さえ可能です !)。
ただし、その場合には特別なソフトが必要になりますが……
とにかく、このようにしようとする組織は、おそらく自分で自分自身の CA になる方が良いでしょう。

<p>
このようなマルチユーザ設定 (モバイルユーザ) は、
事前共有鍵でも可能ですが、それでは、どの IP から接続してくるかわかりませんから、
ID をもとに正しいパスワードが選べるようになっている必要があります。
ですから、ID_PROT モードではなく AGGRESSIVE モードを
使用しなくてはなりません (AGGRESSIVE モードでは、ID はネゴシエーションの
初期の段階で送信されますが、暗号化されずに送信されます。ですから、
AGGRESSIVE モードの方がメッセージ交換が少なくて済みますので高速ですが、
ID が平文で送信される分、セキュリティは下がることになります)。


<p>
<a name= "IKEcl"></a>
<h2>13.9 - isakmpd で使える IKE クライアントは ?</h2>

<p>
<tt>isakmpd</tt> は、OpenBSD 附属の ISAKMP/Oakley 鍵管理デーモンです。
おそらく、ほとんどの ISAKMP 実装とは、部分的にせよ相互運用可能だと思いますが、
実際にテストされたのは以下のものです。また、出回っている
isakmp ソフトの一部は、実は OpenBSD isakmp デーモンをベースにしたものだったりします。

<p>
以下の MS-Windows クライアントは、互換性があるとの報告があります。

<ul>
<!-- <li><a href="http://www.timestep.com/">TimeStep</a> PERMIT/Client -->
<li><a href="http://www.ashleylaurent.com/">Ashley Laurent</a> VPN ソフトウェア
<li><a href="http://www.radguard.com/">Radguard</a> cIPro クライアント
<li><a href="http://www.cisco.com/">Cisco</a> IRE クライアント
<li><a href="http://www.microsoft.com">Microsoft</a> Windows 2000、XP
</ul>

<p>
以下のゲートウェイ/ルータも互換性があるとの報告があります。

<ul>
<li><a href="http://www.cisco.com/">Cisco</a> IOS
<li><a href="http://www.cisco.com/">Cisco</a> PIX
<li><a href="http://www.intel.com/">Intel</a> LanRover
<!-- <li><a href="http://www.timestep.com/">TimeStep</a> PERMIT/Gate -->
<li><a href="http://www.cendio.com/">Cendio</a> Fuego
<li><a href="http://www.kame.net/">KAME</a> for FreeBSD
<li><a href="http://www.xs4all.nl/~freeswan/">FreeS/WAN</a> for Linux
<li><a href="http://www.symantec.com/">Symantec</a> Raptor
<li><a href="http://www.ericsson.com/">Ericsson</a> eBox
<li><a href="http://www.f-secure.com/">F-Secure</a> VPN+
<li><a href="http://www.teamware.com/">Teamware</a> TWISS
<li><a href="http://www.3com.com/">3com</a> Pathbuilder
<li><a href="http://www.nortelnetworks.com/">Nortel</a> Contivity
<li><a href="http://www.checkpoint.com/">CheckPoint</a> FW-1
<li><a href="http://www.watchguard.com/">Watchguard</a> Firebox III
<li><a href="http://www.lucent.com/">Lucent</a> Access Point
</ul>

<p>
<a name= "Trouble"></a>
<h2>13.10 - IPsec/VPN のトラブルシューティング</h2>

<p>
IPsec のトラブルシューティングのための最初のツールは <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8">tcpdump(8)</a> です。
<tt>tcpdump</tt> を使用していくつか探すべきものを挙げると、

<p>
まず、OpenBSD の tcpdump を使用している人は、
拡張版の tcpdump を使用しているので、
ESP と AH パケットについても情報が取れます。もし、OpenBSD
2.5 や他の OS の tcpdump を使用しているのでしたら、おそらく古い
バージョンですから、AH や ESPについてはプロトコル番号しか表示されません
(ESP は IP プロトコル 50、AH は 51)。

<ul>
<li>
tcpdump では、トラフィックが AH/ESP を使用しているか平文のままかを確かめます。
平文のままでしたら、フローが正しく設定されていないか、isakmp のネゴシエーションがうまくいっていません。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&amp;sektion=8">ping(8)</a>
を使用して簡単なトラフィックを発生させてみましょう。
<p>
たとえば、208.1.1.1 と 208.2.2.2 のふたつのホストがあるとして、
208.2.2.2 に login して、以下を実行してみましょう。
<pre>
# <b>ping -c 3 208.1.1.1</b>
PING esp.mil (208.1.1.1): 56 data bytes
64 bytes from 208.1.1.1: icmp_seq=0 ttl=255 time=190.155 ms
64 bytes from 208.1.1.1: icmp_seq=1 ttl=255 time=201.040 ms
64 bytes from 208.1.1.1: icmp_seq=2 ttl=255 time=165.481 ms
--- esp.mil ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 165.481/185.558/201.040 ms
</pre>
<p>
別のセッションでは、encapsulated された ping が見られます。
<pre>
# <b>tcpdump -ni fxp7 host 208.1.1.1</b>
tcpdump: listening on fxp7
14:12:19.630274 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4535 len 116
14:12:19.813519 esp 208.1.1.1 &gt; 208.2.2.2 spi 0x00001001 seq 49313 len 116
14:12:20.630277 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4536 len 116
14:12:20.832458 esp 208.1.1.1 &gt; 208.2.2.2 spi 0x00001001 seq 49314 len 116
14:12:21.630273 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4537 len 116
<b>^C</b>
1831 packets received by filter
0 packets dropped by kernel
</pre>
<p>
<li>ISAKMP は UDP port 500 で実行されます。もし、これがファイアウォールか
パケットフィルタで阻止されていたら、これを変更してください !
<blockquote><pre>
# Passing in ISAKMP traffic from the security gateways
pass in on ne0 proto udp from gatewB/32 port = 500 to gatewA/32 port = 500
pass out on ne0 proto udp from gatewA/32 port = 500 to gatewB/32 port = 500

# Passing in encrypted traffic from security gateways
pass in proto esp from gatewB/32 to gatewA/32
pass out proto esp from gatewA/32 to gatewB/32
</pre></blockquote>
<p>
<li>
isakmpd に役に立つデバッグをすべてつけるのでしたら、次のようにして実行します。
<blockquote><tt>
# <b>/sbin/isakmpd -d -DA=90</b>
</tt></blockquote>
<p>
あるいは (いちばん詳しいタイマデバッグ情報をスキップするには)、
<blockquote><tt>
# <b>/sbin/isakmpd -d -DA=90 -D1=70</b>
</tt></blockquote>
<p>
<li>IPsec で処理されたトラフィックを、netB から自分のローカルのファイアウォール保護つきの netA に
入れるようにする必要があります。
<blockquote><pre>
# Passing in traffic from the designated subnets.
pass in on enc0 from netB/netBmask to netA/netAmask
</pre></blockquote>
<p>
<li>OpenBSD の tcpdump の場合、ほとんどのインターネット
鍵交換 (自動鍵交換) セッションの平文部分はほとんどデコードできます。Tcpdump はまた、AH ペイロードデータも表示します。
<p>
<li>(もし既にデフォルトで使用していないのでしたら) /kern ファイルシステムをマウントします。 
<blockquote><tt>
# <b>mkdir /kern; mount -t kernfs /kern /kern</b>
</tt></blockquote>
<p>
/kern には、現在の SA/SPI 一覧表があって、フローがあるもの
(外行きの SA) もないもの (入ってくる SA) も記述されています。
また、どのようなトラフィックがどこへ行っているのかを調べることができる、
トラフィックカウンタもあります。
<p>
<li>最後に、<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">netstat(1)</a> を使用して SA を見ることができます。
<blockquote><pre>
$ <b>netstat -rn -f encap</b>
Routing tables

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto) 
0.0.0.0/32         0     192.168.99/24      0     0     208.1.1.1/00001000/50
0.0.0.0/32         0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.1.2.0/24       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.1.2.0/24       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.1.5.0/24       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.1.5.0/24       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.2.2.2/32       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.2.2.2/32       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
</pre></blockquote>
<p>
<li>
これだけやってみてもダメでしたら、<tt>option ENCDEBUG</tt> つきでカーネルをコンパイルし直してください。
そして、<tt>net.inet.ip.encdebug</tt> を 1 にしてください。そして、dmesg を見て警告やエラーを探し、それを
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sendbug&amp;sektion=1">sendbug(1)</a> を使用して
OpenBSD の開発者に報告してください。あるいは、もしそれがバグかどうかわからなければ、
<A HREF="../../ja/mail.html">メーリングリスト</a>のいずれかにメッセージを投げてみましょう。
</ul>


<p>
<a name= "SeeAlso"></a>
<h2>13.11 - 関連ドキュメンテーション</h2>

<p>
IPsec が特に詳しく説明されているのは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vpn&amp;sektion=8">vpn(8)</a>
ページでしょう。各種の設定テンプレートが <A HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/">/usr/share/ipsec/</a>
ディレクトリにあるので役に立つと思います。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc(4)</a>、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&amp;sektion=4">ipsec(4)</a>、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;sektion=8">ipsecadm(8)</a>、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd&amp;sektion=8">isakmpd(8)</a>、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a> および
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&amp;sektion=5">isakmpd.policy(5)</a>
の man ページも詳しくて、IPsec の設定と運用に役立つはずです。

<p>
その他リンクとして……

<ul>
<li><a href="http://www.ietf.org/html.charters/ipsec-charter.html">IETF IPsec Working Group</a>
<li><a href="http://isakmp-test.ssh.fi/">SSH IPsec interoperability Test Node</a>
<li><a href="http://ipsec-wit.antd.nist.gov/">NIST IPsec Web Based Interoperability Tester</a>
<li><a href="http://www.r4k.net/ipsec/">A port of OpenBSD's IPsec to FreeBSD</a>
<li><a href="http://www.xs4all.nl/~freeswan/">FreeS/WAN - IPsec for Linux</a>
<li><a href="http://www.pintday.org/hack/docs/vpn-24-minifaq.shtml">OpenBSD 2.4 VPN Configuration Mini-FAQ</a>
</ul>

<p> 
<a name="rfc">
そしてつづきましては RFCども...
</a>

<ul>
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1320.html">RFC 1320</a> - The MD4 Message-Digest Algorithm
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1321.html">RFC 1321</a> - The MD5 Message-Digest Algorithm
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1828.html">RFC 1828</a> - IP Authentication using Keyed MD5
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1829.html">RFC 1829</a> - The ESP DES-CBC Transform
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2040.html">RFC 2040</a> - The RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algorithms
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2085.html">RFC 2085</a> - HMAC-MD5 IP Authentication with Replay Prevention
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2104.html">RFC 2104</a> - HMAC: Keyed-Hashing for Message Authentication
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2144.html">RFC 2144</a> - The CAST-128 Encryption Algorithm 
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2202.html">RFC 2202</a> - Test Cases for HMAC-MD5 and HMAC-SHA-1 
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2207.html">RFC 2207</a> - RSVP Extensions for IPsec Data Flows
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2268.html">RFC 2268</a> - A Description of the RC2 Encryption Algorithm 
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2367.html">RFC 2367</a> - PF_KEY Key Management API, Version 2
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2401.html">RFC 2401</a> - Security Architecture for the Internet Protocol (<b>IPsec</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2402.html">RFC 2402</a> - IP Authentication Header (<b>AH</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2403.html">RFC 2403</a> - The Use of HMAC-MD5-96 within ESP and AH
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2404.html">RFC 2404</a> - The Use of HMAC-SHA-1-96 within ESP and AH
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2405.html">RFC 2405</a> - The ESP DES-CBC Cipher Algorithm With Explicit IV
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2406.html">RFC 2406</a> - IP Encapsulating Security Payload (<b>ESP</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC 2407</a> - The Internet IP Security Domain of Interpretation for ISAKMP
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC 2408</a> - Internet Security Association and Key Management Protocol (<b>ISAKMP</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC 2409</a> - The Internet Key Exchange (<b>IKE</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2410.html">RFC 2410</a> - The NULL Encryption Algorithm and Its Use With IPsec (ha ha...)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2411.html">RFC 2411</a> - IP Security Document Roadmap
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2412.html">RFC 2412</a> - The OAKLEY Key Determination Protocol
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2451.html">RFC 2451</a> - The ESP CBC-Mode Cipher Algorithms
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2631.html">RFC 2631</a> - Diffie-Hellman Key Agreement Method
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2709.html">RFC 2709</a> - Security Model with Tunnel-mode IPsec for NAT Domains
</ul>

<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "faq12.html">[12 章 - 高度なユーザ向け]</a>
<a href= "faq14.html">[14 章 - OpenBSD のハードディスク]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq13.html,v 1.75 ]
<br>
$Translation: faq13.html,v 1.28 2003/05/10 01:03:42 toshi Exp $
<br>
$OpenBSD: faq13.html,v 1.26 2003/05/10 13:21:29 jufi Exp $</small>
</small>

</body>
</html>
