<html>
<head>
<title>13.0 - IPsec を使う</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 2000-2002 by OpenBSD">
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
</head>

<body bgcolor= "#ffffff" text= "#000000">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<h1><font color=#e00000>13.0 - IPsec (IP Security Protocol) を使う</font></h1>
<hr>
 
<p>
<h3>目次</h3>
<UL>
<LI><a href="#What"     >13.1 - IPsecって何?</A></LI>
<LI><a href="#Why"      >13.2 - そりゃ結構だけれど、このぼくがなぜ IPsec なんか使わにゃならんの?</A></LI>
<LI><a href="#Protocols">13.3 - IPsecの裏にあるプロトコルは?</A>
<LI><a href="#Wire"     >13.4 - ネットワーク上のパケットフォーマット</A>
<LI><a href="#Config"   >13.5 - IPsec の設定</A>
<LI><a href="#ManKey"   >13.6 - IPsec を手動鍵設定で使うには?</A>
<LI><a href="#Photuris" >13.7 - photurisd のセットアップは?</A>
<LI><a href="#isakmpd"  >13.8 - isakmpd のセットアップは?</A>
<LI><a href="#x509"     >13.9 - isakmpd を X.509 証明書と使うには?</A>
<LI><a href="#IKEcl"    >13.10 - IKE クライアントで isakmpd と互換性があるのは?</A>
<LI><a href="#Trouble"  >13.11 - IPsec/VPN のトラブルシューティング</A>
<LI><a href="#SeeAlso"  >13.12 - 関連ドキュメンテーション</A>
</UL>
<p>
<Font size="-1">
このドキュメントの一部は、以下のドキュメントからとっている:
<UL>
<LI><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&sektion=4&format=html">ipsec(4)</a>
<LI><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vpn&sektion=8&format=html">vpn(8)</a>
<LI><a href="http://www.freebsd.org/~julian/IPSEC_4_Dummies.html">IPsec for Dummies</a> by Julian Elischer
<LI><a href="http://www.secureops.com/vpn/vpn.html">ISAKMP Howto</a> by Patrick Ethier
<LI><a href="http://hem.passagen.se/hojg/isakmpd/">X.509v3 certificates with isakmpd</a> by J&ouml;rgen Granstam
</UL>
</font>
<hr>
<p>
<a name= "What"></a>
<a name= "13.1"></a>
<h1>13.1 - IPsecってなに?</h1>
</p>
<p>
IPsec は、IP プロトコルファミリーに対する拡張だ。
暗号セキュリティサービスを提供する。このサービスで、認証、
完全性 (integrity)、アクセス制御、機密性が提供される。IPsec は
SSL と似たサービスを、ネットワーク層で提供して、しかもアプリケーションにはまったく
透過的で、しかもずっと強力。透過的というのは、
アプリケーションのほうでは IPsec を使うのに、IPsec のことを何一つ知らなくていい、
ということだ。
IPsec 上では<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/protocols?rev=1.13">あらゆる IP プロトコル</a>を使える。暗号化トンネル (VPN) も作れるし、コンピュータ間で単純な暗号化をしてもいい。
オプションが実にいろいろあるせいで、IPsec はちょっとややこしいのである (それも SSL よりずっと!)
<p>
IPsec を使う前に、
FAQ <a href="../faq6.html">6章</a> の推奨文献には
是非とも目を通しておいてほしい。特に、もし IP アドレスの考え方がわかっていなかったら、
<a href="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">Understanding
IP Addressing</a> (または、
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">ここ</a>)
は大いにお奨めだ。
<P>
論理的には、IPsec は以下のどんな形でも機能する:
<UL>
<LI>Host-to-Host
<LI>Host-to-Network
<LI>Network-to-Network
</UL>
ネットワークのからむすべてのシナリオで、ぼくたちはルータを念頭においている。
つまりは Host-to-Router (そしてこのルータは、ある<i>Network</i>の
トラフィックを制御して暗号化する)。
<P>
これから見るように、IPsec は VPN 接続用にトラフィックをトンネルできる。
でも、その応用は VPN よりはるかに広い。中央インターネット鍵交換登録所があれば、
インターネット上の全マシンはお互いにやりとりをするときに、
強力な暗号や認証が使えるようになるんだ！

<p>
<a name= "Why"></a>
<a name= "13.2"></a>
<h1>13.2 - そりゃ結構だけれど、このぼくがなぜ IPsecなんか使わにゃならんの?</h1>
</p>

<p>
インターネットのプロトコルである IP または IPv4 は、それ自体としては、転送しているデータに対して何の保護も提供しない。
送り主が、自分で名乗っている通りの存在かどうかすら保証してくれない。
IPsec はこれを解決しようとする。以下のサービスはそれぞれ独立と考えられているけれど、
IPsec はそれを統一的な形でサポートしている。

<p>
<h4>機密性</h4> 受信者以外の人には、どんなデータが通信されたかを
理解しにくいようにしておく。インターネット経由で
リモートのマシンにログインするとき、
ほかの人にパスワードを知られたくないよね。
<p>
<h4>完全性 (Integrity)</h4> データが途中で改竄されないようにする。
請求書データをオンラインで送るんなら、
数量や金額やアカウント番号が正確で、
途中で改竄されたりしていないか確かめたいでしょう。
<p>
<h4>Authenticity (正真性／確実性)</h4> データに署名して、それを送ったのが本当にあなただと他の人が
確認できるようにする。ドキュメントがインチキじゃないと確認できるのは、
どう考えてもよいことだ。
<p>
<h4>再送保護 (Replay protection)</h4> やりとりは、何度も繰り返すよう認められたもの以外は、
確実に一回だけしか生じないようにする方法が必要だ。つまり、
だれかがやりとりを記録しておいて、
それをそのまま再送して、結果として同じ応答を何度ももらう、ということができないようにする必要がある。
たとえば、攻撃者が暗号クラック以外の手段でトラフィックの趣旨を他の方法でつきとめて、
そしてそのトラフィックが、その人物にとって有利なイベントを生じさせるものと
しよう (かれの口座にお金を振り込むとか)。
その人物が、あとから単純に同じトラフィックを再送しても
うまくいかないようにする必要がある。
<i>警告: 通常の仕様に関する限り、手動鍵の IPsec を使っているとき 
(たとえば <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;apropos=0&amp;sektion=8&amp;format=html">ipsecadm(8)</a> を使っているとき)
には再送からの保護は実行されない</i>.

<p>
<a name= "Protocols"></a>
<a name= "13.3"></a>
<h1>13.3 - IPsec の裏にあるプロトコルは?</h1>
</p>

<p>
IPsec は、機密性、完全性、authenticity (正真性)、再送保護を提供するのに、
新しいプロトコルを 2 つ使う。このプロトコルは AH (
Authentication header, 認証ヘッダ) と ESP (Encapsulated security payload、暗号ペイロード) だ。
<P>
AH は認証と完全性と再送保護を提供する (が機密性は提供しない)。
ESP との主な差は、AH はパケットの
IP ヘッダの一部 (たとえばパケットの発信元・送り先アドレス) も
保護することだ。
<P>
ESP は認証、完全性、再送保護、データ機密性を
提供する (ヘッダにつづくパケット内のすべてを保護する)。
再送保護は認証と完全性が必要だ
(この二つはいつもペアでくる)。機密性 (暗号化) は、
認証/完全性があってもなくても使える。
同じように、認証・完全性は機密性なしでも使える。
<p>

<a name= "Wire"></a>
<a name= "13.4"></a>
<h1>13.4 - ネットワーク上のパケットフォーマット</h1>
</p>

<p>   <B>認証ヘッダ (Authentication Header)</B>
(AH) は基本的な IP ヘッダの後にきて、データの暗号ハッシュと
識別情報を持っている。ハッシュは 
IP ヘッダ自体の、伝送中に値が変化しない部分もカバーできる。
AH に使う実際のアルゴリズムについては、いくつか別個の RFC があって選べるようになっているけれど、
そのどれも、<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2402.html">RFC2402</a>に指定されたガイドラインには準拠していなくてはならない。

<P>The <B>暗号ペイロード (Encapsulating
Security Payload)</B> (ESP) ヘッダは、ペイロードを暗号化された形で書き換えることを可能にする。
ESP ヘッダは、それに先立つ IP
ヘッダは扱わないので、ペイロード以外のものについてはまったく保証しない。
それぞれ各種の ESP は <A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2406.html">RFC2406</A>にしたがう必要がある。
ESP ヘッダは、ペイロードの認証も提供できる (が ESP の外の
ヘッダについては認証できない)。

<P>IPsec 機能の (ほとんど) 独立した部分が、IPsec encapsulation を
やっているのがデータのもとの発信源かゲートウェイかに
応じて適用される:

<UL>
<LI><B>Transport</B> モードは、パケットを生成しているホストが使うものだ。
Transport モードでは、セキュリティヘッダはトランスポート層 
(e.g . TCP, UDP) のヘッダの前に、IPヘッダがパケットの先頭につけられる前の段階で追加される。
言い換えると、パケットに追加された AH が
TCP ヘッダと、end-to-end IP ヘッダの一部フィールドのハッシングを担当するということだ。
そしてTCP ヘッダとデータの暗号化は ESP
ヘッダがカバーするけれど、でもそれは end-to-end IP ヘッダは暗号化してくれない。</LI>

<LI><B>トンネル</B> モードは、すでに end-to-end IP ヘッダが
パケットに追加されているときで、さらにセキュア接続の片方の端が
ただのゲートウェイのときに使われる。このモードでは、AH と ESP ヘッダは、 end-to-end header を含め
パケット全体をカバーするのに使われる。そしてセキュア接続の向こう端までのホップのみ
(といっても、これはもちろん複数の IP ホップをまたがるかもしれないけれど) をカバーする、
新しい IP ヘッダがつけなおされる。</LI>
</UL>

<P>IPsec で保護されたリンクは、<B>Security Associations
</B>(SAs) によって定義づけられる。各 SA は単一の単方向のデータの流れについて定義されて、
普通は (マルチキャストは無視して) 一つの点から別の点までについて、
なんらかの<B>ユニークなセレクタ</B>によって識別できるトラフィックフローをさす。単一の SA 上を流れるトラフィックはすべて
同じ扱いを受ける。トラフィックの中には、複数の SA を経るものもあって、
そのそれぞれがなんらかの変換を加える。SA の集団を
SA <B>Bundle</B> と呼ぶ。入ってくるパケットは、3 つの定義フィールド
(<B>宛先 IP アドレス, セキュリティパラメータインデックス (Security Parameter
Index), セキュリティプロトコル</B>)に応じて指定の SA に割り当てることができる。
セキュリティパラメータインデックス (Security Parameter
Index、略して SPI) は接続のパラメータのネゴシエーションが行われるときに、SA の受け手が手渡すクッキーだと思えばいい。
セキュリティプロトコルは AH か ESP のどちらかでなくてはならない。受け手の IP
アドレスがこの３つ１組の中に含まれているので、これはユニークな値になることが保証されている。
これは外側の IP ヘッダから見つけることもできるし、最初のセキュリティヘッダ (これは SPI とセキュリティプロトコルを含む) から見つけることもできる。

<P>トンネルモードの AH パケットの例を挙げよう:
<p>
<table border="1">
<tr>
<td><B>IPヘッダ</B></td>
<td><B>AH</B></td>
<td>IPヘッダ2</td>
<td>TCPヘッダ</td>
<td>データ</td>
</tr>
</table>

<P>transport モード AH パケットの例を挙げよう:
<p>
<table border="1">
<tr>
<td><B>IPヘッダ</B></td>
<td><B>AH</B></td>
<td>TCPヘッダ</td>
<td>データ</td>
</tr>
</table>

<P>ESP ヘッダは外側の IP ヘッダを認証できないので、
AH と ESP ヘッダを組み合わせて次のようにしたほうがいい:
<p>
<table border="1">
<tr>
<td><B>IPヘッダ</B></td>
<td><B>AH</B></td>
<td><B>ESP</B></td>
<td><I>TCPヘッダ</I></td>
<td><I>データ</I></td>
</tr>
</table>

<P>これは <B>Transport Adjacency</B> と呼ばれる。トンネル版だと
こんな感じだ:
<p>
<table border="1">
<tr>
<td><B>IPヘッダ</B></td>
<td><B>AH</B></td>
<td><B>ESP</B></td>
<td><I>IPヘッダ2</I></td>
<td><I>TCPヘッダ</I></td>
<td><I>データ</I></td>
</tr>
</table>

<P>でも、これは RFC には明示的に記述されていない。Transport
adjacency と同じように、これはIP ヘッダの中のヘッダいくつかを除いて全パケットを認証したうえで、
ペイロード (イタリクスで表示) を暗号化する。
AH と ESP ヘッダがこのように直接いっしょに適用されているときには、
ヘッダの順番は上記のようになっている必要がある。トンネルモードでは、
任意の recursive encapsulation をやることで、この順番が指定されずにすむようにすることもできる。

<p>
<a name= "Config"></a>
<a name="13.5"></a>
<h1>13.5 - IPsec の設定</h1>
</p>

<P>IPsec システムとゲートウェイがどう設定されるかは、ある程度は設計者まかせに
なってはいるのだけれど、でも RFC はそれがどう実装されるべきかについて強いレコメンデーションを行って
混乱を最小限におさえようとしている。

<p>パケットに何が起こるかをコントロールする、管理エンティティが２つある。
一つは<B>Security Association Database</B> (SAD, 
OpenBSDの IPsecソースコードの中では、TDB または TDB table と呼ばれている) で、
もう一つは<B>Security Policy Database</B> (SPD)だ。

<P>この二つは、あるトラフィックを表現したセレクタをいくつか与えられると、
必要となる処理を記述したエントリを提供してくれるという点で似ている。
でもSPD は実際の処理から二段階ほど遠いところにある: 
SPD は外へ出るパケットに使われて、どの SAD エントリを使うべきか決めるのに利用される。
逆に SAD エントリは、実際のプロセスとそこで使うパラメータを記述する。
SPD のエントリは、既存の SAD エントリのうちどれを使うか
(バンドルなら、SAD エントリは複数あり得るので) を指定するけれど、でもすでに
適切なものがないなら、そのエントリを使って新しいものがつくられる。つくられる SA のフィールドは、
SPD エントリから持ってくる場合もあるし、そのフィールド新設を
開始させたパケットから持ってくる場合もある。

<P>　外行きのパケットは、SPD エントリから個別の SA に行ってエンコーディング用
パラメータをもらう。入ってくるパケットは、SPI/宛先IP/プロトコルの 3 点セットを使って
直接正しい SA にたどりつき、そこから SPD エントリにたどりつく。

<P>　SPD はまたどのトラフィックが IPsec をバイパスすべきか、またどのトラフィックを
捨てるべきかを指定できるので、入ってくる非 IPsec のトラフィックについても参照されなくてはならない。
SPD エントリは、順番が明示的に示されている必要がある。あるパケットに複数のものがマッチする可能性があるし、
処理には再現性がなくてはならないからだ。

<P>SPD というのは、パケットフィルタと似たようなものだと思えばいいかもしれない。そこで決定されるアクションというのは、
SA プロセスの起動になるわけだ。セレクタとして使えるのは
送信元と宛先アドレス、関係ある場合にはポート番号、アプリケーションや、ある場合にはユーザ ID
(これは host based transport SAのみ)、ホスト名、セキュリティ
感度レベル、プロトコルなどだ。

<P>SAD エントリに含まれるのはたとえば:

<UL>
<LI>宛先 IP アドレス
<LI>IPsec プロトコル(AH か ESP)
<LI>SPI (クッキー)
<LI>シーケンスカウンタ
<LI>Seq O/F フラグ
<LI>Anti-replay window info
<LI>AH の種類と情報
<LI>ESP の種類と情報
<LI>寿命情報
<LI>Tunnel/transport モードフラグ
<LI>Path MTU 情報
</UL>

<P>SPD エントリに含まれるのは:

<UL>
<LI>SA起動ポインタ
<LI>セレクタフィールド
</UL>

<P>各 SA は、ESP ヘッダ一つと AH ヘッダ一つを定義できる。
IPsec セッションはこのどちらか、あるいは両方を持たなきゃならない。どちらのヘッダもなしで定義されることは
できない――さもないと、SA を参照するための SPI を指定するヘッダがないことになってしまう。
RFC は、AH とESP ヘッダが SPI の値について
別々の指定をしている場合のことは定義していない。察するに、
これはバンドル中の複数の SA を意味するものと判断されるだろう。

<P>OpenBSD の SPD は、<tt>ipsecadm flow</tt> コマンドを使って管理される
(これに変更を加えるのは、手動鍵設定を使う場合だけだ)。
SAD エントリは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&apropos=0&sektion=8&format=html">ipsecadm(8)</a>を使えばマニュアルで設定できるけれど、
IETF はセッションや鍵交換の初期化などの
自動メカニズムも定義している。
OpenBSD は Photuris (<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2522.html">RFC2522</a>および
<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2523.html">RFC2523</a>)
と ISAKMP 自動鍵交換
(<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC2407</a>,
<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC2408,</A> and
<A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC2409</A>)
を実装していて、それぞれ
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=photurisd&apropos=0&sektion=8&format=html">photurisd(8)</a>
と <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd&apropos=0&sektion=8&format=html">isakmpd(8)</a>
デーモンで使われている。

<p>
a name= "ManKey"></a>
<a name= "13.6"></a>
<h1>13.6 - 手動鍵設定で IPsec を設定するにはどうするの?</h1>
</p>
<P>
IPsec の手始めとしていちばんかんたんなのが手動鍵設定だ。
この手法でネットワーク間を暗号化して VPN をつくれる。
この部分を読んだら、この設定を
自動化するのに<A HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/rc.vpn?rev=1.3">/usr/share/ipsec/rc.vpn</a>
を使う、なんていうのもやってみるといいかもしれない。
<P>
まず、OpenBSDカーネルの IP AH と IP ESP オプションを有効にしよう
(もし rc.vpn スクリプトを使っていたり、あるいは
この次の例のように、ESP だけを使っているような場合には <i>AH は有効にしないでいい。</i>それどころか、
使っていないのに AH を有効にするとセキュリティ上の問題が
発生するかもしれない)。<P>
こういうプロトコルを有効にするための、すてきな sysctl がある。
<ul><tt>
# <b>sysctl -w net.inet.esp.enable=1</b><BR>
net.inet.esp.enable: 0 -&gt; 1<br>
# <b>sysctl -w net.inet.ah.enable=1</b><br>
net.inet.ah.enable: 0 -&gt; 1
</tt></ul>
起動時にこれをたちあげるには<tt>/etc/sysctl.conf</tt> を編集すればいい。
使いたいものに応じてnet.inet.esp.enable そして/あるいは
net.inet.ah.enableの前の # をはずし、それが 1 にセットされている
ことを確かめよう。
<P>
さらに手動鍵の生成も必要だ。
VPN のセキュリティは、この鍵を推定するのが不可能だという点にかかっているので、
この鍵を選ぶのには強力な乱数源を使うのがとてもだいじだ。
これを生成するのに実用性が高い方法の一つとして、
<A HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=random&sektion=4&format=html">random(4)</a>
デバイスを使う手がある。たとえば160ビット分の乱数性をつくりだすには、以下のようにする:
<UL><tt>
# <b>dd if=/dev/urandom bs=1024 count=1 | sha1</b>
</TT></UL>
生成されるビット数はだいじだ。暗号の種類によって、必要な鍵のサイズがちがう。
<PRE>
暗号方式    鍵長
DES       56 bits
3DES      168 bits
BLF       可変 (160 bits 推奨)
CAST      可変 (40-128 bits 推奨)
SKIPJACK  80 bits
</PRE>
<P>
では、SA (Security Associations) の設定をしよう。
Security Association というのは、IP アドレス、SPI, 
セキュリティプロトコル (AH そして/または ESP) の組み合わせだ。IP アドレスは、あなた自身のものと、
送り先のもの両方だ。SPI (Security Parameter
Index) は各種 SA の分類に OpenBSD が使う番号だ。
<P>
<I>これらの例は、トラフィックの暗号化に ESP しか使わない。ESP は
暗号化された中身のデータの認証はするけれど、AH とはちがって
それを包む IP ヘッダは認証してくれない。この「限られた認証」は、
それでもほとんどの場合にはまったく十分なものだ。特にトンネル環境での
ESP の場合には。</I>
<P>
<ul>
<tt>
# <b>ipsecadm new esp -spi SPI_OUT -src MY_EXTERNAL_IP -dst PEER_EXTERNAL_IP
-forcetunnel -enc blf -auth sha1 -key ENC_KEY -authkey AUTH_KEY</b>
</tt>
</ul>
<P>
これを二つのルータで実際にやってみよう。ルータの IP アドレスはそれぞれ 192.168.5.1 と 192.168.25.9 だ。
<P>
ホスト192.168.5.1 上では:
<UL>
<TT>
# <b>ipsecadm new esp -spi 1000 -src 192.168.5.1 -dst 192.168.25.9 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b><BR>
# <b>ipsecadm new esp -spi 1001 -dst 192.168.5.1 -src 192.168.25.9 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b>
</TT>
</UL>
ホスト 192.168.25.9 上では:
<UL>
<TT>
# <b>ipsecadm new esp -spi 1001 -src 192.168.25.9 -dst 192.168.5.1 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b><BR>
# <b>ipsecadm new esp -spi 1000 -dst 192.168.25.9 -src 192.168.5.1 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b>
</TT>
</UL>
<P>
ごらんのように、SPI がちがっている。SPI が何で、それがどこで使われているかについての完全な説明は、<A HREF="#13.4">On the wire format</a> を参照。
<P>
これで Security Associations ができあがったので、
フローを設定しよう。
<P>
まずは 192.168.5.1 から:<P>
さてここでいきなり、フローが<b>2つ</b>創られる。一つはローカルのソースアドレスで、
ローカルホストから出て目的地に向かうすべてのパケットをカバーし、
もう一つのフローは送り先からローカルホストに戻ってくる
フローだ。
<ul>
<tt>
# <b>ipsecadm flow -proto esp -dst 192.168.25.9 -spi 1000
-addr 192.168.5.1 255.255.255.255 192.168.25.9 255.255.255.255</b>
</tt></ul>
192.168.25.9側ではこんな具合だ:
<ul>
<tt>
# <b>ipsecadm flow -proto esp -dst 192.168.5.1 -spi 1001
-addr 192.168.25.9 255.255.255.255 192.168.5.1 255.255.255.255</b>
</tt></ul>
<P>
もし Host-to-Host VPN のオーバーヘッドを減らしたければ、SPI
を作るのに <tt>-forcetunnel</tt> をはずしておくと、transport モードが使える (<tt>-forcetunnel</tt>
を使うと IP ヘッダまで含んだ IP パケットのすべてが必ずSPIにカプセル化
される)。もし
発信元か送り先のどちらかがネットワークなら、トンネルモードを使うしかない。
ネットワークから出入りするトラフィックに SA を使うと、自動的に
トンネルモードの SPI が確実に作られることになる。
<p>
これはIPsecを使い始める簡単なやりかただ。
<P>
IPsec を使えば、プライベート IP アドレス空間をインターネットごしにつなげる。
いい例を挙げよう……208.1.1.1の背後にある 192.168.99.0/24 と、
208.2.2.2の背後にある 208.1.5.0/24 と 208.1.2.0/24 をトンネルでつなげたいとしよう。
以下の例は <A HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/rc.vpn?rev=1.3">rc.vpn</a> スクリプトを使って生成したものだ。
<P>
ごらんのとおり、IPsecで手動鍵設定を使っていると、
やってほしいことを<b>ずばり正確に</b>指定しなきゃダメだ。
あなたのかわりに見当をつけてくれたりはしない。以下の例をみてごらん……
<h2>208.1.1.1 の側では:</h2>
まず、security associations (SA) を設定しよう:<BR>
(これで SPI, 暗号化の方法と鍵が設定される) 
<UL><tt>
# <b>ipsecadm new esp -src 208.1.1.1 -dst 208.2.2.2 -forcetunnel -spi 1001 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -src 208.2.2.2 -dst 208.1.1.1 -forcetunnel -spi 1000 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
</tt></ul>
次に、208.1.1.1 から 208.2.2.2へのフローを設定：
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.2.2.2 255.255.255.255</b><br>
</tt></ul>
次に  208.2.2.2の背後にある208.1.2.0/24 から 192.168.99.0/24へのフローを設定：
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.1.2.0 255.255.255.0</b><BR>
</tt></ul>
次に 208.2.2.2の背後にある 208.1.5.0/24 から 192.168.99.0/24へのフローを設定：
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.1.5.0 255.255.255.0</b><br>
</tt></ul>
こんどは 208.2.2.2の背後にある 208.1.2.0/24 からルータ 208.1.1.1へのフローを設定：
<ul><tT>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.1.2.0 255.255.255.0</b><br>
</tt></ul>
オッケー、では 208.2.2.2の背後の 208.1.5.0/24 からルータ 208.1.1.1へのフローを設定
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.1.5.0 255.255.255.0</b><br>
</tt></ul>
最後に、ルータ 208.2.2.2 から 192.168.99.0/24へのフローを設定しよう
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.2.2.2 255.255.255.255</b><br>
</tt></ul>
<P>
<h2>208.2.2.2側では:</h2>
前と同じように、まずは SAの設定から……
<ul><tt>
# <b>ipsecadm new esp -src 208.2.2.2 -dst 208.1.1.1 -forcetunnel -spi 1000 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -src 208.1.1.1 -dst 208.2.2.2 -forcetunnel -spi 1001 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
</tt></ul>
さてこっちは裏返しになるので……
ルータ 208.2.2.2 から 208.1.1.1へのフローを設定：
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.2.2.2 255.255.255.255 208.1.1.1 255.255.255.255</b><br>
</tt></ul>
208.1.1.1の背後にあるネットワーク 192.168.99.0/24 から 208.1.2.0/24へのフローを設定：
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.2.0 255.255.255.0 192.168.99.0 255.255.255.0</b><br>
</tt></ul>
208.1.1.1の背後にあるネットワーク 192.168.99.0/24 から 208.1.5.0/24へのフローを設定：
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.5.0 255.255.255.0 192.168.99.0 255.255.255.0</b><br>
</tt></ul>
では208.1.1.1の背後の 192.169.99.0/24 からルータ 208.2.2.2へのフローを設定：
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.2.2.2 255.255.255.255 192.168.99.0 255.255.255.0</b><br>
</tt></ul>
はーい、もうすぐおしまいですよー……
208.1.2.0/24 と 208.1.5.0/24 をルータ 208.2.2.2から 208.1.1.1まで届けるのに、
あとフロー2つだけ：
<ul><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.2.0 255.255.255.0 208.2.2.2 255.255.255.255 -ingress</b><br>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.5.0 255.255.255.0 208.2.2.2 255.255.255.255 -ingress</b><br>
</tt></ul>
<P>
ipsecadm を使っていて、自分のやった作業をぜんぶご破算にして
一からやりなおしたければ、次のようにする：
<ul><tt>
# <b>ipsecadm flush</b>
</tt></ul>
これですべての IPsec 情報 (SPI、フロー、ルーティングのエントリ) がシステムから一掃される。

<p>
<a name= "Photuris"></a>
<a name="13.7"></a>
<h1>13.7 - photurisd の設定はどうやるの?</h1>
</p>
<P>
Photuris はまだあまり使われていないし、
RFCのステータスから言えばまだ実験段階だ。でも OpenBSD ではたくさんの人が
利用してきた。
<P>
photurisd を設定するには、まず /etc/photuris/secrets.conf
を photurisd を持ったホストのすべてで編集すること。
<UL>
<PRE>
# <b>cat /etc/photuris/secrets.conf</b>
# Accepted keywords are:
# identity local &quot;id&quot; &quot;secret&quot;
# identity pair local &quot;receivedid&quot; &quot;myid&quot; &quot;secret&quot;
# identity remote &quot;id&quot; &quot;secret&quot;
# identity lookup &quot;tag&quot; username
# Simple 
identity local &quot;Default&quot; &quot;ここを変える&quot;
identity remote &quot;Default&quot; &quot;ここを変える&quot;
</PRE></UL>
&quot;ここを変える&quot; の部分を、local config 側で好きな鍵にして、
それから remote config では別の好きな鍵にしよう。
(リモートボックスでも config を使うこと。ただし &quot;local&quot; 
&quot;remote&quot; を入れ替えて、リモートホスト側にとってはそっちがローカル鍵になるようにする。)
なお、これらの鍵は将来の photurisd のバージョンでは、
最初の鍵交換を公開鍵で行うような形で置き換わることになるので注意。
<P>
<tt>net.inet.ah.enable</tt> が 1に設定されていることを確認しよう。
<UL><PRE>
# <b>sysctl -w net.inet.ah.enable=1</b>
net.inet.ah.enable: 0 -&gt; 1
</PRE></UL>
それから startkeyを実行。
<UL><PRE>
# <b>startkey dst=remote.host</B>
</PRE></UL>
それでは tcpdump を実行して、パケットが AHで暗号化されていることを確認してみよう
(別のウィンドウでpingするとか、なんかセッションを開始してトラフィックをつくること)。
<UL><PRE>
# <b>tcpdump proto ah</b>
</PRE></UL>
なにも出てこないようなら、tcpdump をホストアドレス側で使ってみる手がある。
<UL><PRE>
# <b>tcpdump host remote.host</b>
</PRE></UL>
photurisd が自動的に発信元と送り先のホストやネットワークを設定するように
するには、 /etc/photuris/photuris.startupに記述しておく。

<p>
<a name= "isakmpd"></a>
<a name="13.8"></a>
<h1>13.8 - isakmpdの設定は?</h1>
</p>
<p>VPNs をはじめ IPsec の各種伝統的なアプリケーションを考えているなら、
たぶん ISAKMP を使うことになる。IPsec の商業実装の
一部は、手動鍵設定をさせてくれないので、
なんらかの形の ISAKMP を使うしかなくなる。
<P>

<h3>13.8.1 - isakmpdってなに?</h3> ISAKMP (ときどき IKE, 
Internet Key Exchange、インターネット鍵交換、自動鍵交換とも呼ばれる) は VPN 用の鍵交換メカニズムだ。
RFC 2407, RFC 2408、RFC 2409に記述された手法を使ってセキュリティ上の問題をクリアしている。
ISAKMP は、通常なら <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&apropos=0&sektion=8">ipsecadm(8)</a>
を使わなくてはならないような暗号家具のやりとりを管理してくれる。
二つの IPsec ノード間で IPsec パラメータを確立するために、
二段階プロセスを採用している。

<P> <b>フェーズ 1</b> - ISAKMP ピア２つは、保護され認証されたチャネルを確立し、
２つのデーモン間で通信ができるようにする。これは
両ホスト間で Security Association (SA) を確立する。このチャネルを確立するための手法は、<b>Main
Mode</b> と <b>Aggressive Mode</b> だ。
Main Mode は各種認証情報を
特定の順番で送り、アイデンティティの保護を提供する。Aggressive Mode は
アイデンティティ保護は提供しない。認証情報を
すべて一気に送るからだ。Aggressive mode を使うのは、
ネットワークの帯域幅が狭いときだけにしたほうがいい。
<P>

<b>フェーズ 2</b> - Security Associations が IPsec にかわってネゴされる。
フェーズ 2 は IPsec ホスト間にトンネルか endpoint SA を確立する。
フェーズ 2 では <b>Quick Mode</b> が使われる。フェーズ 1 ですでに SA が確立しているので、
完全な認証をくり返さなくていいからだ。

<P>

手短にいえば、フェーズ 1 は保護されたチャネルを確保するのに使われて、そこで
(もっと手早い) フェーズ 2 の設定が行われる。同じフェーズ 1 チャネルの中で、複数のフェーズ 2 設定を
することもある。フェーズ 2 は実際のトンネルを設定するのに使われる。
フェーズ 1 では IPsec ノード同士が接続を確立して
認証を交換する (X.509 証明か、
事前に共有した秘密)。これで両端とも、相手が認証されたことを
確認できる。フェーズ 2 は鍵の交換で、両者の間のデータが
どう暗号化されるかを決める。

<h3>13.8.2 - isakmpdことはじめ</h3>

<P>
デフォルトで OpenBSD は ISAKMP と
IPsec スタック用のバイナリがついてくる。残念ながら、
サンプルファイルはデフォルトではない。これを手に入れるには、ソースツリーから以下のものを取ってこよう:
/usr/src/sbin/isakmpd/samples/VPN-east.conf and
/usr/src/sbin/isakmpd/samples/policy
CD-ROM (当然持ってるよね) からでもいいし、<A
href="http://www.openbsd.org/cgi-bin/cvsweb/">cvsweb</a> や
<a href="http://www.usa.openbsd.org/anoncvs.html">コマンドライン CVS
クライアント</a>. を使ってもいい (Cvsweb は <a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/samples/VPN-east.conf">VPN-east.conf</a>
と <a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/samples/policy">policy</a>
を用意してある)。この例で使うには、<i>policy</i>
を /etc/isakmpd/isakmpd.policy にコピーしよう。<i>VPN-east.conf</i> は /etc/isakmpd/isakmpd.confにコピーする。
ここでは、VPN (トンネル) の設定の仕方を説明してみる。もし
isakmpd を個別ホスト間で使いたければ、<i>samples</i> ディレクトリにそれ用のサンプルが
入っている。
man ページに詳しい情報があるので、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&sektion=5">isakmpd.conf(5)</a> と
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&sektion=5">isakmpd.policy(5)</a> をお忘れなく。

<p>
まずは esp の起動からだ。FAQ セクションの頭のところの <a href="#ManKey">
Manual Keying</a> で、これを実行時・起動時にそれぞれやる方法を説明している。
次に /etc/isakmpd.policy の編集だ。
このファイルは ISAKMP に、だれが IPsec にアクセスできるかを教える。このシナリオでは、この policy ファイルは、
Encapsulate Security Payload(ESP) を使ってデータを送ってきて、mekmitasdigoat というパスワード (これはあなたが
勝手に決めればいい) で認証された相手なら、だれでも isakmpd と通信できると述べている。このファイルをを変更して、
特定のデジタル証明書で署名されたデータだけを認めるとか、特定の暗号変換を使ったデータだけを認めるとか、
希望をISAKMPに伝えられる。まただれでも IPsec が使えるようにしてもいい。これはテスト用だけにしておくのが望ましい。
万人にアクセスさせるには、policy ファイルを編集して以下だけにしよう:
<BR>
<UL><PRE>
KeyNote-Version: 2
Authorizer: &quot;POLICY&quot;
</PRE></UL>
<P>
同じ policy ファイルには $ のついた行が二行ある。
使う前にこの２行は削除すること。CVS でしか使わない。
<P>
この例で、もっと使い物になる policy ファイルはこんな感じだ:
<BR><UL><PRE>
KeyNote-Version: 2
Comment: この policy は正しいパスワードを使うリモートからの ESP SA を受け付ける
Authorizer: &quot;POLICY&quot;
Licensees: &quot;passphrase:mekmitasdigoat&quot;
Conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; -&gt; &quot;true&quot;; 
</pre></UL>
これを実装すれば、ESP だけを使った基本的な VPN (トンネル) ができあがる。
ホスト A では /etc/isakmpd/isakmpd.conf を編集する。見本で入っている249.2.2.2 という IP アドレスは、
ホスト A の実際の外部 IP アドレスに書き換えること。

<UL><PRE>
[General] 
Retransmits=		5
Exchange-max-time=	120
Listen-on=		249.2.2.2
</PRE></UL>

同じようなことをホスト B の isakmpd.conf でもやろう。249.3.3.3 は
ホスト B の外部 IP アドレスだ。

<UL><PRE>
[General]
Retransmits=		5
Exchange-max-time=	120
Listen-on=		249.3.3.3
</PRE></UL>

<p>ここで isakmpd のおもなふるまいを決める変数を設定できる。ここでは
デフォルトを使っておけばいい。
<b>Listen-on</b>= value は、isakmpd が聞き耳をたてるべき IP 
を指定する。あなたのゲートウェイのインターネット IP だけが必要だ。
ゲートウェイに複数の外部インターフェースがあるなら、
コンマで区切った一覧形式で入力して、どのインターフェースを聴いてほしいか一覧にできる。
<P>
次にホスト A で、もう一度isakmpd.conf を編集しよう。

<UL><PRE>
[Phase 1]
249.3.3.3=		HostB
</PRE></UL>

ホスト Bでは:

<UL><PRE>
[Phase 1]
249.2.2.2=		HostA
</PRE></UL>

<p>この部分は、フェーズ 1 接続のネゴシエーションをするときに受け付けるべき IP アドレスを記述する。
ここでの値は下の部分を指している (フェーズ 1 は単にリモートのピアを認証して、
それが主張通りの相手だと確認するだけなのをお忘れなく)。
IP_Address=<i> &lt;PEER-NAME&gt;</i>という形式で複数のピアを記述できる。
<p>
次にホスト Aでは:
<UL><PRE>
[Phase 2]
Connections=		HostA-HostB
</PRE></UL>

ホスト Bでは:

<UL><PRE>
[Phase 2]
Connections=		HostB-HostA
</PRE></UL>

<p>これは接続のフェーズ 2 を記述したもの。このフェーズは、通信に両
ピアが使うプロトコルを決めるところだ。

<p>The <b>Connections</b>= tag は、その下のセクションをさす。
フェーズ 2 を設定するために受け入れられるメソッドや要件をイニシエートする。これはまた、
いったん開始したらどの接続をイニシエートすべきかをISAKMPD に告げる。
複数のピアホストにつなぐつもりなら、
以下のように複数のセクションを書いてもいいことに注意。

<p>リモートホストの IP アドレスがわからなければ、 <b>Connections</b>= tag に
挙がっていない IP からの接続で参照される、汎用エントリをあるセクションに記述しておいて、
それを Default= で指定するようにすればいい。
<P>
ホスト Aでは:
<UL><PRE>
[HostB]
Phase=			1
Transport=		udp
Local-address=		249.2.2.2
Address=		249.3.3.3
Configuration=		Default-main-mode
Authentication=		mekmitasdigoat
#Flags=
</PRE></UL>

ホスト Bでは:

<UL><PRE>
[HostA]
Phase=			1
Transport=		udp
Local-address=		249.3.3.3
Address=		249.2.2.2
Configuration=		Default-main-mode
Authentication=		mekmitasdigoat
#Flags=
</PRE></UL>

これらは上で説明したフェーズ 1 の部分で参照されているセクションだ。それぞれ
フェーズ 2 に進むためにピアのゲートウェイが満足しなければならない要件を記述している。ほかにもオプションは
たくさんあるけれど、上に挙げたものは最低限必要なものだ。
<ul>
<li><b>Phase=1 </b>が必要なのは、 ISAKMPD コードがフェーズ 1 とフェーズ 2 を処理するのに同じプロシージャを使うからだ。
これを <b>1</b> にしないと、何一つ機能しなくなる。
<li><b>Transport= </b> は、ピアごとにちがう可能性がある。ここでは
udp を使うことにしてあるので、そういうことにしておこう。
一部のピアはファイアーウォールの背後にあって、UDP トラフィックを通さない場合があることに注意。これは当然ながら、設定前に確認しておく必要がある。
<li><b>Local-address </b>は入ってくるパケットが指す目的アドレスだ。一部のケースでは、
フェーズ 1 の接続のために聴くインターフェースがちがっているかもしれない。
この例では、インターフェースは一つしかないので、このピアで聞き耳をたてる
インターフェースの IP がそれになる。
<li><b>Address= </b>は、入ってくるパケットのソースIP。これはピアゲートウェイを
指すのがふつう。
ここはもっと説明が必要。ピアの発信する IP アドレスは事前にわからないことがあるから。
<li><b>Configuration= </b>は、下のセクションを指す。ここでやったような形で
複数のセクションを指定できる。ここではサンプルファイルにあった
デフォルト値を使おう。
<li><b>Authentication=</b> は、このピアが使うはずの、
事前に共有してある秘密。このパスワードが policy に渡されて、
このピアがこのホストと IPsec を使っていいことになっているかを確認する。ここのパスワードを変えたら、
policy ファイルでの記述も変える必要がある。sample ファイルがこのパスワードに応じて提供されるからだ。
最低限の policy ファイルで行くつもりなら、ここでは好きなものを指定すればいい。
<li><b>Flags=</b> はいまは使われていない。RFC では、フェーズ 1 用の追加オプションを指定するための予備として
これを残している。
<p>ほかのオプションを指定するためのタグもたくさんある。詳しくは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&apropos=0&sektion=5&format=html">isakmpd.conf(5)</a>
を参照。
</ul>
<P>
ホスト Aでは:
<UL><PRE>
[HostA-HostB]
Phase=			2
ISAKMP-peer=		HostB
Configuration=		Default-quick-mode
Local-ID=		Net-A
Remote-ID=		Net-B
</PRE></UL>

ホスト Bでは:
<UL><PRE>
[HostB-HostA]
Phase=			2
ISAKMP-peer=		HostA
Configuration=		Default-quick-mode
Local-ID=		Net-B
Remote-ID=		Net-A
</PRE></UL>

<p>これらは、上記のフェーズ2で参照されているセクションをあらわしている。これは
個別の接続のために、二つのゲートウェイ間で話をするのに ISAKMPD が使うべき
個別設定なのだ。
<ul>
<li><b>Phase=2</b> は必須。ISAKMPD コードは、フェーズ 1 と
フェーズ 2 の認証に同じ関数を使うから。これがないと VPN は機能しない。
<li><b>ISAKMPD-Peer=</b> は、上でのホストのセクションの名前だ。つまりフェーズ 2 接続を確立するために、
ここで指定したピアと話をしているんですよ、という意味だ。これがあるのは、 isakmp ピアや接続を記述するのに
複数のセクションがある場合もあるからだ。
<li><b>Configuration=</b> は、下のセクションで、このホストと接続における指定のピアとが
したがうべき規格を記述した部分をさす。
<li><b>Local-ID=</b> は、ピアのゲートウェイへのこのプライベートネットワークを
記述した、以下の IPsec-ID セクションを指す。この部分が送られて、向こう側のゲートウェイがVPN経由で
こちらのネットワークにデータを転送するためのルーティングテーブルをきちんと設定できるようにする。
<li><b>Remote-ID=</b> これは、こちらのホストから見て、リモートのプライベートネットワークで
あるはずのものを記述した、下のIPsec-ID セクションを記述しているこの部分が解釈されて、こちらのプライベートネットワークから
VPN経由でリモートのプライベートネットワークにデータを転送するためのルーティングテーブルをきちんと設定する。
<p>ここでサポートされているタグがもう一つあって、それが Flags= だ。このタグが必要なら
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&apropos=0&sektion=5&format=html">isakmpd.conf(5)</a>を読んでほしい。
</ul>
<P>
ここはIPsec-ID セクションだ。以下のエントリは、ホストAとホストBの
両方で isakmpd.conf ファイルの中になければいけない。この例だと
ホストA (これは上の Net-Aに
つながっている) では 192.168.1.0/255.255.255.0 、ホストB (これは上の Net-Bにつながっている) では192.168.20.0/255.255.255.0 だ。
<UL><PRE>
[Net-A]
ID-type=		IPV4_ADDR_SUBNET
Network=		192.168.1.0
Netmask=		255.255.255.0

[Net-B]
ID-type=		IPV4_ADDR_SUBNET
Network=		192.168.20.0
Netmask=		255.255.255.0
</PRE></UL>

<p>この二つのセクションが各ホストの <b>conf</b> ファイルに含まれている。これが
<b>Local-ID</b> と <b>Remote-ID</b>の識別しで参照されるセクションだ。一つの
プライベートネットワークから、別のプライベートネットワークへのトラフィックを可能にするのに設定されるべき経路と記述している。
<b>ID-type</b>= は <b>IPV4_ADDR_SUBNET</b> か <b>IPV4_ADDR</b>がとれる (RFC2708 にはほかにも有効な値があがっている。OpenBSDの実装ではいまのところIPv4 しかサポートされていない。IPv6 は、OpenBSD-current でサポートされているかもしれない)。
 
<P>
　これで両方のホストで、sample ファイルはこんな具合になっているはずだ:
<UL><PRE>
[Default-main-mode]
DOI=			IPSEC
EXCHANGE_TYPE=		ID_PROT
Transforms=		3DES-SHA
</PRE></UL>

このセクションはフェーズ 1 接続で使う暗号方式の要件を記述している。名前は
<i>Configuration=</i> 変数のとる値を反映している。ごらんのとおり、
Domain of Interest (DOI) を IPSEC として記述した。<b>EXCHANGE_TYPE</b> 変数は、フェーズ 1 では <b>ID_PROT</b> に設定してある、
これはこの認証でカバーされるプロトコルを指定している。
<b>Transforms=</b> はこのやりとりで必要とされる (または指定される) 暗号変換方式だ。この例では、
これは設定ファイルの下のセクションをさしていて、そこでは、われわれは3DESで暗号化されていて
SHAで確認できるチェックサムを持つパケットを受け取る、と書いてある。
サンプルの<b>VPN-east.conf</b>には、いろいろ変換方式が山ほどかいてある。なぜかというと 3DES や SHA は各種プラットホームで必ずしもサポートされいる
わけではないからだ。OpenBSD の場合、これを基本的な設定で変えるべき理由は特にない。このセクションをコピーして変換方式を変えるのは、
ぞんぶんにやってほしい。唯一、必要になるのは、 Configuration= 変数も変えることだ。

<UL><PRE>
[Default-quick-mode]
DOI=			IPSEC
EXCHANGE_TYPE=		QUICK_MODE
Suites=			QM-ESP-3DES-SHA-PFS-SUITE,QM-ESP-DES-MD5-PFS-SUITE
</PRE></UL>

<p>このセクションは、VPN経由で送られるデータの暗号の要件を記述するところで、
上の <i>Configuration</i> で参照される。このセクションと、
すぐ上のフェーズ 1 でここに相当するところとのちがいは、 <b>EXCHANGE_TYPE</b> が <b>QUICK_MODE</b>になっていることなのに注目。
フェーズ 2 では必ずこうなる。
<b>Suites=</b> は IPsec Suite セクションを指している。
両ホスト間で提供されている各種の暗号方式を記述したものだ。
ISAKMP と IPsec については、ほかにも説明することがいっぱいある。いまの基本的な説明をもとに、
自立してやっていける単純ながらも堅牢なVPNができる。
でもこれは、両ホストにとって<i>必要最低最小限の</i> 
<b>isakmpd.conf</b> でしかない。
 
<h3>13.8.3 - isakmpdの起動</h3>
最初にこのデーモンを走らせるときには、以下のコマンドを使おう：
<P>
<ul>
<tt># <b>isakmpd -d -DA=99</b></tt>
</ul>
<P>
デーモンはデーモンモードでは走らず、ふつうのプロセスとして
走る。そしてすべてをターミナルに出力する。isakmpdを止めて
経路を一掃するには、各ノードでisakmpd プロセスを殺してから
<b>ipsecadm flush</b>を実行しよう。

<p>
<a name= "x509"></a>
<a name="13.9"></a>
<h1>13.9 - isakmpd を X.509 証明書といっしょに使うには?</h1>
</p>
<P>
事前に共有した鍵のかわりに証明書を使うように isakmpd を設定するのは、保護されていないピアがたくさんある巨大ネットワークの場合には、
小さなネットワークにくらべてそんなにむずかしくない。むしろ設定が簡単になって、さらに重要なこととして
鍵管理も簡単になるかもしれない。
<P>

<h2>証明書の生成</h2>

鍵や証明書の生成の仕方についてのよい記述が、isakmpd
ソースディレクトリの
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/README.PKI?rev=1.7">README.PKI</a>
ファイルに書いてある。必要なのは
CA 鍵、対応する CA X.509
証明書、ネットワーク上の isakmpd を使うコンピュータそれぞれに秘密鍵一つと、その秘密鍵のそれぞれに対して X.509
証明書一つずつだ。
<p>
X.509 証明書は、証明書の持ち主を記述する Subject Alternative Name
(SubjectAltName) extension が必要だ。証明書の SubjectAltName extension を
certpatch を使って設定する方法も、
SubjectAltNameとしてIPアドレスを設定する場合の説明が README.PKI に書いてある。
ここで IP アドレスを使うのは、isakmpd の
デフォルトのふるまいでもある。
<p>
Certpatch はまた、 FQDN (Fully Qualified Domain
Name) か UFQDN (User FQDN) の使用もサポートしている。FQDN の例はたとえば
<tt>www.openbsd.org</tt> だし、UFQDN の例としては
メールアドレスがある。たとえば <tt>Jorgen.Granstam@abc.se</tt> など。
<p>
この howto 文書では、 FQDN を
SubjectAltNames で使う。IP アドレスを使うほうがちょっと簡単になる。
それが isakmpd のデフォルトのふるまいだからだ。
でも、すぐにわかるように大した差ではない。
<p>
FQDN SubjectAltName を証明書に入れるには、
こんな感じにすればいい：
<p>
<UL><TT>
$ <b>/usr/sbin/certpatch -t fqdn -i home.mysite.se -k ca.key originalcert.crt newcert.crt</b>
</TT></UL>
ここで ca.key は CA の秘密鍵なので、これが
できるのは CA 秘密鍵にアクセスできる人だけだ。
home.mysite.se というのは (実在はしないけれど) 証明書に挿入されるべき FQDN だ。
originalcert.crt と newcert.crt のファイル名は同じ名前にしてもいい。
この場合、もとのファイルは新しい変更済みの証明書に
上書きされる。
<p>
この鍵と証明書を、README.PKI の最後に説明にしたがってディレクトリに
放り込もう。もし本気で鍵を使うつもりなら、CA 鍵 (ca.key) は
どこか安全なところにしまっておこう。


<h2>isakmpdの設定</h2>
  
こんどは /etc/isakmpd/isakmpd.conf 設定ファイルを見てやろう。
これはもともと
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&sektion=5">isakmpd.conf(5)</a>
のサンプルファイルから取ったものだけれど、かなり書き換えてある。
さらに、この設定の理解をより簡単にするために、man ページにある
ものよりもかなり短いファイルを使う。さらにコメントも追加して
 (一部のコメントは isakmpd.conf(5)にあったまま)、名前もちょっと変えた。
ここで使ったドメイン名は、ぼくの知る限りでは一つも実在していない。
<p>
実はこれを読む人はみんな、すでに事前共有鍵についてまともに動く
設定を持っているので (前の節を参照) このファイルでも
目新しいところはあまりない。だからこれは、全部事細かに説明したりはしない。
ぼくが説明しない部分については isakmpd.conf(5) を
見てほしい。
<p>
全体の構成はこんな感じだとしようか。
<p>

<center>
<pre>
one.mysite.se                                        one.worksite.se
 192.168.1.2--+    10.0.0.1====/======10.0.0.2     +--192.168.2.2 
              |  gw.mysite.se       gw.worksite.se |
              +--192.168.1.1         192.168.2.1---+
two.mysite.se |                                    | two.worksite.se
 192.168.1.3--+                                    +--192.168.2.3
</pre>
</center>

<p>
要するに、二つのネットワークが、保護されていないネットワーク上を、IPsecトンネル経由で
接続される、ということ。ここでプライベートインターネット用に予約されたIP
アドレス (RFC1918) を使っていることは無視してほしい。
なにかしら例は必要だったもんで。isakmpd を NAT
と組み合わせて使うとかその手のをどうするかは説明しない(ぼく自身やったことがないから)。
<p>
では設定ファイルを見てやろう。以下は、
セキュリティゲートウェイ gw.mysite.se用のファイルだ:
<UL>
<pre>

# *****************************************************************
# *************  gw.mysite.se isakmpd.conf  のはじまり       ************
# *****************************************************************

# A configuration sample for the isakmpd ISAKMP/Oakley (aka IKE) daemon.
[General]
Policy-File=            /etc/isakmpd/policy
Retransmits=            5
Exchange-max-time=      120
Listen-on=              10.0.0.1


# The name work-gw here is used just as a section name and a tag for
# use in this configuration file below and need not actually be the 
# real hostname or domain name of the peer (but it could be). The IP 
# address however needs to be correct. Phase 1, as you might already
# know, is to negotiate an ISAKMP security association (SA). There 
# should of course be one IP and name for each peer we want to
# communicate with.
[Phase 1]
10.0.0.2=               work-gw


# Now phase 2 is negotiating IPsec SAs. As in phase 1, the name here
# is a section name to be used later. Actually, it can be a comma
# separated list of section names here. Thus if traffic from many
# networks (or individual hosts) should be forwarded through this
# tunnel, more sectionnames would be added (and of course corresponding 
# new sections further down). 
[Phase 2]
Connections=            work-gw-my-gw


# Now, here are some parameters for the ISAKMP SA negotiations. Almost 
# self documenting. The section name is from [Phase 1] above. The most 
# interesting tag might be the ID tag. The ID tag is set to the name
# of the section where the identity information about this host that 
# will be presented to connecting peers, can be found. If the ID tag 
# is not available, isakmpd will assume that it will identify itself 
# using the IP address. You might also notice that there is no longer 
# any authentication tag here in this configuration. The authentication
# data is currently used only in the preshared key case. 
[work-gw]
Phase=                  1
Transport=              udp
Local-address=          10.0.0.1                # Local address
Address=                10.0.0.2                # Peer address
ID=                     my-ID
Configuration=          Default-main-mode


# This is the identity data. ID-type may also be IPV4_ADDR (the
# default), IPV4_ADDR_SUBNET or UFQDN. The Name tag is used for 
# FQDN and UFQDN, for IPV4_ADDR an Address tag would be used instead.
# For IPV4_ADDR_SUBNET a Network and a Netmask tag would be used.  
[my-ID]
ID-type=                FQDN
Name=                   gw.mysite.se


# This is the section for the IPsec connection. The section name is
# from the list in the [Phase 2] section above. The ISAKMP-peer is,
# of course, the tag of our peer from section [Phase 1] above. The 
# Local-ID and Remote-ID tags should be section names describing which
# packages should be forwarded over the IPsec tunnel to the remote 
# network.
[work-gw-my-gw]
Phase=                  2
ISAKMP-peer=            work-gw
Configuration=          Default-quick-mode
Local-ID=               Net-west
Remote-ID=              Net-east

# ここで記述されたネットワーク上のコンピュータから発せられた
# パケットで... 
[Net-west]
ID-type=                IPV4_ADDR_SUBNET
Network=                192.168.1.0
Netmask=                255.255.255.0

# ... 以下の記述とマッチする目的地を
# 持ったものは、暗号化されて
# IPsecトンネル経由でリモートシステムに転送される。
[Net-east]
ID-type=                IPV4_ADDR_SUBNET
Network=                192.168.2.0
Netmask=                255.255.255.0

# Main mode の記述


# Here are the data for main mode. Using DES here for real purposes
# is not very smart since DES is no longer considered a secure
# encryption algorithm. 3DES is generally considered to have much better
# security since it has enough bits in the key to be considered secure. 
# Transforms is a list of tags describing main mode transforms. In 
# this example we have only one.
[Default-main-mode]
DOI=                    IPSEC
EXCHANGE_TYPE=          ID_PROT
Transforms=             3DES-MD5


# Certificates stored in PEM format
# This is important when using certificates. The CA certificates should 
# be in the CA-directory (but not the CA private key ofcourse).
# The Cert-directory should have at least the certificate for the
# local host but other certificates are also allowed. The private key 
# should be the private key of the local host. 
[X509-certificates]
CA-directory=           /etc/isakmpd/ca/
Cert-directory=         /etc/isakmpd/certs/
Private-key=            /etc/isakmpd/private/local.key

# Main mode transforms
######################

# Here is our main mode transform. The important thing here is to use
# RSA_SIG as authentication method when using certificates. It is the
# only method supported when using certificates so far. Commercial
# entities in the US will thus have to wait until September 2000 to
# use this due to the RSA patent. Luckily, I am not living in the US. 
# Also important is the GROUP_DESCRIPTION tag. It must match the
# GROUP_DESCRIPTION tag in the Quick mode transforms further down. 
# The Life tag here could possibly be modified. The LIFE_60_SECS might 
# be shorter than necessary for normal use. 

[3DES-MD5]
ENCRYPTION_ALGORITHM=   3DES_CBC
HASH_ALGORITHM=         MD5
AUTHENTICATION_METHOD=  RSA_SIG
GROUP_DESCRIPTION=      MODP_1024
Life=                   LIFE_60_SECS,LIFE_1000_KB

# Quick mode description
########################

[Default-quick-mode]
DOI=                    IPSEC
EXCHANGE_TYPE=          QUICK_MODE
Suites=                 QM-ESP-3DES-MD5-PFS-SUITE

# Quick mode protection suites
##############################
# 3DES

[QM-ESP-3DES-MD5-PFS-SUITE]
Protocols=              QM-ESP-3DES-MD5-PFS

# 3DES

[QM-ESP-3DES-MD5-PFS]
PROTOCOL_ID=            IPSEC_ESP
Transforms=             QM-ESP-3DES-MD5-PFS-XF

# Quick mode transforms

# Don't forget. The GROUP_DESCRIPTION must match the GROUP_DESCRIPTION 
# in main mode above. For forwarding packets between two networks (or
# from a host to a network) we use TUNNEL mode. Between two hosts we
# may also use TRANSPORT mode instead. 
[QM-ESP-3DES-MD5-PFS-XF]
TRANSFORM_ID=           3DES
ENCAPSULATION_MODE=     TUNNEL
AUTHENTICATION_ALGORITHM=       HMAC_MD5
GROUP_DESCRIPTION=      MODP_1024
Life=                   LIFE_60_SECS


# As we know from the isakmpd.config manpage the LIFE_DURATION here is 
# an offer value (60), a minimum acceptable value (45) and a maximum
# acceptable value. The isakmpd.conf example has this set to 
# 600,450/720 instead. That might be a better value for normal use.
[LIFE_60_SECS]
LIFE_TYPE=              SECONDS
LIFE_DURATION=          60,45:72

[LIFE_1000_KB]
LIFE_TYPE=              KILOBYTES
LIFE_DURATION=          1000,768:1536

# *****************************************************************
# ************* End of the gw.mysite.se isakmpd.conf **************
# *****************************************************************
</pre>
</UL>
<p>
ここまではローカルシステム用の設定。リモートシステムの
設定もまったく同じだけれど、裏返しになる。だからちがうのは
isakmpd.conf ファイルの頭のところだけだ。
セキュリティゲートウェイgw.worksite.seの isakmpd.conf ファイルの頭のところだけ見てやろう:
<p>
<UL>
<pre>
# *****************************************************************
# *************      gw.worksite.se isakmpd.conf のはじまり    **********
# *****************************************************************

[General]
Policy-File=            /etc/isakmpd/policy
Retransmits=            5
Exchange-max-time=      120
Listen-on=              10.0.0.2

[Phase 1]
10.0.0.1=               my-gw

[Phase 2]
Connections=            work-gw-my-gw

[my-gw]
Phase=                  1
Transport=              udp
Local-address=          10.0.0.2                # Local address
Address=                10.0.0.1                # Peer address
ID=                     work-ID
Configuration=          Default-main-mode

[work-ID]
ID-type=                FQDN
Name=                   gw.worksite.se

[work-gw-my-gw]
Phase=                  2
ISAKMP-peer=            my-gw
Configuration=          Default-quick-mode
Local-ID=               Net-east
Remote-ID=              Net-west

# *****************************************************************
# **********************     ... つづく...      **********************
# *****************************************************************
</pre>
</UL>
<p>
あまりむずかしくはなかったね。ただ読むのはちょっと退屈だったかもしれないけれど。次の部分は、
もうちょっとおもしろくなる。
<p>


<h2>policy ファイル</h2>

実をいえば、policy ファイルは初めての人にはちょっとややこしいかもしれない。
特に思い通りに動かないときには。man-ページ
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&sektion=5">isakmpd.policy(5)</a>
は、実はそんなに悪くない。ところどころ
はっきりしないところがあるけれど、全体としてはいい。
<p>
一番簡単な、ちゃんと機能する policy ファイルは
たった一行だ:
<p>
<UL>
<pre>
authorizer: &quot;POLICY&quot;
</pre>
</UL>
<p>
これは要するに、だれが接続していいかについて、ポリシー上の制約はなにもない、
ということだ。だからあまりセキュリティの高い設定ではない。ここの
authorizer タグは、policy を決める権限を持った人物、
ということだ。特別 authorizer である&quot;POLICY&quot; は、
policy について最終的かつ無限の権限を持つ。それ以外の authorizer は、
ここで権限を持つためにはまず &quot;POLICY&quot; に認定してもらわなければならない。
<p>
さらに何が許されるかについて、条件群があるかもしれない。
以下の policy はだから、本物の暗号を何か使って ESP
プロトコルを使用した人だけが認定されるということだ (本物といってもまあ、
これだと DES を使っている人も認められて、DES は
いまやほとんどインチキと思ってもいいくらいだけれど、でも DES を認めないように
この policy を変更するのは、読者の練習問題として残しておこうか)。
これだとESP で暗号化する人ならだれでも認められることに注意。
<p>
<UL>
<pre>
authorizer: &quot;POLICY&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;

</pre>
</UL>
<p>
さらに権限をだれか他の存在 (複数でも
いい) に「サブライセンス」することもできる。簡単なケースとしては、事前共有鍵の
場合だ。この場合、事前に共有されたパスワードを知っている人はすべて
認められる。だから：
<p>
<UL>
<pre>
authorizer: &quot;POLICY&quot;
licensees:  &quot;passphrase:something really secret&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre>
</UL>
<p>
これはこのパスワードを知って条件にマッチした人すべてに
接続を認める (ただしこのパスワードは isalmpd.conf の Authentication タグでも
設定しておくのをお忘れなく)。
<p>
ここまでは何もむずかしくない。こっからがおもしろいところ。まず、
ライセンスを受ける存在はたくさんあってもいいけれど、そのすべてが &quot;POLICY&quot;に認定されなくてはならない。
さらに認定されたライセンス保持者は、他のライセンス保持者にサブライセンスを出せる。
ライセンス保持者は、policyファイルでさらに記述されていたら
単なるストリングでもいい:
<p>
<UL>
<pre>
authorizer: &quot;POLICY&quot;
licensees:  &quot;subpolicyAH&quot; ||  &quot;subpolicyESP&quot;
conditions: app_domain == &quot;IPsec policy&quot; -&gt; &quot;true&quot;;

authorizer: &quot;subpolicyESP&quot; 
licensees:  &quot;passphrase:something more secret&quot;
conditions: esp_present == &quot;yes&quot; -&gt; &quot;true&quot;;

authorizer: &quot;subpolicyAH&quot; 
licensees:  &quot;passphrase:something really secret&quot;
conditions: ah_present == &quot;yes&quot; -&gt; &quot;true&quot;;
</pre>
</UL>
<p>
さあみなさんお待ちかねの部分。Policy はまた、
鍵にサブライセンスしたり権限委譲したりできる。この場合の鍵は、ふつうは
X.509 証明書だ。証明書を簡単に使うには、
それをパスワードがわりに使うことだ。
policy ファイルに個別ユーザの証明書を加えるだけでいい:
<p>
<UL>
<pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA           この部分はユーザ証明書でございますな          AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre>
</UL>
<p>
さて、ユーザの数が多ければ、このやり方がばかげているのはすぐわかる。
isakmpd が CA- ディレクトリと Certificate
ディレクトリから読んでくる証明書と、ピアから送られてくる証明書は、
疑似資格証明 (credentials) に変換される。こうした疑似資格証明に変換された証明書は、
こんな感じになっている:
<p>
<UL>
<pre>

authorizer: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgI2\
    	CzA  この部分はユーザ証明書 (つまりCA証明書) に署名した     AQEB\
        BQA             　人の公開鍵／証明書ですな                  IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
licensees:  &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA          ここんとこは証明書を受ける側の鍵に　           AQEB\
        BQA                          なります                       IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; -&gt; &quot;true&quot;;
</pre>
</UL>
<p>
さて、これらが &quot;POLICY&quot; に認められたものではないので、
それをなんらかの形で認知する policy がなければダメだということに注意。さらに、これは
内部で証明書がどうなっているかを説明している。上の資格証明 (credential) は、
policy ファイルの中では見られない。でも、そういう資格証明に
サブライセンスは出せる。上のサブライセンス発行を思いだしてほしい。あれを使えば、
CA証明書をライセンスとして &quot;POLICY&quot;に書いてやれば、
ある CA が署名した証明書すべてにライセンスが出せる。
<p>
<UL>
<pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA             この部分が CA 証明書でございますな          AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre>
</UL>
<p>
つまり上の policy は、CA に権限委譲する policy の簡単な例だ。
この証明書を持った CA が署名した証明書を持っていて
policy と設定ファイルの設定したほかの条件にも
したがっているユーザはすべて認められる。
<p>

<h2>ほとんど安全……は安全に非ず!</h2>

さて、本当に安全を期するなら、これでは残念ながら十分ではないのだ。
こういう設定のセキュリティゲートウェイを攻撃する方法がある。
もし細々した話がいらないなら、いますぐ次の節まで飛ばそう。
それ以外の人たちは、なぜこれが安全でないかを理解してみようではないの。
むずかしくはないよ。
<p>
この段階で、isakmpds がどんな情報にアクセスできるか考えてほしい。
設定ファイルから、isakmpd はピアがどの IP-アドレスから
送信してくるかわかる ([フェーズ 1] セクションで)。フェーズ 1 の
ネゴシエーションをするときに得られる情報から、ピアがどんな ID を
出してくるかわかって、ピアからの証明書をもらったらそれでピアが本当に
そのIDを持っていることが証明される。問題なさそうだね?
<p>
うん、もしID 情報が IP なら (フェーズ 1 の ID セクションを使わなければ
これがデフォルトに状況になる) すべてはオッケーだ。CA
はその IP を cert に結びつけて、設定の中の IP
だけで必要情報はすべてそろう。なりすまし犯が、ほかのコンピュータから
同じ IP を使うことも不可能ではない
(たとえば両方のコンピュータが同じ LAN 上にあって、
ふだんその IP を使っているマシンがなんらかの理由でダウンしているなど)。
でも、なりすまし犯が、証明書とそれに対応する秘密鍵を持って、
その IP がなりすまし犯のものだと (不正に) 証明することは
不可能なはずだ。
<p>
もしそれが万が一起こったら、そのなりすまし犯はそのIPの所有者から秘密鍵を
どうにかして盗んだか、あるいは CA をなんらかの方法でだまして、
にせの情報を含んだ証明書を発行させたかのどちらかだ。
もしこのいずれかが起こったなら、
秘密鍵の保護が不十分だったか、CA が
なりすまし犯の身元 (あるいは cert の
ID 情報) を十分にチェックできなかったか、あるいは CA 秘密鍵が十分に保護されていなかったかだ。
これらはすべて、そもそもセキュリティがまともに機能する前提なので、
こういう状況は絶対に起こってはいけない。

<p>
さてぼくたちの例では状況がちがう。ここでは
証明書の中に、IPアドレスではなく FQDN が入っている。
[Phase 1] セクションにまだ IP アドレスがあるので、
これはセキュリティ問題となる可能性がある。ISAKMP
フェーズ 1 ネゴシエーションの間に何が起きるかというと、ピアが
期待どおりの IP から送られてきたことをチェックできる (でもさっき説明したように、
これは一部の状況ではごまかせる)。ピアが提示するIDを、
本当にそのピアが持っていることもチェックできる。
でも、いまチェックできないのは、そのID が本当にそのピアが持っていると期待すべき ID なのか、ということだ。
isakmpd は、どんな ID を期待すればいいか一度も教わっていないからだ。
<p>
DNS システムがホストのために IP を FQDN と
結びつけてくれる、という人もいるだろう。それはそうなんだけれど、現在の DNS システムはセキュリティが高くないし、
だましてにせの情報を出させることも、場合によっては
できる (あるいはサービス拒否 (DoS) 攻撃を
攻撃者に受けて、その攻撃者のマシンがDNSサーバの答を
偽造することもできる)。いずれ高セキュリティ DNS も登場するけれど、
まだ出回っていないし (少なくともほとんどの DNS サーバはまだ高セキュリティではない)、
だから現在、cert の FQDN が期待される IP と対応しているかを調べるのに
DNS を使っても保証にはならない。実は isakmpd はこれを DNS にきいたりしない。
DNS が安全でも、UFQDNを使っている場合には
これをチェックできない。
<p>
つまり ID として FQDN を使う場合、アタッカーは
自分の秘密鍵を用意して、それをわれわれの使うのと
同じ CA に署名させる (でももちろんアタッカー自身の FQDN を使って)。それから
ピアに DoS 攻撃をしかけてダウンさせる (実は
ISAKMP プロトコル自体に欠陥があって、ピアに対して
リモートDoS を仕掛けてダウンさせてしまえる可能性があるけれど、
isakmpd がこういう攻撃に対してどのくらい敏感かは知らない)。それから
アタッカーは自分のコンピュータをわれわれのピアと同じように設定して、
ピアのネットワークにつないで
自分のIDと秘密鍵と証明書を使える。
<p>
ぼくたち側の isakmpd は、こっちのピアへの ID が何かを教わっていない (そしてそれは、アタッカーが
証明書とIDと秘密鍵以外はまったく同じ設定にしておいたから)。さらにぼくたちの
isakmpd は証明書が同じ CA のサインしたものだとチェックできる (でも
多くの CA はcert をいっぱいサインするから、cert を手に入れるのはむずかしくないかも)。そして
そこで示された ID が証明書の中の ID といっしょなのも確認できる。でも、
これまで提示された設定では、その ID が期
待していた ID かどうかはチェックできない。だからアタッカーは接続を認められてしまう。
<p>

<h3>攻撃をふせぐ</h3>

すると問題は、どうやったら isakmpd に期待すべき ID のことを教えてあげられるか、
ということだ。ありがたいことにこれは簡単で、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&sektion=5">isakmpd.policy(5)</a>にも説明されている。
policy内でチェックをかけなきゃいけないのだ。
たとえばこんなふうに:
<p>
<UL>
<pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA             この部分が CA 証明書でございますな          AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            remote_id == &quot;gw.worksite.se&quot; -&gt; &quot;true&quot;;
</pre>
</UL>
<p>
これで、IPsec接続を得られるのは gw.worksite.se だけのはず。ほ
かに remote_idのチェックを足せば、許可されるIDは簡単に増える。
つまり以下のようなのを policy に足せばいい:
<p>
<UL>
<pre>
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            (remote_id == &quot;gw.worksite.se&quot;  ||
               remote_id == &quot;gw.whatsite.se&quot;) -&gt; &quot;true&quot;;
</pre>
</UL>
<p>
この policy だと、gw.worksite.se, gw.somesite.se、
gw.whatsite.se のいずれも接続できる。

<p>
policy に証明書丸ごと含めなくてはならないのは残念、
という人もいるだろう。証明書を policy に
入るような形式になおすのは手間だし、
policy も読みにくくなる。だれかがまちがって、
ややこしい policy のなかで、CA 証明書とまちがえて
ユーザ証明書を入れてしまったら、権限のないユーザも
接続が認められてしまうかもしれず、さらに困ったことに、
policy ファイルを見てもそれをつきとめるのはむずかしい (X.509 証明書は
人間に読める形ではないから)。

<p>
さて、本当にカリカリの最先端の人たちには、
この問題の解決方法がある。いまでは、policy 内で証明書そのもののかわりに、
証明書のDistinguished Name (DN) を使うことができる (対応する
証明書はもちろんディスク上の certs
か ca ディレクトリにあって、isakmpd が見つけられるようになっていること)。この
形式だと、上の policy は以下のような感じになるだろう:

<p>
<UL>
<pre>  
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;DN:\C=se\CN=IKELAB CA&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            (remote_id == &quot;gw.worksite.se&quot;  ||
             remote_id == &quot;gw.somesite.se&quot;  ||
             remote_id == &quot;gw.whatsite.se&quot;) -&gt; &quot;true&quot;;
</pre>
</UL>
<p>
ずっと読みやすい、でしょ？　ある証明書の正確な DN
は、openssl ユーティリティを使って証明書を見てやるとわかる。
こんな具合:
<p>
<UL><tt>
$ <b>openssl x509 -text &lt; ca.crt</b>
</tt></UL>
<p>
もっと複雑な policy はもちろんできるけれど、
これはとりあえず入門だし、次の節で別の例を見て
やることになる。
<p>
これで ca.crt の中の証明書について必要な情報が
提供されるはずだ。policy が小さいか、そこそこくらいなら
これでもいいだろう。でも巨大なサイトで接続ユーザが山ほどいるなら、
これでもまだまだだ。

<H2>マルチユーザ設定と、中央管理型認証</h2>

それじゃ isakmpd のホントにクールな機能をいくつか見てやろう。これまでは、
接続してくるはずのピアはよく知られていて、IPアドレスも静的に固定されているものとした。
でも、そういう場合ばかりじゃない。動的に割り当てられたIPを使ったり、
コンピュータを何台も使ったりする人は多い。あるいは (サーバ
なんかだと) 接続したいのがだれなのか、はっきりわからないこともある。

<p>
そこでisakmpdのすてきな機能の一つは、
[Phase 1]セクションでIPではなくデフォルトのタグを使えるというもの。
これによって、isakmpdはどのIPからでもネゴシエーションを受け付けられるようになる。
これはこんな感じになる：
<p>
<UL>
<pre>
[phase 1]
Default=        work-gw
</pre>
</UL>
<p>
まず言っておくべきなのは、この設定はDoS攻撃に対して
安全ではないかもしれないということ。まえにも言ったように、
ISAKMP/IKEプロトコルには欠陥がある。いずれにしても、デフォルトの [phase 1] セクションを使えば、
一種の「認証証明書」が変わりに使えるようになる。
<p>
たとえば権限を持つユーザはたくさんいるけれど、
でも誰でもいいからうけつける、というわけではない場合を考えてみよう。たとえば会社なんかの場合。
会社の従業員は接続させたいけれど、それ以外の人には接続してほしくない。さて、
大企業で社員が何千人もいるとしよう。かれらが
どのコンピュータからでも (社内LAN上のものに限らず) 接続できるようにしたいけれど、
全員がなんでもできるようにはしたくない。この場合、
次のようなpolicy が書けるはずだ：
<P>
<UL>
<pre>
keynote-version: 2
authorizer: &quot;POLICY&quot;
licensees: &quot;telnet@work&quot; || &quot;telnet@lab&quot; || &quot;pop3@work&quot; 
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            remote_id_type == &quot;UFQDN&quot; &amp;&amp;
            (remote_id == &quot;telnet@worksite.se&quot;  ||
             remote_id == &quot;pop3@worksite.se&quot;  ||
             remote_id == &quot;telnet@lab.worksite.se&quot;) -&gt; &quot;true&quot;;

authorizer: &quot;telnet@work&quot;
licensees: &quot;DN:\C=se\CN=IKELAB CA&quot;
conditions: remote_id == &quot;telnet@worksite.se&quot; &amp;&amp;
            local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;23&quot; &amp;&amp;
            local_filter == &quot;192.168.002.003&quot;

authorizer: &quot;telnet@lab&quot;
licensees: &quot;DN:\C=se\CN=IKELAB CA&quot;
conditions: remote_id == &quot;telnet@lab.worksite.se&quot; &amp;&amp;
            local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;23&quot; &amp;&amp;
            local_filter == &quot;192.168.002.002&quot; -&gt; &quot;true&quot;;

authorizer: &quot;pop3@work&quot;
licensees: &quot;DN:\C=se\CN=IKELAB CA&quot;
conditions: local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;110&quot; &amp;&amp;
            local_filter == &quot;192.168.002.003&quot; &amp;&amp;
            remote_id == &quot;telnet@worksite.se&quot; -&gt; &quot;true&quot;;

</pre> 
</UL>
<p> 

これは厳密に正しいかどうかはわからん。ぼくが知る限り、
こいつはまったくテストしていない (だからこのフィルタ条件は、ぼくの思い通りには
ぜんぜん動かないかもしれない)。それと、こいつみたいなpolicy  (というか、
デフォルトがピアのIPにしてあるものすべて) は、isakmpd.confファイルもあわせて書き換えないと
ダメだ。これには、セキュリティ上の問題もついてまわる。さらに、
だれでも接続できるようになっているこの種の接続では、
たぶん接続した人の DN はすべてログしておいたほうが
望ましい。isakmpd はぼくの知る限りでは、これをまだサポートしていない。さらに
この可能性にはべつのセキュリティ上の問題がついてくるかもしれない。なにかあっても、
だれも責任はとってくれないので、覚悟して進むように。でも基本的な考え方はもうはっきりしているはずだ。

<p> 

いまのが持っている、実におもしろい可能性に思い当たらない人がいるとアレだから、念のため説明しておこう、
もしこういう形でISAKMP/IKE を使っているコンピュータがすべて、
リモートからユーザが使いたいと思っているサービスのそれぞれについて、条件の束を持っていたとしよう。すると CA は、
ユーザの証明書にしかるべき SubjectAltName
extension を入れておくだけでそのユーザの認証ができる。さらに、そういう証明書の有効期限を
比較的短いものにしておいて、ユーザは
証明書が古くなってきたら証明書を再発行してダウンロードできるように
しておく。もしユーザが権限を悪用するなら、
証明書を再発行しないようにすれば、有効期限後は入ってこられない。
社員が一人やめたくらいで、
すべてのコンピュータ上のpolicyファイルを変える必要もない。
同じ方式はISAKMP/IPsec 以外の目的にも使えるはずだ (オフラインシステムの認証さえできる！)。
ただしその場合には特別なソフトが必要になるけれど。
とにかく。これをやる組織はおそらく自分で自分自身のCAになったほうがいい。

<p>

こういうマルチユーザ設定 (モバイルユーザ) は、
事前共有鍵でもできうけれど、でもそれだと、どのIPから接続してくるかわからないから、
IDをもとに正しいパスワードが選べるようになっている必要がある。
だからID_PROTモードではなくAGGRESSIVE モードを
使わなくてはならない(AGGRESSIVE モードでは、IDはネゴシエーションの
初期の段階で送られるけれど、暗号化されないで送られる。だから
AGGRESSIVE モードのほうがメッセージ交換が少なくてすむので、高速だけれど、
IDがナマのままで送られるからちょっとセキュリティは下がる)。

<p>
<a name= "IKEcl"></a>
<a name= "13.10">
<h1>13.10 - isakmpdで使えるIKE クライアントは?</h1>
</a>
<P>
<tt>isakmpd</tt> は、OpenBSD についてくる ISAKMP/Oakley 鍵管理デーモンだ。
たぶん、ほとんどの ISAKMP 実装とは、部分的にせよ相互運用可能だと思うけれど、
実際にテストされたのは以下のものだ。出回っている
isakmp ソフトの一部は、実は OpenBSD isakmp デーモンをベースにしたものだったりする。
<P>
以下の MS-Windows クライアントは、互換性があるとの報告がある:
<UL>
<!-- <LI><a href="http://www.timestep.com/">TimeStep</a> PERMIT/Client -->
<LI><a href="http://www.vpcom.com/">Ashley Laurent</a> VPCom VPN ソフトウェア
<LI><a href="http://www.radguard.com/">Radguard</a> cIPro クライアント
<LI><a href="http://www.cisco.com/">Cisco</a> IRE クライアント
<LI><a href="http://www.microsoft.com">Microsoft</a> Windows 2000、XP
</UL>
<P>
以下のゲートウェイ/ルータも互換性があるとの報告:
<UL>
<LI><a href="http://www.cisco.com/">Cisco</a> IOS
<LI><a href="http://www.cisco.com/">Cisco</a> PIX
<LI><a href="http://www.intel.com/">Intel</a> LanRover
<!-- <LI><a href="http://www.timestep.com/">TimeStep</a> PERMIT/Gate -->
<LI><a href="http://www.cendio.com/">Cendio</a> Fuego
<LI><a href="http://www.kame.net/">KAME</a> for FreeBSD
<LI><a href="http://www.xs4all.nl/~freeswan/">FreeS/WAN</a> for Linux
<LI><a href="http://www.symantec.com/">Symantec</a> Raptor
<LI><a href="http://www.ericsson.com/">Ericsson</a> eBox
<LI><a href="http://www.f-secure.com/">F-Secure</a> VPN+
<LI><a href="http://www.teamware.com/">Teamware</a> TWISS
<LI><a href="http://www.3com.com/">3com</a> Pathbuilder
<LI><a href="http://www.nortelnetworks.com/">Nortel</a> Contivity
<LI><a href="http://www.checkpoint.com/">CheckPoint</a> FW-1
<li><a href="http://www.watchguard.com/">Watchguard</a> Firebox III
</UL>

<p>
<a name= "Trouble"></a>
<a name= "13.11"></a>
<h1>13.11 - Troubleshooting IPsec/VPN</h1>
</p>
<p>
IPsec トラブルシューティングの最初のツールは <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&apropos=0&sektion=8&format=html">tcpdump(8)</a>だ。
<tt>tcpdump</tt> を使っていくつか探すべきものを挙げると：
<P>
まずOpenBSDの tcpdump を使っている人は、
拡張版の tcpdump を使っているので、
ESP と AH パケットについても情報がとれる。もし OpenBSD
2.5 や他の OS の tcpdump を使っているなら、たぶん古い
バージョンだから AH や ESPについてはプロトコル番号しか表示されない
(ESP は IP プロトコル 50, AH は 51)。
<UL>
<P>
<LI>
tcpdump では、トラフィックが AH/ESP を使っているか平文のままかを確かめよう。
平文のままなら、フローがちゃんと設定されていないか、
isakmp のネゴシエーションがうまくいっていない。<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&apropos=0&sektion=8&format=html">ping(8)</a>を使って
簡単なトラフィックを発生させてみよう。
<P>
<UL>
たとえば、208.1.1.1 と 208.2.2.2 の２つのホストがある。
208.2.2.2 にログオンして、以下をやってみよう:
<PRE>
# <b>ping -c 3 208.1.1.1</b>
PING esp.mil (208.1.1.1): 56 data bytes
64 bytes from 208.1.1.1: icmp_seq=0 ttl=255 time=190.155 ms
64 bytes from 208.1.1.1: icmp_seq=1 ttl=255 time=201.040 ms
64 bytes from 208.1.1.1: icmp_seq=2 ttl=255 time=165.481 ms
--- esp.mil ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 165.481/185.558/201.040 ms
</PRE>
別のセッションでは、encapsulated されたpingが見られる:
<PRE>
# <b>tcpdump -ni fxp7 host 208.1.1.1</b>
tcpdump: listening on fxp7
14:12:19.630274 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4535 len 116
14:12:19.813519 esp 208.1.1.1 &gt; 208.2.2.2 spi 0x00001001 seq 49313 len 116
14:12:20.630277 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4536 len 116
14:12:20.832458 esp 208.1.1.1 &gt; 208.2.2.2 spi 0x00001001 seq 49314 len 116
14:12:21.630273 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4537 len 116
<b>^C</b>
1831 packets received by filter
0 packets dropped by kernel
</PRE>
</ul>
<P>
<LI>ISAKMP はUDP port 500で実行される。もしこれがファイアーウォールか
パケットフィルタでロックアウトされていたら、これを変えること！
<UL><PRE>
# Passing in ISAKMP traffic from the security gateways
pass in on ne0 proto udp from gatewB/32 port = 500 to gatewA/32 port = 500
pass out on ne0 proto udp from gatewA/32 port = 500 to gatewB/32 port = 500

# Passing in encrypted traffic from security gateways
pass in proto esp from gatewB/32 to gatewA/32
pass out proto esp from gatewA/32 to gatewB/32
</PRE></UL>
<P>
<LI>Photuris は UDP port 468 で動く。考えるのは同じことだけれど、プロトコルは ahだ。
<UL><PRE>
# Passing in Photuris traffic from the security gateways
pass in on ne0 proto udp from gatewB/32 port = 468 to gatewA/32 port = 468
pass out on ne0 proto udp from gatewA/32 port = 468 to gatewB/32 port = 468

# Passing in encrypted traffic from security gateways
pass in proto ah from gatewB/32 to gatewA/32
pass out proto ah from gatewA/32 to gatewB/32
</PRE></UL>
<P>
<LI>
isakmpd にデバッグを全部つけるなら、次のようにして実行しよう：
<P>
<UL><TT>
# <b>/sbin/isakmpd -d -DA=99</b>
</TT></UL><P>
あるいは (いちばん詳しいタイマーデバッグ情報をとばすには)
<P>
<UL><TT>
# <b>/sbin/isakmpd -d -DA=99 -D1=70</b>
</TT></UL>
<P>
<LI>IPsecで処理されたトラフィックを、netBから自分のローカルのファイアーウォール保護つきnetAに
入れるようにしてやる必要がある。
<UL><PRE>
# Passing in traffic from the designated subnets.
pass in on enc0 from netB/netBmask to netA/netAmask
</PRE></UL>
<P>
<LI>OpenBSD の tcpdump だと、ほとんどのインターネット
鍵交換 (自動鍵交換) セッションの平文部分はほとんどデコードできる。Tcpdump はまた AH ペイロードデータも表示する。
<P>
<LI>/kern ファイルシステムをマウントしよう (もしすでにデフォルトで使っていないなら)：
<P>
<UL><TT>
# <b>mkdir /kern; mount -t kernfs /kern /kern</b>
</TT></UL>
<P>
/kern には、現在の SA/SPI 一覧表があって、フローがあるもの
(外行きの SA) もないもの (入ってくる SA) も記述されている。
またどんなトラフィックがどこへ行っているのかしらべられる、トラフィックカウンタも
ある。
<P>
<LI>最後に、 <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&apropos=0&sektion=1&format=html">netstat(1)</a> を使って SAを見ることができる。
<UL><PRE>
$ <b>netstat -rn -f encap</b>
Routing tables

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto) 
0.0.0.0/32         0     192.168.99/24      0     0     208.1.1.1/00001000/50
0.0.0.0/32         0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.1.2.0/24       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.1.2.0/24       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.1.5.0/24       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.1.5.0/24       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.2.2.2/32       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.2.2.2/32       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
</PRE></UL>
<P>
<LI>
これだけやってもダメなら、<tt>option ENCDEBUG</tt>つきでカーネルをコンパイルしなおすこと。
それから <tt>net.inet.ip.encdebug</tt> を 1 にする。そして dmesg を見て
警告やエラーをさがし、それを <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sendbug&apropos=0&sektion=1&format=html">sendbug(1)</a>を使って
OpenBSD デベロッパーに報告しよう。 あるいはもしそれが
バグかどうかわからなかったら、<A HREF="../../ja/mail.html">メーリングリスト</a>のどれかにメッセージを投げてみよう。
</UL>

<p>
<a name= "SeeAlso"></a>
<a name= "13.12"></a>
<h1>13.12 - 関連ドキュメンテーション</h1>
</p>
<p>
IPsec が特に詳しく説明してあるのは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vpn&apropos=0&sektion=0&format=html">vpn(8)</a>
ページだ。各種の設定テンプレートが <A HREF="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/">/usr/share/ipsec/</a>
ディレクトリにあるので役にたつだろう。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4">enc(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&sektion=4">ipsec(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&sektion=8">ipsecadm(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=photurisd&sektion=8">photurisd(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=startkey&sektion=1">startkey(1)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd&sektion=8">isakmpd(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&sektion=5">isakmpd.conf(5)</a> and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&sektion=5">isakmpd.policy(5)</a>
のmanページも詳しくて、IPsecの設定と運用に役立つはずだ。
<P>
その他リンクとして……
<UL>
<LI><a href="http://www.ietf.org/html.charters/ipsec-charter.html">IETF IPsec Working Group</a>
<LI><a href="http://isakmp-test.ssh.fi/">SSH IPsec interoperability Test Node</a>
<LI><a href="http://ipsec-wit.antd.nist.gov/">NIST IPsec Web Based Interoperability Tester</a>
<LI><a href="http://www.r4k.net/ipsec/">A port of OpenBSD's IPsec to FreeBSD</a>
<LI><a href="http://www.xs4all.nl/~freeswan/">FreeS/WAN - IPsec for Linux</a>
<LI><a href="http://www.pintday.org/hack/docs/vpn-24-minifaq.shtml">OpenBSD 2.4 VPN Configuration Mini-FAQ</a>
</UL>
<p> 
<A name="rfc">
そしてつづきましては RFCども...</a>
<UL>
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1320.html">RFC 1320</a> - The MD4 Message-Digest Algorithm
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1321.html">RFC 1321</a> - The MD5 Message-Digest Algorithm
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1828.html">RFC 1828</a> - IP Authentication using Keyed MD5
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1829.html">RFC 1829</a> - The ESP DES-CBC Transform
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2040.html">RFC 2040</a> - The RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algorithms
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2085.html">RFC 2085</a> - HMAC-MD5 IP Authentication with Replay Prevention
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2104.html">RFC 2104</a> - HMAC: Keyed-Hashing for Message Authentication
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2144.html">RFC 2144</a> - The CAST-128 Encryption Algorithm 
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2202.html">RFC 2202</a> - Test Cases for HMAC-MD5 and HMAC-SHA-1 
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2207.html">RFC 2207</a> - RSVP Extensions for IPsec Data Flows
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2268.html">RFC 2268</a> - A Description of the RC2 Encryption Algorithm 
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2367.html">RFC 2367</a> - PF_KEY Key Management API, Version 2
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2401.html">RFC 2401</a> - Security Architecture for the Internet Protocol (<b>IPsec</b>)
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2402.html">RFC 2402</A> - IP Authentication Header (<b>AH</b>)
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2403.html">RFC 2403</A> - The Use of HMAC-MD5-96 within ESP and AH
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2404.html">RFC 2404</A> - The Use of HMAC-SHA-1-96 within ESP and AH
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2405.html">RFC 2405</A> - The ESP DES-CBC Cipher Algorithm With Explicit IV
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2406.html">RFC 2406</A> - IP Encapsulating Security Payload (<b>ESP</b>)
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC 2407</A> - The Internet IP Security Domain of Interpretation for ISAKMP
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC 2408</A> - Internet Security Association and Key Management Protocol (<b>ISAKMP</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC 2409</A> - The Internet Key Exchange (<b>IKE</b>)
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2410.html">RFC 2410</A> - The NULL Encryption Algorithm and Its Use With IPsec (ha ha...)
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2411.html">RFC 2411</A> - IP Security Document Roadmap
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2412.html">RFC 2412</A> - The OAKLEY Key Determination Protocol
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2451.html">RFC 2451</a> - The ESP CBC-Mode Cipher Algorithms
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2522.html">RFC 2522</a> - Photuris: Session-Key Management Protocol
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2523.html">RFC 2523</a> - Photuris: Extended Schemes and Attributes
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2631.html">RFC 2631</a> - Diffie-Hellman Key Agreement Method
<LI><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2709.html">RFC 2709</a> - Security Model with Tunnel-mode IPsec for NAT Domains
</ul>

<font color= "#0000e0">
<a href= "index.html">[FAQ トップへ]</a>
<a href= "faq12.html">[12.0 - 高度なユーザ向け]</a>
<a href= "faq14.html">[14.0 - OpenBSD のハードディスク]</a>
</font>
<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq13.html,v 1.56 ]
<br>
$Translation: faq13.html,v 1.10 2002/07/02 08:12:49 toshi Exp $
<br>
$OpenBSD: faq13.html,v 1.9 2002/07/02 09:13:42 jufi Exp $
</small>
</p>
</body>
</html>
