<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>10 - System Management</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2003 by OpenBSD.">                                           <meta name= "copyright"     content= "Japanese translation copyright 2000 by Yamagata Hiroo">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>

<font color= "#0000e0">
<a href="index.html">[FAQ の目次]</a>
<a href="faq9.html">[9 章 - Linux からのお引っ越し]</a>
<a href="faq11.html">[11 章 - パフォーマンスのチューニング]</a>
</font>

<h1><font color="#e00000">10 - システム管理</font></h1>
<hr>

<h3>Table of Contents</h3>
<ul>
<li><a href="#wheel"         >10.1 - su で root になろうとすると、グループが違うと言われます</a>
<li><a href="#DupFS"         >10.2 - ファイルシステムを丸ごと複製するには ?</a>
<li><a href="#rc"            >10.3 - システム内のデーモンはどのように起動するのでしょう ? (rc(8) の概要)</a>
<li><a href="#RelayingDenied">10.4 - ユーザが OpenBSD システム経由でリモートからメールを送ろうとすると、リレーアクセスが拒否されるのはどうしてでしょう ?</a>
<li><a href="#POP"           >10.5 - POP を設定したのに、誰も POP サーバにアクセスできなくて困っています。どうすれば良いのでしょう ?</a>
<li><a href="#SendmailDNS"   >10.6 - どうして sendmail は /etc/hosts を無視するのでしょう ?</a>
<li><a href="#HTTPS"         >10.7 - SSL(8) を使用したセキュアな HTTP サーバの設定</a>
<li><a href="#vipw"          >10.8 - /etc/passwd を vi(1) で編集したのに変更が反映されません。なぜでしょう ?</a>
<li><a href="#AddDelUser"    >10.9 - ユーザを追加するには ? &nbsp; また、削除するには ?</a>
<li><a href="#FTPOnly"       >10.10 - ftp 専用アカウントを作成するにはどうすればよいのでしょう ?</a>
<li><a href="#Quotas"        >10.11 - ユーザのディスク quota を設定</a>
<li><a href="#Kerberos"      >10.12 - KerberosV のクライアントとサーバの設定</a>
<li><a href="#AnonFTP"       >10.13 - Anonymous FTP サーバの設定</a>
<li><a href="#ftpchroot"     >10.14 - ftpd(8) でユーザをホームディレクトリから出られないようにするには ?</a>
<li><a href="#Patches"       >10.15 - OpenBSD にパッチを適用する</a>
<li><a href="#httpdchroot"   >10.16 - Apache の chroot() って何でしょう ?</a>
<li><a href="#rootshell"     >10.17 - 標準の root のシェルが好きではありません !</a>
<li><a href="#ksh"           >10.18 - ksh で他に何ができますか ?</a>
</ul>

<hr>

<p>
<a name= "wheel"></a>
<h2>10.1 - su で root になろうとすると、グループが違うと言われます</h2>

<p>
既存のユーザが su するには、そのユーザを手作業で <kbd>&quot;wheel&quot;</kbd> グループに追加する必要があります。
これはセキュリティ上の理由によるものですので、誰にそのアクセス権を付与するかについては十分に注意してください。
OpenBSD では、<kbd>wheel</kbd> グループの人は <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su(1)</a>
ユーザランドプログラムを使用して root になることができます。<kbd>&quot;wheel&quot;</kbd> にないユーザは su(1)
を使用することはできません。<strong>ericj</strong> というユーザを <kbd>&quot;wheel&quot;</kbd> に追加するときに
<kbd>/etc/group</kbd> に追加する場合のエントリを以下に示します。

<p>
もし、新しいユーザの追加を <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>
で実行しているのでしたら、途中で "<tt>Invite <i>user</i> into other groups:</tt>"
という設定項目が出てきますので、ここに wheel と入力すれば wheel に追加されます。
これを実行すると /etc/group にその人が追加され、以下の例のようになります。

<blockquote><pre>
wheel:*:0:root,ericj
</pre></blockquote>

<p>
ユーザを <kbd>&quot;wheel&quot;</kbd> に加えずに、スーパーユーザの特権の一部をユーザに使用させたい場合には、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a> を使用します。

<p>
<a name= "DupFS"></a>
<h2>10.2 - ファイルシステムを丸ごと複製するには ?</h2>

<p>
ファイルシステムの複製には <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a> と
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a> を使用します。たとえば、
<kbd>SRC</kbd> ディレクトリ以下のものすべてを <kbd>DST</kbd> に複製するには、次のようにします。

<blockquote><pre>
# <strong>cd /SRC; dump 0f - . | (cd /DST; restore -rf - )</strong>
</pre></blockquote>

<p>
dump は強力なバックアップ能力を備えるように設計されているので、単にファイルシステムの一部
(あるいは丸ごと) を複製する程度のことにいちいち使用するようなものではないかも知れません。それなら
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>
コマンドのほうが高速です。形式はとても似ています。

<blockquote>
<pre>
# <strong>cd /SRC; tar cf -  . | (cd /DST; tar xpf - )</strong>
</pre>
</blockquote>

<p>
<a name= "rc"></a>
<h2>10.3 - システム内のデーモンはどのようにして起動するのでしょう ? (rc(8) の概要)</h2>

<p>
OpenBSD は <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">rc(8)</a>
スタイルの起動をします。これは起動にいくつか鍵となるファイルを持っています。

<ul>
	<li>/etc/rc - 主要スクリプト。編集したりしてはいけません。
	<li>/etc/rc.conf - <i>/etc/rc</i> が使用するファイルで、
	    システム起動時にどのデーモンを起動すべきかを記述。
	<li>/etc/rc.conf.local - /etc/rc.conf 自体には手を加えずに、/etc/rc.conf の設定にオーバーライドして
	    使用するための設定ファイル。しばしばアップグレードを行う人たちには便利なものです。
	<li>/etc/netstart - ネットワーク初期化に使うスクリプト。編集してはいけません。
	<li>/etc/rc.local - ローカル管理のためのスクリプト。
	    新しいデーモンやホスト固有の情報は、ここに保存しましょう。
	<li>/etc/rc.securelevel - セキュリティレベルが変わる前に実行しなくてはならないコマンドを実行するスクリプト。
	    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a> を参照。
	<li>/etc/rc.shutdown - シャットダウン時に実行されるスクリプト。シャットダウン前に実行させたいことをすべてここに記述します。
	    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.shutdown&amp;sektion=8">rc.shutdown(8)</a> を参照。
</ul>

<h3>rc(8) の仕組みは ?</h3>

<p>
システム管理者が専念すべき主要ファイルは、<i>/etc/rc.conf</i>
(または <i>/etc/rc.conf.local</i>)、<i>/etc/rc.local</i> と
<i>/etc/rc.shutdown</i> です。rc(8) の進行のフローは以下のようになります。

<p>
カーネルが起動すると、<i>/etc/rc</i> が実行されます。
<ul>
	<li>まず、ファイルシステムをチェックします。これは /etc/fastboot ファイルがあれば省略されますが、
	    もちろん省略することは望ましいことではありません。
	<li>設定用の変数が <i>/etc/rc.conf</i> から読み込まれます。そしてその後、<i>/etc/rc.conf.local</i> が読み込まれます。
	    rc.conf.local 中の設定は rc.conf の設定をオーバーライドします。
	<li>ファイルシステムをマウントします。
	<li><i>/tmp</i> をクリアして、エディタファイルは保存します。
	<li><i>/etc/netstart</i> によってネットワークの設定を行います。
		<ul>
		<li>ネットワークインターフェースの設定
		<li>ホスト名、ドメイン名等の設定
		</ul>
	<li>システムデーモンを起動します。
	<li>その他の各種チェックを実行します (quota、savecore 等)。
	<li>ローカルデーモンを <i>/etc/rc.local</i> 経由で実行します。
</ul>

<h3>OpenBSD 付属のデーモンやサービスを起動する</h3>

<p>
OpenBSD にデフォルトで附属しているデーモンやサービスのほとんどは、<i>/etc/rc.conf</i>
設定ファイルを編集するだけでシステムの起動時に起動されるようになります。まず、デフォルトの
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/rc.conf">/etc/rc.conf</a>
ファイルを見てみましょう。次のような行が多数あるはずです。

<blockquote><pre>
ftpd_flags=NO           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
このような行は、ftpd はシステム起動時には起動されない、という意味になります (少なくとも rc(8) 経由では。詳細は
<a href="faq10.html#AnonFTP">Anonymous FTP FAQ</a> を参照してください)。いずれにせよ、各行にはコメントもあり、
そのデーモンやサービスの<b>通常利用</b>の場合の値を示しています。しかし、これは、そのデーモンやサービスを
そのフラグで使用しなければならないことを意味するものではありません。man(1) は常に参照可能ですので、好みの形で
起動するようにできます。たとえば、httpd(8) のデフォルトは以下のようになっています。

<blockquote><pre>
httpd_flags=NO          # for normal use: "" (or "-DSSL" after reading ssl(8))
</pre></blockquote>

<p>
ここでは明らかに、httpd の起動には、通常はどのようなフラグも不要であることがわかります。ですから、普通に httpd
を使用するだけでしたら、上記の行を &quot;<b>httpd_flags=""</b>&quot; にすれば良いのです。しかし、SSL を有効にして
httpd を起動するには、この行を &quot;httpd_flags="-DSSL"&quot; のように編集してください (詳細については、
<a href="#HTTPS">SSL FAQ</a> か <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a> を参照してください)。

<p>
もっとも、<i>/etc/rc.conf</i> ファイル自身は決して編集しない方法の方が良いでしょう。
その代わりに、<i>/etc/rc.conf.local</i> ファイルを作成し、<i>/etc/rc.conf</i>
ファイルの変更しようとしている行だけをこのファイルにコピーしてから編集するのです。
この方法では、将来のアップグレードがより簡単になります。それは、すべての変更が
ひとつのファイルに入っているからです。

<h3>ローカルのデーモン起動と設定</h3>

<p>
ports など、他の方法でシステムにインストールしたその他デーモンを起動するには、
<i>/etc/rc.local</i> ファイルを使用します。たとえば、/usr/local/sbin/daemonx にデーモンをインストールしたとします。
これをシステムの起動時に起動したい場合には、<i>/etc/rc.local</i> に以下のようなエントリを書き加えます。

<blockquote><pre>
if [ -x /usr/local/sbin/daemonx ]; then
             echo -n ' daemonx';       /usr/local/sbin/daemonx
fi
</pre></blockquote>

<p>
(もし、システム起動時にデーモンが自動的に起動されなかった場合には、
コマンドラインの行末に "&amp;" を追加するということを覚えておいてください。)

<p>
これ以降は、起動時にこのデーモンが実行されるようになります。また、起動時のエラーも見られます。
もし、エラーなしで普通にブートすると、以下のような行が表示されるでしょう。

<blockquote><pre>
Starting local daemons: daemonx.
</pre></blockquote>

<h3>rc.shutdown</h3>

<p>
<i>/etc/rc.shutdown</i> はシャットダウンの際に実行されるスクリプトです。
システムのシャットダウン前に実行させたいことは、すべてこのファイルに記述してください。
apm があるのでしたら、&quot;powerdown=YES&quot; も設定しておきます。これは &quot;shutdown -p&quot;と同じになります。

<p>
<a name= "RelayingDenied"></a>
<h2>10.4 - ユーザが OpenBSD システム経由でリモートからメールを送ろうとすると、中継が拒否されるのはなぜでしょう ?</h2>

<p>
以下を試してみてください。

<blockquote><pre>
# <strong>cat /etc/mail/sendmail.cf | grep relay-domains</strong>
</pre></blockquote>

<p>
出力はこのような感じでしょう。

<blockquote><pre>
FR-o /etc/mail/relay-domains
</pre></blockquote>

<p>
もし、このファイルがないようでしたら、これを作成してください。
リモートからメールを送信してくるホストを、以下の構文で記述する必要があります。

<blockquote><pre>
.domain.com    # domain.com内のホストからはすべてのメールのやり取りを認める
sub.domain.com # sub.domain.com とそのドメイン内のホストからはすべてのメールのやり取りを認める
10.2           # IP ネット 10.2.*.*内の全ホストからのメールのやり取りを認める
</pre></blockquote>

<p>
このファイルを作成したら、sendmail に「HangUP」シグナルを送るのを忘れないようにしましょう
(ほとんどのデーモンに設定を再読み込みさせるシグナルです)。

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/sendmail.pid`</strong>
</pre></blockquote>

<p>

<h3>参考文献</h3>

<p>
<ul>
<li><a href="http://www.sendmail.org/~ca/email/relayingdenied.html">http://www.sendmail.org/~ca/email/relayingdenied.html</a>
<li><a href="http://www.sendmail.org/tips/relaying.html">http://www.sendmail.org/tips/relaying.html</a>
<li><a href="http://www.sendmail.org/antispam.html">http://www.sendmail.org/antispam.html</a>
</ul>

<p>
<a name= "POP"></a>
<h2>10.5 - POP を設定したのに、誰も POP サーバにアクセスできなくて困っています。どうすれば良いのでしょう ?</h2>

<p>
POP に関係する問題のほとんどは、一時ファイルとロックファイルの問題でしょう。
pop サーバから以下のようなエラーメッセージが出力された場合には、

<blockquote><pre>
-ERR Couldn't open temporary file, do you own it?
</pre></blockquote>

<p>
ファイルパーミッションを以下のように変更してください。</p>

<blockquote><pre>
permission in  /var
drwxrwxr-x   2 bin     mail     512 May 26 20:08 mail


permissions in  /var/mail
-rw-------   1 username   username        0 May 26 20:08 username
</pre></blockquote>

<p>
もうひとつチェックしておきたいのは、ユーザの /var/mail ファイルがそのユーザ自身の所有になっているかどうかです。
もちろんそうなっているはずなのですが (つまり、/var/mail/joe を所有しているのは joe のはずなのですが)、
なぜかそうなっていない場合には、それが問題の原因でしょう !

<p>
もちろん、/var/mail に対して、グループ mail での書き込みを許可しておくと、
あいまいで変なセキュリティ上の問題が発生します。おそらく、このようにしておいても何も問題はないでしょう。
しかし、問題になる可能性はあります (特にあなたが有名なサイトを運営していたり、ISP だったりしたら...) !
OpenBSD の ports コレクションには、正しい方法でインストールすることが可能な
POP デーモンがいくつかあります。
しかし、もし可能でしたら、
OpenBSD の基本インストールで利用可能となっている
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=popa3d&amp;sektion=8">popa3d</a>
を使用してください。
あるいは単に、自分の POP デーモン用に選んだオプションが間違っているだけなのかも知れません
(たとえば、dot locking 等)。あるいは、POP デーモンがロックをかけるディレクトリを
変更すれば済む話かも知れません (ただし、そうなるとロックは POP デーモンにとってのみ
意味があることになってしまうのですが)。

<p>
<b>追伸:</b> OpenBSD は &quot;mail&quot; という名前のグループを持っていないことに注意してください。ですので、必要なら、これを <i>/etc/group</i> ファイルに作成しなければなりません。このエントリは、

<blockquote><pre>
mail:*:6:
</pre></blockquote>

<p>
のようなもので十分でしょう。

<a name="SendmailDNS"></a>
<h2>10.6 - どうして sendmail は <tt>/etc/hosts ファイルを無視するのでしょう ?</tt></h2>

<p>
デフォルトで、sendmail は、<tt>/etc/hosts</tt> ファイルではなく、
DNS を名前解決に使用します。この挙動は、<tt>/etc/mail/service.switch</tt>
を使用することで変更することが可能です。

<p>
DNS サーバへの問い合わせの前に hosts ファイルを参照したい場合には、
以下のような行を含む <tt>/etc/mail/service.switch</tt> ファイルを作成します。

<pre>
     hosts       files dns
</pre>

<p>
もし、hosts ファイル*だけ*を参照させたい場合には、次のような行を使用します。

<pre>
     hosts       files
</pre>

<p>
そして、以下のように sendmail に HUP シグナルを送ります。

<pre>
     # <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre>

<p>
これによって上記の変更が有効になります。


<p>
<a name= "HTTPS"></a>
<h2>10.7 - SSL(8) を使用したセキュアな HTTP サーバの設定</h2>

<p>
OpenBSD は SSL 対応の httpd および RSA ライブラリを含んで出荷されています。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
で使用するためには、
まず証明書を作成しなければなりません。これは <i>/etc/ssl/private/</i>
中の関連する鍵とともに <i>/etc/ssl/</i> に保存されます。
ここで示すステップは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>
man ページからのものです。詳細についてはそちらを参照してください。この FAQ は、
web サーバ用に RSA 証明書の作成の仕方を説明しますが、
DSA サーバ証明書には触れません。こちらについては、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>
man ページを参照してください。

<p>
最初に、OpenSSL を使用して自分のサーバの鍵と証明書を作成する必要があります。

<div style="margin-left: 2em">
<pre>
# <strong>openssl genrsa -out /etc/ssl/private/server.key 1024</strong>
</pre>
</div>

<p>
あるいは、鍵をパスフレーズで暗号化して、
それをタイプしないとサーバが起動できないようにするには以下のようにします。

<div style="margin-left: 2em">
<pre>
# <strong>openssl genrsa -des3 -out /etc/ssl/private/server.key 1024</strong>
</pre>
</div>

<p>
次のステップは、証明書署名要求を出すことです。これで
Certifying Authority (CA) に証明書にサインをもらうことができます。
そのためには、以下のコマンドを使用します。

<div style="margin-left: 2em">
<pre>
# <strong>openssl req -new -key /etc/ssl/private/server.key -out /etc/ssl/private/server.csr</strong>
</pre>
</div>

<p>
これで鍵にサインしてくれる CA に渡すことのできる <i>server.csr</i> ファイルが生成されます。
このような CA の一例として、<a href="http://www.thawte.com/">http://www.thawte.com/</a>
でアクセス可能な <b>Thawte Certification</b> があります。Thawte は現時点では、RSA 鍵に署名してくれますが、
DSA 鍵も使用できるようにするための手続きも進行中です。

<p>
とてもここまでできない人や、証明書は自分でサインすればいいと考える人は、以下のようにすることもできます。

<div style="margin-left: 2em">
<pre>
# <strong>openssl x509 -req -days 365 -in /etc/ssl/private/server.csr \
       -signkey /etc/ssl/private/server.key -out /etc/ssl/server.crt</strong>
</pre>
</div>

<p>
<i>/etc/ssl/server.crt</i> と <i>/etc/ssl/private/server.key</i> があれば、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a> を <b>-DSSL</b> フラグつきで起動できるはずです。
これであなたのマシンも、ポート 443 で https のトランザクションができるようになったはずです。

<p>
<a name= "vipw"></a>
<h2>10.7 - /etc/passwd を vi(1) で編集したのに変更が反映されません。なぜでしょう ?</h2>

<p>
/etc/passwd を編集しても、変更は全部消えてしまいます。OpenBSD では、/etc/passwd を動的に
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pwd_mkdb&amp;sektion=8&amp;apropos=0">pwd_mkdb(8)</a> コマンドで生成しています。OpenBSD の主パスワードファイルは /etc/master.passwd なのです。
pwd_mkdb(8) によると、

<blockquote><pre>
FILES
     /etc/master.passwd  current password file
     /etc/passwd         a Version 7 format password file
     /etc/pwd.db         insecure password database file
     /etc/pwd.db.tmp     temporary file
     /etc/spwd.db        secure password database file
     /etc/spwd.db.tmp    temporary file
</pre></blockquote>

<p>
/etc/passwd のような従来の Unix パスワードファイルの場合、
ユーザの暗号化パスワードを含む各種情報が、システム上の万人に提供されていました
(そのため、Crack のようなプログラムの最初の標的にされてしまいます)。
4.4BSD で master.passwd ファイルが導入されましたが、これは拡張フォーマットを持っていて
(/etc/passwd で提供されていたものよりオプションが増えました)、root しか読むことができません。
さらに高速にデータにアクセスするため、このデータにアクセスするライブラリコールは、
通常は /etc/pwd.db と /etc/spwd.db とを読みます。

<p>
OpenBSD は、パスワードファイルを編集するのに使用するツールが附属しています。
これが vipw(8) です。vipw は vi (あるいは $EDITOR で定義したお気に入りのエディタ)
を使用して /etc/master.passwd を編集できるようにします。その編集が終了すれば、
その変更に合わせて、自動的に /etc/passwd、/etc/pwd.db、/etc/spwd.db を更新します。
vipw はまた、これらのファイルのロックの面倒も見てくれますので、
あなたの編集と同時に誰かが変更しようとした場合には、アクセスが拒否されるようになっています。

<p>
<a name= "AddDelUser"></a>
<h2>10.9 - ユーザを追加するには ? &nbsp; また、削除するには ?</h2>

<p>
OpenBSD は、簡単にユーザをシステムに追加するためのふたつのコマンドを用意しています。

<ul>
<li><a href="#adduser">adduser(8)</a>
<li><a href="#user">user(8)</a>
</ul>

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw(8)</a>
を使用して、ユーザを手で追加することもできますが、
これはほとんどの操作がより難しいものになります。

<a name="adduser"></a>
<p>
OpenBSD でユーザを追加するのに最も良い方法は
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>
スクリプトを使用することでしょう。<strong>/etc/adduser.conf</strong> を編集することで、
adduser(8) を設定することができます。
adduser(8) は <strong>/etc/passwd</strong>、<strong>/etc/group</strong>
と shell データベースに矛盾がないかもチェックします。
これは、エントリと $HOME ディレクトリも自動的に作成します。
さらには、ユーザの歓迎メッセージまで送信してくれるのです。
これはあなたのニーズ次第で変更することもできます。
以下では、例として、ユーザ <b>testuser</b> をシステムに追加しています。
このユーザの $HOME ディレクトリは <i>/home/testuser</i> で、
<b>guest</b> グループに入り、シェルは <i>/bin/ksh</i> となります。

<blockquote><pre>
# <strong>adduser</strong>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_]: <strong>testuser</strong>
Enter full name []: <strong>Test FAQ User</strong>
Enter shell csh ksh nologin sh [ksh]: <strong>ksh</strong>
Uid [1002]: <strong>&lt;Enter&gt;</strong>
Login group testuser [testuser]: <strong>guest</strong>
Login group is ``guest''. Invite testuser into other groups: guest no
[no]: <strong>no</strong>
Enter password []: 
Enter password again []:

Name:     testuser
Password: ****
Fullname: Test FAQ User
Uid:      1002
Gid:      31 (guest)
Groups:   guest
HOME:     /home/testuser
Shell:    /bin/ksh
OK? (y/n) [y]: <strong>y</strong>
Added user ``testuser''
Copy files from /usr/share/skel to /home/testuser
Add another user? (y/n) [y]: <strong>n</strong>
Goodbye!
</pre></blockquote>

<p>
ユーザを削除するには、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rmuser&amp;sektion=8">rmuser(8)</a>
ユーティリティを使用します。このユーティリティは、そのユーザの存在をすべて消去してしまいます。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=1">crontab(1)</a>
の関連エントリも消去されますし、$HOME ディレクトリも (オーナがそのユーザなら) 消去され、
メールも消去されます。もちろん、<strong>/etc/passwd</strong> と <strong>/etc/group</strong>
のエントリも消去されます。以下は、さきほど追加したユーザを削除した場合です。
ユーザ名を入力するようプロンプトが出力され、ユーザのホームディレクトリを削除すべきかどうか
確認を求められているのがわかります。

<blockquote><pre>
# <strong>rmuser</strong>
Enter login name for user to remove: <strong>testuser</strong>
Matching password entry:

testuser:$2a$07$ZWnBOsbqMJ.ducQBfsTKUe3PL97Ve1AHWJ0A4uLamniLNXLeYrEie:1002:31::0:0:Test FAQ User:/home/testuser:/bin/ksh

Is this the entry you wish to remove? <strong>y</strong>
Remove user's home directory (/home/testuser)? <strong>y</strong>
Updating password file, updating databases, done.
Updating group file: done.
Removing user's home directory (/home/testuser): done.
</pre></blockquote>

<a name="user"></a>
<h3>user(8) を使用したユーザの追加</h3>

<p>
これらのツールは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>
コマンドのような対話型ではありませんので、スクリプト内での使用がより簡単になっていると言えます。

<p>
このツール全体は以下のとおりです。
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=8">group(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupadd&amp;sektion=8">groupadd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupdel&amp;sektion=8">groupdel(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupinfo&amp;sektion=8">groupinfo(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupmod&amp;sektion=8">groupmod(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=user&amp;sektion=8">user(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=useradd&amp;sektion=8">useradd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userdel&amp;sektion=8">userdel(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userinfo&amp;sektion=8">userinfo(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=usermod&amp;sektion=8">usermod(8)</a>
</ul>

<h4>実際のユーザ追加</h4>

<p>
user(8) は対話的に使用できないので、ユーザを手軽に追加する最も簡単な方法は、
adduser(8) コマンドを使うことです。実際のコマンド <i>/usr/sbin/user</i> は、
その他の <i>/usr/sbin/user*</i> コマンド群のフロントエンドに過ぎません。
ですから、以下のコマンドは <b>user add</b> や <b>useradd</b>
を使用すれば追加できますし、何が必要で、何が不要かはあなたの選択次第であり、
コマンドの使用方法は一切変りません。

<p>
この例では、上記の <a href="#adduser">adduser</a> で行ったのと同じユーザを
同じ条件で追加してみましょう。useradd(8) は、
ユーザ追加前にデフォルト設定を知っているほうが、より使いやすいものになります。
この設定は、<i>/etc/usermgmt.conf</i> に記述してあり、
次のようにすることで参照可能です。

<blockquote><pre>
$ <strong>user add -D</strong>
group           users
base_dir        /home
skel_dir        /etc/skel
shell           /bin/csh
inactive        0
expire          Null (unset)
range           1000..60000
</pre></blockquote>

<p>
コマンドラインでオプション指定しない限りは、この設定が使用されます。
たとえば、ここでの例では、ユーザの所属グループは <b>users</b> ではなく
<b>guest</b> にしたいとします。さらにもうひとつのハードルがあります。
パスワードをコマンドラインで指定しなければなりません。
そのパスワードも、暗号化済みのパスワードなのです。ですから、まず
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=encrypt&amp;sektion=1">encrypt(1)</a>
ユーティリティを使用して予めパスワードを作成しておく必要があります。
たとえば、OpenBSD のパスワードはデフォルトでは Blowfish アルゴリズムを 6 回適用したものになります。
useradd(8) に指定するパスワードを作成するには、まず、以下のようにしなければならないことになります。

<blockquote><pre>
$ <strong>encrypt -p -b 6</strong>
Enter string:                &lt;---- ここで使いたいパスワードを入力
$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq
</pre></blockquote>

<p>
これで暗号化されたパスワードが作成されましたので、ユーザの追加を実行できます。

<blockquote><pre>
# <strong>user add -p '$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq' -u 1002 \
-s /bin/ksh -c "Test FAQ User" -m -g guest testuser</strong>
</pre></blockquote>

<p>
<b>注:</b> シェルが user(8) に送る前にこれを解釈してしまうので、
パスワードのストリングを囲むときには、
&quot;&nbsp;&quot; (ダブルクォーツ) ではなく、
'&nbsp;' (シングルクォート) を使用しなければなりません。
これに加えて、ユーザのホームディレクトリを作成して
<i>/etc/skel</i> のファイルをコピーしておく必要があるのでしたら、
<b>-m</b> オプションを忘れないようにしてください。

<p>
ユーザが問題なく作成されたかどうかを確認するには、いろいろな
ユーティリティが使用可能です。以下に、すべてが正しく作成されたかどうかを
確認するためのコマンドをいくつか挙げておきます。

<blockquote><pre>
$ <strong>ls -la /home</strong>
total 14
drwxr-xr-x   5 root      wheel   512 May 12 14:29 .
drwxr-xr-x  15 root      wheel   512 Apr 25 20:52 ..
drwxr-xr-x  24 ericj     wheel  2560 May 12 13:38 ericj
drwxr-xr-x   2 testuser  guest   512 May 12 14:28 testuser
$ <strong>id testuser</strong>
uid=1002(testuser) gid=31(guest) groups=31(guest)
$ <strong>finger testuser</strong>
Login: testuser                         Name: Test FAQ User
Directory: /home/testuser               Shell: /bin/ksh
Last login Sat Apr 22 16:05 (EDT) on ttyC2
No Mail.
No Plan.
</pre></blockquote>

<p>
これらのコマンドに加えて、user(8) は userinfo(8) と呼ばれる独自のユーティリティを提供していて、
ユーザ属性を表示することができます。

<blockquote><pre>
$ <strong>userinfo testuser</strong>
login   testuser
passwd  *
uid     1002
groups  guest
change  Wed Dec 31 19:00:00 1969
class
gecos   Test FAQ User
dir     /home/testuser
shell   /bin/ksh
expire  Wed Dec 31 19:00:00 1969
</pre></blockquote>

<h4>ユーザ削除</h4>

<p>
user(8) 以下のコマンドでユーザ削除するには、userdel(8) を使用します。
これはとても簡単で使いやすいコマンドです。
上記の例で作成したユーザを削除するには、単に次のようにします。

<blockquote><pre>
# <strong>userdel -r testuser</strong>
</pre></blockquote>

<p>
<b>-r</b> オプションに注意してください。ユーザのホームディレクトリも同時に削除する場合には、
このオプションが必要になります。あるいは、<b>-r</b> の代わりに
<b>-p</b> を指定した場合には、ユーザのアカウントはロックされますが、
情報が一切削除されることはありません。

<p>
<a name= "FTPOnly"></a>
<h2>10.10 - (anonymous FTP ではない) ftp 専用アカウントを作成するにはどうすればよいのでしょう ?</h2>

<p>
いくつかの方法があるのですが、よく使われる方法としては <i>/usr/bin/false</i> を
<strong>/etc/shells</strong> にシェルとして追加し、そしてユーザを設定するときにログインシェルを
/usr/bin/false に指定することで、対話型のログインをできないようにした上で、 ftp は使用可能にすることができます。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a> を使用すると、
デフォルトでホームディレクトリを <i>/home/&lt;user&gt;</i> にすることができます。それで良ければ、ホームディレクトリを
変更しなくても構いませんが、これも任意のディレクトリを指定することができます。<i>/etc/ftpchroot</i>
に対象ユーザのユーザ名を加えておけば、そのユーザがアクセスできるのは彼自身のホームディレクトリのファイルだけになります。
また、<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a> に
<b>-A</b> オプションを指定することで、ftpchroot ログインしか受け付けなくなります !

<p>
<a name= "Quotas"></a>
<h2>10.11 - ユーザのディスク quota を設定</h2>

<p>
quota は、あるユーザがドライブ上で使用可能なディスクスペースを制限するのに使用します。
リソースが限られているときにはとても役に立ちます。
quota はユーザ別 および/または グループ別に設定することができます。

<p>
quota の設定の第一歩は、
<a href="../faq5.html#Options">カーネルの設定</a>の中に
"<tt>option QUOTA</tt>" が入っていることを確かめることです。
これは GENERIC カーネルにはデフォルトで入っています。次に、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"><tt>/etc/fstab</tt></a>
の中で quota を有効にするファイルシステムにマークをつけることで、これは
quota を使用するファイルシステムに、<tt>userquota</tt> と <tt>groupquota</tt>
というキーワードでマークを示します。デフォルトで
<tt>quota.user</tt> と <tt>quota.group</tt> というファイルが
そのファイルシステムのルートに作成され、ここに quota の情報が保存されます。
このデフォルトは、"userquota=/var/quotas/quota.user" のように
quota オプションにファイル名を指定することでオーバーライドされます。
もちろん、ここで指定するのは、quota 情報が指定されているどのようなファイルでも構いません。
以下は、userquota を有効にしたファイルシステムがひとつだけ存在し、
quota ファイルが標準ではない位置に存在する /etc/fstab の例です。

<blockquote><pre>
/dev/wd0a / ffs rw,userquota=/var/quotas/quota.user 1 1
</pre></blockquote>

<p>
では、ユーザの quota を設定しましょう。これには、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=edquota&amp;sektion=8">edquota(8)</a>
ユーティリティを使用します。簡単な使用方法は、単に "<tt>edquota&nbsp;&lt;user&gt;</tt>"
とします。edquota(8) は、vi(1) や環境変数 EDITOR に設定されたエディタを使用して quota
を編集します。たとえば、

<blockquote><pre>
# <strong>edquota ericj</strong>
</pre></blockquote>

<p>
入力することによる出力は以下のようになります。

<blockquote><pre>
Quotas for user ericj:
/: blocks in use: 62, limits (soft = 0, hard = 0)
	inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
ユーザのディスク使用量を制限するには、このファイルを以下の例のように編集します。

<blockquote><pre>
Quotas for user ericj:
/: blocks in use: 62, limits (soft = 1000, hard = 1050)
	inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
quota の割り当ては 1k ブロック単位で行われることに注意してください。
ここでは softlimit が 1000k にセットされ、hardlimit は
1050k にセットされています。softlimit というのは、
ユーザが制限を越えたという警告を受けて、猶予期間内にディスク使用量を減らすよう、
ユーザに要求を出します。猶予期間は eduquota(8) で <strong>-t</strong>
オプションを使用することで設定できます。
この猶予期間が過ぎると、softlimit は hardlimit として処理されるようになります。
これは普通は、アロケーションエラーを引き起こすことになります。

<p>
これで quota が設定されましたので、quota を有効にします。そのためには、以下の例のように
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quotaon&amp;sektion=8">quotaon(8)</a>
を使用します。

<blockquote><pre>
# <strong>quotaon -a</strong>
</pre></blockquote>

<p>
これは <tt>/etc/fstab</tt> を参照して、quota オプションのついたファイルシステムを有効化する作業です。
これによって、quota が有効になりますので、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quota&amp;sektion=1">quota(1)</a>
を使用して見ることが可能になります。"<tt>quota &lt;user&gt;</tt>" というコマンドを使用することで、
そのユーザの情報も見ることができます。引数なしで呼び出されると、quota(1) コマンドは quota 統計を表示すします。
たとえば以下のようにしてみてください。

<blockquote><pre>
# <strong>quota ericj</strong>
</pre></blockquote>

<p>
すると、得られる結果は以下のようなものになるはずです。

<blockquote><pre>
Disk quotas for user ericj (uid 1001): 
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
              /      62    1000    1050              27       0       0        
</pre></blockquote>

<p>
デフォルトで /etc/fstab で設定した quota が起動時にセットされます。
これをオフにするには、次のコマンドを使用します。

<blockquote><pre>
# <strong>quotaoff -a</strong>
</pre></blockquote>

<p>
<a name= "Kerberos"></a>
<h2>10.12 - KerberosV のクライアントとサーバの設定</h2>

<p>
OpenBSD には、デフォルトの状態で KerberosV がシステムの構成部品として組み込まれています。

<p>
KerberosV についてのより詳しいことは、OpenBSD システム上で以下のコマンドを使用してください。
<pre>
     # <b>info heimdal</b>
</pre>


<p>
<a name= "AnonFTP"></a>
<h2>10.13 - Anonymous FTP サービスの設定</h2>

<p>
Anonymous FTP は、アカウントのない人たちに File Transfer Protocol を使用してあなたのコンピュータ上のマシンにアクセスさせるものです。
以下に、この anonymous FTP サーバの概要、そのログの取り方、その他の設定について述べます。

<h3>FTP アカウントの追加</h3>

<p>
まず、システム上に "ftp" というアカウントが必要になります。このアカウントは、使用可能なパスワードを持っていてはいけません。
ここでは仮にログインディレクトリを /home/ftp としますが、これはどこでも好みのディレクトリを指定して構いません。
anonymous ftp を使用する場合、ftp は chroot して 'ftp' ユーザのホームディレクトリに移動します。この詳細については、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftp(8)</a> と 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a> の
man ページを参照してください。以下に <i>ftp</i> ユーザ追加の例を示します。ここでは <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a> を使用します。
さらに <i>/etc/shells</i> に /usr/bin/false を追加しておいてください。これがこの ftp ユーザに使用させる &quot;シェル&quot;
ということになります。このため彼らは、空のパスワードをもらってもログインすることはできません。これには簡単に
<i>echo /usr/bin/false &gt;&gt; /etc/shells</i> とすれば良いでしょう。また、adduser
の質問のときにそのシェルがあらわれるようにしたければ、<i>/etc/adduser.conf</i> も変更しておく必要があります。

<blockquote><pre>
oshibana# <strong>adduser</strong>
Use option ``-silent'' if you don't want see all warnings &amp; questions.

Reading /etc/shells
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_]: <strong>ftp</strong>
Enter full name []: <strong>anonymous ftp</strong>
Enter shell csh false ksh nologin sh tcsh zsh [sh]: <strong>false</strong>
Uid [1002]:
Login group ftp [ftp]:
Login group is ``ftp''. Invite ftp into other groups: guest no
[no]: <strong>no</strong>
Enter password []:
Use an empty password? (y/n) [y]: <strong>y</strong>

Name:     ftp
Password: ****
Fullname: anonymous ftp
Uid:      1002
Gid:      1002 (ftp)
Groups:   ftp
HOME:     /home/ftp
Shell:    /usr/bin/false
OK? (y/n) [y]: <strong>y</strong>
Added user ``ftp''
Copy files from /usr/share/skel to /home/ftp
Add another user? (y/n) [y]: <strong>n</strong>
Goodbye!
</pre></blockquote>

<h3>ディレクトリの設定</h3>

<p>
これでユーザと同時に <i>/home/ftp</i> というディレクトリが作成されました。これはこちらの意図したとおりの結果なのですが、
anonymous ftp で使用するためにはもうひと工夫が必要になります。これについては
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftp(8)</a> man ページに説明されています。

<p>
/home/ftp/usr や /home/ftp/bin ディレクトリは<b>作成する必要はありません</b>。
<ul>
<li><i>/home/ftp</i> - これがメインのディレクトリです。所有者は root にして、パーミッションは 555 にしておいてください。
<li><i>/home/ftp/etc</i> - これはまったくのオプションでしかなく、お勧めもしません。それは、このマシン上のユーザについての情報を漏曳することになるだけだからです。しかし、anonymous ftp ディレクトリで、ファイルに実際のオーナ情報等を表示させたい場合には、<i>/home/ftp/etc</i> ディレクトリを作成して /etc/pwd.db と /etc/group をこのディレクトリにコピーしておきます。このディレクトリはモードを 511 にして、コピーしたふたつのファイルはモード 444 にしておきます。これでファイルの所有者が番号ではなく名前で表示されるようになります。
また、pwd.db にはパスワードは含まれず、パスワードはすべて spwd.db に入っています。
ですから、spwd.db は<strong>絶対に</strong>コピーしてはいけません。
<li><i>/home/ftp/pub</i> - これは、共有したいファイルをコピーしておく標準のディレクトリです。
このディレクトリもモード 555 にしておいてください。
</ul>

<p> 
以上のディレクトリはすべて、所有者を「root」にしておきます。
以下に、最終的にディレクトリがどのような構成になるのかを示します。

<blockquote><pre>
oshibana# pwd 
/home
oshibana# ls -laR ftp
total 5
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 .
drwxr-xr-x  7 root  wheel  512 Jul  6 10:58 ..
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 etc
dr-xr-xr-x  2 root  ftp    512 Jul  6 11:33 pub

ftp/etc:
total 43
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 .
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 ..
-r--r--r--  1 root  ftp    316 Jul  6 11:34 group
-r--r--r--  1 root  ftp  40960 Jul  6 11:34 pwd.db

ftp/pub:
total 2
dr-xr-xr-x  2 root  ftp  512 Jul  6 11:33 .
dr-xr-xr-x  5 root  ftp  512 Jul  6 11:33 ..
</pre></blockquote>

<h3>サーバを起動してログの取得を開始</h3>

<p>
ftpd の場合、これを inetd から実行するのか、あるいは rc スクリプトで開始するのか選択することが可能です。以下の例では、
デーモンを <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/inetd.conf">inetd.conf</a> から起動することにします。
まずは ftpd のオプションのいくつかに馴れておいてください。<i>/etc/inetd.conf</i> のデフォルトの記述は以下のようになります。

<blockquote><pre>
<strong>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -US</strong>
</pre></blockquote>

<p>
ここでは ftpd は <i>-US</i> オプションで起動されています。これは anonymous 接続のログを <i>/var/log/ftpd</i> に記録し、
同時に発生するセッションのログを <i>/var/run/utmp</i> に記録するものです。これでセッションが who(1) で見られるようになります。
中には、anonymous サーバだけを実行して、ユーザには ftp を許可しないようにしたい場合もあるでしょう。そのためには、ftpd を
<i>-A</i> オプションで起動します。以下に挙げるのは、ftpd を anonymous 接続のみを認める形で起動する例です。さらに <i>-ll</i>
オプションも付与しています。これは、get、retrieve などの ftp コマンドと合わせて、それぞれの接続のログを syslog に記録します。

<blockquote><pre>
<strong>ftp             stream  tcp     nowait  root    /usr/libexec/tcpd       ftpd -llUSA</strong>
</pre></blockquote>

<p>
Note - トラフィックが非常に高い ftp サーバを運用する人は、ftpd を inetd.conf から起動しないほうがいいかも知れません。
最も良い方法は、inetd.conf の ftpd をコメントアウトして、ftpd を <i>-D</i> オプションつきで rc.conf から起動することでしょう。
これなら、ftpd はデーモンとして起動されるので、inetd から起動するよりオーバーヘッドもずっと小さくなるのです。
rc.conf から起動するときの記述例は以下のようになりませす。

<blockquote><pre>
ftpd_flags="-DllUSA"           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
これはもちろん、<i>/etc/inetd.conf</i>から ftpd をコメントアウトして、
inetd にこのファイルを再読み込みさせておかなければうまく動作しません。

<h3>その他関連ファイル</h3>

<ul>
<li><i>/etc/ftpwelcome</i> - ここには ftp サーバに接続した人に対して表示するメッセージを書きます。
<li><i>/etc/motd</i> - これは、ftp サーバにログインしてきた人に対して表示するメッセージです。
<li><i>.message</i> - このファイルはどこのディレクトリに置いても構いません。ユーザがそのディレクトリに入ってきたら表示されるメッセージです。
</ul>


<p>
<a name= "ftpchroot"></a>
<h2>10.14 - ftpd(8) でユーザをホームディレクトリから出られないようにするには</a></h2>

<p>
OpenBSD の <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a> は、
デフォルトでこれを簡単にこなせるようになっています。これは
<strong>/etc/ftpchroot</strong> ファイルを使用することで実現できます。
ユーザは常に信用できるとは限りませんから、
ホームディレクトリに押し込めておくことが必要になるかも知れません。
これはデフォルトでは、有効になっていません。デフォルトの挙動の例を以下に示します。

<blockquote><pre>
$ <strong>ftp localhost</strong>
Connected to localhost.
220 oshibana FTP server (Version 6.4/OpenBSD) ready.
Name (localhost:ericj): <strong>ericj</strong>
331 Password required for ericj.
Password: <strong>*********</strong>
230- OpenBSD 3.3 (GENERIC) #44: Sat Mar 29 13:22:05 MST 2003
230- 
230- Welcome to OpenBSD: The proactively secure Unix-like operating system.
230- 
230- Please use the sendbug(1) utility to report bugs in the system.
230- Before reporting a bug, please try to reproduce it with the latest
230- version of the code.  With bug reports, please try to ensure that
230- enough information to reproduce the problem is enclosed, and if a
230- known fix for it exists, include that as well.
230- 
230 User ericj logged in.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> <strong>cd /</strong>
250 CWD command successful.
ftp> <strong>ls</strong>
227 Entering Passive Mode (127,0,0,1,60,7)
150 Opening ASCII mode data connection for 'file list'.
altroot
bin
dev
etc
home
mnt
root
sbin
stand
tmp
usr
var
bsd
sys
boot
226 Transfer complete.
ftp> <strong>quit</strong>
221 Goodbye.
</pre></blockquote>

<p>
ご覧のとおり、全サーバへのアクセスが認められてしまいます。
この世が完璧であらゆるユーザが全面的に信用できるのであれば、
これでも構いませんが、残念ながらそうはいきません。ユーザを制限するには、
単にそのユーザ名を <strong>/etc/ftpchroot</strong> ファイルに記述します。
以下の例では、&quot;ericj&quot; というユーザが制限されています。

<blockquote><pre>
$ <strong>cat /etc/ftpchroot</strong>
#       $ OpenBSD: ftpchroot,v 1.3 1996/07/18 12:12:47 deraadt Exp $
#
# list of users (one per line) given ftp access to a chrooted area.   
# read by ftpd(8).
ericj
</pre></blockquote>

<p>
これだけで、&quot;ericj&quot; というユーザは自分のディレクトリから出られなくなます。
次の例のように、/ ディレクトリが
いきなりこのユーザのホームディレクトリになっているのです !

<blockquote><pre>
$ <strong>ftp localhost</strong>
Connected to localhost.
220 oshibana FTP server (Version 6.4/OpenBSD) ready.
Name (localhost:ericj): <strong>ericj</strong>
331 Password required for ericj.
Password: <strong>*********</strong>
230 User ericj logged in.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> <strong>cd /</strong>
250 CWD command successful.
ftp> <strong>ls</strong>
227 Entering Passive Mode (127,0,0,1,92,171)
150 Opening ASCII mode data connection for 'file list'.
.login
.mailrc
.profile
.rhosts
.ssh
.cshrc
work
mail
src
226 Transfer complete.
ftp> <strong>quit</strong>
221 Goodbye.
</pre></blockquote>

<p>
<a name= "Patches"></a>
<h2>10.14 - OpenBSD にパッチを適用する</h2>

<p>
OpenBSD ソースツリーは絶えず変化して改善されていますし、
同時によくある問題への修正も行われ、そのためのパッチが公開されています。
これらのパッチは、
<a href="../../ja/errata.html">http://www.openbsd.org/errata.html</a>
にある errata web ページ上で、カテゴリ別に分けて公開されています。そして、
これらのカテゴリは、それぞれのアーキテクチャごとに適用されるべきパッチと、
アーキテクチャ独立のパッチに関連しています。

<p>
しかし、パッチは OpenBSD への機能追加のために行われているわけではないことに注意してください。
これは、緊急対応が必要な、重要な信頼性改善やセキュリティ上の問題への対応のためだけに使用されるものです。
ただし、それに対応するかどうかについては、
常にシステム管理者次第です。

<p>
たとえば、セキュリティのための修正のため、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=talkd&amp;sektion=8">talkd(8)</a> に
<a href="../../ja/errata.html">errata.html</a>
からのパッチを適用してみましょう。

<h3>このようなパッチは、CVS ツリーにあるものとはどのように異なっているのでしょうか ?</h3>

<p>
<a href="../../ja/errata.html">http://www.openbsd.org/errata.html</a>
にポストされるパッチは、最新リリースのソースツリーに対するものなのです。
また、最新の CVS ツリーに対するパッチには、リリースシステムでは求められないような
その他の変化が含まれているかも知れません。

<h3>システムにパッチをあてる準備をします。</h3>

<p>
OpenBSD オペレーティングシステム用のパッチは、diff で配布されています。
これは元のソースコードに対する差分を含むテキストファイルです。
これはバイナリ形式では<b>配布されていません</b>。つまり、
システムにパッチを適用するためには、OpenBSD
<b>リリース</b>バージョンのソースコードが手元になければなりません。
OpenBSD のソースコードが全部そろっている必要はありませんが、
パッチを適用するプログラムの分についてはすべて必要となります。たとえば、
カーネルにパッチを適用するのでしたら、カーネルのソースコードが手元に必要となるのです。

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cvs&amp;sektion=1">cvs(1)</a>
を使用すると、手軽に好みの anonymous cvs サーバから、必要なソースコードだけを取得することができます。サーバ一覧は
<a href="http://www.openbsd.org/ja/anoncvs.html">http://www.openbsd.org/anoncvs.html</a>
を参照してください。

<p>
<i>3.3-release</i> の talkd(8) のソースコードを
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cvs&amp;sektion=1">cvs(1)</a>
で取得するには、以下のコマンドを使用します。

<div style="margin-left: 2em">
<pre>
$ <b>cvs -d anoncvs@anoncvs5.usa.openbsd.org:/cvs co -rOPENBSD_3_3_BASE src/libexec/talkd/</b>
cvs server: Updating src/libexec/talkd
U src/libexec/talkd/announce.c
U src/libexec/talkd/talkd.c
U src/libexec/talkd/talkd.h
</pre>
</div>

<p>
必要なソースコードの CVS パスを調べるには、適用したいパッチの <i>Index:</i> 行を見ます。
この例では、CVS パスは <i>src/libexec/talkd/</i> になります。必ず OPENBSD_version_number_BASE のリビジョンをチェックしてください。&quot;BASE&quot; がない場合には、安定版ブランチをチェックアウトしていることになります。これには不要な他のコードが含まれているかも知れません。既にパッチブランチを追いかけているのでしたら、パッチは既にソースに含まれているはずですが、必ず確認するようにしてください。<a href="../../ja/plus.html">http://www.openbsd.org/plus.html</a> を見れば、どのパッチがパッチブランチに適用されたのかがわかるはずです。もし、パッチがまだ適用されていなければ、上記のコマンドを使用して最新リリースのソースコードを取得してください。

<p>
また、公式 OpenBSD CD を買ってくれた人は、直接 CD からソースコードを持ってくると良いでしょう。CD からソースを持ってくる方法については、CD に付属の紙を見てください。このようにすれば、anoncvs 経由でソースを持って来る必要はありません。

<blockquote><pre>
Apply by doing:
        cd /usr/src
        patch -p0 &lt; 026_talkd.patch
        cd libexec/talkd
        make obj &amp;&amp; make depend &amp;&amp; make &amp;&amp; make install

Index: libexec/talkd/announce.c <b>&lt;------ Path to sources </b>
===================================================================
RCS file: /cvs/src/libexec/talkd/announce.c,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -r1.8 -r1.9
--- libexec/talkd/announce.c    1998/08/18 03:42:10     1.8
+++ libexec/talkd/announce.c    2000/07/06 00:01:45     1.9
@@ -160,6 +160,6 @@
                *(bptr++) = '\n';
        }
        *bptr = '\0';
-       fprintf(tf, big_buf);
+       fprintf(tf, "%s", big_buf);
        fflush(tf);
 }
</pre></blockquote>

<p>
然るべきソースコードを入手したら、パッチを取得して <i>src/</i> に置いてください。

<h3>パッチを適用する</h3>

<div style="margin-left: 2em">
<pre>
$ <b>cd /usr/src</b>
$ <b>patch -p0&lt;/path/to/026_talkd.patch</b>
Hmm...  Looks like a unified diff to me...
The text leading up to this was:
--------------------------
|Apply by doing:
|       cd /usr/src
|       patch -p0 &lt; 026_talkd.patch
|       cd libexec/talkd
|       make obj &amp;&amp; make depend &amp;&amp; make &amp;&amp; make install
|
|Index: libexec/talkd/announce.c
|===================================================================
|RCS file: /cvs/src/libexec/talkd/announce.c,v
|retrieving revision 1.8
|retrieving revision 1.9
|diff -u -r1.8 -r1.9
|--- libexec/talkd/announce.c   1998/08/18 03:42:10     1.8
|+++ libexec/talkd/announce.c   2000/07/06 00:01:45     1.9
--------------------------
Patching file libexec/talkd/announce.c using Plan A...
Hunk #1 succeeded at 160. <b>&lt;------------ Patch Succeeded</b>
done
$ <b>cd /usr/src/libexec/talkd/</b>
$ <b>ls</b>
CVS             announce.c      print.c         table.c         talkd.c
Makefile        announce.c.orig process.c       talkd.8         talkd.h
$ <b>make obj &amp;&amp; make depend &amp;&amp; make</b>
making /home/ericj/lsrc/src/libexec/talkd/obj
mkdep -a /home/ericj/lsrc/src/libexec/talkd/talkd.c /home/ericj/lsrc/src/libexec/talkd/announce.c /home/ericj/lsrc/src/libexec/talkd/process.c /home/ericj/lsrc/src/libexec/talkd/table.c /home/ericj/lsrc/src/libexec/talkd/print.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/talkd.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/announce.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/process.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/table.c
cc -O2     -c /home/ericj/lsrc/src/libexec/talkd/print.c
cc   -o ntalkd talkd.o announce.o process.o table.o print.o
nroff -Tascii -mandoc /home/ericj/lsrc/src/libexec/talkd/talkd.8 &gt; talkd.cat8
$ <b>sudo make install</b>
install -c -s -o root -g bin  -m 555 ntalkd /usr/libexec
install -c -o root -g bin -m 444 talkd.cat8 /usr/share/man/cat8/talkd.0
/usr/share/man/cat8/ntalkd.0 -&gt; /usr/share/man/cat8/talkd.0
</pre>
</div>

<p>
これが終了したら、該当サービスを再起動してください。


<a name="httpdchroot"></a>
<h2>10.16 - Apache の chroot() って何でしょう ?</h2>
<!-- XXXchanges - stops being new with 3.3 -->

<p>
OpenBSD 3.2 から、Apache 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
サーバは、デフォルトで
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>
されるようになりました。これは驚異的にセキュリティを向上させるものですが、
そのための準備ができていなければ、問題を生ずることとなるかも知れません。

<h3>chroot とは何でしょう ?</h3>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>
されたアプリケーションは特定のディレクトリに閉じ込められ、そのディレクトリが
"<tt>/</tt>" (ルート) ディレクトリであるかのように見えます。
そして、残りのディレクトリツリーをさまよい歩くことはできません。
httpd(8) の場合ですと、プログラムが起動すると、まず、自身のログファイルをオープンし、
自身の TCP ポート (ただし、この時点では、まだデータは受信しません) とバインドし、
そして、自身の設定を読み込みます。次に、自分で自分自身を <i>/var/www</i> に閉じ込め、
権限を落とします。そして、リクエストを受け付け始めます。これは、Apache が使用し、
あるいはサービスを提供するすべてのファイルは、<i>/var/www</i>
ディレクトリの中になければならないということを意味します。これによって、
Apache に何かセキュリティ上の問題があった場合にも、セキュリティは驚異的に向上します。
ダメージは「読み込みのみ」のパーミッションを持つ単一のディレクトリに限定され、
そして損害を被るリソースはなくなるのです。

<h3>ユーザにとって、これは何を意味するのでしょう ?</h3>

<p>
単刀直入に言えば、chroot(2) を行う Apache は新しいものですので、多くの古い
アプリケーションやシステム設定は以前のようには動かなくなってしまうでしょう。

<ul>
<li><b>歴史的なファイルシステムのレイアウト:</b> OpenBSD の古い目のバージョンから
アップグレードされたサーバは、web ファイルをユーザのディレクトリに持っているかも
知れませんが、これは明らかに chroot(2) された環境では動作しなくなります。というのは、
chroot(2) された httpd(8) は <i>/home</i> にアクセスすることができなくなるからです。
管理者は、すべての web ファイルを置くには、既存の /var/www パーティションが
小さ過ぎることにも気付くかも知れません。この場合の選択肢は、再構築を行うか
chroot(2) の機能を使用しないことでしょう。もちろん、ユーザのホームディレクトリから
<i>/var/www</i> を指し示すシンボリックリンクを使用することもできますが、
chroot(2) されているため、その逆に <i>/var/www</i> から
ファイルシステムの他の場所へのシンボリックリンクを使用することはできません。
もし、ユーザに対して、<a href="faq10.html#ftpchroot">chroot(2) された
FTP アクセス</a>を行わせたいのでしたら、シンボリックリンク先には、
FTP chroot(2) のためにアクセスできないので、これもうまく動かないだろう
ということに注意してください。この問題に対する解決策は、これらのユーザに対しては
<i>/home</i> ディレクトリをホームディレクトリとして使用せず、たとえば
<i>/var/www/home</i> のようなディレクトリを代わりに使用させることでしょう。

<li><b>ログローテーション:</b> 通常、ログのローテーションは古いファイルをリネームすることによって
行われます。Apache の場合は、SIGUSR1 シグナルを httpd(8) に送信することで、古いログがクローズされ、
新しいログがオープンされます。しかし、いったん特権を放棄してしまうと、httpd(8) はログをオープンする
能力を持たなくなるので、これはもはや不可能となります。ですので、ログのローテーションを行うためには、
以下のように httpd(8) をいったん停止させて、再起動させる必要があります。

<pre>
     # <b>apachectl stop && apachectl start</b>
</pre>

また、これ以外に、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pipe&amp;sektion=2">pipe(2)</a>
にロギングし、pipe(2) の他端における外部のログローテーションの仕組みを使用する方法を含む、
他の戦略もあります。

<li><b>既存の Apache のモジュール:</b> 仮想的にすべてをロードする方法を使用することになるのですが、
一部は chroot(2) 環境下では正しく動作しない可能性がありますので、
"<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=apachectl&amp;sektion=8">apachectl</a> restart</tt>"
には、httpd(8) が終了してしまうようなエラーの原因となるなど、多くの問題が残ります。

<li><b>既存の CGI:</b> ほとんどのものは、そのままでは動かないでしょう。なぜなら、これらは、
<i>/var/www</i> の外部のプログラムやライブラリを必要とすることが多いからです。これらのうちの
いくつかは、(他のディレクトリのライブラリを必要としない) スタティックリンクとしてコンパイル
することによって解決できるかも知れません。また、これは取るに足りないことではありませんし、
かなりのプログラミング知識を要求されるのですが、他のほとんどは <i>/var/www</i> ディレクトリに
アプリケーションが必要とするファイルを置くことで解決できるかも知れません。ですので、ほとんどの
ユーザは、これらのアプリケーションが更新されるまでは chroot(2) の機能を単純に無効にする方が、
より簡単であるということに落ち着くでしょう。

</ul>

いくつかのケースでは、アプリケーションや設定ファイルを chroot 先に置くよう
変更することができます。他のケースでは、
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf</a></i>
の中で、httpd(8) のオプションとして <tt>-u</tt> を使用して、単にこの機能を無効化することになるでしょう。

<a name="rootshell"></a>
<h2>10.17 - 標準の root のシェルが好きではありません !</h2>
OpenBSD の <i>root</i> のデフォルトシェルは、伝統的な要因で
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>
となっています。OpenBSD の root login 用のシェルが csh(1) でなければならないという
必要条件はありません (が、これを変更する前の見解を保持しています)。

<p>
他の Unix ライクなオペレーティングシステムから来たユーザが、csh(1) は好みではない
と言って、どのようにすればこれを変更できるのかを尋ねてくることがあります。
そのような場合のためのいくつかの選択肢があります。

<ul>
<li><b><i>root</i> でログインしてはいけません !</b>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su</a>
と
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo</a>
さえあれば、初期設定後のほとんどのアプリケーションにとって、ユーザが
root としてログインしなければならない理由など、ほとんどありません。
<li><b>ログイン後に好みのシェルを呼び出す:</b> もし、ksh(1) や
他のシェルがお好みでしたら、それをデフォルトのシェルから呼び出しましょう。
<li><b>root のシェルを変更する:</b> これは、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chsh&amp;sektion=1">chsh</a> か
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw</a>
を使用して変更できます。
</ul>

伝統的な Unix のガイドラインでは、root 用のシェルはスタティックリンクとなるようにコンパイルされたものだけを使用すべき、
となっています。と言うのは、システムをシングルユーザモードで起動した場合、
root パーティション以外はマウントされないので、ダイナミックリンクされたシェルは <tt>/usr</tt>
パーティションに置かれたライブラリにアクセスできないからです。しかし、OpenBSD の場合、
システムがシングルユーザモードで使用するシェルを聞いてきますし、その場合のデフォルトが
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
となっていますので、このことは OpenBSD にとっては重大な問題ではありません。

OpenBSD の 3 個の標準シェル
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
および
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>)
は、すべてスタティックにリンクされていて、シングルユーザモードでも使用可能となっています。

<p>
root のシェルは絶対に変更すべきではないということがときどき言われますが、
OpenBSD においてはそのような理由は特にありません。しかし、繰り返しますが、
それが問題なのではなく、root としてログインしてはいけない、ということです。

<a name="ksh"></a>
<h2>10.18 - <i>ksh</i> で他に何ができますか ?</h2>
OpenBSD では、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
はパブリックドメイン版の Korn Shell である
<a href="http://web.cs.mun.ca/~michael/pdksh/">pdksh</a> であり、これは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a> と同じバイナリとなっています。

<p>
しばしば Linux システム上で使用されている <i>bash</i> のユーザの利便性は、
おそらく、非常によく似た機能を
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
にも見つけることができるでしょう。ksh(1) は、タブ補完やコマンド行編集、
および矢印キーによるヒストリ機能、CTRL-A/CTRL-E によるコマンド行の
先頭/最後へのジャンプなど、<i>bash</i> のよく使用される機能のほとんどを
用意しています。もし、他の <i>bash</i> の機能を希望する場合には、<i>bash</i> 自体を
<a href="faq8.html#Ports">ports</a> や <a href="faq8.html#Packages">packages</a>
から導入することも可能です。

<p>
<i>ksh</i> のコマンドプロンプトは、<tt>PS1</tt> 環境変数で設定される
デフォルトの "$ " 以上の情報を持つものに簡単に変更することができます。 
たとえば、次の行を <tt>/etc/profile</tt> に挿入することで、

<pre>
     export PS1='$PWD $ '
</pre>

以下のようなコマンドプロンプトを表示させることができるようになります。

<pre>
     /home/nick $
</pre>

多くの便利な機能や例が記載されている
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/ksh.kshrc?content-type=text/plain"><tt>/etc/ksh.kshrc</tt></a>
を参照して、
ユーザ自身の <tt>.profile</tt> の中に記述しておくと良いでしょう。
<p>
<font color= "#0000e0">
<a href="index.html">[FAQ の目次]</a>
<a href="faq9.html">[9 章 - Linux からのお引っ越し]</a>
<a href="faq11.html">[11 章 - パフォーマンスのチューニング]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq10.html,v 1.91 ]
<br>
$Translation: faq10.html,v 1.3 2003/06/17 23:04:53 toshi Exp $
<br>
$OpenBSD: faq10.html,v 1.3 2003/06/21 10:00:37 jufi Exp $
</small>
</body>
</html>  
