<!DOCTYPE HTML PUBLIC  "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="de">
<meta name="resource-type" content="document">
<meta name="description" CONTENT="Wie man einen OpenBSD port erzeugt">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1997-2004 by OpenBSD.">
<title>Das Erzeugen eines OpenBSD ports</title>
<link rev="made" href="mailto:www@openbsd.org">
</head>
<body text="#000000" bgcolor="#ffffff" link="#23238e">
<a href="index.html"><img alt="[OpenBSD]" height="30" width="141" src="../images/smalltitle.gif" border="0"></a>

  <h2><font color="#e00000">Das Erzeugen eines OpenBSD ports</font></h2>

   Du hast also gerade dein Lieblingssoftwarepaket auf deiner OpenBSD-Maschine
   kompiliert und möchtest deinen Erfolg mit anderen teilen, indem du davon
   einen Standard port machst ? Was also ist jetzt zu tun ?
  <p>
   Die wichtigste Sache, die du machen solltest, ist mit anderen zu <strong>kommunizieren</strong>.
   Frage die anderen Leute auf <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>,
   ob sie am selben port arbeiten. <em>Teile es dem ursprünglichen Programmierer
   mit</em>, inklusive der Probleme, wenn du welche findest. Wenn die Lizenzbedingungen
   nicht korrekt sind, sag es ihm. Wenn du grosse Schwierigkeiten hattest, den port zum Laufen
   zu kriegen, teile ihm mit, was verbessert werden könnte. Wenn sie nur auf Linux entwickeln und den
   Rest der Unix-Welt ignorieren, versuche, ihre Sichtweise etwas zu erweitern.
  <p>
   <strong>KOMMUNIKATION</strong> macht den Unterschied zwischen einem erfolgreichen port
   und einem port, der langsam von allen alleine gelassen und nicht mehr benutzt wird aus.
  <p>
   Sieh dir zuerst die porting-Informationen auf dieser Seite an. Dann überprüfe all
   die gelinkten Dokumente, insbesondere die OpenBSD porting 
   <a href="../checklist.html">checklist</a>.
  <p>
   Teste, teste nochmal und schlussendlich teste nochmals !
  <p>
   Liefere den port aus (submit).  Erzeuge einen 'gzipped tarball' des port Verzeichnisses.
   Du kannst diesen entweder auf einen öffentlichen FTP oder HTTP Server legen, und die
   Addresse an <a href="mailto:ports@openbsd.org">ports@openbsd.org</a> mailen,
   oder den port 'mime encoded' an die selbe Adresse schicken. Wähle einfach eine Methode aus.
  <p>

<h3><font color="#0000e0">Index der Porting Dokumentation</font></h3>
<ul>
<li><a href="#Avail">Verfügbare Porting Information</a></li>
<li><a href="#Policy">OpenBSD Porting Policy</a></li>
<li><a href="#Security">Sicherheitsemfpehlungen</a></li>
<li><a href="#Generic">Generische Porting Hinweise</a></li>
<li><a href="#Other">Andere hilfreiche Hinweise</a></li>
</ul>

  <h3><font color="#0000e0"><a name="Avail">Verfügbare Porting Information</a></font></h3>
  <ul>
   <li>OpenBSD porting <a href="../checklist.html">checklist</a>.
   <li>Die man page 
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5">bsd.port.mk(5)</a>.
       Sie dokumentiert das ports Infrastruktur Makefile, das am Ende 
       jedes individuellen port Makefiles eingeschlossen wird.  
       Es gibt am Anfang noch ein paar Kommentare innerhalb der Datei selbst,
       aber die meisten der sinnvollen Informationen sind jetzt dokumentiert.
   <li>Einige Unterschiede zu den anderen BSD port Systemen, hautpsächlich eine Zusammenfassung
   der <a href="../porting/de/diffs.html">Infrastruktur Unterschiede</a>.
   <li><a href="../porting/de/libraries.html">Das Benutzen von shared libraries
   in OpenBSD Ports</a>. Die Regeln sind <strong>sehr wichtig
   </strong> sobald du shared libraries benutzt.
   <li><a href="../porting/de/autoconf.html">GNU autoconf Spezifikationen</a>,
       wie man sie im Gebrauch mit OpenBSD Ports handhabt.
   <li><a href="../porting/de/config.html">Konfigurationsdateien</a>,
       ein häufiger Stolperstein für neue Entwickler und die einzigartigen
       Werkzeuge, die der OpenBSD Ports Tree besitzt, um diese zu verarbeiten.
   <li><a href="../audio-port.html">Das Portieren von Audio-Applikationen auf OpenBSD</a>.
   <li>Die
       <a href="http://www.netbsd.org/Documentation/software/packages.html">
       NetBSD Package System</a> Dokumentation. Dieses Dokument beschreibt die  
       NetBSD Version des FreeBSD Portsystems und ist recht hilfreich.
   <li>Das
       <a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/index.html">FreeBSD
       Porter's Handbook</a>.  Das ist die FreeBSD porting Bibel.
   <li>Die OpenBSD ports Mailingliste
       <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>.
  </ul>
  <h3><font color="#0000e0"><a name="Policy">OpenBSD Porting Politik</a></font></h3>
  <ul>
   <li>OpenBSD benutzt NICHT <code>/usr/local/etc/rc.d</code>.<br>
       <code>/usr/local</code> wird dank NFS oftmals von verschiedenen Maschinen
         benutzt.  Aus diesem Grund können Konfigurationsdateien, die spezifisch
         für eine bestimmte Maschine sind auch nicht in <code>/usr/local</code> abgelegt werden,
         <code>/etc</code> ist die zentrale Lagerstätte für individuelle 
 	 Maschinen-Konfigurationsdateien.
         Außerdem ist es OpenBSD Politik, niemals Dateien unter 
         <code>/etc</code> automatisch upzudaten. Ports, die ein spezifisches 
         Boot Setup benötigen, sollten den Administrator anweisen, was zu tun ist, 
	 anstatt blind Dateien zu instalieren.
   <li>OpenBSD komprimiert KEINE man pages.
   <li>OpenBSD benötigt KEIN <code>-lcrypt</code>.<br>
       DES ist Teil der Standard-<code>libc</code>.
   <li>OpenBSD hat einen separaten Namensraum für User und Gruppen, 
       die von ports erzeugt werden.
       See <code>/usr/ports/infrastructure/db/user.list</code> for details.
   <li>OpenBSD is stark sicherheitsorientiert. Du solltest die
       <a href="#Security">Sicherheitssektion</a> auf dieser Seite lesen und verstehen.
   <li>Stelle sicher, dass der <code>&#36;OpenBSD&#36;</code> CVS tag in das
       Makefile eingefügt wird. Wenn du einen port von einem anderen System importierst, stelle sicher,
       dass du auch ihren tag im Makefile belässt.
   <li>Das Ziel ist, dass alle 'ported applications' OpenBSD unterstützen. Um dieses Ziel zu erreichen
       <strong>musst</strong> du alle OpenBSD patches auch zurück an den originalen
       Programmierer zurückliefern.
  </ul>
  <h3><font color="#0000e0"><a name="Security">Sicherheitsempfehlungen</a></font></h3>
  Es gibt viele Sicherheitsprobleme, über die man sich Gedanken machen muss. Wenn du nicht 
       absolut sicher bist, was du tust, frage bitte auf der 
       <a href="mailto:ports@openbsd.org">ports</a> Mailingliste um Hilfe.

  <ul>
   <li>Benutze <em>keinen</em> alpha oder beta Code wenn du einen port vorbereitest. Benutze die letzte
       reguläre Version oder die letzte gepatchte.	 

   <li>Alle Software, die auf einem Server installiert werden soll, sollte auf
       buffer overflows untersucht werden, insbesondere unsichere Benutzung von 
       <code>strcat/strcpy/strcmp/sprintf</code>. Im allgemeinen sollte 
       <code>sprintf</code> durch <code>snprintf</code> ersetzt werden.

   <li>Benutze niemals Dateinamen statt echter Sicherheit. Es gibt zahlreiche 'race
       conditions'  in denen du keine saubere Kontrolle mehr hast. Ein Angreifer, der
       bereits normale Userrechte auf deiner Maschine hat, könnte Dateien in 
       <code>/tmp</code> mit symbolischen Links auf strategischere Dateien ersetzen, wie etwa
       <code>/etc/master.passwd</code>.  

   <li>Zum Beispiel erzeugen sowohl <code>fopen</code> als auch <code>freopen</code>
       <strong>eine neue Datei oder öffnen eine bereits existierende</strong> zum 
       Schreiben. Ein Angreifer könnte einen symbolischen Link von
       <code>/etc/master.passwd</code> auf <code>/tmp/addrpool_dump</code> setzen. Sofort 
       wenn ihn öffnest ist deine Passwortdatei verraten. Ja, sogar mit einem 
       <code>unlink</code> direkt davor. Du kannst nur das Fenster der Möglichkeiten
       enger machen.  Benutze stattdessen <code>open</code> mit
       <code>O_CREAT|O_EXCL</code> und <code>fdopen</code>.
                 
   <li>Ein weiteres sehr bekanntes Problem ist die <code>mktemp</code>
       Funktion. Beachte die Warnungen des 'bsd linker' bei ihre Benutzung.  
       <strong>Die müssen gefixed werden</strong>.
       Das ist nicht ganz so einfach wie <code>s/mktemp/mkstemp/g</code>.  <br>
       Sieh dir die <code>mktemp(3)</code> man page von OpenBSD current 
       für mehr Hinweise an.
       Korrekter Code, der <code>mkstemp</code> benutzt, schließt den Source zu
       <code>ed</code> oder <code>mail</code> ein.
       Eine seltenes Beispiel von Code, der <code>mktemp</code> korrekt benutzt 
       kann im <code>rsync</code> port gefunden werden.

   <li>Nur weil du etwas lesen kannst heisst es nicht, dass du das solltest. Eine
       sehr bekannte Lücke dieser Art war das <code>startx</code> Problem. Als
       setuid Programm konntest du startx mit jeder Datei als Skript starten.
       Wenn die Datei kein sauberes Shell-Skript war folgte eine Fehlermeldung, 
       zusammen mit der ersten Zeile der betreffenden Datei, ohne weitere
       Überprüfung der Rechte.  Ziemlich einfach die
       erste Zeile der shadow passwd Datei zu erhalten, besonders wenn man bedenkt, dass
       die erste Zeile meist den root Eintrag enthält.
       Öffne nicht deine Datei um dann ein
       <code>fstat</code> auf den 'open descriptor' zu machen, um zu überprüfen 
       ob du sie hättest öffnen können müssen (oder der Angreifer wird
       mit /dev/rst0 spielen und dein Band zurückspulen) -- öffne es mit korrekt 
       gesetzter uid/gid/grouplist.

   <li>Tue nichts, was eine Shell im Hintergrund von setuid Programmen forkt bevor du  
       deine Rechte zurücksetzt. Das schließt
       <code>popen</code> und 
       <code>system</code> ein.  
       Benutze stattdessen <code>fork</code>, <code>pipe</code> und <code>execve</code>.

   <li>
       Gib' offene 'descriptors' anstatt von Dateiname an andere Programme weiter, um race
       conditions zu vermeiden. Sogar wenn ein Programm keine 'file descriptors'
       akzeptiert, kannst du immer noch <code>/dev/fd/0</code> benutzen.

   <li>Zugriffsrechte sind an 'file descriptors' gebunden. Wenn du setuid Rechte setzen musst,
       um eine Datei zu öffnen, öffne die Datei, dann lass deine Rechte fallen. Du kannst nach
       wie vor auf den 'open descriptor' zugreifen, aber du musst dir um ihn weniger Dinge Sorgen machen. Das hat aber
       zwei Seiten: auch nachdem du die Rechte fallenlassen hast, solltest du noch auf die 'descriptors'
       aufpassen.

   <li>Vermeide root setuid wo du nur kannst. Grundsätzlich kann root alles tun,
       aber root Rechte werden nur sehr selten wirklich benötigt, vielleicht mit Ausnahme
       vom Erzeugen von Sockets mit einer Nummer kleiner 1024. Es ist beutend besser, dass 
       <code>inetd</code> zu überlassen und nur die relevanten Einträge in 
       <code>inetd.conf</code> zu machen.  
       Du musst natürlich die erforderliche Magie zum Schreiben von daemons kennen, um das
       zu erreichen.
       Man könnte sagen, dass du keinerlei Chancen hast, ein gutes setuid Programm zu schreiben,
       wenn du nicht weisst, wie man das macht.

   <li>Benutze setgid anstelle von setuid. Abgesehen von diesen spezifischen Dateien, die von
       setgid Programmen benötigt werden, sind die meisten Dateien nicht 'group-writable'. Daher 
       werden Sicherheitsprobleme in einem 'setgid' Programm dein System nicht bedrohen: mit nur 
       Gruppenrechten wird  das schlimmste, was ein Angreifer anrichten kann, das Hacken einer 
       Score-Tabelle in einem Spiel oder etwas ähnliches sein.
       Siehe auch den <code>xkobo</code> port für ein Beispiel einer solchen Änderung.

   <li>Vertraue keinen 'group-writable' Dateien.  Auch wenn sie geprüft wurden, werden 
       setgid immer noch als wichtige potentielle Sicherheitslöcher betrachtet.
       Von daher sollten Informationen, die hiervon berührt werden nicht als sensitive 
       Information betrachtet werden. 

   <li>Vertraue nicht deinem 'environment' ! Das schließt einfache Dinge wie etwa  
       deinen <code>PATH</code> ein (benutze niemals <code>system</code> mit einem 
       unqualifizierten Namen, vermeide <code>execvp</code>), es betrifft aber auch solche
       feinen Dinge wie locale, timezone, termcap, und so weiter.  
       Sei vorsichtig mit 'transitivity': Auch wenn du alle Vorsichtsmassregeln triffst,
       machen das Programme, die du aufrufst, noch lange nicht.
       Benutze <strong>niemals</strong>
        <code>system</code> in privilegierten Programmen, baue eine saubere 'command 
       line', ein kontrolliertes 'environment', und rufe <code>execve</code> direkt auf. 
       Die <code>perlsec</code> man page ist ein gutes Tutorium über solche Probleme.

   <li>Benutze niemals setuid shell-scripts. Sie sind vererbliche Sicherheitslücken.  
       Schliesse sie in C Code ein, der eine saubere 'environment' sicherstellt.
       Auf der anderen Seite gibt es unter OpenBSD auch die sicheren Perl-Skripte.

   <li>Nimm dich vor dem 'dynamic loader' in acht. Wenn du ihn mit setuid laufen lässt, wird er nur
       vertraenswürdigen Libraries trauen, die mit ldconfig gescannt wurden.
       Setgid ist nicht genug.

   <li>Dynamic libraries sind schwierig. C++ Code stellt ein ähnliches Problem dar. 
       Grundsätzlich könnten Libraries einige Dinge basierend auf deinem 'environment' 
       tun, sogar bevor dein Hauptprogramm dazu kommt seinen setuid Status zu checken.   
       OpenBSD <code>issetugid</code> kümmert sich um dieses Problem vom Standpunkt eines
       Library Autors.  Versuche nicht Libraries zu portieren, bis du diesen Punkt wirklich
       absolut verstanden hast.	 
  </ul>
  <h3><font color="#0000e0"><a name="Generic">Generische porting Hinweise</a></font></h3>
  <ul>
   <li><code>__OpenBSD__</code> sollte sparsam benutzt werden, wenn überhaupt.
       Konstruktionen, die wie
       <pre>
            #if defined(__NetBSD__) || defined(__FreeBSD__)
       </pre>
       aussehen, sind oft unpassend. Füge nicht blindlings <code>__OpenBSD__</code>
       hinzu. Versuche stattdessen herauszufinden, was vor sich geht und welches Feature 
       tatsächlich gebraucht wird. Manual pages sind oftmals hilfreich, da sie historische 
       Kommentare enthalten und darstellen, wann ein spezielles Feature in OpenBSD eingefügt
       wurde. Den numerischen Wert von <code>BSD</code> gegen bekannte Versionen/Zahlen zu 
       prüfen ist meistens der richtige Weg. Der
       <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/Packages.txt">NetBSD package guide</a>
       enthält noch weitere Informationen.
   <li><code>BSD</code> zu definieren ist eine schlechte Idee. Versuche <code>sys/param.h</code>
       einzubinden.
       Das definiert nicht nur <code>BSD</code>, sondern gibt auch einen sauberen Wert.
       Das richtige Code Fragment sollte etwa so aussehen:
       <pre>
           #if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
           #include &lt;sys/param.h&gt;
           #endif
       </pre>
   <li>Teste, ob Features vorhanden sind, und nicht nach spezifischen Betriebssystemen. Auf lange Sicht 
       ist es besser zu erfahren, ob <code>tcgetattr</code> funktioniert, als zu erfahren, ob man
       gerade auf 4.3 BSD oder später oder etwa SystemVR4 arbeitet.
       Diese Art von Test trifft einfach nicht den Punkt.
       Ein sinnvoller Weg wäre zum Beispiel auf ein bestimmtes System zu testen,
       eine Runde von  
       <code>HAVE_TCGETATTR</code> zu definieren, und dann mit dem nächsten System weiterzumachen.
       Diese Technik trennt die feature-Tests von denen auf spezielle Betriebssysteme.
       In grosser Eile kann ein anderer 'porter' das ganze set von
       <code>-DHAVE_XXX</code> Definitionen zum Makefile hinzufügen. 
       Man könnte das auch selber schreiben oder im configure-Skript testen und es dann automatisch 
       hinzufügen. Als negatives Beispiel, dem man _nicht_ folgen sollte kann der 
       nethack 3.2.2-Source dienen: er nimmt jede Menge Dinge basierend auf dem Systemtyp an.
       Die meisten dieser Annahmen sind veraltet und haben nichts mehr mit der Realität zu tun:
       POSIX sind nützlicher als alte BSD versus SystemV 
       Unterschiede, da einige traditionelle BSD-Funktionen jetzt nur noch durch
       Kompatibilitäts-Bibliotheken unterstützt werden.

   <li>Vermeide include Dateien, die andere includes enthalten, die wiederum andere... Erstens weil es
       uneffizient ist. Dein Projekt wird mit einer Datei enden, die alles andere 'included'.
       Und außerdem werden dabei Probleme erzeugt, die schwierig zu beheben sind.
       Es wird schwieriger an einem bestimmten Punkt <em>nicht</em> eine bestimmte Datei
       mit einzubinden.

   <li>Vermeide bizarre macro Tricks.  'Undefining' eines Makros, die von einem Header-File
       definiert wurde ist eine schlechte Idee. Das Definieren eines Makros um ein
       spezielles Verhalten von einer include-Datei zu bekommen, ist auch eine schlechte Idee: 
       Kompiliermodi sollten global sein. Wenn du POSIX Verhalten willst, teile es mit, 
       indem du 
       <code>#define POSIX_C_SOURCE</code> im ganzen Projekt einsetzt, nicht
       nur wenn dir danach ist.

   <li>Schreibe niemals 'system function prototypes'.  Alle modernen Systeme, 
       inklusive OpenBSD, haben einen Standardplatz für diese 'prototypes'.  
       Wahrscheinliche Plätze sind etwa <code>unistd.h</code>, <code>fcntl.h</code> oder 
       <code>termios.h</code>.
       Die man page zeigt regelmäßig wo die 'prototypes' zu finden sind.
       Du könntest noch eine Runde <code>HAVE_XXX</code> Makros benötigen um die
       richtige Datei zu beschaffen. Mach dir keine Sorgen darum ,dass du eine Datei zwei 
       Mal 'includen' könntest, include Dateien haben Aufpasser, die solchen Unfug 
       verhindern.<br>
       Falls irgendein kaputtes System von dir verlangt, den 'prototype' zu schreiben, dehne das
       nicht gleich auf alle anderen Systeme aus. 
       'Roll-your-own prototypes' werden nicht funktionieren da sie Typen benutzen könnten,
       die auf deinem Sytem funktionieren, aber eben nicht auf andere Systeme portierbar sind
       ; (<code>unsigned long</code> anstelle von 
       <code>size_t</code>) benutzen, oder einen <code>const</code> Status falsch verstehen. 
       Außerdem sind einige Compiler, so wie auch OpenBSD's gcc, 
       in der Lage bessere Arbeit mit sehr oft verwendeten Funktionen wie 
       <code>strlen</code> zu leisten, wenn man die richtigen header-Dateien einbindet.

   <li>Benutze  nicht den Namen einer Standard-System-Funktion für irgend etwas anderes.
       Wenn du deine eigene Funktion schreiben willst, gib ihr einen eigenen Namen, und 
       rufe diese Funktion überall auf.  Wenn du zur Standard-System-Funktion 
       zurückkehren willst, musst du nur deinen Code auskommentieren, und den Namen
       wieder auf die Systemfunktion zurückschreiben. Mach es nicht andersherum.
       Der Code sollte etwa so aussehen:
<pre>
       /* prototype part */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf);
       #else
       /* include correct file */
       #include &lt;stdlib.h&gt;
       /* use system function */
       #define foo_gcvt  gcvt
       #endif

       /* definition part */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf)
          {
          /* proper definition */
          }

       /* typical use */
       s = foo_gcvt(n, 15, b);
       </pre>
  </ul>
  <h3><font color="#0000e0"><a name="Other">Andere hilfreiche Hinweise</a></font></h3>
  <ul>
   <li>Neuere Versionen von <code>bsd.port.mk</code> setzen den Installer-Pfad.
       Sie sorgen insbesondere dafür, dass <code>/usr/bin</code> und
       <code>/bin</code> <em>vor</em>
       <code>/usr/local/bin</code> und <code>/usr/X11R6/bin</code> durchsucht werden.
   <li>Erzeuge <em>KEINE</em> shared libraries wenn
       <code>${NO_SHARED_LIBS}</code> auf YES gesetzt ist (Vorsicht: es kann nur nach der
       Einbindung von <code>bsd.port.mk</code> definiert werden). Wenn dein port ein
       GNU configure benutzt, füge einfach die Zeile
       <code>CONFIGURE_ARGS += ${CONFIGURE_SHARED}</code> in das Makefile ein.
   <li>Es ist in Ordnung ein erst neuerlich hinzugefügtes Feature von
       <code>bsd.port.mk</code> zwingend zu benötigen, da die Leute sowieso  
	ihren ports tree mitsamt <code>bsd.port.mk</code> updaten sollten.
       <code>NEED_VERSION</code> ist von nun an hinfällig.
   <li>Bevorzuge <code>update-plist</code>, um Paketlisten zu generieren
       und zu aktualisieren, anstatt diese Dinge per Hand zu erledigen.
       Du kannst die unerwünschten Zeilen auskommentieren.
       <code>update-plist</code> kann die meisten Dateitypen alleine erkennen
       und die meisten extra annotations korrekt kopieren.
   <li>Füge <code>USE_SYSTRACE=Yes</code> in <code>/etc/mk.conf</code> ein,
       um fehlfunktionierende Skripte, Makefiles, etc. zu entdecken.
   <li>In OpenBSD sind <code>curses.h/libcurses/libtermlib</code> die
       ``neuen curses''.  Ändere:<br>
       <code>ncurses.h ==&gt; curses.h</code><br>
       ``old (BSD) curses'' ist durch das Definieren von
       <code>_USE_OLD_CURSES_</code> verfügbar
       und zwar vor dem Einbinden von <code>curses.h</code> (für gewöhnlich 
       in einem Makefile) und dem Linken mit
       <code>-locurses</code>.
   <li>In OpenBSD wurden die Terminals von den alten BSD
       <code>sgtty</code> zur neuen POSIX <code>tcgetattr</code> Familie umgestellt.
       Vermeide den alten Stil in neuem Code. Es kann Code geben, der  
       <code>tcgetattr</code> als Synonym fiür das ältere  
       <code>sgtty</code> definiert, aber das ist auf OpenBSD höchstens eine 
       kurzfristige Methode.  
       Der <code>xterm</code> Source Code ist ein sehr gutes Beispiel, wie man es nicht
       machen sollte. Versuche deine Systemfunktionalität richtig hinzubekommen: Du
       willst ja einen Typen, der den Status deines Terminals behält 
       (möglicher typedef), du willst eine Funktion die den momentanen Status herausfindet, 
       und eine Funktion, die den neuen Status setzt.
       Funktionen, die diesen Status modifizieren sind schwieriger als es den Anschein hat, 
       da sie dazu tendieren von System zu System unterschiedlich zu sein. Vergiss auch 
       nicht, dass du Fälle behandeln musst, bei denen du gar nicht an einem 
       Terminal angeschlossen bist, und in denen du 'signals' behandeln musst: nicht
       nur das Beenden, sondern auch 
       (<code>SIGTSTP</code>) im Hintergrund. Du solltest das Terminal immer in einem 
       sauberen Zustand belassen. Mach die Tests unter einer alten Shell, wie etwa sh, 
       die das Terminal nicht gleich in allen Fällen 'resettet', nachdem das Programm
       beendet wurde.
   <li>Die neueren termcap/terminfo und curses, wie sie Teil von OpenBSD sind, 
       beinhalten Standardsequenzen für das Kontrollieren von Farb-Terminals.
       Wenn möglich benutze diese, kehre auf anderen Systemen auf die ANSI Farb-
       Sequenzen zurück. Trotzdem sind noch nicht alle Terminalbeschreibungen 
       auf dem neuesten Stand, und du musst möglicherweise in der Lage sein diese
       Sequenzen von Hand zu bearbeiten. So macht es vim. Das ist aber nicht unbedingt
       notwendig. Mit Ausnahme von privilegierten Programmen ist es generell möglich
       eine termcap Definition durch die <code>TERMCAP></code>-Variable zu übersteuern 
       und sie dadurch zu sauberem Arbeiten zu bringen.
   <li>Signal Semantiken sind schwierig, und sind von System zu System verschieden.
       Benutze <code>sigaction</code> um spezifische Semantiken zu bekommen, zusammen mit
       anderen 'System Calls' ,die in der entsprechenden manpage aufgeführt werden.
  </ul>
  <hr>
<a href="index.html"><img height="24" width="24" src="../back.gif" border="0" alt="Zurück zur OpenBSD-Hauptseite"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br><small>
<!--
Originally [OpenBSD: porting.html,v 1.52 ]
$Translation: porting.html,v 1.31 2005/02/03 14:19:16 paldium Exp $
-->
$OpenBSD: porting.html,v 1.30 2005/02/04 20:39:01 jufi Exp $
</small>
</body>
</html>
