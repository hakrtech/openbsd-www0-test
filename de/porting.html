<!DOCTYPE HTML PUBLIC  "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="de">
<meta name="resource-type" content="document">
<meta name="description" CONTENT="Wie man einen OpenBSD port erzeugt">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1997-2003 by OpenBSD.">
<title>Das Erzeugen eines OpenBSD ports</title>
<link rev="made" href="mailto:www@openbsd.org">
</head>
<body text="#000000" bgcolor="#ffffff" link="#23238e">
<a href="index.html"><img alt="[OpenBSD]" height="30" width="141" src="../images/smalltitle.gif" border="0"></a>

  <h2><font color="#e00000">Das Erzeugen eines OpenBSD ports</font></h2>

   Du hast also gerade dein Lieblingssoftwarepaket auf deiner OpenBSD-Maschine
   kompiliert und m&ouml;chtest deinen Erfolg mit anderen teilen, indem du davon
   einen Standard port machst ? Was also ist jetzt zu tun ?
  <p>
   Die wichtigste Sache, die du machen solltest, ist mit anderen zu <strong>kommunizieren</strong>.
   Frage die anderen Leute auf <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>,
   ob sie am selben port arbeiten. <em>Teile es dem urspr&uuml;nglichen Programmierer
   mit</em>, inklusive der Probleme, wenn du welche findest. Wenn die Lizenzbedingungen
   nicht korrekt sind, sag es ihm. Wenn du grosse Schwierigkeiten hattest, den port zum Laufen
   zu kriegen, teile ihm mit, was verbessert werden k&ouml;nnte. Wenn sie nur auf Linux entwickeln und den
   Rest der Unix-Welt ignorieren, versuche, ihre Sichtweise etwas zu erweitern.
  <p>
   <strong>KOMMUNIKATION</strong> macht den Unterschied zwischen einem erfolgreichen port
   und einem port, der langsam von allen alleine gelassen und nicht mehr benutzt wird aus.
  <p>
   Sieh dir zuerst die porting-Informationen auf dieser Seite an. Dann &uuml;berpr&uuml;fe all
   die gelinkten Dokumente, insbesondere die OpenBSD porting 
   <a href="../checklist.html">checklist</a>.
  <p>
   Teste, teste nochmal und schlussendlich teste nochmals !
  <p>
   Liefere den port aus (submit).  Erzeuge einen 'gzipped tarball' des port Verzeichnisses.
   Du kannst diesen entweder auf einen &ouml;ffentlichen FTP oder HTTP Server legen, und die
   Addresse an <a href="mailto:ports@openbsd.org">ports@openbsd.org</a> mailen,
   oder den port 'mime encoded' an die selbe Adresse schicken. W&auml;hle einfach eine Methode aus.
  <p>

<h3><font color="#0000e0">Index der Porting Dokumentation</font></h3>
<ul>
<li><a href="#Avail">Verf&uuml;gbare Porting Information</a></li>
<li><a href="#Policy">OpenBSD Porting Policy</a></li>
<li><a href="#Security">Sicherheitsemfpehlungen</a></li>
<li><a href="#Generic">Generische Porting Hinweise</a></li>
<li><a href="#Other">Andere hilfreiche Hinweise</a></li>
</ul>

  <h3><font color="#0000e0"><a name="Avail">Verf&uuml;gbare Porting Information</a></font></h3>
  <ul>
   <li>OpenBSD porting <a href="../checklist.html">checklist</a>.
   <li>Die man page 
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5">bsd.port.mk(5)</a>.
       Sie dokumentiert das ports Infrastruktur Makefile, das am Ende 
       jedes individuellen port Makefiles eingeschlossen wird.  
       Es gibt am Anfang noch ein paar Kommentare innerhalb der Datei selbst,
       aber die meisten der sinnvollen Informationen sind jetzt dokumentiert.
   <li>Einige Unterschiede zu den anderen BSD port Systemen, hautps&auml;chlich eine Zusammenfassung
   der <a href="../porting/de/diffs.html">Infrastruktur Unterschiede</a>.
   <li><a href="../porting/libraries.html">Das Benutzen von shared libraries
   in OpenBSD Ports</a>. Die Regeln sind <strong>sehr wichtig
   </strong> sobald du shared libraries benutzt, insbesondere sobald
   pkg_update eines Tages funktionieren wird...
   <li><a href="../audio-port.html">Das Portieren von Audio-Applikationen auf OpenBSD</a>.
   <li>Die
       <a href="http://www.netbsd.org/Documentation/software/packages.html">
       NetBSD Package System</a> Dokumentation. Dieses Dokument beschreibt die  
       NetBSD Version des FreeBSD Portsystems und ist recht hilfreich.
   <li>Das
       <a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/index.html">FreeBSD
       Porter's Handbook</a>.  Das ist die FreeBSD porting Bibel.
   <li>Die OpenBSD ports Mailingliste
       <a href="mailto:ports@openbsd.org">ports@OpenBSD.ORG</a>.
  </ul>
  <h3><font color="#0000e0"><a name="Policy">OpenBSD Porting Politik</a></font></h3>
  <ul>
   <li>OpenBSD benutzt NICHT <code>/usr/local/etc/rc.d</code>.<br>
       <code>/usr/local</code> wird dank NFS oftmals von verschiedenen Maschinen
         benutzt.  Aus diesem Grund k&ouml;nnen Konfigurationsdateien, die spezifisch
         f&uuml;r eine bestimmte Maschine sind auch nicht in <code>/usr/local</code> abgelegt werden,
         <code>/etc</code> ist die zentrale Lagerst&auml;tte f&uuml;r individuelle 
 	 Maschinen-Konfigurationsdateien.
         Au&szlig;erdem ist es OpenBSD Politik, niemals Dateien unter 
         <code>/etc</code> automatisch upzudaten. Ports, die ein spezifisches 
         Boot Setup ben&ouml;tigen, sollten den Administrator anweisen, was zu tun ist, 
	 anstatt blind Dateien zu instalieren.
   <li>OpenBSD komprimiert KEINE man pages.
   <li>OpenBSD ben&ouml;tigt KEIN <code>-lcrypt</code>.<br>
       DES ist Teil der Standard-<code>libc</code>.
   <li>OpenBSD is stark sicherheitsorientiert. Du solltest die
       <a href="#Security">Sicherheitssektion</a> auf dieser Seite lesen und verstehen.
   <li>Stelle sicher, dass der <code>&#36;OpenBSD&#36;</code> CVS tag in das
       Makefile eingef&uuml;gt wird. Wenn du einen port von einem anderen System importierst, stelle sicher,
       dass du auch ihren tag im Makefile bel&auml;sst. Trotz allem ersetze den FreeBSD 	
       <code>&#36;Id&#36;</code> tag mit dem
       <code>&#36;FreeBSD&#36;</code> tag.
   <li>Das Ziel ist, dass alle 'ported applications' OpenBSD unterst&uuml;tzen. Um dieses Ziel zu erreichen
       <strong>musst</strong> du alle OpenBSD patches auch zur&uuml;ck an den originalen
       Programmierer zur&uuml;ckliefern.
  </ul>
  <h3><font color="#0000e0"><a name="Security">Sicherheitsempfehlungen</a></font></h3>
  Es gibt viele Sicherheitsprobleme, &uuml;ber die man sich Gedanken machen muss. Wenn du nicht 
       absolut sicher bist, was du tust, frage bitte auf der 
       <a href="mailto:ports@openbsd.org">ports</a> Mailingliste um Hilfe.

  <ul>
   <li>Benutze <em>keinen</em> alpha oder beta Code wenn du einen port vorbereitest. Benutze die letzte
       regul&auml;re Version oder die letzte gepatchte.	 

   <li>Alle Software, die auf einem Server installiert werden soll, sollte auf
       buffer overflows untersucht werden, insbesondere unsichere Benutzung von 
       <code>strcat/strcpy/strcmp/sprintf</code>. Im allgemeinen sollte 
       <code>sprintf</code> durch <code>snprintf</code> ersetzt werden.

   <li>Benutze niemals Dateinamen statt echter Sicherheit. Es gibt zahlreiche 'race
       conditions'  in denen du keine saubere Kontrolle mehr hast. Ein Angreifer, der
       bereits normale Userrechte auf deiner Maschine hat, k&ouml;nnte Dateien in 
       <code>/tmp</code> mit symbolischen Links auf strategischere Dateien ersetzen, wie etwa
       <code>/etc/master.passwd</code>.  

   <li>Zum Beispiel erzeugen sowohl <code>fopen</code> als auch <code>freopen</code>
       <strong>eine neue Datei oder &ouml;ffnen eine bereits existierende</strong> zum 
       Schreiben. Ein Angreifer k&ouml;nnte einen symbolischen Link von
       <code>/etc/master.passwd</code> auf <code>/tmp/addrpool_dump</code> setzen. Sofort 
       wenn ihn &ouml;ffnest ist deine Passwortdatei verraten. Ja, sogar mit einem 
       <code>unlink</code> direkt davor. Du kannst nur das Fenster der M&ouml;glichkeiten
       enger machen.  Benutze stattdessen <code>open</code> mit
       <code>O_CREAT|O_EXCL</code> und <code>fdopen</code>.
                 
   <li>Ein weiteres sehr bekanntes Problem ist die <code>mktemp</code>
       Funktion. Beachte die Warnungen des 'bsd linker' bei ihre Benutzung.  
       <strong>Die m&uuml;ssen gefixed werden</strong>.
       Das ist nicht ganz so einfach wie <code>s/mktemp/mkstemp/g</code>.  <br>
       Sieh dir die <code>mktemp(3)</code> man page von OpenBSD current 
       f&uuml;r mehr Hinweise an.
       Korrekter Code, der <code>mkstemp</code> benutzt, schliesst den Source zu
       <code>ed</code> oder <code>mail</code> ein.
       Eine seltenes Beispiel von Code, der <code>mktemp</code> korrekt benutzt 
       kann im <code>rsync</code> port gefunden werden.

   <li>Nur weil du etwas lesen kannst heisst es nicht, dass du das solltest. Eine
       sehr bekannte L&uuml;cke dieser Art war das <code>startx</code> Problem. Als
       setuid Programm konntest du startx mit jeder Datei als Skript starten.
       Wenn die Datei kein sauberes Shell-Skript war folgte eine Fehlermeldung, 
       zusammen mit der ersten Zeile der betreffenden Datei, ohne weitere
       &Uuml;berpr&uuml;fung der Rechte.  Ziemlich einfach die
       erste Zeile der shadow passwd Datei zu erhalten, besonders wenn man bedenkt, dass
       die erste Zeile meist den root Eintrag enth&auml;lt.
       &Ouml;ffne nicht deine Datei um dann ein
       <code>fstat</code> auf den 'open descriptor' zu machen, um zu &uuml;berpr&uuml;fen 
       ob du sie h&auml;ttest &ouml;ffnen k&ouml;nnen m&uuml;ssen (oder der Angreifer wird
       mit /dev/rst0 spielen und dein Band zur&uuml;ckspulen) -- &ouml;ffne es mit korrekt 
       gesetzter uid/gid/grouplist.

   <li>Tue nichts, was eine Shell im Hintergrund von setuid Programmen forkt bevor du  
       deine Rechte zur&uuml;cksetzt. Das schliesst
       <code>popen</code> und 
       <code>system</code> ein.  
       Benutze stattdessen <code>fork</code>, <code>pipe</code> und <code>execve</code>.

   <li>
       Gib' offene 'descriptors' anstatt von Dateiname an andere Programme weiter, um race
       conditions zu vermeiden. Sogar wenn ein Programm keine 'file descriptors'
       akzeptiert, kannst du immer noch <code>/dev/fd/0</code> benutzen.

   <li>Zugriffsrechte sind an 'file descriptors' gebunden. Wenn du setuid Rechte setzen musst,
       um eine Datei zu &ouml;ffnen, &ouml;ffne die Datei, dann lass deine Rechte fallen. Du kannst nach
       wie vor auf den 'open descriptor' zugreifen, aber du musst dir um ihn weniger Dinge Sorgen machen. Das hat aber
       zwei Seiten: auch nachdem du die Rechte fallenlassen hast, solltest du noch auf die 'descriptors'
       aufpassen.

   <li>Vermeide root setuid wo du nur kannst. Grunds&auml;tzlich kann root alles tun,
       aber root Rechte werden nur sehr selten wirklich ben&ouml;tigt, vielleicht mit Ausnahme
       vom Erzeugen von Sockets mit einer Nummer kleiner 1024. Es ist beutend besser, dass 
       <code>inetd</code> zu &uuml;berlassen und nur die relevanten Eintr&auml;ge in 
       <code>inetd.conf</code> zu machen.  
       Du musst nat&uuml;rlich die erforderliche Magie zum Schreiben von daemons kennen, um das
       zu erreichen.
       Man k&ouml;nnte sagen, dass du keinerlei Chancen hast, ein gutes setuid Programm zu schreiben,
       wenn du nicht weisst, wie man das macht.

   <li>Benutze setgid anstelle von setuid. Abgesehen von diesen spezifischen Dateien, die von
       setgid Programmen ben&ouml;tigt werden, sind die meisten Dateien nicht 'group-writable'. Daher 
       werden Sicherheitsprobleme in einem 'setgid' Programm dein System nicht bedrohen: mit nur 
       Gruppenrechten wird  das schlimmste, was ein Angreifer anrichten kann, das Hacken einer 
       Score-Tabelle in einem Spiel oder etwas &auml;hnliches sein.
       Siehe auch den <code>xkobo</code> port f&uuml;r ein Beispiel einer solchen &Auml;nderung.

   <li>Vertraue keinen 'group-writable' Dateien.  Auch wenn sie gepr&uuml;ft wurden, werden 
       setgid immer noch als wichtige potentielle Sicherheitsl&ouml;cher betrachtet.
       Von daher sollten Informationen, die hiervon ber&uuml;hrt werden nicht als sensitive 
       Information betrachtet werden. 

   <li>Vertraue nicht deinem 'environment' ! Das schliesst einfache Dinge wie etwa  
       deinen <code>PATH</code> ein (benutze niemals <code>system</code> mit einem 
       unqualifizierten Namen, vermeide <code>execvp</code>), es betrifft aber auch solche
       feinen Dinge wie locale, timezone, termcap, und so weiter.  
       Sei vorsichtig mit 'transitivity': Auch wenn du alle Vorsichtsmassregeln triffst,
       machen das Programme, die du aufrufst, noch lange nicht.
       Benutze <strong>niemals</strong>
        <code>system</code> in privilegierten Programmen, baue eine saubere 'command 
       line', ein kontrolliertes 'environment', und rufe <code>execve</code> direkt auf. 
       Die <code>perlsec</code> man page ist ein gutes Tutorium &uuml;ber solche Probleme.

   <li>Benutze niemals setuid shell-scripts. Sie sind vererbliche Sicherheitsl&uuml;cken.  
       Schliesse sie in C Code ein, der eine saubere 'environment' sicherstellt.
       Auf der anderen Seite gibt es unter OpenBSD auch die sicheren Perl-Skripte.

   <li>Nimm dich vor dem 'dynamic loader' in acht. Wenn du ihn mit setuid laufen l&auml;sst, wird er nur
       vertraensw&uuml;rdigen Libraries trauen, die mit ldconfig gescannt wurden.
       Setgid ist nicht genug.

   <li>Dynamic libraries sind schwierig. C++ Code stellt ein &auml;hnliches Problem dar. 
       Grunds&auml;tzlich k&ouml;nnten Libraries einige Dinge basierend auf deinem 'environment' 
       tun, sogar bevor dein Hauptprogramm dazu kommt seinen setuid Status zu checken.   
       OpenBSD <code>issetugid</code> k&uuml;mmert sich um dieses Problem vom Standpunkt eines
       Library Autors.  Versuche nicht Libraries zu portieren, bis du diesen Punkt wirklich
       absolut verstanden hast.	 
  </ul>
  <h3><font color="#0000e0"><a name="Generic">Generische porting Hinweise</a></font></h3>
  <ul>
   <li><code>__OpenBSD__</code> sollte sparsam benutzt werden, wenn &uuml;berhaupt.
       Konstruktionen, die wie
       <pre>
            #if defined(__NetBSD__) || defined(__FreeBSD__)
       </pre>
       aussehen, sind oft unpassend. F&uuml;ge nicht blindlings <code>__OpenBSD__</code>
       hinzu. Versuche stattdessen herauszufinden, was vor sich geht und welches Feature 
       tats&auml;chlich gebraucht wird. Manual pages sind oftmals hilfreich, da sie historische 
       Kommentare enthalten und darstellen, wann ein spezielles Feature in OpenBSD eingef&uuml;gt
       wurde. Den numerischen Wert von <code>BSD</code> gegen bekannte Versionen/Zahlen zu 
       pr&uuml;fen ist meistens der richtige Weg. Der
       <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/Packages.txt">NetBSD package guide</a>
       enth&auml;lt noch weitere Informationen.
   <li><code>BSD</code> zu definieren ist eine schlechte Idee. Versuche <code>sys/param.h</code>
       einzubinden.
       Das definiert nicht nur <code>BSD</code>, sondern gibt auch einen sauberen Wert.
       Das richtige Code Fragment sollte etwa so aussehen:
       <pre>
           #if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
           #include &lt;sys/param.h&gt;
           #endif
       </pre>
   <li>Teste, ob Features vorhanden sind, und nicht nach spezifischen Betriebssystemen. Auf lange Sicht 
       ist es besser zu erfahren, ob <code>tcgetattr</code> funktioniert, als zu erfahren, ob man
       gerade auf 4.3 BSD oder sp&auml;ter oder etwa SystemVR4 arbeitet.
       Diese Art von Test trifft einfach nicht den Punkt.
       Ein sinnvoller Weg w&auml;re zum Beispiel auf ein bestimmtes System zu testen,
       eine Runde von  
       <code>HAVE_TCGETATTR</code> zu definieren, und dann mit dem n&auml;chsten System weiterzumachen.
       Diese Technik trennt die feature-Tests von denen auf spezielle Betriebssysteme.
       In grosser Eile kann ein anderer 'porter' das ganze set von
       <code>-DHAVE_XXX</code> Definitionen zum Makefile hinzuf&uuml;gen. 
       Man k&ouml;nnte das auch selber schreiben oder im configure-Skript testen und es dann automatisch 
       hinzuf&uuml;gen. Als negatives Beispiel, dem man _nicht_ folgen sollte kann der 
       nethack 3.2.2-Source dienen: er nimmt jede Menge Dinge basierend auf dem Systemtyp an.
       Die meisten dieser Annahmen sind veraltet und haben nichts mehr mit der Realit&auml;t zu tun:
       POSIX sind n&uuml;tzlicher als alte BSD versus SystemV 
       Unterschiede, da einige traditionelle BSD-Funktionen jetzt nur noch durch
       Kompatibilit&auml;ts-Bibliotheken unterst&uuml;tzt werden.

   <li>Vermeide include Dateien, die andere includes enthalten, die wiederum andere... Erstens weil es
       uneffizient ist. Dein Projekt wird mit einer Datei enden, die alles andere 'included'.
       Und ausserdem werden dabei Probleme erzeugt, die schwierig zu beheben sind.
       Es wird schwieriger an einem bestimmten Punkt <em>nicht</em> eine bestimmte Datei
       mit einzubinden.

   <li>Vermeide bizarre macro Tricks.  'Undefining' eines Makros, die von einem Header-File
       definiert wurde ist eine schlechte Idee. Das Definieren eines Makros um ein
       spezielles Verhalten von einer include-Datei zu bekommen, ist auch eine schlechte Idee: 
       Kompiliermodi sollten global sein. Wenn du POSIX Verhalten willst, teile es mit, 
       indem du 
       <code>#define POSIX_C_SOURCE</code> im ganzen Projekt einsetzt, nicht
       nur wenn dir danach ist.

   <li>Schreibe niemals 'system function prototypes'.  Alle modernen Systeme, 
       inklusive OpenBSD, haben einen Standardplatz f&uuml;r diese 'prototypes'.  
       Wahrscheinliche Pl&auml;tze sind etwa <code>unistd.h</code>, <code>fcntl.h</code> oder 
       <code>termios.h</code>.
       Die man page zeigt regelm&auml;ssig wo die 'prototypes' zu finden sind.
       Du k&ouml;nntest noch eine Runde <code>HAVE_XXX</code> Makros ben&ouml;tigen um die
       richtige Datei zu beschaffen. Mach dir keine Sorgen darum ,dass du eine Datei zwei 
       Mal 'includen' k&ouml;nntest, include Dateien haben Aufpasser, die solchen Unfug 
       verhindern.<br>
       Falls irgendein kaputtes System von dir verlangt, den 'prototype' zu schreiben, dehne das
       nicht gleich auf alle anderen Systeme aus. 
       'Roll-your-own prototypes' werden nicht funktionieren da sie Typen benutzen k&ouml;nnten,
       die auf deinem Sytem funktionieren, aber eben nicht auf andere Systeme portierbar sind
       ; (<code>unsigned long</code> anstelle von 
       <code>size_t</code>) benutzen, oder einen <code>const</code> Status falsch verstehen. 
       Ausserdem sind einige Compiler, so wie auch OpenBSD's gcc, 
       in der Lage bessere Arbeit mit sehr oft verwendeten Funktionen wie 
       <code>strlen</code> zu leisten, wenn man die richtigen header-Dateien einbindet.

   <li>Benutze  nicht den Namen einer Standard-System-Funktion f&uuml;r irgend etwas anderes.
       Wenn du deine eigene Funktion schreiben willst, gib ihr einen eigenen Namen, und 
       rufe diese Funktion &uuml;berall auf.  Wenn du zur Standard-System-Funktion 
       zur&uuml;ckkehren willst, musst du nur deinen Code auskommentieren, und den Namen
       wieder auf die Systemfunktion zur&uuml;ckschreiben. Mach es nicht andersherum.
       Der Code sollte etwa so aussehen:
<pre>
       /* prototype part */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf);
       #else
       /* include correct file */
       #include &lt;stdlib.h&gt;
       /* use system function */
       #define foo_gcvt  gcvt
       #endif

       /* definition part */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf)
          {
          /* proper definition */
          }

       /* typical use */
       s = foo_gcvt(n, 15, b);
       </pre>
  </ul>
  <h3><font color="#0000e0"><a name="Other">Andere hilfreiche Hinweise</a></font></h3>
  <ul>
   <li>Neuere Versionen von <code>bsd.port.mk</code> setzen den Installer-Pfad.
       Sie sorgen insbesondere daf&uuml;r, dass <code>/usr/bin</code> und
       <code>/bin</code> <em>vor</em>
       <code>/usr/local/bin</code> und <code>/usr/X11R6/bin</code> durchsucht werden.
   <li>Erzeuge <em>KEINE</em> shared libraries wenn
       <code>${NO_SHARED_LIBS}</code>  definiert ist (Vorsicht: es kann nur nach der 
       Einbindung von <code>bsd.port.mk</code> definiert werden). Wenn dein port ein
       GNU configure benutzt, f&uuml;ge einfach die Zeile
       <code>CONFIGURE_ARGS += ${CONFIGURE_SHARED}</code> in das Makefile ein.
   <li>Es ist in Ordnung ein erst neuerlich hinzugef&uuml;gtes Feature von
       <code>bsd.port.mk</code> zwingend zu ben&ouml;tigen, da die Leute sowieso  
	ihren ports tree mitsamt <code>bsd.port.mk</code> updaten sollten.
       <code>NEED_VERSION</code> ist von nun an hinf&auml;llig.
   <li>In OpenBSD sind <code>curses.h/libcurses/libtermlib</code> die
       ``neuen curses''.  &Auml;ndere:<br>
       <code>ncurses.h ==&gt; curses.h</code><br>
       ``old (BSD) curses'' ist durch das Definieren von
       <code>_USE_OLD_CURSES_</code> verf&uuml;gbar
       und zwar vor dem Einbinden von <code>curses.h</code> (f&uuml;r gew&ouml;hnlich 
       in einem Makefile) und dem Linken mit
       <code>-locurses</code>.
   <li>In OpenBSD wurden die Terminals von den alten BSD
       <code>sgtty</code> zur neuen POSIX <code>tcgetattr</code> Familie umgestellt.
       Vermeide den alten Stil in neuem Code. Es kann Code geben, der  
       <code>tcgetattr</code> als Synonym fi&uuml;r das &auml;ltere  
       <code>sgtty</code> definiert, aber das ist auf OpenBSD h&ouml;chstens eine 
       kurzfristige Methode.  
       Der <code>xterm</code> Source Code ist ein sehr gutes Beispiel, wie man es nicht
       machen sollte. Versuche deine Systemfunktionalit&auml;t richtig hinzubekommen: Du
       willst ja einen Typen, der den Status deines Terminals beh&auml;lt 
       (m&ouml;glicher typedef), du willst eine Funktion die den momentanen Status herausfindet, 
       und eine Funktion, die den neuen Status setzt.
       Funktionen, die diesen Status modifizieren sind schwieriger als es den Anschein hat, 
       da sie dazu tendieren von System zu System unterschiedlich zu sein. Vergiss auch 
       nicht, dass du F&auml;lle behandeln musst, bei denen du gar nicht an einem 
       Terminal angeschlossen bist, und in denen du 'signals' behandeln musst: nicht
       nur das Beenden, sondern auch 
       (<code>SIGTSTP</code>) im Hintergrund. Du solltest das Terminal immer in einem 
       sauberen Zustand belassen. Mach die Tests unter einer alten Shell, wie etwa sh, 
       die das Terminal nicht gleich in allen F&auml;llen 'resettet', nachdem das Programm
       beendet wurde.
   <li>Die neueren termcap/terminfo und curses, wie sie Teil von OpenBSD sind, 
       beinhalten Standardsequenzen f&uuml;r das Kontrollieren von Farb-Terminals.
       Wenn m&ouml;glich benutze diese, kehre auf anderen Systemen auf die ANSI Farb-
       Sequenzen zur&uuml;ck. Trotzdem sind noch nicht alle Terminalbeschreibungen 
       auf dem neuesten Stand, und du musst m&ouml;glicherweise in der Lage sein diese
       Sequenzen von Hand zu bearbeiten. So macht es vim. Das ist aber nicht unbedingt
       notwendig. Mit Ausnahme von privilegierten Programmen ist es generell m&ouml;glich
       eine termcap Definition durch die <code>TERMCAP></code>-Variable zu &uuml;bersteuern 
       und sie dadurch zu sauberem Arbeiten zu bringen.
   <li>Signal Semantiken sind schwierig, und sind von System zu System verschieden.
       Benutze <code>sigaction</code> um spezifische Semantiken zu bekommen, zusammen mit
       anderen 'System Calls' ,die in der entsprechenden manpage aufgef&uuml;hrt werden.
  </ul>
  <hr>
<a href="index.html"><img height="24" width="24" src="../back.gif" border="0" alt="Zur&uuml;ck zur OpenBSD-Hauptseite"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<small>
<br>
Originally [OpenBSD: porting.html,v 1.45 ]
<br>
$Translation: porting.html,v 1.20 2003/04/15 17:37:58 jufi Exp $
</small>
<br><small>$OpenBSD: porting.html,v 1.20 2003/04/15 17:43:35 jufi Exp $</small>
</body>
</html>
