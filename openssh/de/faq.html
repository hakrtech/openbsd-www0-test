<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Häufig gestellte Fragen zu OpenSSH</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name= "description"   content= "the OpenSSH FAQ page">
<meta name= "keywords"      content= "OpenSSH,SSH,Secure Shell,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1999-2005 OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">
<a href="index.html"><img alt="[OpenSSH]" height="30" width="141" src="../images/smalltitle.gif" border="0"></a>
<p>

<h1>OpenSSH-FAQ (Häufig gestellte Fragen)</h1>

<strong>Datum: 20.09.2005</strong>

<hr>

<blockquote>
<h3><a href= "#1.0">1.0 - Was ist OpenSSH und wo kann ich sie
    bekommen?</a></h3>
<ul>
<li><a href= "#1.1">1.1 - Was ist OpenSSH und wo kann ich sie
    herunterladen?</a>
<li><a href= "#1.2">1.2 - Warum sollte sie eingesetzt werden?</a>
<li><a href= "#1.3">1.3 - Welche Betriebssysteme werden unterstützt?</a>
<li><a href= "#1.4">1.4 - Was ist mit Copyrights, Benutzung und
    Patenten?</a>
<li><a href= "#1.5">1.5 - Wo sollte ich um Hilfe fragen?</a>
<li><a href= "#1.6">1.6 - Ich habe einen Fehler gefunden. Wo melde ich
    ihn?</a>
</ul>

<h3><a href= "#2.0">2.0 - Allgemeine Fragen</a></h3>
<ul>
<li><a href= "#2.1">2.1 - Warum benutzt ssh/scp Verbindungen auf den unteren Ports? Meine Firewall blockiert diese.</a>
<li><a href= "#2.2">2.2 - Warum ist der ssh-Client setuid root?</a>
<li><a href= "#2.3">2.3 - Warum hat SSH 2.3 Probleme beim Interoperieren mit OpenSSH 2.1.1?</a>
<li><a href= "#2.4">2.4 - Warum gibt OpenSSH Folgendes aus: Dispatch protocol error: type 20</a>
<li><a href= "#2.5">2.5 - Alte Versionen des kommerziellen SSH verschlüsseln Hostkeys mit IDEA.</a>
<li><a href= "#2.6">2.6 - Was sind das für Warnmeldungen über Schlüssellängen?</a>
<li><a href= "#2.7">2.7 - X11- und/oder Agent-Weiterleitung funktioniert nicht.</a>
<li><a href= "#2.8">2.8 - Nach dem Upgrade auf OpenSSH habe ich keine SSH2-Unterstützung mehr.</a>
<li><a href= "#2.9">2.9 - sftp/scp kann keine Verbindung aufbauen, obwohl ssh funktioniert.</a>
<li><a href= "#2.10">2.10 - Werdet ihr [foo] zu scp hinzufügen?</a>
<li><a href= "#2.11">2.11 - Wie verwende ich Portweiterleitung?</a>
<li><a href= "#2.12">2.12 - Meine ssh-Verbindung friert ein oder steigt nach N Minuten Inaktivität aus.</a>
<li><a href= "#2.13">2.13 - Wie rufe ich scp auf, um eine Datei zu kopieren, die einen Doppelpunkt beinhaltet?</a>
<li><a href= "#2.14">2.14 - Warum teilt OpenSSH seine Version den Clients mit?</a>
</ul>

<h3><a href= "#3.0">3.0 - Fragen zum portablen OpenSSH</a></h3>
<ul>
<li><a href= "#3.1">3.1 - Unechte PAM-Authentifikationsmeldungen in den Logdateien.</a>
<li><a href= "#3.2">3.2 - Leere Passwörter sind bei der PAM-Authentifikation nicht erlaubt.</a>
<li><a href= "#3.3">3.3 - ssh(1) benötigt sehr lange zum Verbinden oder zum Einloggen</a>
<li><a href= "#3.4">3.4 - »Can't locate module net-pf-10«-Meldungen im Log unter Linux.</a>
<li><a href= "#3.5">3.5 - Passwortauthentifikation funktioniert nicht (z.&nbsp;B. unter Slackware 7.0 oder Red Hat 6.x)</a>
<li><a href= "#3.6">3.6 - Configure oder sshd(8) beschweren sich über fehlende RSA-Unterstützung</a>
<li><a href= "#3.7">3.7 - »scp: command not found«-Fehler</a>
<li><a href= "#3.8">3.8 - Kann die Passphrase nicht lesen</a>
<li><a href= "#3.9">3.9 - configure fehlt oder make versagt</a>
<li><a href= "#3.10">3.10 - Hängt beim Verlassen von ssh</a>
<li><a href= "#3.11">3.11 - Wieso hängt ssh beim Beenden?</a>
<li><a href= "#3.12">3.12 - Ich habe ein Upgrade auf OpenSSH 3.1 durchgeführt und dann ging die X11-Weiterleitung nicht mehr.</a>
<li><a href= "#3.13">3.13 - Ich habe ein Upgrade auf OpenSSH 3.8 durchgeführt und dann gingen einige X11-Programme nicht mehr.</a>
<li><a href= "#3.14">3.14 - Ich habe meinen öffentlichen Schlüssel in authorized_keys kopiert, aber Publickey-Authentifizierung funktioniert immer noch nicht.</a>
<li><a href= "#3.15">3.15 - OpenSSH-Versionen und das Verhalten von PAM.</a>
<li><a href= "#3.16">3.16 - Warum zeigen weder »w« noch »who« unter AIX 5.x Benutzer an, die über ssh eingeloggt sind?</a>
</ul>

</blockquote>

<hr>

<h2><u><a name= "1.0">1.0 - Was ist OpenSSH und wo kann ich sie bekommen?</a></u></h2>

<h2><a name= "1.1">1.1 - Was ist OpenSSH und wo kann ich sie herunterladen?</a></h2>

<p>
OpenSSH ist eine <b>FREIE</b> Version der SSH-Suite von
Netzwerkverbindungs-Tools, auf die sich eine steigende Anzahl
Personen im Internet verlassen. Viele Benutzer von telnet,
rlogin, ftp und anderen solchen Programmen haben noch nicht
realisiert, dass ihr Passwort unverschlüsselt über
das Internet übertragen wird, aber so ist es. OpenSSH
verschlüsselt den gesamten Verkehr (inklusive Passwörtern),
um Mithören (eavesdropping), ,Entführen von Verbindungen'
(connection hijacking) und andere Angriffe auf Netzwerkebene
effektiv zu eliminieren.

<p>
Die OpenSSH-Suite beinhaltet das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>-Programm,
das rlogin und telnet ersetzt, und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a>,
das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rcp&amp;sektion=1">rcp(1)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
ersetzt. OpenSSH beinhaltet auch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp&amp;sektion=1">sftp(1)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp-server&amp;sektion=8">sftp-server(8)</a>,
die eine einfache Lösung für Dateiübertragungen realisieren.
Sie basieren auf dem
<a href="../txt/draft-ietf-secsh-filexfer-02.txt">secsh-filexfer</a>-IETF-Entwurf.


<p><strong>OpenSSH besteht aus mehreren Programmen.</strong>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a> - Serverprogramm, das auf der Servermaschine läuft. Es lauscht, ob es Verbindungswünsche von Clientmaschinen gibt und führt dann eine Authentifikation durch, bevor es den Client bedient.
Das Verhalten wird von der Konfigurationsdatei <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd_config&amp;sektion=5">
sshd_config(5)</a></i> verwaltet.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a> - Dies ist das Clientprogramm, das benutzt wird, um sich auf einer anderen Maschine einzuloggen oder dort Kommandos auszuführen. <i>slogin</i> ist ein weiterer Name für dieses Programm.
Das Verhalten wird von der systemweiten Konfigurationsdatei <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh_config&amp;sektion=5">
ssh_config(5)</a></i> und den benutzerspezifischen
<i>$HOME/.ssh/config</i>-Dateien verwaltet.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a> - Kopiert Dateien sicher von einer Maschine zur anderen.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a> - Wird benutzt, um ,Pubkey'-Authentifikations-Schlüssel (RSA oder DSA) zu erzeugen (Hostschlüssel und Benutzer-Authentifikationsschlüssel).
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-agent&amp;sektion=1">ssh-agent(1)</a> - Authentifikationsagent.  Er kann benutzt werden, um RSA-Schlüssel für die Authentifikation bereitzuhalten.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-add&amp;sektion=1">ssh-add(1)</a> - Wird benutzt, um neue Schlüssel beim Agenten zu registrieren.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp-server&amp;sektion=8">sftp-server(8)</a> - SFTP-Server-Subsystem.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp&amp;sektion=1">sftp(1)</a> - Sicheres Dateiübertragungsprogramm.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keyscan&amp;sektion=1">ssh-keyscan(1)</a> - Sammelt ssh-Publickeys ein.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keysign&amp;sektion=8">ssh-keysign(8)</a> - ssh Hilfsprogramm für hostbasierte Authentifikation.
</ul>

<h3>Herunterladen</h3>

<p>
OpenSSH erscheint in zwei herunterladbaren Distributionen: der nativen
<a href="openbsd.html">OpenBSD</a>-Distribution und der Multiplattform
<a href="portable.html">Portable</a> Distribution. Wenn du OpenSSH für
eine aktuelle Version von OpenBSD oder zur Integration in ein Projekt
benötigst, möchtest du vermutlich die
<a href="openbsd.html">OpenBSD</a>-Distribution. Falls du OpenSSH für
eine andere Plattform oder für eine ältere OpenBSD-Version
benötigst, möchtest du vermutlich die
<a href="portable.html">Portable</a>-Distribution.

<p>
Wenn du herunterlädst, verwende bitte einen
<a href="portable.html#mirrors">Mirror</a> in deiner Nähe.

<h2><a name= "1.2">1.2 - Warum sollte sie eingesetzt werden?</a></h2>

<p>
OpenSSH ist eine Sammlung von Werkzeugen, die dir hilft, deine
Netzwerkverbindungen sicherer zu machen. Hier ist eine Liste der
Funktionalitäten:


<ul>
	<li>Starke Authentifikation.  Schließt verschiedene Sicherheitslöcher (z.&nbsp;B. IP-, ,routing'-, und DNS-,spoofing').
	<li>Verbesserte Privatsphäre.  Alle Verbindungen werden automatisch und transparent verschlüsselt.
	<li>Sichere X11-Sitzungen.  Das Programm setzt DISPLAY auf der Servermaschine automatisch und leitet alle X11-Verbindungen über den sicheren Kanal weiter.
	<li>Willkürliche TCP/IP-Ports können durch den verschlüsselten Kanal in beide Richtungen gelenkt werden (z.&nbsp;B. für e-cash-Transaktionen).
	<li>Für normale Benutzer wird keine Schulung und kein Training benötigt.
	<li>Vertraut nie dem Netzwerk. Minimales Vertrauen auf der Gegenseite der Verbindung. Minimales Vertrauen gegenüber den Domain Name Servern. Pure RSA-Authentifikation vertraut nichts und niemandem, bis auf den ,private key'.
	<li>Der Client authentifiziert die Servermaschine am Beginn jeder Verbindung mit RSA, um ,trojanischen Pferden' (durch ,routing'- oder DNS-,spoofing') und ,man-in-the-middle'-Angriffen vorzubeugen, und der Server tut das Gleiche mit der Clientmaschine bevor er <i>.rhosts</i>- oder <i>/etc/hosts.equiv</i>-Authentifikation erlaubt (um DNS-, ,routing'- oder IP-,spoofing' vorzubeugen).
	<li>Die ,host authentication key'-Distribution kann zentral laufen, wird jedoch automatisch, sobald die erste Verbindung zur Maschine geöffnet wird.
	<li>Jeder Benutzer kann beliebig viele RSA-Authentifikationsschlüssel zur eigenen Verwendung erzeugen.
	<li>Das Serverprogramm hat seinen eigenen RSA-Schlüssel, der jede Stunde automatisch neu erzeugt wird.
	<li>Ein Authentifikationsagent, der auf dem Laptop oder der Workstation des Benutzers läuft, kann benutzt werden, um die RSA-Authentifikationsschlüssel des Anwenders zu halten.
	<li>Die Software kann auch ohne root-Privilegien installiert und benutzt werden (mit eingeschränkter Funktionalität).
	<li>Der Client ist in systemweiten und benutzerspezifischen Konfigurationsdateien anpassbar.
	<li>Optionale Kompression aller Daten mittels gzip (inklusive ,forwarded X11'- und TCP/IP-Daten), was zu bedeutenden Beschleunigungen auf langsamen Verbindungen führen kann.
	<li>Kompletter Ersatz für rlogin, rsh und rcp.
</ul>

<p>
Zurzeit werden fast alle Übertragungen in Computernetzwerken
unverschlüsselt durchgeführt. Als Konsequenz kann jeder, der
Zugriff auf irgendeine Maschine in diesem Netzwerk hat, alle Verbindungen
abhören. Das wird auch von Hackern, neugierigen Administratoren,
Arbeitgebern, Kriminellen, Industriespionen und Regierungen so
durchgeführt.
Einige Netzwerke senden derartig viel elektromagnetische Strahlung ab,
dass Daten sogar in großer Entfernung noch aufgefangen werden
können.


<p>
Wenn du dich einloggst, wird dein Passwort im Klartext übertragen.
Daher kann dann jeder Lauscher deinen Account zu jeglicher Tat benutzen.
Es gibt weltweit viele Zeugnisse dafür, dass Cracker auf dem Rechner
eines Opfers unbemerkt ein Programm gestartet haben, welches ohne Wissen des
Anwenders einfach nur das Netzwerk belauscht und Passwörter gesammelt
hat. Programme, die das tun, gibt es im Internet oder können von einem
kompetenten Programmierer innerhalb weniger Stunden selbst geschrieben
werden.


<p>
Firmen haben Geschäftsgeheimnisse, Patentanträge in Vorbereitung,
Preisinformationen, Informationen über Vertragspartner, Kundendaten,
Personendaten, Finanzdaten etc. Zurzeit kann jeder mit Zugriff auf das
Netzwerk (jede Maschine im Netzwerk) alles belauschen, was im Netzwerk
vor sich geht, und das noch ohne die normalen Zugriffsbeschränkungen.


<p>
Vielen Firmen ist nicht bewusst, dass Informationen so einfach aus ihrem
Netzwerk gesammelt werden können. Sie vertrauen darin, dass ihre
Daten sicher sind, da niemand wissen kann, dass dort vertrauliche
Informationen kursieren, oder auch, weil dort so viele andere Daten
übertragen werden. Dies ist keine sichere Einstellung.


<h2><a name= "1.3">1.3 - Welche Betriebssysteme werden unterstützt?</a></h2>

<p>
Obwohl OpenSSH unter <a href="http://www.openbsd.org/">OpenBSD</a> entwickelt
wird, gibt es eine breite Palette an Portierungen auf andere Betriebssysteme.
Die portable Version von OpenSSH wird von
<a href="mailto:djm@openbsd.org">Damien Miller</a> geleitet. Einen
schnellen Überblick über die portable Version von OpenSSH gibt
dir <a href="portable.html">http://www.openssh.com/portable.html</a>.
Betriebssysteme, die zurzeit unterstützt werden, sind:


<ul>
	<li>OpenBSD
	<li>NetBSD
	<li>FreeBSD
	<li>AIX
	<li>HP-UX
	<li>IRIX
	<li>Linux
	<li>NeXT
	<li>SCO
	<li>SNI/Reliant Unix
	<li>Solaris
	<li>Digital Unix/Tru64/OSF
	<li>Mac OS X
	<li>Cygwin
</ul>

<p>
Eine Liste der Anbieter, die OpenSSH in ihre Distributionen einbinden,
befindet sich auf der <a href="users.html">OpenSSH-Benutzerseite</a>.

<h2><a name= "1.4">1.4 - Was ist mit Copyrights, Benutzung und Patenten?</a></h2>
<p>
Die OpenSSH Entwickler haben sehr hart versucht, OpenSSH frei
von Patent- oder Copyrightproblemen zu halten. Dazu mussten einige
Optionen aus OpenSSH entfernt werden. Nämlich die Unterstützung
für patentierte Algorithmen.

<p>
OpenSSH unterstützt keinerlei patentierte Transportalgorithmen.
Im SSH1-Modus sind nur 3DES und Blowfish möglich.
Im SSH2-Modus können nur 3DES, Blowfish, CAST128, Arcfour und AES
ausgewählt werden. Der patentierte IDEA-Algorithmus wird nicht
unterstützt.

<p>
OpenSSH bietet Unterstützung für sowohl das SSH1- als auch das
SSH2-Protokoll.

<p>
Seit das RSA-Patent ausgelaufen ist, gibt es keinerlei Beschränkungen
mehr für Software, die den RSA-Algorithmus benutzen, inklusive OpenBSD.

<h2><a name= "1.5">1.5 - Wo sollte ich um Hilfe fragen?</a></h2>
<p>
Es gibt mehrere Stellen, die du um Hilfe bitten kannst. Zusätzlich
zur <a href="index.html">OpenSSH-Webseite</a> gibt es
mehrere Mailinglisten, in denen du dein Glück versuchen kannst.
Bevor du das tust, durchsuche bitte alle Mailinglisten-Archive um
zu sehen, ob deine Frage vielleicht schon beantwortet wurde. Die
OpenSSH-Mailingliste wurde archiviert und steht in durchsuchbarer Form unter
<a href="http://marc.info/?l=openssh-unix-dev&amp;r=1&amp;w=2">marc.info</a>.
zur Verfügung.

<p>
Mehr Informationen über das Abonnieren von OpenSSH-bezogenen
Mailinglisten gibt es unter
<a href="list.html">OpenSSH-Mailinglisten</a>.

<h2><a name= "1.6">1.6 - Ich habe einen Fehler gefunden. Wo melde ich
    ihn?</a></h2>
<p>
Informationen zum Senden von Fehlermeldungen können auf der OpenSSH
<a href="report.html">,Fehler melden'</a>-Seite gefunden werden.
<p>
Wenn du eine Sicherheitslücke melden möchtest, kontaktiere bitte die
private Liste »<a href="mailto:openssh@openssh.com"
>openssh@openssh.com</a>«.

<h2><u><a name= "2.0">2.0 - Allgemeine Fragen</a></u></h2>

<h2><a name= "2.1">2.1 - Warum benutzt ssh/scp Verbindungen auf den unteren Ports?</a></h2>
<p>
Der OpenSSH-Client benutzt die unteren Ports für rhosts- und
rhosts-rsa-Authentifikation, da der Server dem Benutzernamen vertrauen muss,
den der Client liefert. Um das zu umgehen, kannst du das Beispiel weiter unten
in deine <i>ssh_config</i>- oder <i>~/.ssh/config</i>-Datei kopieren.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>UsePrivilegedPort no</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Oder du kannst diese Option auf der Kommandozeile angeben, indem du die
Option <b>-o</b> des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>-Kommandos
benutzt.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>ssh -o "UsePrivilegedPort no" host.com</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.2">2.2 - Warum ist der ssh-Client setuid root?</a></h2>

<p>
In Verbindung mit der vorhergehenden Frage (<a href="#2.1">2.1</a>)
braucht OpenSSH root-Autorität, um sich an die unteren und privilegierten
Ports binden zu können, um dann eine <i>rhosts-Authentifikation</i>
durchzuführen. Genauso notwendig ist dieser privilegierte Port
für rhosts-rsa-Authentifikation zu älteren SSH-Versionen.

<p>
Zusätzlich gilt sowohl für <i>rhosts-rsa-Authentifikation</i>
(in Protokollversion 1) als auch für <i>hostbasierte Authentifikation</i>
(in Protokollversion 2), dass der ssh-Client Zugang zum
,<i>private host key</i>' braucht, um die Clientmaschine am Server
anzumelden.
OpenSSH-Versionen vor 3.3 benötigten das <code>ssh</code>-Binary
mit gesetztem setuid-Bit, um das zu erreichen, aber du kannst das Bit
löschen, wenn du diese Authentifizierungsmethoden nicht
benutzen willst.

<p>
Beginnend mit OpenSSH 3.3 ist <code>ssh</code> standardmäßig nicht
setuid. <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keysign">ssh-keysign</a>
wird benutzt, um die privaten Hostschlüssel auszulesen, und ssh benutzt
standardmäßig keine privilegierten Quellports. Wenn du
doch einen benutzen willst, musst du das setuid-Bit von <code>ssh</code>
per Hand setzen.

<h2><a name= "2.3">2.3 - Warum hat SSH 2.3 Probleme beim Interoperieren mit OpenSSH 2.1.1?</a></h2>

<p>
SSH 2.3 und frühere Versionen haben einen Fehler in ihrer
HMAC-Implementation. Ihr Code hat nicht die komplette Ausgabe des Datenblocks
von der Auswahl bereitgestellt, sondern stattdessen eben nur 128 Bits.
Bei längeren Anfragen konnte dann SSH 2.3 eben nicht mit OpenSSH
zusammenarbeiten.

<p>
OpenSSH 2.2.0 erkennt, dass SSH 2.3 diesen Fehler hat. In
zukünftigen Versionen von SSH wird dieser Fehler behoben sein.
Alternativ kannst du das folgende in deine <i>/etc/sshd2_config</i> von
SSH 2.3 einfügen.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>Mac hmac-md5</b>
               </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.4">2.4 - Warum gibt OpenSSH Folgendes aus: Dispatch protocol error: type 20</a></h2>

<p>
Probleme bei der Zusammenarbeit treten auf, weil ältere Versionen
von OpenSSH noch keine Unterstützung für ,session rekeying' hatten.
Das kommerzielle SSH 2.3 versucht diese Funktionalität abzulehnen, und es kann
zum Einfrieren der Verbindung kommen, oder die Fehlermeldung
,<b>Dispatch protocol error: type 20 </b>' kann zu lesen sein.
Das Problem wird entweder durch ein Upgrade auf eine aktuelle
OpenSSH-Version oder Abschalten des ,rekeying' durch Hinzufügen des
folgenden in die <i>ssh2_config</i> oder <i>sshd2_config</i> vom
kommerziellen SSH 2.3 behoben.


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>RekeyIntervalSeconds 0</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.5">2.5 - Alte Versionen des kommerziellen SSH verschlüsseln Hostkeys mit IDEA.</a></h2>

<p>
Die alten Versionen von SSH haben einen patentierten Algorithmus benutzt,
um ihren <i>/etc/ssh/ssh_host_key</i> zu verschlüsseln. Das Problem
manifestiert sich darin, dass der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
seinen Hostschlüssel nicht lesen kann. Um das Problem zu lösen, benutze
das Kommando weiter unten, um deinen ssh_host_key zu 3DES zu konvertieren.
<b>HINWEIS:</b> Benutze das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>-Programm
von dem kommerziellen SSH-Produkt und *NICHT* OpenSSH für
das Beispiel weiter unten.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
# <b>ssh-keygen -u -f /etc/ssh/ssh_host_key</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.6">2.6 - Was sind das für Warnungen über Schlüssellängen?</a></h2>

<p>
Das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>
des kommerziellen SSH-Programms hat einen Fehler beinhaltet, der dazu
führte, dass es von Zeit zu Zeit ,Pubkey'-Authentifikationsschlüssel (RSA oder
DSA) generiert hat, deren ,Most Significant'-Bit (MSB) nicht
gesetzt war. Solche Schlüssel wurden zwar als ,mit voller Länge'
angekündigt, waren aber die Hälfte der Zeit über kleiner als angekündigt.

<p>
OpenSSH wird Warnungen ausgeben, wenn es solchen Schlüsseln begegnet.
Um diese Warnungen loszuwerden, passe deine <i>known_hosts</i>-Datei an und
ersetze die falsche Schlüssellänge (normalerweise ,1024') mit
der richtigen (normalerweise ,1023').

<h2><a name= "2.7">2.7 - X11- und/oder Agent-Weiterleitung funktioniert nicht.</a></h2>

<p>
Prüfe deine <i>ssh_config</i> und <i>sshd_config</i>. Die
voreingestellten Konfigurationsdateien schalten den Authentifikationsagenten
und X11-Weiterleitung ab. Füge die Zeilen unten in die <i>sshd_config</i>
ein, um sie zu aktivieren:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>X11Forwarding yes</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
und füge die folgenden Zeilen in die <i>ssh_config</i> ein:

<blockquote>
<table border=0 width="800">
	<tr>
		<td nowrap bgcolor="#EEEEEE">
<b>ForwardAgent yes</b><br>
<b>ForwardX11 yes</b>
		</td>
	</tr>
</table>
</blockquote>

<p>
X11-Weiterleitung setzt eine funktionierende <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=xauth&amp;sektion=1"
>xauth(1)</a>-Binary voraus. Unter OpenBSD befindet sie sich im
<i>xbase</i>-Dateiset, was auf anderen Plattformen jedoch nicht der
Fall sein muss. Für die portable OpenSSH muss xauth entweder während
dem configure-Aufruf gefunden werden oder später mittels
<b>XauthLocation</b> in der sshd_config(5) und ssh_config(5)
angegeben werden.

<p>
Hinweis zur Agenten-Interoperabilität: Es gibt zwei unterschiedliche
und inkompatible Agentweiterleitung-Mechanismen innerhalb des
SSH2-Protokolls. OpenSSH hat immer eine Erweiterung der originalen
SSH1-Agent-Anfragen genutzt, jedoch verwenden einige kommerzielle
Produkte ein anderes, nicht freies Agentweiterleitungsprotokoll.
Dies bedeutet, dass Agentweiterleitung nicht zwischen OpenSSH und
diesen kommerziellen Produkten genutzt werden kann.

<p>
<b>HINWEIS:</b> Benutzer von Linux Mandrake 7.2: Mandrake modifiziert
die <i>XAUTHORITY</i>-Umgebungsvariable in <i>/etc/skel/.bashrc</i>
und damit das Heimatverzeichnis jedes Bash-Benutzers. Diese Variable wird
von OpenSSH gesetzt und daher muss für die oben genannten
Optionen die folgende Zeile auskommentiert werden:


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b># export XAUTHORITY=$HOME/.Xauthority</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.8">2.8 - Nach dem Upgrade auf OpenSSH habe ich keine SSH2-Unterstützung mehr.</a></h2>

<p>
Die Dateien <i>sshd_config</i> oder <i>ssh_config</i> können von
Version zu Version verändert werden. Du solltest immer nach solchen
Änderungen Ausschau halten, wenn du auf eine neue Version von OpenSSH
upgradest. Nach OpenSSH 2.3.0 musst du das folgende in deine
<i>sshd_config</i> einfügen:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>HostKey /etc/ssh_host_dsa_key</b><br>
<b>HostKey /etc/ssh_host_rsa_key</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.9">2.9 - sftp/scp kann keine Verbindung aufbauen, obwohl ssh funktioniert.</a></h2>

<p>
sftp und/oder scp können beim Aufbauen der Verbindung Probleme haben,
wenn du eine Shellinitialisierung (.profile, .bashrc, .chsrc etc.) hast,
die Ausgaben für nicht interaktive Sitzungen produziert. Diese Ausgabe
verwirrt den sftp/scp-Client. Hiermit kannst du prüfen, ob deine
Shell das tut:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>ssh yourhost /usr/bin/true</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Wenn das Kommando oben irgendeine Art von Ausgabe produziert, musst du
deine Shellinitialisierung modifizieren.

<h2><a name= "2.10">2.10 - Werdet ihr [foo] zu scp hinzufügen?</a></h2>

<p>
Kurze Antwort: Nein.

<p>
Lange Antwort: scp ist nicht standardisiert. Die Beschreibung, die einer
Spezifikation am nächsten kommt, ist: »Was rcp macht«. Da das selbe Kommando
auf beiden Seiten einer Verbindung benutzt wird, bedeutet das Hinzufügen
von Funktionalitäten oder Optionen das Risiko von Inkompatibilitäten
mit anderen Implementationen.

<p>
Neue Funktionalitäten sind eher in sftp wahrscheinlich, da das Protokoll
standardisiert (na ja, ein
,<a href="http://www.ietf.org/html.charters/OLD/secsh-charter.html">
draft standard</a>') und erweiterbar ist und Client sowie Server
voneinander getrennt sind.

<h2><a name= "2.11">2.11 - Wie verwende ich Portweiterleitung?</a></h2>

<p>
Wenn sshd(8) auf dem Server auf der Gegenseite läuft, kann es möglich
sein, bestimmte Dienste durch ssh zu ,tunneln'. Das kann wünschenswert
sein, um beispielsweise POP- und SMTP-Verbindungen zu verschlüsseln,
selbst wenn die Software keine eigene Unterstützung für
verschlüsselte Verbindungen hat. Das Tunneln verwendet Portweiterleitung,
um eine Verbindung zwischen dem Client und dem Server herzustellen. Die
Client-Software muss hierfür in der Lage sein, auf einen nicht standardisierten
Port verbinden zu können.

<p>
Die Idee dahinter ist, dass der Client sich mit dem entfernten System über
ssh verbindet und angibt, welcher Port auf der Maschine des Clients dazu
verwendet werden soll, Verbindungen zum Server weiterzuleiten. Danach ist es
möglich, die Dienste, die verschlüsselt werden sollen (z.&nbsp;B. fetchmail,
irc), auf dem Client mit der Angabe des gleichen Ports, der an ssh
übergeben wurde, zu starten, und die Verbindung wird durch ssh getunnelt.
Standardmäßig wird das System, das das Weiterleiten durchführt, nur
eigene Verbindungen zulassen.

<p>
Die wichtigsten Optionen zum Tunneln sind die Optionen -L und -R, welche dem
Benutzer das Portweiterleiten erlauben, die Option -D, welche das dynamische
Portweiterleiten erlaubt, die Option -g, die es anderen Hosts erlaubt,
Portweiterleitung zu benutzen, und die Option -f, welche ssh zuweist, nach
der Authentifizierung im Hintergrund weiterzuarbeiten. Lies die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1"
>ssh(1)</a>-Manualseite, um weitere Details zu erfahren.

<p>
Dies ist ein Beispiel für eine getunnelte IRC-Sitzung von der Clientmaschine
,127.0.0.1' (localhost) zum entfernten Server ,server.example.com':

<blockquote>
<table border=0 width="800">
	<tr>
		<td nowrap bgcolor="#EEEEEE">
<b>ssh -f -L 1234:server.example.com:6667 server.example.com sleep 10<br>
irc -c '#users' -p 1234 pinky 127.0.0.1</b>
	</td>
	</tr>
</table>
</blockquote>

<p>
Dies tunnelt eine Verbindung zum IRC-Server server.example.com und tritt mit
dem Nick ,pinky' dem Channel ,#users' bei. Der lokale Port, der in diesem
Beispiel verwendet wurde, ist 1234. Es tut nichts zur Sache, welcher Port
benutzt wird, so lange er größer ist als 1023 (bedenke, nur root
kann Sockets auf privilegierten Ports öffnen) und keine Störung
mit bereits verwendeten Ports auftritt. Die Verbindung wird zum Port 6667
auf dem entfernten Server weitergeleitet, da das der Standardport für
IRC-Dienste ist.

<p>
Der Remote-Befehl ,sleep 10' wurde angegeben, um dem Dienst, der getunnelt
werden soll, eine gewisse Zeit (10 Sekunden in diesem Beispiel) zu geben, um
zu starten. Wenn in der angegebenen Zeit keine Verbindung aufgebaut wurde,
wird ssh sich beenden. Falls mehr Zeit benötigt wird, kann der sleep(1)-Wert
entsprechend erhöht werden oder alternativ könnte das oben
aufgelistete Beispiel als eine Funktion in die Benutzershell eingefügt
werden. Siehe ksh(1) und csh(1) für weitere Details über
benutzerdefinierte Funktionen.

<p>
ssh besitzt des Weiteren die Option -N, welche praktisch für das
Portweiterleiten ist: Wenn -N übergeben wurde, ist es nicht notwendig, einen
Remote-Befehl (»sleep 10« in dem Beispiel oben) anzugeben. Allerdings
führt die Benutzung dieser Option dazu, dass ssh für immer wartet
(anstatt zu beenden, wenn ein Remote-Befehl ausgeführt wurde), sodass
der Benutzer darauf achten muss, den Prozess hinterher manuell mit kill(1)
zu beenden.

<h2><a name= "2.12">2.12 - Meine ssh-Verbindung friert ein oder steigt nach N
Minuten Inaktivität aus.</a></h2>

<p>
Das ist üblicherweise das Resultat eines Paketfilters oder einem
NAT-Gerät, das die TCP-Verbindung wegen Inaktivität auslaufen
lässt. Du kannst <b>ClientAliveInterval</b> in der <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd_config&amp;sektion=5">
sshd_config</a></i> des Servers aktivieren oder <b>ServerAliveInterval</b> in
der <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh_config&amp;sektion=5">
ssh_config</a></i> des Clients ermöglichen (die letzte Option ist in
OpenSSH 3.8 und neuer verfügbar).

<p>
Das Aktivieren einer der beiden Optionen und das Setzen des Intervalls, das
kürzer als die benötigte Zeit ist, um die Verbindung auslaufen zu
lassen, sorgen dafür, dass die Verbindung in der Verbindungstabelle des
Gerätes ,frisch' gehalten wird.

<h2><a name= "2.13">2.13 - Wie rufe ich scp auf, um eine Datei zu kopieren,
die einen Doppelpunkt beinhaltet?</a></h2>

<b><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">
scp</a></b> interpretiert den Teil vor dem Doppelpunkt als Namen des
entfernten Servers und versucht, eine Verbindung zu diesem aufzubauen. Um
das zu verhindern, greife auf die Datei mit relativer oder absoluter
Pfadangabe zu, z.&nbsp;B.:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ scp ./source:file sshserver:
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.14">2.14 - Warum teilt OpenSSH seine Version den Clients mit?</a></h2>

<p>
OpenSSH, wie die meisten SSH-Implementationen, teilt seinen Namen und seine
Version den Clients mit, wenn sie eine Verbindung aufbauen, z.&nbsp;B.
</p>

<blockquote>
SSH-2.0-OpenSSH_3.9
</blockquote>

<p>
Diese Information wird von den Clients und Servern verwendet, um
Protokollkompatibilitätskniffe zu aktiveren, die veränderte, fehlerhafte
oder fehlende Funktionen in der Implementation, mit der sie reden,
zu umgehen. Dieser Protokollfunktionstest ist weiterhin nötig, weil noch
immer Versionen mit Inkompatibilitäten im Umlauf sind.
</p>

<h2><u><a name= "3.0">3.0 - Fragen zum portablen OpenSSH</a></u></h2>

<h2><a name= "3.1">3.1 - Unechte PAM-Authentifikationsmeldungen in den Logdateien.</a></h2>

<p>
Die portable Version von OpenSSH generiert unechte misslungene
Authentifikationsmeldungen bei jedem Login, etwa wie:


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
"<b>authentication failure; (uid=0) -&gt; root for sshd service</b>"
                </td>
        </tr>
</table>
</blockquote>

<p>
Diese werden erzeugt, weil OpenSSH zuerst versucht herauszufinden, ob
der Anwender eine Authentifikation zum Login benötigt (z.&nbsp;B. leeres Passwort).
Dummerweise logt PAM alle Authentifikationversuche,
inklusive diesem hier.

<p>
Wenn es dich zu sehr stört, setze
»<b>PermitEmptyPasswords no</b>« in <i>sshd_config</i>. Das
wird die Meldung stilllegen, allerdings auf Kosten dessen, dass es nicht
mehr möglich ist, sich in Accounts mit leeren Passwörtern
einzuloggen. Das ist im übrigen bereits der Standard, wenn du die
mitgelieferte <i>sshd_config</i>-Datei benutzt.

<h2><a name= "3.2">3.2 - Leere Passwörter sind bei der PAM-Authentifikation nicht erlaubt.</a></h2>

<p>
Um leere Passwörter in einer OpenSSH-Version zu erlauben, die mit
PAM erzeugt wurde, musst du das ,nullok'-Flag an das Ende des
Password-Checking-Moduls in der <i>/etc/pam.d/sshd</i>-Datei
setzen. Zum Beispiel:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
auth required/lib/security/pam_unix.so shadow nodelay nullok
                </td>
        </tr>
</table>
</blockquote>

<p>
Das muss zusätzlich zum Setzen von
»<b>PermitEmptyPasswords yes</b>« in der
<i>sshd_config</i>-Datei geschehen.

<p>
Es gibt einen Fallstrick beim Benutzen leerer Passwörter mit
PAM-Authentifikation: PAM wird jegliches Passwort erlauben, wenn ein Account
mit einem leeren Passwort authentifiziert wird. Das macht den Check, den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
benutzt, um zu prüfen, ob der Account ein Passwort gesetzt hat,
wirkungslos und umgeht ebenso die Richtlinie, die von
<b>PermitEmptyPasswords</b> gesetzt wurde. Aus diesem Grund raten wir
davon ab, die <b>nullok</b>-Direktive in deiner PAM-Konfigurationsdatei
zu setzen, es sei denn, du willst leere Passwörter explizit erlauben.


<h2><a name= "3.3">3.3 - ssh(1) benötigt sehr lange zum Verbinden oder zum Einloggen</a></h2>

<p>
Große Verzögerungen (mehr als 10 Sekunden) werden normalerweise
durch Probleme mit der Namensauflösung verursacht:
<ul>
<li>Einige Versionen der glibc (insbesondere glibc 2.1, die mit Red Hat 6.1
ausgeliefert wurde) können einen langen Zeitraum benötigen, um
,IPv6 zu IPv4'-Adressen von Domänennamen aufzulösen. Das kann
umgangen werden, indem die Option <b>AddressFamily inet</b> in der
<i>ssh_config</i> eingetragen wird.</li>

<li>Es könnte ein DNS-Auflösungsproblem vorliegen, entweder beim
Client oder beim Server. Du kannst den <code>nslookup</code>-Befehl auf dem
Client und dem Server verwenden, um den Namen und die IP-Adresse der Gegenseite
auflösen zu lassen. Lass zusätzlich den Namen auf dem Server
auflösen, den der Client beim Auflösen der IP-Adresse des Servers
zurückgegeben hat. Du kannst die meisten Lookups serverseitig durch
das Hinzufügen von <b>UseDNS no</b> in <i>sshd_config</i>
deaktivieren.</li>
</ul>

<p>
Verzögerungen unter 10 Sekunden können andere Ursachen haben.

<ul>

<li>OpenSSH-Versionen vor 3.8 hatten eine <i>moduli</i>-Datei mit moduli,
die kleiner waren als die, nach denen OpenSSH Ausschau hielt, und als Resultat
würde sshd am Ende moduli verwenden, die beachtlich größer
wären als die, die angefragt wurden, was auf Kosten der Geschwindigkeit
geschah. Das Ersetzen der <i>moduli</i>-Datei wird das Problem lösen
(bedenke, dass diese Datei bei einem Upgrade in den meisten Fällen nicht
ausgetauscht wird und daher manuell ersetzt werden muss).</li>

<li>OpenSSH-Versionen vor 3.8 hatten einen Fehler in <code>ssh</code>, der
dazu führte, dass es größere moduli anforderte als erwartet
(was dann, in Kombination mit dem oben genannten Problem, in erheblichen
Geschwindigkeitseinbußen endete).
Ein Upgrade des Clients auf Version 3.8 oder höher wird das Problem
beheben.</li>

<li>Falls entweder der Server oder der Client keinen kernelbasierten
Zufallszahlengenerator besitzen (z.&nbsp;B. Solaris &lt; 9, AIX &lt; 5.2, HP-UX
&lt; 11.11) und kein Ersatz verfügbar ist (z.&nbsp;B. <a href=
"ftp://ftp.ayamura.org/pub/prngd/">prngd</a>), ist es möglich, dass ein
Programm, das von <code>ssh-rand-helper</code> zum Generieren vom Entropy
aufgerufen wird, hängt. Das kann ermittelt werden, indem es im Debug-Modus
ausgeführt wird:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
/usr/local/libexec/ssh-rand-helper -vvv
                </td>
        </tr>
</table>
</blockquote>

Alle beachtlichen Verzögerungen sollten untersucht und behoben,
oder aber die entsprechenden Befehle aus <i>ssh_prng_cmds</i> entfernt
werden.
</li>

</ul>

<h3>Wie langsam ist ,langsam'?</h3>
Unter normalen Umständen ist die Geschwindigkeit des SSH-Logins
abhängig von der CPU-Leistung des Clients und Servers. Zum Vergleich
folgen typische Verbindungszeiten für <code>time ssh localhost
true</code> mit einem 1024-Bit-RSA-Schlüssel auf einem ansonsten
ungenutzten System. OpenSSH und OpenSSL wurden mit gcc 3.3.x compiliert.

<p>
<table>
<tr><th>CPU</th><th>Zeit (SSHv1)<a href="#3.3fn1">[1]</a></th>
	<th>Zeit (SSHv2)</th></tr>
<tr><td>170MHz SPARC/sun4m</td><td>0.74 Sek</td><td>1.25 Sek</td></tr>
<tr><td>236MHz HPPA/8200<a href="#3.3fn2">[2]</a></td><td>0.44 Sek</td>
	<td>0.79 Sek</td></tr>
<tr><td>375MHz PowerPC/604e</td><td>0.38 Sek</td><td>0.51 Sek</td></tr>
<tr><td>933MHz VIA Ezra</td><td>0.34 Sek</td><td>0.44 Sek</td></tr>
<tr><td>2.1GHz Athlon 2600+</td><td>0.14 Sek</td><td>0.22 Sek</td></tr>
</table>

<br>

<a name="3.3fn1">[1]</a> Das SSHv1 Protokoll ist zwar schneller, aber
kryptographisch schwächer als SSHv2.<br>

<a name="3.3fn2">[2]</a> Zu dem Zeitpunkt des Schreibens generiert gcc relativ
langsamen Code auf HPPA für RSA- und Diffie-Hellman-Operationen (siehe
<a href= "http://gcc.gnu.org/bugzilla/show_bug.cgi?id=7625">gcc bug #7625</a>
und <a
href="http://marc.info/?l=openssh-unix-dev&amp;m=102646106016694">
Diskussion auf openssh-unix-dev</a>).

<h2><a name= "3.4">3.4 - »Can't locate module net-pf-10«-Meldungen im Log unter Linux.</a></h2>

<p>
Der Linux-Kernel sucht (via modprobe) nach der Protokollfamilie 10 (IPv6).
Lade entweder das passende Kernelmodul, gib den korrekten Alias in
<i>/etc/modules.conf</i> an oder schalte IPv6 in <i>/etc/modules.conf</i> ab.


<p>
Aus irgendeinem blödsinnigen Grund kann
<i>/etc/modules.conf</i> auch <i>/etc/conf.modules</i> heißen.


<h2><a name= "3.5">3.5 - Passwortauthentifikation funktioniert nicht (z.&nbsp;B. unter Slackware 7.0 oder Red Hat 6.x)</a></h2>

<p>
Falls das Passwort das korrekte Passwort ist, und der Login weiterhin
verwehrt bleibt, liegt die Ursache normalerweise darin, dass das
System zwar mit MD5-Typ-Passwörtern arbeitet, aber die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crypt&amp;sektion=3"
>crypt(3)</a>-Funktion, die von sshd verwendet wird, diese nicht
verstehen kann.

<p>
Betroffene Passwörter haben eine Passwortzeichenkette in
<i>/etc/passwd</i> oder <i>/etc/shadow</i>, die mit <b>$1$</b> beginnt.
Falls die Passwortauthentifikation für neue Accounts oder Accounts
mit Passwörtern, die kürzlich aktualisiert wurden, fehlschlägt, aber
mit alten Accounts funktioniert, dann ist dies wahrscheinlich das
Problem.

<p>
Der Grund hierfür ist, dass einige Versionen von OpenSSL eine
crypt(3)-Funktion haben, die keine MD5-Passwörter versteht, und die
,link'-Reihenfolge von sshd führt dazu, dass OpenSSLs crypt(3) und nicht
das vom System genutzt wird. OpenSSHs configure versucht dies
zu korrigieren aber ist damit nicht immer erfolgreich.

<p>
Es gibt einige mögliche Lösungen:

<ul>
<li>
<p>
Aktiviere sshds eingebaute Unterstützung für MD5-Passwörter während
der Erzeugungsphase.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
./configure --with-md5-passwords [Optionen]
                </td>
        </tr>
</table>
</blockquote>

Dies ist sogar dann sicher, wenn du beide Verschlüsselungstypen
verwendest, da sshd den korrekten Algorithmus für jeden Account
automatisch auswählt.

<li>
<p>
Wenn dein System eine separate libcrypt-Bibliothek hat (z.&nbsp;B.
Slackware 7), dann kannst du manuell -lcrypt zur LIBS-Liste
einfügen, sodass es statt OpenSSLs verwendet wird:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
LIBS=-lcrypt ./configure [Optionen]
                </td>
        </tr>
</table>
</blockquote>

<li>
<p>
Wenn deine Plattform PAM unterstützt, könntest du sshd so konfigurieren,
dass es dieses verwendet (siehe <a href= "#3.15" >Sektion 3.15</a>). Das
bedeutet, dass sshd Passwörter nicht selbst überprüfen wird, sondern es
an die konfigurierten PAM-Module übergibt.
</ul>

<h2><a name= "3.6">3.6 - Configure oder sshd(8) beschweren sich über fehlende RSA- oder DSA-Unterstützung</a></h2>

<p>
Stelle sicher, dass deine OpenSSL-Bibliotheken mit eingebauter RSA- oder
DSA-Unterstützung erzeugt wurden, entweder intern oder durch RSAref.


<h2><a name= "3.7">3.7 - »scp: command not found«-Fehler</a></h2>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a>
muss sich im Standard-PATH sowohl auf dem Client als auch auf dem Server
befinden. Möglicherweise musst du die Option <b>--with-default-path</b>
angeben, um einen angepassten Pfad für die Suche auf dem
Server angeben zu können. Diese Option ersetzt den Standardpfad, sodass
du sowohl alle bisherigen Verzeichnisse in deinem Pfad angeben musst als auch
das Verzeichnis, in dem scp installiert ist. Zum Beispiel:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>./configure --with-default-path=/bin:/usr/bin:/usr/local/bin:/path/to/scp</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Bedenke, dass die Konfiguration des Administrators des Servers Vorrang
gegenüber der Option <b>--with-default-path</b> hat. Das beinhaltet
das Rücksetzen von PATH in <i>/etc/profile</i>, PATH in
<i>/etc/environment</i> unter AIX oder (für 3.7p1 und höher) das
Setzen von PATH oder SUPATH in <i>/etc/default/login</i> unter Solaris oder
Reliant Unix.

<h2><a name= "3.8">3.8 - Kann die Passphrase nicht lesen</a></h2>

<p>
Einige Betriebssysteme setzen <i>/dev/tty</i> mit falschen Modi, was
zum Fehler beim Lesen von Passwörtern mit folgender Fehlermeldung
führt:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
You have no controlling tty.  Cannot read passphrase.
                </td>
        </tr>
</table>
</blockquote>

<p>
Die Lösung hierzu ist, die Berechtigungen von <i>/dev/tty</i> auf 0666 zu
setzen und dann das ganze deinem Betriebssystem-Hersteller als Fehler zu
melden.


<h2><a name= "3.9">3.9 - configure fehlt oder make versagt</a></h2>

<p>
Wenn es keine configure-Datei in deiner tar.gz-Datei gibt, die du
heruntergeladen hast, oder make mit einem ,missing seperator'-Fehler
versagt, hast du vermutlich die OpenBSD-Distribution heruntergeladen
und versuchst, sie auf einer anderen Plattform zu kompilieren.
Bitte verwende die <a href="portable.html">portable Version</a>.


<h2><a name= "3.10">3.10 - Hängt beim Verlassen von ssh</a></h2>

<p>
OpenSSH kann beim Beenden hängen bleiben. Das kann passieren, wenn
es einen aktiven Hintergrundprozess gibt. Linux und HP-UX sind
hierfür bekannt. Das Problem kann hiermit verifiziert werden:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>sleep 20 &amp; exit</b>
                </td>
        </tr>
</table>
</blockquote>

Versuche stattdessen das hier zu benutzen:
<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>sleep 20 &lt; /dev/null &gt; /dev/null 2&gt;&amp;1 &amp;</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Ein Umgehen des Problems für bash-Anwender ist mittels eines
Einfügens von <b>"shopt -s huponexit"</b> in entweder /etc/bashrc oder
~/.bashrc möglich. Ansonsten konsultiere die Manualseite deiner Shell um
eine Option zu finden, mit der man aktiven Jobs ein HUP-Signal senden kann,
wenn man sie verlässt. Siehe <a
href="http://bugzilla.mindrot.org/show_bug.cgi?id=52">bug #52</a>
für andere Möglichkeiten, das Problem umgehen zu können.

<h2><a name= "3.11">3.11 - Wieso hängt ssh beim Beenden?</a></h2>

<p>
Beim Ausführen von
<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>ssh host command</b>
                </td>
        </tr>
</table>
</blockquote>
<b>muss</b> ssh hängen bleiben, da es zu warten hat
<ul>
<li>
bis es sicherstellen kann, dass <code>command</code> keine weiteren
Eingaben benötigt.
<li>
bis es sicherstellen kann, dass <code>command</code> keine weitere
Ausgaben zurückgibt.
<li>
bis <code>command</code> beendet ist, da der sshd den Exitstatus
von <code>command</code> an ssh weitergeben muss.
</ul>
<p>

<h2><a name= "3.12">3.12 - Ich habe ein Upgrade auf OpenSSH 3.1
durchgeführt und dann ging die X11-Weiterleitung nicht mehr.</a></h2>

Beginnend mit OpenSSH 3.1 lauscht der sshd-X11-Weiterleitungsserver
standardmäßig auf localhost; siehe auch die
Option <b>X11UseLocalhost</b> von sshd, um zum vorherigen Verhalten
zurückzukehren, wenn deine älteren X11-Clients nicht mit dieser
Konfiguration funktionieren.<p>

Im Allgemeinen sollten X11-Clients, die X11 R6 benutzen, mit dieser
Einstellung funktionieren. Einige Hersteller, einschließlich HP, setzen
X11-Clients mit R6- und R5-Bibliotheken ein, sodass einige Clients
funktionieren und andere nicht.
Das gilt z.&nbsp;B. für HP-UX 11.X.<p>

<h2><a name= "3.13">3.13 - Ich habe ein Upgrade auf OpenSSH 3.8
durchgeführt und dann gingen einige X11-Programme nicht
mehr.</a></h2>

<p>
Wie in den <a href="../txt/release-3.8">3.8 release notes</a> dokumentiert
worden ist, wird <code>ssh</code> standardmäßig ,untrusted X11
cookies' benutzen. Das vorherige Verhalten kann durch das Setzen von
<b>ForwardX11Trusted yes</b> in <i>sshd_config</i> wiederhergestellt werden.

<p>
Mögliche Symptome beinhalten:<br>
<code>BadWindow (invalid Window parameter)<br>
BadAccess (attempt to access private resource denied)<br>
X Error of failed request:  BadAtom (invalid Atom parameter)<br>
Major opcode of failed request:  20 (X_GetProperty)<br></code>

<h2><a name= "3.14">3.14 - Ich habe meinen öffentlichen Schlüssel
in authorized_keys kopiert, aber Publickey-Authentifizierung funktioniert
immer noch nicht.</a></h2>

<p>
Typischerweise wird das durch die Dateirechte von $HOME,
$HOME/.ssh oder $HOME/.ssh/authorized_keys hervorgerufen, die mehr erlauben
als sshd standardmäßig zulässt.

<p>
In diesem Falle kann es behoben werden, indem Folgendes auf dem Server
ausgeführt wird.
<blockquote>
<table border=0 width="800">
<tr>
  <td nowrap bgcolor="#EEEEEE">
$ <b>chmod go-w $HOME $HOME/.ssh</b><br>
$ <b>chmod 600 $HOME/.ssh/authorized_keys</b>
$ <b>chown `whoami` $HOME/.ssh/authorized_keys</b><br>
  </td>
</tr>
</table>
</blockquote>

<p>
Falls das aus irgendeinem Grund nicht möglich sein sollte, besteht die
Alternative darin, <b>StrictModes no</b> in <i>sshd_config</i> zu setzen,
jedoch wird das nicht empfohlen.

<h2><a name= "3.15">3.15 - OpenSSH-Versionen und das Verhalten von PAM.</a></h2>

Das portable OpenSSH hat eine Option, die während der Konfigurationsphase
gesetzt werden kann, um sshds Nutzung des
<a href="http://www.opengroup.org/onlinepubs/008329799/">PAM</a>-
(Pluggable Authentication Modules) Interfaces zu aktivieren.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
./configure --with-pam [Optionen]
                </td>
        </tr>
</table>
</blockquote>

Um PAM auf irgendeine Weise nutzen zu können, muss diese Option während
der Erzeugungsphase gesetzt sein. Das Laufzeit-Verhalten, wenn PAM
erzeugt wurde, variiert mit der Version des portablen OpenSSH, und
spätere Versionen müssen es ebenfalls mit dem Setzen von
<b>UsePAM</b> auf <b>yes</b> in <i>sshd_config</i> aktivieren.

<p>
Das Verhalten der relevanten Authentifikations-Optionen, wenn
PAM-Unterstützung integriert wurde, ist in der folgenden Tabelle
zusammengefasst.

<p>
<table border="1">
  <tr> <th>Version</th> <th>UsePAM</th> <th>PasswordAuthentication</th> <th>ChallengeResponseAuthentication</th> </tr>
  <tr>
    <td>&lt;=3.6.1p2</td>
    <td>Nicht nutzbar</td>
    <td>Verwendet PAM</td>
    <td>Verwendet PAM, wenn <b>PAMAuthenticationViaKbdInt</b> aktiv ist</td>
  </tr>
  <tr>
    <td>3.7p1 - 3.7.1p1</td>
    <td>Standard ist <b>yes</b></td>
    <td>Verwendet nicht PAM</td>
    <td>Verwendet PAM, wenn <b>UsePAM</b> aktiv ist</td>
  </tr>
  <tr>
    <td>3.7.1p2 - 3.8.1p1</td>
    <td>Standard ist <b>no</b></td>
    <td>Verwendet nicht PAM <a href="#3.15fn1">[1]</a></td>
    <td>Verwendet PAM, wenn <b>UsePAM</b> aktiv ist</td>
  </tr>
  <tr>
    <td>3.9p1</td>
    <td>Standard ist <b>no</b></td>
    <td>Verwendet PAM, wenn <b>UsePAM</b> aktiv ist</td>
    <td>Verwendet PAM, wenn <b>UsePAM</b> aktiv ist</td>
  </tr>
</table>
<p>

<a name= "3.15fn1">[1]</a> Einige Verkäufer, insbesondere
Redhat/Fedora, haben die Passwortauthentifikation von 3.9p1
auf ihre 3.8x-basierten Packages zurückportiert. Wenn du ein
Package nutzt, das von einem Verkäufer bereitgestellt wurde,
konsultiere bitte deren Dokumentation.

<p>
,OpenSSH Portable's PAM-Interface hat immer noch Probleme mit ein
paar Modulen, jedoch hoffen wir, dass wir diese Anzahl in Zukunft
verringern können. Zum Zeitpunkt der Veröffentlichung von 3.9p1
sind folgende Probleme bekannt:

<ul>
  <li>Module, die sich auf ,module-private' Daten verlassen (z.&nbsp;B.
  pam_dhkeys, pam_krb5, AFS) können darin fehlschlagen, korrekte
  ,Credentials' zu erzeugen (Fehler <a
  href="http://bugzilla.mindrot.org/show_bug.cgi?id=688">#688</a>)
  wenn über <b>ChallengeResponseAuthentication</b> authentifiziert
  wird. <b>PasswordAuthentication</b> mit 3.9p1 und neuer sollten
  funktionieren.
</ul>

Du kannst außerdem <a
href="http://bugzilla.mindrot.org/buglist.cgi?product=Portable+OpenSSH&amp;bug_status=RESOLVED&amp;bug_status=NEW&amp;bug_status=ACCEPTED&amp;component=PAM+support"
>bugzilla für aktuelle PAM-Probleme</a> durchsehen.

<h2><a name= "3.16">3.16 - Warum zeigen weder »w« noch »who« unter AIX 5.x Benutzer an, die über ssh eingeloggt sind?</a></h2>

Zwischen AIX 4.3.3 und AIX 5.x wurde das Format vom »wtmp struct«
geändert. Das bedeutet, dass sshd-Binarys, die unter AIX 4.x erzeugt
wurden, keine korrekten wtmp-Einträge schreiben, wenn sie unter AIX 5.x
ausgeführt werden. Dies kann behoben werden, indem einfach sshd auf
einem AIX-5.x-System neukompiliert und dieser dann eingesetzt wird.

<hr>
<a href="index.html"><img height=24 width=24 src="../back.gif" border=0 alt=OpenSSH></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq.html,v 1.110 ]<br>
$Translation: faq.html,v 1.79 2010/02/20 14:37:14 tobias Exp $<br>
-->
$OpenBSD: faq.html,v 1.74 2010/02/24 07:21:25 ajacoutot Exp $
</small>

</body>
</html>
