<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>H&auml;ufig gestellte Fragen zu OpenSSH</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content= "Die OpenSSH FAQ Seite">
<meta name= "keywords"      content= "OpenSSH,SSH,Secure Shell,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1999-2004 OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">
<img alt="[OpenSSH]" height=30 width=141 src="../images/smalltitle.gif">
<p>

<h1>OpenSSH FAQ (H&auml;ufig gestellte Fragen)</h1>

<strong>Datum: 12.04.2004</strong>

<hr>

<blockquote>
<h3><a href= "#1.0">1.0 - Was ist OpenSSH und wo kann ich es bekommen?</a></h3>
<ul>
<li><a href= "#1.1">1.1 - Was ist OpenSSH und wo kann ich es herunterladen?</a>
<li><a href= "#1.2">1.2 - Warum sollte es eingesetzt werden?</a>
<li><a href= "#1.3">1.3 - Welche Betriebssysteme werden unterst&uuml;tzt?</a>
<li><a href= "#1.4">1.4 - Was ist mit Copyrights, Benutzung und Patenten?</a>
<li><a href= "#1.5">1.5 - Wo sollte ich um Hilfe fragen?</a>
</ul>

<h3><a href= "#2.0">2.0 - Allgemeine Fragen</a></h3>
<ul>
<li><a href= "#2.1">2.1 - Warum benutzt ssh/scp Verbindungen auf den unteren Ports? Meine Firewall blockiert diese.</a>
<li><a href= "#2.2">2.2 - Warum ist der ssh Client setuid root?</a>
<li><a href= "#2.3">2.3 - Warum hat SSH 2.3 Probleme beim Interoperieren mit OpenSSH 2.1.1?</a>
<li><a href= "#2.4">2.4 - Warum gibt OpenSSH folgendes aus: Dispatch protocol error: type 20</a>
<li><a href= "#2.5">2.5 - Alte Versionen des kommerziellen SSH verschl&uuml;sseln ,host keys' mit IDEA.</a>
<li><a href= "#2.6">2.6 - Was sind das f&uuml;r Warnmeldungen &uuml;ber Schl&uuml;ssell&auml;ngen?</a>
<li><a href= "#2.7">2.7 - X11 und/oder ,agent forwarding' funktioniert nicht.</a>
<li><a href= "#2.8">2.8 - Nach dem Upgrade auf OpenSSH habe ich keine SSH2 Unterst&uuml;tzung mehr.</a>
<li><a href= "#2.9">2.9 - sftp/scp kann keine Verbindung aufbauen, obwohl ssh funktioniert.</a>
<li><a href= "#2.10">2.10 - Werdet ihr [foo] zu scp hinzuf&uuml;gen?</a>
<li><a href= "#2.11">2.11 - Wie verwende ich ,port forwarding'?</a>
<li><a href= "#2.12">2.12 - Meine ssh Verbindung friert ein oder steigt nach N Minuten Inaktivit&auml;t aus.</a>
<li><a href= "#2.13">2.13 - Wie rufe ich scp auf, um eine Datei zu kopieren, die einen Doppelpunkt beinhaltet?</a>
</ul>

<h3><a href= "#3.0">3.0 - Fragen zum ,portablen OpenSSH'</a></h3>
<ul>
<li><a href= "#3.1">3.1 - Unechte PAM Authentifikations-Meldungen in den Logdateien.</a>
<li><a href= "#3.2">3.2 - Leere Passw&ouml;rter sind bei der PAM Authentifikation nicht erlaubt.</a>
<li><a href= "#3.3">3.3 - ssh(1) ben&ouml;tigt sehr lange zum Verbinden oder zum Einloggen</a>
<li><a href= "#3.4">3.4 - "Can't locate module net-pf-10" Meldungen im Log unter Linux.</a>
<li><a href= "#3.5">3.5 - Passwort Authentifikation funktioniert nicht unter Slackware 7.0 oder Red Hat 6.x</a>
<li><a href= "#3.6">3.6 - Configure oder sshd(8) beschweren sich &uuml;ber fehlende RSA Unterst&uuml;tzung</a>
<li><a href= "#3.7">3.7 - "scp: command not found" Fehler</a>
<li><a href= "#3.8">3.8 - Kann die Passphrase nicht lesen</a>
<li><a href= "#3.9">3.9 - ,configure' fehlt oder make versagt</a>
<li><a href= "#3.10">3.10 - H&auml;ngt beim Verlassen von ssh</a>
<li><a href= "#3.11">3.11 - Wieso h&auml;ngt ssh beim Beenden?</a>
<li><a href= "#3.12">3.12 - Ich habe ein Upgrade auf OpenSSH 3.1 durchgef&uuml;hrt und dann ging ,X11 forwarding' nicht mehr.</a>
<li><a href= "#3.13">3.13 - Ich habe ein Upgrade auf OpenSSH 3.8 durchgef&uuml;hrt und dann gingen einige X11 Programme nicht mehr.</a>
<li><a href= "#3.14">3.14 - Ich habe meinen &ouml;ffentlichen Schl&uuml;ssel in authorized_keys kopiert, aber public-key Authentifizierung funktioniert immernoch nicht.</a>
</ul>

</blockquote>

<hr>

<h2><u><a name= "1.0">1.0 - Was ist OpenSSH und wo kann ich es bekommen?</a></u></h2>

<h2><a name= "1.1">1.1 - Was ist OpenSSH und wo kann ich es herunterladen?</a></h2>

<p>
OpenSSH ist eine <b>FREIE</b> Version der SSH Suite von
Netzwerkverbindungs-Tools, auf die sich eine steigende Anzahl
von Leuten im Internet verlassen. Viele Benutzer von telnet,
rlogin, ftp und anderen solchen Programmen haben noch nicht
realisiert, dass ihr Passwort unverschl&uuml;sselt &uuml;ber
das Internet &uuml;bertragen wird, aber so ist es. OpenSSH
verschl&uuml;sselt den gesamten Verkehr (inklusive Passw&ouml;rtern),
um Mith&ouml;ren (eavesdropping), ,Entf&uuml;hren von Verbindungen'
(connection hijacking) und andere Angriffe auf Netzwerk-Ebene
effektiv zu eliminieren.

<p>
Die OpenSSH Suite beinhaltet das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>
Programm, das rlogin und telnet ersetzt, und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a>,
das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rcp&amp;sektion=1">rcp(1)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
ersetzt. OpenSSH beinhaltet auch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp&amp;sektion=1">sftp(1)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp-server&amp;sektion=8">sftp-server(8)</a>,
die eine einfache L&ouml;sung f&uuml;r Datei&uuml;bertragungen realisieren.
Sie basieren auf dem
<a href="../txt/draft-ietf-secsh-filexfer-02.txt">secsh-filexfer</a> IETF
Entwurf.


<p><strong>OpenSSH besteht aus mehreren Programmen.</strong>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a> - Server Programm, das auf der Server-Maschine l&auml;uft. Es lauscht, ob es Verbindungsw&uuml;nsche von Client-Maschinen gibt und f&uuml;hrt dann eine Authentifikation durch, bevor es den Client bedient.
Das Verhalten wird von der Konfigurationsdatei <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd_config&amp;sektion=5">
sshd_config(5)</a></i> verwaltet.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a> - Dies ist das Client Programm, das benutzt wird, um sich auf einer anderen Maschine einzuloggen oder dort Kommandos auszuf&uuml;hren. <i>slogin</i> ist ein weiterer Name f&uuml;r dieses Programm.
Das Verhalten wird von der systemweiten Konfigurationsdatei <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh_config&amp;sektion=5">
ssh_config(5)</a></i> und den benutzerspezifischen <i>$HOME/.ssh/config</i>
Dateien verwaltet.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a> - Kopiert Dateien sicher von einer Maschine zur anderen.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a> - Wird benutzt, um ,Pubkey Authentication' (RSA or DSA) Schl&uuml;ssel zu erzeugen (,host keys' und ,user authentication keys').
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-agent&amp;sektion=1">ssh-agent(1)</a> - Authentifikations-Agent.  Er kann benutzt werden, um RSA Schl&uuml;ssel f&uuml;r die Authentifikation bereitzuhalten.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-add&amp;sektion=1">ssh-add(1)</a> - Wird benutzt, um neue Schl&uuml;ssel beim Agent zu registrieren.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp-server&amp;sektion=8">sftp-server(8)</a> - SFTP Server Subsystem.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp&amp;sektion=1">sftp(1)</a> - Sicheres Datei&uuml;bertragungsprogramm.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keyscan&amp;sektion=1">ssh-keyscan(1)</a> - Sammelt ssh ,public keys' ein.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keysign&amp;sektion=8">ssh-keysign(8)</a> - ssh Hilfs-Programm f&uuml;r Host-basierende Authentifikation.
</ul>

<h3>Herunterladen</h3>

<p>
OpenSSH erscheint in zwei herunterladbaren Distributionen: der nativen <a
href="openbsd.html">OpenBSD</a> Distribution und der Multi-Plattform
<a href="portable.html">Portable</a> Distribution. Wenn du OpenSSH f&uuml;r
eine aktuelle Version von OpenBSD oder zur Integration in ein Projekt
ben&ouml;tigst, m&ouml;chtest du vermutlich die <a
href="openbsd.html">OpenBSD</a> Distribution. Falls du OpenSSH f&uuml;r
eine andere Plattform oder f&uuml;r eine &auml;ltere OpenBSD Version
ben&ouml;tigst, m&ouml;chtest du vermutlich die <a
href="portable.html">Portable</a> Distribution.

<p>
Wenn du herunterl&auml;dst, verwende bitte einen <a
href="portable.html#mirrors">mirror</a> in deiner N&auml;he.

<h2><a name= "1.2">1.2 - Warum sollte es eingesetzt werden?</a></h2>

<p>
OpenSSH ist eine Sammlung von Werkzeugen, die dir hilft, deine
Netzwerk-Verbindungen sicherer zu machen. Hier ist eine Liste der
Funktionalit&auml;ten:


<ul>
	<li>Starke Authentifikation.  Schlie&szlig;t verschiedene Sicherheitsl&ouml;cher (z.B. IP, routing, und DNS ,spoofing').
	<li>Verbesserte Privatsph&auml;re.  Alle Verbindungen werden automatisch und transparent verschl&uuml;sselt.
	<li>Sichere X11 Sitzungen.  Das Programm setzt DISPLAY auf der Server Maschine automatisch und leitet alle X11 Verbindungen &uuml;ber den sicheren Kanal weiter.
	<li>Willk&uuml;rliche TCP/IP Ports k&ouml;nnen durch den verschl&uuml;sselten Kanal in beide Richtungen gelenkt werden (z.B. f&uuml;r e-cash Transaktionen).
	<li>F&uuml;r normale Benutzer wird keine Schulung und kein Training ben&ouml;tigt.
	<li>Vertraut nie dem Netzwerk. Minimales Vertrauen auf der Gegenseite der Verbindung. Minimales Vertrauen gegen&uuml;ber den Domain Name Servern. Pure RSA Authentifikation vertraut nichts und niemandem, bis auf den ,private key'.
	<li>Der Client authentifiziert die Servermaschine am Beginn jeder Verbindung mit RSA, um ,trojanischen Pferden' (durch routing oder DNS ,spoofing') und ,man-in-the-middle' Angriffen vorzubeugen, und der Server tut das gleiche mit der Clientmaschine bevor er <i>.rhosts</i> oder <i>/etc/hosts.equiv</i> Authentifikation erlaubt (um DNS, routing oder IP ,spoofing' vorzubeugen).
	<li>Die ,host authentication key' Distribution kann zentral laufen, wird jedoch automatisch, sobald die erste Verbindung zur Maschine ge&ouml;ffnet wird.
	<li>Jeder Benutzer kann beliebig viele RSA Authentifikations-Schl&uuml;ssel zur eigenen Verwendung erzeugen.
	<li>Das Server-Programm hat seinen eigenen RSA Schl&uuml;ssel, der jede Stunde automatisch neu erzeugt wird.
	<li>Ein Authentifikations-Agent, der auf dem Laptop oder der Workstation des Benutzers l&auml;uft, kann benutzt werden, um die RSA Authentifikations-Schl&uuml;ssel des Anwenders zu halten.
	<li>Die Software kann auch ohne root-Privilegien installiert und benutzt werden (mit eingeschr&auml;nkter Funktionalit&auml;t).
	<li>Der Client ist in systemweiten und benutzerspezifischen Konfigurationsdateien anpassbar.
	<li>Optionale Kompression aller Daten mittels gzip (inklusive ,forwarded X11' und TCP/IP Daten), was zu bedeutenden Beschleunigungen auf langsamen Verbindungen f&uuml;hren kann.
	<li>Kompletter Ersatz f&uuml;r rlogin, rsh und rcp.
</ul>

<p>
Zur Zeit werden fast alle &Uuml;bertragungen in Computer-Netzwerken
unverschl&uuml;sselt durchgef&uuml;hrt. Als Konsequenz kann jeder, der
Zugriff auf irgendeine Maschine in diesem Netzwerk hat, alle Verbindungen
abh&ouml;ren. Das wird auch von Hackern, neugierigen Administratoren,
Arbeitgebern, Kriminellen, Industriespionen und Regierungen so
durchgef&uuml;hrt.
Einige Netzwerke senden derartig viel elektromagnetische Strahlung ab,
dass Daten sogar in gro&szlig;er Entfernung noch aufgefangen werden
k&ouml;nnen.


<p>
Wenn du dich einloggst, wird dein Passwort im Klartext &uuml;bertragen.
Daher kann dann jeder Lauscher deinen Account zu jeglicher Tat benutzen.
Es gibt weltweit viele Zeugnisse daf&uuml;r, dass Cracker auf dem Rechner
eines Opfers unbemerkt ein Programm gestartet haben, welches ohne Wissen des
Anwenders einfach nur das Netzwerk belauscht und Passw&ouml;rter gesammelt
hat. Programme, die das tun, gibt es im Internet oder k&ouml;nnen von einem
kompetenten Programmierer innerhalb weniger Stunden selbst geschrieben
werden.


<p>
Firmen haben Gesch&auml;ftsgeheimnisse, Patentantr&auml;ge in Vorbereitung,
Preisinformationen, Informationen &uuml;ber Vertragspartner, Kundendaten,
Personendaten, Finanzdaten, etc. Zur Zeit kann jeder mit Zugriff auf das
Netzwerk (jede Maschine im Netzwerk) alles belauschen, was im Netzwerk
vor sich geht, und das noch ohne die normalen Zugriffsbeschr&auml;nkungen.


<p>
Vielen Firmen ist nicht bewusst, dass Informationen so einfach aus ihrem
Netzwerk gesammelt werden k&ouml;nnen. Sie vertrauen darin, dass ihre
Daten sicher sind, da niemand wissen kann, dass dort vertrauliche
Informationen kursieren, oder auch, weil dort so viele andere Daten
&uuml;bertragen werden. Dies ist keine sichere Einstellung.


<h2><a name= "1.3">1.3 - Welche Betriebssysteme werden unterst&uuml;tzt?</a></h2>

<p>
Obwohl OpenSSH unter <a href="http://www.openbsd.org/">OpenBSD</a> entwickelt
wird, gibt es eine breite Palette an Portierungen auf andere Betriebssysteme.
Die portable Version von OpenSSH wird von
<a href="mailto:djm@openbsd.org">Damien Miller</a> geleitet. Einen
schnellen &Uuml;berblick &uuml;ber die portable Version von OpenSSH gibt
dir <a href="portable.html">http://www.openssh.com/portable.html</a>.
Betriebssysteme, die zur Zeit unterst&uuml;tzt werden, sind:


<ul>
	<li>OpenBSD
	<li>NetBSD
	<li>FreeBSD
	<li>AIX
	<li>HP-UX
	<li>IRIX
	<li>Linux
	<li>NeXT
	<li>SCO
	<li>SNI/Reliant Unix
	<li>Solaris
	<li>Digital Unix/Tru64/OSF
	<li>Mac OS X
	<li>Cygwin
</ul>

<p>
Eine Liste der Anbieter, die OpenSSH in ihre Distributionen einbinden,
befindet sich auf der <a href="users.html">OpenSSH Benutzer Seite</a>.

<h2><a name= "1.4">1.4 - Was ist mit Copyrights, Benutzung und Patenten?</a></h2>
<p>
Die OpenSSH Entwickler haben sehr hart versucht, OpenSSH frei
von Patent- oder Copyright-Problemen zu halten. Dazu mussten einige
Optionen aus OpenSSH entfernt werden. N&auml;mlich die Unterst&uuml;tzung
f&uuml;r patentierte Algorithmen.

<p>
OpenSSH unterst&uuml;tzt keinerlei patentierte Transportalgorithmen.
Im SSH1 Modus sind nur 3DES und Blowfish m&ouml;glich.
Im SSH2 Modus k&ouml;nnen nur 3DES, Blowfish, CAST128, Arcfour und AES
ausgew&auml;hlt werden. Der patentierte IDEA Algorithmus wird nicht
unterst&uuml;tzt.

<p>
OpenSSH bietet Unterst&uuml;tzung f&uuml;r sowohl das SSH1 als auch das
SSH2 Protokoll.

<p>
Seit das RSA Patent ausgelaufen ist, gibt es keinerlei Beschr&auml;nkungen
mehr f&uuml;r Software, die den RSA Algorithmus benutzen, inklusive OpenBSD.

<h2><a name= "1.5">1.5 - Wo sollte ich um Hilfe fragen?</a></h2>
<p>
Es gibt mehrere Stellen, die du um Hilfe bitten kannst. Zus&auml;tzlich
zur <a href="http://www.openssh.com/">OpenSSH Webseite</a> gibt es
mehrere Mailinglisten, in denen du dein Gl&uuml;ck versuchen kannst.
Bevor du das tust, durchsuche bitte alle Mailinglisten-Archive um
zu sehen, ob deine Frage vielleicht schon beantwortet wurde. Die
OpenSSH Mailingliste wurde archiviert und steht in durchsuchbarer Form unter
<a href="http://marc.theaimsgroup.com/?l=openssh-unix-dev&amp;r=1&amp;w=2">theaimsgroup.com</a>
zur Verf&uuml;gung.

<p>
Mehr Informationen &uuml;ber das Abonnieren von OpenSSH bezogenen
Mailinglisten gibt es unter
<a href="list.html">OpenSSH Mailinglisten</a>.

<p>
Informationen zum Senden von Bugreports k&ouml;nnen auf der OpenSSH
<a href="report.html">Bugs melden</a> Seite gefunden werden.

<h2><u><a name= "2.0">2.0 - Allgemeine Fragen</a></u></h2>

<h2><a name= "2.1">2.1 - Warum benutzt ssh/scp Verbindungen auf den unteren Ports?</a></h2>
<p>
Der OpenSSH Client benutzt die unteren Ports f&uuml;r rhosts und rhosts-rsa
Authentifikation, da der Server dem Benutzernamen vertrauen muss, den der
Client liefert. Um das zu umgehen, kannst du das Beispiel weiter unten
in deine <i>ssh_config</i> oder <i>~/.ssh/config</i> Datei kopieren.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>UsePrivilegedPort no</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Oder du kannst diese Option auf der Kommandozeile angeben, indem du die
<b>-o</b> Option des <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>
Kommandos benutzt.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>ssh -o "UsePrivilegedPort no" host.com</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.2">2.2 - Warum ist der ssh Client setuid root?</a></h2>

<p>
In Verbindung mit der vorhergehenden Frage (<a href="#2.1">2.1</a>)
braucht OpenSSH ,root authority', um sich an die unteren und privilegierten
Ports binden zu k&ouml;nnen, um dann eine <i>rhosts Authentifikation</i>
durchzuf&uuml;hren. Genauso notwendig ist dieser privilegierte Port
f&uuml;r rhosts-rsa Authentifikation zu &auml;lteren SSH Versionen.

<p>
Zus&auml;tzlich gilt sowohl f&uuml;r <i>rhosts-rsa Authentifikation</i>
(in Protokoll Version 1) als auch f&uuml;r <i>host-basierte Authentifikation</i>
(in Protokoll Version 2), dass der ssh Client Zugang zum
<i>private host key</i> braucht, um die Clientmaschine am Server
anzumelden.
OpenSSH Versionen vor 3.3 ben&ouml;tigten das <code>ssh</code> Binary
mit gesetztem setuid Bit, um das zu erreichen, aber du kannst das Bit
l&ouml;schen, wenn du diese Authentifizierungsmethoden nicht
benutzen willst.

<p>
Beginnend mit OpenSSH 3.3 ist <code>ssh</code> standardm&auml;&szlig;ig nicht
setuid. <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keysign">ssh-keysign</a>
wird benutzt, um die privaten hosts keys auszulesen, und ssh benutzt
standardm&auml;&szlig;ig keine privilegierten Source Ports. Wenn du
doch einen benutzen willst, musst du das setuid Bit von <code>ssh</code>
per Hand setzen.

<h2><a name= "2.3">2.3 - Warum hat SSH 2.3 Probleme beim Interoperieren mit OpenSSH 2.1.1?</a></h2>

<p>
SSH 2.3 und fr&uuml;here Versionen haben einen Fehler in ihrer HMAC
Implementierung. Ihr Code hat nicht die komplette Ausgabe des Datenblocks
von der Auswahl bereitgestellt, sondern stattdessen eben nur 128 Bits.
Bei l&auml;ngeren Anfragen konnte dann SSH 2.3 eben nicht mit OpenSSH
zusammenarbeiten.

<p>
OpenSSH 2.2.0 erkennt, dass SSH 2.3 diesen Fehler hat. In
zuk&uuml;nftigen Versionen von SSH wird dieser Fehler behoben sein.
Alternativ kannst du das folgende in deine SSH 2.3 <i>/etc/sshd2_config</i>
einf&uuml;gen.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>Mac hmac-md5</b>
               </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.4">2.4 - Warum gibt OpenSSH folgendes aus: Dispatch protocol error: type 20</a></h2>

<p>
Probleme bei der Zusammenarbeit treten auf, weil &auml;ltere Versionen
von OpenSSH noch keine Unterst&uuml;tzung f&uuml;r ,session rekeying' hatten.
Das kommerzielle SSH 2.3 versucht dieses Feature abzulehnen, und es kann
zum Einfrieren der Verbindung kommen, oder die Fehlermeldung
&quot;<b>Dispatch protocol error: type 20 </b>&quot; kann zu lesen sein.
Das Problem wird entweder durch ein Upgrade auf eine aktuelle OpenSSH
Version oder Abschalten des ,rekeying' durch Hinzuf&uuml;gen des
folgenden in die kommerzielle SSH 2.3 <i>ssh2_config</i> oder
<i>sshd2_config</i> behoben.


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>RekeyIntervalSeconds 0</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.5">2.5 - Alte Versionen des kommerziellen SSH verschl&uuml;sseln ,host keys' mit IDEA.</a></h2>

<p>
Die alten Versionen von SSH haben einen patentierten Algorithmus benutzt,
um ihren <i>/etc/ssh/ssh_host_key</i> zu verschl&uuml;sseln. Das Problem
manifestiert sich darin, dass der <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
seinen host key nicht lesen kann. Um das Problem zu l&ouml;sen, benutze
das Kommando weiter unten, um deinen ssh_host_key zu 3DES zu konvertieren.
<b>HINWEIS:</b> Benutze das <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>
Programm von dem kommerziellen SSH Produkt und *NICHT* OpenSSH f&uuml;r
das Beispiel weiter unten.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
# <b>ssh-keygen -u -f /etc/ssh/ssh_host_key</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.6">2.6 - Was sind das f&uuml;r Warnungen &uuml;ber Schl&uuml;ssell&auml;ngen?</a></h2>

<p>
Das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>
des kommerziellen SSH Programms hat einen Fehler beinhaltet, der dazu
f&uuml;hrte, dass es von Zeit zu Zeit ,Pubkey Authentication (RSA oder
DSA) keys' generiert hat, deren ,Most Significant Bit' (MSB) nicht
gesetzt war. Solche Schl&uuml;ssel wurden zwar als ,mit voller L&auml;nge'
angek&uuml;ndigt, waren aber tats&auml;chlich die H&auml;lfte der Zeit
k&uuml;rzer als behauptet.

<p>
OpenSSH wird Warnungen ausgeben, wenn es solchen Schl&uuml;sseln begegnet.
Um diese Warnungen loszuwerden, passe deine known_hosts Datei an und
ersetze die falsche Schl&uuml;ssell&auml;nge (normalerweise ,1024') mit
der richtigen (normalerweise ,1023').

<h2><a name= "2.7">2.7 - X11 und/oder ,agent forwarding' funktioniert nicht.</a></h2>

<p>
Pr&uuml;fe deine <i>ssh_config</i> und <i>sshd_config</i>. Die
voreingestellten Konfigurationsdateien schalten ,authentication agent' und
,X11 forwarding' ab. F&uuml;ge die Zeilen unten in die <i>sshd_config</i>
ein, um sie zu aktivieren:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>X11Forwarding yes</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
und f&uuml;ge die folgenden Zeilen in die <i>ssh_config</i> ein:

<blockquote>
<table border=0 width="800">
	<tr>
		<td nowrap bgcolor="#EEEEEE">
<b>ForwardAgent yes</b><br>
<b>ForwardX11 yes</b>
		</td>
	</tr>
</table>
</blockquote>

<p>
<b>HINWEIS:</b> Benutzer von Linux Mandrake 7.2: Mandrake modifiziert
die <i>XAUTHORITY</i> Umgebungsvariable in <i>/etc/skel/.bashrc</i>
und damit das ,home directory' jedes Bash-Benutzers. Diese Variable wird
von OpenSSH gesetzt und daher muss f&uuml;r die oben genannten
Optionen die folgende Zeile auskommentiert werden:


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b># export XAUTHORITY=$HOME/.Xauthority</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.8">2.8 - Nach dem Upgrade auf OpenSSH habe ich keine SSH2 Unterst&uuml;tzung mehr.</a></h2>

<p>
Die Dateien <i>sshd_config</i> oder <i>ssh_config</i> k&ouml;nnen von
Version zu Version ver&auml;ndert werden. Du solltest immer nach solchen
&Auml;nderungen Ausschau halten, wenn du auf eine neue Version von OpenSSH
upgradest. Nach OpenSSH 2.3.0 musst du das folgende in deine
<i>sshd_config</i> einf&uuml;gen:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>HostKey /etc/ssh_host_dsa_key</b><br>
<b>HostKey /etc/ssh_host_rsa_key</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.9">2.9 - sftp/scp kann keine Verbindung aufbauen, obwohl ssh funktioniert.</a></h2>

<p>
sftp und/oder scp k&ouml;nnen beim Aufbauen der Verbindung Probleme haben,
wenn du eine Shell Initialisierung (.profile, .bashrc, .chsrc, etc.) hast,
die Ausgaben f&uuml;r nicht-interaktive Sitzungen produziert. Diese Ausgabe
verwirrt den sftp/scp Client. Hiermit kannst du pr&uuml;fen, ob deine
Shell das tut:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>ssh yourhost /usr/bin/true</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Wenn das Kommando oben irgendeine Art von Ausgabe produziert, musst du
deine Shell Initialisierung modifizieren.

<h2><a name="2.10">2.10 - Werdet ihr [foo] zu scp hinzuf&uuml;gen?</a></h2>

<p>
Kurze Antwort: Nein.

<p>
Lange Antwort: scp ist nicht standardisiert. Die Beschreibung, die einer
Spezifikation am n&auml;chsten kommt, ist: "was rcp tut". Da das selbe Kommando
auf beiden Seiten einer Verbindung benutzt wird, bedeutet das Hinzuf&uuml;gen
von Funktionalit&auml;ten oder Optionen das Risiko von Inkompatibilit&auml;ten
mit anderen Implementierungen.

<p>
Neue Funktionalit&auml;ten sind eher in sftp wahrscheinlich, da das Protokoll
standardisiert ist (naja, ein
<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-filexfer-05.txt">
draft standard</a>) und Client sowie Server voneinander getrennt sind.

<h2><a name= "2.11">2.11 - Wie verwende ich ,port forwarding'?</a></h2>

<p>
Wenn sshd(8) auf dem Server auf der Gegenseite l&auml;uft, kann es m&ouml;glich
sein, bestimmte Dienste durch ssh zu ,tunneln'. Das kann w&uuml;nschenswert
sein, um beispielsweise POP und SMTP Verbindungen zu verschl&uuml;sseln,
selbst wenn die Software keine eigene Unterst&uuml;tzung f&uuml;r
verschl&uuml;sselte Verbindungen hat. Das Tunneln verwendet ,port forwarding',
um eine Verbindung zwischen dem Client und dem Server herzustellen. Die Client
Software muss hierf&uuml;r in der Lage sein, auf einen nicht-standardisierten
Port verbinden zu k&ouml;nnen.

<p>
Die Idee dahinter ist, dass der Client sich mit dem entfernten System &uuml;ber
ssh verbindet und angibt, welcher Port auf der Maschine des Clients dazu
verwendet werden soll, Verbindungen zum Server weiterzuleiten. Danach ist es
m&ouml;glich, die Dienste, die verschl&uuml;sselt werden sollen (z.B. fetchmail,
irc), auf dem Client mit der Angabe des gleichen Ports, der an ssh
&uuml;bergeben wurde, zu starten, und die Verbindung wird durch ssh getunnelt.

<p>
Die wichtigsten Optionen zum Tunneln sind die Optionen -L und -R, welche dem
Benutzer das ,port forwarding' erlauben, die -D Option, welche das ,dynamic
port forwarding' erlaubt und die -f Option, welche ssh zuweist, im
Hintergrund weiterzuarbeiten. Siehe weiter unten f&uuml;r mehr Details zu
diesen Optionen.

<p>
Dies ist ein Beispiel f&uuml;r eine getunnelte IRC Sitzung von der Client
Maschine ,127.0.0.1' (localhost) zum entfernten Server ,server.example.com':

<blockquote>
<table border=0 width="800">
	<tr>
		<td nowrap bgcolor="#EEEEEE">
<b>ssh -f -L 1234:server.example.com:6667 server.example.com sleep 10<br>
irc -c '#users' -p 1234 pinky 127.0.0.1</b>
	</td>
	</tr>
</table>
</blockquote>

<p>
Dies tunnelt eine Verbindung zum IRC Server server.example.com und tritt mit
dem Nick ,pinky' dem Channel ,#users' bei. Der lokale Port, der in diesem
Beispiel verwendet wurde, ist 1234. Es tut nichts zur Sache, welcher Port
benutzt wird, so lange er gr&ouml;&szlig;er ist als 1023 (bedenke, nur root
kann Sockets auf privilegierten Ports &ouml;ffnen) und keine St&ouml;rung
mit bereits verwendeten Ports auftritt. Die Verbindung wird zum Port 6667
auf dem entfernten Server weitergeleitet, da das der Standard Port f&uuml;r
IRC Dienste ist.

<p>
Der remote Befehl ,sleep 10' wurde angegeben, um dem Dienst, der getunnelt
werden soll, eine gewisse Zeit (10 Sekunden in diesem Beispiel) zu geben, um
zu starten. Wenn in der angegebenen Zeit keine Verbindung aufgebaut wurde,
wird ssh sich beenden. Falls mehr Zeit ben&ouml;tigt wird, kann der sleep(1)
Wert entsprechend erh&ouml;ht werden, oder alternativ k&ouml;nnte das oben
aufgelistete Beispiel als eine Funktion in die Benutzer Shell eingef&uuml;gt
werden. Siehe ksh(1) und csh(1) f&uuml;r weitere Details &uuml;ber
benutzerdefinierte Funktionen.

<p>
ssh besitzt des weiteren eine -N Option, welche praktisch f&uuml;r ,port
forwarding' ist: Wenn -N &uuml;bergeben wurde, ist es nicht notwendig einen
remote Befehl (,sleep 10' in dem Beispiel oben) anzugeben. Allerdings
f&uuml;hrt die Benutzung dieser Option dazu, dass ssh f&uuml;r immer wartet
(anstatt zu beenden, wenn ein remote Befehl ausgef&uuml;hrt wurde), so dass
der Benutzer darauf achten muss, den Prozess hinterher manuell mit kill(1)
zu beenden.

<h2><a name= "2.12">2.12 - Meine ssh Verbindung friert ein oder steigt nach N
Minuten Inaktivit&auml;t aus.</a></h2>

<p>
Das ist &uuml;blicherweise das Resultat eines Paketfilters oder einem NAT
Ger&auml;t, das die TCP Verbindung wegen Inaktivit&auml;t auslaufen
l&auml;sst. Du kannst <b>ClientAliveInterval</b> in der <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd_config&amp;sektion=5">
sshd_config</a></i> des Servers aktivieren oder <b>ServerAliveInterval</b> in
der <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh_config&amp;sektion=5">
ssh_config</a></i> des Clients erm&ouml;glichen (die letzte Option ist in
OpenSSH 3.8 und neuer verf&uuml;gbar).

<p>
Das Aktivieren einer der beiden Optionen und das Setzen des Intervalls, das
k&uuml;rzer als die ben&ouml;tigte Zeit ist, um die Verbindung auslaufen zu
lassen, sorgen daf&uuml;r, dass die Verbindung in der Verbindungstablle des
Ger&auml;tes ,frisch' gehalten wird.

<h2><a name= "2.13">2.13 - Wie rufe ich scp auf, um eine Datei zu kopieren,
die einen Doppelpunkt beinhaltet?</a></h2>

<b><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">
scp</a></b> interpretiert den Teil vor dem Doppelpunkt als Namen des
entfernten Servers und versucht, eine Verbindung zu diesem aufzubauen. Um
das zu verhindern, greife auf die Datei mit relativer oder absoluter
Pfadangabe zu, z.B.:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ scp ./source:file sshserver:
                </td>
        </tr>
</table>
</blockquote>

<h2><u><a name= "3.0">3.0 - Fragen zum ,portablen OpenSSH'</a></u></h2>

<h2><a name= "3.1">3.1 - Unechte PAM Authentifikations-Meldungen in den Logdateien.</a></h2>

<p>
Die portable Version von OpenSSH generiert unechte misslungene
Authentifikationsmeldungen bei jedem Login, etwa wie:


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
&quot;<b>authentication failure; (uid=0) -&gt; root for sshd service</b>&quot;
                </td>
        </tr>
</table>
</blockquote>

<p>
Diese werden erzeugt, weil OpenSSH zuerst versucht herauszufinden, ob
der Anwender eine Authentifikation zum Login ben&ouml;tigt (leeres Passwort
z.B.). Dummerweise logt PAM alle Authentifikationversuche,
inklusive diesen hier.

<p>
Wenn es dich zu sehr st&ouml;rt, setze
&quot;<b>PermitEmptyPasswords no</b>&quot; in <i>sshd_config</i>. Das
wird die Meldung stilllegen, allerdings auf Kosten dessen, dass es nicht
mehr m&ouml;glich ist, sich in Accounts mit leeren Passw&ouml;rtern
einzuloggen. Das ist im &uuml;brigen bereits der Standard, wenn du die
mitgelieferte <i>sshd_config</i> Datei benutzt.

<h2><a name= "3.2">3.2 - Leere Passw&ouml;rter sind bei der PAM Authentifikation nicht erlaubt.</a></h2>

<p>
Um leere Passw&ouml;rter in einer OpenSSH Version zu erlauben, die mit
PAM erzeugt wurde, musst du das ,nullok-Flag' an das Ende des
Password-Checking Moduls in der <i>/etc/pam.d/sshd</i>
Datei setzen. Zum Beispiel:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
auth required/lib/security/pam_unix.so shadow nodelay nullok
                </td>
        </tr>
</table>
</blockquote>

<p>
Das muss zus&auml;tzlich zum Setzen von
&quot;<b>PermitEmptyPasswords yes</b>&quot; in der
<i>sshd_config</i> Datei geschehen.

<p>
Es gibt einen Fallstrick beim Benutzen leerer Passw&ouml;rter mit PAM
Authentifikation: PAM wird jegliches Passwort erlauben, wenn ein Account
mit einem leeren Passwort authentifiziert wird. Das macht den Check, den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
benutzt, um zu pr&uuml;fen, ob der Account ein Passwort gesetzt hat,
wirklungslos und umgeht ebenso die Policy, die von
<b>PermitEmptyPasswords</b> gesetzt wurde. Aus diesem Grund raten wir
davon ab, die <b>nullok</b> Direktive in deiner PAM Konfigurationsdatei
zu setzen, es sei denn, du willst leere Passw&ouml;rter explizit erlauben.


<h2><a name= "3.3">3.3 - ssh(1) ben&ouml;tigt sehr lange zum Verbinden oder zum Einloggen</a></h2>

<p>
Gro&szlig;e Verz&ouml;gerungen (mehr als 10 Sekunden) werden normalerweise
durch Probleme mit der Namensaufl&ouml;sung verursacht:
<ul>
<li>Einige Versionen der glibc (insbesondere glibc 2.1, die mit Red Hat 6.1
ausgeliefert wurde) k&ouml;nnen einen langen Zeitraum ben&ouml;tigen, um
"IPv6 zu IPv4" Adressen von Dom&auml;nennamen aufzul&ouml;sen. Das kann
umgangen werden, indem die Option <b>AddressFamily inet</b> in der
<i>ssh_config</i> eingetragen wird.</li>

<li>Es k&ouml;nnte ein DNS Aufl&ouml;sungsproblem vorliegen, entweder beim
Client oder beim Server. Du kannst den <code>nslookup</code> Befehl auf dem
Client und dem Server verwenden, um den Namen und die IP Adresse der Gegenseite
aufl&ouml;sen zu lassen. Lasse zus&auml;tzlich den Namen auf dem Server
aufl&ouml;sen, den der Client beim Aufl&ouml;sen der IP-Adresse des Servers
zur&uuml;ckgegeben hat. Du kannst die meisten Lookups server-seitig durch
das Hinzuf&uuml;gen von <b>UseDNS no</b> in <i>sshd_config</i>
deaktiveren.</li>
</ul>

<p>
Verz&ouml;gerungen unter 10 Sekunden k&ouml;nnen andere Ursachen haben.

<ul>

<li>OpenSSH Versionen vor 3.8 hatten eine <i>moduli</i> Datei mit moduli,
die kleiner waren als das, wonach OpenSSH Ausschau hielt, und als Resultat
w&uuml;rde sshd am Ende moduli verwenden, die bedeutlich gr&ouml;&szlig;er
w&auml;ren als die, die angefragt wurden, was auf Kosten der Geschwindigkeit
geschah. Das Ersetzen der <i>moduli</i> Datei wird das Problem l&ouml;sen
(bedenke, dass diese Datei bei einem Upgrade in den meisten F&auml;llen nicht
ausgetauscht wird und daher manuell ersetzt werden muss).</li>

<li>OpenSSH Versionen vor 3.8 hatten einen Fehler in <code>ssh</code>, der
dazu f&uuml;hrte, dass es gr&ouml;&szlig;ere moduli anforderte als erwartet
(was dann, in Kombination mit dem oben genannten Problem, in erheblichen
Geschwindigkeitseinbu&szlig;en endete).
Ein Upgrade des Clients auf Version 3.8 oder h&ouml;her wird das Problem
beheben.</li>

<li>Falls entweder der Server oder der Client keinen Kernel-basierten
Zufallszahlengenerator besitzen (z.B. Solaris &lt; 9, AIX &lt; 5.2, HP-UX
&lt; 11.11) und kein Ersatz verf&uuml;gbar ist (z.B. <a href=
"ftp://ftp.ayamura.org/pub/prngd/">prngd</a>), ist es m&ouml;glich, dass ein
Programm, das von <code>ssh-rand-helper</code> zum Generieren vom Entropy
aufgerufen wird, h&auml;ngt. Das kann ermittelt werden, indem es im Debug
Modus ausgef&uuml;hrt wird:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
/usr/local/libexec/ssh-rand-helper -vvv
                </td>
        </tr>
</table>
</blockquote>

Alle beachtlichen Verz&ouml;gerungen sollten untersucht und behoben,
oder aber die entsprechenden Befehle aus <i>ssh_prng_cmds</i> entfernt
werden.
</li>

</ul>

<h3>Wie langsam ist "langsam"?</h3>
Unter normalen Umst&auml;nden ist die Geschwindigkeit des SSH Logins
abh&auml;ngig von der CPU Leistung des Clients und Servers. Zum Vergleich
folgen typische Verbindungszeiten f&uuml;r <code>time ssh localhost
true</code> mit einem 1024-Bit RSA Schl&uuml;ssel auf einem ansonsten
ungenutzten System. OpenSSH und OpenSSL wurden mit gcc 3.3.x compiliert.

<p>
<table>
<tr><th>CPU</th><th>Zeit (SSHv1)<a href="#3.3fn1">[1]</a></th>
	<th>Zeit (SSHv2)</th></tr>
<tr><td>170MHz SPARC/sun4m</td><td>0.74 Sek</td><td>1.25 Sek</td></tr>
<tr><td>236MHz HPPA/8200<a href="#3.3fn2">[2]</a></td><td>0.44 Sek</td>
	<td>0.79 Sek</td></tr>
<tr><td>375MHz PowerPC/604e</td><td>0.38 Sek</td><td>0.51 Sek</td></tr>
<tr><td>933MHz VIA Ezra</td><td>0.34 Sek</td><td>0.44 Sek</td></tr>
<tr><td>2.1GHz Athlon 2600</td><td>0.14 Sek</td><td>0.22 Sek</td></tr>
</table>

<br>

<a name="3.3fn1">[1]</a> Das SSHv1 Protokoll ist zwar schneller, aber
kryptographisch schw&auml;cher als SSHv2.<br>

<a name="3.3fn2">[2]</a> Zu dem Zeitpunkt des Schreibens generiert gcc relativ
langsamen Code auf HPPA f&uuml;r RSA und Diffie-Hellman Operationen (siehe
<a href= "http://gcc.gnu.org/bugzilla/show_bug.cgi?id=7625">gcc bug #7625</a>
und <a
href="http://marc.theaimsgroup.com/?l=openssh-unix-dev&m=102646106016694">
Diskussion auf openssh-unix-dev</a>).

<h2><a name= "3.4">3.4 - "Can't locate module net-pf-10" Meldungen im Log unter Linux.</a></h2>

<p>
Der Linux Kernel sucht (via modprobe) nach der Protokollfamilie 10 (IPv6).
Lade entweder das passende Kernelmodul, gib den korrekten Alias in
<i>/etc/modules.conf</i> an oder schalte IPv6 in <i>/etc/modules.conf</i> ab.


<p>
Aus irgendeinem bl&ouml;dsinnigen Grund kann
<i>/etc/modules.conf</i> auch <i>/etc/conf.modules</i> hei&szlig;en.


<h2><a name= "3.5">3.5 - Passwort Authentifikation funktioniert nicht unter Slackware 7.0 oder Red Hat 6.x</a></h2>

<p>
F&uuml; Slackware 7.0 musst du OpenSSH mit der libcrypt verlinken.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
LIBS=-lcrypt ./configure [Optionen]
                </td>
        </tr>
</table>
</blockquote>

<p> Einige Versionen von Red Hat haben Passwort-Tools, die zwar MD5-style
Passw&ouml;rter erstellen, die von der crypt() Funktion des Systems jedoch
nicht verstanden werden. Wenn Passwort Authentifikation f&uuml;r neue
Accounts oder Accounts mit Passw&ouml;rtern, die vor kurzem ge&auml;ndert
worden sind, fehlschlagen, es aber mit alten Accounts funktioniert, ist
das sehr wahrscheinlich der Grund. (Betroffene Accounts haben
Passwort-Zeichenketten in <i>/etc/shadow</i>, die mit <code>$1$</code>
beginnen).

<p>
Um das Problem zu behebnen, aktiviere MD5 Unterst&uuml;tzung in sshd
w&auml;hrend der Entwicklungsphase, um das Problem zu beheben:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
./configure --with-md5-passwords [Optionen]
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "3.6">3.6 - Configure oder sshd(8) beschweren sich &uuml;ber fehlende RSA oder DSA Unterst&uuml;tzung</a></h2>

<p>
Stelle sicher, dass deine OpenSSL Bibliotheken mit eingebauter RSA oder DSA
Unterst&uuml;tzung erzeugt wurden, entweder intern oder durch RSAref.


<h2><a name= "3.7">3.7 - "scp: command not found" Fehler</a></h2>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a>
muss sich im Standard PATH sowohl auf dem Client als auch auf dem Server
befinden. M&ouml;glicherweise musst du die <b>--with-default-path</b>
Option angeben, um einen angepassten Pfad f&uuml;r die Suche auf dem
Server angeben zu k&ouml;nnen. Diese Option ersetzt den Standardpfad, so dass
du sowohl alle bisherigen Verzeichnisse in deinem Pfad angeben musst als auch
das Verzeichnis, in dem scp installiert ist. Zum Beispiel:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>./configure --with-default-path=/bin:/usr/bin:/usr/local/bin:/path/to/scp</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Bedenke, dass die Konfiguration des Administrators des Servers Vorrang
gegen&uuml;ber der Option <b>--with-default-path</b> hat. Das beinhaltet
das R&uuml;cksetzen von PATH in /etc/profile, PATH in <i>/etc/environment</i>
unter AIX oder (f&uuml;r 3.7p1 und h&ouml;her) das Setzen von PATH oder
SUPATH in <i>/etc/default/login</i> unter Solaris oder Reliant Unix.

<h2><a name= "3.8">3.8 - Kann die Passphrase nicht lesen</a></h2>

<p>
Einige Betriebssysteme setzen <i>/dev/tty</i> mit falschen Modes, was
zum Fehler beim Lesen von Passw&ouml;rtern mit folgender Fehlermeldung
f&uuml;hrt:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
You have no controlling tty.  Cannot read passphrase.
                </td>
        </tr>
</table>
</blockquote>

<p>
Die L&ouml;sung hierzu ist, die Berechtigungen von <i>/dev/tty</i> auf 0666 zu
setzen und dann das ganze deinem Betriebssystem-Hersteller als Bug zu melden.


<h2><a name= "3.9">3.9 - ,configure' fehlt oder make versagt</a></h2>

<p>
Wenn es keine ,configure' Datei in deiner tar.gz Datei gibt, die du
heruntergeladen hast, oder make mit einem "missing seperator" Fehler
versagt, hast du vermutlich die OpenBSD Distribution heruntergeladen
und versuchst, sie auf einer anderen Plattform zu kompilieren.
Bitte verwende die <a href="portable.html">portable version</a>.


<h2><a name= "3.10">3.10 - H&auml;ngt beim Verlassen von ssh</a></h2>

<p>
OpenSSH kann beim Beenden h&auml;ngen bleiben. Das kann passieren, wenn
es einen aktiven Hintergrundprozess gibt. Linux und HP-UX sind
hierf&uuml;r bekannt. Das Problem kann hiermit verifiziert werden:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>sleep 20 & exit</b>
                </td>
        </tr>
</table>
</blockquote>

Versuche stattdessen das hier zu benutzen:
<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>sleep 20 < /dev/null > /dev/null 2>&1 &</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Ein Umgehen des Problems f&uuml;r bash Anwender ist mittels eines
Einf&uuml;gens von <b>"shopt -s huponexit"</b> in entweder /etc/bashrc oder
~/.bashrc m&ouml;glich. Ansonsten konsultiere die man page deiner Shell um
eine Option zu finden, mit der man aktiven Jobs ein HUP Signal senden kann,
wenn man sie verl&auml;sst. Siehe <a
href="http://bugzilla.mindrot.org/show_bug.cgi?id=52">bug #52</a>
f&uuml;r andere M&ouml;glichkeiten, das Problem umgehen zu k&ouml;nnen.

<h2><a name= "3.11">3.11 - Wieso h&auml;ngt ssh beim Beenden?</a></h2>

<p>
Beim Ausf&uuml;hren von
<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>ssh host command</b>
                </td>
        </tr>
</table>
</blockquote>
<b>muss</b> ssh h&auml;ngenbleiben, da es zu warten hat
<ul>
<li>
bis es sicherstellen kann, dass <code>command</code> keine weiteren
Eingaben ben&ouml;tigt.
<li>
bis es sicherstellen kann, dass <code>command</code> keine weitere
Ausgaben zur&uuml;ckgibt.
<li>
bis <code>command</code> beendet ist, da der sshd den Exit-Status
von <code>command</code> an ssh weitergeben muss.
</ul>
<p>

<h2><a name= "3.12">3.12 - Ich habe ein Upgrade auf OpenSSH 3.1
durchgef&uuml;hrt und dann ging ,X11 forwarding' nicht mehr.</a></h2>

Beginnend mit OpenSSH 3.1 lauscht der sshd ,X11 forwarding' Server
standardm&auml;&szlig;ig auf localhost; siehe auch die sshd
<b>X11UseLocalhost</b> Option um zum vorherigen Verhalten
zur&uuml;ckzukehren, wenn deine &auml;lteren X11 Clients nicht mit dieser
Konfiguration funktionieren.<p>

Im Allgemeinen sollten X11 Clients, die X11 R6 benutzen, mit dieser
Einstellung funktionieren. Einige Hersteller, einschlie&szlig;lich HP, setzen
X11 Clients mit R6 und R5 libs ein, so dass einige Clients funktionieren
und andere nicht.
Das gilt z.B. f&uuml;r HP-UX 11.X.<p>

<h2><a name= "3.13">3.13 - Ich habe ein Upgrade auf OpenSSH 3.8
durchgef&uuml;hrt und dann gingen einige X11 Programme nicht
mehr.</a></h2>

<p>
Wie in den <a href="../txt/release-3.8">3.8 release notes</a> dokumentiert
worden ist, wird <code>ssh</code> standardm&auml;&szlig;ig ,untrusted X11
cookies' benutzen. Das vorherige Verhalten kann durch das Setzen von
<b>ForwardX11Trusted yes</b> in <i>sshd_config</i> wiederhergestellt werden.

<p>
M&ouml;gliche Symptome beinhalten:<br>
<code>BadWindow (invalid Window parameter)<br>
BadAccess (attempt to access private resource denied)<br>
X Error of failed request:  BadAtom (invalid Atom parameter)<br>
Major opcode of failed request:  20 (X_GetProperty)<br></code>

<h2><a name= "3.14">3.14 - Ich habe meinen &ouml;ffentlichen Schl&uuml;ssel
in authorized_keys kopiert, aber public-key Authentifizierung funktioniert
immernoch nicht.</a></h2>

<p>
Typischerweise wird das durch die Dateirechte von $HOME,
$HOME/.ssh oder $HOME/.ssh/authorized_keys hervorgerufen, die mehr erlauben
als sshd standardm&auml;&szlig;ig zul&auml;sst.

<p>
In diesem Falle kann es behoben werden, indem folgendes auf dem Server
ausgef&uuml;hrt wird.
<blockquote>
<table border=0 width="800">
<tr>
  <td nowrap bgcolor="#EEEEEE">
$ <b>chmod go-w $HOME $HOME/.ssh</b><br>
$ <b>chmod 600 $HOME/.ssh/authorized_keys</b>
  </td>
</tr>
</table>
</blockquote>

<p>
Falls das aus irgendeinem Grund nicht m&ouml;glich sein sollte, besteht die
Alternative darin, <b>StrictModes no</b> in <i>sshd_config</i> zu setzen,
jedoch wird das nicht empfohlen.

<hr>
<a href="index.html"><img height=24 width=24 src="../back.gif" border=0 alt=OpenSSH></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq.html,v 1.88 ]
<br>
$Translation: faq.html,v 1.46 2004/09/23 12:55:06 jufi Exp $
<br>
</small>
<small>$OpenBSD: faq.html,v 1.45 2004/09/23 14:19:34 jufi Exp $</small>
</body>
</html>
