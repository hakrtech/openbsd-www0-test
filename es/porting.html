<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="resource-type" content="document">
<meta name="description" CONTENT="How to make an OpenBSD port">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1997-1999 by the OpenBSD project">
<title>Crear un Porte para OpenBSD</title>
<link rev="made" href="mailto:www@openbsd.org">
</head>

<body text="#000000" bgcolor="#FFFFFF" link="#23238E">

<img height="30" width="141" src="../images/smalltitle.gif" alt="[OpenBSD]" >

<h2><font color="#e00000">Crear un Porte para OpenBSD</font></h2>

Suponiendo que ya haya compilado su programa favorito en su sistema OpenBSD y
quiera compartir su esfuerzo convirtiéndolo en un porte.  ¿Cómo hacerlo?

<p>
La cosa más importante que puede hacer es <strong>comunicarlo</strong>.
Pregunte en <a href="mailto:ports@openbsd.org">ports@openbsd.org</a> si
alguien ya está trabajando en lo mismo.
<em>Comuníqueselo al autor original del programa</em>, e incluya los
problemas que pueda encontrar.
Si aparece algún error en la información sobre la licencia hágaselo saber.
Si tuvo que evitar bucles para crear el porte, dígale qué es lo que debe
solucionar.
Si sólo están desarrollando para Linux y da la impresión de que les trae sin
cuidado el resto del mundo Unix, intente hacer que cambien de opinión.

<p>
La <strong>COMUNICACIÓN</strong> es lo que marca la diferencia entre un porte
con éxito y un porte que tarde o temprano será abandonado por todos.

<p>
Antes que nada eche una hojeada a la información sobre portes en esta página
y luego lea los documentos a los que se hace referencia, especialmente a la
<a href="../checklist.html">lista de comprobación</a> de portes de OpenBSD.

<p>
¡Haga pruebas una y otra vez, y finalmente vuelva a repasarlas!

<p>
Envíe el porte.  Haga un archivo comprimido con tar y gzip del directorio del
porte.
Lo puede poner en un servidor público de FTP o HTTP y enviar la dirección de
éste a <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>, o enviarlo
directamente a esta dirección con codificado MIME.
Elija el método que más le convenga.

<p>
<h3><font color="#0000e0">Información Disponible sobre Cómo Portar</font></h3>

<ul>
<li>El fichero <code>/usr/share/mk/bsd.port.mk</code> es el makefile del
    sistema de portes que se incluye al final del makefile de cada porte
    individual.
    Lea los comentarios que encontrará al principio del makefile.
    Describen muy bien las opciones para make.

<li>La documentación 
    <a href="http://www.netbsd.org/Documentation/software/packages.html">NetBSD
    Package System</a> describe la versión de NetBSD del sistema de portes de
    FreeBSD, y es muy útil.

<li>La sección 19.2.5 de la 
    <a href="http://www.freebsd.org/handbook/porting.html">Guía de
    FreeBSD</a>.  Es la biblia para los portes en FreeBSD.

<li>La <a href="../checklist.html">lista de comprobación</a> de portes de
    OpenBSD.

<li><a href="audio-port.html">Portar aplicaciones de audio a OpenBSD</a>.

<li>La lista de correos para los portes de OpenBSD 
    <a href="mailto:ports@openbsd.org">ports@OpenBSD.org</a>.
</ul>

<p>
<h3><font color="#0000e0">Política sobre Portes de OpenBSD</font></h3>

<ul>
<li>Debido a que <code>/usr/local</code> es un sistema de archivos con
    frecuencia compartido entre varias máquinas mediante NFS, OpenBSD NO usa
    <code>/usr/local/etc/rc.d</code>.
    Por este motivo los ficheros de configuración específicos de cada máquina
    no se pueden guardar en <code>/usr/local</code>, y por tanto
    <code>/etc</code> es el repositorio central para los ficheros de
    configuración específicos de cada máquina.
    Más aún, la política de OpenBSD es la de no actualizar nunca de forma
    automática los ficheros en <code>/etc</code>.
    Los portes que necesitan algún tipo de configuración de arranque deben
    avisar al administrador del sistema de lo que debe hacer en lugar de
    instalar ficheros a ciegas.

<li>Las páginas de manual en OpenBSD NO están comprimidas.

<li>OpenBSD NO requiere <code>-lcrypt</code>.
    <br>
    El cifrado con DES es parte del <code>libc</code> típico.

<li>OpenBSD tiene una fuerte orientación hacia la seguridad.
    Se aconseja leer y comprender la <a href="#security">sección de
    seguridad</a> en esta página.

<li>Asegúrese de que añade la marca de CVS <code>&#36;OpenBSD&#36;</code> al
    fichero de Makefile.
    Si importa un porte desde otro sistema, asegúrese de que también conserva
    la marca en el fichero Makefile.
    En el caso de que el porte se haga desde FreeBSD substituya la marca de
    FreeBSD <code>&#36;Id&#36;</code> por la marca
    <code>&#36;FreeBSD&#36;</code>.

<li>El objetivo a alcanzar es que todas las aplicaciones portadas tengan
    soporte en OpenBSD.
    Para conseguirlo <strong>debe</strong> informar ampliamente sobre
    cualquier parche para OpenBSD al mantenedor de la aplicación.
</ul>

<p>
<a name="security"></a>
<h3><font color="#0000e0">Recomendaciones de Seguridad</font></h3>

Existen muchos problemas de seguridad que nos deben preocupar.
Si no se está absolutamente seguro de lo que se está haciendo, por favor pida
ayuda a la lista de correo de <a href="mailto:ports@openbsd.org">portes</a>.

<ul>
<li><em>NO</em> use código en estado alpha o beta cuando esté creando un
    porte.
    Use la revisión o versión más actual.

<li>Cualquier programa que vaya a ser instalado como servidor debería ser
    escaneado en busca de desbordamientos en la memoria intermedia,
    especialmente en el caso de utilización insegura de
    <code>strcat/strcpy/strcmp/sprintf</code>.
    En general, <code>sprintf</code> se debe substituir con
    <code>snprintf</code>.

<li>No use nunca nombres de ficheros en lugar de seguridad real.
    Existen numerosas condiciones de carrera para las que no se tiene un
    debido control.
    Por ejemplo, un atacante que ya haya obtenido privilegios de usuario en
    sus máquinas puede substituir ficheros en <code>/tmp</code> con enlaces
    simbólicos a ficheros más estratégicos, como
    <code>/etc/master.passwd</code>.

<li>Por ejemplo, tanto <code>fopen</code> como <code>freopen</code>
    <strong>generan un nuevo fichero o abren ficheros ya existentes</strong>
    para escritura.
    Un atacante puede crear un enlace simbólico desde
    <code>/etc/master.passwd</code> a <code>/tmp/addrpool_dump</code>.
    En cuanto Vd. lo abra, el fichero de su contraseña será filtrado.
    Sí, incluso con un <code>unlink</code> antes, que tan sólo minimizaría el
    riesgo.
    Use <code>open</code> con <code>O_CREATIO_EXCL</code> y
    <code>fdopen</code> en lugar de lo anterior.

<li>Otro problema muy común es el de la función <code>mktemp</code>.
    Haga caso a los avisos del enlazador de bsd sobre su uso.
    <strong>Se deben solucionar</strong>.
    Esto no es tan sencillo como <code>s/mktemp/mkstemp/g</code>.
    <br>
    Para más indicaciones sobre este respecto vaya a la página de manual de
    <code>mktemp(3)</code> en OpenBSD current.
    Un código correcto que use <code>mkstemp</code> puede ser el de los 
    fuentes de <code>ed</code> o <code>mail</code>.
    Se puede encontra un tipo poco usual de código que use correctamente 
    <code>mktemp</code> en el porte <code>rsync</code>.

<li>Que lo pueda leer no implica que lo deba leer.
    Un agujero muy conocido de esta naturaleza era el del problema con
    <code>startx</code>.
    Al ser un programa setuid, se podía ejecutar con cualquier fichero como
    guión (script).
    Si el fichero no era un guión válido de la shell, le seguía un mensaje de
    error junto con la primera línea de error del fichero, sin comprobar más
    permisos.
    Considerando que los ficheros shadow passwd a menudo comienzan con una
    entrada de root, obtener esta primera línea era bastante útil para un
    atacante.
    No abra un fichero y a continuación ejecute <code>fstat</code> en el
    descriptor abierto para comprobar lo podría haber abierto (o el atacante
    jugará con <code>/dev/rst0</code> y rebobinará su cinta);  ábralo con el
    correcto uid/gid/grouplist.

<li>No use nada que cree un proceso hijo de una shell en programas setuid 
    antes de haber eliminado sus privilegios.
    Esto incluye <code>popen</code> y <code>system</code>.
    En su lugar use <code>fork</code>, <code>pipe</code> y
    <code>execve</code>.

<li>Pase descriptores abiertos en lugar de nombres de archivos a otros
    programas para evitar condiciones de carrera.
    Aun en el caso de que un programa no acepte descriptores de ficheros,
    puede usar <code>/dev/fd/0</code>.

<li>Los derechos de acceso van adjuntos a los descriptores de ficheros.
    Si necesita derechos setuid para abrir un fichero, abra ese fichero y
    elimine sus privilegios.
    Esto es un arma de doble filo:  incluso después de haber eliminado sus
    privilegios, debería observar esos descriptores.

<li>Evite root setuid siempre que pueda.
    En principio puede hacer cualquier cosa, pero los derechos de root se
    necesitan en raras ocasiones, tal vez excepto para crear portes de
    &quot;socket&quot; con un número por debajo de 1024.
    En este caso tal vez sea mejor controlarlo con <code>inetd</code> y
    simplemente añadir las entradas relevantes a <code>inetd.conf</code>.
    Debe conocer el &quot;magic&quot; apropiado requerido para poder 
    codificar &quot;d&aelig;mons&quot;.
    Se podría decir que no se tienen programas setuid comerciales si no se
    sabes cómo hacer eso.

<li>Use setgid en lugar de setuid.
    Aparte de los ficheros específicos que necesitan los programas setgid, la
    mayoría de ficheros no tienen permisos de escritura para grupo.
    Por tanto, un problema de seguridad en un programa setgid no comprometerá
    tanto su sistema;  con sólo derechos de grupo, lo peor que podrá hacer un
    atacante es cambiar la tabla de puntuación de un juego o algo parecido.
    Vea el porte <code>xkobo</code> como un ejemplo de un cambio de este
    tipo.

<li>No confíe en ficheros con permisos de escritura para grupo.
    Aunque hayan pasado una auditoría, los programas setgid no se perciben
    como un agujero de seguridad en potencia.
    Por lo tanto, cualquier cosa que pueda ser falsificada no debería ser
    considerarada como información reservada.

<li>¡No confíe en su entorno!
    Esto incluye cosas tan sencillas como su <code>PATH</code> (nunca use
    <code>system</code> con un nombre no cualificado y evite
    <code>execvp</code>), pero tampoco de entornos menos obvios como su
    <code>locale</code>, <code>timezone</code>, <code>termcap</code> y otros.
    <strong>Nunca</strong> use <code>system</code> en programas
    privilegiados;  en su lugar cree su propia orden de línea, un entorno
    controlado, y una llamada directa a <code>execve</code>.
    La página de manual de <code>perlsec</code> es una buena tutorial sobre
    estos problemas.

<li>Nunca use guiones de shell setuid.
    Éstos son inseguros por definición.
    Envuélvalos dentro de código C que asegure un entorno apropiado.
    Por otra parte, las características de OpenBSD incluyen guiones de perl
    seguros.

<li>Tenga cuidado con el cargador dinámico.
    Si está ejecutando setuid sólo ejecutará bibliotecas que hayan sido
    escaneadas con <code>ldconfig</code>.
    Setgid no basta.

<li>Las bibliotecas dinámicas son complicadas.
    El código C++ presenta un problema parecido.
    Básicamente, las bibliotecas pueden tomar alguna acción basándose en su
    entorno antes incluso de que su programa principal haya podido comprobar
    su estado setuid.
    OpenBSD <code>issetugid</code> trata este problema desde el punto de
    vista del escritor de bibliotecas.
    No intente portar bibliotecas a menos que conozca este tema a la
    perfección.
</ul>

<p>
<h3><font color="#0000e0">Ayudas Generales para Portar</font></h3>

<ul>
<li><code>__OpenBSD__</code> se debería usar con cuentagotas o nada.
    Construcciones como
    
    <pre>
        #if defined(__NetBSD__) || defined(__FreeBSD__)
    </pre>
    
    son a menudo inapropiadas.
    No añada <code>__OpenBSD__</code> a éstas a ciegas.
    En lugar de esto, intente imaginar qué es lo que está ocurriendo y qué es
    lo que se necesita.
    Las páginas de manual son de gran utilidad para estos casos, ya que
    incluyen comentarios de tipo historial en los que se menciona cuándo una
    característica particular se integró en <code>BSD</code>.
    Verificar el valor numérico de <code>BSD</code> contra el de las
    versiones conocidas es por lo general la forma correcta de hacerlo.  Vea 
    <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/Packages.txt">the
    NetBSD package guide</a> para obtener más información al respecto.

<li>Definir <code>BSD</code> no es una buena idea, al contrario.
    Intente incluir <code>sys/parm.h</code>.
    Esto no sólo define <code>BSD</code>, sino que también le da un valor
    apropiado.
    El fragmento de código correcto debería ser así:
    
    <pre>
        #if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
        #include &lt;sys/param.h&gt;
	#endif
    </pre>
    
<li>Base sus comprobaciones en las características, no en sistemas operativos
    específicos.
    A la larga es mucho mejor comprobar si <code>tcgetattr</code> funciona
    que si está funcionando en BSD 4.3 o posterior, o en SystemVR4.
    Este tipo de pruebas sólo confunden.
    La manera de hacerlas es, por ejemplo, comprobándolo para un sistema en
    particular, configurar los &quot;define&quot; <code>HAVE_TCGETATTR</code>, 
    y a continuación proceder con el sistema siguiente.
    Esta técnica separa las comprobaciones de características de los sistemas
    operativos específicos.
    De forma rápida, otro portado puede así simplemente añadir todas los
    &quot;define&quot; <code>-DHAVE_XXX</code> al fichero Makefile.
    También es posible escribirlo o añadirlo a un guión de configuración para
    comprobar esa caracterítica y añadirla de modo automático.
    Como un ejemplo de lo que no se debe hacer, compruebe los fuentes de
    nethack 3.2.2:  asume un montón de cosas basadas en el tipo del sistema.
    La mayoría de éstas están obsoletas y ya no reflejan la realidad:  las
    funciones POSIX son más útiles que las viejas diferencias entre BSD y
    SystemV, hasta el punto que algunas funciones bsd tradicionales sólo
    conservan el soporte mediante bibliotecas de compatibilidad.

<li>Evite incluir ficheros que incluyan otras inclusiones que... Primero,
    porque no es eficiente.
    Su proyecto acabará incluyendo un fichero que incluya todo.
    También, porque hace que algunos problemas sean difíciles de solucionar.
    Se hace más difícil <em>no</em> incluir un fichero particular en un
    momento dado.

<li>Evite macros estrafalarias.
    No definir una macro que fue definida por un fichero de cabecera es una
    mala idea.
    Definir macros para obtener un comportamiento específico de un fichero
    include también es una mala idea:  los modos de compilación deberían ser
    globales.
    Si quiere obtener un comportamiento POSIX dígalo, y añada <code>#define
    POSIX_C_SOURCE</code> en todo el proyecto, no sólo cuando lo crea
    conveniente.

<li>Nunca escriba prototipos de funciones de sistema.
    Todos los sistemas modernos, incluido OpenBSD, tienen una localización
    típica para estos prototipos.  Dichas localizaciones es probable que sean
    <code>unistd.h</code>, <code>fcntl.h</code>, o <code>termios.h</code>
    entre otras.
    La página de manual suele indicar dónde se puede encontrar el prototipo.
    Es posible que necesite otras cuantas macros de <code>HAVE_XXX</code>
    para conseguir el fichero correcto.
    No se preocupe por incluir el mismo fichero dos veces, los ficheros
    include tienen métodos de prevención contra esto.
    <br>
    Si algún sistema estropeado necesita que escriba el prototipo. no lo
    imponga en otros sistemas.
    El uso de prototipos propios no funcionará porque pueden usar tipos que
    son equivalentes en su sistema, pero no son portables a otros sistemas
    (<code>unsigned long</code> en lugar de <code>size_t</code>), o
    resultarán en estados incorrectos de <code>const</code>.
    Además, algunos compiladores como el gcc propio de OpenBSD, pueden hacer
    un trabajo mejor como algunas funciones muy frecuentes como
    <code>strlen</code> si incluye el fichero de cabecera correcto.

<li>No use el nombre de una función de sistema estándar para nada más.
    si quiere escribir su propia función, déle su propio nombre, y llame a
    esa función en todas partes.
    Si desea volver a la función de sistema por definición, sólo tiene que
    comentar su código y definir su propio nombre en la función del sistema.
    No lo haga de otro modo.
    El código debería ser del siguiente modo

<pre>
       /* prototype part */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf);
       #else
       /* include correct file */
       #include &lt;stdlib.h&gt;
       /* use system function */
       #define foo_gcvt  gcvt
       #endif

       /* definition part */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf)
          {
          /* proper definition */
          }

       /* typical use */
       s = foo_gcvt(n, 15, b);
       </pre>

</ul>

<p>
<h3><font color="#0000e0">Otras Ayudas</font></h3>

<ul>
<li>Las versiones recientes de <code>bsd.port.mk</code> definen el camino de
    los instaladores.
    En particular, definen que se busque en <code>/usr/bin</code> y
    <code>/bin</code> <em>antes que</em> <code>/usr/local/bin</code> y
    <code>/usr/X11R6/bin</code>.

<li><em>NO</em> genere bibliotecas compartidas si se encuentra definido
    <code>${NO_SHARED_LIBS}</code> (cuidado, sólo se puede definir después de
    incluir <code>bsd.port.mk</code>).
    Si su porte tiene un GNU configure, añada la línea <code>CONFIGURE_ARGS
    += ${CONFIGURE_SHARED}</code> al fichero Makefile.

<li>Si se apoya en una función que apareció en una versión reciente de
    <code>bsd.port.mk</code> no olvide añadir una línea <code>NEED_VERSION =
    x.yy</code> en el fichero Makefile.

<li>En OpenBSD <code>curses.h/libcurses/libtermlib</code> es el &laquo;nuevo
    curses&raquo;.  Cambie lo siguiente:<br>
    <code>ncurses.h ==&gt; curses.h</code><br>
    <code>-lncurses ==&gt; -lcurses</code><br>
    Se puede disponer del &laquo;viejo (BSD) curses&raquo; definiendo
    <code>_USE_OLD_CURSES_</code> antes de incluir <code>curses.h</code> (por
    lo general en un fichero Makefile) y enlazándolo con
    <code>-locurses</code>.

<li>En OpenBSD el terminal se ha actualizado del viejo <code>sgtty</code> de
    BSD al nuevo <code>tcgetattr</code> de POSIX.
    Evite el viejo estilo en código nuevo.
    Algo de código es posible que defina <code>tcgetattr</code> como sinónimo
    del viejo <code>sgtty</code>, pero esto es como mucho una medida
    temporal en OpenBSD.
    El código fuente de <code>xterm</code> es un buen ejemplo de lo que no
    hay que hacer.
    Intente obtener la funcionalidad de su sistema correctamente:  lo que
    quiere es un tipo que recuerde el estado de su terminal (probablemente
    typedef), una función que extraiga el estado actual, y una función que
    configure un nuevo estado.
    Las funciones que modifican este estado son más difíciles, ya que tienden
    a variar según el sistema.
    Tampoco olvide que tendrá que manejar casos en los que no esté conectado
    a un terminal, y que necesita poder manejar señales:  no sólo de
    terminación, sin también de fondo (<code>SIGTSTP</code>).
    Debería dejar siempre el terminal en un buen estado.
    Lleve a cabo verificaciones en shells más viejas como sh, que no
    reconfiguren el terminal de ningún modo al terminar un programa.

<li>Los termcap/terminfo y curses más modernos, como los que se incluyen con
    OpenBSD, incluyen secuencias típicas para el control de terminales de
    color.
    Si es posible debería usar éstas, volviendo a las secuencias de color
    típicas de ANSI en otros sistemas.
    Sin embargo, las descripciones de algunos terminales todavía no se han
    actualizado, y es posible que necesite poder especificar estas secuencias
    de modo manual.
    Éste es el modo en que lo hace vim.
    Esto no es estrictamente necesario.
    Excepto en casos de programas privilegiados, por lo general es posible
    anular una definición termcap mediante la variable <code>TERMCAP</code> y
    hacer que funcione correctamente.

<li>La semántica de señales es complicada, y varía de un sistema a otro.
    Use <code>sigaction</code> para asegurarse semánticas específicas, junto
    con otras llmadas al sistema cuya referencia puede encontrar en las
    páginas de manual.

</ul>

<hr>
<a href="index.html"><img height="24" width="24" src="../back.gif" border="0" alt="OpenBSD"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: porting.html,v 1.28 2000/03/25 02:29:50 wvdputte Exp ]<br>
$Translation: porting.html,v 1.3 2000/04/03 22:50:55 horacio Exp $<br>
$OpenBSD: porting.html,v 1.2 2000/04/05 21:00:52 wvdputte Exp $
</small>
</body>
</html>
